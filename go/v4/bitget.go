package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitget struct {
	Exchange
}

func NewBitgetCore() *bitget {
	p := &bitget{}
	setDefaults(p)
	return p
}

func (this *bitget) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bitget",
		"name":      "Bitget",
		"countries": []interface{}{"SG"},
		"version":   "v2",
		"rateLimit": 50,
		"certified": true,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               true,
			"swap":                                 true,
			"future":                               true,
			"option":                               false,
			"addMargin":                            true,
			"borrowCrossMargin":                    true,
			"borrowIsolatedMargin":                 true,
			"cancelAllOrders":                      true,
			"cancelOrder":                          true,
			"cancelOrders":                         true,
			"closeAllPositions":                    true,
			"closePosition":                        true,
			"createConvertTrade":                   true,
			"createDepositAddress":                 false,
			"createMarketBuyOrderWithCost":         true,
			"createMarketOrderWithCost":            false,
			"createMarketSellOrderWithCost":        false,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createPostOnlyOrder":                  true,
			"createReduceOnlyOrder":                false,
			"createStopLimitOrder":                 true,
			"createStopLossOrder":                  true,
			"createStopMarketOrder":                true,
			"createStopOrder":                      true,
			"createTakeProfitOrder":                true,
			"createTrailingAmountOrder":            false,
			"createTrailingPercentOrder":           true,
			"createTriggerOrder":                   true,
			"editOrder":                            true,
			"fetchAccounts":                        false,
			"fetchBalance":                         true,
			"fetchBorrowInterest":                  true,
			"fetchBorrowRateHistories":             false,
			"fetchBorrowRateHistory":               false,
			"fetchCanceledAndClosedOrders":         true,
			"fetchCanceledOrders":                  true,
			"fetchClosedOrders":                    true,
			"fetchConvertCurrencies":               true,
			"fetchConvertQuote":                    true,
			"fetchConvertTrade":                    false,
			"fetchConvertTradeHistory":             true,
			"fetchCrossBorrowRate":                 true,
			"fetchCrossBorrowRates":                false,
			"fetchCurrencies":                      true,
			"fetchDeposit":                         false,
			"fetchDepositAddress":                  true,
			"fetchDepositAddresses":                false,
			"fetchDepositAddressesByNetwork":       false,
			"fetchDeposits":                        true,
			"fetchDepositsWithdrawals":             false,
			"fetchDepositWithdrawFee":              "emulated",
			"fetchDepositWithdrawFees":             true,
			"fetchFundingHistory":                  true,
			"fetchFundingInterval":                 true,
			"fetchFundingIntervals":                false,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    true,
			"fetchIndexOHLCV":                      true,
			"fetchIsolatedBorrowRate":              true,
			"fetchIsolatedBorrowRates":             false,
			"fetchLedger":                          true,
			"fetchLeverage":                        true,
			"fetchLeverageTiers":                   false,
			"fetchLiquidations":                    false,
			"fetchLongShortRatio":                  false,
			"fetchLongShortRatioHistory":           true,
			"fetchMarginAdjustmentHistory":         false,
			"fetchMarginMode":                      true,
			"fetchMarketLeverageTiers":             true,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       true,
			"fetchMarkPrice":                       true,
			"fetchMyLiquidations":                  true,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    true,
			"fetchOpenInterestHistory":             false,
			"fetchOpenOrders":                      true,
			"fetchOrder":                           true,
			"fetchOrderBook":                       true,
			"fetchOrderBooks":                      false,
			"fetchOrders":                          false,
			"fetchOrderTrades":                     false,
			"fetchPosition":                        true,
			"fetchPositionHistory":                 "emulated",
			"fetchPositionMode":                    false,
			"fetchPositions":                       true,
			"fetchPositionsHistory":                true,
			"fetchPositionsRisk":                   false,
			"fetchPremiumIndexOHLCV":               false,
			"fetchStatus":                          false,
			"fetchTicker":                          true,
			"fetchTickers":                         true,
			"fetchTime":                            true,
			"fetchTrades":                          true,
			"fetchTradingFee":                      true,
			"fetchTradingFees":                     true,
			"fetchTransactions":                    false,
			"fetchTransfer":                        false,
			"fetchTransfers":                       true,
			"fetchWithdrawAddresses":               false,
			"fetchWithdrawal":                      false,
			"fetchWithdrawals":                     true,
			"reduceMargin":                         true,
			"repayCrossMargin":                     true,
			"repayIsolatedMargin":                  true,
			"setLeverage":                          true,
			"setMargin":                            false,
			"setMarginMode":                        true,
			"setPositionMode":                      true,
			"signIn":                               false,
			"transfer":                             true,
			"withdraw":                             true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1d",
			"3d":  "3d",
			"1w":  "1w",
			"1M":  "1m",
		},
		"hostname": "bitget.com",
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/fbaa10cc-a277-441d-a5b7-997dd9a87658",
			"api": map[string]interface{}{
				"spot":    "https://api.{hostname}",
				"mix":     "https://api.{hostname}",
				"user":    "https://api.{hostname}",
				"p2p":     "https://api.{hostname}",
				"broker":  "https://api.{hostname}",
				"margin":  "https://api.{hostname}",
				"common":  "https://api.{hostname}",
				"tax":     "https://api.{hostname}",
				"convert": "https://api.{hostname}",
				"copy":    "https://api.{hostname}",
				"earn":    "https://api.{hostname}",
				"uta":     "https://api.{hostname}",
			},
			"www":      "https://www.bitget.com",
			"doc":      []interface{}{"https://www.bitget.com/api-doc/common/intro", "https://www.bitget.com/api-doc/spot/intro", "https://www.bitget.com/api-doc/contract/intro", "https://www.bitget.com/api-doc/broker/intro", "https://www.bitget.com/api-doc/margin/intro", "https://www.bitget.com/api-doc/copytrading/intro", "https://www.bitget.com/api-doc/earn/intro", "https://bitgetlimited.github.io/apidoc/en/mix", "https://bitgetlimited.github.io/apidoc/en/spot", "https://bitgetlimited.github.io/apidoc/en/broker", "https://bitgetlimited.github.io/apidoc/en/margin"},
			"fees":     "https://www.bitget.cc/zh-CN/rate?tab=1",
			"referral": "https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"common": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/public/annoucements": 1,
						"v2/public/time":         1,
					},
				},
				"spot": map[string]interface{}{
					"get": map[string]interface{}{
						"spot/v1/notice/queryAllNotices":    1,
						"spot/v1/public/time":               1,
						"spot/v1/public/currencies":         6.6667,
						"spot/v1/public/products":           1,
						"spot/v1/public/product":            1,
						"spot/v1/market/ticker":             1,
						"spot/v1/market/tickers":            1,
						"spot/v1/market/fills":              2,
						"spot/v1/market/fills-history":      2,
						"spot/v1/market/candles":            1,
						"spot/v1/market/depth":              1,
						"spot/v1/market/spot-vip-level":     2,
						"spot/v1/market/merge-depth":        1,
						"spot/v1/market/history-candles":    1,
						"spot/v1/public/loan/coinInfos":     2,
						"spot/v1/public/loan/hour-interest": 2,
						"v2/spot/public/coins":              6.6667,
						"v2/spot/public/symbols":            1,
						"v2/spot/market/vip-fee-rate":       2,
						"v2/spot/market/tickers":            1,
						"v2/spot/market/merge-depth":        1,
						"v2/spot/market/orderbook":          1,
						"v2/spot/market/candles":            1,
						"v2/spot/market/history-candles":    1,
						"v2/spot/market/fills":              2,
						"v2/spot/market/fills-history":      2,
					},
				},
				"mix": map[string]interface{}{
					"get": map[string]interface{}{
						"mix/v1/market/contracts":             1,
						"mix/v1/market/depth":                 1,
						"mix/v1/market/ticker":                1,
						"mix/v1/market/tickers":               1,
						"mix/v1/market/contract-vip-level":    2,
						"mix/v1/market/fills":                 1,
						"mix/v1/market/fills-history":         2,
						"mix/v1/market/candles":               1,
						"mix/v1/market/index":                 1,
						"mix/v1/market/funding-time":          1,
						"mix/v1/market/history-fundRate":      1,
						"mix/v1/market/current-fundRate":      1,
						"mix/v1/market/open-interest":         1,
						"mix/v1/market/mark-price":            1,
						"mix/v1/market/symbol-leverage":       1,
						"mix/v1/market/queryPositionLever":    1,
						"mix/v1/market/open-limit":            1,
						"mix/v1/market/history-candles":       1,
						"mix/v1/market/history-index-candles": 1,
						"mix/v1/market/history-mark-candles":  1,
						"mix/v1/market/merge-depth":           1,
						"v2/mix/market/vip-fee-rate":          2,
						"v2/mix/market/merge-depth":           1,
						"v2/mix/market/ticker":                1,
						"v2/mix/market/tickers":               1,
						"v2/mix/market/fills":                 1,
						"v2/mix/market/fills-history":         2,
						"v2/mix/market/candles":               1,
						"v2/mix/market/history-candles":       1,
						"v2/mix/market/history-index-candles": 1,
						"v2/mix/market/history-mark-candles":  1,
						"v2/mix/market/open-interest":         1,
						"v2/mix/market/funding-time":          1,
						"v2/mix/market/symbol-price":          1,
						"v2/mix/market/history-fund-rate":     1,
						"v2/mix/market/current-fund-rate":     1,
						"v2/mix/market/contracts":             1,
						"v2/mix/market/query-position-lever":  2,
						"v2/mix/market/account-long-short":    20,
					},
				},
				"margin": map[string]interface{}{
					"get": map[string]interface{}{
						"margin/v1/cross/public/interestRateAndLimit":    2,
						"margin/v1/isolated/public/interestRateAndLimit": 2,
						"margin/v1/cross/public/tierData":                2,
						"margin/v1/isolated/public/tierData":             2,
						"margin/v1/public/currencies":                    1,
						"v2/margin/currencies":                           2,
						"v2/margin/market/long-short-ratio":              20,
					},
				},
				"earn": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/earn/loan/public/coinInfos":     2,
						"v2/earn/loan/public/hour-interest": 2,
					},
				},
				"uta": map[string]interface{}{
					"get": map[string]interface{}{
						"v3/market/instruments":       1,
						"v3/market/tickers":           1,
						"v3/market/orderbook":         1,
						"v3/market/fills":             1,
						"v3/market/open-interest":     1,
						"v3/market/candles":           1,
						"v3/market/history-candles":   1,
						"v3/market/current-fund-rate": 1,
						"v3/market/history-fund-rate": 1,
						"v3/market/risk-reserve":      1,
						"v3/market/discount-rate":     1,
						"v3/market/margin-loans":      1,
						"v3/market/position-tier":     1,
						"v3/market/oi-limit":          2,
					},
				},
			},
			"private": map[string]interface{}{
				"spot": map[string]interface{}{
					"get": map[string]interface{}{
						"spot/v1/wallet/deposit-address":    4,
						"spot/v1/wallet/withdrawal-list":    1,
						"spot/v1/wallet/deposit-list":       1,
						"spot/v1/account/getInfo":           20,
						"spot/v1/account/assets":            2,
						"spot/v1/account/assets-lite":       2,
						"spot/v1/account/transferRecords":   1,
						"spot/v1/convert/currencies":        2,
						"spot/v1/convert/convert-record":    2,
						"spot/v1/loan/ongoing-orders":       2,
						"spot/v1/loan/repay-history":        2,
						"spot/v1/loan/revise-history":       2,
						"spot/v1/loan/borrow-history":       2,
						"spot/v1/loan/debts":                2,
						"v2/spot/trade/orderInfo":           1,
						"v2/spot/trade/unfilled-orders":     1,
						"v2/spot/trade/history-orders":      1,
						"v2/spot/trade/fills":               2,
						"v2/spot/trade/current-plan-order":  1,
						"v2/spot/trade/history-plan-order":  1,
						"v2/spot/account/info":              20,
						"v2/spot/account/assets":            2,
						"v2/spot/account/subaccount-assets": 2,
						"v2/spot/account/bills":             2,
						"v2/spot/account/transferRecords":   1,
						"v2/account/funding-assets":         2,
						"v2/account/bot-assets":             2,
						"v2/account/all-account-balance":    20,
						"v2/spot/wallet/deposit-address":    2,
						"v2/spot/wallet/deposit-records":    2,
						"v2/spot/wallet/withdrawal-records": 2,
					},
					"post": map[string]interface{}{
						"spot/v1/wallet/transfer":                   4,
						"spot/v1/wallet/transfer-v2":                4,
						"spot/v1/wallet/subTransfer":                10,
						"spot/v1/wallet/withdrawal":                 4,
						"spot/v1/wallet/withdrawal-v2":              4,
						"spot/v1/wallet/withdrawal-inner":           4,
						"spot/v1/wallet/withdrawal-inner-v2":        4,
						"spot/v1/account/sub-account-spot-assets":   200,
						"spot/v1/account/bills":                     2,
						"spot/v1/trade/orders":                      2,
						"spot/v1/trade/batch-orders":                4,
						"spot/v1/trade/cancel-order":                2,
						"spot/v1/trade/cancel-order-v2":             2,
						"spot/v1/trade/cancel-symbol-order":         2,
						"spot/v1/trade/cancel-batch-orders":         4,
						"spot/v1/trade/cancel-batch-orders-v2":      4,
						"spot/v1/trade/orderInfo":                   1,
						"spot/v1/trade/open-orders":                 1,
						"spot/v1/trade/history":                     1,
						"spot/v1/trade/fills":                       1,
						"spot/v1/plan/placePlan":                    1,
						"spot/v1/plan/modifyPlan":                   1,
						"spot/v1/plan/cancelPlan":                   1,
						"spot/v1/plan/currentPlan":                  1,
						"spot/v1/plan/historyPlan":                  1,
						"spot/v1/plan/batchCancelPlan":              2,
						"spot/v1/convert/quoted-price":              4,
						"spot/v1/convert/trade":                     4,
						"spot/v1/loan/borrow":                       2,
						"spot/v1/loan/repay":                        2,
						"spot/v1/loan/revise-pledge":                2,
						"spot/v1/trace/order/orderCurrentList":      2,
						"spot/v1/trace/order/orderHistoryList":      2,
						"spot/v1/trace/order/closeTrackingOrder":    2,
						"spot/v1/trace/order/updateTpsl":            2,
						"spot/v1/trace/order/followerEndOrder":      2,
						"spot/v1/trace/order/spotInfoList":          2,
						"spot/v1/trace/config/getTraderSettings":    2,
						"spot/v1/trace/config/getFollowerSettings":  2,
						"spot/v1/trace/user/myTraders":              2,
						"spot/v1/trace/config/setFollowerConfig":    2,
						"spot/v1/trace/user/myFollowers":            2,
						"spot/v1/trace/config/setProductCode":       2,
						"spot/v1/trace/user/removeTrader":           2,
						"spot/v1/trace/getRemovableFollower":        2,
						"spot/v1/trace/user/removeFollower":         2,
						"spot/v1/trace/profit/totalProfitInfo":      2,
						"spot/v1/trace/profit/totalProfitList":      2,
						"spot/v1/trace/profit/profitHisList":        2,
						"spot/v1/trace/profit/profitHisDetailList":  2,
						"spot/v1/trace/profit/waitProfitDetailList": 2,
						"spot/v1/trace/user/getTraderInfo":          2,
						"v2/spot/trade/place-order":                 2,
						"v2/spot/trade/cancel-order":                2,
						"v2/spot/trade/batch-orders":                20,
						"v2/spot/trade/batch-cancel-order":          2,
						"v2/spot/trade/cancel-symbol-order":         4,
						"v2/spot/trade/place-plan-order":            1,
						"v2/spot/trade/modify-plan-order":           1,
						"v2/spot/trade/cancel-plan-order":           1,
						"v2/spot/trade/batch-cancel-plan-order":     2,
						"v2/spot/wallet/transfer":                   2,
						"v2/spot/wallet/subaccount-transfer":        2,
						"v2/spot/wallet/withdrawal":                 2,
						"v2/spot/wallet/cancel-withdrawal":          2,
						"v2/spot/wallet/modify-deposit-account":     2,
					},
				},
				"mix": map[string]interface{}{
					"get": map[string]interface{}{
						"mix/v1/account/account":                2,
						"mix/v1/account/accounts":               2,
						"mix/v1/position/singlePosition":        2,
						"mix/v1/position/singlePosition-v2":     2,
						"mix/v1/position/allPosition":           4,
						"mix/v1/position/allPosition-v2":        4,
						"mix/v1/position/history-position":      1,
						"mix/v1/account/accountBill":            2,
						"mix/v1/account/accountBusinessBill":    4,
						"mix/v1/order/current":                  1,
						"mix/v1/order/marginCoinCurrent":        1,
						"mix/v1/order/history":                  2,
						"mix/v1/order/historyProductType":       4,
						"mix/v1/order/detail":                   2,
						"mix/v1/order/fills":                    2,
						"mix/v1/order/allFills":                 2,
						"mix/v1/plan/currentPlan":               1,
						"mix/v1/plan/historyPlan":               2,
						"mix/v1/trace/currentTrack":             2,
						"mix/v1/trace/followerOrder":            2,
						"mix/v1/trace/followerHistoryOrders":    2,
						"mix/v1/trace/historyTrack":             2,
						"mix/v1/trace/summary":                  1,
						"mix/v1/trace/profitSettleTokenIdGroup": 1,
						"mix/v1/trace/profitDateGroupList":      1,
						"mix/v1/trade/profitDateList":           2,
						"mix/v1/trace/waitProfitDateList":       1,
						"mix/v1/trace/traderSymbols":            1,
						"mix/v1/trace/traderList":               2,
						"mix/v1/trace/traderDetail":             2,
						"mix/v1/trace/queryTraceConfig":         2,
						"v2/mix/account/account":                2,
						"v2/mix/account/accounts":               2,
						"v2/mix/account/sub-account-assets":     200,
						"v2/mix/account/open-count":             2,
						"v2/mix/account/bill":                   2,
						"v2/mix/market/query-position-lever":    2,
						"v2/mix/position/single-position":       2,
						"v2/mix/position/all-position":          4,
						"v2/mix/position/history-position":      1,
						"v2/mix/order/detail":                   2,
						"v2/mix/order/fills":                    2,
						"v2/mix/order/fill-history":             2,
						"v2/mix/order/orders-pending":           2,
						"v2/mix/order/orders-history":           2,
						"v2/mix/order/orders-plan-pending":      2,
						"v2/mix/order/orders-plan-history":      2,
						"v2/mix/market/position-long-short":     20,
					},
					"post": map[string]interface{}{
						"mix/v1/account/sub-account-contract-assets": 200,
						"mix/v1/account/open-count":                  1,
						"mix/v1/account/setLeverage":                 4,
						"mix/v1/account/setMargin":                   4,
						"mix/v1/account/setMarginMode":               4,
						"mix/v1/account/setPositionMode":             4,
						"mix/v1/order/placeOrder":                    2,
						"mix/v1/order/batch-orders":                  2,
						"mix/v1/order/cancel-order":                  2,
						"mix/v1/order/cancel-batch-orders":           2,
						"mix/v1/order/modifyOrder":                   2,
						"mix/v1/order/cancel-symbol-orders":          2,
						"mix/v1/order/cancel-all-orders":             2,
						"mix/v1/order/close-all-positions":           20,
						"mix/v1/plan/placePlan":                      2,
						"mix/v1/plan/modifyPlan":                     2,
						"mix/v1/plan/modifyPlanPreset":               2,
						"mix/v1/plan/placeTPSL":                      2,
						"mix/v1/plan/placeTrailStop":                 2,
						"mix/v1/plan/placePositionsTPSL":             2,
						"mix/v1/plan/modifyTPSLPlan":                 2,
						"mix/v1/plan/cancelPlan":                     2,
						"mix/v1/plan/cancelSymbolPlan":               2,
						"mix/v1/plan/cancelAllPlan":                  2,
						"mix/v1/trace/closeTrackOrder":               2,
						"mix/v1/trace/modifyTPSL":                    2,
						"mix/v1/trace/closeTrackOrderBySymbol":       2,
						"mix/v1/trace/setUpCopySymbols":              2,
						"mix/v1/trace/followerSetBatchTraceConfig":   2,
						"mix/v1/trace/followerCloseByTrackingNo":     2,
						"mix/v1/trace/followerCloseByAll":            2,
						"mix/v1/trace/followerSetTpsl":               2,
						"mix/v1/trace/cancelCopyTrader":              4,
						"mix/v1/trace/traderUpdateConfig":            2,
						"mix/v1/trace/myTraderList":                  2,
						"mix/v1/trace/myFollowerList":                2,
						"mix/v1/trace/removeFollower":                2,
						"mix/v1/trace/public/getFollowerConfig":      2,
						"mix/v1/trace/report/order/historyList":      2,
						"mix/v1/trace/report/order/currentList":      2,
						"mix/v1/trace/queryTraderTpslRatioConfig":    2,
						"mix/v1/trace/traderUpdateTpslRatioConfig":   2,
						"v2/mix/account/set-leverage":                4,
						"v2/mix/account/set-margin":                  4,
						"v2/mix/account/set-margin-mode":             4,
						"v2/mix/account/set-position-mode":           4,
						"v2/mix/order/place-order":                   2,
						"v2/mix/order/click-backhand":                20,
						"v2/mix/order/batch-place-order":             20,
						"v2/mix/order/modify-order":                  2,
						"v2/mix/order/cancel-order":                  2,
						"v2/mix/order/batch-cancel-orders":           2,
						"v2/mix/order/close-positions":               20,
						"v2/mix/order/place-tpsl-order":              2,
						"v2/mix/order/place-plan-order":              2,
						"v2/mix/order/modify-tpsl-order":             2,
						"v2/mix/order/modify-plan-order":             2,
						"v2/mix/order/cancel-plan-order":             2,
					},
				},
				"user": map[string]interface{}{
					"get": map[string]interface{}{
						"user/v1/fee/query":                      2,
						"user/v1/sub/virtual-list":               2,
						"user/v1/sub/virtual-api-list":           2,
						"user/v1/tax/spot-record":                1,
						"user/v1/tax/future-record":              1,
						"user/v1/tax/margin-record":              1,
						"user/v1/tax/p2p-record":                 1,
						"v2/user/virtual-subaccount-list":        2,
						"v2/user/virtual-subaccount-apikey-list": 2,
					},
					"post": map[string]interface{}{
						"user/v1/sub/virtual-create":                 4,
						"user/v1/sub/virtual-modify":                 4,
						"user/v1/sub/virtual-api-batch-create":       20,
						"user/v1/sub/virtual-api-create":             4,
						"user/v1/sub/virtual-api-modify":             4,
						"v2/user/create-virtual-subaccount":          4,
						"v2/user/modify-virtual-subaccount":          4,
						"v2/user/batch-create-subaccount-and-apikey": 20,
						"v2/user/create-virtual-subaccount-apikey":   4,
						"v2/user/modify-virtual-subaccount-apikey":   4,
					},
				},
				"p2p": map[string]interface{}{
					"get": map[string]interface{}{
						"p2p/v1/merchant/merchantList": 2,
						"p2p/v1/merchant/merchantInfo": 2,
						"p2p/v1/merchant/advList":      2,
						"p2p/v1/merchant/orderList":    2,
						"v2/p2p/merchantList":          2,
						"v2/p2p/merchantInfo":          2,
						"v2/p2p/orderList":             2,
						"v2/p2p/advList":               2,
					},
				},
				"broker": map[string]interface{}{
					"get": map[string]interface{}{
						"broker/v1/account/info":                     2,
						"broker/v1/account/sub-list":                 20,
						"broker/v1/account/sub-email":                20,
						"broker/v1/account/sub-spot-assets":          2,
						"broker/v1/account/sub-future-assets":        2,
						"broker/v1/account/subaccount-transfer":      1,
						"broker/v1/account/subaccount-deposit":       1,
						"broker/v1/account/subaccount-withdrawal":    1,
						"broker/v1/account/sub-api-list":             2,
						"v2/broker/account/info":                     2,
						"v2/broker/account/subaccount-list":          20,
						"v2/broker/account/subaccount-email":         2,
						"v2/broker/account/subaccount-spot-assets":   2,
						"v2/broker/account/subaccount-future-assets": 2,
						"v2/broker/manage/subaccount-apikey-list":    2,
					},
					"post": map[string]interface{}{
						"broker/v1/account/sub-create":                  20,
						"broker/v1/account/sub-modify":                  20,
						"broker/v1/account/sub-modify-email":            20,
						"broker/v1/account/sub-address":                 2,
						"broker/v1/account/sub-withdrawal":              2,
						"broker/v1/account/sub-auto-transfer":           4,
						"broker/v1/account/sub-api-create":              2,
						"broker/v1/account/sub-api-modify":              2,
						"v2/broker/account/modify-subaccount-email":     2,
						"v2/broker/account/create-subaccount":           20,
						"v2/broker/account/modify-subaccount":           20,
						"v2/broker/account/subaccount-address":          2,
						"v2/broker/account/subaccount-withdrawal":       2,
						"v2/broker/account/set-subaccount-autotransfer": 2,
						"v2/broker/manage/create-subaccount-apikey":     2,
						"v2/broker/manage/modify-subaccount-apikey":     2,
					},
				},
				"margin": map[string]interface{}{
					"get": map[string]interface{}{
						"margin/v1/cross/account/riskRate":                   2,
						"margin/v1/cross/account/maxTransferOutAmount":       2,
						"margin/v1/isolated/account/maxTransferOutAmount":    2,
						"margin/v1/isolated/order/openOrders":                2,
						"margin/v1/isolated/order/history":                   2,
						"margin/v1/isolated/order/fills":                     2,
						"margin/v1/isolated/loan/list":                       2,
						"margin/v1/isolated/repay/list":                      2,
						"margin/v1/isolated/interest/list":                   2,
						"margin/v1/isolated/liquidation/list":                2,
						"margin/v1/isolated/fin/list":                        2,
						"margin/v1/cross/order/openOrders":                   2,
						"margin/v1/cross/order/history":                      2,
						"margin/v1/cross/order/fills":                        2,
						"margin/v1/cross/loan/list":                          2,
						"margin/v1/cross/repay/list":                         2,
						"margin/v1/cross/interest/list":                      2,
						"margin/v1/cross/liquidation/list":                   2,
						"margin/v1/cross/fin/list":                           2,
						"margin/v1/cross/account/assets":                     2,
						"margin/v1/isolated/account/assets":                  2,
						"v2/margin/crossed/borrow-history":                   2,
						"v2/margin/crossed/repay-history":                    2,
						"v2/margin/crossed/interest-history":                 2,
						"v2/margin/crossed/liquidation-history":              2,
						"v2/margin/crossed/financial-records":                2,
						"v2/margin/crossed/account/assets":                   2,
						"v2/margin/crossed/account/risk-rate":                2,
						"v2/margin/crossed/account/max-borrowable-amount":    2,
						"v2/margin/crossed/account/max-transfer-out-amount":  2,
						"v2/margin/crossed/interest-rate-and-limit":          2,
						"v2/margin/crossed/tier-data":                        2,
						"v2/margin/crossed/open-orders":                      2,
						"v2/margin/crossed/history-orders":                   2,
						"v2/margin/crossed/fills":                            2,
						"v2/margin/isolated/borrow-history":                  2,
						"v2/margin/isolated/repay-history":                   2,
						"v2/margin/isolated/interest-history":                2,
						"v2/margin/isolated/liquidation-history":             2,
						"v2/margin/isolated/financial-records":               2,
						"v2/margin/isolated/account/assets":                  2,
						"v2/margin/isolated/account/risk-rate":               2,
						"v2/margin/isolated/account/max-borrowable-amount":   2,
						"v2/margin/isolated/account/max-transfer-out-amount": 2,
						"v2/margin/isolated/interest-rate-and-limit":         2,
						"v2/margin/isolated/tier-data":                       2,
						"v2/margin/isolated/open-orders":                     2,
						"v2/margin/isolated/history-orders":                  2,
						"v2/margin/isolated/fills":                           2,
					},
					"post": map[string]interface{}{
						"margin/v1/cross/account/borrow":                      2,
						"margin/v1/isolated/account/borrow":                   2,
						"margin/v1/cross/account/repay":                       2,
						"margin/v1/isolated/account/repay":                    2,
						"margin/v1/isolated/account/riskRate":                 2,
						"margin/v1/cross/account/maxBorrowableAmount":         2,
						"margin/v1/isolated/account/maxBorrowableAmount":      2,
						"margin/v1/isolated/account/flashRepay":               2,
						"margin/v1/isolated/account/queryFlashRepayStatus":    2,
						"margin/v1/cross/account/flashRepay":                  2,
						"margin/v1/cross/account/queryFlashRepayStatus":       2,
						"margin/v1/isolated/order/placeOrder":                 4,
						"margin/v1/isolated/order/batchPlaceOrder":            4,
						"margin/v1/isolated/order/cancelOrder":                2,
						"margin/v1/isolated/order/batchCancelOrder":           2,
						"margin/v1/cross/order/placeOrder":                    2,
						"margin/v1/cross/order/batchPlaceOrder":               2,
						"margin/v1/cross/order/cancelOrder":                   2,
						"margin/v1/cross/order/batchCancelOrder":              2,
						"v2/margin/crossed/account/borrow":                    2,
						"v2/margin/crossed/account/repay":                     2,
						"v2/margin/crossed/account/flash-repay":               2,
						"v2/margin/crossed/account/query-flash-repay-status":  2,
						"v2/margin/crossed/place-order":                       2,
						"v2/margin/crossed/batch-place-order":                 2,
						"v2/margin/crossed/cancel-order":                      2,
						"v2/margin/crossed/batch-cancel-order":                2,
						"v2/margin/isolated/account/borrow":                   2,
						"v2/margin/isolated/account/repay":                    2,
						"v2/margin/isolated/account/flash-repay":              2,
						"v2/margin/isolated/account/query-flash-repay-status": 2,
						"v2/margin/isolated/place-order":                      2,
						"v2/margin/isolated/batch-place-order":                2,
						"v2/margin/isolated/cancel-order":                     2,
						"v2/margin/isolated/batch-cancel-order":               2,
					},
				},
				"copy": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/copy/mix-trader/order-current-track":     2,
						"v2/copy/mix-trader/order-history-track":     2,
						"v2/copy/mix-trader/order-total-detail":      2,
						"v2/copy/mix-trader/profit-history-summarys": 1,
						"v2/copy/mix-trader/profit-history-details":  1,
						"v2/copy/mix-trader/profit-details":          1,
						"v2/copy/mix-trader/profits-group-coin-date": 1,
						"v2/copy/mix-trader/config-query-symbols":    1,
						"v2/copy/mix-trader/config-query-followers":  2,
						"v2/copy/mix-follower/query-current-orders":  2,
						"v2/copy/mix-follower/query-history-orders":  1,
						"v2/copy/mix-follower/query-settings":        2,
						"v2/copy/mix-follower/query-traders":         2,
						"v2/copy/mix-follower/query-quantity-limit":  2,
						"v2/copy/mix-broker/query-traders":           2,
						"v2/copy/mix-broker/query-history-traces":    2,
						"v2/copy/mix-broker/query-current-traces":    2,
						"v2/copy/spot-trader/profit-summarys":        2,
						"v2/copy/spot-trader/profit-history-details": 2,
						"v2/copy/spot-trader/profit-details":         2,
						"v2/copy/spot-trader/order-total-detail":     2,
						"v2/copy/spot-trader/order-history-track":    2,
						"v2/copy/spot-trader/order-current-track":    2,
						"v2/copy/spot-trader/config-query-settings":  2,
						"v2/copy/spot-trader/config-query-followers": 2,
						"v2/copy/spot-follower/query-traders":        2,
						"v2/copy/spot-follower/query-trader-symbols": 2,
						"v2/copy/spot-follower/query-settings":       2,
						"v2/copy/spot-follower/query-history-orders": 2,
						"v2/copy/spot-follower/query-current-orders": 2,
					},
					"post": map[string]interface{}{
						"v2/copy/mix-trader/order-modify-tpsl":       2,
						"v2/copy/mix-trader/order-close-positions":   2,
						"v2/copy/mix-trader/config-setting-symbols":  2,
						"v2/copy/mix-trader/config-setting-base":     2,
						"v2/copy/mix-trader/config-remove-follower":  2,
						"v2/copy/mix-follower/setting-tpsl":          1,
						"v2/copy/mix-follower/settings":              2,
						"v2/copy/mix-follower/close-positions":       2,
						"v2/copy/mix-follower/cancel-trader":         4,
						"v2/copy/spot-trader/order-modify-tpsl":      2,
						"v2/copy/spot-trader/order-close-tracking":   2,
						"v2/copy/spot-trader/config-setting-symbols": 2,
						"v2/copy/spot-trader/config-remove-follower": 2,
						"v2/copy/spot-follower/stop-order":           2,
						"v2/copy/spot-follower/settings":             2,
						"v2/copy/spot-follower/setting-tpsl":         2,
						"v2/copy/spot-follower/order-close-tracking": 2,
						"v2/copy/spot-follower/cancel-trader":        2,
					},
				},
				"tax": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/tax/spot-record":   20,
						"v2/tax/future-record": 20,
						"v2/tax/margin-record": 20,
						"v2/tax/p2p-record":    20,
					},
				},
				"convert": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/convert/currencies":            2,
						"v2/convert/quoted-price":          2,
						"v2/convert/convert-record":        2,
						"v2/convert/bgb-convert-coin-list": 2,
						"v2/convert/bgb-convert-records":   2,
					},
					"post": map[string]interface{}{
						"v2/convert/trade":       2,
						"v2/convert/bgb-convert": 2,
					},
				},
				"earn": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/earn/savings/product":           2,
						"v2/earn/savings/account":           2,
						"v2/earn/savings/assets":            2,
						"v2/earn/savings/records":           2,
						"v2/earn/savings/subscribe-info":    2,
						"v2/earn/savings/subscribe-result":  2,
						"v2/earn/savings/redeem-result":     2,
						"v2/earn/sharkfin/product":          2,
						"v2/earn/sharkfin/account":          2,
						"v2/earn/sharkfin/assets":           2,
						"v2/earn/sharkfin/records":          2,
						"v2/earn/sharkfin/subscribe-info":   2,
						"v2/earn/sharkfin/subscribe-result": 4,
						"v2/earn/loan/ongoing-orders":       2,
						"v2/earn/loan/repay-history":        2,
						"v2/earn/loan/revise-history":       2,
						"v2/earn/loan/borrow-history":       2,
						"v2/earn/loan/debts":                2,
						"v2/earn/loan/reduces":              2,
						"v2/earn/account/assets":            2,
					},
					"post": map[string]interface{}{
						"v2/earn/savings/subscribe":  2,
						"v2/earn/savings/redeem":     2,
						"v2/earn/sharkfin/subscribe": 2,
						"v2/earn/loan/borrow":        2,
						"v2/earn/loan/repay":         2,
						"v2/earn/loan/revise-pledge": 2,
					},
				},
				"common": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/common/trade-rate": 2,
					},
				},
				"uta": map[string]interface{}{
					"get": map[string]interface{}{
						"v3/account/assets":                 1,
						"v3/account/settings":               1,
						"v3/account/deposit-records":        2,
						"v3/account/financial-records":      1,
						"v3/account/repayable-coins":        2,
						"v3/account/payment-coins":          2,
						"v3/account/convert-records":        1,
						"v3/account/transferable-coins":     2,
						"v3/account/sub-transfer-record":    4,
						"v3/ins-loan/transfered":            6.6667,
						"v3/ins-loan/symbols":               6.6667,
						"v3/ins-loan/risk-unit":             6.6667,
						"v3/ins-loan/repaid-history":        6.6667,
						"v3/ins-loan/product-infos":         6.6667,
						"v3/ins-loan/loan-order":            6.6667,
						"v3/ins-loan/ltv-convert":           6.6667,
						"v3/ins-loan/ensure-coins-convert":  6.6667,
						"v3/position/current-position":      1,
						"v3/position/history-position":      1,
						"v3/trade/order-info":               1,
						"v3/trade/unfilled-orders":          1,
						"v3/trade/unfilled-strategy-orders": 1,
						"v3/trade/history-orders":           1,
						"v3/trade/history-strategy-orders":  1,
						"v3/trade/fills":                    1,
						"v3/user/sub-list":                  2,
						"v3/user/sub-api-list":              2,
					},
					"post": map[string]interface{}{
						"v3/account/set-leverage":        2,
						"v3/account/set-hold-mode":       2,
						"v3/account/repay":               4,
						"v3/account/transfer":            4,
						"v3/account/sub-transfer":        4,
						"v3/account/max-open-available":  4,
						"v3/ins-loan/bind-uid":           6.6667,
						"v3/trade/place-order":           2,
						"v3/trade/place-strategy-order":  2,
						"v3/trade/modify-order":          2,
						"v3/trade/modify-strategy-order": 2,
						"v3/trade/cancel-order":          2,
						"v3/trade/cancel-strategy-order": 2,
						"v3/trade/place-batch":           4,
						"v3/trade/batch-modify-order":    2,
						"v3/trade/cancel-batch":          4,
						"v3/trade/cancel-symbol-order":   4,
						"v3/trade/close-positions":       4,
						"v3/user/create-sub":             2,
						"v3/user/freeze-sub":             2,
						"v3/user/create-sub-api":         2,
						"v3/user/update-sub-api":         2,
						"v3/user/delete-sub-api":         2,
					},
				},
			},
		},
		"fees": map[string]interface{}{
			"spot": map[string]interface{}{
				"taker": this.ParseNumber("0.002"),
				"maker": this.ParseNumber("0.002"),
			},
			"swap": map[string]interface{}{
				"taker": this.ParseNumber("0.0006"),
				"maker": this.ParseNumber("0.0004"),
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey":   true,
			"secret":   true,
			"password": true,
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"1": ExchangeError,
				"failure to get a peer from the ring-balancer": ExchangeNotAvailable,
				"4010":               PermissionDenied,
				"4001":               ExchangeError,
				"4002":               ExchangeError,
				"40020":              BadRequest,
				"30001":              AuthenticationError,
				"30002":              AuthenticationError,
				"30003":              AuthenticationError,
				"30004":              AuthenticationError,
				"30005":              InvalidNonce,
				"30006":              AuthenticationError,
				"30007":              BadRequest,
				"30008":              RequestTimeout,
				"30009":              ExchangeError,
				"30010":              AuthenticationError,
				"30011":              PermissionDenied,
				"30012":              AuthenticationError,
				"30013":              AuthenticationError,
				"30014":              DDoSProtection,
				"30015":              AuthenticationError,
				"30016":              ExchangeError,
				"30017":              ExchangeError,
				"30018":              ExchangeError,
				"30019":              ExchangeNotAvailable,
				"30020":              BadRequest,
				"30021":              BadRequest,
				"30022":              PermissionDenied,
				"30023":              BadRequest,
				"30024":              BadSymbol,
				"30025":              BadRequest,
				"30026":              DDoSProtection,
				"30027":              AuthenticationError,
				"30028":              PermissionDenied,
				"30029":              AccountSuspended,
				"30030":              ExchangeError,
				"30031":              BadRequest,
				"30032":              BadSymbol,
				"30033":              BadRequest,
				"30034":              ExchangeError,
				"30035":              ExchangeError,
				"30036":              ExchangeError,
				"30037":              ExchangeNotAvailable,
				"30038":              OnMaintenance,
				"32001":              AccountSuspended,
				"32002":              PermissionDenied,
				"32003":              CancelPending,
				"32004":              ExchangeError,
				"32005":              InvalidOrder,
				"32006":              InvalidOrder,
				"32007":              InvalidOrder,
				"32008":              InvalidOrder,
				"32009":              InvalidOrder,
				"32010":              ExchangeError,
				"32011":              ExchangeError,
				"32012":              ExchangeError,
				"32013":              ExchangeError,
				"32014":              ExchangeError,
				"32015":              ExchangeError,
				"32016":              ExchangeError,
				"32017":              ExchangeError,
				"32018":              ExchangeError,
				"32019":              ExchangeError,
				"32020":              ExchangeError,
				"32021":              ExchangeError,
				"32022":              ExchangeError,
				"32023":              ExchangeError,
				"32024":              ExchangeError,
				"32025":              ExchangeError,
				"32026":              ExchangeError,
				"32027":              ExchangeError,
				"32028":              AccountSuspended,
				"32029":              ExchangeError,
				"32030":              InvalidOrder,
				"32031":              ArgumentsRequired,
				"32038":              AuthenticationError,
				"32040":              ExchangeError,
				"32044":              ExchangeError,
				"32045":              ExchangeError,
				"32046":              ExchangeError,
				"32047":              ExchangeError,
				"32048":              InvalidOrder,
				"32049":              ExchangeError,
				"32050":              InvalidOrder,
				"32051":              InvalidOrder,
				"32052":              ExchangeError,
				"32053":              ExchangeError,
				"32057":              ExchangeError,
				"32054":              ExchangeError,
				"32055":              InvalidOrder,
				"32056":              ExchangeError,
				"32058":              ExchangeError,
				"32059":              InvalidOrder,
				"32060":              InvalidOrder,
				"32061":              InvalidOrder,
				"32062":              InvalidOrder,
				"32063":              InvalidOrder,
				"32064":              ExchangeError,
				"32065":              ExchangeError,
				"32066":              ExchangeError,
				"32067":              ExchangeError,
				"32068":              ExchangeError,
				"32069":              ExchangeError,
				"32070":              ExchangeError,
				"32071":              ExchangeError,
				"32072":              ExchangeError,
				"32073":              ExchangeError,
				"32074":              ExchangeError,
				"32075":              ExchangeError,
				"32076":              ExchangeError,
				"32077":              ExchangeError,
				"32078":              ExchangeError,
				"32079":              ExchangeError,
				"32080":              ExchangeError,
				"32083":              ExchangeError,
				"33001":              PermissionDenied,
				"33002":              AccountSuspended,
				"33003":              InsufficientFunds,
				"33004":              ExchangeError,
				"33005":              ExchangeError,
				"33006":              ExchangeError,
				"33007":              ExchangeError,
				"33008":              InsufficientFunds,
				"33009":              ExchangeError,
				"33010":              ExchangeError,
				"33011":              ExchangeError,
				"33012":              ExchangeError,
				"33013":              InvalidOrder,
				"33014":              OrderNotFound,
				"33015":              InvalidOrder,
				"33016":              ExchangeError,
				"33017":              InsufficientFunds,
				"33018":              ExchangeError,
				"33020":              ExchangeError,
				"33021":              BadRequest,
				"33022":              InvalidOrder,
				"33023":              ExchangeError,
				"33024":              InvalidOrder,
				"33025":              InvalidOrder,
				"33026":              ExchangeError,
				"33027":              InvalidOrder,
				"33028":              InvalidOrder,
				"33029":              InvalidOrder,
				"33034":              ExchangeError,
				"33035":              ExchangeError,
				"33036":              ExchangeError,
				"33037":              ExchangeError,
				"33038":              ExchangeError,
				"33039":              ExchangeError,
				"33040":              ExchangeError,
				"33041":              ExchangeError,
				"33042":              ExchangeError,
				"33043":              ExchangeError,
				"33044":              ExchangeError,
				"33045":              ExchangeError,
				"33046":              ExchangeError,
				"33047":              ExchangeError,
				"33048":              ExchangeError,
				"33049":              ExchangeError,
				"33050":              ExchangeError,
				"33051":              ExchangeError,
				"33059":              BadRequest,
				"33060":              BadRequest,
				"33061":              ExchangeError,
				"33062":              ExchangeError,
				"33063":              ExchangeError,
				"33064":              ExchangeError,
				"33065":              ExchangeError,
				"21009":              ExchangeError,
				"34001":              PermissionDenied,
				"34002":              InvalidAddress,
				"34003":              ExchangeError,
				"34004":              ExchangeError,
				"34005":              ExchangeError,
				"34006":              ExchangeError,
				"34007":              ExchangeError,
				"34008":              InsufficientFunds,
				"34009":              ExchangeError,
				"34010":              ExchangeError,
				"34011":              ExchangeError,
				"34012":              ExchangeError,
				"34013":              ExchangeError,
				"34014":              ExchangeError,
				"34015":              ExchangeError,
				"34016":              PermissionDenied,
				"34017":              AccountSuspended,
				"34018":              AuthenticationError,
				"34019":              PermissionDenied,
				"34020":              PermissionDenied,
				"34021":              InvalidAddress,
				"34022":              ExchangeError,
				"34023":              PermissionDenied,
				"34026":              ExchangeError,
				"34036":              ExchangeError,
				"34037":              ExchangeError,
				"34038":              ExchangeError,
				"34039":              ExchangeError,
				"35001":              ExchangeError,
				"35002":              ExchangeError,
				"35003":              ExchangeError,
				"35004":              ExchangeError,
				"35005":              AuthenticationError,
				"35008":              InvalidOrder,
				"35010":              InvalidOrder,
				"35012":              InvalidOrder,
				"35014":              InvalidOrder,
				"35015":              InvalidOrder,
				"35017":              ExchangeError,
				"35019":              InvalidOrder,
				"35020":              InvalidOrder,
				"35021":              InvalidOrder,
				"35022":              ExchangeError,
				"35024":              ExchangeError,
				"35025":              InsufficientFunds,
				"35026":              ExchangeError,
				"35029":              OrderNotFound,
				"35030":              InvalidOrder,
				"35031":              InvalidOrder,
				"35032":              ExchangeError,
				"35037":              ExchangeError,
				"35039":              ExchangeError,
				"35040":              InvalidOrder,
				"35044":              ExchangeError,
				"35046":              InsufficientFunds,
				"35047":              InsufficientFunds,
				"35048":              ExchangeError,
				"35049":              InvalidOrder,
				"35050":              InvalidOrder,
				"35052":              InsufficientFunds,
				"35053":              ExchangeError,
				"35055":              InsufficientFunds,
				"35057":              ExchangeError,
				"35058":              ExchangeError,
				"35059":              BadRequest,
				"35060":              BadRequest,
				"35061":              BadRequest,
				"35062":              InvalidOrder,
				"35063":              InvalidOrder,
				"35064":              InvalidOrder,
				"35066":              InvalidOrder,
				"35067":              InvalidOrder,
				"35068":              InvalidOrder,
				"35069":              InvalidOrder,
				"35070":              InvalidOrder,
				"35071":              InvalidOrder,
				"35072":              InvalidOrder,
				"35073":              InvalidOrder,
				"35074":              InvalidOrder,
				"35075":              InvalidOrder,
				"35076":              InvalidOrder,
				"35077":              InvalidOrder,
				"35078":              InvalidOrder,
				"35079":              InvalidOrder,
				"35080":              InvalidOrder,
				"35081":              InvalidOrder,
				"35082":              InvalidOrder,
				"35083":              InvalidOrder,
				"35084":              InvalidOrder,
				"35085":              InvalidOrder,
				"35086":              InvalidOrder,
				"35087":              InvalidOrder,
				"35088":              InvalidOrder,
				"35089":              InvalidOrder,
				"35090":              ExchangeError,
				"35091":              ExchangeError,
				"35092":              ExchangeError,
				"35093":              ExchangeError,
				"35094":              ExchangeError,
				"35095":              BadRequest,
				"35096":              ExchangeError,
				"35097":              ExchangeError,
				"35098":              ExchangeError,
				"35099":              ExchangeError,
				"36001":              BadRequest,
				"36002":              BadRequest,
				"36005":              ExchangeError,
				"36101":              AuthenticationError,
				"36102":              PermissionDenied,
				"36103":              AccountSuspended,
				"36104":              PermissionDenied,
				"36105":              PermissionDenied,
				"36106":              AccountSuspended,
				"36107":              PermissionDenied,
				"36108":              InsufficientFunds,
				"36109":              PermissionDenied,
				"36201":              PermissionDenied,
				"36202":              PermissionDenied,
				"36203":              InvalidOrder,
				"36204":              ExchangeError,
				"36205":              BadRequest,
				"36206":              BadRequest,
				"36207":              InvalidOrder,
				"36208":              InvalidOrder,
				"36209":              InvalidOrder,
				"36210":              InvalidOrder,
				"36211":              InvalidOrder,
				"36212":              InvalidOrder,
				"36213":              InvalidOrder,
				"36214":              ExchangeError,
				"36216":              OrderNotFound,
				"36217":              InvalidOrder,
				"36218":              InvalidOrder,
				"36219":              InvalidOrder,
				"36220":              InvalidOrder,
				"36221":              InvalidOrder,
				"36222":              InvalidOrder,
				"36223":              InvalidOrder,
				"36224":              InvalidOrder,
				"36225":              InvalidOrder,
				"36226":              InvalidOrder,
				"36227":              InvalidOrder,
				"36228":              InvalidOrder,
				"36229":              InvalidOrder,
				"36230":              InvalidOrder,
				"400":                BadRequest,
				"401":                AuthenticationError,
				"403":                PermissionDenied,
				"404":                BadRequest,
				"405":                BadRequest,
				"415":                BadRequest,
				"429":                DDoSProtection,
				"500":                ExchangeNotAvailable,
				"1001":               RateLimitExceeded,
				"1002":               ExchangeError,
				"1003":               ExchangeError,
				"40001":              AuthenticationError,
				"40002":              AuthenticationError,
				"40003":              AuthenticationError,
				"40004":              InvalidNonce,
				"40005":              InvalidNonce,
				"40006":              AuthenticationError,
				"40007":              BadRequest,
				"40008":              InvalidNonce,
				"40009":              AuthenticationError,
				"40010":              AuthenticationError,
				"40011":              AuthenticationError,
				"40012":              AuthenticationError,
				"40013":              ExchangeError,
				"40014":              PermissionDenied,
				"40015":              ExchangeError,
				"40016":              PermissionDenied,
				"40017":              ExchangeError,
				"40018":              PermissionDenied,
				"40019":              BadRequest,
				"40031":              AccountSuspended,
				"40037":              AuthenticationError,
				"40102":              BadRequest,
				"40103":              BadRequest,
				"40104":              ExchangeError,
				"40105":              ExchangeError,
				"40106":              ExchangeError,
				"40107":              ExchangeError,
				"40108":              InvalidOrder,
				"40109":              OrderNotFound,
				"40200":              OnMaintenance,
				"40201":              InvalidOrder,
				"40202":              ExchangeError,
				"40203":              BadRequest,
				"40204":              BadRequest,
				"40205":              BadRequest,
				"40206":              BadRequest,
				"40207":              BadRequest,
				"40208":              BadRequest,
				"40209":              BadRequest,
				"40300":              ExchangeError,
				"40301":              PermissionDenied,
				"40302":              BadRequest,
				"40303":              BadRequest,
				"40304":              BadRequest,
				"40305":              BadRequest,
				"40306":              ExchangeError,
				"40308":              OnMaintenance,
				"40309":              BadSymbol,
				"40400":              ExchangeError,
				"40401":              ExchangeError,
				"40402":              BadRequest,
				"40403":              BadRequest,
				"40404":              BadRequest,
				"40405":              BadRequest,
				"40406":              BadRequest,
				"40407":              ExchangeError,
				"40408":              ExchangeError,
				"40409":              ExchangeError,
				"40500":              InvalidOrder,
				"40501":              ExchangeError,
				"40502":              ExchangeError,
				"40503":              ExchangeError,
				"40504":              ExchangeError,
				"40505":              ExchangeError,
				"40506":              AuthenticationError,
				"40507":              AuthenticationError,
				"40508":              ExchangeError,
				"40509":              ExchangeError,
				"40600":              ExchangeError,
				"40601":              ExchangeError,
				"40602":              ExchangeError,
				"40603":              ExchangeError,
				"40604":              ExchangeNotAvailable,
				"40605":              ExchangeError,
				"40606":              ExchangeError,
				"40607":              ExchangeError,
				"40608":              ExchangeError,
				"40609":              ExchangeError,
				"40700":              BadRequest,
				"40701":              ExchangeError,
				"40702":              ExchangeError,
				"40703":              ExchangeError,
				"40704":              ExchangeError,
				"40705":              BadRequest,
				"40706":              InvalidOrder,
				"40707":              BadRequest,
				"40708":              BadRequest,
				"40709":              ExchangeError,
				"40710":              ExchangeError,
				"40711":              InsufficientFunds,
				"40712":              InsufficientFunds,
				"40713":              ExchangeError,
				"40714":              ExchangeError,
				"40762":              InsufficientFunds,
				"40768":              OrderNotFound,
				"40808":              InvalidOrder,
				"41103":              InvalidOrder,
				"41114":              OnMaintenance,
				"43011":              InvalidOrder,
				"43001":              OrderNotFound,
				"43012":              InsufficientFunds,
				"43025":              InvalidOrder,
				"43115":              OnMaintenance,
				"45110":              InvalidOrder,
				"40774":              InvalidOrder,
				"45122":              InvalidOrder,
				"invalid sign":       AuthenticationError,
				"invalid currency":   BadSymbol,
				"invalid symbol":     BadSymbol,
				"invalid period":     BadRequest,
				"invalid user":       ExchangeError,
				"invalid amount":     InvalidOrder,
				"invalid type":       InvalidOrder,
				"invalid orderId":    InvalidOrder,
				"invalid record":     ExchangeError,
				"invalid accountId":  BadRequest,
				"invalid address":    BadRequest,
				"accesskey not null": AuthenticationError,
				"illegal accesskey":  AuthenticationError,
				"sign not null":      AuthenticationError,
				"req_time is too much difference from server time": InvalidNonce,
				"permissions not right":                            PermissionDenied,
				"illegal sign invalid":                             AuthenticationError,
				"user locked":                                      AccountSuspended,
				"Request Frequency Is Too High":                    RateLimitExceeded,
				"more than a daily rate of cash":                   BadRequest,
				"more than the maximum daily withdrawal amount":    BadRequest,
				"need to bind email or mobile":                     ExchangeError,
				"user forbid":                                      PermissionDenied,
				"User Prohibited Cash Withdrawal":                  PermissionDenied,
				"Cash Withdrawal Is Less Than The Minimum Value":   BadRequest,
				"Cash Withdrawal Is More Than The Maximum Value":   BadRequest,
				"the account with in 24 hours ban coin":            PermissionDenied,
				"order cancel fail":                                BadRequest,
				"base symbol error":                                BadSymbol,
				"base date error":                                  ExchangeError,
				"api signature not valid":                          AuthenticationError,
				"gateway internal error":                           ExchangeError,
				"audit failed":                                     ExchangeError,
				"order queryorder invalid":                         BadRequest,
				"market no need price":                             InvalidOrder,
				"limit need price":                                 InvalidOrder,
				"userid not equal to account_id":                   ExchangeError,
				"your balance is low":                              InsufficientFunds,
				"address invalid cointype":                         ExchangeError,
				"system exception":                                 ExchangeError,
				"50003":                                            ExchangeError,
				"50004":                                            BadSymbol,
				"50006":                                            PermissionDenied,
				"50007":                                            PermissionDenied,
				"50008":                                            RequestTimeout,
				"50009":                                            RateLimitExceeded,
				"50010":                                            ExchangeError,
				"50014":                                            InvalidOrder,
				"50015":                                            InvalidOrder,
				"50016":                                            InvalidOrder,
				"50017":                                            InvalidOrder,
				"50018":                                            InvalidOrder,
				"50019":                                            InvalidOrder,
				"50020":                                            InsufficientFunds,
				"50021":                                            InvalidOrder,
				"50026":                                            InvalidOrder,
				"invalid order query time":                         ExchangeError,
				"invalid start time":                               BadRequest,
				"invalid end time":                                 BadRequest,
				"20003":                                            ExchangeError,
				"01001":                                            ExchangeError,
				"43111":                                            PermissionDenied,
			},
			"broad": map[string]interface{}{
				"invalid size, valid range": ExchangeError,
			},
		},
		"precisionMode": TICK_SIZE,
		"commonCurrencies": map[string]interface{}{
			"APX":     "AstroPepeX",
			"DEGEN":   "DegenReborn",
			"JADE":    "Jade Protocol",
			"OMNI":    "omni",
			"TONCOIN": "TON",
		},
		"options": map[string]interface{}{
			"uta":                     false,
			"timeDifference":          0,
			"adjustForTimeDifference": false,
			"timeframes": map[string]interface{}{
				"spot": map[string]interface{}{
					"1m":  "1min",
					"5m":  "5min",
					"15m": "15min",
					"30m": "30min",
					"1h":  "1h",
					"4h":  "4h",
					"6h":  "6Hutc",
					"12h": "12Hutc",
					"1d":  "1Dutc",
					"3d":  "3Dutc",
					"1w":  "1Wutc",
					"1M":  "1Mutc",
				},
				"swap": map[string]interface{}{
					"1m":  "1m",
					"3m":  "3m",
					"5m":  "5m",
					"15m": "15m",
					"30m": "30m",
					"1h":  "1H",
					"2h":  "2H",
					"4h":  "4H",
					"6h":  "6Hutc",
					"12h": "12Hutc",
					"1d":  "1Dutc",
					"3d":  "3Dutc",
					"1w":  "1Wutc",
					"1M":  "1Mutc",
				},
				"uta": map[string]interface{}{
					"1m":  "1m",
					"3m":  "3m",
					"5m":  "5m",
					"15m": "15m",
					"30m": "30m",
					"1h":  "1H",
					"2h":  "2H",
					"4h":  "4H",
					"6h":  "6H",
					"12h": "12H",
					"1d":  "1D",
				},
			},
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "swap"},
			},
			"defaultType":                       "spot",
			"defaultSubType":                    "linear",
			"createMarketBuyOrderRequiresPrice": true,
			"broker":                            "p4sve",
			"withdraw": map[string]interface{}{
				"fillResponseFromRequest": true,
			},
			"fetchOHLCV": map[string]interface{}{
				"maxRecentDaysPerTimeframe": map[string]interface{}{
					"1m":  30,
					"3m":  30,
					"5m":  30,
					"15m": 30,
					"30m": 30,
					"1h":  60,
					"4h":  240,
					"6h":  360,
					"12h": 720,
					"1d":  1440,
					"3d":  Multiply(1440, 3),
					"1w":  Multiply(1440, 7),
					"1M":  Multiply(1440, 30),
				},
				"spot": map[string]interface{}{
					"maxLimitPerTimeframe": map[string]interface{}{
						"1d": 300,
						"3d": 100,
						"1w": 100,
						"1M": 100,
					},
					"method": "publicSpotGetV2SpotMarketCandles",
				},
				"swap": map[string]interface{}{
					"maxLimitPerTimeframe": map[string]interface{}{
						"4h":  540,
						"6h":  360,
						"12h": 180,
						"1d":  90,
						"3d":  30,
						"1w":  13,
						"1M":  4,
					},
					"method": "publicMixGetV2MixMarketCandles",
				},
			},
			"fetchTrades": map[string]interface{}{
				"spot": map[string]interface{}{
					"method": "publicSpotGetV2SpotMarketFillsHistory",
				},
				"swap": map[string]interface{}{
					"method": "publicMixGetV2MixMarketFillsHistory",
				},
			},
			"fetchFundingRate": map[string]interface{}{
				"method": "publicMixGetV2MixMarketCurrentFundRate",
			},
			"accountsByType": map[string]interface{}{
				"spot":      "spot",
				"cross":     "crossed_margin",
				"isolated":  "isolated_margin",
				"swap":      "usdt_futures",
				"usdc_swap": "usdc_futures",
				"future":    "coin_futures",
				"p2p":       "p2p",
			},
			"accountsById": map[string]interface{}{
				"spot":            "spot",
				"crossed_margin":  "cross",
				"isolated_margin": "isolated",
				"usdt_futures":    "swap",
				"usdc_futures":    "usdc_swap",
				"coin_futures":    "future",
				"p2p":             "p2p",
			},
			"sandboxMode": false,
			"networks": map[string]interface{}{
				"TRC20":    "TRC20",
				"ERC20":    "ERC20",
				"BEP20":    "BSC",
				"ATOM":     "ATOM",
				"ACA":      "AcalaToken",
				"APT":      "Aptos",
				"ARBONE":   "ArbitrumOne",
				"ARBNOVA":  "ArbitrumNova",
				"AVAXC":    "C-Chain",
				"AVAXX":    "X-Chain",
				"AR":       "Arweave",
				"BCH":      "BCH",
				"BCHA":     "BCHA",
				"BITCI":    "BITCI",
				"BTC":      "BTC",
				"CELO":     "CELO",
				"CSPR":     "CSPR",
				"ADA":      "Cardano",
				"CHZ":      "ChilizChain",
				"CRC20":    "CronosChain",
				"DOGE":     "DOGE",
				"DOT":      "DOT",
				"EOS":      "EOS",
				"ETHF":     "ETHFAIR",
				"ETHW":     "ETHW",
				"ETC":      "ETC",
				"EGLD":     "Elrond",
				"FIL":      "FIL",
				"FIO":      "FIO",
				"FTM":      "Fantom",
				"HRC20":    "HECO",
				"ONE":      "Harmony",
				"HNT":      "Helium",
				"ICP":      "ICP",
				"IOTX":     "IoTeX",
				"KARDIA":   "KAI",
				"KAVA":     "KAVA",
				"KDA":      "KDA",
				"KLAY":     "Klaytn",
				"KSM":      "Kusama",
				"LAT":      "LAT",
				"LTC":      "LTC",
				"MINA":     "MINA",
				"MOVR":     "MOVR",
				"METIS":    "MetisToken",
				"GLMR":     "Moonbeam",
				"NEAR":     "NEARProtocol",
				"NULS":     "NULS",
				"OASYS":    "OASYS",
				"OASIS":    "ROSE",
				"OMNI":     "OMNI",
				"ONT":      "Ontology",
				"OPTIMISM": "Optimism",
				"OSMO":     "Osmosis",
				"POKT":     "PocketNetwork",
				"MATIC":    "Polygon",
				"QTUM":     "QTUM",
				"REEF":     "REEF",
				"SOL":      "SOL",
				"SYS":      "SYS",
				"SXP":      "Solar",
				"XYM":      "Symbol",
				"TON":      "TON",
				"TT":       "TT",
				"TLOS":     "Telos",
				"THETA":    "ThetaToken",
				"VITE":     "VITE",
				"WAVES":    "WAVES",
				"WAX":      "WAXP",
				"WEMIX":    "WEMIXMainnet",
				"XDC":      "XDCNetworkXDC",
				"XRP":      "XRP",
				"FET":      "FETCH",
				"NEM":      "NEM",
				"REI":      "REINetwork",
				"ZIL":      "ZIL",
				"ABBC":     "ABBCCoin",
				"RSK":      "RSK",
				"AZERO":    "AZERO",
				"TRC10":    "TRC10",
				"JUNO":     "JUNO",
				"ZKSYNC":   "zkSyncEra",
				"STARKNET": "Starknet",
				"VIC":      "VICTION",
			},
			"networksById": map[string]interface{}{},
			"fetchPositions": map[string]interface{}{
				"method": "privateMixGetV2MixPositionAllPosition",
			},
			"defaultTimeInForce": "GTC",
			"fiatCurrencies":     []interface{}{"EUR", "VND", "PLN", "CZK", "HUF", "DKK", "AUD", "CAD", "NOK", "SEK", "CHF", "MXN", "COP", "ARS", "GBP", "BRL", "UAH", "ZAR"},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":   true,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": false,
					},
					"triggerDirection": false,
					"stopLossPrice":    true,
					"takeProfitPrice":  true,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  false,
							"mark":  false,
							"index": false,
						},
						"price": true,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"marketBuyRequiresPrice": true,
					"marketBuyByCost":        true,
				},
				"createOrders": map[string]interface{}{
					"max": 50,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     true,
					"limit":          100,
					"daysBack":       nil,
					"untilDays":      90,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          100,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       true,
					"limit":            100,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        90,
					"trigger":          true,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 200,
				},
			},
			"forPerps": map[string]interface{}{
				"extends": "spot",
				"createOrder": map[string]interface{}{
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": false,
					},
					"triggerDirection": false,
					"stopLossPrice":    true,
					"takeProfitPrice":  true,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  true,
							"mark":  true,
							"index": true,
						},
						"price": false,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 true,
					"trailing":               true,
					"marketBuyRequiresPrice": false,
					"marketBuyByCost":        false,
				},
				"fetchMyTrades": map[string]interface{}{
					"untilDays": 7,
				},
				"fetchClosedOrders": map[string]interface{}{
					"trailing": true,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forPerps",
				},
				"inverse": map[string]interface{}{
					"extends": "forPerps",
				},
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forPerps",
				},
				"inverse": map[string]interface{}{
					"extends": "forPerps",
				},
			},
		},
	})
}
func (this *bitget) SetSandboxMode(enabled interface{}) {
	AddElementToObject(this.Options, "sandboxMode", enabled)
}
func (this *bitget) HandleProductTypeAndParams(optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var subType interface{} = nil
	subTypeparamsVariable := this.HandleSubTypeAndParams("handleProductTypeAndParams", nil, params)
	subType = GetValue(subTypeparamsVariable, 0)
	params = GetValue(subTypeparamsVariable, 1)
	var defaultProductType interface{} = nil
	if IsTrue(IsTrue((!IsEqual(subType, nil))) && IsTrue((IsEqual(market, nil)))) {
		// set default only if subType is defined and market is not defined, since there is also USDC productTypes which are also linear
		// const sandboxMode = this.safeBool (this.options, 'sandboxMode', false);
		// if (sandboxMode) {
		//     defaultProductType = (subType === 'linear') ? 'SUSDT-FUTURES' : 'SCOIN-FUTURES';
		// } else {
		defaultProductType = Ternary(IsTrue((IsEqual(subType, "linear"))), "USDT-FUTURES", "COIN-FUTURES")
	}
	var productType interface{} = this.SafeString2(params, "productType", "category", defaultProductType)
	if IsTrue(IsTrue((IsEqual(productType, nil))) && IsTrue((!IsEqual(market, nil)))) {
		var settle interface{} = GetValue(market, "settle")
		if IsTrue(GetValue(market, "spot")) {
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("handleProductTypeAndParams", params)
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			if IsTrue(!IsEqual(marginMode, nil)) {
				productType = "MARGIN"
			} else {
				productType = "SPOT"
			}
		} else if IsTrue(IsEqual(settle, "USDT")) {
			productType = "USDT-FUTURES"
		} else if IsTrue(IsEqual(settle, "USDC")) {
			productType = "USDC-FUTURES"
		} else if IsTrue(IsEqual(settle, "SUSDT")) {
			productType = "SUSDT-FUTURES"
		} else if IsTrue(IsEqual(settle, "SUSDC")) {
			productType = "SUSDC-FUTURES"
		} else if IsTrue(IsTrue(IsTrue((IsEqual(settle, "SBTC"))) || IsTrue((IsEqual(settle, "SETH")))) || IsTrue((IsEqual(settle, "SEOS")))) {
			productType = "SCOIN-FUTURES"
		} else {
			productType = "COIN-FUTURES"
		}
	}
	if IsTrue(IsEqual(productType, nil)) {
		panic(ArgumentsRequired(Add(this.Id, " requires a productType param, one of \"USDT-FUTURES\", \"USDC-FUTURES\", \"COIN-FUTURES\", \"SUSDT-FUTURES\", \"SUSDC-FUTURES\", \"SCOIN-FUTURES\" or for uta only \"SPOT\"")))
	}
	params = this.Omit(params, []interface{}{"productType", "category"})
	return []interface{}{productType, params}
}

/**
 * @method
 * @name bitget#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://www.bitget.com/api-doc/common/public/Get-Server-Time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *bitget) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicCommonGetV2PublicTime(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700111073740,
		//         "data": {
		//             "serverTime": "1700111073740"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.SafeInteger(data, "serverTime")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchMarkets
 * @description retrieves data on all markets for bitget
 * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
 * @see https://www.bitget.com/api-doc/margin/common/support-currencies
 * @see https://www.bitget.com/api-doc/uta/public/Instruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} an array of objects representing market data
 */
func (this *bitget) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes186912 := (<-this.LoadTimeDifference())
			PanicOnError(retRes186912)
		}
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchMarkets", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			retRes187419 := (<-this.FetchUtaMarkets(params))
			PanicOnError(retRes187419)
			ch <- retRes187419
			return nil
		} else {

			retRes187619 := (<-this.FetchDefaultMarkets(params))
			PanicOnError(retRes187619)
			ch <- retRes187619
			return nil
		}

	}()
	return ch
}
func (this *bitget) FetchDefaultMarkets(params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var types interface{} = nil
		var fetchMarketsOptions interface{} = this.SafeDict(this.Options, "fetchMarkets")
		var defaultMarkets interface{} = []interface{}{"spot", "swap"}
		if IsTrue(!IsEqual(fetchMarketsOptions, nil)) {
			types = this.SafeList(fetchMarketsOptions, "types", defaultMarkets)
		} else {
			// for backward-compatibility
			types = this.SafeList(this.Options, "fetchMarkets", defaultMarkets)
		}
		var promises interface{} = []interface{}{}
		var fetchMargins interface{} = false
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			var typeVar interface{} = GetValue(types, i)
			if IsTrue(IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future")))) {
				var subTypes interface{} = []interface{}{"USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES", "SUSDT-FUTURES", "SCOIN-FUTURES", "SUSDC-FUTURES"}
				for j := 0; IsLessThan(j, GetArrayLength(subTypes)); j++ {
					AppendToArray(&promises, this.PublicMixGetV2MixMarketContracts(this.Extend(params, map[string]interface{}{
						"productType": GetValue(subTypes, j),
					})))
				}
			} else if IsTrue(IsEqual(typeVar, "spot")) {
				AppendToArray(&promises, this.PublicSpotGetV2SpotPublicSymbols(params))
				fetchMargins = true
				AppendToArray(&promises, this.PublicMarginGetV2MarginCurrencies(params))
			} else {
				panic(NotSupported(Add(Add(Add(this.Id, " does not support "), typeVar), " market")))
			}
		}

		results := (<-promiseAll(promises))
		PanicOnError(results)
		var markets interface{} = []interface{}{}
		AddElementToObject(this.Options, "crossMarginPairsData", []interface{}{})
		AddElementToObject(this.Options, "isolatedMarginPairsData", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
			var res interface{} = this.SafeDict(results, i)
			var data interface{} = this.SafeList(res, "data", []interface{}{})
			var firstData interface{} = this.SafeDict(data, 0, map[string]interface{}{})
			var isBorrowable interface{} = this.SafeBool(firstData, "isBorrowable")
			if IsTrue(IsTrue(fetchMargins) && IsTrue(!IsEqual(isBorrowable, nil))) {
				var keysList interface{} = ObjectKeys(this.IndexBy(data, "symbol"))
				AddElementToObject(this.Options, "crossMarginPairsData", keysList)
				AddElementToObject(this.Options, "isolatedMarginPairsData", keysList)
			} else {
				markets = this.ArrayConcat(markets, data)
			}
		}
		//
		// spot
		//
		//     {
		//         "symbol": "TRXUSDT",
		//         "baseCoin": "TRX",
		//         "quoteCoin": "USDT",
		//         "minTradeAmount": "0",
		//         "maxTradeAmount": "10000000000",
		//         "takerFeeRate": "0.002",
		//         "makerFeeRate": "0.002",
		//         "pricePrecision": "6",
		//         "quantityPrecision": "4",
		//         "quotePrecision": "6",
		//         "status": "online",
		//         "minTradeUSDT": "5",
		//         "buyLimitPriceRatio": "0.05",
		//         "sellLimitPriceRatio": "0.05"
		//     }
		//
		// swap and future
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "baseCoin": "BTC",
		//         "quoteCoin": "USDT",
		//         "buyLimitPriceRatio": "0.01",
		//         "sellLimitPriceRatio": "0.01",
		//         "feeRateUpRatio": "0.005",
		//         "makerFeeRate": "0.0002",
		//         "takerFeeRate": "0.0006",
		//         "openCostUpRatio": "0.01",
		//         "supportMarginCoins": ["USDT"],
		//         "minTradeNum": "0.001",
		//         "priceEndStep": "1",
		//         "volumePlace": "3",
		//         "pricePlace": "1",
		//         "sizeMultiplier": "0.001",
		//         "symbolType": "perpetual",
		//         "minTradeUSDT": "5",
		//         "maxSymbolOrderNum": "200",
		//         "maxProductOrderNum": "400",
		//         "maxPositionNum": "150",
		//         "symbolStatus": "normal",
		//         "offTime": "-1",
		//         "limitOpenTime": "-1",
		//         "deliveryTime": "",
		//         "deliveryStartTime": "",
		//         "deliveryPeriod": "",
		//         "launchTime": "",
		//         "fundInterval": "8",
		//         "minLever": "1",
		//         "maxLever": "125",
		//         "posLimit": "0.05",
		//         "maintainTime": ""
		//     }
		//
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var marketId interface{} = this.SafeString(market, "symbol")
			var quoteId interface{} = this.SafeString(market, "quoteCoin")
			var baseId interface{} = this.SafeString(market, "baseCoin")
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var base interface{} = this.SafeCurrencyCode(baseId)
			var supportMarginCoins interface{} = this.SafeValue(market, "supportMarginCoins", []interface{}{})
			var settleId interface{} = nil
			if IsTrue(this.InArray(baseId, supportMarginCoins)) {
				settleId = baseId
			} else if IsTrue(this.InArray(quoteId, supportMarginCoins)) {
				settleId = quoteId
			} else {
				settleId = this.SafeString(supportMarginCoins, 0)
			}
			var settle interface{} = this.SafeCurrencyCode(settleId)
			var symbol interface{} = Add(Add(base, "/"), quote)
			var typeVar interface{} = nil
			var swap interface{} = false
			var spot interface{} = false
			var future interface{} = false
			var contract interface{} = false
			var pricePrecision interface{} = nil
			var amountPrecision interface{} = nil
			var linear interface{} = nil
			var inverse interface{} = nil
			var expiry interface{} = nil
			var expiryDatetime interface{} = nil
			var symbolType interface{} = this.SafeString(market, "symbolType")
			var marginModes interface{} = nil
			var isMarginTradingAllowed interface{} = false
			if IsTrue(IsEqual(symbolType, nil)) {
				typeVar = "spot"
				spot = true
				pricePrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision")))
				amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision")))
				var hasCrossMargin interface{} = this.InArray(marketId, GetValue(this.Options, "crossMarginPairsData"))
				var hasIsolatedMargin interface{} = this.InArray(marketId, GetValue(this.Options, "isolatedMarginPairsData"))
				marginModes = map[string]interface{}{
					"cross":    hasCrossMargin,
					"isolated": hasIsolatedMargin,
				}
				isMarginTradingAllowed = IsTrue(hasCrossMargin) || IsTrue(hasIsolatedMargin)
			} else {
				if IsTrue(IsEqual(symbolType, "perpetual")) {
					typeVar = "swap"
					swap = true
					symbol = Add(Add(symbol, ":"), settle)
				} else if IsTrue(IsEqual(symbolType, "delivery")) {
					expiry = this.SafeInteger(market, "deliveryTime")
					expiryDatetime = this.Iso8601(expiry)
					var expiryParts interface{} = Split(expiryDatetime, "-")
					var yearPart interface{} = this.SafeString(expiryParts, 0)
					var dayPart interface{} = this.SafeString(expiryParts, 2)
					var year interface{} = Slice(yearPart, 2, 4)
					var month interface{} = this.SafeString(expiryParts, 1)
					var day interface{} = Slice(dayPart, 0, 2)
					var expiryString interface{} = Add(Add(year, month), day)
					typeVar = "future"
					future = true
					symbol = Add(Add(Add(Add(symbol, ":"), settle), "-"), expiryString)
				}
				contract = true
				inverse = (IsEqual(base, settle))
				linear = !IsTrue(inverse)
				var priceDecimals interface{} = this.SafeInteger(market, "pricePlace")
				var amountDecimals interface{} = this.SafeInteger(market, "volumePlace")
				var priceStep interface{} = this.SafeString(market, "priceEndStep")
				var amountStep interface{} = this.SafeString(market, "sizeMultiplier")
				precise := NewPrecise(priceStep)
				precise.Decimals = mathMax(precise.Decimals, priceDecimals)
				precise.Reduce()
				var priceString interface{} = precise.ToString()
				pricePrecision = this.ParseNumber(priceString)
				preciseAmount := NewPrecise(amountStep)
				preciseAmount.Decimals = mathMax(preciseAmount.Decimals, amountDecimals)
				preciseAmount.Reduce()
				var amountString interface{} = preciseAmount.ToString()
				amountPrecision = this.ParseNumber(amountString)
				marginModes = map[string]interface{}{
					"cross":    true,
					"isolated": true,
				}
			}
			var status interface{} = this.SafeString2(market, "status", "symbolStatus")
			var active interface{} = nil
			if IsTrue(!IsEqual(status, nil)) {
				active = (IsTrue((IsEqual(status, "online"))) || IsTrue((IsEqual(status, "normal"))))
			}
			var minCost interface{} = nil
			if IsTrue(IsEqual(quote, "USDT")) {
				minCost = this.SafeNumber(market, "minTradeUSDT")
			}
			var contractSize interface{} = Ternary(IsTrue(contract), 1, nil)
			AppendToArray(&result, this.SafeMarketStructure(map[string]interface{}{
				"id":             marketId,
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           typeVar,
				"spot":           spot,
				"margin":         IsTrue(spot) && IsTrue(isMarginTradingAllowed),
				"marginModes":    marginModes,
				"swap":           swap,
				"future":         future,
				"option":         false,
				"active":         active,
				"contract":       contract,
				"linear":         linear,
				"inverse":        inverse,
				"taker":          this.SafeNumber(market, "takerFeeRate"),
				"maker":          this.SafeNumber(market, "makerFeeRate"),
				"contractSize":   contractSize,
				"expiry":         expiry,
				"expiryDatetime": expiryDatetime,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": amountPrecision,
					"price":  pricePrecision,
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": this.SafeNumber(market, "minLever"),
						"max": this.SafeNumber(market, "maxLever"),
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber2(market, "minTradeNum", "minTradeAmount"),
						"max": this.SafeNumber(market, "maxTradeAmount"),
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": minCost,
						"max": nil,
					},
				},
				"created": this.SafeInteger(market, "launchTime"),
				"info":    market,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *bitget) FetchUtaMarkets(params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var subTypes interface{} = []interface{}{"SPOT", "USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES"}
		var promises interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(subTypes)); i++ {
			var req interface{} = this.Extend(params, map[string]interface{}{
				"category": GetValue(subTypes, i),
			})
			AppendToArray(&promises, this.PublicUtaGetV3MarketInstruments(req))
		}

		results := (<-promiseAll(promises))
		PanicOnError(results)
		var markets interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
			var res interface{} = this.SafeDict(results, i)
			var data interface{} = this.SafeList(res, "data", []interface{}{})
			markets = this.ArrayConcat(markets, data)
		}
		//
		// spot uta
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "category": "SPOT",
		//         "baseCoin": "BTC",
		//         "quoteCoin": "USDT",
		//         "buyLimitPriceRatio": "0.05",
		//         "sellLimitPriceRatio": "0.05",
		//         "minOrderQty": "0.000001",
		//         "maxOrderQty": "0",
		//         "pricePrecision": "2",
		//         "quantityPrecision": "6",
		//         "quotePrecision": "8",
		//         "minOrderAmount": "1",
		//         "maxSymbolOrderNum": "400",
		//         "maxProductOrderNum": "400",
		//         "status": "online",
		//         "maintainTime": ""
		//     }
		//
		// margin uta
		//
		//     {
		//         "symbol": "BTCUSDC",
		//         "category": "MARGIN",
		//         "baseCoin": "BTC",
		//         "quoteCoin": "USDC",
		//         "buyLimitPriceRatio": "0.05",
		//         "sellLimitPriceRatio": "0.05",
		//         "minOrderQty": "0.00001",
		//         "maxOrderQty": "0",
		//         "pricePrecision": "2",
		//         "quantityPrecision": "5",
		//         "quotePrecision": "7",
		//         "minOrderAmount": "1",
		//         "maxSymbolOrderNum": "400",
		//         "maxProductOrderNum": "400",
		//         "status": "online",
		//         "maintainTime": "",
		//         "isIsolatedBaseBorrowable": "NO",
		//         "isIsolatedQuotedBorrowable": "NO",
		//         "warningRiskRatio": "0.8",
		//         "liquidationRiskRatio": "1",
		//         "maxCrossedLeverage": "3",
		//         "maxIsolatedLeverage": "0",
		//         "userMinBorrow": "0.00000001",
		//         "areaSymbol": "no"
		//     }
		//
		// swap and future uta
		//
		//     {
		//         "symbol": "BTCPERP",
		//         "category": "USDC-FUTURES",
		//         "baseCoin": "BTC",
		//         "quoteCoin": "USDC",
		//         "buyLimitPriceRatio": "0.02",
		//         "sellLimitPriceRatio": "0.02",
		//         "feeRateUpRatio": "0.005",
		//         "makerFeeRate": "0.0002",
		//         "takerFeeRate": "0.0006",
		//         "openCostUpRatio": "0.01",
		//         "minOrderQty": "0.0001",
		//         "maxOrderQty": "",
		//         "pricePrecision": "1",
		//         "quantityPrecision": "4",
		//         "quotePrecision": null,
		//         "priceMultiplier": "0.5",
		//         "quantityMultiplier": "0.0001",
		//         "type": "perpetual",
		//         "minOrderAmount": "5",
		//         "maxSymbolOrderNum": "200",
		//         "maxProductOrderNum": "1000",
		//         "maxPositionNum": "150",
		//         "status": "online",
		//         "offTime": "-1",
		//         "limitOpenTime": "-1",
		//         "deliveryTime": "",
		//         "deliveryStartTime": "",
		//         "deliveryPeriod": "",
		//         "launchTime": "",
		//         "fundInterval": "8",
		//         "minLeverage": "1",
		//         "maxLeverage": "125",
		//         "maintainTime": ""
		//     }
		//
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var category interface{} = this.SafeString(market, "category")
			var marketId interface{} = this.SafeString(market, "symbol")
			var quoteId interface{} = this.SafeString(market, "quoteCoin")
			var baseId interface{} = this.SafeString(market, "baseCoin")
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var base interface{} = this.SafeCurrencyCode(baseId)
			var settleId interface{} = nil
			var settle interface{} = nil
			if IsTrue(IsEqual(category, "USDT-FUTURES")) {
				settleId = "USDT"
			} else if IsTrue(IsEqual(category, "USDC-FUTURES")) {
				settleId = "USDC"
			} else if IsTrue(IsEqual(category, "COIN-FUTURES")) {
				settleId = base
			}
			if IsTrue(!IsEqual(settleId, nil)) {
				settle = this.SafeCurrencyCode(settleId)
			}
			var symbol interface{} = Add(Add(base, "/"), quote)
			var typeVar interface{} = nil
			var swap interface{} = false
			var spot interface{} = false
			var future interface{} = false
			var contract interface{} = false
			var pricePrecision interface{} = nil
			var amountPrecision interface{} = nil
			var linear interface{} = nil
			var inverse interface{} = nil
			var expiry interface{} = nil
			var expiryDatetime interface{} = nil
			var symbolType interface{} = this.SafeString(market, "type")
			var marginModes interface{} = nil
			var isMarginTradingAllowed interface{} = false
			var isUtaMargin interface{} = (IsEqual(category, "MARGIN"))
			if IsTrue(IsTrue(isUtaMargin) || IsTrue((IsEqual(category, "SPOT")))) {
				typeVar = "spot"
				spot = true
				if IsTrue(isUtaMargin) {
					var isolatedBase interface{} = this.SafeString(market, "isIsolatedBaseBorrowable")
					var isolatedQuote interface{} = this.SafeString(market, "isIsolatedQuotedBorrowable")
					var isolated interface{} = IsTrue((IsEqual(isolatedBase, "YES"))) || IsTrue((IsEqual(isolatedQuote, "YES")))
					var maxCrossLeverage interface{} = this.SafeString(market, "maxCrossedLeverage")
					var cross interface{} = (!IsEqual(maxCrossLeverage, "0"))
					marginModes = map[string]interface{}{
						"cross":    cross,
						"isolated": isolated,
					}
					isMarginTradingAllowed = true
				}
			} else {
				if IsTrue(IsEqual(symbolType, "perpetual")) {
					typeVar = "swap"
					swap = true
					symbol = Add(Add(symbol, ":"), settle)
				} else if IsTrue(IsEqual(symbolType, "delivery")) {
					expiry = this.SafeInteger(market, "deliveryTime")
					expiryDatetime = this.Iso8601(expiry)
					var expiryParts interface{} = Split(expiryDatetime, "-")
					var yearPart interface{} = this.SafeString(expiryParts, 0)
					var dayPart interface{} = this.SafeString(expiryParts, 2)
					var year interface{} = Slice(yearPart, 2, 4)
					var month interface{} = this.SafeString(expiryParts, 1)
					var day interface{} = Slice(dayPart, 0, 2)
					var expiryString interface{} = Add(Add(year, month), day)
					typeVar = "future"
					future = true
					symbol = Add(Add(Add(Add(symbol, ":"), settle), "-"), expiryString)
				}
				contract = true
				inverse = (IsEqual(base, settle))
				linear = !IsTrue(inverse)
				marginModes = map[string]interface{}{
					"cross":    true,
					"isolated": true,
				}
			}
			pricePrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision")))
			amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision")))
			var status interface{} = this.SafeString(market, "status")
			var active interface{} = nil
			if IsTrue(!IsEqual(status, nil)) {
				active = (IsTrue((IsEqual(status, "online"))) || IsTrue((IsEqual(status, "normal"))))
			}
			var contractSize interface{} = Ternary(IsTrue(contract), 1, nil)
			AppendToArray(&result, this.SafeMarketStructure(map[string]interface{}{
				"id":             marketId,
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           typeVar,
				"spot":           spot,
				"margin":         IsTrue(spot) && IsTrue(isMarginTradingAllowed),
				"marginModes":    marginModes,
				"swap":           swap,
				"future":         future,
				"option":         false,
				"active":         active,
				"contract":       contract,
				"linear":         linear,
				"inverse":        inverse,
				"taker":          this.SafeNumber(market, "takerFeeRate"),
				"maker":          this.SafeNumber(market, "makerFeeRate"),
				"contractSize":   contractSize,
				"expiry":         expiry,
				"expiryDatetime": expiryDatetime,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": amountPrecision,
					"price":  pricePrecision,
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": this.SafeNumber(market, "minLeverage"),
						"max": this.SafeNumber(market, "maxLeverage"),
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "minOrderQty"),
						"max": this.SafeNumber(market, "maxOrderQty"),
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": this.SafeInteger(market, "launchTime"),
				"info":    market,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *bitget) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicSpotGetV2SpotPublicCoins(params))
		PanicOnError(response)
		//
		//    {
		//        "code": "00000",
		//        "msg": "success",
		//        "requestTime": "1746195617812",
		//        "data": [
		//            {
		//                "coinId": "1456",
		//                "coin": "NEIROETH",
		//                "transfer": "false",
		//                "chains": [
		//                    {
		//                        "chain": "ERC20",
		//                        "needTag": "false",
		//                        "withdrawable": "true",
		//                        "rechargeable": "true",
		//                        "withdrawFee": "44.91017965",
		//                        "extraWithdrawFee": "0",
		//                        "depositConfirm": "12",
		//                        "withdrawConfirm": "64",
		//                        "minDepositAmount": "0.06",
		//                        "minWithdrawAmount": "60",
		//                        "browserUrl": "https://etherscan.io/tx/",
		//                        "contractAddress": "0xee2a03aa6dacf51c18679c516ad5283d8e7c2637",
		//                        "withdrawStep": "0",
		//                        "withdrawMinScale": "8",
		//                        "congestion": "normal"
		//                    }
		//                ],
		//                "areaCoin": "no"
		//            },
		//            ...
		//
		var result interface{} = map[string]interface{}{}
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var fiatCurrencies interface{} = this.SafeList(this.Options, "fiatCurrencies", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var id interface{} = this.SafeString(entry, "coin") // we don't use 'coinId' as it has no use. it is 'coin' field that needs to be used in currency related endpoints (deposit, withdraw, etc..)
			var code interface{} = this.SafeCurrencyCode(id)
			var chains interface{} = this.SafeValue(entry, "chains", []interface{}{})
			var networks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString(chain, "chain")
				var network interface{} = this.NetworkIdToCode(networkId, code)
				network = ToUpper(network)
				AddElementToObject(networks, network, map[string]interface{}{
					"info":    chain,
					"id":      networkId,
					"network": network,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(chain, "minWithdrawAmount"),
							"max": nil,
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(chain, "minDepositAmount"),
							"max": nil,
						},
					},
					"active":    nil,
					"withdraw":  IsEqual(this.SafeString(chain, "withdrawable"), "true"),
					"deposit":   IsEqual(this.SafeString(chain, "rechargeable"), "true"),
					"fee":       this.SafeNumber(chain, "withdrawFee"),
					"precision": this.ParseNumber(this.ParsePrecision(this.SafeString(chain, "withdrawMinScale"))),
				})
			}
			var isFiat interface{} = this.InArray(code, fiatCurrencies)
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      entry,
				"id":        id,
				"code":      code,
				"networks":  networks,
				"type":      Ternary(IsTrue(isFiat), "fiat", "crypto"),
				"name":      nil,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
 * @see https://www.bitget.com/api-doc/contract/position/Get-Query-Position-Lever
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Tier-Data
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Tier-Data
 * @see https://www.bitget.com/api-doc/uta/public/Get-Position-Tier-Data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] for spot margin 'cross' or 'isolated', default is 'isolated'
 * @param {string} [params.code] required for cross spot margin
 * @param {string} [params.productType] *contract and uta only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func (this *bitget) FetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes25118 := (<-this.LoadMarkets())
		PanicOnError(retRes25118)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		var marginMode interface{} = nil
		var productType interface{} = nil
		var uta interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMarketLeverageTiers", params, "isolated")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchMarketLeverageTiers", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(IsEqual(productType, "SPOT")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					productType = "MARGIN"
				}
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketPositionTier(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
			AddElementToObject(request, "productType", productType)
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.PublicMixGetV2MixMarketQueryPositionLever(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "isolated")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.PrivateMarginGetV2MarginIsolatedTierData(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "cross")) {
			var code interface{} = this.SafeString(params, "code")
			if IsTrue(IsEqual(code, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchMarketLeverageTiers() requires a code argument")))
			}
			params = this.Omit(params, "code")
			var currency interface{} = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))

			response = (<-this.PrivateMarginGetV2MarginCrossedTierData(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(BadRequest(Add(Add(this.Id, " fetchMarketLeverageTiers() symbol does not support market "), GetValue(market, "symbol"))))
		}
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700290724614,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT",
		//                 "level": "1",
		//                 "startUnit": "0",
		//                 "endUnit": "150000",
		//                 "leverage": "125",
		//                 "keepMarginRate": "0.004"
		//             },
		//         ]
		//     }
		//
		// isolated
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700291531894,
		//         "data": [
		//             {
		//                 "tier": "1",
		//                 "symbol": "BTCUSDT",
		//                 "leverage": "10",
		//                 "baseCoin": "BTC",
		//                 "quoteCoin": "USDT",
		//                 "baseMaxBorrowableAmount": "2",
		//                 "quoteMaxBorrowableAmount": "24000",
		//                 "maintainMarginRate": "0.05",
		//                 "initRate": "0.1111"
		//             },
		//         ]
		//     }
		//
		// cross
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700291818831,
		//         "data": [
		//             {
		//                 "tier": "1",
		//                 "leverage": "3",
		//                 "coin": "BTC",
		//                 "maxBorrowableAmount": "26",
		//                 "maintainMarginRate": "0.1"
		//             }
		//         ]
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1752735673127,
		//         "data": [
		//             {
		//                 "tier": "1",
		//                 "minTierValue": "0",
		//                 "maxTierValue": "150000",
		//                 "leverage": "125",
		//                 "mmr": "0.004"
		//             },
		//         ]
		//     }
		//
		var result interface{} = this.SafeValue(response, "data", []interface{}{})

		ch <- this.ParseMarketLeverageTiers(result, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// swap and future
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "level": "1",
	//         "startUnit": "0",
	//         "endUnit": "150000",
	//         "leverage": "125",
	//         "keepMarginRate": "0.004"
	//     }
	//
	// isolated
	//
	//     {
	//         "tier": "1",
	//         "symbol": "BTCUSDT",
	//         "leverage": "10",
	//         "baseCoin": "BTC",
	//         "quoteCoin": "USDT",
	//         "baseMaxBorrowableAmount": "2",
	//         "quoteMaxBorrowableAmount": "24000",
	//         "maintainMarginRate": "0.05",
	//         "initRate": "0.1111"
	//     }
	//
	// cross
	//
	//     {
	//         "tier": "1",
	//         "leverage": "3",
	//         "coin": "BTC",
	//         "maxBorrowableAmount": "26",
	//         "maintainMarginRate": "0.1"
	//     }
	//
	// uta
	//
	//     {
	//         "tier": "1",
	//         "minTierValue": "0",
	//         "maxTierValue": "150000",
	//         "leverage": "125",
	//         "mmr": "0.004"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var tiers interface{} = []interface{}{}
	var minNotional interface{} = 0
	for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
		var item interface{} = GetValue(info, i)
		var minimumNotional interface{} = this.SafeNumber2(item, "startUnit", "minTierValue")
		if IsTrue(!IsEqual(minimumNotional, nil)) {
			minNotional = minimumNotional
		}
		var maxNotional interface{} = this.SafeNumberN(item, []interface{}{"endUnit", "maxBorrowableAmount", "baseMaxBorrowableAmount", "maxTierValue"})
		var marginCurrency interface{} = this.SafeString2(item, "coin", "baseCoin")
		var currencyId interface{} = Ternary(IsTrue((!IsEqual(marginCurrency, nil))), marginCurrency, GetValue(market, "base"))
		var marketId interface{} = this.SafeString(item, "symbol")
		AppendToArray(&tiers, map[string]interface{}{
			"tier":                  this.SafeInteger2(item, "level", "tier"),
			"symbol":                this.SafeSymbol(marketId, market),
			"currency":              this.SafeCurrencyCode(currencyId),
			"minNotional":           minNotional,
			"maxNotional":           maxNotional,
			"maintenanceMarginRate": this.SafeNumberN(item, []interface{}{"keepMarginRate", "maintainMarginRate", "mmr"}),
			"maxLeverage":           this.SafeNumber(item, "leverage"),
			"info":                  item,
		})
		minNotional = maxNotional
	}
	return tiers
}

/**
 * @method
 * @name bitget#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Record
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in milliseconds
 * @param {string} [params.idLessThan] return records with id less than the provided value
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bitget) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27168 := (<-this.LoadMarkets())
		PanicOnError(retRes27168)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes272019 := (<-this.FetchPaginatedCallCursor("fetchDeposits", nil, since, limit, params, "idLessThan", "idLessThan", nil, 100))
			PanicOnError(retRes272019)
			ch <- retRes272019
			return nil
		}
		if IsTrue(IsEqual(since, nil)) {
			since = Subtract(this.Milliseconds(), 7776000000) // 90 days
		}
		var request interface{} = map[string]interface{}{
			"startTime": since,
			"endTime":   this.Milliseconds(),
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.PrivateSpotGetV2SpotWalletDepositRecords(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700528340608,
		//         "data": [
		//             {
		//                 "orderId": "1083832260799930368",
		//                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
		//                 "coin": "BTC",
		//                 "type": "deposit",
		//                 "size": "0.00030000",
		//                 "status": "success",
		//                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
		//                 "dest": "on_chain",
		//                 "chain": "BTC",
		//                 "fromAddress": null,
		//                 "cTime": "1694131668281",
		//                 "uTime": "1694131680247"
		//             }
		//         ]
		//     }
		//
		var rawTransactions interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(rawTransactions, nil, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#withdraw
 * @description make a withdrawal
 * @see https://www.bitget.com/api-doc/spot/account/Wallet-Withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.chain] the blockchain network the withdrawal is taking place on
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bitget) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		this.CheckAddress(address)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a \"network\" parameter")))
		}

		retRes27868 := (<-this.LoadMarkets())
		PanicOnError(retRes27868)
		var currency interface{} = this.Currency(code)
		var networkId interface{} = this.NetworkCodeToId(networkCode)
		var request interface{} = map[string]interface{}{
			"coin":         GetValue(currency, "id"),
			"address":      address,
			"chain":        networkId,
			"size":         this.CurrencyToPrecision(code, amount, networkCode),
			"transferType": "on_chain",
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "tag", tag)
		}

		response := (<-this.PrivateSpotPostV2SpotWalletWithdrawal(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//          "code":"00000",
		//          "msg":"success",
		//          "requestTime":1696784219602,
		//          "data": {
		//              "orderId":"1094957867615789056",
		//              "clientOid":"64f1e4ce842041d296b4517df1b5c2d7"
		//          }
		//      }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var result interface{} = this.ParseTransaction(data, currency)
		AddElementToObject(result, "type", "withdrawal")
		var withdrawOptions interface{} = this.SafeValue(this.Options, "withdraw", map[string]interface{}{})
		var fillResponseFromRequest interface{} = this.SafeBool(withdrawOptions, "fillResponseFromRequest", true)
		if IsTrue(fillResponseFromRequest) {
			AddElementToObject(result, "currency", code)
			AddElementToObject(result, "amount", amount)
			AddElementToObject(result, "tag", tag)
			AddElementToObject(result, "address", address)
			AddElementToObject(result, "addressTo", address)
			AddElementToObject(result, "network", networkCode)
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Withdraw-Record
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in milliseconds
 * @param {string} [params.idLessThan] return records with id less than the provided value
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bitget) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28428 := (<-this.LoadMarkets())
		PanicOnError(retRes28428)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes284619 := (<-this.FetchPaginatedCallCursor("fetchWithdrawals", nil, since, limit, params, "idLessThan", "idLessThan", nil, 100))
			PanicOnError(retRes284619)
			ch <- retRes284619
			return nil
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		if IsTrue(IsEqual(since, nil)) {
			since = Subtract(this.Milliseconds(), 7776000000) // 90 days
		}
		var request interface{} = map[string]interface{}{
			"startTime": since,
			"endTime":   this.Milliseconds(),
		}
		if IsTrue(!IsEqual(currency, nil)) {
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateSpotGetV2SpotWalletWithdrawalRecords(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700528340608,
		//         "data": [
		//             {
		//                 "orderId": "1083832260799930368",
		//                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
		//                 "clientOid": "123",
		//                 "coin": "BTC",
		//                 "type": "withdraw",
		//                 "size": "0.00030000",
		//                 "fee": "-1.0000000",
		//                 "status": "success",
		//                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
		//                 "dest": "on_chain",
		//                 "chain": "BTC",
		//                 "confirm": "100",
		//                 "fromAddress": null,
		//                 "cTime": "1694131668281",
		//                 "uTime": "1694131680247"
		//             }
		//         ]
		//     }
		//
		var rawTransactions interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(rawTransactions, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "orderId": "1083832260799930368",
	//         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
	//         "coin": "BTC",
	//         "type": "deposit",
	//         "size": "0.00030000",
	//         "status": "success",
	//         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
	//         "dest": "on_chain",
	//         "chain": "BTC",
	//         "fromAddress": null,
	//         "cTime": "1694131668281",
	//         "uTime": "1694131680247"
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "orderId": "1083832260799930368",
	//         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
	//         "clientOid": "123",
	//         "coin": "BTC",
	//         "type": "withdraw",
	//         "size": "0.00030000",
	//         "fee": "-1.0000000",
	//         "status": "success",
	//         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
	//         "dest": "on_chain",
	//         "chain": "BTC",
	//         "confirm": "100",
	//         "fromAddress": null,
	//         "cTime": "1694131668281",
	//         "uTime": "1694131680247"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(transaction, "coin")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var timestamp interface{} = this.SafeInteger(transaction, "cTime")
	var networkId interface{} = this.SafeString(transaction, "chain")
	var status interface{} = this.SafeString(transaction, "status")
	var tag interface{} = this.SafeString(transaction, "tag")
	var feeCostString interface{} = this.SafeString(transaction, "fee")
	var feeCostAbsString interface{} = nil
	if IsTrue(!IsEqual(feeCostString, nil)) {
		feeCostAbsString = Precise.StringAbs(feeCostString)
	}
	var fee interface{} = nil
	var amountString interface{} = this.SafeString(transaction, "size")
	if IsTrue(!IsEqual(feeCostAbsString, nil)) {
		fee = map[string]interface{}{
			"currency": code,
			"cost":     this.ParseNumber(feeCostAbsString),
		}
		amountString = Precise.StringSub(amountString, feeCostAbsString)
	}
	return map[string]interface{}{
		"id":          this.SafeString(transaction, "orderId"),
		"info":        transaction,
		"txid":        this.SafeString(transaction, "tradeId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     this.NetworkIdToCode(networkId),
		"addressFrom": this.SafeString(transaction, "fromAddress"),
		"address":     this.SafeString(transaction, "toAddress"),
		"addressTo":   this.SafeString(transaction, "toAddress"),
		"amount":      this.ParseNumber(amountString),
		"type":        this.SafeString(transaction, "type"),
		"currency":    code,
		"status":      this.ParseTransactionStatus(status),
		"updated":     this.SafeInteger(transaction, "uTime"),
		"tagFrom":     nil,
		"tag":         tag,
		"tagTo":       tag,
		"comment":     nil,
		"internal":    nil,
		"fee":         fee,
	}
}
func (this *bitget) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"success":             "ok",
		"Pending":             "pending",
		"pending_review":      "pending",
		"pending_review_fail": "failed",
		"reject":              "failed",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bitget#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *bitget) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes29988 := (<-this.LoadMarkets())
		PanicOnError(retRes29988)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin": GetValue(currency, "id"),
		}
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode, code))
		}

		response := (<-this.PrivateSpotGetV2SpotWalletDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700532244807,
		//         "data": {
		//             "coin": "BTC",
		//             "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
		//             "chain": "",
		//             "tag": null,
		//             "url": "https://blockchair.com/bitcoin/transaction/"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseDepositAddress(data, currency)
		return nil

	}()
	return ch
}
func (this *bitget) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "coin": "BTC",
	//         "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
	//         "chain": "",
	//         "tag": null,
	//         "url": "https://blockchair.com/bitcoin/transaction/"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(depositAddress, "coin")
	var networkId interface{} = this.SafeString(depositAddress, "chain")
	var parsedCurrency interface{} = this.SafeCurrencyCode(currencyId, currency)
	var network interface{} = nil
	if IsTrue(!IsEqual(networkId, nil)) {
		network = this.NetworkIdToCode(networkId, parsedCurrency)
	}
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": parsedCurrency,
		"network":  network,
		"address":  this.SafeString(depositAddress, "address"),
		"tag":      this.SafeString(depositAddress, "tag"),
	}
}

/**
 * @method
 * @name bitget#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitget.com/api-doc/spot/market/Get-Orderbook
 * @see https://www.bitget.com/api-doc/contract/market/Get-Merge-Depth
 * @see https://www.bitget.com/api-doc/uta/public/OrderBook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *bitget) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes30678 := (<-this.LoadMarkets())
		PanicOnError(retRes30678)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchOrderBook", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketOrderbook(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PublicSpotGetV2SpotMarketOrderbook(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketMergeDepth(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//       "code": "00000",
		//       "msg": "success",
		//       "requestTime": 1645854610294,
		//       "data": {
		//         "asks": [ [ "39102", "11.026" ] ],
		//         "bids": [ [ '39100.5', "1.773" ] ],
		//         "ts": "1645854610294"
		//       }
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750329437753,
		//         "data": {
		//             "a": [ [ 104992.60, 0.018411 ] ],
		//             "b":[ [104927.40, 0.229914 ] ],
		//             "ts": "1750329437763"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var bidsKey interface{} = Ternary(IsTrue(uta), "b", "bids")
		var asksKey interface{} = Ternary(IsTrue(uta), "a", "asks")
		var timestamp interface{} = this.SafeInteger(data, "ts")

		ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, bidsKey, asksKey)
		return nil

	}()
	return ch
}
func (this *bitget) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//   {
	//       "symbol": "BTCUSDT",
	//       "price": "26242",
	//       "indexPrice": "34867",
	//       "markPrice": "25555",
	//       "ts": "1695793390482"
	//   }
	//
	// spot
	//
	//     {
	//         "open": "37202.46",
	//         "symbol": "BTCUSDT",
	//         "high24h": "37744.75",
	//         "low24h": "36666",
	//         "lastPr": "37583.69",
	//         "quoteVolume": "519127705.303",
	//         "baseVolume": "13907.0386",
	//         "usdtVolume": "519127705.302908",
	//         "ts": "1700532903261",
	//         "bidPr": "37583.68",
	//         "askPr": "37583.69",
	//         "bidSz": "0.0007",
	//         "askSz": "0.0829",
	//         "openUtc": "37449.4",
	//         "changeUtc24h": "0.00359",
	//         "change24h": "0.00321"
	//     }
	//
	// swap and future
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "lastPr": "104823.8",
	//         "askPr": "104823.8",
	//         "bidPr": "104823.5",
	//         "bidSz": "0.703",
	//         "askSz": "13.894",
	//         "high24h": "105289.3",
	//         "low24h": "103447.9",
	//         "ts": "1750332210370",
	//         "change24h": "0.00471",
	//         "baseVolume": "79089.5675",
	//         "quoteVolume": "8274870921.80485",
	//         "usdtVolume": "8274870921.80485",
	//         "openUtc": "104833",
	//         "changeUtc24h": "-0.00009",
	//         "indexPrice": "104881.953125",
	//         "fundingRate": "-0.000014",
	//         "holdingAmount": "7452.6421",
	//         "deliveryStartTime": null,
	//         "deliveryTime": null,
	//         "deliveryStatus": "",
	//         "open24h": "104332.3",
	//         "markPrice": "104824.2"
	//     }
	//
	// spot uta
	//
	//     {
	//         "category": "SPOT",
	//         "symbol": "BTCUSDT",
	//         "ts": "1750330651972",
	//         "lastPrice": "104900.2",
	//         "openPrice24h": "104321.2",
	//         "highPrice24h": "107956.8",
	//         "lowPrice24h": "103600.1",
	//         "ask1Price": "104945.8",
	//         "bid1Price": "104880.6",
	//         "bid1Size": "0.266534",
	//         "ask1Size": "0.014001",
	//         "price24hPcnt": "0.00555",
	//         "volume24h": "355.941109",
	//         "turnover24h": "37302936.008134"
	//     }
	//
	// swap and future uta
	//
	//     {
	//         "category": "USDT-FUTURES",
	//         "symbol": "BTCUSDT",
	//         "ts": "1750332730472",
	//         "lastPrice": "104738",
	//         "openPrice24h": "104374",
	//         "highPrice24h": "105289.3",
	//         "lowPrice24h": "103447.9",
	//         "ask1Price": "104738",
	//         "bid1Price": "104737.7",
	//         "bid1Size": "2.036",
	//         "ask1Size": "8.094",
	//         "price24hPcnt": "0.00349",
	//         "volume24h": "79101.6477",
	//         "turnover24h": "8276293391.45973",
	//         "indexPrice": "104785.956168",
	//         "markPrice": "104738",
	//         "fundingRate": "-0.000007",
	//         "openInterest": "7465.5938",
	//         "deliveryStartTime": "",
	//         "deliveryTime": "",
	//         "deliveryStatus": ""
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	var close interface{} = this.SafeString2(ticker, "lastPr", "lastPrice")
	var timestamp interface{} = this.SafeIntegerOmitZero(ticker, "ts") // exchange bitget provided 0
	var change interface{} = this.SafeString(ticker, "change24h")
	var category interface{} = this.SafeString(ticker, "category")
	var markPrice interface{} = this.SafeString(ticker, "markPrice")
	var marketType interface{} = nil
	if IsTrue(IsTrue((!IsEqual(markPrice, nil))) && IsTrue((!IsEqual(category, "SPOT")))) {
		marketType = "contract"
	} else {
		marketType = "spot"
	}
	var percentage interface{} = this.SafeString(ticker, "price24hPcnt")
	if IsTrue(IsEqual(percentage, nil)) {
		percentage = Precise.StringMul(change, "100")
	}
	return this.SafeTicker(map[string]interface{}{
		"symbol":        this.SafeSymbol(marketId, market, nil, marketType),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString2(ticker, "high24h", "highPrice24h"),
		"low":           this.SafeString2(ticker, "low24h", "lowPrice24h"),
		"bid":           this.SafeString2(ticker, "bidPr", "bid1Price"),
		"bidVolume":     this.SafeString2(ticker, "bidSz", "bid1Size"),
		"ask":           this.SafeString2(ticker, "askPr", "ask1Price"),
		"askVolume":     this.SafeString2(ticker, "askSz", "ask1Size"),
		"vwap":          nil,
		"open":          this.SafeStringN(ticker, []interface{}{"open", "open24h", "openPrice24h"}),
		"close":         close,
		"last":          close,
		"previousClose": nil,
		"change":        change,
		"percentage":    percentage,
		"average":       nil,
		"baseVolume":    this.SafeString2(ticker, "baseVolume", "volume24h"),
		"quoteVolume":   this.SafeString2(ticker, "quoteVolume", "turnover24h"),
		"indexPrice":    this.SafeString(ticker, "indexPrice"),
		"markPrice":     markPrice,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name bitget#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
 * @see https://www.bitget.com/api-doc/contract/market/Get-Ticker
 * @see https://www.bitget.com/api-doc/uta/public/Tickers
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bitget) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes32808 := (<-this.LoadMarkets())
		PanicOnError(retRes32808)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchTicker", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PublicSpotGetV2SpotMarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketTicker(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700532903782,
		//         "data": [
		//             {
		//                 "open": "37202.46",
		//                 "symbol": "BTCUSDT",
		//                 "high24h": "37744.75",
		//                 "low24h": "36666",
		//                 "lastPr": "37583.69",
		//                 "quoteVolume": "519127705.303",
		//                 "baseVolume": "13907.0386",
		//                 "usdtVolume": "519127705.302908",
		//                 "ts": "1700532903261",
		//                 "bidPr": "37583.68",
		//                 "askPr": "37583.69",
		//                 "bidSz": "0.0007",
		//                 "askSz": "0.0829",
		//                 "openUtc": "37449.4",
		//                 "changeUtc24h": "0.00359",
		//                 "change24h": "0.00321"
		//             }
		//         ]
		//     }
		//
		// swap and future
		//
		//      {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750332210369,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT",
		//                 "lastPr": "104823.8",
		//                 "askPr": "104823.8",
		//                 "bidPr": "104823.5",
		//                 "bidSz": "0.703",
		//                 "askSz": "13.894",
		//                 "high24h": "105289.3",
		//                 "low24h": "103447.9",
		//                 "ts": "1750332210370",
		//                 "change24h": "0.00471",
		//                 "baseVolume": "79089.5675",
		//                 "quoteVolume": "8274870921.80485",
		//                 "usdtVolume": "8274870921.80485",
		//                 "openUtc": "104833",
		//                 "changeUtc24h": "-0.00009",
		//                 "indexPrice": "104881.953125",
		//                 "fundingRate": "-0.000014",
		//                 "holdingAmount": "7452.6421",
		//                 "deliveryStartTime": null,
		//                 "deliveryTime": null,
		//                 "deliveryStatus": "",
		//                 "open24h": "104332.3",
		//                 "markPrice": "104824.2"
		//             }
		//         ]
		//     }
		//
		// spot uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750330653575,
		//         "data": [
		//             {
		//                 "category": "SPOT",
		//                 "symbol": "BTCUSDT",
		//                 "ts": "1750330651972",
		//                 "lastPrice": "104900.2",
		//                 "openPrice24h": "104321.2",
		//                 "highPrice24h": "107956.8",
		//                 "lowPrice24h": "103600.1",
		//                 "ask1Price": "104945.8",
		//                 "bid1Price": "104880.6",
		//                 "bid1Size": "0.266534",
		//                 "ask1Size": "0.014001",
		//                 "price24hPcnt": "0.00555",
		//                 "volume24h": "355.941109",
		//                 "turnover24h": "37302936.008134"
		//             }
		//         ]
		//     }
		//
		// swap and future uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750332731203,
		//         "data": [
		//             {
		//                 "category": "USDT-FUTURES",
		//                 "symbol": "BTCUSDT",
		//                 "ts": "1750332730472",
		//                 "lastPrice": "104738",
		//                 "openPrice24h": "104374",
		//                 "highPrice24h": "105289.3",
		//                 "lowPrice24h": "103447.9",
		//                 "ask1Price": "104738",
		//                 "bid1Price": "104737.7",
		//                 "bid1Size": "2.036",
		//                 "ask1Size": "8.094",
		//                 "price24hPcnt": "0.00349",
		//                 "volume24h": "79101.6477",
		//                 "turnover24h": "8276293391.45973",
		//                 "indexPrice": "104785.956168",
		//                 "markPrice": "104738",
		//                 "fundingRate": "-0.000007",
		//                 "openInterest": "7465.5938",
		//                 "deliveryStartTime": "",
		//                 "deliveryTime": "",
		//                 "deliveryStatus": ""
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTicker(GetValue(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchMarkPrice
 * @description fetches the mark price for a specific market
 * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bitget) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes34368 := (<-this.LoadMarkets())
		PanicOnError(retRes34368)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " fetchMarkPrice() is not supported for spot markets")))
		} else {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketSymbolPrice(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTicker(GetValue(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
 * @see https://www.bitget.com/api-doc/uta/public/Tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {string} [params.subType] *contract only* 'linear', 'inverse'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bitget) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes34698 := (<-this.LoadMarkets())
		PanicOnError(retRes34698)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbol interface{} = this.SafeValue(symbols, 0)
			market = this.Market(symbol)
		}
		var response interface{} = nil
		var request interface{} = map[string]interface{}{}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		// Calls like `.fetchTickers (undefined, {subType:'inverse'})` should be supported for this exchange, so
		// as "options.defaultSubType" is also set in exchange options, we should consider `params.subType`
		// with higher priority and only default to spot, if `subType` is not set in params
		var passedSubType interface{} = this.SafeString(params, "subType")
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		// only if passedSubType && productType is undefined, then use spot
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchTickers", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsTrue((!IsEqual(symbols, nil))) && IsTrue((IsEqual(symbolsLength, 1)))) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(IsEqual(typeVar, "spot")) && IsTrue(IsEqual(passedSubType, nil))) {

			response = (<-this.PublicSpotGetV2SpotMarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700532903782,
		//         "data": [
		//             {
		//                 "open": "37202.46",
		//                 "symbol": "BTCUSDT",
		//                 "high24h": "37744.75",
		//                 "low24h": "36666",
		//                 "lastPr": "37583.69",
		//                 "quoteVolume": "519127705.303",
		//                 "baseVolume": "13907.0386",
		//                 "usdtVolume": "519127705.302908",
		//                 "ts": "1700532903261",
		//                 "bidPr": "37583.68",
		//                 "askPr": "37583.69",
		//                 "bidSz": "0.0007",
		//                 "askSz": "0.0829",
		//                 "openUtc": "37449.4",
		//                 "changeUtc24h": "0.00359",
		//                 "change24h": "0.00321"
		//             }
		//         ]
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700533773477,
		//         "data": [
		//             {
		//                 "open": "14.9776",
		//                 "symbol": "LINKUSDT",
		//                 "high24h": "15.3942",
		//                 "low24h": "14.3457",
		//                 "lastPr": "14.3748",
		//                 "quoteVolume": "7008612.4299",
		//                 "baseVolume": "469908.8523",
		//                 "usdtVolume": "7008612.42986561",
		//                 "ts": "1700533772309",
		//                 "bidPr": "14.375",
		//                 "askPr": "14.3769",
		//                 "bidSz": "50.004",
		//                 "askSz": "0.7647",
		//                 "openUtc": "14.478",
		//                 "changeUtc24h": "-0.00713",
		//                 "change24h": "-0.04978"
		//             },
		//         ]
		//     }
		//
		// spot uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750330653575,
		//         "data": [
		//             {
		//                 "category": "SPOT",
		//                 "symbol": "BTCUSDT",
		//                 "ts": "1750330651972",
		//                 "lastPrice": "104900.2",
		//                 "openPrice24h": "104321.2",
		//                 "highPrice24h": "107956.8",
		//                 "lowPrice24h": "103600.1",
		//                 "ask1Price": "104945.8",
		//                 "bid1Price": "104880.6",
		//                 "bid1Size": "0.266534",
		//                 "ask1Size": "0.014001",
		//                 "price24hPcnt": "0.00555",
		//                 "volume24h": "355.941109",
		//                 "turnover24h": "37302936.008134"
		//             }
		//         ]
		//     }
		//
		// swap and future uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750332731203,
		//         "data": [
		//             {
		//                 "category": "USDT-FUTURES",
		//                 "symbol": "BTCUSDT",
		//                 "ts": "1750332730472",
		//                 "lastPrice": "104738",
		//                 "openPrice24h": "104374",
		//                 "highPrice24h": "105289.3",
		//                 "lowPrice24h": "103447.9",
		//                 "ask1Price": "104738",
		//                 "bid1Price": "104737.7",
		//                 "bid1Size": "2.036",
		//                 "ask1Size": "8.094",
		//                 "price24hPcnt": "0.00349",
		//                 "volume24h": "79101.6477",
		//                 "turnover24h": "8276293391.45973",
		//                 "indexPrice": "104785.956168",
		//                 "markPrice": "104738",
		//                 "fundingRate": "-0.000007",
		//                 "openInterest": "7465.5938",
		//                 "deliveryStartTime": "",
		//                 "deliveryTime": "",
		//                 "deliveryStatus": ""
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}
func (this *bitget) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot, swap and future: fetchTrades
	//
	//     {
	//         "tradeId": "1075199767891652609",
	//         "price": "29376.5",
	//         "size": "6.035",
	//         "side": "Buy",
	//         "ts": "1692073521000",
	//         "symbol": "BTCUSDT"
	//     }
	//
	// spot: fetchMyTrades
	//
	//     {
	//         "userId": "7264631750",
	//         "symbol": "BTCUSDT",
	//         "orderId": "1098394344925597696",
	//         "tradeId": "1098394344974925824",
	//         "orderType": "market",
	//         "side": "sell",
	//         "priceAvg": "28467.68",
	//         "size": "0.0002",
	//         "amount": "5.693536",
	//         "feeDetail": {
	//             "deduction": "no",
	//             "feeCoin": "USDT",
	//             "totalDeductionFee": "",
	//             "totalFee": "-0.005693536"
	//         },
	//         "tradeScope": "taker",
	//         "cTime": "1697603539699",
	//         "uTime": "1697603539754"
	//     }
	//
	// spot margin: fetchMyTrades
	//
	//     {
	//         "orderId": "1099353730455318528",
	//         "tradeId": "1099353730627092481",
	//         "orderType": "market",
	//         "side": "sell",
	//         "priceAvg": "29543.7",
	//         "size": "0.0001",
	//         "amount": "2.95437",
	//         "tradeScope": "taker",
	//         "feeDetail": {
	//             "deduction": "no",
	//             "feeCoin": "USDT",
	//             "totalDeductionFee": "0",
	//             "totalFee": "-0.00295437"
	//         },
	//         "cTime": "1697832275063",
	//         "uTime": "1697832275150"
	//     }
	//
	// swap and future: fetchMyTrades
	//
	//     {
	//         "tradeId": "1111468664328269825",
	//         "symbol": "BTCUSDT",
	//         "orderId": "1111468664264753162",
	//         "price": "37271.4",
	//         "baseVolume": "0.001",
	//         "feeDetail": [
	//             {
	//                 "deduction": "no",
	//                 "feeCoin": "USDT",
	//                 "totalDeductionFee": null,
	//                 "totalFee": "-0.02236284"
	//             }
	//         ],
	//         "side": "buy",
	//         "quoteVolume": "37.2714",
	//         "profit": "-0.0007",
	//         "enterPointSource": "web",
	//         "tradeSide": "close",
	//         "posMode": "hedge_mode",
	//         "tradeScope": "taker",
	//         "cTime": "1700720700342"
	//     }
	//
	// uta fetchTrades
	//
	//     {
	//         "execId": "1319896716324937729",
	//         "price": "105909.1",
	//         "size": "6.3090",
	//         "side": "sell",
	//         "ts": "1750413820344"
	//     }
	//
	// uta fetchMyTrades
	//
	//     {
	//         "execId": "1322441401010528257",
	//         "orderId": "1322441400976261120",
	//         "category": "USDT-FUTURES",
	//         "symbol": "BTCUSDT",
	//         "orderType": "market",
	//         "side": "sell",
	//         "execPrice": "107005.4",
	//         "execQty": "0.0001",
	//         "execValue": "10.7005",
	//         "tradeScope": "taker",
	//         "feeDetail": [{
	//             "feeCoin": "USDT",
	//             "fee":"0.00642032"
	//         }],
	//         "createdTime": "1751020520451",
	//         "updatedTime": "1751020520458",
	//         "execPnl": "0.00017"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"cTime", "ts", "createdTime"})
	var fee interface{} = nil
	var feeDetail interface{} = this.SafeValue(trade, "feeDetail")
	var posMode interface{} = this.SafeString(trade, "posMode")
	var category interface{} = this.SafeString(trade, "category")
	var isFeeStructure interface{} = IsTrue((!IsEqual(posMode, nil))) || IsTrue((!IsEqual(category, nil)))
	var feeStructure interface{} = Ternary(IsTrue(isFeeStructure), GetValue(feeDetail, 0), feeDetail)
	if IsTrue(!IsEqual(feeStructure, nil)) {
		var currencyCode interface{} = this.SafeCurrencyCode(this.SafeString(feeStructure, "feeCoin"))
		fee = map[string]interface{}{
			"currency": currencyCode,
		}
		var feeCostString interface{} = this.SafeString2(feeStructure, "totalFee", "fee")
		var deduction interface{} = Ternary(IsTrue(IsEqual(this.SafeString(feeStructure, "deduction"), "yes")), true, false)
		if IsTrue(deduction) {
			AddElementToObject(fee, "cost", feeCostString)
		} else {
			AddElementToObject(fee, "cost", Precise.StringNeg(feeCostString))
		}
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"id":           this.SafeString2(trade, "tradeId", "execId"),
		"order":        this.SafeString(trade, "orderId"),
		"symbol":       symbol,
		"side":         this.SafeStringLower(trade, "side"),
		"type":         this.SafeString(trade, "orderType"),
		"takerOrMaker": this.SafeString(trade, "tradeScope"),
		"price":        this.SafeStringN(trade, []interface{}{"priceAvg", "price", "execPrice"}),
		"amount":       this.SafeStringN(trade, []interface{}{"baseVolume", "size", "execQty"}),
		"cost":         this.SafeStringN(trade, []interface{}{"quoteVolume", "amount", "execValue"}),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name bitget#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.bitget.com/api-doc/spot/market/Get-Recent-Trades
 * @see https://www.bitget.com/api-doc/spot/market/Get-Market-Trades
 * @see https://www.bitget.com/api-doc/contract/market/Get-Recent-Fills
 * @see https://www.bitget.com/api-doc/contract/market/Get-Fills-History
 * @see https://www.bitget.com/api-doc/uta/public/Fills
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {int} [params.until] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* default false, when true will automatically paginate by calling this endpoint multiple times
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *bitget) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes37948 := (<-this.LoadMarkets())
		PanicOnError(retRes37948)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes379819 := (<-this.FetchPaginatedCallCursor("fetchTrades", symbol, since, limit, params, "idLessThan", "idLessThan"))
			PanicOnError(retRes379819)
			ch <- retRes379819
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(uta) {
				AddElementToObject(request, "limit", mathMin(limit, 100))
			} else if IsTrue(GetValue(market, "contract")) {
				AddElementToObject(request, "limit", mathMin(limit, 1000))
			} else {
				AddElementToObject(request, "limit", limit)
			}
		}
		var options interface{} = this.SafeValue(this.Options, "fetchTrades", map[string]interface{}{})
		var response interface{} = nil
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(IsEqual(productType, "SPOT")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTrades", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				if IsTrue(!IsEqual(marginMode, nil)) {
					productType = "MARGIN"
				}
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketFills(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {
			var spotOptions interface{} = this.SafeValue(options, "spot", map[string]interface{}{})
			var defaultSpotMethod interface{} = this.SafeString(spotOptions, "method", "publicSpotGetV2SpotMarketFillsHistory")
			var spotMethod interface{} = this.SafeString(params, "method", defaultSpotMethod)
			params = this.Omit(params, "method")
			if IsTrue(IsEqual(spotMethod, "publicSpotGetV2SpotMarketFillsHistory")) {
				requestparamsVariable := this.HandleUntilOption("endTime", request, params)
				request = GetValue(requestparamsVariable, 0)
				params = GetValue(requestparamsVariable, 1)
				if IsTrue(!IsEqual(since, nil)) {
					AddElementToObject(request, "startTime", since)
				}

				response = (<-this.PublicSpotGetV2SpotMarketFillsHistory(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(spotMethod, "publicSpotGetV2SpotMarketFills")) {

				response = (<-this.PublicSpotGetV2SpotMarketFills(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			var swapOptions interface{} = this.SafeValue(options, "swap", map[string]interface{}{})
			var defaultSwapMethod interface{} = this.SafeString(swapOptions, "method", "publicMixGetV2MixMarketFillsHistory")
			var swapMethod interface{} = this.SafeString(params, "method", defaultSwapMethod)
			params = this.Omit(params, "method")
			AddElementToObject(request, "productType", productType)
			if IsTrue(IsEqual(swapMethod, "publicMixGetV2MixMarketFillsHistory")) {
				requestparamsVariable := this.HandleUntilOption("endTime", request, params)
				request = GetValue(requestparamsVariable, 0)
				params = GetValue(requestparamsVariable, 1)
				if IsTrue(!IsEqual(since, nil)) {
					AddElementToObject(request, "startTime", since)
				}

				response = (<-this.PublicMixGetV2MixMarketFillsHistory(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(swapMethod, "publicMixGetV2MixMarketFills")) {

				response = (<-this.PublicMixGetV2MixMarketFills(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1692073693562,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT_SPBL",
		//                 "tradeId": "1075200479040323585",
		//                 "side": "Sell",
		//                 "price": "29381.54",
		//                 "size": "0.0056",
		//                 "ts": "1692073691000"
		//             },
		//         ]
		//     }
		//
		// swap
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1692073522689,
		//         "data": [
		//             {
		//                 "tradeId": "1075199767891652609",
		//                 "price": "29376.5",
		//                 "size": "6.035",
		//                 "side": "Buy",
		//                 "ts": "1692073521000",
		//                 "symbol": "BTCUSDT_UMCBL"
		//             },
		//         ]
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750413823980,
		//         "data": [
		//             {
		//                 "execId": "1319896716324937729",
		//                 "price": "105909.1",
		//                 "size": "6.3090",
		//                 "side": "sell",
		//                 "ts": "1750413820344"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.bitget.com/api-doc/common/public/Get-Trade-Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross', for finding the fee rate of spot margin trading pairs
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *bitget) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes39288 := (<-this.LoadMarkets())
		PanicOnError(retRes39288)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTradingFee", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				AddElementToObject(request, "businessType", "margin")
			} else {
				AddElementToObject(request, "businessType", "spot")
			}
		} else {
			AddElementToObject(request, "businessType", "mix")
		}

		response := (<-this.PrivateCommonGetV2CommonTradeRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700549524887,
		//         "data": {
		//             "makerFeeRate": "0.001",
		//             "takerFeeRate": "0.001"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseTradingFee(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
 * @see https://www.bitget.com/api-doc/margin/common/support-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.margin] set to true for spot margin
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func (this *bitget) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes39738 := (<-this.LoadMarkets())
		PanicOnError(retRes39738)
		var response interface{} = nil
		var marginMode interface{} = nil
		var marketType interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTradingFees", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			var margin interface{} = this.SafeBool(params, "margin", false)
			params = this.Omit(params, "margin")
			if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(margin)) {

				response = (<-this.PublicMarginGetV2MarginCurrencies(params))
				PanicOnError(response)
			} else {

				response = (<-this.PublicSpotGetV2SpotPublicSymbols(params))
				PanicOnError(response)
			}
		} else if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(params, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketContracts(params))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " does not support "), marketType), " market")))
		}
		//
		// spot and margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700102364653,
		//         "data": [
		//             {
		//                 "symbol": "TRXUSDT",
		//                 "baseCoin": "TRX",
		//                 "quoteCoin": "USDT",
		//                 "minTradeAmount": "0",
		//                 "maxTradeAmount": "10000000000",
		//                 "takerFeeRate": "0.002",
		//                 "makerFeeRate": "0.002",
		//                 "pricePrecision": "6",
		//                 "quantityPrecision": "4",
		//                 "quotePrecision": "6",
		//                 "status": "online",
		//                 "minTradeUSDT": "5",
		//                 "buyLimitPriceRatio": "0.05",
		//                 "sellLimitPriceRatio": "0.05"
		//             },
		//         ]
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700102364709,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT",
		//                 "baseCoin": "BTC",
		//                 "quoteCoin": "USDT",
		//                 "buyLimitPriceRatio": "0.01",
		//                 "sellLimitPriceRatio": "0.01",
		//                 "feeRateUpRatio": "0.005",
		//                 "makerFeeRate": "0.0002",
		//                 "takerFeeRate": "0.0006",
		//                 "openCostUpRatio": "0.01",
		//                 "supportMarginCoins": ["USDT"],
		//                 "minTradeNum": "0.001",
		//                 "priceEndStep": "1",
		//                 "volumePlace": "3",
		//                 "pricePlace": "1",
		//                 "sizeMultiplier": "0.001",
		//                 "symbolType": "perpetual",
		//                 "minTradeUSDT": "5",
		//                 "maxSymbolOrderNum": "200",
		//                 "maxProductOrderNum": "400",
		//                 "maxPositionNum": "150",
		//                 "symbolStatus": "normal",
		//                 "offTime": "-1",
		//                 "limitOpenTime": "-1",
		//                 "deliveryTime": "",
		//                 "deliveryStartTime": "",
		//                 "deliveryPeriod": "",
		//                 "launchTime": "",
		//                 "fundInterval": "8",
		//                 "minLever": "1",
		//                 "maxLever": "125",
		//                 "posLimit": "0.05",
		//                 "maintainTime": ""
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var marketId interface{} = this.SafeString(entry, "symbol")
			var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
			var market interface{} = this.Market(symbol)
			var fee interface{} = this.ParseTradingFee(entry, market)
			AddElementToObject(result, symbol, fee)
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *bitget) ParseTradingFee(data interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(data, "symbol")
	return map[string]interface{}{
		"info":       data,
		"symbol":     this.SafeSymbol(marketId, market),
		"maker":      this.SafeNumber(data, "makerFeeRate"),
		"taker":      this.SafeNumber(data, "takerFeeRate"),
		"percentage": nil,
		"tierBased":  nil,
	}
}
func (this *bitget) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         "1645911960000",
	//         "39406",
	//         "39407",
	//         "39374.5",
	//         "39379",
	//         "35.526",
	//         "1399132.341"
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var inverse interface{} = this.SafeBool(market, "inverse")
	var volumeIndex interface{} = Ternary(IsTrue(inverse), 6, 5)
	return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, volumeIndex)}
}

/**
 * @method
 * @name bitget#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Candle-Data
 * @see https://www.bitget.com/api-doc/spot/market/Get-History-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Index-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Mark-Candle-Data
 * @see https://www.bitget.com/api-doc/uta/public/Get-Candle-Data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.useHistoryEndpoint] whether to force to use historical endpoint (it has max limit of 200)
 * @param {boolean} [params.useHistoryEndpointForPagination] whether to force to use historical endpoint for pagination (default true)
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.price] *swap only* "mark" (to fetch mark price candles) or "index" (to fetch index price candles)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *bitget) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes41408 := (<-this.LoadMarkets())
		PanicOnError(retRes41408)
		var defaultLimit interface{} = 100 // default 100, max 1000
		var maxLimitForRecentEndpoint interface{} = 1000
		var maxLimitForHistoryEndpoint interface{} = 200 // note, max 1000 bars are supported for "recent-candles" endpoint, but "historical-candles" support only max 200
		var useHistoryEndpoint interface{} = this.SafeBool(params, "useHistoryEndpoint", false)
		var useHistoryEndpointForPagination interface{} = this.SafeBool(params, "useHistoryEndpointForPagination", true)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			var limitForPagination interface{} = Ternary(IsTrue(useHistoryEndpointForPagination), maxLimitForHistoryEndpoint, maxLimitForRecentEndpoint)

			retRes415019 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, limitForPagination))
			PanicOnError(retRes415019)
			ch <- retRes415019
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var marketType interface{} = nil
		var timeframes interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			timeframes = GetValue(GetValue(this.Options, "timeframes"), "uta")
			AddElementToObject(request, "interval", this.SafeString(timeframes, timeframe, timeframe))
		} else {
			marketType = Ternary(IsTrue(GetValue(market, "spot")), "spot", "swap")
			timeframes = GetValue(GetValue(this.Options, "timeframes"), marketType)
			AddElementToObject(request, "granularity", this.SafeString(timeframes, timeframe, timeframe))
		}
		var msInDay interface{} = 86400000
		var now interface{} = this.Milliseconds()
		var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
		var until interface{} = this.SafeInteger(params, "until")
		var limitDefined interface{} = !IsEqual(limit, nil)
		var sinceDefined interface{} = !IsEqual(since, nil)
		var untilDefined interface{} = !IsEqual(until, nil)
		params = this.Omit(params, []interface{}{"until"})
		// retrievable periods listed here:
		// - https://www.bitget.com/api-doc/spot/market/Get-Candle-Data#request-parameters
		// - https://www.bitget.com/api-doc/contract/market/Get-Candle-Data#description
		var key interface{} = Ternary(IsTrue(GetValue(market, "spot")), "spot", "swap")
		var ohlcOptions interface{} = this.SafeDict(GetValue(this.Options, "fetchOHLCV"), key, map[string]interface{}{})
		var maxLimitPerTimeframe interface{} = this.SafeDict(ohlcOptions, "maxLimitPerTimeframe", map[string]interface{}{})
		var maxLimitForThisTimeframe interface{} = this.SafeInteger(maxLimitPerTimeframe, timeframe, limit)
		var recentEndpointDaysMap interface{} = this.SafeDict(GetValue(this.Options, "fetchOHLCV"), "maxRecentDaysPerTimeframe", map[string]interface{}{})
		var recentEndpointAvailableDays interface{} = this.SafeInteger(recentEndpointDaysMap, timeframe)
		var recentEndpointBoundaryTs interface{} = Subtract(now, Multiply((Subtract(recentEndpointAvailableDays, 1)), msInDay))
		if IsTrue(limitDefined) {
			limit = mathMin(limit, maxLimitForRecentEndpoint)
			limit = mathMin(limit, maxLimitForThisTimeframe)
		} else {
			limit = defaultLimit
		}
		var limitMultipliedDuration interface{} = Multiply(limit, duration)
		// exchange aligns from endTime, so it's important, not startTime
		// startTime is supported only on "recent" endpoint, not on "historical" endpoint
		var calculatedStartTime interface{} = nil
		var calculatedEndTime interface{} = nil
		if IsTrue(sinceDefined) {
			calculatedStartTime = since
			AddElementToObject(request, "startTime", since)
			if !IsTrue(untilDefined) {
				calculatedEndTime = this.Sum(calculatedStartTime, limitMultipliedDuration)
				AddElementToObject(request, "endTime", calculatedEndTime)
			}
		}
		if IsTrue(untilDefined) {
			calculatedEndTime = until
			AddElementToObject(request, "endTime", calculatedEndTime)
			if !IsTrue(sinceDefined) {
				calculatedStartTime = Subtract(calculatedEndTime, limitMultipliedDuration)
			}
		}
		// if historical endpoint is needed, we should re-set the variables
		var historicalEndpointNeeded interface{} = false
		if IsTrue(IsTrue((IsTrue(!IsEqual(calculatedStartTime, nil)) && IsTrue(IsLessThanOrEqual(calculatedStartTime, recentEndpointBoundaryTs)))) || IsTrue(useHistoryEndpoint)) {
			historicalEndpointNeeded = true
			// only for "historical-candles" - ensure we use correct max limit
			limit = mathMin(limit, maxLimitForHistoryEndpoint)
			limitMultipliedDuration = Multiply(limit, duration)
			calculatedStartTime = Subtract(calculatedEndTime, limitMultipliedDuration)
			AddElementToObject(request, "startTime", calculatedStartTime)
			// for contract, maximum 90 days allowed between start-end times
			if !IsTrue(GetValue(market, "spot")) {
				var maxDistanceDaysForContracts interface{} = 90
				// only correct if request is larger
				if IsTrue(IsGreaterThan(Subtract(calculatedEndTime, calculatedStartTime), Multiply(maxDistanceDaysForContracts, msInDay))) {
					calculatedEndTime = this.Sum(calculatedStartTime, Multiply(maxDistanceDaysForContracts, msInDay))
					AddElementToObject(request, "endTime", calculatedEndTime)
				}
			}
		}
		// we need to set limit to safely cover the period
		AddElementToObject(request, "limit", limit)
		// make request
		var response interface{} = nil
		var productType interface{} = nil
		var priceType interface{} = nil
		priceTypeparamsVariable := this.HandleParamString(params, "price")
		priceType = GetValue(priceTypeparamsVariable, 0)
		params = GetValue(priceTypeparamsVariable, 1)
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(!IsEqual(priceType, nil)) {
				if IsTrue(IsEqual(priceType, "mark")) {
					AddElementToObject(request, "type", "MARK")
				} else if IsTrue(IsEqual(priceType, "index")) {
					AddElementToObject(request, "type", "INDEX")
				}
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketCandles(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {
			// checks if we need history endpoint
			if IsTrue(historicalEndpointNeeded) {

				response = (<-this.PublicSpotGetV2SpotMarketHistoryCandles(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				if !IsTrue(limitDefined) {
					AddElementToObject(request, "limit", 1000)
					limit = 1000
				}

				response = (<-this.PublicSpotGetV2SpotMarketCandles(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			AddElementToObject(request, "productType", productType)
			var extended interface{} = this.Extend(request, params)
			if IsTrue(!IsTrue(historicalEndpointNeeded) && IsTrue((IsTrue(IsEqual(priceType, "mark")) || IsTrue(IsEqual(priceType, "index"))))) {
				if !IsTrue(limitDefined) {
					AddElementToObject(extended, "limit", 1000)
					limit = 1000
				}
				// Recent endpoint for mark/index prices
				// https://www.bitget.com/api-doc/contract/market/Get-Candle-Data

				response = (<-this.PublicMixGetV2MixMarketCandles(this.Extend(map[string]interface{}{
					"kLineType": priceType,
				}, extended)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(priceType, "mark")) {

				response = (<-this.PublicMixGetV2MixMarketHistoryMarkCandles(extended))
				PanicOnError(response)
			} else if IsTrue(IsEqual(priceType, "index")) {

				response = (<-this.PublicMixGetV2MixMarketHistoryIndexCandles(extended))
				PanicOnError(response)
			} else {
				if IsTrue(historicalEndpointNeeded) {

					response = (<-this.PublicMixGetV2MixMarketHistoryCandles(extended))
					PanicOnError(response)
				} else {
					if !IsTrue(limitDefined) {
						AddElementToObject(extended, "limit", 1000)
						limit = 1000
					}

					response = (<-this.PublicMixGetV2MixMarketCandles(extended))
					PanicOnError(response)
				}
			}
		}
		if IsTrue(IsEqual(response, "")) {

			ch <- []interface{}{} // happens when a new token is listed
			return nil
		}
		//  [ ["1645911960000","39406","39407","39374.5","39379","35.526","1399132.341"] ]
		var data interface{} = this.SafeList(response, "data", response)

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Assets
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-List
 * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Assets
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Get-Isolated-Assets
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-cross-assets
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-isolated-assets
 * @see https://www.bitget.com/api-doc/uta/account/Get-Account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {string} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *bitget) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes43138 := (<-this.LoadMarkets())
		PanicOnError(retRes43138)
		var request interface{} = map[string]interface{}{}
		var marketType interface{} = nil
		var marginMode interface{} = nil
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchBalance", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(uta) {

			response = (<-this.PrivateUtaGetV3AccountAssets(this.Extend(request, params)))
			PanicOnError(response)
			var results interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			var assets interface{} = this.SafeList(results, "assets", []interface{}{})

			ch <- this.ParseUtaBalance(assets)
			return nil
		} else if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixAccountAccounts(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "isolated")) {

			response = (<-this.PrivateMarginGetMarginV1IsolatedAccountAssets(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "cross")) {

			response = (<-this.PrivateMarginGetMarginV1CrossAccountAssets(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateSpotGetV2SpotAccountAssets(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchBalance() does not support "), marketType), " accounts")))
		}
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700623852854,
		//         "data": [
		//             {
		//                 "coin": "USDT",
		//                 "available": "0.00000000",
		//                 "limitAvailable": "0",
		//                 "frozen": "0.00000000",
		//                 "locked": "0.00000000",
		//                 "uTime": "1699937566000"
		//             }
		//         ]
		//     }
		//
		// swap
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700625127294,
		//         "data": [
		//             {
		//                 "marginCoin": "USDT",
		//                 "locked": "0",
		//                 "available": "0",
		//                 "crossedMaxAvailable": "0",
		//                 "isolatedMaxAvailable": "0",
		//                 "maxTransferOut": "0",
		//                 "accountEquity": "0",
		//                 "usdtEquity": "0.000000005166",
		//                 "btcEquity": "0",
		//                 "crossedRiskRate": "0",
		//                 "unrealizedPL": "0",
		//                 "coupon": "0",
		//                 "crossedUnrealizedPL": null,
		//                 "isolatedUnrealizedPL": null
		//             }
		//         ]
		//     }
		//
		// isolated margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1697501436571,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT",
		//                 "coin": "BTC",
		//                 "totalAmount": "0.00021654",
		//                 "available": "0.00021654",
		//                 "transferable": "0.00021654",
		//                 "frozen": "0",
		//                 "borrow": "0",
		//                 "interest": "0",
		//                 "net": "0.00021654",
		//                 "ctime": "1697248128071"
		//             },
		//         ]
		//     }
		//
		// cross margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1697515463804,
		//         "data": [
		//             {
		//                 "coin": "BTC",
		//                 "totalAmount": "0.00024996",
		//                 "available": "0.00024996",
		//                 "transferable": "0.00004994",
		//                 "frozen": "0",
		//                 "borrow": "0.0001",
		//                 "interest": "0.00000001",
		//                 "net": "0.00014995",
		//                 "ctime": "1697251265504"
		//             },
		//         ]
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1749980065089,
		//         "data": {
		//             "accountEquity": "11.13919278",
		//             "usdtEquity": "11.13921165",
		//             "btcEquity": "0.00011256",
		//             "unrealisedPnl": "0",
		//             "usdtUnrealisedPnl": "0",
		//             "btcUnrealizedPnl": "0",
		//             "effEquity": "6.19299777",
		//             "mmr": "0",
		//             "imr": "0",
		//             "mgnRatio": "0",
		//             "positionMgnRatio": "0",
		//             "assets": [
		//                 {
		//                     "coin": "USDT",
		//                     "equity": "6.19300826",
		//                     "usdValue": "6.19299777",
		//                     "balance": "6.19300826",
		//                     "available": "6.19300826",
		//                     "debt": "0",
		//                     "locked": "0"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})

		ch <- this.ParseBalance(data)
		return nil

	}()
	return ch
}
func (this *bitget) ParseUtaBalance(balance interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": balance,
	}
	//
	//     {
	//         "coin": "USDT",
	//         "equity": "6.19300826",
	//         "usdValue": "6.19299777",
	//         "balance": "6.19300826",
	//         "available": "6.19300826",
	//         "debt": "0",
	//         "locked": "0"
	//     }
	//
	for i := 0; IsLessThan(i, GetArrayLength(balance)); i++ {
		var entry interface{} = GetValue(balance, i)
		var account interface{} = this.Account()
		var currencyId interface{} = this.SafeString(entry, "coin")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		AddElementToObject(account, "debt", this.SafeString(entry, "debt"))
		AddElementToObject(account, "used", this.SafeString(entry, "locked"))
		AddElementToObject(account, "free", this.SafeString(entry, "available"))
		AddElementToObject(account, "total", this.SafeString(entry, "balance"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}
func (this *bitget) ParseBalance(balance interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": balance,
	}
	//
	// spot
	//
	//     {
	//         "coin": "USDT",
	//         "available": "0.00000000",
	//         "limitAvailable": "0",
	//         "frozen": "0.00000000",
	//         "locked": "0.00000000",
	//         "uTime": "1699937566000"
	//     }
	//
	// swap
	//
	//     {
	//         "marginCoin": "USDT",
	//         "locked": "0",
	//         "available": "0",
	//         "crossedMaxAvailable": "0",
	//         "isolatedMaxAvailable": "0",
	//         "maxTransferOut": "0",
	//         "accountEquity": "0",
	//         "usdtEquity": "0.000000005166",
	//         "btcEquity": "0",
	//         "crossedRiskRate": "0",
	//         "unrealizedPL": "0",
	//         "coupon": "0",
	//         "crossedUnrealizedPL": null,
	//         "isolatedUnrealizedPL": null
	//     }
	//
	// isolated margin
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "coin": "BTC",
	//         "totalAmount": "0.00021654",
	//         "available": "0.00021654",
	//         "transferable": "0.00021654",
	//         "frozen": "0",
	//         "borrow": "0",
	//         "interest": "0",
	//         "net": "0.00021654",
	//         "ctime": "1697248128071"
	//     }
	//
	// cross margin
	//
	//     {
	//         "coin": "BTC",
	//         "totalAmount": "0.00024995",
	//         "available": "0.00024995",
	//         "transferable": "0.00004993",
	//         "frozen": "0",
	//         "borrow": "0.0001",
	//         "interest": "0.00000001",
	//         "net": "0.00014994",
	//         "ctime": "1697251265504"
	//     }
	//
	for i := 0; IsLessThan(i, GetArrayLength(balance)); i++ {
		var entry interface{} = GetValue(balance, i)
		var account interface{} = this.Account()
		var currencyId interface{} = this.SafeString2(entry, "marginCoin", "coin")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var borrow interface{} = this.SafeString(entry, "borrow")
		if IsTrue(!IsEqual(borrow, nil)) {
			var interest interface{} = this.SafeString(entry, "interest")
			AddElementToObject(account, "free", this.SafeString(entry, "transferable"))
			AddElementToObject(account, "total", this.SafeString(entry, "totalAmount"))
			AddElementToObject(account, "debt", Precise.StringAdd(borrow, interest))
		} else {
			// Use transferable instead of available for swap and margin https://github.com/ccxt/ccxt/pull/19127
			var spotAccountFree interface{} = this.SafeString(entry, "available")
			var contractAccountFree interface{} = this.SafeString(entry, "maxTransferOut")
			if IsTrue(!IsEqual(contractAccountFree, nil)) {
				AddElementToObject(account, "free", contractAccountFree)
				AddElementToObject(account, "total", this.SafeString(entry, "accountEquity"))
			} else {
				AddElementToObject(account, "free", spotAccountFree)
				var frozen interface{} = this.SafeString(entry, "frozen")
				var locked interface{} = this.SafeString(entry, "locked")
				AddElementToObject(account, "used", Precise.StringAdd(frozen, locked))
			}
		}
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}
func (this *bitget) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"new":              "open",
		"init":             "open",
		"not_trigger":      "open",
		"partial_fill":     "open",
		"partially_fill":   "open",
		"partially_filled": "open",
		"triggered":        "closed",
		"full_fill":        "closed",
		"filled":           "closed",
		"fail_trigger":     "rejected",
		"cancel":           "canceled",
		"cancelled":        "canceled",
		"canceled":         "canceled",
		"live":             "open",
		"fail_execute":     "rejected",
		"executed":         "closed",
	}
	return this.SafeString(statuses, status, status)
}
func (this *bitget) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder, editOrder, closePosition
	//
	//     {
	//         "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd479",
	//         "orderId": null
	//     }
	//
	// createOrders
	//
	//     [
	//         {
	//             "orderId": "1111397214281175046",
	//             "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
	//         },
	//         {
	//             "orderId": "",
	//             "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
	//             "errorMsg": "less than the minimum amount 5 USDT",
	//             "errorCode": "45110"
	//         },
	//     ]
	//
	// spot, swap, future, spot margin and uta: cancelOrder, cancelOrders, cancelAllOrders
	//
	//     {
	//         "orderId": "1098758604547850241",
	//         "clientOid": "1098758604585598977"
	//     }
	//
	// spot trigger: cancelOrder
	//
	//     {
	//         "result": "success"
	//     }
	//
	// spot: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
	//
	//     {
	//         "userId": "7264631750",
	//         "symbol": "BTCUSDT",
	//         "orderId": "1111499608327360513",
	//         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
	//         "size": "0.0002000000000000", // COST for 'buy market' order! AMOUNT in all other cases
	//         "price": "0", // in fetchOrder: 0 for market order, otherwise limit price (field not present in fetchOpenOrders
	//         "orderType": "limit",
	//         "side": "buy",
	//         "status": "live",
	//         "basePrice": "0",
	//         "priceAvg": "25000.0000000000000000",   // 0 if nothing filled
	//         "baseVolume": "0.0000000000000000",     // 0 if nothing filled
	//         "quoteVolume": "0.0000000000000000",    // 0 if nothing filled
	//         "enterPointSource": "WEB",
	//         "orderSource": "normal",
	//         "cTime": "1700728077966",
	//         "uTime": "1700728077966"
	//         "feeDetail": "{\\"newFees\\":{\\"c\\":0,\\"d\\":0,\\"deduction\\":false,\\"r\\":-0.0064699886,\\"t\\":-0.0064699886,\\"totalDeductionFee\\":0},\\"USDT\\":{\\"deduction\\":false,\\"feeCoinCode\\":\\"USDT\\",\\"totalDeductionFee\\":0,\\"totalFee\\":-0.0064699886000000}}", // might not be present in fetchOpenOrders
	//         "triggerPrice": null,
	//         "tpslType": "normal",
	//         "quoteCoin": "USDT",  // not present in fetchOpenOrders
	//         "baseCoin": "DOT",    // not present in fetchOpenOrders
	//         "cancelReason": "",   // not present in fetchOpenOrders
	//     }
	//
	// spot trigger: fetchOpenOrders, fetchCanceledAndClosedOrders
	//
	//     {
	//         "orderId": "1111503385931620352",
	//         "clientOid": "1111503385910648832",
	//         "symbol": "BTCUSDT",
	//         "size": "0.0002",
	//         "planType": "AMOUNT",
	//         "executePrice": "25000",
	//         "triggerPrice": "26000",
	//         "status": "live",
	//         "orderType": "limit",
	//         "side": "buy",
	//         "triggerType": "fill_price",
	//         "enterPointSource": "API",
	//         "cTime": "1700728978617",
	//         "uTime": "1700728978617"
	//     }
	//
	// spot margin: fetchOpenOrders, fetchCanceledAndClosedOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderType": "limit",
	//         "enterPointSource": "WEB",
	//         "orderId": "1111506377509580801",
	//         "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
	//         "loanType": "autoLoanAndRepay",
	//         "price": "25000",
	//         "side": "buy",
	//         "status": "live",
	//         "baseSize": "0.0002",
	//         "quoteSize": "5",
	//         "priceAvg": "0",
	//         "size": "0",
	//         "amount": "0",
	//         "force": "gtc",
	//         "cTime": "1700729691866",
	//         "uTime": "1700729691866"
	//     }
	//
	// swap and future: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "size": "0.001",
	//         "orderId": "1111465253393825792",
	//         "clientOid": "1111465253431574529",
	//         "baseVolume": "0",
	//         "fee": "0",
	//         "price": "27000",
	//         "priceAvg": "",
	//         "state": "live",
	//         // "status": "live", // key for fetchOpenOrders, fetchClosedOrders
	//         "side": "buy",
	//         "force": "gtc",
	//         "totalProfits": "0",
	//         "posSide": "long",
	//         "marginCoin": "USDT",
	//         "quoteVolume": "0",
	//         "leverage": "20",
	//         "marginMode": "crossed",
	//         "enterPointSource": "API",
	//         "tradeSide": "open",
	//         "posMode": "hedge_mode",
	//         "orderType": "limit",
	//         "orderSource": "normal",
	//         "presetStopSurplusPrice": "",
	//         "presetStopLossPrice": "",
	//         "reduceOnly": "NO",
	//         "cTime": "1700719887120",
	//         "uTime": "1700719887120"
	//
	//     for swap trigger order, the additional below fields are present:
	//
	//         "planType": "normal_plan",
	//         "callbackRatio": "",
	//         "triggerPrice": "24000",
	//         "triggerType": "mark_price",
	//         "planStatus": "live",
	//         "stopSurplusTriggerPrice": "",
	//         "stopSurplusExecutePrice": "",
	//         "stopSurplusTriggerType": "fill_price",
	//         "stopLossTriggerPrice": "",
	//         "stopLossExecutePrice": "",
	//         "stopLossTriggerType": "fill_price",
	//     }
	//
	// uta: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
	//
	//     {
	//         "orderId": "1320244799629316096",
	//         "clientOid": "1320244799633510400",
	//         "category": "USDT-FUTURES",
	//         "symbol": "BTCUSDT",
	//         "orderType": "limit",
	//         "side": "buy",
	//         "price": "50000",
	//         "qty": "0.001",
	//         "amount": "0",
	//         "cumExecQty": "0",
	//         "cumExecValue": "0",
	//         "avgPrice": "0",
	//         "timeInForce": "gtc",
	//         "orderStatus": "live",
	//         "posSide": "long",
	//         "holdMode": "hedge_mode",
	//         "reduceOnly": "NO",
	//         "feeDetail": [{
	//             "feeCoin": "",
	//             "fee": ""
	//         }],
	//         "createdTime": "1750496809871",
	//         "updatedTime": "1750496809886",
	//         "cancelReason": "",
	//         "execType": "normal",
	//         "stpMode": "none",
	//         "tpTriggerBy": null,
	//         "slTriggerBy": null,
	//         "takeProfit": null,
	//         "stopLoss": null,
	//         "tpOrderType": null,
	//         "slOrderType": null,
	//         "tpLimitPrice": null,
	//         "slLimitPrice": null
	//     }
	//
	// uta trigger: fetchClosedOrders, fetchCanceledOrders
	//
	//     {
	//         "orderId": "1330984742276198400",
	//         "clientOid": "1330984742276198400",
	//         "symbol": "BTCUSDT",
	//         "category": "USDT-FUTURES",
	//         "qty": "0.001",
	//         "posSide": "long",
	//         "tpTriggerBy": "market",
	//         "slTriggerBy": "mark",
	//         "takeProfit": "",
	//         "stopLoss": "112000",
	//         "tpOrderType": "market",
	//         "slOrderType": "limit",
	//         "tpLimitPrice": "",
	//         "slLimitPrice": "111000",
	//         "createdTime": "1753057411736",
	//         "updatedTime": "1753058267412"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var errorMessage interface{} = this.SafeString(order, "errorMsg")
	if IsTrue(!IsEqual(errorMessage, nil)) {
		return this.SafeOrder(map[string]interface{}{
			"info":          order,
			"id":            this.SafeString(order, "orderId"),
			"clientOrderId": this.SafeString2(order, "clientOrderId", "clientOid"),
			"status":        "rejected",
		}, market)
	}
	var posSide interface{} = this.SafeString(order, "posSide")
	var isContractOrder interface{} = (!IsEqual(posSide, nil))
	var marketType interface{} = Ternary(IsTrue(isContractOrder), "contract", "spot")
	if IsTrue(!IsEqual(market, nil)) {
		marketType = GetValue(market, "type")
	}
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market, nil, marketType)
	var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"cTime", "ctime", "createdTime"})
	var updateTimestamp interface{} = this.SafeInteger2(order, "uTime", "updatedTime")
	var rawStatus interface{} = this.SafeStringN(order, []interface{}{"status", "state", "orderStatus", "planStatus"})
	var fee interface{} = nil
	var feeCostString interface{} = this.SafeString(order, "fee")
	if IsTrue(!IsEqual(feeCostString, nil)) {
		// swap
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(Precise.StringNeg(feeCostString)),
			"currency": GetValue(market, "settle"),
		}
	}
	var feeDetail interface{} = this.SafeValue(order, "feeDetail")
	var uta interface{} = !IsEqual(this.SafeString(order, "category"), nil)
	if IsTrue(uta) {
		var feeResult interface{} = this.SafeDict(feeDetail, 0, map[string]interface{}{})
		var utaFee interface{} = this.SafeString(feeResult, "fee")
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(Precise.StringNeg(utaFee)),
			"currency": GetValue(market, "settle"),
		}
	} else {
		if IsTrue(!IsEqual(feeDetail, nil)) {
			var parsedFeeDetail interface{} = JsonParse(feeDetail)
			var feeValues interface{} = ObjectValues(parsedFeeDetail)
			var feeObject interface{} = nil
			for i := 0; IsLessThan(i, GetArrayLength(feeValues)); i++ {
				var feeValue interface{} = GetValue(feeValues, i)
				if IsTrue(!IsEqual(this.SafeValue(feeValue, "feeCoinCode"), nil)) {
					feeObject = feeValue
					break
				}
			}
			fee = map[string]interface{}{
				"cost":     this.ParseNumber(Precise.StringNeg(this.SafeString(feeObject, "totalFee"))),
				"currency": this.SafeCurrencyCode(this.SafeString(feeObject, "feeCoinCode")),
			}
		}
	}
	var postOnly interface{} = nil
	var timeInForce interface{} = this.SafeStringUpper2(order, "force", "timeInForce")
	if IsTrue(IsEqual(timeInForce, "POST_ONLY")) {
		postOnly = true
		timeInForce = "PO"
	}
	var reduceOnly interface{} = nil
	var reduceOnlyRaw interface{} = this.SafeString(order, "reduceOnly")
	if IsTrue(!IsEqual(reduceOnlyRaw, nil)) {
		reduceOnly = Ternary(IsTrue((IsEqual(reduceOnlyRaw, "NO"))), false, true)
	}
	var price interface{} = nil
	var average interface{} = nil
	var basePrice interface{} = this.SafeString(order, "basePrice")
	if IsTrue(!IsEqual(basePrice, nil)) {
		// for spot fetchOpenOrders, the price is priceAvg and the filled price is basePrice
		price = this.SafeString(order, "priceAvg")
		average = this.SafeString(order, "basePrice")
	} else {
		price = this.SafeStringN(order, []interface{}{"price", "executePrice", "slLimitPrice", "tpLimitPrice"})
		average = this.SafeString(order, "priceAvg")
	}
	var size interface{} = nil
	var filled interface{} = nil
	var baseSize interface{} = this.SafeString(order, "baseSize")
	if IsTrue(!IsEqual(baseSize, nil)) {
		// for spot margin fetchOpenOrders, the order size is baseSize and the filled amount is size
		size = baseSize
		filled = this.SafeString(order, "size")
	} else {
		size = this.SafeString2(order, "size", "qty")
		filled = this.SafeString2(order, "baseVolume", "cumExecQty")
	}
	var side interface{} = this.SafeString(order, "side")
	var posMode interface{} = this.SafeString(order, "posMode")
	if IsTrue(IsTrue(IsEqual(posMode, "hedge_mode")) && IsTrue(reduceOnly)) {
		side = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
	}
	var orderType interface{} = this.SafeString(order, "orderType")
	var isBuyMarket interface{} = IsTrue((IsEqual(side, "buy"))) && IsTrue((IsEqual(orderType, "market")))
	if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue(isBuyMarket)) {
		// as noted in top comment, for 'buy market' the 'size' field is COST, not AMOUNT
		size = this.SafeString(order, "baseVolume")
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                order,
		"id":                  this.SafeString2(order, "orderId", "data"),
		"clientOrderId":       this.SafeString2(order, "clientOrderId", "clientOid"),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  updateTimestamp,
		"lastUpdateTimestamp": updateTimestamp,
		"symbol":              GetValue(market, "symbol"),
		"type":                orderType,
		"side":                side,
		"price":               price,
		"amount":              size,
		"cost":                this.SafeString2(order, "quoteVolume", "quoteSize"),
		"average":             average,
		"filled":              filled,
		"remaining":           nil,
		"timeInForce":         timeInForce,
		"postOnly":            postOnly,
		"reduceOnly":          reduceOnly,
		"triggerPrice":        this.SafeNumber(order, "triggerPrice"),
		"takeProfitPrice":     this.SafeNumberN(order, []interface{}{"presetStopSurplusPrice", "stopSurplusTriggerPrice", "takeProfit"}),
		"stopLossPrice":       this.SafeNumberN(order, []interface{}{"presetStopLossPrice", "stopLossTriggerPrice", "stopLoss"}),
		"status":              this.ParseOrderStatus(rawStatus),
		"fee":                 fee,
		"trades":              nil,
	}, market)
}

/**
 * @method
 * @name bitget#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes49628 := (<-this.LoadMarkets())
		PanicOnError(retRes49628)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
		}
		var req interface{} = map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": false,
		}

		retRes497015 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, this.Extend(req, params)))
		PanicOnError(retRes497015)
		ch <- retRes497015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#createOrder
 * @description create a trade order
 * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
 * @see https://www.bitget.com/api-doc/spot/plan/Place-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Place-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Place-Tpsl-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Place-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
 * @see https://www.bitget.com/api-doc/uta/trade/Place-Order
 * @see https://www.bitget.com/api-doc/uta/strategy/Place-Strategy-Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *spot only* how much you want to trade in units of the quote currency, for market buy orders only
 * @param {float} [params.triggerPrice] *swap only* The price at which a trigger order is triggered at
 * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {string} [params.loanType] *spot margin only* 'normal', 'autoLoan', 'autoRepay', or 'autoLoanAndRepay' default is 'normal'
 * @param {string} [params.holdSide] *contract stopLossPrice, takeProfitPrice only* Two-way position: ('long' or 'short'), one-way position: ('buy' or 'sell')
 * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
 * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
 * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
 * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
 * @param {string} [params.triggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
 * @param {boolean} [params.oneWayMode] *swap and future only* required to set this to true in one_way_mode and you can leave this as undefined in hedge_mode, can adjust the mode using the setPositionMode() method
 * @param {bool} [params.hedged] *swap and future only* true for hedged mode, false for one way mode, default is false
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {string} [params.posSide] *uta only* hedged two-way position side, long or short
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes50198 := (<-this.LoadMarkets())
		PanicOnError(retRes50198)
		var market interface{} = this.Market(symbol)
		var marginParams interface{} = this.HandleMarginModeAndParams("createOrder", params)
		var marginMode interface{} = GetValue(marginParams, 0)
		var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
		var stopLossTriggerPrice interface{} = this.SafeValue(params, "stopLossPrice")
		var takeProfitTriggerPrice interface{} = this.SafeValue(params, "takeProfitPrice")
		var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRatio")
		var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
		var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
		var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
		var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
		var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "createOrder", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			var request interface{} = this.CreateUtaOrderRequest(symbol, typeVar, side, amount, price, params)
			if IsTrue(isStopLossOrTakeProfitTrigger) {

				response = (<-this.PrivateUtaPostV3TradePlaceStrategyOrder(request))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateUtaPostV3TradePlaceOrder(request))
				PanicOnError(response)
			}
		} else {
			var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
			if IsTrue(GetValue(market, "spot")) {
				if IsTrue(isTriggerOrder) {

					response = (<-this.PrivateSpotPostV2SpotTradePlacePlanOrder(request))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.PrivateMarginPostV2MarginIsolatedPlaceOrder(request))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginPostV2MarginCrossedPlaceOrder(request))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateSpotPostV2SpotTradePlaceOrder(request))
					PanicOnError(response)
				}
			} else {
				if IsTrue(IsTrue(isTriggerOrder) || IsTrue(isTrailingPercentOrder)) {

					response = (<-this.PrivateMixPostV2MixOrderPlacePlanOrder(request))
					PanicOnError(response)
				} else if IsTrue(isStopLossOrTakeProfitTrigger) {

					response = (<-this.PrivateMixPostV2MixOrderPlaceTpslOrder(request))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateMixPostV2MixOrderPlaceOrder(request))
					PanicOnError(response)
				}
			}
		}
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1645932209602,
		//         "data": {
		//             "orderId": "881669078313766912",
		//             "clientOid": "iauIBf#a45b595f96474d888d0ada"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *bitget) CreateUtaOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var productType interface{} = nil
	productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
	productType = GetValue(productTypeparamsVariable, 0)
	params = GetValue(productTypeparamsVariable, 1)
	if IsTrue(IsEqual(productType, "SPOT")) {
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(!IsEqual(marginMode, nil)) {
			productType = "MARGIN"
		}
	}
	var request interface{} = map[string]interface{}{
		"category": productType,
		"symbol":   GetValue(market, "id"),
		"qty":      this.AmountToPrecision(symbol, amount),
		"side":     side,
	}
	var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(request, "clientOid", clientOrderId)
		params = this.Omit(params, "clientOrderId")
	}
	var stopLossTriggerPrice interface{} = this.SafeNumber(params, "stopLossPrice")
	var takeProfitTriggerPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
	var stopLoss interface{} = this.SafeValue(params, "stopLoss")
	var takeProfit interface{} = this.SafeValue(params, "takeProfit")
	var isStopLoss interface{} = !IsEqual(stopLoss, nil)
	var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
	var isStopLossTrigger interface{} = !IsEqual(stopLossTriggerPrice, nil)
	var isTakeProfitTrigger interface{} = !IsEqual(takeProfitTriggerPrice, nil)
	var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTrigger) || IsTrue(isTakeProfitTrigger)
	if IsTrue(isStopLossOrTakeProfitTrigger) {
		if IsTrue(isStopLossTrigger) {
			var slType interface{} = this.SafeString(params, "slTriggerBy", "mark")
			AddElementToObject(request, "slTriggerBy", slType)
			AddElementToObject(request, "stopLoss", this.PriceToPrecision(symbol, stopLossTriggerPrice))
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "slLimitPrice", this.PriceToPrecision(symbol, price))
				AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "limit"))
			} else {
				AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "market"))
			}
		} else if IsTrue(isTakeProfitTrigger) {
			var tpType interface{} = this.SafeString(params, "tpTriggerBy", "mark")
			AddElementToObject(request, "tpTriggerBy", tpType)
			AddElementToObject(request, "takeProfit", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "tpLimitPrice", this.PriceToPrecision(symbol, price))
				AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "limit"))
			} else {
				AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "market"))
			}
		}
		params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice"})
	} else {
		if IsTrue(isStopLoss) {
			var slTriggerPrice interface{} = this.SafeNumber2(stopLoss, "triggerPrice", "stopPrice")
			var slLimitPrice interface{} = this.SafeNumber(stopLoss, "price")
			AddElementToObject(request, "stopLoss", this.PriceToPrecision(symbol, slTriggerPrice))
			if IsTrue(!IsEqual(slLimitPrice, nil)) {
				AddElementToObject(request, "slLimitPrice", this.PriceToPrecision(symbol, slLimitPrice))
				AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "limit"))
			} else {
				AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "market"))
			}
		}
		if IsTrue(isTakeProfit) {
			var tpTriggerPrice interface{} = this.SafeNumber2(takeProfit, "triggerPrice", "stopPrice")
			var tpLimitPrice interface{} = this.SafeNumber(takeProfit, "price")
			AddElementToObject(request, "takeProfit", this.PriceToPrecision(symbol, tpTriggerPrice))
			if IsTrue(!IsEqual(tpLimitPrice, nil)) {
				AddElementToObject(request, "tpLimitPrice", this.PriceToPrecision(symbol, tpLimitPrice))
				AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "limit"))
			} else {
				AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "market"))
			}
		}
		var isMarketOrder interface{} = IsEqual(typeVar, "market")
		if !IsTrue(isMarketOrder) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}
		AddElementToObject(request, "orderType", typeVar)
		var exchangeSpecificTifParam interface{} = this.SafeString(params, "timeInForce")
		var postOnly interface{} = nil
		postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(exchangeSpecificTifParam, "post_only"), params)
		postOnly = GetValue(postOnlyparamsVariable, 0)
		params = GetValue(postOnlyparamsVariable, 1)
		var defaultTimeInForce interface{} = this.SafeStringUpper(this.Options, "defaultTimeInForce")
		var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce", defaultTimeInForce)
		if IsTrue(postOnly) {
			AddElementToObject(request, "timeInForce", "post_only")
		} else if IsTrue(IsEqual(timeInForce, "GTC")) {
			AddElementToObject(request, "timeInForce", "gtc")
		} else if IsTrue(IsEqual(timeInForce, "FOK")) {
			AddElementToObject(request, "timeInForce", "fok")
		} else if IsTrue(IsEqual(timeInForce, "IOC")) {
			AddElementToObject(request, "timeInForce", "ioc")
		}
	}
	var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
	var hedged interface{} = nil
	hedgedparamsVariable := this.HandleParamBool(params, "hedged", false)
	hedged = GetValue(hedgedparamsVariable, 0)
	params = GetValue(hedgedparamsVariable, 1)
	if IsTrue(reduceOnly) {
		if IsTrue(IsTrue(hedged) || IsTrue(isStopLossOrTakeProfitTrigger)) {
			var reduceOnlyPosSide interface{} = Ternary(IsTrue((IsEqual(side, "sell"))), "long", "short")
			AddElementToObject(request, "posSide", reduceOnlyPosSide)
		} else if !IsTrue(isStopLossOrTakeProfitTrigger) {
			AddElementToObject(request, "reduceOnly", "yes")
		}
	} else {
		if IsTrue(hedged) {
			var posSide interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), "long", "short")
			AddElementToObject(request, "posSide", posSide)
		}
	}
	params = this.Omit(params, []interface{}{"stopLoss", "takeProfit", "postOnly", "reduceOnly", "hedged"})
	return this.Extend(request, params)
}
func (this *bitget) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var marketType interface{} = nil
	var marginMode interface{} = nil
	marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params)
	marketType = GetValue(marketTypeparamsVariable, 0)
	params = GetValue(marketTypeparamsVariable, 1)
	marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	var request interface{} = map[string]interface{}{
		"symbol":    GetValue(market, "id"),
		"orderType": typeVar,
	}
	var hedged interface{} = nil
	hedgedparamsVariable := this.HandleParamBool(params, "hedged", false)
	hedged = GetValue(hedgedparamsVariable, 0)
	params = GetValue(hedgedparamsVariable, 1)
	// backward compatibility for `oneWayMode`
	var oneWayMode interface{} = nil
	oneWayModeparamsVariable := this.HandleParamBool(params, "oneWayMode")
	oneWayMode = GetValue(oneWayModeparamsVariable, 0)
	params = GetValue(oneWayModeparamsVariable, 1)
	if IsTrue(!IsEqual(oneWayMode, nil)) {
		hedged = !IsTrue(oneWayMode)
	}
	var isMarketOrder interface{} = IsEqual(typeVar, "market")
	var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
	var stopLossTriggerPrice interface{} = this.SafeValue(params, "stopLossPrice")
	var takeProfitTriggerPrice interface{} = this.SafeValue(params, "takeProfitPrice")
	var stopLoss interface{} = this.SafeValue(params, "stopLoss")
	var takeProfit interface{} = this.SafeValue(params, "takeProfit")
	var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
	var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
	var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
	var isStopLoss interface{} = !IsEqual(stopLoss, nil)
	var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
	var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
	var isStopLossOrTakeProfit interface{} = IsTrue(isStopLoss) || IsTrue(isTakeProfit)
	var trailingTriggerPrice interface{} = this.SafeString(params, "trailingTriggerPrice", this.NumberToString(price))
	var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRatio")
	var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
	if IsTrue(IsGreaterThan(this.Sum(isTriggerOrder, isStopLossTriggerOrder, isTakeProfitTriggerOrder, isTrailingPercentOrder), 1)) {
		panic(ExchangeError(Add(this.Id, " createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")))
	}
	if IsTrue(IsEqual(typeVar, "limit")) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var triggerPriceType interface{} = this.SafeString2(params, "triggerPriceType", "triggerType", "mark_price")
	var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
	var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
	var exchangeSpecificTifParam interface{} = this.SafeString2(params, "force", "timeInForce")
	var postOnly interface{} = nil
	postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(exchangeSpecificTifParam, "post_only"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	var defaultTimeInForce interface{} = this.SafeStringUpper(this.Options, "defaultTimeInForce")
	var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce", defaultTimeInForce)
	if IsTrue(postOnly) {
		AddElementToObject(request, "force", "post_only")
	} else if IsTrue(IsEqual(timeInForce, "GTC")) {
		AddElementToObject(request, "force", "GTC")
	} else if IsTrue(IsEqual(timeInForce, "FOK")) {
		AddElementToObject(request, "force", "FOK")
	} else if IsTrue(IsEqual(timeInForce, "IOC")) {
		AddElementToObject(request, "force", "IOC")
	}
	params = this.Omit(params, []interface{}{"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "postOnly", "reduceOnly", "clientOrderId", "trailingPercent", "trailingTriggerPrice"})
	if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
		AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
		AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		AddElementToObject(request, "productType", productType)
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
		}
		if IsTrue(IsTrue(IsTrue(isTriggerOrder) || IsTrue(isStopLossOrTakeProfitTrigger)) || IsTrue(isTrailingPercentOrder)) {
			AddElementToObject(request, "triggerType", triggerPriceType)
		}
		if IsTrue(isTrailingPercentOrder) {
			if !IsTrue(isMarketOrder) {
				panic(BadRequest(Add(this.Id, " createOrder() bitget trailing orders must be market orders")))
			}
			if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " createOrder() bitget trailing orders must have a trailingTriggerPrice param")))
			}
			AddElementToObject(request, "planType", "track_plan")
			AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
			AddElementToObject(request, "callbackRatio", trailingPercent)
		} else if IsTrue(isTriggerOrder) {
			AddElementToObject(request, "planType", "normal_plan")
			AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
			}
			if IsTrue(isStopLoss) {
				var slTriggerPrice interface{} = this.SafeString2(stopLoss, "triggerPrice", "stopPrice")
				AddElementToObject(request, "stopLossTriggerPrice", this.PriceToPrecision(symbol, slTriggerPrice))
				var slPrice interface{} = this.SafeString(stopLoss, "price")
				AddElementToObject(request, "stopLossExecutePrice", this.PriceToPrecision(symbol, slPrice))
				var slType interface{} = this.SafeString(stopLoss, "type", "mark_price")
				AddElementToObject(request, "stopLossTriggerType", slType)
			}
			if IsTrue(isTakeProfit) {
				var tpTriggerPrice interface{} = this.SafeString2(takeProfit, "triggerPrice", "stopPrice")
				AddElementToObject(request, "stopSurplusTriggerPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
				var tpPrice interface{} = this.SafeString(takeProfit, "price")
				AddElementToObject(request, "stopSurplusExecutePrice", this.PriceToPrecision(symbol, tpPrice))
				var tpType interface{} = this.SafeString(takeProfit, "type", "mark_price")
				AddElementToObject(request, "stopSurplusTriggerType", tpType)
			}
		} else if IsTrue(isStopLossOrTakeProfitTrigger) {
			if !IsTrue(isMarketOrder) {
				panic(ExchangeError(Add(this.Id, " createOrder() bitget stopLoss or takeProfit orders must be market orders")))
			}
			if IsTrue(hedged) {
				AddElementToObject(request, "holdSide", Ternary(IsTrue((IsEqual(side, "sell"))), "long", "short"))
			} else {
				AddElementToObject(request, "holdSide", Ternary(IsTrue((IsEqual(side, "sell"))), "buy", "sell"))
			}
			if IsTrue(isStopLossTriggerOrder) {
				AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, stopLossTriggerPrice))
				AddElementToObject(request, "planType", "pos_loss")
			} else if IsTrue(isTakeProfitTriggerOrder) {
				AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
				AddElementToObject(request, "planType", "pos_profit")
			}
		} else {
			if IsTrue(isStopLoss) {
				var slTriggerPrice interface{} = this.SafeValue2(stopLoss, "triggerPrice", "stopPrice")
				AddElementToObject(request, "presetStopLossPrice", this.PriceToPrecision(symbol, slTriggerPrice))
			}
			if IsTrue(isTakeProfit) {
				var tpTriggerPrice interface{} = this.SafeValue2(takeProfit, "triggerPrice", "stopPrice")
				AddElementToObject(request, "presetStopSurplusPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
			}
		}
		if !IsTrue(isStopLossOrTakeProfitTrigger) {
			if IsTrue(IsEqual(marginMode, nil)) {
				marginMode = "cross"
			}
			var marginModeRequest interface{} = Ternary(IsTrue((IsEqual(marginMode, "cross"))), "crossed", "isolated")
			AddElementToObject(request, "marginMode", marginModeRequest)
			var requestSide interface{} = side
			if IsTrue(reduceOnly) {
				if !IsTrue(hedged) {
					AddElementToObject(request, "reduceOnly", "YES")
				} else {
					// on bitget hedge mode if the position is long the side is always buy, and if the position is short the side is always sell
					requestSide = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
					AddElementToObject(request, "tradeSide", "Close")
				}
			} else {
				if IsTrue(hedged) {
					AddElementToObject(request, "tradeSide", "Open")
				}
			}
			AddElementToObject(request, "side", requestSide)
		}
	} else if IsTrue(IsEqual(marketType, "spot")) {
		if IsTrue(IsTrue(isStopLossOrTakeProfitTrigger) || IsTrue(isStopLossOrTakeProfit)) {
			panic(InvalidOrder(Add(this.Id, " createOrder() does not support stop loss/take profit orders on spot markets, only swap markets")))
		}
		AddElementToObject(request, "side", side)
		var quantity interface{} = nil
		var planType interface{} = nil
		var createMarketBuyOrderRequiresPrice interface{} = true
		createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
		createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
		params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
		if IsTrue(IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))) {
			planType = "total"
			var cost interface{} = this.SafeNumber(params, "cost")
			params = this.Omit(params, "cost")
			if IsTrue(!IsEqual(cost, nil)) {
				quantity = this.CostToPrecision(symbol, cost)
			} else if IsTrue(createMarketBuyOrderRequiresPrice) {
				if IsTrue(IsEqual(price, nil)) {
					panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
				} else {
					var amountString interface{} = this.NumberToString(amount)
					var priceString interface{} = this.NumberToString(price)
					var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
					quantity = this.CostToPrecision(symbol, quoteAmount)
				}
			} else {
				quantity = this.CostToPrecision(symbol, amount)
			}
		} else {
			planType = "amount"
			quantity = this.AmountToPrecision(symbol, amount)
		}
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
		}
		if IsTrue(!IsEqual(marginMode, nil)) {
			AddElementToObject(request, "loanType", "normal")
			if IsTrue(IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))) {
				AddElementToObject(request, "quoteSize", quantity)
			} else {
				AddElementToObject(request, "baseSize", quantity)
			}
		} else {
			if IsTrue(!IsEqual(quantity, nil)) {
				AddElementToObject(request, "size", quantity)
			}
			if IsTrue(!IsEqual(triggerPrice, nil)) {
				AddElementToObject(request, "planType", planType)
				AddElementToObject(request, "triggerType", triggerPriceType)
				AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
				if IsTrue(!IsEqual(price, nil)) {
					AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
				}
			}
		}
	} else {
		panic(NotSupported(Add(Add(Add(this.Id, " createOrder() does not support "), marketType), " orders")))
	}
	return this.Extend(request, params)
}
func (this *bitget) CreateUtaOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes54078 := (<-this.LoadMarkets())
		PanicOnError(retRes54078)
		var ordersRequests interface{} = []interface{}{}
		var symbol interface{} = nil
		var marginMode interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				symbol = marketId
			} else {
				if IsTrue(!IsEqual(symbol, marketId)) {
					panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
				}
			}
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{}{})
			var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
			var currentMarginMode interface{} = GetValue(marginResult, 0)
			if IsTrue(!IsEqual(currentMarginMode, nil)) {
				if IsTrue(IsEqual(marginMode, nil)) {
					marginMode = currentMarginMode
				} else {
					if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
						panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
					}
				}
			}
			var orderRequest interface{} = this.CreateUtaOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var market interface{} = this.Market(symbol)

		response := (<-this.PrivateUtaPostV3TradePlaceBatch(ordersRequests))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1752810184560,
		//         "data": [
		//             {
		//                 "orderId": "1329947796441513984",
		//                 "clientOid": "1329947796483457024"
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://www.bitget.com/api-doc/spot/trade/Batch-Place-Orders
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Order
 * @see https://www.bitget.com/api-doc/uta/trade/Place-Batch
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the api endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes54748 := (<-this.LoadMarkets())
		PanicOnError(retRes54748)
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "createOrders", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			retRes547819 := (<-this.CreateUtaOrders(orders, params))
			PanicOnError(retRes547819)
			ch <- retRes547819
			return nil
		}
		var ordersRequests interface{} = []interface{}{}
		var symbol interface{} = nil
		var marginMode interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				symbol = marketId
			} else {
				if IsTrue(!IsEqual(symbol, marketId)) {
					panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
				}
			}
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{}{})
			var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
			var currentMarginMode interface{} = GetValue(marginResult, 0)
			if IsTrue(!IsEqual(currentMarginMode, nil)) {
				if IsTrue(IsEqual(marginMode, nil)) {
					marginMode = currentMarginMode
				} else {
					if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
						panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
					}
				}
			}
			var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":    GetValue(market, "id"),
			"orderList": ordersRequests,
		}
		var response interface{} = nil
		if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
			if IsTrue(IsEqual(marginMode, nil)) {
				marginMode = "cross"
			}
			var marginModeRequest interface{} = Ternary(IsTrue((IsEqual(marginMode, "cross"))), "crossed", "isolated")
			AddElementToObject(request, "marginMode", marginModeRequest)
			AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixPostV2MixOrderBatchPlaceOrder(request))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "isolated")) {

			response = (<-this.PrivateMarginPostV2MarginIsolatedBatchPlaceOrder(request))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "cross")) {

			response = (<-this.PrivateMarginPostV2MarginCrossedBatchPlaceOrder(request))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateSpotPostV2SpotTradeBatchOrders(request))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700703539416,
		//         "data": {
		//             "successList": [
		//                 {
		//                     "orderId": "1111397214281175046",
		//                     "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
		//                 },
		//             ],
		//             "failureList": [
		//                 {
		//                     "orderId": "",
		//                     "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
		//                     "errorMsg": "less than the minimum amount 5 USDT",
		//                     "errorCode": "45110"
		//                 },
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var failure interface{} = this.SafeValue(data, "failureList", []interface{}{})
		var orderInfo interface{} = this.SafeValue(data, "successList", []interface{}{})
		var both interface{} = this.ArrayConcat(orderInfo, failure)

		ch <- this.ParseOrders(both, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#editOrder
 * @description edit a trade order
 * @see https://www.bitget.com/api-doc/spot/plan/Modify-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Modify-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Modify-Tpsl-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Modify-Plan-Order
 * @see https://www.bitget.com/api-doc/uta/trade/Modify-Order
 * @see https://www.bitget.com/api-doc/uta/strategy/Modify-Strategy-Order
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
 * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
 * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
 * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
 * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
 * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
 * @param {string} [params.newTriggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes56018 := (<-this.LoadMarkets())
		PanicOnError(retRes56018)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"orderId": id,
		}
		var isMarketOrder interface{} = IsEqual(typeVar, "market")
		var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
		var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
		var stopLossPrice interface{} = this.SafeValue(params, "stopLossPrice")
		var isStopLossOrder interface{} = !IsEqual(stopLossPrice, nil)
		var takeProfitPrice interface{} = this.SafeValue(params, "takeProfitPrice")
		var isTakeProfitOrder interface{} = !IsEqual(takeProfitPrice, nil)
		var stopLoss interface{} = this.SafeValue(params, "stopLoss")
		var takeProfit interface{} = this.SafeValue(params, "takeProfit")
		var isStopLoss interface{} = !IsEqual(stopLoss, nil)
		var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
		var trailingTriggerPrice interface{} = this.SafeString(params, "trailingTriggerPrice", this.NumberToString(price))
		var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "newCallbackRatio")
		var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
		if IsTrue(IsGreaterThan(this.Sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder, isTrailingPercentOrder), 1)) {
			panic(ExchangeError(Add(this.Id, " editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")))
		}
		var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
		}
		params = this.Omit(params, []interface{}{"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "clientOrderId", "trailingTriggerPrice", "trailingPercent"})
		var response interface{} = nil
		var productType interface{} = nil
		var uta interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "editOrder", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(!IsEqual(amount, nil)) {
				AddElementToObject(request, "qty", this.AmountToPrecision(symbol, amount))
			}
			if IsTrue(IsTrue(isStopLossOrder) || IsTrue(isTakeProfitOrder)) {
				if IsTrue(isStopLossOrder) {
					var slType interface{} = this.SafeString(params, "slTriggerBy", "mark")
					AddElementToObject(request, "slTriggerBy", slType)
					AddElementToObject(request, "stopLoss", this.PriceToPrecision(symbol, stopLossPrice))
					if IsTrue(!IsEqual(price, nil)) {
						AddElementToObject(request, "slLimitPrice", this.PriceToPrecision(symbol, price))
						AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "limit"))
					} else {
						AddElementToObject(request, "slOrderType", this.SafeString(params, "slOrderType", "market"))
					}
				} else if IsTrue(isTakeProfitOrder) {
					var tpType interface{} = this.SafeString(params, "tpTriggerBy", "mark")
					AddElementToObject(request, "tpTriggerBy", tpType)
					AddElementToObject(request, "takeProfit", this.PriceToPrecision(symbol, takeProfitPrice))
					if IsTrue(!IsEqual(price, nil)) {
						AddElementToObject(request, "tpLimitPrice", this.PriceToPrecision(symbol, price))
						AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "limit"))
					} else {
						AddElementToObject(request, "tpOrderType", this.SafeString(params, "tpOrderType", "market"))
					}
				}
				params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice"})

				response = (<-this.PrivateUtaPostV3TradeModifyStrategyOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				if IsTrue(!IsEqual(price, nil)) {
					AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
				}

				response = (<-this.PrivateUtaPostV3TradeModifyOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "spot")) {
			if IsTrue(IsEqual(triggerPrice, nil)) {
				panic(NotSupported(Add(this.Id, " editOrder() only supports plan/trigger spot orders")))
			}
			var editMarketBuyOrderRequiresPrice interface{} = this.SafeBool(this.Options, "editMarketBuyOrderRequiresPrice", true)
			if IsTrue(IsTrue(IsTrue(editMarketBuyOrderRequiresPrice) && IsTrue(isMarketOrder)) && IsTrue((IsEqual(side, "buy")))) {
				if IsTrue(IsEqual(price, nil)) {
					panic(InvalidOrder(Add(this.Id, " editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the editMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")))
				} else {
					var amountString interface{} = this.NumberToString(amount)
					var priceString interface{} = this.NumberToString(price)
					var cost interface{} = this.ParseNumber(Precise.StringMul(amountString, priceString))
					AddElementToObject(request, "size", this.PriceToPrecision(symbol, cost))
				}
			} else {
				AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
			}
			AddElementToObject(request, "orderType", typeVar)
			AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
			AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))

			response = (<-this.PrivateSpotPostV2SpotTradeModifyPlanOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsTrue((!IsTrue(GetValue(market, "swap")))) && IsTrue((!IsTrue(GetValue(market, "future"))))) {
				panic(NotSupported(Add(Add(Add(this.Id, " editOrder() does not support "), GetValue(market, "type")), " orders")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			AddElementToObject(request, "productType", productType)
			if IsTrue(!IsTrue(isTakeProfitOrder) && !IsTrue(isStopLossOrder)) {
				AddElementToObject(request, "newSize", this.AmountToPrecision(symbol, amount))
				if IsTrue(IsTrue((!IsEqual(price, nil))) && !IsTrue(isTrailingPercentOrder)) {
					AddElementToObject(request, "newPrice", this.PriceToPrecision(symbol, price))
				}
			}
			if IsTrue(isTrailingPercentOrder) {
				if !IsTrue(isMarketOrder) {
					panic(BadRequest(Add(this.Id, " editOrder() bitget trailing orders must be market orders")))
				}
				if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
					AddElementToObject(request, "newTriggerPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
				}
				AddElementToObject(request, "newCallbackRatio", trailingPercent)

				response = (<-this.PrivateMixPostV2MixOrderModifyPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsTrue(isTakeProfitOrder) || IsTrue(isStopLossOrder)) {
				AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
				AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
				if IsTrue(!IsEqual(price, nil)) {
					AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
				}
				if IsTrue(isStopLossOrder) {
					AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, stopLossPrice))
				} else if IsTrue(isTakeProfitOrder) {
					AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, takeProfitPrice))
				}

				response = (<-this.PrivateMixPostV2MixOrderModifyTpslOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(isTriggerOrder) {
				AddElementToObject(request, "newTriggerPrice", this.PriceToPrecision(symbol, triggerPrice))
				if IsTrue(isStopLoss) {
					var slTriggerPrice interface{} = this.SafeNumber2(stopLoss, "triggerPrice", "stopPrice")
					AddElementToObject(request, "newStopLossTriggerPrice", this.PriceToPrecision(symbol, slTriggerPrice))
					var slPrice interface{} = this.SafeNumber(stopLoss, "price")
					AddElementToObject(request, "newStopLossExecutePrice", this.PriceToPrecision(symbol, slPrice))
					var slType interface{} = this.SafeString(stopLoss, "type", "mark_price")
					AddElementToObject(request, "newStopLossTriggerType", slType)
				}
				if IsTrue(isTakeProfit) {
					var tpTriggerPrice interface{} = this.SafeNumber2(takeProfit, "triggerPrice", "stopPrice")
					AddElementToObject(request, "newSurplusTriggerPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
					var tpPrice interface{} = this.SafeNumber(takeProfit, "price")
					AddElementToObject(request, "newStopSurplusExecutePrice", this.PriceToPrecision(symbol, tpPrice))
					var tpType interface{} = this.SafeString(takeProfit, "type", "mark_price")
					AddElementToObject(request, "newStopSurplusTriggerType", tpType)
				}

				response = (<-this.PrivateMixPostV2MixOrderModifyPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				var defaultNewClientOrderId interface{} = this.Uuid()
				var newClientOrderId interface{} = this.SafeString2(params, "newClientOid", "newClientOrderId", defaultNewClientOrderId)
				params = this.Omit(params, "newClientOrderId")
				AddElementToObject(request, "newClientOid", newClientOrderId)
				if IsTrue(isStopLoss) {
					var slTriggerPrice interface{} = this.SafeValue2(stopLoss, "triggerPrice", "stopPrice")
					AddElementToObject(request, "newPresetStopLossPrice", this.PriceToPrecision(symbol, slTriggerPrice))
				}
				if IsTrue(isTakeProfit) {
					var tpTriggerPrice interface{} = this.SafeValue2(takeProfit, "triggerPrice", "stopPrice")
					AddElementToObject(request, "newPresetStopSurplusPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
				}

				response = (<-this.PrivateMixPostV2MixOrderModifyOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700708275737,
		//         "data": {
		//             "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd459",
		//             "orderId": null
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#cancelOrder
 * @description cancels an open order
 * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Order
 * @see https://www.bitget.com/api-doc/spot/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Cancel-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Cancel-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Cancel-Order
 * @see https://www.bitget.com/api-doc/uta/trade/Cancel-Order
 * @see https://www.bitget.com/api-doc/uta/strategy/Cancel-Strategy-Order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] set to true for canceling trigger orders
 * @param {string} [params.planType] *swap only* either profit_plan, loss_plan, normal_plan, pos_profit, pos_loss, moving_plan or track_plan
 * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {string} [params.clientOrderId] the clientOrderId of the order, id does not need to be provided if clientOrderId is provided
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}

		retRes57988 := (<-this.LoadMarkets())
		PanicOnError(retRes57988)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = nil
		var response interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var trailing interface{} = this.SafeValue(params, "trailing")
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		params = this.Omit(params, []interface{}{"stop", "trigger", "trailing"})
		if !IsTrue((IsTrue(GetValue(market, "spot")) && IsTrue(trigger))) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "cancelOrder", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		var isPlanOrder interface{} = IsTrue(trigger) || IsTrue(trailing)
		var isContract interface{} = IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))
		var isContractTriggerEndpoint interface{} = IsTrue(IsTrue(isContract) && IsTrue(isPlanOrder)) && !IsTrue(uta)
		var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientOid")
		if IsTrue(isContractTriggerEndpoint) {
			var orderIdList interface{} = []interface{}{}
			var orderId interface{} = map[string]interface{}{}
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				params = this.Omit(params, "clientOrderId")
				AddElementToObject(orderId, "clientOid", clientOrderId)
			} else {
				AddElementToObject(orderId, "orderId", id)
			}
			AppendToArray(&orderIdList, orderId)
			AddElementToObject(request, "orderIdList", orderIdList)
		} else {
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				params = this.Omit(params, "clientOrderId")
				AddElementToObject(request, "clientOid", clientOrderId)
			} else {
				AddElementToObject(request, "orderId", id)
			}
		}
		if IsTrue(uta) {
			if IsTrue(trigger) {

				response = (<-this.PrivateUtaPostV3TradeCancelStrategyOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateUtaPostV3TradeCancelOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)
			if IsTrue(trailing) {
				var planType interface{} = this.SafeString(params, "planType", "track_plan")
				AddElementToObject(request, "planType", planType)

				response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(trigger) {

				response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateMixPostV2MixOrderCancelOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.PrivateMarginPostV2MarginIsolatedCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginPostV2MarginCrossedCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {
				if IsTrue(trigger) {

					response = (<-this.PrivateSpotPostV2SpotTradeCancelPlanOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateSpotPostV2SpotTradeCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " cancelOrder() does not support "), GetValue(market, "type")), " orders")))
		}
		//
		// spot, swap, future and spot margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1697690413177,
		//         "data": {
		//             "orderId": "1098758604547850241",
		//             "clientOid": "1098758604585598977"
		//         }
		//     }
		//
		// swap trigger
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700711311791,
		//         "data": {
		//             "successList": [
		//                 {
		//                     "clientOid": "1111428059067125760",
		//                     "orderId": "1111428059067125761"
		//                 }
		//             ],
		//             "failureList": []
		//         }
		//     }
		//
		// spot trigger
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700711728063,
		//         "data": {
		//             "result": "success"
		//         }
		//     }
		//
		// uta trigger
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": "1753058267399",
		//         "data": null
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var order interface{} = nil
		if IsTrue(isContractTriggerEndpoint) {
			var orderInfo interface{} = this.SafeValue(data, "successList", []interface{}{})
			order = GetValue(orderInfo, 0)
		} else {
			if IsTrue(IsTrue(uta) && IsTrue(trigger)) {
				order = response
			} else {
				order = data
			}
		}

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}
func (this *bitget) CancelUtaOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes59408 := (<-this.LoadMarkets())
		PanicOnError(retRes59408)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var requestList interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
			var individualId interface{} = GetValue(ids, i)
			var order interface{} = map[string]interface{}{
				"orderId":  individualId,
				"symbol":   GetValue(market, "id"),
				"category": productType,
			}
			AppendToArray(&requestList, order)
		}

		response := (<-this.PrivateUtaPostV3TradeCancelBatch(requestList))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1752813731517,
		//         "data": [
		//             {
		//                 "orderId": "1329948909442023424",
		//                 "clientOid": "1329948909446217728"
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#cancelOrders
 * @description cancel multiple orders
 * @see https://www.bitget.com/api-doc/spot/trade/Batch-Cancel-Orders
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
 * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Cancel-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Cancel-Orders
 * @see https://www.bitget.com/api-doc/uta/trade/Cancel-Batch
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} an array of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes59948 := (<-this.LoadMarkets())
		PanicOnError(retRes59948)
		var market interface{} = this.Market(symbol)
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "cancelOrders", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			retRes599919 := (<-this.CancelUtaOrders(ids, symbol, params))
			PanicOnError(retRes599919)
			ch <- retRes599919
			return nil
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrders", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		params = this.Omit(params, []interface{}{"stop", "trigger"})
		var orderIdList interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
			var individualId interface{} = GetValue(ids, i)
			var orderId interface{} = map[string]interface{}{
				"orderId": individualId,
			}
			AppendToArray(&orderIdList, orderId)
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue((IsEqual(marginMode, nil)))) {
			AddElementToObject(request, "orderList", orderIdList)
		} else {
			AddElementToObject(request, "orderIdList", orderIdList)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginPostV2MarginCrossedBatchCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateMarginPostV2MarginIsolatedBatchCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {

				response = (<-this.PrivateSpotPostV2SpotTradeBatchCancelOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)
			if IsTrue(trigger) {

				response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateMixPostV2MixOrderBatchCancelOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": "1680008815965",
		//         "data": {
		//             "successList": [
		//                 {
		//                     "orderId": "1024598257429823488",
		//                     "clientOid": "876493ce-c287-4bfc-9f4a-8b1905881313"
		//                 },
		//             ],
		//             "failureList": []
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList(data, "successList", []interface{}{})

		ch <- this.ParseOrders(orders, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#cancelAllOrders
 * @description cancel all open orders
 * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Symbol-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Batch-Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#isolated-batch-cancel-orders
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#cross-batch-cancel-order
 * @see https://www.bitget.com/api-doc/uta/trade/Cancel-All-Order
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}

		retRes60848 := (<-this.LoadMarkets())
		PanicOnError(retRes60848)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		params = this.Omit(params, []interface{}{"stop", "trigger"})
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrders", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(IsEqual(productType, "SPOT")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					productType = "MARGIN"
				}
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaPostV3TradeCancelSymbolOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginPostMarginV1CrossOrderBatchCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateMarginPostMarginV1IsolatedOrderBatchCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {
				if IsTrue(trigger) {
					var stopRequest interface{} = map[string]interface{}{
						"symbolList": []interface{}{GetValue(market, "id")},
					}

					response = (<-this.PrivateSpotPostV2SpotTradeBatchCancelPlanOrder(this.Extend(stopRequest, params)))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateSpotPostV2SpotTradeCancelSymbolOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
				//
				//     {
				//         "code": "00000",
				//         "msg": "success",
				//         "requestTime": 1700716953996,
				//         "data": {
				//             "symbol": "BTCUSDT"
				//         }
				//     }
				//
				var timestamp interface{} = this.SafeInteger(response, "requestTime")
				var responseData interface{} = this.SafeDict(response, "data")
				var marketId interface{} = this.SafeString(responseData, "symbol")

				ch <- []interface{}{this.SafeOrder(map[string]interface{}{
					"info":      response,
					"symbol":    this.SafeSymbol(marketId, nil, nil, "spot"),
					"timestamp": timestamp,
					"datetime":  this.Iso8601(timestamp),
				})}
				return nil
			}
		} else {
			AddElementToObject(request, "productType", productType)
			if IsTrue(trigger) {

				response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateMixPostV2MixOrderBatchCancelOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		var data interface{} = this.SafeDict(response, "data")
		var resultList interface{} = this.SafeListN(data, []interface{}{"resultList", "successList", "list"})
		var failureList interface{} = this.SafeList2(data, "failure", "failureList")
		var responseList interface{} = nil
		if IsTrue(IsTrue((!IsEqual(resultList, nil))) && IsTrue((!IsEqual(failureList, nil)))) {
			responseList = this.ArrayConcat(resultList, failureList)
		} else {
			responseList = resultList
		}

		ch <- this.ParseOrders(responseList)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Order-Info
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Details
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-Details
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {string} [params.clientOrderId] the clientOrderId of the order, id does not need to be provided if clientOrderId is provided
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
		}

		retRes62278 := (<-this.LoadMarkets())
		PanicOnError(retRes62278)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientOid")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			params = this.Omit(params, []interface{}{"clientOrderId"})
			AddElementToObject(request, "clientOid", clientOrderId)
		} else {
			AddElementToObject(request, "orderId", id)
		}
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchOrder", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			response = (<-this.PrivateUtaGetV3TradeOrderInfo(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PrivateSpotGetV2SpotTradeOrderInfo(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixOrderDetail(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchOrder() does not support "), GetValue(market, "type")), " orders")))
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700719076263,
		//         "data": [
		//             {
		//                 "userId": "7264631750",
		//                 "symbol": "BTCUSDT",
		//                 "orderId": "1111461743123927040",
		//                 "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
		//                 "price": "25000.0000000000000000",
		//                 "size": "0.0002000000000000",
		//                 "orderType": "limit",
		//                 "side": "buy",
		//                 "status": "live",
		//                 "priceAvg": "0",
		//                 "baseVolume": "0.0000000000000000",
		//                 "quoteVolume": "0.0000000000000000",
		//                 "enterPointSource": "API",
		//                 "feeDetail": "",
		//                 "orderSource": "normal",
		//                 "cTime": "1700719050198",
		//                 "uTime": "1700719050198"
		//             }
		//         ]
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700719918781,
		//         "data": {
		//             "symbol": "BTCUSDT",
		//             "size": "0.001",
		//             "orderId": "1111465253393825792",
		//             "clientOid": "1111465253431574529",
		//             "baseVolume": "0",
		//             "fee": "0",
		//             "price": "27000",
		//             "priceAvg": "",
		//             "state": "live",
		//             "side": "buy",
		//             "force": "gtc",
		//             "totalProfits": "0",
		//             "posSide": "long",
		//             "marginCoin": "USDT",
		//             "presetStopSurplusPrice": "",
		//             "presetStopLossPrice": "",
		//             "quoteVolume": "0",
		//             "orderType": "limit",
		//             "leverage": "20",
		//             "marginMode": "crossed",
		//             "reduceOnly": "NO",
		//             "enterPointSource": "API",
		//             "tradeSide": "open",
		//             "posMode": "hedge_mode",
		//             "orderSource": "normal",
		//             "cTime": "1700719887120",
		//             "uTime": "1700719887120"
		//         }
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750496858333,
		//         "data": {
		//             "orderId": "1320244799629316096",
		//             "clientOid": "1320244799633510400",
		//             "category": "USDT-FUTURES",
		//             "symbol": "BTCUSDT",
		//             "orderType": "limit",
		//             "side": "buy",
		//             "price": "50000",
		//             "qty": "0.001",
		//             "amount": "0",
		//             "cumExecQty": "0",
		//             "cumExecValue": "0",
		//             "avgPrice": "0",
		//             "timeInForce": "gtc",
		//             "orderStatus": "live",
		//             "posSide": "long",
		//             "holdMode": "hedge_mode",
		//             "reduceOnly": "NO",
		//             "feeDetail": [{
		//                 "feeCoin": "",
		//                 "fee": ""
		//             }],
		//             "createdTime": "1750496809871",
		//             "updatedTime": "1750496809886",
		//             "cancelReason": "",
		//             "execType": "normal",
		//             "stpMode": "none",
		//             "tpTriggerBy": null,
		//             "slTriggerBy": null,
		//             "takeProfit": null,
		//             "stopLoss": null,
		//             "tpOrderType": null,
		//             "slOrderType": null,
		//             "tpLimitPrice": null,
		//             "slLimitPrice": null
		//         }
		//     }
		//
		if IsTrue(!IsTrue(uta) && IsTrue((IsString(response)))) {
			response = JsonParse(response)
		}
		var data interface{} = this.SafeDict(response, "data")
		if IsTrue((!IsEqual(data, nil))) {
			if !IsTrue(IsArray(data)) {

				ch <- this.ParseOrder(data, market)
				return nil
			}
		}
		var dataList interface{} = this.SafeList(response, "data", []interface{}{})
		var dataListLength interface{} = GetArrayLength(dataList)
		if IsTrue(IsEqual(dataListLength, 0)) {
			panic(OrderNotFound(Add(Add(Add(Add(this.Id, " fetchOrder() could not find order id "), id), " in "), this.Json(response))))
		}
		var first interface{} = this.SafeDict(dataList, 0, map[string]interface{}{})

		ch <- this.ParseOrder(first, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Unfilled-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-Current-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-Pending
 * @see https://www.bitget.com/api-doc/contract/plan/get-orders-plan-pending
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Open-Orders
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Open-Orders
 * @see https://www.bitget.com/api-doc/uta/strategy/Get-Unfilled-Strategy-Orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes64118 := (<-this.LoadMarkets())
		PanicOnError(retRes64118)
		var market interface{} = nil
		var typeVar interface{} = nil
		var request interface{} = map[string]interface{}{}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			var defaultType interface{} = this.SafeString2(this.Options, "fetchOpenOrders", "defaultType", "spot")
			var marketType interface{} = Ternary(IsTrue((InOp(market, "type"))), GetValue(market, "type"), defaultType)
			typeVar = this.SafeString(params, "type", marketType)
		} else {
			var defaultType interface{} = this.SafeString2(this.Options, "fetchOpenOrders", "defaultType", "spot")
			typeVar = this.SafeString(params, "type", defaultType)
		}
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			var cursorReceived interface{} = nil
			var cursorSent interface{} = nil
			if IsTrue(uta) {
				cursorReceived = "cursor"
				cursorSent = "cursor"
			} else if IsTrue(IsEqual(typeVar, "spot")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					cursorReceived = "minId"
					cursorSent = "idLessThan"
				}
			} else {
				cursorReceived = "endId"
				cursorSent = "idLessThan"
			}

			retRes644619 := (<-this.FetchPaginatedCallCursor("fetchOpenOrders", symbol, since, limit, params, cursorReceived, cursorSent))
			PanicOnError(retRes644619)
			ch <- retRes644619
			return nil
		}
		var response interface{} = nil
		var trailing interface{} = this.SafeBool(params, "trailing")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		var planTypeDefined interface{} = !IsEqual(this.SafeString(params, "planType"), nil)
		var isTrigger interface{} = (IsTrue(trigger) || IsTrue(planTypeDefined))
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsTrue(uta) && IsTrue((IsTrue(IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future")))) || IsTrue((!IsEqual(marginMode, nil)))))) {
			var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
			params = this.Omit(params, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "clientOid", clientOrderId)
			}
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		params = this.Omit(params, []interface{}{"type", "stop", "trigger", "trailing"})
		if IsTrue(uta) {
			if IsTrue(IsEqual(typeVar, "spot")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					productType = "MARGIN"
				}
			}
			AddElementToObject(request, "category", productType)
			if IsTrue(trigger) {

				response = (<-this.PrivateUtaGetV3TradeUnfilledStrategyOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateUtaGetV3TradeUnfilledOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(IsEqual(typeVar, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(IsEqual(since, nil)) {
					since = Subtract(this.Milliseconds(), 7776000000)
					AddElementToObject(request, "startTime", since)
				}
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.PrivateMarginGetV2MarginIsolatedOpenOrders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginGetV2MarginCrossedOpenOrders(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {
				if IsTrue(trigger) {

					response = (<-this.PrivateSpotGetV2SpotTradeCurrentPlanOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.PrivateSpotGetV2SpotTradeUnfilledOrders(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else {
			AddElementToObject(request, "productType", productType)
			if IsTrue(trailing) {
				var planType interface{} = this.SafeString(params, "planType", "track_plan")
				AddElementToObject(request, "planType", planType)

				response = (<-this.PrivateMixGetV2MixOrderOrdersPlanPending(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(isTrigger) {
				var planType interface{} = this.SafeString(params, "planType", "normal_plan")
				AddElementToObject(request, "planType", planType)

				response = (<-this.PrivateMixGetV2MixOrderOrdersPlanPending(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateMixGetV2MixOrderOrdersPending(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700728123994,
		//         "data": [
		//             {
		//                 "userId": "7264631750",
		//                 "symbol": "BTCUSDT",
		//                 "orderId": "1111499608327360513",
		//                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
		//                 "priceAvg": "25000.0000000000000000",
		//                 "size": "0.0002000000000000",
		//                 "orderType": "limit",
		//                 "side": "buy",
		//                 "status": "live",
		//                 "basePrice": "0",
		//                 "baseVolume": "0.0000000000000000",
		//                 "quoteVolume": "0.0000000000000000",
		//                 "enterPointSource": "WEB",
		//                 "orderSource": "normal",
		//                 "cTime": "1700728077966",
		//                 "uTime": "1700728077966"
		//             }
		//         ]
		//     }
		//
		// spot stop
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700729361609,
		//         "data": {
		//             "nextFlag": false,
		//             "idLessThan": "1111503385931620352",
		//             "orderList": [
		//                 {
		//                     "orderId": "1111503385931620352",
		//                     "clientOid": "1111503385910648832",
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.0002",
		//                     "planType": "AMOUNT",
		//                     "executePrice": "25000",
		//                     "triggerPrice": "26000",
		//                     "status": "live",
		//                     "orderType": "limit",
		//                     "side": "buy",
		//                     "triggerType": "fill_price",
		//                     "enterPointSource": "API",
		//                     "cTime": "1700728978617",
		//                     "uTime": "1700728978617"
		//                 }
		//             ]
		//         }
		//     }
		//
		// spot margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700729887686,
		//         "data": {
		//             "orderList": [
		//                 {
		//                     "symbol": "BTCUSDT",
		//                     "orderType": "limit",
		//                     "enterPointSource": "WEB",
		//                     "orderId": "1111506377509580801",
		//                     "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
		//                     "loanType": "autoLoanAndRepay",
		//                     "price": "25000",
		//                     "side": "buy",
		//                     "status": "live",
		//                     "baseSize": "0.0002",
		//                     "quoteSize": "5",
		//                     "priceAvg": "0",
		//                     "size": "0",
		//                     "amount": "0",
		//                     "force": "gtc",
		//                     "cTime": "1700729691866",
		//                     "uTime": "1700729691866"
		//                 }
		//             ],
		//             "maxId": "1111506377509580801",
		//             "minId": "1111506377509580801"
		//         }
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700725609065,
		//         "data": {
		//             "entrustedList": [
		//                 {
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.002",
		//                     "orderId": "1111488897767604224",
		//                     "clientOid": "1111488897805352960",
		//                     "baseVolume": "0",
		//                     "fee": "0",
		//                     "price": "25000",
		//                     "priceAvg": "",
		//                     "status": "live",
		//                     "side": "buy",
		//                     "force": "gtc",
		//                     "totalProfits": "0",
		//                     "posSide": "long",
		//                     "marginCoin": "USDT",
		//                     "quoteVolume": "0",
		//                     "leverage": "20",
		//                     "marginMode": "crossed",
		//                     "enterPointSource": "web",
		//                     "tradeSide": "open",
		//                     "posMode": "hedge_mode",
		//                     "orderType": "limit",
		//                     "orderSource": "normal",
		//                     "presetStopSurplusPrice": "",
		//                     "presetStopLossPrice": "",
		//                     "reduceOnly": "NO",
		//                     "cTime": "1700725524378",
		//                     "uTime": "1700725524378"
		//                 }
		//             ],
		//             "endId": "1111488897767604224"
		//         }
		//     }
		//
		// swap and future stop
		//
		//     {
		//         "code": "00000",\
		//         "msg": "success",
		//         "requestTime": 1700726417495,
		//         "data": {
		//             "entrustedList": [
		//                 {
		//                     "planType": "normal_plan",
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.001",
		//                     "orderId": "1111491399869075457",
		//                     "clientOid": "1111491399869075456",
		//                     "price": "27000",
		//                     "callbackRatio": "",
		//                     "triggerPrice": "24000",
		//                     "triggerType": "mark_price",
		//                     "planStatus": "live",
		//                     "side": "buy",
		//                     "posSide": "long",
		//                     "marginCoin": "USDT",
		//                     "marginMode": "crossed",
		//                     "enterPointSource": "API",
		//                     "tradeSide": "open",
		//                     "posMode": "hedge_mode",
		//                     "orderType": "limit",
		//                     "stopSurplusTriggerPrice": "",
		//                     "stopSurplusExecutePrice": "",
		//                     "stopSurplusTriggerType": "fill_price",
		//                     "stopLossTriggerPrice": "",
		//                     "stopLossExecutePrice": "",
		//                     "stopLossTriggerType": "fill_price",
		//                     "cTime": "1700726120917",
		//                     "uTime": "1700726120917"
		//                 }
		//             ],
		//             "endId": "1111491399869075457"
		//         }
		//     }
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750753395850,
		//         "data": {
		//             "list": [
		//                 {
		//                     "orderId": "1321320757371228160",
		//                     "clientOid": "1321320757371228161",
		//                     "category": "USDT-FUTURES",
		//                     "symbol": "BTCUSDT",
		//                     "orderType": "limit",
		//                     "side": "buy",
		//                     "price": "50000",
		//                     "qty": "0.001",
		//                     "amount": "0",
		//                     "cumExecQty": "0",
		//                     "cumExecValue": "0",
		//                     "avgPrice": "0",
		//                     "timeInForce": "gtc",
		//                     "orderStatus": "live",
		//                     "posSide": "long",
		//                     "holdMode": "hedge_mode",
		//                     "reduceOnly": "NO",
		//                     "feeDetail": [
		//                         {
		//                             "feeCoin": "",
		//                             "fee": ""
		//                         }
		//                     ],
		//                     "createdTime": "1750753338186",
		//                     "updatedTime": "1750753338203",
		//                     "stpMode": "none",
		//                     "tpTriggerBy": null,
		//                     "slTriggerBy": null,
		//                     "takeProfit": null,
		//                     "stopLoss": null,
		//                     "tpOrderType": null,
		//                     "slOrderType": null,
		//                     "tpLimitPrice": null,
		//                     "slLimitPrice": null
		//                 }
		//             ],
		//             "cursor": "1321320757371228160"
		//         }
		//     }
		//
		// uta trigger
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1753057527060,
		//         "data": [
		//             {
		//                 "orderId": "1330984742276198400",
		//                 "clientOid": "1330984742276198400",
		//                 "symbol": "BTCUSDT",
		//                 "category": "USDT-FUTURES",
		//                 "qty": "0.001",
		//                 "posSide": "long",
		//                 "tpTriggerBy": "market",
		//                 "slTriggerBy": "mark",
		//                 "takeProfit": "",
		//                 "stopLoss":"114000",
		//                 "tpOrderType": "market",
		//                 "slOrderType": "limit",
		//                 "tpLimitPrice": "",
		//                 "slLimitPrice": "113000",
		//                 "createdTime": "1753057411736",
		//                 "updatedTime": "1753057411747"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data")
		if IsTrue(uta) {
			var result interface{} = nil
			if IsTrue(trigger) {
				result = this.SafeList(response, "data", []interface{}{})
			} else {
				result = this.SafeList(data, "list", []interface{}{})
			}

			ch <- this.ParseOrders(result, market, since, limit)
			return nil
		} else if IsTrue(IsEqual(typeVar, "spot")) {
			if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(trigger)) {
				var resultList interface{} = this.SafeList(data, "orderList", []interface{}{})

				ch <- this.ParseOrders(resultList, market, since, limit)
				return nil
			}
		} else {
			var result interface{} = this.SafeList(data, "entrustedList", []interface{}{})

			ch <- this.ParseOrders(result, market, since, limit)
			return nil
		}

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes68118 := (<-this.LoadMarkets())
		PanicOnError(retRes68118)

		orders := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(orders)

		ch <- this.FilterBy(orders, "status", "closed")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
 * @param {string} symbol unified market symbol of the canceled orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of canceled orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes68408 := (<-this.LoadMarkets())
		PanicOnError(retRes68408)

		orders := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(orders)

		ch <- this.FilterBy(orders, "status", "canceled")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchCanceledAndClosedOrders
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
 * @see https://www.bitget.com/api-doc/uta/strategy/Get-History-Strategy-Orders
 * @description fetches information on multiple canceled and closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			retRes687419 := (<-this.FetchUtaCanceledAndClosedOrders(symbol, since, limit, params))
			PanicOnError(retRes687419)
			ch <- retRes687419
			return nil
		}

		retRes68768 := (<-this.LoadMarkets())
		PanicOnError(retRes68768)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchCanceledAndClosedOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchCanceledAndClosedOrders", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			var cursorReceived interface{} = nil
			if IsTrue(IsEqual(marketType, "spot")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					cursorReceived = "minId"
				}
			} else {
				cursorReceived = "endId"
			}

			retRes689819 := (<-this.FetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, params, cursorReceived, "idLessThan"))
			PanicOnError(retRes689819)
			ch <- retRes689819
			return nil
		}
		var response interface{} = nil
		var trailing interface{} = this.SafeBool(params, "trailing")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		params = this.Omit(params, []interface{}{"stop", "trigger", "trailing"})
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) || IsTrue((!IsEqual(marginMode, nil)))) {
			var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
			params = this.Omit(params, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "clientOid", clientOrderId)
			}
		}
		var now interface{} = this.Milliseconds()
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(IsEqual(since, nil)) {
					since = Subtract(now, 7776000000)
					AddElementToObject(request, "startTime", since)
				}
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.PrivateMarginGetV2MarginIsolatedHistoryOrders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.PrivateMarginGetV2MarginCrossedHistoryOrders(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(trigger) {
				if IsTrue(IsEqual(symbol, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " fetchCanceledAndClosedOrders() requires a symbol argument")))
				}
				var endTime interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "until"})
				params = this.Omit(params, []interface{}{"until"})
				if IsTrue(IsEqual(since, nil)) {
					since = Subtract(now, 7776000000)
					AddElementToObject(request, "startTime", since)
				}
				if IsTrue(IsEqual(endTime, nil)) {
					AddElementToObject(request, "endTime", now)
				}

				response = (<-this.PrivateSpotGetV2SpotTradeHistoryPlanOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateSpotGetV2SpotTradeHistoryOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)
			var planTypeDefined interface{} = !IsEqual(this.SafeString(params, "planType"), nil)
			if IsTrue(trailing) {
				var planType interface{} = this.SafeString(params, "planType", "track_plan")
				AddElementToObject(request, "planType", planType)

				response = (<-this.PrivateMixGetV2MixOrderOrdersPlanHistory(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsTrue(trigger) || IsTrue(planTypeDefined)) {
				var planType interface{} = this.SafeString(params, "planType", "normal_plan")
				AddElementToObject(request, "planType", planType)

				response = (<-this.PrivateMixGetV2MixOrderOrdersPlanHistory(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateMixGetV2MixOrderOrdersHistory(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700791085380,
		//         "data": [
		//             {
		//                 "userId": "7264631750",
		//                 "symbol": "BTCUSDT",
		//                 "orderId": "1111499608327360513",
		//                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
		//                 "price": "25000.0000000000000000",
		//                 "size": "0.0002000000000000",
		//                 "orderType": "limit",
		//                 "side": "buy",
		//                 "status": "cancelled",
		//                 "priceAvg": "0",
		//                 "baseVolume": "0.0000000000000000",
		//                 "quoteVolume": "0.0000000000000000",
		//                 "enterPointSource": "WEB",
		//                 "feeDetail": "",
		//                 "orderSource": "normal",
		//                 "cTime": "1700728077966",
		//                 "uTime": "1700728911471"
		//             },
		//         ]
		//     }
		//
		// spot stop
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700792099146,
		//         "data": {
		//             "nextFlag": false,
		//             "idLessThan": "1098757597417775104",
		//             "orderList": [
		//                 {
		//                     "orderId": "1111503385931620352",
		//                     "clientOid": "1111503385910648832",
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.0002",
		//                     "planType": "AMOUNT",
		//                     "executePrice": "25000",
		//                     "triggerPrice": "26000",
		//                     "status": "cancelled",
		//                     "orderType": "limit",
		//                     "side": "buy",
		//                     "triggerType": "fill_price",
		//                     "enterPointSource": "API",
		//                     "cTime": "1700728978617",
		//                     "uTime": "1700729666868"
		//                 },
		//             ]
		//         }
		//     }
		//
		// spot margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700792381435,
		//         "data": {
		//             "orderList": [
		//                 {
		//                     "symbol": "BTCUSDT",
		//                     "orderType": "limit",
		//                     "enterPointSource": "WEB",
		//                     "orderId": "1111456274707001345",
		//                     "clientOid": "41e428dd305a4f668671b7f1ed00dc50",
		//                     "loanType": "autoLoanAndRepay",
		//                     "price": "27000",
		//                     "side": "buy",
		//                     "status": "cancelled",
		//                     "baseSize": "0.0002",
		//                     "quoteSize": "5.4",
		//                     "priceAvg": "0",
		//                     "size": "0",
		//                     "amount": "0",
		//                     "force": "gtc",
		//                     "cTime": "1700717746427",
		//                     "uTime": "1700717780636"
		//                 },
		//             ],
		//             "maxId": "1111456274707001345",
		//             "minId": "1098396464990269440"
		//         }
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700792674673,
		//         "data": {
		//             "entrustedList": [
		//                 {
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.002",
		//                     "orderId": "1111498800817143808",
		//                     "clientOid": "1111498800850698240",
		//                     "baseVolume": "0",
		//                     "fee": "0",
		//                     "price": "25000",
		//                     "priceAvg": "",
		//                     "status": "canceled",
		//                     "side": "buy",
		//                     "force": "gtc",
		//                     "totalProfits": "0",
		//                     "posSide": "long",
		//                     "marginCoin": "USDT",
		//                     "quoteVolume": "0",
		//                     "leverage": "20",
		//                     "marginMode": "crossed",
		//                     "enterPointSource": "web",
		//                     "tradeSide": "open",
		//                     "posMode": "hedge_mode",
		//                     "orderType": "limit",
		//                     "orderSource": "normal",
		//                     "presetStopSurplusPrice": "",
		//                     "presetStopLossPrice": "",
		//                     "reduceOnly": "NO",
		//                     "cTime": "1700727885449",
		//                     "uTime": "1700727944563"
		//                 },
		//             ],
		//             "endId": "1098397008323575809"
		//         }
		//     }
		//
		// swap and future stop
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700792938359,
		//         "data": {
		//             "entrustedList": [
		//                 {
		//                     "planType": "normal_plan",
		//                     "symbol": "BTCUSDT",
		//                     "size": "0.001",
		//                     "orderId": "1111491399869075457",
		//                     "clientOid": "1111491399869075456",
		//                     "planStatus": "cancelled",
		//                     "price": "27000",
		//                     "feeDetail": null,
		//                     "baseVolume": "0",
		//                     "callbackRatio": "",
		//                     "triggerPrice": "24000",
		//                     "triggerType": "mark_price",
		//                     "side": "buy",
		//                     "posSide": "long",
		//                     "marginCoin": "USDT",
		//                     "marginMode": "crossed",
		//                     "enterPointSource": "API",
		//                     "tradeSide": "open",
		//                     "posMode": "hedge_mode",
		//                     "orderType": "limit",
		//                     "stopSurplusTriggerPrice": "",
		//                     "stopSurplusExecutePrice": "",
		//                     "stopSurplusTriggerType": "fill_price",
		//                     "stopLossTriggerPrice": "",
		//                     "stopLossExecutePrice": "",
		//                     "stopLossTriggerType": "fill_price",
		//                     "cTime": "1700726120917",
		//                     "uTime": "1700727879652"
		//                 },
		//             ],
		//             "endId": "1098760007867502593"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(trigger)) {

				ch <- this.ParseOrders(this.SafeValue(data, "orderList", []interface{}{}), market, since, limit)
				return nil
			}
		} else {

			ch <- this.ParseOrders(this.SafeValue(data, "entrustedList", []interface{}{}), market, since, limit)
			return nil
		}
		if IsTrue(IsString(response)) {
			response = JsonParse(response)
		}
		var orders interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) FetchUtaCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes71588 := (<-this.LoadMarkets())
		PanicOnError(retRes71588)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		if IsTrue(IsEqual(productType, "SPOT")) {
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("fetchCanceledAndClosedOrders", params)
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			if IsTrue(!IsEqual(marginMode, nil)) {
				productType = "MARGIN"
			}
		}
		var request interface{} = map[string]interface{}{
			"category": productType,
		}
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes717819 := (<-this.FetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, params, "cursor", "cursor"))
			PanicOnError(retRes717819)
			ch <- retRes717819
			return nil
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		params = this.Omit(params, []interface{}{"stop", "trigger"})
		if IsTrue(trigger) {

			response = (<-this.PrivateUtaGetV3TradeHistoryStrategyOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateUtaGetV3TradeHistoryOrders(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// uta
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1752531592855,
		//         "data": {
		//             "list": [
		//                 {
		//                     "orderId": "1322441400976261120",
		//                     "clientOid": "1322441400976261121",
		//                     "category": "USDT-FUTURES",
		//                     "symbol": "BTCUSDT",
		//                     "orderType": "market",
		//                     "side": "sell",
		//                     "price": "0",
		//                     "qty": "0.0001",
		//                     "amount": "0",
		//                     "cumExecQty": "0.0001",
		//                     "cumExecValue": "10.7005",
		//                     "avgPrice": "107005.4",
		//                     "timeInForce": "gtc",
		//                     "orderStatus": "filled",
		//                     "posSide": "long",
		//                     "holdMode": "hedge_mode",
		//                     "reduceOnly": "NO",
		//                     "feeDetail": [
		//                         {
		//                             "feeCoin": "USDT",
		//                             "fee": "0.00642032"
		//                         }
		//                     ],
		//                     "createdTime": "1751020520442",
		//                     "updatedTime": "1751020520457",
		//                     "cancelReason": "",
		//                     "execType": "normal",
		//                     "stpMode": "none",
		//                     "tpTriggerBy": null,
		//                     "slTriggerBy": null,
		//                     "takeProfit": null,
		//                     "stopLoss": null,
		//                     "tpOrderType": null,
		//                     "slOrderType": null,
		//                     "tpLimitPrice": null,
		//                     "slLimitPrice": null
		//                 },
		//             ],
		//             "cursor": "1322441328637100035"
		//         }
		//     }
		//
		// uta trigger
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1753058447920,
		//         "data": {
		//             "list": [
		//                 {
		//                     "orderId": "1330984742276198400",
		//                     "clientOid": "1330984742276198400",
		//                     "symbol": "BTCUSDT",
		//                     "category": "USDT-FUTURES",
		//                     "qty": "0.001",
		//                     "posSide": "long",
		//                     "tpTriggerBy": "market",
		//                     "slTriggerBy": "mark",
		//                     "takeProfit": "",
		//                     "stopLoss": "112000",
		//                     "tpOrderType": "market",
		//                     "slOrderType": "limit",
		//                     "tpLimitPrice": "",
		//                     "slLimitPrice": "111000",
		//                     "createdTime": "1753057411736",
		//                     "updatedTime": "1753058267412"
		//                 },
		//             ],
		//             "cursor": 1330960754317619202
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList(data, "list", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Bills
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.symbol] *contract only* unified market symbol
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func (this *bitget) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes73008 := (<-this.LoadMarkets())
		PanicOnError(retRes73008)
		var symbol interface{} = this.SafeString(params, "symbol")
		params = this.Omit(params, "symbol")
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchLedger", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			var cursorReceived interface{} = nil
			if IsTrue(!IsEqual(marketType, "spot")) {
				cursorReceived = "endId"
			}

			retRes731619 := (<-this.FetchPaginatedCallCursor("fetchLedger", symbol, since, limit, params, cursorReceived, "idLessThan"))
			PanicOnError(retRes731619)
			ch <- retRes731619
			return nil
		}
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateSpotGetV2SpotAccountBills(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(symbol, nil)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			var productType interface{} = nil
			productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
			productType = GetValue(productTypeparamsVariable, 0)
			params = GetValue(productTypeparamsVariable, 1)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixAccountBill(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700795836415,
		//         "data": [
		//             {
		//                 "billId": "1111506298997215233",
		//                 "coin": "USDT",
		//                 "groupType": "transfer",
		//                 "businessType": "transfer_out",
		//                 "size": "-11.64958799",
		//                 "balance": "0.00000000",
		//                 "fees": "0.00000000",
		//                 "cTime": "1700729673028"
		//             },
		//         ]
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700795977890,
		//         "data": {
		//             "bills": [
		//                 {
		//                     "billId": "1111499428100472833",
		//                     "symbol": "",
		//                     "amount": "-11.64958799",
		//                     "fee": "0",
		//                     "feeByCoupon": "",
		//                     "businessType": "trans_to_exchange",
		//                     "coin": "USDT",
		//                     "cTime": "1700728034996"
		//                 },
		//             ],
		//             "endId": "1098396773329305606"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data")
		if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
			var bills interface{} = this.SafeValue(data, "bills", []interface{}{})

			ch <- this.ParseLedger(bills, currency, since, limit)
			return nil
		}

		ch <- this.ParseLedger(data, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	//
	//     {
	//         "billId": "1111506298997215233",
	//         "coin": "USDT",
	//         "groupType": "transfer",
	//         "businessType": "transfer_out",
	//         "size": "-11.64958799",
	//         "balance": "0.00000000",
	//         "fees": "0.00000000",
	//         "cTime": "1700729673028"
	//     }
	//
	// swap and future
	//
	//     {
	//         "billId": "1111499428100472833",
	//         "symbol": "",
	//         "amount": "-11.64958799",
	//         "fee": "0",
	//         "feeByCoupon": "",
	//         "businessType": "trans_to_exchange",
	//         "coin": "USDT",
	//         "cTime": "1700728034996"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(item, "coin")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var timestamp interface{} = this.SafeInteger(item, "cTime")
	var after interface{} = this.SafeNumber(item, "balance")
	var fee interface{} = this.SafeNumber2(item, "fees", "fee")
	var amountRaw interface{} = this.SafeString2(item, "size", "amount")
	var amount interface{} = this.ParseNumber(Precise.StringAbs(amountRaw))
	var direction interface{} = "in"
	if IsTrue(IsGreaterThanOrEqual(GetIndexOf(amountRaw, "-"), 0)) {
		direction = "out"
	}
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "billId"),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"direction":        direction,
		"account":          nil,
		"referenceId":      nil,
		"referenceAccount": nil,
		"type":             this.ParseLedgerType(this.SafeString(item, "businessType")),
		"currency":         code,
		"amount":           amount,
		"before":           nil,
		"after":            after,
		"status":           nil,
		"fee": map[string]interface{}{
			"currency": code,
			"cost":     fee,
		},
	}, currency)
}
func (this *bitget) ParseLedgerType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"trans_to_cross":                  "transfer",
		"trans_from_cross":                "transfer",
		"trans_to_exchange":               "transfer",
		"trans_from_exchange":             "transfer",
		"trans_to_isolated":               "transfer",
		"trans_from_isolated":             "transfer",
		"trans_to_contract":               "transfer",
		"trans_from_contract":             "transfer",
		"trans_to_otc":                    "transfer",
		"trans_from_otc":                  "transfer",
		"open_long":                       "trade",
		"close_long":                      "trade",
		"open_short":                      "trade",
		"close_short":                     "trade",
		"force_close_long":                "trade",
		"force_close_short":               "trade",
		"burst_long_loss_query":           "trade",
		"burst_short_loss_query":          "trade",
		"force_buy":                       "trade",
		"force_sell":                      "trade",
		"burst_buy":                       "trade",
		"burst_sell":                      "trade",
		"delivery_long":                   "settlement",
		"delivery_short":                  "settlement",
		"contract_settle_fee":             "fee",
		"append_margin":                   "transaction",
		"adjust_down_lever_append_margin": "transaction",
		"reduce_margin":                   "transaction",
		"auto_append_margin":              "transaction",
		"cash_gift_issue":                 "cashback",
		"cash_gift_recycle":               "cashback",
		"bonus_issue":                     "rebate",
		"bonus_recycle":                   "rebate",
		"bonus_expired":                   "rebate",
		"transfer_in":                     "transfer",
		"transfer_out":                    "transfer",
		"deposit":                         "deposit",
		"withdraw":                        "withdrawal",
		"buy":                             "trade",
		"sell":                            "trade",
	}
	return this.SafeString(types, typeVar, typeVar)
}

/**
 * @method
 * @name bitget#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Fills
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Fills
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-Fills
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Transaction-Details
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-Fills
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *bitget) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(!IsTrue(uta) && IsTrue((IsEqual(symbol, nil)))) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes75278 := (<-this.LoadMarkets())
		PanicOnError(retRes75278)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var paginate interface{} = false
		var marginMode interface{} = nil
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(paginate) {
			var cursorReceived interface{} = nil
			var cursorSent interface{} = nil
			if IsTrue(uta) {
				cursorReceived = "cursor"
				cursorSent = "cursor"
			} else if IsTrue(GetValue(market, "spot")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					cursorReceived = "minId"
					cursorSent = "idLessThan"
				}
			} else {
				cursorReceived = "endId"
				cursorSent = "idLessThan"
			}

			retRes755619 := (<-this.FetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, params, cursorReceived, cursorSent))
			PanicOnError(retRes755619)
			ch <- retRes755619
			return nil
		}
		var response interface{} = nil
		if IsTrue(uta) {

			response = (<-this.PrivateUtaGetV3TradeFills(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			if IsTrue(GetValue(market, "spot")) {
				if IsTrue(!IsEqual(marginMode, nil)) {
					if IsTrue(IsEqual(since, nil)) {
						AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
					}
					if IsTrue(IsEqual(marginMode, "isolated")) {

						response = (<-this.PrivateMarginGetV2MarginIsolatedFills(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(IsEqual(marginMode, "cross")) {

						response = (<-this.PrivateMarginGetV2MarginCrossedFills(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else {

					response = (<-this.PrivateSpotGetV2SpotTradeFills(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {
				var productType interface{} = nil
				productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
				productType = GetValue(productTypeparamsVariable, 0)
				params = GetValue(productTypeparamsVariable, 1)
				AddElementToObject(request, "productType", productType)

				response = (<-this.PrivateMixGetV2MixOrderFills(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700802995406,
		//         "data": [
		//             {
		//                 "userId": "7264631751",
		//                 "symbol": "BTCUSDT",
		//                 "orderId": "1098394344925597696",
		//                 "tradeId": "1098394344974925824",
		//                 "orderType": "market",
		//                 "side": "sell",
		//                 "priceAvg": "28467.68",
		//                 "size": "0.0002",
		//                 "amount": "5.693536",
		//                 "feeDetail": {
		//                     "deduction": "no",
		//                     "feeCoin": "USDT",
		//                     "totalDeductionFee": "",
		//                     "totalFee": "-0.005693536"
		//                 },
		//                 "tradeScope": "taker",
		//                 "cTime": "1697603539699",
		//                 "uTime": "1697603539754"
		//             }
		//         ]
		//     }
		//
		// spot margin
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700803176399,
		//         "data": {
		//             "fills": [
		//                 {
		//                     "orderId": "1099353730455318528",
		//                     "tradeId": "1099353730627092481",
		//                     "orderType": "market",
		//                     "side": "sell",
		//                     "priceAvg": "29543.7",
		//                     "size": "0.0001",
		//                     "amount": "2.95437",
		//                     "tradeScope": "taker",
		//                     "feeDetail": {
		//                         "deduction": "no",
		//                         "feeCoin": "USDT",
		//                         "totalDeductionFee": "0",
		//                         "totalFee": "-0.00295437"
		//                     },
		//                     "cTime": "1697832275063",
		//                     "uTime": "1697832275150"
		//                 },
		//             ],
		//             "minId": "1099353591699161118",
		//             "maxId": "1099353730627092481"
		//         }
		//     }
		//
		// swap and future
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700803357487,
		//         "data": {
		//             "fillList": [
		//                 {
		//                     "tradeId": "1111468664328269825",
		//                     "symbol": "BTCUSDT",
		//                     "orderId": "1111468664264753162",
		//                     "price": "37271.4",
		//                     "baseVolume": "0.001",
		//                     "feeDetail": [
		//                         {
		//                             "deduction": "no",
		//                             "feeCoin": "USDT",
		//                             "totalDeductionFee": null,
		//                             "totalFee": "-0.02236284"
		//                         }
		//                     ],
		//                     "side": "buy",
		//                     "quoteVolume": "37.2714",
		//                     "profit": "-0.0007",
		//                     "enterPointSource": "web",
		//                     "tradeSide": "close",
		//                     "posMode": "hedge_mode",
		//                     "tradeScope": "taker",
		//                     "cTime": "1700720700342"
		//                 },
		//             ],
		//             "endId": "1099351587643699201"
		//         }
		//     }
		//
		// uta
		//
		//      {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1751099666579,
		//         "data": {
		//             "list": [
		//                 {
		//                     "execId": "1322441401010528257",
		//                     "orderId": "1322441400976261120",
		//                     "category": "USDT-FUTURES",
		//                     "symbol": "BTCUSDT",
		//                     "orderType": "market",
		//                     "side": "sell",
		//                     "execPrice": "107005.4",
		//                     "execQty": "0.0001",
		//                     "execValue": "10.7005",
		//                     "tradeScope": "taker",
		//                     "feeDetail": [{
		//                         "feeCoin": "USDT",
		//                         "fee":"0.00642032"
		//                     }],
		//                     "createdTime": "1751020520451",
		//                     "updatedTime": "1751020520458",
		//                     "execPnl": "0.00017"
		//                 },
		//             ],
		//             "cursor": "1322061241878880257"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data")
		if IsTrue(uta) {
			var fills interface{} = this.SafeList(data, "list", []interface{}{})

			ch <- this.ParseTrades(fills, market, since, limit)
			return nil
		} else if IsTrue((IsTrue(GetValue(market, "swap")) || IsTrue((GetValue(market, "future"))))) {
			var fills interface{} = this.SafeList(data, "fillList", []interface{}{})

			ch <- this.ParseTrades(fills, market, since, limit)
			return nil
		} else if IsTrue(!IsEqual(marginMode, nil)) {
			var fills interface{} = this.SafeList(data, "fills", []interface{}{})

			ch <- this.ParseTrades(fills, market, since, limit)
			return nil
		}

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://www.bitget.com/api-doc/contract/position/get-single-position
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bitget) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes77408 := (<-this.LoadMarkets())
		PanicOnError(retRes77408)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		var uta interface{} = nil
		var result interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchPosition", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaGetV3PositionCurrentPosition(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1750929905423,
			//         "data": {
			//             "list": [
			//                 {
			//                     "category": "USDT-FUTURES",
			//                     "symbol": "BTCUSDT",
			//                     "marginCoin": "USDT",
			//                     "holdMode": "hedge_mode",
			//                     "posSide": "long",
			//                     "marginMode": "crossed",
			//                     "positionBalance": "5.435199",
			//                     "available": "0.001",
			//                     "frozen": "0",
			//                     "total": "0.001",
			//                     "leverage": "20",
			//                     "curRealisedPnl": "0",
			//                     "avgPrice": "107410.3",
			//                     "positionStatus": "normal",
			//                     "unrealisedPnl": "0.0047",
			//                     "liquidationPrice": "0",
			//                     "mmr": "0.004",
			//                     "profitRate": "0.0008647337475591",
			//                     "markPrice": "107415.3",
			//                     "breakEvenPrice": "107539.2",
			//                     "totalFunding": "0",
			//                     "openFeeTotal": "-0.06444618",
			//                     "closeFeeTotal": "0",
			//                     "createdTime": "1750495670699",
			//                     "updatedTime": "1750929883465"
			//                 }
			//             ]
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			result = this.SafeList(data, "list", []interface{}{})
		} else {
			AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixPositionSinglePosition(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1700807531673,
			//         "data": [
			//             {
			//                 "marginCoin": "USDT",
			//                 "symbol": "BTCUSDT",
			//                 "holdSide": "long",
			//                 "openDelegateSize": "0",
			//                 "marginSize": "3.73555",
			//                 "available": "0.002",
			//                 "locked": "0",
			//                 "total": "0.002",
			//                 "leverage": "20",
			//                 "achievedProfits": "0",
			//                 "openPriceAvg": "37355.5",
			//                 "marginMode": "crossed",
			//                 "posMode": "hedge_mode",
			//                 "unrealizedPL": "0.007",
			//                 "liquidationPrice": "31724.970702417",
			//                 "keepMarginRate": "0.004",
			//                 "markPrice": "37359",
			//                 "marginRatio": "0.029599540355",
			//                 "cTime": "1700807507275"
			//             }
			//         ]
			//     }
			//
			result = this.SafeList(response, "data", []interface{}{})
		}
		var first interface{} = this.SafeDict(result, 0, map[string]interface{}{})

		ch <- this.ParsePosition(first, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchPositions
 * @description fetch all open positions
 * @see https://www.bitget.com/api-doc/contract/position/get-all-position
 * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Position
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
 * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {boolean} [params.useHistoryEndpoint] default false, when true  will use the historic endpoint to fetch positions
 * @param {string} [params.method] either (default) 'privateMixGetV2MixPositionAllPosition', 'privateMixGetV2MixPositionHistoryPosition', or 'privateUtaGetV3PositionCurrentPosition'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bitget) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes78528 := (<-this.LoadMarkets())
		PanicOnError(retRes78528)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes785619 := (<-this.FetchPaginatedCallCursor("fetchPositions", nil, nil, nil, params, "endId", "idLessThan"))
			PanicOnError(retRes785619)
			ch <- retRes785619
			return nil
		}
		var method interface{} = nil
		var useHistoryEndpoint interface{} = this.SafeBool(params, "useHistoryEndpoint", false)
		if IsTrue(useHistoryEndpoint) {
			method = "privateMixGetV2MixPositionHistoryPosition"
		} else {
			methodparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "method", "privateMixGetV2MixPositionAllPosition")
			method = GetValue(methodparamsVariable, 0)
			params = GetValue(methodparamsVariable, 1)
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var first interface{} = this.SafeString(symbols, 0)
			market = this.Market(first)
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		var isHistory interface{} = false
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaGetV3PositionCurrentPosition(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "privateMixGetV2MixPositionAllPosition")) {
			var marginCoin interface{} = this.SafeString(params, "marginCoin", "USDT")
			if IsTrue(!IsEqual(symbols, nil)) {
				marginCoin = GetValue(market, "settleId")
			} else if IsTrue(IsEqual(productType, "USDT-FUTURES")) {
				marginCoin = "USDT"
			} else if IsTrue(IsEqual(productType, "USDC-FUTURES")) {
				marginCoin = "USDC"
			} else if IsTrue(IsEqual(productType, "SUSDT-FUTURES")) {
				marginCoin = "SUSDT"
			} else if IsTrue(IsEqual(productType, "SUSDC-FUTURES")) {
				marginCoin = "SUSDC"
			} else if IsTrue(IsTrue((IsEqual(productType, "SCOIN-FUTURES"))) || IsTrue((IsEqual(productType, "COIN-FUTURES")))) {
				if IsTrue(IsEqual(marginCoin, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " fetchPositions() requires a marginCoin parameter that matches the productType")))
				}
			}
			AddElementToObject(request, "marginCoin", marginCoin)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixPositionAllPosition(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			isHistory = true
			if IsTrue(!IsEqual(market, nil)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixGetV2MixPositionHistoryPosition(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// privateMixGetV2MixPositionAllPosition
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700807810221,
		//         "data": [
		//             {
		//                 "marginCoin": "USDT",
		//                 "symbol": "BTCUSDT",
		//                 "holdSide": "long",
		//                 "openDelegateSize": "0",
		//                 "marginSize": "3.73555",
		//                 "available": "0.002",
		//                 "locked": "0",
		//                 "total": "0.002",
		//                 "leverage": "20",
		//                 "achievedProfits": "0",
		//                 "openPriceAvg": "37355.5",
		//                 "marginMode": "crossed",
		//                 "posMode": "hedge_mode",
		//                 "unrealizedPL": "0.03",
		//                 "liquidationPrice": "31725.023602417",
		//                 "keepMarginRate": "0.004",
		//                 "markPrice": "37370.5",
		//                 "marginRatio": "0.029550120396",
		//                 "cTime": "1700807507275"
		//             }
		//         ]
		//     }
		//
		// privateMixGetV2MixPositionHistoryPosition
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700808051002,
		//         "data": {
		//             "list": [
		//                 {
		//                     "symbol": "BTCUSDT",
		//                     "marginCoin": "USDT",
		//                     "holdSide": "long",
		//                     "openAvgPrice": "37272.1",
		//                     "closeAvgPrice": "37271.4",
		//                     "marginMode": "crossed",
		//                     "openTotalPos": "0.001",
		//                     "closeTotalPos": "0.001",
		//                     "pnl": "-0.0007",
		//                     "netProfit": "-0.0454261",
		//                     "totalFunding": "0",
		//                     "openFee": "-0.02236326",
		//                     "closeFee": "-0.02236284",
		//                     "utime": "1700720700400",
		//                     "ctime": "1700720651684"
		//                 },
		//             ],
		//             "endId": "1099351653866962944"
		//         }
		//     }
		//
		// privateUtaGetV3PositionCurrentPosition
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1750929905423,
		//         "data": {
		//             "list": [
		//                 {
		//                     "category": "USDT-FUTURES",
		//                     "symbol": "BTCUSDT",
		//                     "marginCoin": "USDT",
		//                     "holdMode": "hedge_mode",
		//                     "posSide": "long",
		//                     "marginMode": "crossed",
		//                     "positionBalance": "5.435199",
		//                     "available": "0.001",
		//                     "frozen": "0",
		//                     "total": "0.001",
		//                     "leverage": "20",
		//                     "curRealisedPnl": "0",
		//                     "avgPrice": "107410.3",
		//                     "positionStatus": "normal",
		//                     "unrealisedPnl": "0.0047",
		//                     "liquidationPrice": "0",
		//                     "mmr": "0.004",
		//                     "profitRate": "0.0008647337475591",
		//                     "markPrice": "107415.3",
		//                     "breakEvenPrice": "107539.2",
		//                     "totalFunding": "0",
		//                     "openFeeTotal": "-0.06444618",
		//                     "closeFeeTotal": "0",
		//                     "createdTime": "1750495670699",
		//                     "updatedTime": "1750929883465"
		//                 }
		//             ]
		//         }
		//     }
		//
		var position interface{} = []interface{}{}
		if IsTrue(IsTrue(uta) || IsTrue(isHistory)) {
			var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			position = this.SafeList(data, "list", []interface{}{})
		} else {
			position = this.SafeList(response, "data", []interface{}{})
		}
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(position)); i++ {
			AppendToArray(&result, this.ParsePosition(GetValue(position, i), market))
		}
		symbols = this.MarketSymbols(symbols)

		ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
		return nil

	}()
	return ch
}
func (this *bitget) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchPosition
	//
	//     {
	//         "marginCoin": "USDT",
	//         "symbol": "BTCUSDT",
	//         "holdSide": "long",
	//         "openDelegateSize": "0",
	//         "marginSize": "3.73555",
	//         "available": "0.002",
	//         "locked": "0",
	//         "total": "0.002",
	//         "leverage": "20",
	//         "achievedProfits": "0",
	//         "openPriceAvg": "37355.5",
	//         "marginMode": "crossed",
	//         "posMode": "hedge_mode",
	//         "unrealizedPL": "0.007",
	//         "liquidationPrice": "31724.970702417",
	//         "keepMarginRate": "0.004",
	//         "markPrice": "37359",
	//         "marginRatio": "0.029599540355",
	//         "cTime": "1700807507275"
	//     }
	//
	// uta: fetchPosition
	//
	//     {
	//         "category": "USDT-FUTURES",
	//         "symbol": "BTCUSDT",
	//         "marginCoin": "USDT",
	//         "holdMode": "hedge_mode",
	//         "posSide": "long",
	//         "marginMode": "crossed",
	//         "positionBalance": "5.435199",
	//         "available": "0.001",
	//         "frozen": "0",
	//         "total": "0.001",
	//         "leverage": "20",
	//         "curRealisedPnl": "0",
	//         "avgPrice": "107410.3",
	//         "positionStatus": "normal",
	//         "unrealisedPnl": "0.0047",
	//         "liquidationPrice": "0",
	//         "mmr": "0.004",
	//         "profitRate": "0.0008647337475591",
	//         "markPrice": "107415.3",
	//         "breakEvenPrice": "107539.2",
	//         "totalFunding": "0",
	//         "openFeeTotal": "-0.06444618",
	//         "closeFeeTotal": "0",
	//         "createdTime": "1750495670699",
	//         "updatedTime": "1750929883465"
	//     }
	//
	// fetchPositions: privateMixGetV2MixPositionAllPosition
	//
	//     {
	//         "marginCoin": "USDT",
	//         "symbol": "BTCUSDT",
	//         "holdSide": "long",
	//         "openDelegateSize": "0",
	//         "marginSize": "3.73555",
	//         "available": "0.002",
	//         "locked": "0",
	//         "total": "0.002",
	//         "leverage": "20",
	//         "achievedProfits": "0",
	//         "openPriceAvg": "37355.5",
	//         "marginMode": "crossed",
	//         "posMode": "hedge_mode",
	//         "unrealizedPL": "0.03",
	//         "liquidationPrice": "31725.023602417",
	//         "keepMarginRate": "0.004",
	//         "markPrice": "37370.5",
	//         "marginRatio": "0.029550120396",
	//         "cTime": "1700807507275"
	//     }
	//
	// fetchPositionsHistory: privateMixGetV2MixPositionHistoryPosition
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "marginCoin": "USDT",
	//         "holdSide": "long",
	//         "openAvgPrice": "37272.1",
	//         "closeAvgPrice": "37271.4",
	//         "marginMode": "crossed",
	//         "openTotalPos": "0.001",
	//         "closeTotalPos": "0.001",
	//         "pnl": "-0.0007",
	//         "netProfit": "-0.0454261",
	//         "totalFunding": "0",
	//         "openFee": "-0.02236326",
	//         "closeFee": "-0.02236284",
	//         "utime": "1700720700400",
	//         "ctime": "1700720651684"
	//     }
	//
	// closeAllPositions
	//
	//     {
	//         "orderId": "1120923953904893955",
	//         "clientOid": "1120923953904893956"
	//     }
	//
	// uta: fetchPositionsHistory
	//
	//     {
	//         "positionId": "1322441328637100049",
	//         "category": "USDT-FUTURES",
	//         "symbol": "BTCUSDT",
	//         "marginCoin": "USDT",
	//         "holdMode": "hedge_mode",
	//         "posSide": "long",
	//         "marginMode": "crossed",
	//         "openPriceAvg": "107003.7",
	//         "closePriceAvg": "107005.4",
	//         "openTotalPos": "0.0001",
	//         "closeTotalPos": "0.0001",
	//         "cumRealisedPnl": "0.00017",
	//         "netProfit": "-0.01267055",
	//         "totalFunding": "0",
	//         "openFeeTotal": "-0.00642022",
	//         "closeFeeTotal": "-0.00642032",
	//         "createdTime": "1751020503195",
	//         "updatedTime": "1751020520458"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "symbol")
	market = this.SafeMarket(marketId, market, nil, "contract")
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeIntegerN(position, []interface{}{"cTime", "ctime", "createdTime"})
	var marginMode interface{} = this.SafeString(position, "marginMode")
	var collateral interface{} = nil
	var initialMargin interface{} = nil
	var unrealizedPnl interface{} = this.SafeString2(position, "unrealizedPL", "unrealisedPnl")
	var rawCollateral interface{} = this.SafeString2(position, "marginSize", "positionBalance")
	if IsTrue(IsEqual(marginMode, "isolated")) {
		collateral = Precise.StringAdd(rawCollateral, unrealizedPnl)
	} else if IsTrue(IsEqual(marginMode, "crossed")) {
		marginMode = "cross"
		initialMargin = rawCollateral
	}
	var holdMode interface{} = this.SafeString2(position, "posMode", "holdMode")
	var hedged interface{} = nil
	if IsTrue(IsEqual(holdMode, "hedge_mode")) {
		hedged = true
	} else if IsTrue(IsEqual(holdMode, "one_way_mode")) {
		hedged = false
	}
	var side interface{} = this.SafeString2(position, "holdSide", "posSide")
	var leverage interface{} = this.SafeString(position, "leverage")
	var contractSizeNumber interface{} = this.SafeValue(market, "contractSize")
	var contractSize interface{} = this.NumberToString(contractSizeNumber)
	var baseAmount interface{} = this.SafeString2(position, "total", "openTotalPos")
	var entryPrice interface{} = this.SafeStringN(position, []interface{}{"openPriceAvg", "openAvgPrice", "avgPrice"})
	var maintenanceMarginPercentage interface{} = this.SafeString(position, "keepMarginRate")
	var openNotional interface{} = Precise.StringMul(entryPrice, baseAmount)
	if IsTrue(IsEqual(initialMargin, nil)) {
		initialMargin = Precise.StringDiv(openNotional, leverage)
	}
	var contracts interface{} = this.ParseNumber(Precise.StringDiv(baseAmount, contractSize))
	if IsTrue(IsEqual(contracts, nil)) {
		contracts = this.SafeNumber(position, "closeTotalPos")
	}
	var markPrice interface{} = this.SafeString(position, "markPrice")
	var notional interface{} = Precise.StringMul(baseAmount, markPrice)
	var initialMarginPercentage interface{} = Precise.StringDiv(initialMargin, notional)
	var liquidationPrice interface{} = this.ParseNumber(this.OmitZero(this.SafeString(position, "liquidationPrice")))
	var calcTakerFeeRate interface{} = "0.0006"
	var calcTakerFeeMult interface{} = "0.9994"
	if IsTrue(IsTrue(IsTrue((IsEqual(liquidationPrice, nil))) && IsTrue((IsEqual(marginMode, "isolated")))) && IsTrue(Precise.StringGt(baseAmount, "0"))) {
		var signedMargin interface{} = Precise.StringDiv(rawCollateral, baseAmount)
		var signedMmp interface{} = maintenanceMarginPercentage
		if IsTrue(IsEqual(side, "short")) {
			signedMargin = Precise.StringNeg(signedMargin)
			signedMmp = Precise.StringNeg(signedMmp)
		}
		var mmrMinusOne interface{} = Precise.StringSub("1", signedMmp)
		var numerator interface{} = Precise.StringSub(entryPrice, signedMargin)
		if IsTrue(IsEqual(side, "long")) {
			mmrMinusOne = Precise.StringMul(mmrMinusOne, calcTakerFeeMult)
		} else {
			numerator = Precise.StringMul(numerator, calcTakerFeeMult)
		}
		liquidationPrice = this.ParseNumber(Precise.StringDiv(numerator, mmrMinusOne))
	}
	var feeToClose interface{} = Precise.StringMul(notional, calcTakerFeeRate)
	var maintenanceMargin interface{} = Precise.StringAdd(Precise.StringMul(maintenanceMarginPercentage, notional), feeToClose)
	var percentage interface{} = Precise.StringMul(Precise.StringDiv(unrealizedPnl, initialMargin, 4), "100")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          this.SafeString2(position, "orderId", "positionId"),
		"symbol":                      symbol,
		"notional":                    this.ParseNumber(notional),
		"marginMode":                  marginMode,
		"liquidationPrice":            liquidationPrice,
		"entryPrice":                  this.ParseNumber(entryPrice),
		"unrealizedPnl":               this.ParseNumber(unrealizedPnl),
		"realizedPnl":                 this.SafeNumberN(position, []interface{}{"pnl", "curRealisedPnl", "cumRealisedPnl"}),
		"percentage":                  this.ParseNumber(percentage),
		"contracts":                   contracts,
		"contractSize":                contractSizeNumber,
		"markPrice":                   this.ParseNumber(markPrice),
		"lastPrice":                   this.SafeNumber2(position, "closeAvgPrice", "closePriceAvg"),
		"side":                        side,
		"hedged":                      hedged,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"lastUpdateTimestamp":         this.SafeInteger2(position, "utime", "updatedTime"),
		"maintenanceMargin":           this.ParseNumber(maintenanceMargin),
		"maintenanceMarginPercentage": this.ParseNumber(maintenanceMarginPercentage),
		"collateral":                  this.ParseNumber(collateral),
		"initialMargin":               this.ParseNumber(initialMargin),
		"initialMarginPercentage":     this.ParseNumber(initialMarginPercentage),
		"leverage":                    this.ParseNumber(leverage),
		"marginRatio":                 this.SafeNumber2(position, "marginRatio", "mmr"),
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name bitget#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Funding-Rate
 * @see https://www.bitget.com/api-doc/uta/public/Get-History-Funding-Rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of funding rate structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *bitget) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes82668 := (<-this.LoadMarkets())
		PanicOnError(retRes82668)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var productType interface{} = nil
		var uta interface{} = nil
		var response interface{} = nil
		var result interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketHistoryFundRate(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1750435113658,
			//         "data": {
			//             "resultList": [
			//                 {
			//                     "symbol": "BTCUSDT",
			//                     "fundingRate": "-0.000017",
			//                     "fundingRateTimestamp": "1750431600000"
			//                 },
			//             ]
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			result = this.SafeList(data, "resultList", []interface{}{})
		} else {
			var paginate interface{} = false
			paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
			paginate = GetValue(paginateparamsVariable, 0)
			params = GetValue(paginateparamsVariable, 1)
			if IsTrue(paginate) {

				retRes830523 := (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, "pageNo", 100))
				PanicOnError(retRes830523)
				ch <- retRes830523
				return nil
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "pageSize", limit)
			}
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketHistoryFundRate(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1652406728393,
			//         "data": [
			//             {
			//                 "symbol": "BTCUSDT",
			//                 "fundingRate": "-0.0003",
			//                 "fundingTime": "1652396400000"
			//             },
			//         ]
			//     }
			//
			result = this.SafeList(response, "data", []interface{}{})
		}
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
			var entry interface{} = GetValue(result, i)
			var marketId interface{} = this.SafeString(entry, "symbol")
			var symbolInner interface{} = this.SafeSymbol(marketId, market)
			var timestamp interface{} = this.SafeInteger2(entry, "fundingTime", "fundingRateTimestamp")
			AppendToArray(&rates, map[string]interface{}{
				"info":        entry,
				"symbol":      symbolInner,
				"fundingRate": this.SafeNumber(entry, "fundingRate"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.bitget.com/api-doc/contract/market/Get-Current-Funding-Rate
 * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Next-Funding-Time
 * @see https://www.bitget.com/api-doc/uta/public/Get-Current-Funding-Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {string} [params.method] either (default) 'publicMixGetV2MixMarketCurrentFundRate' or 'publicMixGetV2MixMarketFundingTime'
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *bitget) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes83608 := (<-this.LoadMarkets())
		PanicOnError(retRes83608)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var uta interface{} = nil
		var response interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRate", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			response = (<-this.PublicUtaGetV3MarketCurrentFundRate(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)
			var method interface{} = nil
			methodparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRate", "method", "publicMixGetV2MixMarketCurrentFundRate")
			method = GetValue(methodparamsVariable, 0)
			params = GetValue(methodparamsVariable, 1)
			if IsTrue(IsEqual(method, "publicMixGetV2MixMarketCurrentFundRate")) {

				response = (<-this.PublicMixGetV2MixMarketCurrentFundRate(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(method, "publicMixGetV2MixMarketFundingTime")) {

				response = (<-this.PublicMixGetV2MixMarketFundingTime(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRate(GetValue(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchFundingRates
 * @description fetch the current funding rates for all markets
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] *contract only* 'linear', 'inverse'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a dictionary of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func (this *bitget) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes84498 := (<-this.LoadMarkets())
		PanicOnError(retRes84498)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbol interface{} = this.SafeValue(symbols, 0)
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		AddElementToObject(request, "productType", productType)

		response := (<-this.PublicMixGetV2MixMarketTickers(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "code": "00000",
		//     "msg": "success",
		//     "requestTime": 1700533773477,
		//     "data": [
		//         {
		//             "symbol": "BTCUSD",
		//             "lastPr": "29904.5",
		//             "askPr": "29904.5",
		//             "bidPr": "29903.5",
		//             "bidSz": "0.5091",
		//             "askSz": "2.2694",
		//             "high24h": "0",
		//             "low24h": "0",
		//             "ts": "1695794271400",
		//             "change24h": "0",
		//             "baseVolume": "0",
		//             "quoteVolume": "0",
		//             "usdtVolume": "0",
		//             "openUtc": "0",
		//             "changeUtc24h": "0",
		//             "indexPrice": "29132.353333",
		//             "fundingRate": "-0.0007",
		//             "holdingAmount": "125.6844",
		//             "deliveryStartTime": null,
		//             "deliveryTime": null,
		//             "deliveryStatus": "delivery_normal",
		//             "open24h": "0",
		//             "markPrice": "12345"
		//         },
		//     ]
		// }
		symbols = this.MarketSymbols(symbols)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRates(data, symbols)
		return nil

	}()
	return ch
}
func (this *bitget) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchFundingRate: publicMixGetV2MixMarketCurrentFundRate, publicUtaGetV3MarketCurrentFundRate
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "fundingRate": "-0.000013",
	//         "fundingRateInterval": "8",
	//         "nextUpdate": "1745510400000",
	//         "minFundingRate": "-0.003",
	//         "maxFundingRate": "0.003"
	//     }
	//
	// fetchFundingRate: publicMixGetV2MixMarketFundingTime
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "nextFundingTime": "1745424000000",
	//         "ratePeriod": "8"
	//     }
	//
	// fetchFundingInterval
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "nextFundingTime": "1727942400000",
	//         "ratePeriod": "8"
	//     }
	//
	// fetchFundingRates
	//
	//     {
	//         "symbol": "BTCUSD",
	//         "lastPr": "29904.5",
	//         "askPr": "29904.5",
	//         "bidPr": "29903.5",
	//         "bidSz": "0.5091",
	//         "askSz": "2.2694",
	//         "high24h": "0",
	//         "low24h": "0",
	//         "ts": "1695794271400",
	//         "change24h": "0",
	//         "baseVolume": "0",
	//         "quoteVolume": "0",
	//         "usdtVolume": "0",
	//         "openUtc": "0",
	//         "changeUtc24h": "0",
	//         "indexPrice": "29132.353333",
	//         "fundingRate": "-0.0007",
	//         "holdingAmount": "125.6844",
	//         "deliveryStartTime": null,
	//         "deliveryTime": null,
	//         "deliveryStatus": "delivery_normal",
	//         "open24h": "0",
	//         "markPrice": "12345"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market, nil, "swap")
	var fundingTimestamp interface{} = this.SafeInteger2(contract, "nextFundingTime", "nextUpdate")
	var interval interface{} = this.SafeString2(contract, "ratePeriod", "fundingRateInterval")
	var timestamp interface{} = this.SafeInteger(contract, "ts")
	var markPrice interface{} = this.SafeNumber(contract, "markPrice")
	var indexPrice interface{} = this.SafeNumber(contract, "indexPrice")
	var intervalString interface{} = nil
	if IsTrue(!IsEqual(interval, nil)) {
		intervalString = Add(interval, "h")
	}
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                markPrice,
		"indexPrice":               indexPrice,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                timestamp,
		"datetime":                 this.Iso8601(timestamp),
		"fundingRate":              this.SafeNumber(contract, "fundingRate"),
		"fundingTimestamp":         fundingTimestamp,
		"fundingDatetime":          this.Iso8601(fundingTimestamp),
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nil,
		"nextFundingDatetime":      nil,
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 intervalString,
	}
}

/**
 * @method
 * @name bitget#fetchFundingHistory
 * @description fetch the funding history
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
 * @param {string} symbol unified market symbol
 * @param {int} [since] the starting timestamp in milliseconds
 * @param {int} [limit] the number of entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch funding history for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func (this *bitget) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes86018 := (<-this.LoadMarkets())
		PanicOnError(retRes86018)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingHistory() requires a symbol argument")))
		}
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes860819 := (<-this.FetchPaginatedCallCursor("fetchFundingHistory", symbol, since, limit, params, "endId", "idLessThan"))
			PanicOnError(retRes860819)
			ch <- retRes860819
			return nil
		}
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadSymbol(Add(this.Id, " fetchFundingHistory() supports swap contracts only")))
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":       GetValue(market, "id"),
			"marginCoin":   GetValue(market, "settleId"),
			"businessType": "contract_settle_fee",
			"productType":  productType,
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateMixGetV2MixAccountBill(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700795977890,
		//         "data": {
		//             "bills": [
		//                 {
		//                     "billId": "1111499428100472833",
		//                     "symbol": "BTCUSDT",
		//                     "amount": "-0.004992",
		//                     "fee": "0",
		//                     "feeByCoupon": "",
		//                     "businessType": "contract_settle_fee",
		//                     "coin": "USDT",
		//                     "cTime": "1700728034996"
		//                 },
		//             ],
		//             "endId": "1098396773329305606"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var result interface{} = this.SafeValue(data, "bills", []interface{}{})

		ch <- this.ParseFundingHistories(result, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseFundingHistory(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "billId": "1111499428100472833",
	//         "symbol": "BTCUSDT",
	//         "amount": "-0.004992",
	//         "fee": "0",
	//         "feeByCoupon": "",
	//         "businessType": "contract_settle_fee",
	//         "coin": "USDT",
	//         "cTime": "1700728034996"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var currencyId interface{} = this.SafeString(contract, "coin")
	var timestamp interface{} = this.SafeInteger(contract, "cTime")
	return map[string]interface{}{
		"info":      contract,
		"symbol":    this.SafeSymbol(marketId, market, nil, "swap"),
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"code":      this.SafeCurrencyCode(currencyId),
		"amount":    this.SafeNumber(contract, "amount"),
		"id":        this.SafeString(contract, "billId"),
	}
}
func (this *bitget) ParseFundingHistories(contracts interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	since := GetArg(optionalArgs, 1, nil)
	_ = since
	limit := GetArg(optionalArgs, 2, nil)
	_ = limit
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(contracts)); i++ {
		var contract interface{} = GetValue(contracts, i)
		var business interface{} = this.SafeString(contract, "businessType")
		if IsTrue(!IsEqual(business, "contract_settle_fee")) {
			continue
		}
		AppendToArray(&result, this.ParseFundingHistory(contract, market))
	}
	var sorted interface{} = this.SortBy(result, "timestamp")
	var symbol interface{} = nil
	if IsTrue(!IsEqual(market, nil)) {
		symbol = GetValue(market, "symbol")
	}
	return this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func (this *bitget) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes87038 := (<-this.LoadMarkets())
		PanicOnError(retRes87038)
		var holdSide interface{} = this.SafeString(params, "holdSide")
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":      GetValue(market, "id"),
			"marginCoin":  GetValue(market, "settleId"),
			"amount":      this.AmountToPrecision(symbol, amount),
			"holdSide":    holdSide,
			"productType": productType,
		}
		params = this.Omit(params, "holdSide")

		response := (<-this.PrivateMixPostV2MixAccountSetMargin(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700813444618,
		//         "data": ""
		//     }
		//
		ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{}{
			"amount": this.ParseNumber(amount),
			"type":   typeVar,
		})
		return nil

	}()
	return ch
}
func (this *bitget) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{} {
	//
	// addMargin/reduceMargin
	//
	//     {
	//         "code": "00000",
	//         "msg": "success",
	//         "requestTime": 1700813444618,
	//         "data": ""
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var errorCode interface{} = this.SafeString(data, "code")
	var status interface{} = Ternary(IsTrue((IsEqual(errorCode, "00000"))), "ok", "failed")
	return map[string]interface{}{
		"info":       data,
		"symbol":     GetValue(market, "symbol"),
		"type":       nil,
		"marginMode": "isolated",
		"amount":     nil,
		"total":      nil,
		"code":       GetValue(market, "settle"),
		"status":     status,
		"timestamp":  nil,
		"datetime":   nil,
	}
}

/**
 * @method
 * @name bitget#reduceMargin
 * @description remove margin from a position
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func (this *bitget) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(IsGreaterThan(amount, 0)) {
			panic(BadRequest(Add(this.Id, " reduceMargin() amount parameter must be a negative value")))
		}
		var holdSide interface{} = this.SafeString(params, "holdSide")
		if IsTrue(IsEqual(holdSide, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " reduceMargin() requires a holdSide parameter, either long or short")))
		}

		retRes877615 := (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
		PanicOnError(retRes877615)
		ch <- retRes877615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#addMargin
 * @description add margin
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func (this *bitget) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var holdSide interface{} = this.SafeString(params, "holdSide")
		if IsTrue(IsEqual(holdSide, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " addMargin() requires a holdSide parameter, either long or short")))
		}

		retRes879415 := (<-this.ModifyMarginHelper(symbol, amount, "add", params))
		PanicOnError(retRes879415)
		ch <- retRes879415
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *bitget) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes88078 := (<-this.LoadMarkets())
		PanicOnError(retRes88078)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":      GetValue(market, "id"),
			"marginCoin":  GetValue(market, "settleId"),
			"productType": productType,
		}

		response := (<-this.PrivateMixGetV2MixAccountAccount(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1709366911964,
		//         "data": {
		//             "marginCoin": "USDT",
		//             "locked": "0",
		//             "available": "0",
		//             "crossedMaxAvailable": "0",
		//             "isolatedMaxAvailable": "0",
		//             "maxTransferOut": "0",
		//             "accountEquity": "0",
		//             "usdtEquity": "0.000000009166",
		//             "btcEquity": "0",
		//             "crossedRiskRate": "0",
		//             "crossedMarginLeverage": 20,
		//             "isolatedLongLever": 20,
		//             "isolatedShortLever": 20,
		//             "marginMode": "crossed",
		//             "posMode": "hedge_mode",
		//             "unrealizedPL": "0",
		//             "coupon": "0",
		//             "crossedUnrealizedPL": "0",
		//             "isolatedUnrealizedPL": ""
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var isCrossMarginMode interface{} = IsEqual(this.SafeString(leverage, "marginMode"), "crossed")
	var longLevKey interface{} = Ternary(IsTrue(isCrossMarginMode), "crossedMarginLeverage", "isolatedLongLever")
	var shortLevKey interface{} = Ternary(IsTrue(isCrossMarginMode), "crossedMarginLeverage", "isolatedShortLever")
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        GetValue(market, "symbol"),
		"marginMode":    Ternary(IsTrue(isCrossMarginMode), "cross", "isolated"),
		"longLeverage":  this.SafeInteger(leverage, longLevKey),
		"shortLeverage": this.SafeInteger(leverage, shortLevKey),
	}
}

/**
 * @method
 * @name bitget#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.bitget.com/api-doc/contract/account/Change-Leverage
 * @see https://www.bitget.com/api-doc/uta/account/Change-Leverage
 * @param {int} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.holdSide] *isolated only* position direction, 'long' or 'short'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @param {boolean} [params.posSide] required for uta isolated margin, long or short
 * @returns {object} response from the exchange
 */
func (this *bitget) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes88808 := (<-this.LoadMarkets())
		PanicOnError(retRes88808)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"leverage": this.NumberToString(leverage),
		}
		var uta interface{} = nil
		var response interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "setLeverage", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(IsEqual(productType, "SPOT")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTrades", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				if IsTrue(!IsEqual(marginMode, nil)) {
					productType = "MARGIN"
				}
			}
			AddElementToObject(request, "coin", GetValue(market, "settleId"))
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaPostV3AccountSetLeverage(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixPostV2MixAccountSetLeverage(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin-Mode
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *bitget) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}
		marginMode = ToLower(marginMode)
		if IsTrue(IsEqual(marginMode, "cross")) {
			marginMode = "crossed"
		}
		if IsTrue(IsTrue((!IsEqual(marginMode, "isolated"))) && IsTrue((!IsEqual(marginMode, "crossed")))) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() marginMode must be either isolated or crossed (cross)")))
		}

		retRes89548 := (<-this.LoadMarkets())
		PanicOnError(retRes89548)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":      GetValue(market, "id"),
			"marginCoin":  GetValue(market, "settleId"),
			"marginMode":  marginMode,
			"productType": productType,
		}

		response := (<-this.PrivateMixPostV2MixAccountSetMarginMode(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700865205552,
		//         "data": {
		//             "symbol": "BTCUSDT",
		//             "marginCoin": "USDT",
		//             "longLeverage": "20",
		//             "shortLeverage": "3",
		//             "marginMode": "isolated"
		//         }
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://www.bitget.com/api-doc/contract/account/Change-Hold-Mode
 * @see https://www.bitget.com/api-doc/uta/account/Change-Position-Mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by bitget setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] required if not uta and symbol is undefined: 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} response from the exchange
 */
func (this *bitget) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes89968 := (<-this.LoadMarkets())
		PanicOnError(retRes89968)
		var posMode interface{} = Ternary(IsTrue(hedged), "hedge_mode", "one_way_mode")
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var productType interface{} = nil
		var uta interface{} = nil
		var response interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "setPositionMode", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "holdMode", posMode)

			response = (<-this.PrivateUtaPostV3AccountSetHoldMode(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "posMode", posMode)
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixPostV2MixAccountSetPositionMode(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchOpenInterest
 * @description retrieves the open interest of a contract trading pair
 * @see https://www.bitget.com/api-doc/contract/market/Get-Open-Interest
 * @see https://www.bitget.com/api-doc/uta/public/Get-Open-Interest
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func (this *bitget) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes90498 := (<-this.LoadMarkets())
		PanicOnError(retRes90498)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "contract")) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
		}
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var uta interface{} = nil
		var response interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchOpenInterest", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PublicUtaGetV3MarketOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOpenInterest(data, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	// default
	//
	//     {
	//         "openInterestList": [
	//             {
	//                 "symbol": "BTCUSDT",
	//                 "size": "52234.134"
	//             }
	//         ],
	//         "ts": "1700866041023"
	//     }
	//
	// uta
	//
	//     {
	//         "list": [
	//             {
	//                 "symbol": "BTCUSDT",
	//                 "openInterest": "18166.3583"
	//             }
	//         ],
	//         "ts": "1751101220993"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var data interface{} = this.SafeList2(interest, "openInterestList", "list", []interface{}{})
	var timestamp interface{} = this.SafeInteger(interest, "ts")
	var marketId interface{} = this.SafeString(GetValue(data, 0), "symbol")
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             this.SafeSymbol(marketId, market, nil, "contract"),
		"openInterestAmount": this.SafeNumber2(GetValue(data, 0), "size", "openInterest"),
		"openInterestValue":  nil,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"info":               interest,
	}, market)
}

/**
 * @method
 * @name bitget#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-TransferRecords
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *bitget) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchTransfers() requires a code argument")))
		}

		retRes91608 := (<-this.LoadMarkets())
		PanicOnError(retRes91608)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTransfers", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var fromAccount interface{} = this.SafeString(params, "fromAccount", typeVar)
		params = this.Omit(params, "fromAccount")
		var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{}{})
		typeVar = this.SafeString(accountsByType, fromAccount)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":     GetValue(currency, "id"),
			"fromType": typeVar,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.PrivateSpotGetV2SpotAccountTransferRecords(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700873854651,
		//         "data": [
		//             {
		//                 "coin": "USDT",
		//                 "status": "Successful",
		//                 "toType": "crossed_margin",
		//                 "toSymbol": "",
		//                 "fromType": "spot",
		//                 "fromSymbol": "",
		//                 "size": "11.64958799",
		//                 "ts": "1700729673028",
		//                 "clientOid": "1111506298504744960",
		//                 "transferId": "24930940"
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransfers(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.bitget.com/api-doc/spot/account/Wallet-Transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] unified CCXT market symbol, required when transferring to or from an account type that is a leveraged position-by-position account
 * @param {string} [params.clientOid] custom id
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *bitget) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes92208 := (<-this.LoadMarkets())
		PanicOnError(retRes92208)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{}{})
		var fromType interface{} = this.SafeString(accountsByType, fromAccount)
		var toType interface{} = this.SafeString(accountsByType, toAccount)
		var request interface{} = map[string]interface{}{
			"fromType": fromType,
			"toType":   toType,
			"amount":   amount,
			"coin":     GetValue(currency, "id"),
		}
		var symbol interface{} = this.SafeString(params, "symbol")
		params = this.Omit(params, "symbol")
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}

		response := (<-this.PrivateSpotPostV2SpotWalletTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700874302021,
		//         "data": {
		//             "transferId": "1112112916581847040",
		//             "clientOrderId": null
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		AddElementToObject(data, "ts", this.SafeInteger(response, "requestTime"))

		ch <- this.ParseTransfer(data, currency)
		return nil

	}()
	return ch
}
func (this *bitget) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// transfer
	//
	//     {
	//         "transferId": "1112112916581847040",
	//         "clientOrderId": null,
	//         "ts": 1700874302021
	//     }
	//
	// fetchTransfers
	//
	//     {
	//         "coin": "USDT",
	//         "status": "Successful",
	//         "toType": "crossed_margin",
	//         "toSymbol": "",
	//         "fromType": "spot",
	//         "fromSymbol": "",
	//         "size": "11.64958799",
	//         "ts": "1700729673028",
	//         "clientOid": "1111506298504744960",
	//         "transferId": "24930940"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transfer, "ts")
	var status interface{} = this.SafeStringLower(transfer, "status")
	var currencyId interface{} = this.SafeString(transfer, "coin")
	var fromAccountRaw interface{} = this.SafeString(transfer, "fromType")
	var accountsById interface{} = this.SafeValue(this.Options, "accountsById", map[string]interface{}{})
	var fromAccount interface{} = this.SafeString(accountsById, fromAccountRaw, fromAccountRaw)
	var toAccountRaw interface{} = this.SafeString(transfer, "toType")
	var toAccount interface{} = this.SafeString(accountsById, toAccountRaw, toAccountRaw)
	return map[string]interface{}{
		"info":        transfer,
		"id":          this.SafeString(transfer, "transferId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    this.SafeCurrencyCode(currencyId, currency),
		"amount":      this.SafeNumber(transfer, "size"),
		"fromAccount": fromAccount,
		"toAccount":   toAccount,
		"status":      this.ParseTransferStatus(status),
	}
}
func (this *bitget) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"successful": "ok",
	}
	return this.SafeString(statuses, status, status)
}
func (this *bitget) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "chains": [
	//             {
	//                 "browserUrl": "https://blockchair.com/bitcoin/transaction/",
	//                 "chain": "BTC",
	//                 "depositConfirm": "1",
	//                 "extraWithdrawFee": "0",
	//                 "minDepositAmount": "0.0001",
	//                 "minWithdrawAmount": "0.005",
	//                 "needTag": "false",
	//                 "rechargeable": "true",
	//                 "withdrawConfirm": "1",
	//                 "withdrawFee": "0.0004",
	//                 "withdrawable": "true"
	//             },
	//         ],
	//         "coin": "BTC",
	//         "coinId": "1",
	//         "transfer": "true""
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var chains interface{} = this.SafeValue(fee, "chains", []interface{}{})
	var chainsLength interface{} = GetArrayLength(chains)
	var result interface{} = map[string]interface{}{
		"info": fee,
		"withdraw": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"networks": map[string]interface{}{},
	}
	for i := 0; IsLessThan(i, chainsLength); i++ {
		var chain interface{} = GetValue(chains, i)
		var networkId interface{} = this.SafeString(chain, "chain")
		var currencyCode interface{} = this.SafeString(currency, "code")
		var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
		AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
			"deposit": map[string]interface{}{
				"fee":        nil,
				"percentage": nil,
			},
			"withdraw": map[string]interface{}{
				"fee":        this.SafeNumber(chain, "withdrawFee"),
				"percentage": false,
			},
		})
		if IsTrue(IsEqual(chainsLength, 1)) {
			AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(chain, "withdrawFee"))
			AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
		}
	}
	return result
}

/**
 * @method
 * @name bitget#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *bitget) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes93728 := (<-this.LoadMarkets())
		PanicOnError(retRes93728)

		response := (<-this.PublicSpotGetV2SpotPublicCoins(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "data": [
		//             {
		//                 "chains": [
		//                     {
		//                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
		//                         "chain": "BTC",
		//                         "depositConfirm": "1",
		//                         "extraWithdrawFee": "0",
		//                         "minDepositAmount": "0.0001",
		//                         "minWithdrawAmount": "0.005",
		//                         "needTag": "false",
		//                         "rechargeable": "true",
		//                         "withdrawConfirm": "1",
		//                         "withdrawFee": "0.0004",
		//                         "withdrawable": "true"
		//                     },
		//                 ],
		//                 "coin": "BTC",
		//                 "coinId": "1",
		//                 "transfer": "true""
		//             }
		//         ],
		//         "msg": "success",
		//         "requestTime": "1700120731773"
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseDepositWithdrawFees(data, codes, "coin")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Borrow
 * @param {string} code unified currency code of the currency to borrow
 * @param {string} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *bitget) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes94188 := (<-this.LoadMarkets())
		PanicOnError(retRes94188)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":         GetValue(currency, "id"),
			"borrowAmount": this.CurrencyToPrecision(code, amount),
		}

		response := (<-this.PrivateMarginPostV2MarginCrossedAccountBorrow(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700876470931,
		//         "data": {
		//             "loanId": "1112122013642272769",
		//             "coin": "USDT",
		//             "borrowAmount": "4"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Borrow
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to borrow
 * @param {string} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *bitget) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes94538 := (<-this.LoadMarkets())
		PanicOnError(retRes94538)
		var currency interface{} = this.Currency(code)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"coin":         GetValue(currency, "id"),
			"borrowAmount": this.CurrencyToPrecision(code, amount),
			"symbol":       GetValue(market, "id"),
		}

		response := (<-this.PrivateMarginPostV2MarginIsolatedAccountBorrow(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700877255605,
		//         "data": {
		//             "loanId": "1112125304879067137",
		//             "symbol": "BTCUSDT",
		//             "coin": "USDT",
		//             "borrowAmount": "4"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Repay
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {string} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *bitget) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes94918 := (<-this.LoadMarkets())
		PanicOnError(retRes94918)
		var currency interface{} = this.Currency(code)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"coin":        GetValue(currency, "id"),
			"repayAmount": this.CurrencyToPrecision(code, amount),
			"symbol":      GetValue(market, "id"),
		}

		response := (<-this.PrivateMarginPostV2MarginIsolatedAccountRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700877518012,
		//         "data": {
		//             "remainDebtAmount": "0",
		//             "repayId": "1112126405439270912",
		//             "symbol": "BTCUSDT",
		//             "coin": "USDT",
		//             "repayAmount": "8.000137"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Repay
 * @param {string} code unified currency code of the currency to repay
 * @param {string} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *bitget) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes95298 := (<-this.LoadMarkets())
		PanicOnError(retRes95298)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":        GetValue(currency, "id"),
			"repayAmount": this.CurrencyToPrecision(code, amount),
		}

		response := (<-this.PrivateMarginPostV2MarginCrossedAccountRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700876704885,
		//         "data": {
		//             "remainDebtAmount": "0",
		//             "repayId": "1112122994945830912",
		//             "coin": "USDT",
		//             "repayAmount": "4.00006834"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}
func (this *bitget) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// isolated: borrowMargin
	//
	//     {
	//         "loanId": "1112125304879067137",
	//         "symbol": "BTCUSDT",
	//         "coin": "USDT",
	//         "borrowAmount": "4"
	//     }
	//
	// cross: borrowMargin
	//
	//     {
	//         "loanId": "1112122013642272769",
	//         "coin": "USDT",
	//         "borrowAmount": "4"
	//     }
	//
	// isolated: repayMargin
	//
	//     {
	//         "remainDebtAmount": "0",
	//         "repayId": "1112126405439270912",
	//         "symbol": "BTCUSDT",
	//         "coin": "USDT",
	//         "repayAmount": "8.000137"
	//     }
	//
	// cross: repayMargin
	//
	//     {
	//         "remainDebtAmount": "0",
	//         "repayId": "1112122994945830912",
	//         "coin": "USDT",
	//         "repayAmount": "4.00006834"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	market := GetArg(optionalArgs, 1, nil)
	_ = market
	var currencyId interface{} = this.SafeString(info, "coin")
	var marketId interface{} = this.SafeString(info, "symbol")
	var symbol interface{} = nil
	if IsTrue(!IsEqual(marketId, nil)) {
		symbol = this.SafeSymbol(marketId, market, nil, "spot")
	}
	return map[string]interface{}{
		"id":        this.SafeString2(info, "loanId", "repayId"),
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"amount":    this.SafeNumber2(info, "borrowAmount", "repayAmount"),
		"symbol":    symbol,
		"timestamp": nil,
		"datetime":  nil,
		"info":      info,
	}
}

/**
 * @method
 * @name bitget#fetchMyLiquidations
 * @description retrieves the users liquidated positions
 * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Liquidation-Records
 * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Liquidation-Records
 * @param {string} [symbol] unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitget api endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @param {string} [params.marginMode] 'cross' or 'isolated' default value is 'cross'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func (this *bitget) FetchMyLiquidations(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes96248 := (<-this.LoadMarkets())
		PanicOnError(retRes96248)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyLiquidations", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes962819 := (<-this.FetchPaginatedCallCursor("fetchMyLiquidations", symbol, since, limit, params, "minId", "idLessThan"))
			PanicOnError(retRes962819)
			ch <- retRes962819
			return nil
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchMyLiquidations", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(!IsEqual(typeVar, "spot")) {
			panic(NotSupported(Add(this.Id, " fetchMyLiquidations() supports spot margin markets only")))
		}
		var request interface{} = map[string]interface{}{}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		} else {
			AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyLiquidations", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, "isolated")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchMyLiquidations() requires a symbol argument")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.PrivateMarginGetV2MarginIsolatedLiquidationHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "cross")) {

			response = (<-this.PrivateMarginGetV2MarginCrossedLiquidationHistory(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// isolated
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1698114119193,
		//         "data": {
		//             "resultList": [
		//                 {
		//                     "liqId": "123",
		//                     "symbol": "BTCUSDT",
		//                     "liqStartTime": "1653453245342",
		//                     "liqEndTime": "16312423423432",
		//                     "liqRiskRatio": "1.01",
		//                     "totalAssets": "1242.34",
		//                     "totalDebt": "1100",
		//                     "liqFee": "1.2",
		//                     "uTime": "1668134458717",
		//                     "cTime": "1653453245342"
		//                 }
		//             ],
		//             "maxId": "0",
		//             "minId": "0"
		//         }
		//     }
		//
		// cross
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1698114119193,
		//         "data": {
		//             "resultList": [
		//                 {
		//                     "liqId": "123",
		//                     "liqStartTime": "1653453245342",
		//                     "liqEndTime": "16312423423432",
		//                     "liqRiskRatio": "1.01",
		//                     "totalAssets": "1242.34",
		//                     "totalDebt": "1100",
		//                     "LiqFee": "1.2",
		//                     "uTime": "1668134458717",
		//                     "cTime": "1653453245342"
		//                 }
		//             ],
		//             "maxId": "0",
		//             "minId": "0"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var liquidations interface{} = this.SafeList(data, "resultList", []interface{}{})

		ch <- this.ParseLiquidations(liquidations, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{} {
	//
	// isolated
	//
	//     {
	//         "liqId": "123",
	//         "symbol": "BTCUSDT",
	//         "liqStartTime": "1653453245342",
	//         "liqEndTime": "16312423423432",
	//         "liqRiskRatio": "1.01",
	//         "totalAssets": "1242.34",
	//         "totalDebt": "1100",
	//         "liqFee": "1.2",
	//         "uTime": "1692690126000"
	//         "cTime": "1653453245342"
	//     }
	//
	// cross
	//
	//     {
	//         "liqId": "123",
	//         "liqStartTime": "1653453245342",
	//         "liqEndTime": "16312423423432",
	//         "liqRiskRatio": "1.01",
	//         "totalAssets": "1242.34",
	//         "totalDebt": "1100",
	//         "LiqFee": "1.2",
	//         "uTime": "1692690126000"
	//         "cTime": "1653453245342"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(liquidation, "symbol")
	var timestamp interface{} = this.SafeInteger(liquidation, "liqEndTime")
	var liquidationFee interface{} = this.SafeString2(liquidation, "LiqFee", "liqFee")
	var totalDebt interface{} = this.SafeString(liquidation, "totalDebt")
	var quoteValueString interface{} = Precise.StringAdd(liquidationFee, totalDebt)
	return this.SafeLiquidation(map[string]interface{}{
		"info":         liquidation,
		"symbol":       this.SafeSymbol(marketId, market),
		"contracts":    nil,
		"contractSize": nil,
		"price":        nil,
		"baseValue":    nil,
		"quoteValue":   this.ParseNumber(quoteValueString),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
	})
}

/**
 * @method
 * @name bitget#fetchIsolatedBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Margin-Interest-Rate-And-Max-Borrowable-Amount
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
 */
func (this *bitget) FetchIsolatedBorrowRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes97778 := (<-this.LoadMarkets())
		PanicOnError(retRes97778)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateMarginGetV2MarginIsolatedInterestRateAndLimit(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700878692567,
		//         "data": [
		//             {
		//                 "symbol": "BTCUSDT",
		//                 "leverage": "10",
		//                 "baseCoin": "BTC",
		//                 "baseTransferable": true,
		//                 "baseBorrowable": true,
		//                 "baseDailyInterestRate": "0.00007",
		//                 "baseAnnuallyInterestRate": "0.02555",
		//                 "baseMaxBorrowableAmount": "27",
		//                 "baseVipList": [
		//                     {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
		//                     {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
		//                     {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
		//                     {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
		//                     {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
		//                     {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
		//                 ],
		//                 "quoteCoin": "USDT",
		//                 "quoteTransferable": true,
		//                 "quoteBorrowable": true,
		//                 "quoteDailyInterestRate": "0.00041095",
		//                 "quoteAnnuallyInterestRate": "0.14999675",
		//                 "quoteMaxBorrowableAmount": "300000",
		//                 "quoteList": [
		//                     {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
		//                     {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
		//                     {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
		//                     {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
		//                     {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
		//                     {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
		//                 ]
		//             }
		//         ]
		//     }
		//
		var timestamp interface{} = this.SafeInteger(response, "requestTime")
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var first interface{} = this.SafeValue(data, 0, map[string]interface{}{})
		AddElementToObject(first, "timestamp", timestamp)

		ch <- this.ParseIsolatedBorrowRate(first, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "leverage": "10",
	//         "baseCoin": "BTC",
	//         "baseTransferable": true,
	//         "baseBorrowable": true,
	//         "baseDailyInterestRate": "0.00007",
	//         "baseAnnuallyInterestRate": "0.02555",
	//         "baseMaxBorrowableAmount": "27",
	//         "baseVipList": [
	//             {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
	//             {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
	//             {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
	//             {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
	//             {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
	//             {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
	//         ],
	//         "quoteCoin": "USDT",
	//         "quoteTransferable": true,
	//         "quoteBorrowable": true,
	//         "quoteDailyInterestRate": "0.00041095",
	//         "quoteAnnuallyInterestRate": "0.14999675",
	//         "quoteMaxBorrowableAmount": "300000",
	//         "quoteList": [
	//             {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
	//             {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
	//             {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
	//             {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
	//             {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
	//             {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
	//         ]
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market, nil, "spot")
	var baseId interface{} = this.SafeString(info, "baseCoin")
	var quoteId interface{} = this.SafeString(info, "quoteCoin")
	var timestamp interface{} = this.SafeInteger(info, "timestamp")
	return map[string]interface{}{
		"symbol":    symbol,
		"base":      this.SafeCurrencyCode(baseId),
		"baseRate":  this.SafeNumber(info, "baseDailyInterestRate"),
		"quote":     this.SafeCurrencyCode(quoteId),
		"quoteRate": this.SafeNumber(info, "quoteDailyInterestRate"),
		"period":    86400000,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}

/**
 * @method
 * @name bitget#fetchCrossBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Margin-Interest-Rate-And-Borrowable
 * @see https://www.bitget.com/api-doc/uta/public/Get-Margin-Loans
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#borrow-rate-structure}
 */
func (this *bitget) FetchCrossBorrowRate(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes98968 := (<-this.LoadMarkets())
		PanicOnError(retRes98968)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin": GetValue(currency, "id"),
		}
		var uta interface{} = nil
		var response interface{} = nil
		var result interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchCrossBorrowRate", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			response = (<-this.PublicUtaGetV3MarketMarginLoans(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1752817798893,
			//         "data": {
			//             "dailyInterest": "0.00100008",
			//             "annualInterest": "0.3650292",
			//             "limit": "100"
			//         }
			//     }
			//
			result = this.SafeDict(response, "data", map[string]interface{}{})
		} else {

			response = (<-this.PrivateMarginGetV2MarginCrossedInterestRateAndLimit(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "00000",
			//         "msg": "success",
			//         "requestTime": 1700879047861,
			//         "data": [
			//             {
			//                 "coin": "BTC",
			//                 "leverage": "3",
			//                 "transferable": true,
			//                 "borrowable": true,
			//                 "dailyInterestRate": "0.00007",
			//                 "annualInterestRate": "0.02555",
			//                 "maxBorrowableAmount": "26",
			//                 "vipList": [
			//                     {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
			//                     {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
			//                     {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
			//                     {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
			//                     {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
			//                     {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
			//                 ]
			//             }
			//         ]
			//     }
			//
			var data interface{} = this.SafeValue(response, "data", []interface{}{})
			result = this.SafeValue(data, 0, map[string]interface{}{})
		}
		var timestamp interface{} = this.SafeInteger(response, "requestTime")
		AddElementToObject(result, "timestamp", timestamp)

		ch <- this.ParseBorrowRate(result, currency)
		return nil

	}()
	return ch
}
func (this *bitget) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// default
	//
	//     {
	//         "coin": "BTC",
	//         "leverage": "3",
	//         "transferable": true,
	//         "borrowable": true,
	//         "dailyInterestRate": "0.00007",
	//         "annualInterestRate": "0.02555",
	//         "maxBorrowableAmount": "26",
	//         "vipList": [
	//             {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
	//             {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
	//             {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
	//             {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
	//             {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
	//             {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
	//         ]
	//     }
	//
	// uta
	//
	//     {
	//         "dailyInterest": "0.00100008",
	//         "annualInterest": "0.3650292",
	//         "limit": "100"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(info, "coin")
	var timestamp interface{} = this.SafeInteger(info, "timestamp")
	return map[string]interface{}{
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"rate":      this.SafeNumber2(info, "dailyInterestRate", "dailyInterest"),
		"period":    86400000,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}

/**
 * @method
 * @name bitget#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Interest-Records
 * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Interest-Records
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol when fetching interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func (this *bitget) FetchBorrowInterest(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		symbol := GetArg(optionalArgs, 1, nil)
		_ = symbol
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes100138 := (<-this.LoadMarkets())
		PanicOnError(retRes100138)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchBorrowInterest", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes1001719 := (<-this.FetchPaginatedCallCursor("fetchBorrowInterest", symbol, since, limit, params, "minId", "idLessThan"))
			PanicOnError(retRes1001719)
			ch <- retRes1001719
			return nil
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		} else {
			AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, "isolated")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchBorrowInterest() requires a symbol argument")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.PrivateMarginGetV2MarginIsolatedInterestHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marginMode, "cross")) {

			response = (<-this.PrivateMarginGetV2MarginCrossedInterestHistory(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// isolated
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700879935189,
		//         "data": {
		//             "resultList": [
		//                 {
		//                     "interestId": "1112125304879067137",
		//                     "interestCoin": "USDT",
		//                     "dailyInterestRate": "0.00041095",
		//                     "loanCoin": "USDT",
		//                     "interestAmount": "0.0000685",
		//                     "interstType": "first",
		//                     "symbol": "BTCUSDT",
		//                     "cTime": "1700877255648",
		//                     "uTime": "1700877255648"
		//                 },
		//             ],
		//             "maxId": "1112125304879067137",
		//             "minId": "1100138015672119298"
		//         }
		//     }
		//
		// cross
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1700879597044,
		//         "data": {
		//             "resultList": [
		//                 {
		//                     "interestId": "1112122013642272769",
		//                     "interestCoin": "USDT",
		//                     "dailyInterestRate": "0.00041",
		//                     "loanCoin": "USDT",
		//                     "interestAmount": "0.00006834",
		//                     "interstType": "first",
		//                     "cTime": "1700876470957",
		//                     "uTime": "1700876470957"
		//                 },
		//             ],
		//             "maxId": "1112122013642272769",
		//             "minId": "1096917004629716993"
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var rows interface{} = this.SafeValue(data, "resultList", []interface{}{})
		var interest interface{} = this.ParseBorrowInterests(rows, market)

		ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// isolated
	//
	//     {
	//         "interestId": "1112125304879067137",
	//         "interestCoin": "USDT",
	//         "dailyInterestRate": "0.00041095",
	//         "loanCoin": "USDT",
	//         "interestAmount": "0.0000685",
	//         "interstType": "first",
	//         "symbol": "BTCUSDT",
	//         "cTime": "1700877255648",
	//         "uTime": "1700877255648"
	//     }
	//
	// cross
	//
	//     {
	//         "interestId": "1112122013642272769",
	//         "interestCoin": "USDT",
	//         "dailyInterestRate": "0.00041",
	//         "loanCoin": "USDT",
	//         "interestAmount": "0.00006834",
	//         "interstType": "first",
	//         "cTime": "1700876470957",
	//         "uTime": "1700876470957"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	market = this.SafeMarket(marketId, market)
	var marginMode interface{} = Ternary(IsTrue((!IsEqual(marketId, nil))), "isolated", "cross")
	var timestamp interface{} = this.SafeInteger(info, "cTime")
	return map[string]interface{}{
		"info":           info,
		"symbol":         this.SafeString(market, "symbol"),
		"currency":       this.SafeCurrencyCode(this.SafeString(info, "interestCoin")),
		"interest":       this.SafeNumber(info, "interestAmount"),
		"interestRate":   this.SafeNumber(info, "dailyInterestRate"),
		"amountBorrowed": nil,
		"marginMode":     marginMode,
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name bitget#closePosition
 * @description closes an open position for a market
 * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
 * @see https://www.bitget.com/api-doc/uta/trade/Close-All-Positions
 * @param {string} symbol unified CCXT market symbol
 * @param {string} [side] one-way mode: 'buy' or 'sell', hedge-mode: 'long' or 'short'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bitget) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes101648 := (<-this.LoadMarkets())
		PanicOnError(retRes101648)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var productType interface{} = nil
		var uta interface{} = nil
		var response interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "closePosition", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			if IsTrue(!IsEqual(side, nil)) {
				AddElementToObject(request, "posSide", side)
			}
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaPostV3TradeClosePositions(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(side, nil)) {
				AddElementToObject(request, "holdSide", side)
			}
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixPostV2MixOrderClosePositions(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var order interface{} = this.SafeList2(data, "successList", "list", []interface{}{})

		ch <- this.ParseOrder(GetValue(order, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#closeAllPositions
 * @description closes all open positions for a market type
 * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
 * @see https://www.bitget.com/api-doc/uta/trade/Close-All-Positions
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bitget) CloseAllPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes102368 := (<-this.LoadMarkets())
		PanicOnError(retRes102368)
		var request interface{} = map[string]interface{}{}
		var productType interface{} = nil
		var uta interface{} = nil
		var response interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "closeAllPositions", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaPostV3TradeClosePositions(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PrivateMixPostV2MixOrderClosePositions(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var orderInfo interface{} = this.SafeList2(data, "successList", "list", []interface{}{})

		ch <- this.ParsePositions(orderInfo, nil, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchMarginMode
 * @description fetches the margin mode of a trading pair
 * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func (this *bitget) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes102978 := (<-this.LoadMarkets())
		PanicOnError(retRes102978)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":      GetValue(market, "id"),
			"marginCoin":  GetValue(market, "settleId"),
			"productType": productType,
		}

		response := (<-this.PrivateMixGetV2MixAccountAccount(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1709791216652,
		//         "data": {
		//             "marginCoin": "USDT",
		//             "locked": "0",
		//             "available": "19.88811074",
		//             "crossedMaxAvailable": "19.88811074",
		//             "isolatedMaxAvailable": "19.88811074",
		//             "maxTransferOut": "19.88811074",
		//             "accountEquity": "19.88811074",
		//             "usdtEquity": "19.888110749166",
		//             "btcEquity": "0.000302183391",
		//             "crossedRiskRate": "0",
		//             "crossedMarginLeverage": 20,
		//             "isolatedLongLever": 20,
		//             "isolatedShortLever": 20,
		//             "marginMode": "crossed",
		//             "posMode": "hedge_mode",
		//             "unrealizedPL": "0",
		//             "coupon": "0",
		//             "crossedUnrealizedPL": "0",
		//             "isolatedUnrealizedPL": ""
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginMode(data, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marginType interface{} = this.SafeString(marginMode, "marginMode")
	marginType = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", marginType)
	return map[string]interface{}{
		"info":       marginMode,
		"symbol":     GetValue(market, "symbol"),
		"marginMode": marginType,
	}
}

/**
 * @method
 * @name bitget#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
 * @see https://www.bitget.com/api-doc/uta/trade/Get-Position-History
 * @param {string[]} [symbols] unified contract symbols
 * @param {int} [since] timestamp in ms of the earliest position to fetch, default=3 months ago, max range for params["until"] - since is 3 months
 * @param {int} [limit] the maximum amount of records to fetch, default=20, max=100
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest position to fetch, max range for params["until"] - since is 3 months
 * @param {string} [params.productType] USDT-FUTURES (default), COIN-FUTURES, USDC-FUTURES, SUSDT-FUTURES, SCOIN-FUTURES, or SUSDC-FUTURES
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bitget) FetchPositionsHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes103658 := (<-this.LoadMarkets())
		PanicOnError(retRes103658)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		var productType interface{} = nil
		var uta interface{} = nil
		var response interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsGreaterThan(symbolsLength, 0)) {
				market = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchPositionsHistory", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {
			AddElementToObject(request, "category", productType)

			response = (<-this.PrivateUtaGetV3PositionHistoryPosition(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateMixGetV2MixPositionHistoryPosition(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var responseList interface{} = this.SafeList(data, "list", []interface{}{})
		var positions interface{} = this.ParsePositions(responseList, symbols, params)

		ch <- this.FilterBySinceLimit(positions, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://www.bitget.com/api-doc/common/convert/Get-Quoted-Price
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func (this *bitget) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes104728 := (<-this.LoadMarkets())
		PanicOnError(retRes104728)
		var request interface{} = map[string]interface{}{
			"fromCoin":     fromCode,
			"toCoin":       toCode,
			"fromCoinSize": this.NumberToString(amount),
		}

		response := (<-this.PrivateConvertGetV2ConvertQuotedPrice(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1712121940158,
		//         "data": {
		//             "fromCoin": "USDT",
		//             "fromCoinSize": "5",
		//             "cnvtPrice": "0.9993007892377704",
		//             "toCoin": "USDC",
		//             "toCoinSize": "4.99650394",
		//             "traceId": "1159288930228187140",
		//             "fee": "0"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var fromCurrencyId interface{} = this.SafeString(data, "fromCoin", fromCode)
		var fromCurrency interface{} = this.Currency(fromCurrencyId)
		var toCurrencyId interface{} = this.SafeString(data, "toCoin", toCode)
		var toCurrency interface{} = this.Currency(toCurrencyId)

		ch <- this.ParseConversion(data, fromCurrency, toCurrency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#createConvertTrade
 * @description convert from one currency to another
 * @see https://www.bitget.com/api-doc/common/convert/Trade
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} amount how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.price the price of the conversion, obtained from fetchConvertQuote()
 * @param {string} params.toAmount the amount you want to trade in units of the toCurrency, obtained from fetchConvertQuote()
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func (this *bitget) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes105188 := (<-this.LoadMarkets())
		PanicOnError(retRes105188)
		var price interface{} = this.SafeString2(params, "price", "cnvtPrice")
		if IsTrue(IsEqual(price, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createConvertTrade() requires a price parameter")))
		}
		var toAmount interface{} = this.SafeString2(params, "toAmount", "toCoinSize")
		if IsTrue(IsEqual(toAmount, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createConvertTrade() requires a toAmount parameter")))
		}
		params = this.Omit(params, []interface{}{"price", "toAmount"})
		var request interface{} = map[string]interface{}{
			"traceId":      id,
			"fromCoin":     fromCode,
			"toCoin":       toCode,
			"fromCoinSize": this.NumberToString(amount),
			"toCoinSize":   toAmount,
			"cnvtPrice":    price,
		}

		response := (<-this.PrivateConvertPostV2ConvertTrade(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1712123746203,
		//         "data": {
		//             "cnvtPrice": "0.99940076",
		//             "toCoin": "USDC",
		//             "toCoinSize": "4.99700379",
		//             "ts": "1712123746217"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var toCurrencyId interface{} = this.SafeString(data, "toCoin", toCode)
		var toCurrency interface{} = this.Currency(toCurrencyId)

		ch <- this.ParseConversion(data, nil, toCurrency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Record
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func (this *bitget) FetchConvertTradeHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes105688 := (<-this.LoadMarkets())
		PanicOnError(retRes105688)
		var request interface{} = map[string]interface{}{}
		var msInDay interface{} = 86400000
		var now interface{} = this.Milliseconds()
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		} else {
			AddElementToObject(request, "startTime", Subtract(now, msInDay))
		}
		var endTime interface{} = this.SafeString2(params, "endTime", "until")
		if IsTrue(!IsEqual(endTime, nil)) {
			AddElementToObject(request, "endTime", endTime)
		} else {
			AddElementToObject(request, "endTime", now)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		params = this.Omit(params, "until")

		response := (<-this.PrivateConvertGetV2ConvertConvertRecord(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1712124371799,
		//         "data": {
		//             "dataList": [
		//                 {
		//                     "id": "1159296505255219205",
		//                     "fromCoin": "USDT",
		//                     "fromCoinSize": "5",
		//                     "cnvtPrice": "0.99940076",
		//                     "toCoin": "USDC",
		//                     "toCoinSize": "4.99700379",
		//                     "ts": "1712123746217",
		//                     "fee": "0"
		//                 }
		//             ],
		//             "endId": "1159296505255219205"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var dataList interface{} = this.SafeList(data, "dataList", []interface{}{})

		ch <- this.ParseConversions(dataList, code, "fromCoin", "toCoin", since, limit)
		return nil

	}()
	return ch
}
func (this *bitget) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchConvertQuote
	//
	//     {
	//         "fromCoin": "USDT",
	//         "fromCoinSize": "5",
	//         "cnvtPrice": "0.9993007892377704",
	//         "toCoin": "USDC",
	//         "toCoinSize": "4.99650394",
	//         "traceId": "1159288930228187140",
	//         "fee": "0"
	//     }
	//
	// createConvertTrade
	//
	//     {
	//         "cnvtPrice": "0.99940076",
	//         "toCoin": "USDC",
	//         "toCoinSize": "4.99700379",
	//         "ts": "1712123746217"
	//     }
	//
	// fetchConvertTradeHistory
	//
	//     {
	//         "id": "1159296505255219205",
	//         "fromCoin": "USDT",
	//         "fromCoinSize": "5",
	//         "cnvtPrice": "0.99940076",
	//         "toCoin": "USDC",
	//         "toCoinSize": "4.99700379",
	//         "ts": "1712123746217",
	//         "fee": "0"
	//     }
	//
	fromCurrency := GetArg(optionalArgs, 0, nil)
	_ = fromCurrency
	toCurrency := GetArg(optionalArgs, 1, nil)
	_ = toCurrency
	var timestamp interface{} = this.SafeInteger(conversion, "ts")
	var fromCoin interface{} = this.SafeString(conversion, "fromCoin")
	var fromCode interface{} = this.SafeCurrencyCode(fromCoin, fromCurrency)
	var to interface{} = this.SafeString(conversion, "toCoin")
	var toCode interface{} = this.SafeCurrencyCode(to, toCurrency)
	return map[string]interface{}{
		"info":         conversion,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"id":           this.SafeString2(conversion, "id", "traceId"),
		"fromCurrency": fromCode,
		"fromAmount":   this.SafeNumber(conversion, "fromCoinSize"),
		"toCurrency":   toCode,
		"toAmount":     this.SafeNumber(conversion, "toCoinSize"),
		"price":        this.SafeNumber(conversion, "cnvtPrice"),
		"fee":          this.SafeNumber(conversion, "fee"),
	}
}

/**
 * @method
 * @name bitget#fetchConvertCurrencies
 * @description fetches all available currencies that can be converted
 * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *bitget) FetchConvertCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes106798 := (<-this.LoadMarkets())
		PanicOnError(retRes106798)

		response := (<-this.PrivateConvertGetV2ConvertCurrencies(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "requestTime": 1712121755897,
		//         "data": [
		//             {
		//                 "coin": "BTC",
		//                 "available": "0.00009850",
		//                 "maxAmount": "0.756266",
		//                 "minAmount": "0.00001"
		//             },
		//         ]
		//     }
		//
		var result interface{} = map[string]interface{}{}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var id interface{} = this.SafeString(entry, "coin")
			var code interface{} = this.SafeCurrencyCode(id)
			AddElementToObject(result, code, map[string]interface{}{
				"info":      entry,
				"id":        id,
				"code":      code,
				"networks":  nil,
				"type":      nil,
				"name":      nil,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  this.SafeNumber(entry, "available"),
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": this.SafeNumber(entry, "minAmount"),
						"max": this.SafeNumber(entry, "maxAmount"),
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Next-Funding-Time
 * @see https://www.bitget.com/api-doc/uta/public/Get-Current-Funding-Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *bitget) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes107468 := (<-this.LoadMarkets())
		PanicOnError(retRes107468)
		var market interface{} = this.Market(symbol)
		var productType interface{} = nil
		productTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
		productType = GetValue(productTypeparamsVariable, 0)
		params = GetValue(productTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		var uta interface{} = nil
		utaparamsVariable := this.HandleOptionAndParams(params, "fetchFundingInterval", "uta", false)
		uta = GetValue(utaparamsVariable, 0)
		params = GetValue(utaparamsVariable, 1)
		if IsTrue(uta) {

			response = (<-this.PublicUtaGetV3MarketCurrentFundRate(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "productType", productType)

			response = (<-this.PublicMixGetV2MixMarketFundingTime(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseFundingRate(first, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#fetchLongShortRatioHistory
 * @description fetches the long short ratio history for a unified market symbol
 * @see https://www.bitget.com/api-doc/common/apidata/Margin-Ls-Ratio
 * @see https://www.bitget.com/api-doc/common/apidata/Account-Long-Short
 * @param {string} symbol unified symbol of the market to fetch the long short ratio for
 * @param {string} [timeframe] the period for the ratio
 * @param {int} [since] the earliest time in ms to fetch ratios for
 * @param {int} [limit] the maximum number of long short ratio structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/#/?id=long-short-ratio-structure}
 */
func (this *bitget) FetchLongShortRatioHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		timeframe := GetArg(optionalArgs, 1, nil)
		_ = timeframe
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes108128 := (<-this.LoadMarkets())
		PanicOnError(retRes108128)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(timeframe, nil)) {
			AddElementToObject(request, "period", timeframe)
		}
		var response interface{} = nil
		if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {

			response = (<-this.PublicMixGetV2MixMarketAccountLongShort(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicMarginGetV2MarginMarketLongShortRatio(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLongShortRatioHistory(data, market)
		return nil

	}()
	return ch
}
func (this *bitget) ParseLongShortRatio(info interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var timestamp interface{} = this.SafeIntegerOmitZero(info, "ts")
	return map[string]interface{}{
		"info":           info,
		"symbol":         this.SafeSymbol(marketId, market, nil, "contract"),
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
		"timeframe":      nil,
		"longShortRatio": this.SafeNumber2(info, "longShortRatio", "longShortAccountRatio"),
	}
}
func (this *bitget) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if !IsTrue(response) {
		return nil // fallback to default error handler
	}
	//
	// spot
	//
	//     {"code":"00000","msg":"success","requestTime":1713294492511,"data":[...]}"
	//
	//     {"status":"fail","err_code":"01001","err_msg":""}
	//     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
	//     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
	//     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
	//     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
	//     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
	//     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
	//     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
	//     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
	//     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
	//
	// swap
	//
	//     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
	//     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
	//     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
	//     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
	//     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
	//     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
	//     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":""}
	//
	var message interface{} = this.SafeString2(response, "err_msg", "msg")
	var feedback interface{} = Add(Add(this.Id, " "), body)
	var nonEmptyMessage interface{} = (IsTrue(IsTrue((!IsEqual(message, nil))) && IsTrue((!IsEqual(message, "")))) && IsTrue((!IsEqual(message, "success"))))
	if IsTrue(nonEmptyMessage) {
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
	}
	var errorCode interface{} = this.SafeString2(response, "code", "err_code")
	var nonZeroErrorCode interface{} = IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "00000")))
	if IsTrue(nonZeroErrorCode) {
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
	}
	if IsTrue(IsTrue(nonZeroErrorCode) || IsTrue(nonEmptyMessage)) {
		panic(ExchangeError(feedback))
	}
	return nil
}
func (this *bitget) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func (this *bitget) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, []interface{}{})
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var signed interface{} = IsEqual(GetValue(api, 0), "private")
	var endpoint interface{} = GetValue(api, 1)
	var pathPart interface{} = "/api"
	var request interface{} = Add("/", this.ImplodeParams(path, params))
	var payload interface{} = Add(pathPart, request)
	var url interface{} = Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), endpoint)), payload)
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	if IsTrue(!IsTrue(signed) && IsTrue((IsEqual(method, "GET")))) {
		var keys interface{} = ObjectKeys(query)
		var keysLength interface{} = GetArrayLength(keys)
		if IsTrue(IsGreaterThan(keysLength, 0)) {
			url = Add(Add(url, "?"), this.Urlencode(query))
		}
	}
	if IsTrue(signed) {
		this.CheckRequiredCredentials()
		var timestamp interface{} = ToString(this.Nonce())
		var auth interface{} = Add(Add(timestamp, method), payload)
		if IsTrue(IsEqual(method, "POST")) {
			body = this.Json(params)
			auth = Add(auth, body)
		} else {
			if IsTrue(GetArrayLength(ObjectKeys(params))) {
				var queryInner interface{} = Add("?", this.Urlencode(this.Keysort(params)))
				// check #21169 pr
				if IsTrue(IsGreaterThan(GetIndexOf(queryInner, "%24"), OpNeg(1))) {
					queryInner = Replace(queryInner, "%24", "$")
				}
				url = Add(url, queryInner)
				auth = Add(auth, queryInner)
			}
		}
		var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256, "base64")
		var broker interface{} = this.SafeString(this.Options, "broker")
		headers = map[string]interface{}{
			"ACCESS-KEY":         this.ApiKey,
			"ACCESS-SIGN":        signature,
			"ACCESS-TIMESTAMP":   timestamp,
			"ACCESS-PASSPHRASE":  this.Password,
			"X-CHANNEL-API-CODE": broker,
		}
		if IsTrue(IsEqual(method, "POST")) {
			AddElementToObject(headers, "Content-Type", "application/json")
		}
	}
	var sandboxMode interface{} = this.SafeBool2(this.Options, "sandboxMode", "sandbox", false)
	if IsTrue(IsTrue(IsTrue(sandboxMode) && IsTrue((!IsEqual(path, "v2/public/time")))) && IsTrue((!IsEqual(path, "v3/market/current-fund-rate")))) {
		// https://github.com/ccxt/ccxt/issues/25252#issuecomment-2662742336
		if IsTrue(IsEqual(headers, nil)) {
			headers = map[string]interface{}{}
		}
		var productType interface{} = this.SafeString(params, "productType")
		if IsTrue(IsTrue(IsTrue((!IsEqual(productType, "SCOIN-FUTURES"))) && IsTrue((!IsEqual(productType, "SUSDT-FUTURES")))) && IsTrue((!IsEqual(productType, "SUSDC-FUTURES")))) {
			AddElementToObject(headers, "PAPTRADING", "1")
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}

func (this *bitget) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
