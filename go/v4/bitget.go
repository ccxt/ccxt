package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitget struct {
    Exchange

}

func NewBitgetCore() bitget {
   p := bitget{}
   setDefaults(&p)
   return p
}

func  (this *bitget) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitget",
        "name": "Bitget",
        "countries": []interface{}{"SG"},
        "version": "v2",
        "rateLimit": 50,
        "certified": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": true,
            "option": false,
            "addMargin": true,
            "borrowCrossMargin": true,
            "borrowIsolatedMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": true,
            "closePosition": true,
            "createConvertTrade": true,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createOrderWithTakeProfitAndStopLoss": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopLossOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "createTakeProfitOrder": true,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": true,
            "createTriggerOrder": true,
            "editOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowInterest": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledAndClosedOrders": true,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchConvertCurrencies": true,
            "fetchConvertQuote": true,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": true,
            "fetchCrossBorrowRate": true,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": true,
            "fetchIsolatedBorrowRate": true,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchLongShortRatio": false,
            "fetchLongShortRatioHistory": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": true,
            "fetchMarketLeverageTiers": true,
            "fetchMarkets": true,
            "fetchMarkOHLCV": true,
            "fetchMarkPrice": true,
            "fetchMyLiquidations": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": true,
            "fetchPositionHistory": "emulated",
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": true,
            "fetchWithdrawAddresses": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "repayCrossMargin": true,
            "repayIsolatedMargin": true,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": true,
            "setPositionMode": true,
            "signIn": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1m",
        },
        "hostname": "bitget.com",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/fbaa10cc-a277-441d-a5b7-997dd9a87658",
            "api": map[string]interface{} {
                "spot": "https://api.{hostname}",
                "mix": "https://api.{hostname}",
                "user": "https://api.{hostname}",
                "p2p": "https://api.{hostname}",
                "broker": "https://api.{hostname}",
                "margin": "https://api.{hostname}",
                "common": "https://api.{hostname}",
                "tax": "https://api.{hostname}",
                "convert": "https://api.{hostname}",
                "copy": "https://api.{hostname}",
                "earn": "https://api.{hostname}",
            },
            "www": "https://www.bitget.com",
            "doc": []interface{}{"https://www.bitget.com/api-doc/common/intro", "https://www.bitget.com/api-doc/spot/intro", "https://www.bitget.com/api-doc/contract/intro", "https://www.bitget.com/api-doc/broker/intro", "https://www.bitget.com/api-doc/margin/intro", "https://www.bitget.com/api-doc/copytrading/intro", "https://www.bitget.com/api-doc/earn/intro", "https://bitgetlimited.github.io/apidoc/en/mix", "https://bitgetlimited.github.io/apidoc/en/spot", "https://bitgetlimited.github.io/apidoc/en/broker", "https://bitgetlimited.github.io/apidoc/en/margin"},
            "fees": "https://www.bitget.cc/zh-CN/rate?tab=1",
            "referral": "https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "common": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/public/annoucements": 1,
                        "v2/public/time": 1,
                    },
                },
                "spot": map[string]interface{} {
                    "get": map[string]interface{} {
                        "spot/v1/notice/queryAllNotices": 1,
                        "spot/v1/public/time": 1,
                        "spot/v1/public/currencies": 6.6667,
                        "spot/v1/public/products": 1,
                        "spot/v1/public/product": 1,
                        "spot/v1/market/ticker": 1,
                        "spot/v1/market/tickers": 1,
                        "spot/v1/market/fills": 2,
                        "spot/v1/market/fills-history": 2,
                        "spot/v1/market/candles": 1,
                        "spot/v1/market/depth": 1,
                        "spot/v1/market/spot-vip-level": 2,
                        "spot/v1/market/merge-depth": 1,
                        "spot/v1/market/history-candles": 1,
                        "spot/v1/public/loan/coinInfos": 2,
                        "spot/v1/public/loan/hour-interest": 2,
                        "v2/spot/public/coins": 6.6667,
                        "v2/spot/public/symbols": 1,
                        "v2/spot/market/vip-fee-rate": 2,
                        "v2/spot/market/tickers": 1,
                        "v2/spot/market/merge-depth": 1,
                        "v2/spot/market/orderbook": 1,
                        "v2/spot/market/candles": 1,
                        "v2/spot/market/history-candles": 1,
                        "v2/spot/market/fills": 2,
                        "v2/spot/market/fills-history": 2,
                    },
                },
                "mix": map[string]interface{} {
                    "get": map[string]interface{} {
                        "mix/v1/market/contracts": 1,
                        "mix/v1/market/depth": 1,
                        "mix/v1/market/ticker": 1,
                        "mix/v1/market/tickers": 1,
                        "mix/v1/market/contract-vip-level": 2,
                        "mix/v1/market/fills": 1,
                        "mix/v1/market/fills-history": 2,
                        "mix/v1/market/candles": 1,
                        "mix/v1/market/index": 1,
                        "mix/v1/market/funding-time": 1,
                        "mix/v1/market/history-fundRate": 1,
                        "mix/v1/market/current-fundRate": 1,
                        "mix/v1/market/open-interest": 1,
                        "mix/v1/market/mark-price": 1,
                        "mix/v1/market/symbol-leverage": 1,
                        "mix/v1/market/queryPositionLever": 1,
                        "mix/v1/market/open-limit": 1,
                        "mix/v1/market/history-candles": 1,
                        "mix/v1/market/history-index-candles": 1,
                        "mix/v1/market/history-mark-candles": 1,
                        "mix/v1/market/merge-depth": 1,
                        "v2/mix/market/vip-fee-rate": 2,
                        "v2/mix/market/merge-depth": 1,
                        "v2/mix/market/ticker": 1,
                        "v2/mix/market/tickers": 1,
                        "v2/mix/market/fills": 1,
                        "v2/mix/market/fills-history": 2,
                        "v2/mix/market/candles": 1,
                        "v2/mix/market/history-candles": 1,
                        "v2/mix/market/history-index-candles": 1,
                        "v2/mix/market/history-mark-candles": 1,
                        "v2/mix/market/open-interest": 1,
                        "v2/mix/market/funding-time": 1,
                        "v2/mix/market/symbol-price": 1,
                        "v2/mix/market/history-fund-rate": 1,
                        "v2/mix/market/current-fund-rate": 1,
                        "v2/mix/market/contracts": 1,
                        "v2/mix/market/query-position-lever": 2,
                        "v2/mix/market/account-long-short": 20,
                    },
                },
                "margin": map[string]interface{} {
                    "get": map[string]interface{} {
                        "margin/v1/cross/public/interestRateAndLimit": 2,
                        "margin/v1/isolated/public/interestRateAndLimit": 2,
                        "margin/v1/cross/public/tierData": 2,
                        "margin/v1/isolated/public/tierData": 2,
                        "margin/v1/public/currencies": 1,
                        "v2/margin/currencies": 2,
                        "v2/margin/market/long-short-ratio": 20,
                    },
                },
                "earn": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/earn/loan/public/coinInfos": 2,
                        "v2/earn/loan/public/hour-interest": 2,
                    },
                },
            },
            "private": map[string]interface{} {
                "spot": map[string]interface{} {
                    "get": map[string]interface{} {
                        "spot/v1/wallet/deposit-address": 4,
                        "spot/v1/wallet/withdrawal-list": 1,
                        "spot/v1/wallet/deposit-list": 1,
                        "spot/v1/account/getInfo": 20,
                        "spot/v1/account/assets": 2,
                        "spot/v1/account/assets-lite": 2,
                        "spot/v1/account/transferRecords": 1,
                        "spot/v1/convert/currencies": 2,
                        "spot/v1/convert/convert-record": 2,
                        "spot/v1/loan/ongoing-orders": 2,
                        "spot/v1/loan/repay-history": 2,
                        "spot/v1/loan/revise-history": 2,
                        "spot/v1/loan/borrow-history": 2,
                        "spot/v1/loan/debts": 2,
                        "v2/spot/trade/orderInfo": 1,
                        "v2/spot/trade/unfilled-orders": 1,
                        "v2/spot/trade/history-orders": 1,
                        "v2/spot/trade/fills": 2,
                        "v2/spot/trade/current-plan-order": 1,
                        "v2/spot/trade/history-plan-order": 1,
                        "v2/spot/account/info": 20,
                        "v2/spot/account/assets": 2,
                        "v2/spot/account/subaccount-assets": 2,
                        "v2/spot/account/bills": 2,
                        "v2/spot/account/transferRecords": 1,
                        "v2/account/funding-assets": 2,
                        "v2/account/bot-assets": 2,
                        "v2/account/all-account-balance": 20,
                        "v2/spot/wallet/deposit-address": 2,
                        "v2/spot/wallet/deposit-records": 2,
                        "v2/spot/wallet/withdrawal-records": 2,
                    },
                    "post": map[string]interface{} {
                        "spot/v1/wallet/transfer": 4,
                        "spot/v1/wallet/transfer-v2": 4,
                        "spot/v1/wallet/subTransfer": 10,
                        "spot/v1/wallet/withdrawal": 4,
                        "spot/v1/wallet/withdrawal-v2": 4,
                        "spot/v1/wallet/withdrawal-inner": 4,
                        "spot/v1/wallet/withdrawal-inner-v2": 4,
                        "spot/v1/account/sub-account-spot-assets": 200,
                        "spot/v1/account/bills": 2,
                        "spot/v1/trade/orders": 2,
                        "spot/v1/trade/batch-orders": 4,
                        "spot/v1/trade/cancel-order": 2,
                        "spot/v1/trade/cancel-order-v2": 2,
                        "spot/v1/trade/cancel-symbol-order": 2,
                        "spot/v1/trade/cancel-batch-orders": 4,
                        "spot/v1/trade/cancel-batch-orders-v2": 4,
                        "spot/v1/trade/orderInfo": 1,
                        "spot/v1/trade/open-orders": 1,
                        "spot/v1/trade/history": 1,
                        "spot/v1/trade/fills": 1,
                        "spot/v1/plan/placePlan": 1,
                        "spot/v1/plan/modifyPlan": 1,
                        "spot/v1/plan/cancelPlan": 1,
                        "spot/v1/plan/currentPlan": 1,
                        "spot/v1/plan/historyPlan": 1,
                        "spot/v1/plan/batchCancelPlan": 2,
                        "spot/v1/convert/quoted-price": 4,
                        "spot/v1/convert/trade": 4,
                        "spot/v1/loan/borrow": 2,
                        "spot/v1/loan/repay": 2,
                        "spot/v1/loan/revise-pledge": 2,
                        "spot/v1/trace/order/orderCurrentList": 2,
                        "spot/v1/trace/order/orderHistoryList": 2,
                        "spot/v1/trace/order/closeTrackingOrder": 2,
                        "spot/v1/trace/order/updateTpsl": 2,
                        "spot/v1/trace/order/followerEndOrder": 2,
                        "spot/v1/trace/order/spotInfoList": 2,
                        "spot/v1/trace/config/getTraderSettings": 2,
                        "spot/v1/trace/config/getFollowerSettings": 2,
                        "spot/v1/trace/user/myTraders": 2,
                        "spot/v1/trace/config/setFollowerConfig": 2,
                        "spot/v1/trace/user/myFollowers": 2,
                        "spot/v1/trace/config/setProductCode": 2,
                        "spot/v1/trace/user/removeTrader": 2,
                        "spot/v1/trace/getRemovableFollower": 2,
                        "spot/v1/trace/user/removeFollower": 2,
                        "spot/v1/trace/profit/totalProfitInfo": 2,
                        "spot/v1/trace/profit/totalProfitList": 2,
                        "spot/v1/trace/profit/profitHisList": 2,
                        "spot/v1/trace/profit/profitHisDetailList": 2,
                        "spot/v1/trace/profit/waitProfitDetailList": 2,
                        "spot/v1/trace/user/getTraderInfo": 2,
                        "v2/spot/trade/place-order": 2,
                        "v2/spot/trade/cancel-order": 2,
                        "v2/spot/trade/batch-orders": 20,
                        "v2/spot/trade/batch-cancel-order": 2,
                        "v2/spot/trade/cancel-symbol-order": 4,
                        "v2/spot/trade/place-plan-order": 1,
                        "v2/spot/trade/modify-plan-order": 1,
                        "v2/spot/trade/cancel-plan-order": 1,
                        "v2/spot/trade/batch-cancel-plan-order": 2,
                        "v2/spot/wallet/transfer": 2,
                        "v2/spot/wallet/subaccount-transfer": 2,
                        "v2/spot/wallet/withdrawal": 2,
                        "v2/spot/wallet/cancel-withdrawal": 2,
                        "v2/spot/wallet/modify-deposit-account": 2,
                    },
                },
                "mix": map[string]interface{} {
                    "get": map[string]interface{} {
                        "mix/v1/account/account": 2,
                        "mix/v1/account/accounts": 2,
                        "mix/v1/position/singlePosition": 2,
                        "mix/v1/position/singlePosition-v2": 2,
                        "mix/v1/position/allPosition": 4,
                        "mix/v1/position/allPosition-v2": 4,
                        "mix/v1/position/history-position": 1,
                        "mix/v1/account/accountBill": 2,
                        "mix/v1/account/accountBusinessBill": 4,
                        "mix/v1/order/current": 1,
                        "mix/v1/order/marginCoinCurrent": 1,
                        "mix/v1/order/history": 2,
                        "mix/v1/order/historyProductType": 4,
                        "mix/v1/order/detail": 2,
                        "mix/v1/order/fills": 2,
                        "mix/v1/order/allFills": 2,
                        "mix/v1/plan/currentPlan": 1,
                        "mix/v1/plan/historyPlan": 2,
                        "mix/v1/trace/currentTrack": 2,
                        "mix/v1/trace/followerOrder": 2,
                        "mix/v1/trace/followerHistoryOrders": 2,
                        "mix/v1/trace/historyTrack": 2,
                        "mix/v1/trace/summary": 1,
                        "mix/v1/trace/profitSettleTokenIdGroup": 1,
                        "mix/v1/trace/profitDateGroupList": 1,
                        "mix/v1/trade/profitDateList": 2,
                        "mix/v1/trace/waitProfitDateList": 1,
                        "mix/v1/trace/traderSymbols": 1,
                        "mix/v1/trace/traderList": 2,
                        "mix/v1/trace/traderDetail": 2,
                        "mix/v1/trace/queryTraceConfig": 2,
                        "v2/mix/account/account": 2,
                        "v2/mix/account/accounts": 2,
                        "v2/mix/account/sub-account-assets": 200,
                        "v2/mix/account/open-count": 2,
                        "v2/mix/account/bill": 2,
                        "v2/mix/market/query-position-lever": 2,
                        "v2/mix/position/single-position": 2,
                        "v2/mix/position/all-position": 4,
                        "v2/mix/position/history-position": 1,
                        "v2/mix/order/detail": 2,
                        "v2/mix/order/fills": 2,
                        "v2/mix/order/fill-history": 2,
                        "v2/mix/order/orders-pending": 2,
                        "v2/mix/order/orders-history": 2,
                        "v2/mix/order/orders-plan-pending": 2,
                        "v2/mix/order/orders-plan-history": 2,
                        "v2/mix/market/position-long-short": 20,
                    },
                    "post": map[string]interface{} {
                        "mix/v1/account/sub-account-contract-assets": 200,
                        "mix/v1/account/open-count": 1,
                        "mix/v1/account/setLeverage": 4,
                        "mix/v1/account/setMargin": 4,
                        "mix/v1/account/setMarginMode": 4,
                        "mix/v1/account/setPositionMode": 4,
                        "mix/v1/order/placeOrder": 2,
                        "mix/v1/order/batch-orders": 2,
                        "mix/v1/order/cancel-order": 2,
                        "mix/v1/order/cancel-batch-orders": 2,
                        "mix/v1/order/modifyOrder": 2,
                        "mix/v1/order/cancel-symbol-orders": 2,
                        "mix/v1/order/cancel-all-orders": 2,
                        "mix/v1/order/close-all-positions": 20,
                        "mix/v1/plan/placePlan": 2,
                        "mix/v1/plan/modifyPlan": 2,
                        "mix/v1/plan/modifyPlanPreset": 2,
                        "mix/v1/plan/placeTPSL": 2,
                        "mix/v1/plan/placeTrailStop": 2,
                        "mix/v1/plan/placePositionsTPSL": 2,
                        "mix/v1/plan/modifyTPSLPlan": 2,
                        "mix/v1/plan/cancelPlan": 2,
                        "mix/v1/plan/cancelSymbolPlan": 2,
                        "mix/v1/plan/cancelAllPlan": 2,
                        "mix/v1/trace/closeTrackOrder": 2,
                        "mix/v1/trace/modifyTPSL": 2,
                        "mix/v1/trace/closeTrackOrderBySymbol": 2,
                        "mix/v1/trace/setUpCopySymbols": 2,
                        "mix/v1/trace/followerSetBatchTraceConfig": 2,
                        "mix/v1/trace/followerCloseByTrackingNo": 2,
                        "mix/v1/trace/followerCloseByAll": 2,
                        "mix/v1/trace/followerSetTpsl": 2,
                        "mix/v1/trace/cancelCopyTrader": 4,
                        "mix/v1/trace/traderUpdateConfig": 2,
                        "mix/v1/trace/myTraderList": 2,
                        "mix/v1/trace/myFollowerList": 2,
                        "mix/v1/trace/removeFollower": 2,
                        "mix/v1/trace/public/getFollowerConfig": 2,
                        "mix/v1/trace/report/order/historyList": 2,
                        "mix/v1/trace/report/order/currentList": 2,
                        "mix/v1/trace/queryTraderTpslRatioConfig": 2,
                        "mix/v1/trace/traderUpdateTpslRatioConfig": 2,
                        "v2/mix/account/set-leverage": 4,
                        "v2/mix/account/set-margin": 4,
                        "v2/mix/account/set-margin-mode": 4,
                        "v2/mix/account/set-position-mode": 4,
                        "v2/mix/order/place-order": 2,
                        "v2/mix/order/click-backhand": 20,
                        "v2/mix/order/batch-place-order": 20,
                        "v2/mix/order/modify-order": 2,
                        "v2/mix/order/cancel-order": 2,
                        "v2/mix/order/batch-cancel-orders": 2,
                        "v2/mix/order/close-positions": 20,
                        "v2/mix/order/place-tpsl-order": 2,
                        "v2/mix/order/place-plan-order": 2,
                        "v2/mix/order/modify-tpsl-order": 2,
                        "v2/mix/order/modify-plan-order": 2,
                        "v2/mix/order/cancel-plan-order": 2,
                    },
                },
                "user": map[string]interface{} {
                    "get": map[string]interface{} {
                        "user/v1/fee/query": 2,
                        "user/v1/sub/virtual-list": 2,
                        "user/v1/sub/virtual-api-list": 2,
                        "user/v1/tax/spot-record": 1,
                        "user/v1/tax/future-record": 1,
                        "user/v1/tax/margin-record": 1,
                        "user/v1/tax/p2p-record": 1,
                        "v2/user/virtual-subaccount-list": 2,
                        "v2/user/virtual-subaccount-apikey-list": 2,
                    },
                    "post": map[string]interface{} {
                        "user/v1/sub/virtual-create": 4,
                        "user/v1/sub/virtual-modify": 4,
                        "user/v1/sub/virtual-api-batch-create": 20,
                        "user/v1/sub/virtual-api-create": 4,
                        "user/v1/sub/virtual-api-modify": 4,
                        "v2/user/create-virtual-subaccount": 4,
                        "v2/user/modify-virtual-subaccount": 4,
                        "v2/user/batch-create-subaccount-and-apikey": 20,
                        "v2/user/create-virtual-subaccount-apikey": 4,
                        "v2/user/modify-virtual-subaccount-apikey": 4,
                    },
                },
                "p2p": map[string]interface{} {
                    "get": map[string]interface{} {
                        "p2p/v1/merchant/merchantList": 2,
                        "p2p/v1/merchant/merchantInfo": 2,
                        "p2p/v1/merchant/advList": 2,
                        "p2p/v1/merchant/orderList": 2,
                        "v2/p2p/merchantList": 2,
                        "v2/p2p/merchantInfo": 2,
                        "v2/p2p/orderList": 2,
                        "v2/p2p/advList": 2,
                    },
                },
                "broker": map[string]interface{} {
                    "get": map[string]interface{} {
                        "broker/v1/account/info": 2,
                        "broker/v1/account/sub-list": 20,
                        "broker/v1/account/sub-email": 20,
                        "broker/v1/account/sub-spot-assets": 2,
                        "broker/v1/account/sub-future-assets": 2,
                        "broker/v1/account/subaccount-transfer": 1,
                        "broker/v1/account/subaccount-deposit": 1,
                        "broker/v1/account/subaccount-withdrawal": 1,
                        "broker/v1/account/sub-api-list": 2,
                        "v2/broker/account/info": 2,
                        "v2/broker/account/subaccount-list": 20,
                        "v2/broker/account/subaccount-email": 2,
                        "v2/broker/account/subaccount-spot-assets": 2,
                        "v2/broker/account/subaccount-future-assets": 2,
                        "v2/broker/manage/subaccount-apikey-list": 2,
                    },
                    "post": map[string]interface{} {
                        "broker/v1/account/sub-create": 20,
                        "broker/v1/account/sub-modify": 20,
                        "broker/v1/account/sub-modify-email": 20,
                        "broker/v1/account/sub-address": 2,
                        "broker/v1/account/sub-withdrawal": 2,
                        "broker/v1/account/sub-auto-transfer": 4,
                        "broker/v1/account/sub-api-create": 2,
                        "broker/v1/account/sub-api-modify": 2,
                        "v2/broker/account/modify-subaccount-email": 2,
                        "v2/broker/account/create-subaccount": 20,
                        "v2/broker/account/modify-subaccount": 20,
                        "v2/broker/account/subaccount-address": 2,
                        "v2/broker/account/subaccount-withdrawal": 2,
                        "v2/broker/account/set-subaccount-autotransfer": 2,
                        "v2/broker/manage/create-subaccount-apikey": 2,
                        "v2/broker/manage/modify-subaccount-apikey": 2,
                    },
                },
                "margin": map[string]interface{} {
                    "get": map[string]interface{} {
                        "margin/v1/cross/account/riskRate": 2,
                        "margin/v1/cross/account/maxTransferOutAmount": 2,
                        "margin/v1/isolated/account/maxTransferOutAmount": 2,
                        "margin/v1/isolated/order/openOrders": 2,
                        "margin/v1/isolated/order/history": 2,
                        "margin/v1/isolated/order/fills": 2,
                        "margin/v1/isolated/loan/list": 2,
                        "margin/v1/isolated/repay/list": 2,
                        "margin/v1/isolated/interest/list": 2,
                        "margin/v1/isolated/liquidation/list": 2,
                        "margin/v1/isolated/fin/list": 2,
                        "margin/v1/cross/order/openOrders": 2,
                        "margin/v1/cross/order/history": 2,
                        "margin/v1/cross/order/fills": 2,
                        "margin/v1/cross/loan/list": 2,
                        "margin/v1/cross/repay/list": 2,
                        "margin/v1/cross/interest/list": 2,
                        "margin/v1/cross/liquidation/list": 2,
                        "margin/v1/cross/fin/list": 2,
                        "margin/v1/cross/account/assets": 2,
                        "margin/v1/isolated/account/assets": 2,
                        "v2/margin/crossed/borrow-history": 2,
                        "v2/margin/crossed/repay-history": 2,
                        "v2/margin/crossed/interest-history": 2,
                        "v2/margin/crossed/liquidation-history": 2,
                        "v2/margin/crossed/financial-records": 2,
                        "v2/margin/crossed/account/assets": 2,
                        "v2/margin/crossed/account/risk-rate": 2,
                        "v2/margin/crossed/account/max-borrowable-amount": 2,
                        "v2/margin/crossed/account/max-transfer-out-amount": 2,
                        "v2/margin/crossed/interest-rate-and-limit": 2,
                        "v2/margin/crossed/tier-data": 2,
                        "v2/margin/crossed/open-orders": 2,
                        "v2/margin/crossed/history-orders": 2,
                        "v2/margin/crossed/fills": 2,
                        "v2/margin/isolated/borrow-history": 2,
                        "v2/margin/isolated/repay-history": 2,
                        "v2/margin/isolated/interest-history": 2,
                        "v2/margin/isolated/liquidation-history": 2,
                        "v2/margin/isolated/financial-records": 2,
                        "v2/margin/isolated/account/assets": 2,
                        "v2/margin/isolated/account/risk-rate": 2,
                        "v2/margin/isolated/account/max-borrowable-amount": 2,
                        "v2/margin/isolated/account/max-transfer-out-amount": 2,
                        "v2/margin/isolated/interest-rate-and-limit": 2,
                        "v2/margin/isolated/tier-data": 2,
                        "v2/margin/isolated/open-orders": 2,
                        "v2/margin/isolated/history-orders": 2,
                        "v2/margin/isolated/fills": 2,
                    },
                    "post": map[string]interface{} {
                        "margin/v1/cross/account/borrow": 2,
                        "margin/v1/isolated/account/borrow": 2,
                        "margin/v1/cross/account/repay": 2,
                        "margin/v1/isolated/account/repay": 2,
                        "margin/v1/isolated/account/riskRate": 2,
                        "margin/v1/cross/account/maxBorrowableAmount": 2,
                        "margin/v1/isolated/account/maxBorrowableAmount": 2,
                        "margin/v1/isolated/account/flashRepay": 2,
                        "margin/v1/isolated/account/queryFlashRepayStatus": 2,
                        "margin/v1/cross/account/flashRepay": 2,
                        "margin/v1/cross/account/queryFlashRepayStatus": 2,
                        "margin/v1/isolated/order/placeOrder": 4,
                        "margin/v1/isolated/order/batchPlaceOrder": 4,
                        "margin/v1/isolated/order/cancelOrder": 2,
                        "margin/v1/isolated/order/batchCancelOrder": 2,
                        "margin/v1/cross/order/placeOrder": 2,
                        "margin/v1/cross/order/batchPlaceOrder": 2,
                        "margin/v1/cross/order/cancelOrder": 2,
                        "margin/v1/cross/order/batchCancelOrder": 2,
                        "v2/margin/crossed/account/borrow": 2,
                        "v2/margin/crossed/account/repay": 2,
                        "v2/margin/crossed/account/flash-repay": 2,
                        "v2/margin/crossed/account/query-flash-repay-status": 2,
                        "v2/margin/crossed/place-order": 2,
                        "v2/margin/crossed/batch-place-order": 2,
                        "v2/margin/crossed/cancel-order": 2,
                        "v2/margin/crossed/batch-cancel-order": 2,
                        "v2/margin/isolated/account/borrow": 2,
                        "v2/margin/isolated/account/repay": 2,
                        "v2/margin/isolated/account/flash-repay": 2,
                        "v2/margin/isolated/account/query-flash-repay-status": 2,
                        "v2/margin/isolated/place-order": 2,
                        "v2/margin/isolated/batch-place-order": 2,
                        "v2/margin/isolated/cancel-order": 2,
                        "v2/margin/isolated/batch-cancel-order": 2,
                    },
                },
                "copy": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/copy/mix-trader/order-current-track": 2,
                        "v2/copy/mix-trader/order-history-track": 2,
                        "v2/copy/mix-trader/order-total-detail": 2,
                        "v2/copy/mix-trader/profit-history-summarys": 1,
                        "v2/copy/mix-trader/profit-history-details": 1,
                        "v2/copy/mix-trader/profit-details": 1,
                        "v2/copy/mix-trader/profits-group-coin-date": 1,
                        "v2/copy/mix-trader/config-query-symbols": 1,
                        "v2/copy/mix-trader/config-query-followers": 2,
                        "v2/copy/mix-follower/query-current-orders": 2,
                        "v2/copy/mix-follower/query-history-orders": 1,
                        "v2/copy/mix-follower/query-settings": 2,
                        "v2/copy/mix-follower/query-traders": 2,
                        "v2/copy/mix-follower/query-quantity-limit": 2,
                        "v2/copy/mix-broker/query-traders": 2,
                        "v2/copy/mix-broker/query-history-traces": 2,
                        "v2/copy/mix-broker/query-current-traces": 2,
                        "v2/copy/spot-trader/profit-summarys": 2,
                        "v2/copy/spot-trader/profit-history-details": 2,
                        "v2/copy/spot-trader/profit-details": 2,
                        "v2/copy/spot-trader/order-total-detail": 2,
                        "v2/copy/spot-trader/order-history-track": 2,
                        "v2/copy/spot-trader/order-current-track": 2,
                        "v2/copy/spot-trader/config-query-settings": 2,
                        "v2/copy/spot-trader/config-query-followers": 2,
                        "v2/copy/spot-follower/query-traders": 2,
                        "v2/copy/spot-follower/query-trader-symbols": 2,
                        "v2/copy/spot-follower/query-settings": 2,
                        "v2/copy/spot-follower/query-history-orders": 2,
                        "v2/copy/spot-follower/query-current-orders": 2,
                    },
                    "post": map[string]interface{} {
                        "v2/copy/mix-trader/order-modify-tpsl": 2,
                        "v2/copy/mix-trader/order-close-positions": 2,
                        "v2/copy/mix-trader/config-setting-symbols": 2,
                        "v2/copy/mix-trader/config-setting-base": 2,
                        "v2/copy/mix-trader/config-remove-follower": 2,
                        "v2/copy/mix-follower/setting-tpsl": 1,
                        "v2/copy/mix-follower/settings": 2,
                        "v2/copy/mix-follower/close-positions": 2,
                        "v2/copy/mix-follower/cancel-trader": 4,
                        "v2/copy/spot-trader/order-modify-tpsl": 2,
                        "v2/copy/spot-trader/order-close-tracking": 2,
                        "v2/copy/spot-trader/config-setting-symbols": 2,
                        "v2/copy/spot-trader/config-remove-follower": 2,
                        "v2/copy/spot-follower/stop-order": 2,
                        "v2/copy/spot-follower/settings": 2,
                        "v2/copy/spot-follower/setting-tpsl": 2,
                        "v2/copy/spot-follower/order-close-tracking": 2,
                        "v2/copy/spot-follower/cancel-trader": 2,
                    },
                },
                "tax": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/tax/spot-record": 20,
                        "v2/tax/future-record": 20,
                        "v2/tax/margin-record": 20,
                        "v2/tax/p2p-record": 20,
                    },
                },
                "convert": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/convert/currencies": 2,
                        "v2/convert/quoted-price": 2,
                        "v2/convert/convert-record": 2,
                        "v2/convert/bgb-convert-coin-list": 2,
                        "v2/convert/bgb-convert-records": 2,
                    },
                    "post": map[string]interface{} {
                        "v2/convert/trade": 2,
                        "v2/convert/bgb-convert": 2,
                    },
                },
                "earn": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/earn/savings/product": 2,
                        "v2/earn/savings/account": 2,
                        "v2/earn/savings/assets": 2,
                        "v2/earn/savings/records": 2,
                        "v2/earn/savings/subscribe-info": 2,
                        "v2/earn/savings/subscribe-result": 2,
                        "v2/earn/savings/redeem-result": 2,
                        "v2/earn/sharkfin/product": 2,
                        "v2/earn/sharkfin/account": 2,
                        "v2/earn/sharkfin/assets": 2,
                        "v2/earn/sharkfin/records": 2,
                        "v2/earn/sharkfin/subscribe-info": 2,
                        "v2/earn/sharkfin/subscribe-result": 4,
                        "v2/earn/loan/ongoing-orders": 2,
                        "v2/earn/loan/repay-history": 2,
                        "v2/earn/loan/revise-history": 2,
                        "v2/earn/loan/borrow-history": 2,
                        "v2/earn/loan/debts": 2,
                        "v2/earn/loan/reduces": 2,
                        "v2/earn/account/assets": 2,
                    },
                    "post": map[string]interface{} {
                        "v2/earn/savings/subscribe": 2,
                        "v2/earn/savings/redeem": 2,
                        "v2/earn/sharkfin/subscribe": 2,
                        "v2/earn/loan/borrow": 2,
                        "v2/earn/loan/repay": 2,
                        "v2/earn/loan/revise-pledge": 2,
                    },
                },
                "common": map[string]interface{} {
                    "get": map[string]interface{} {
                        "v2/common/trade-rate": 2,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "spot": map[string]interface{} {
                "taker": this.ParseNumber("0.002"),
                "maker": this.ParseNumber("0.002"),
            },
            "swap": map[string]interface{} {
                "taker": this.ParseNumber("0.0006"),
                "maker": this.ParseNumber("0.0004"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "1": ExchangeError,
                "failure to get a peer from the ring-balancer": ExchangeNotAvailable,
                "4010": PermissionDenied,
                "4001": ExchangeError,
                "4002": ExchangeError,
                "30001": AuthenticationError,
                "30002": AuthenticationError,
                "30003": AuthenticationError,
                "30004": AuthenticationError,
                "30005": InvalidNonce,
                "30006": AuthenticationError,
                "30007": BadRequest,
                "30008": RequestTimeout,
                "30009": ExchangeError,
                "30010": AuthenticationError,
                "30011": PermissionDenied,
                "30012": AuthenticationError,
                "30013": AuthenticationError,
                "30014": DDoSProtection,
                "30015": AuthenticationError,
                "30016": ExchangeError,
                "30017": ExchangeError,
                "30018": ExchangeError,
                "30019": ExchangeNotAvailable,
                "30020": BadRequest,
                "30021": BadRequest,
                "30022": PermissionDenied,
                "30023": BadRequest,
                "30024": BadSymbol,
                "30025": BadRequest,
                "30026": DDoSProtection,
                "30027": AuthenticationError,
                "30028": PermissionDenied,
                "30029": AccountSuspended,
                "30030": ExchangeError,
                "30031": BadRequest,
                "30032": BadSymbol,
                "30033": BadRequest,
                "30034": ExchangeError,
                "30035": ExchangeError,
                "30036": ExchangeError,
                "30037": ExchangeNotAvailable,
                "30038": OnMaintenance,
                "32001": AccountSuspended,
                "32002": PermissionDenied,
                "32003": CancelPending,
                "32004": ExchangeError,
                "32005": InvalidOrder,
                "32006": InvalidOrder,
                "32007": InvalidOrder,
                "32008": InvalidOrder,
                "32009": InvalidOrder,
                "32010": ExchangeError,
                "32011": ExchangeError,
                "32012": ExchangeError,
                "32013": ExchangeError,
                "32014": ExchangeError,
                "32015": ExchangeError,
                "32016": ExchangeError,
                "32017": ExchangeError,
                "32018": ExchangeError,
                "32019": ExchangeError,
                "32020": ExchangeError,
                "32021": ExchangeError,
                "32022": ExchangeError,
                "32023": ExchangeError,
                "32024": ExchangeError,
                "32025": ExchangeError,
                "32026": ExchangeError,
                "32027": ExchangeError,
                "32028": AccountSuspended,
                "32029": ExchangeError,
                "32030": InvalidOrder,
                "32031": ArgumentsRequired,
                "32038": AuthenticationError,
                "32040": ExchangeError,
                "32044": ExchangeError,
                "32045": ExchangeError,
                "32046": ExchangeError,
                "32047": ExchangeError,
                "32048": InvalidOrder,
                "32049": ExchangeError,
                "32050": InvalidOrder,
                "32051": InvalidOrder,
                "32052": ExchangeError,
                "32053": ExchangeError,
                "32057": ExchangeError,
                "32054": ExchangeError,
                "32055": InvalidOrder,
                "32056": ExchangeError,
                "32058": ExchangeError,
                "32059": InvalidOrder,
                "32060": InvalidOrder,
                "32061": InvalidOrder,
                "32062": InvalidOrder,
                "32063": InvalidOrder,
                "32064": ExchangeError,
                "32065": ExchangeError,
                "32066": ExchangeError,
                "32067": ExchangeError,
                "32068": ExchangeError,
                "32069": ExchangeError,
                "32070": ExchangeError,
                "32071": ExchangeError,
                "32072": ExchangeError,
                "32073": ExchangeError,
                "32074": ExchangeError,
                "32075": ExchangeError,
                "32076": ExchangeError,
                "32077": ExchangeError,
                "32078": ExchangeError,
                "32079": ExchangeError,
                "32080": ExchangeError,
                "32083": ExchangeError,
                "33001": PermissionDenied,
                "33002": AccountSuspended,
                "33003": InsufficientFunds,
                "33004": ExchangeError,
                "33005": ExchangeError,
                "33006": ExchangeError,
                "33007": ExchangeError,
                "33008": InsufficientFunds,
                "33009": ExchangeError,
                "33010": ExchangeError,
                "33011": ExchangeError,
                "33012": ExchangeError,
                "33013": InvalidOrder,
                "33014": OrderNotFound,
                "33015": InvalidOrder,
                "33016": ExchangeError,
                "33017": InsufficientFunds,
                "33018": ExchangeError,
                "33020": ExchangeError,
                "33021": BadRequest,
                "33022": InvalidOrder,
                "33023": ExchangeError,
                "33024": InvalidOrder,
                "33025": InvalidOrder,
                "33026": ExchangeError,
                "33027": InvalidOrder,
                "33028": InvalidOrder,
                "33029": InvalidOrder,
                "33034": ExchangeError,
                "33035": ExchangeError,
                "33036": ExchangeError,
                "33037": ExchangeError,
                "33038": ExchangeError,
                "33039": ExchangeError,
                "33040": ExchangeError,
                "33041": ExchangeError,
                "33042": ExchangeError,
                "33043": ExchangeError,
                "33044": ExchangeError,
                "33045": ExchangeError,
                "33046": ExchangeError,
                "33047": ExchangeError,
                "33048": ExchangeError,
                "33049": ExchangeError,
                "33050": ExchangeError,
                "33051": ExchangeError,
                "33059": BadRequest,
                "33060": BadRequest,
                "33061": ExchangeError,
                "33062": ExchangeError,
                "33063": ExchangeError,
                "33064": ExchangeError,
                "33065": ExchangeError,
                "21009": ExchangeError,
                "34001": PermissionDenied,
                "34002": InvalidAddress,
                "34003": ExchangeError,
                "34004": ExchangeError,
                "34005": ExchangeError,
                "34006": ExchangeError,
                "34007": ExchangeError,
                "34008": InsufficientFunds,
                "34009": ExchangeError,
                "34010": ExchangeError,
                "34011": ExchangeError,
                "34012": ExchangeError,
                "34013": ExchangeError,
                "34014": ExchangeError,
                "34015": ExchangeError,
                "34016": PermissionDenied,
                "34017": AccountSuspended,
                "34018": AuthenticationError,
                "34019": PermissionDenied,
                "34020": PermissionDenied,
                "34021": InvalidAddress,
                "34022": ExchangeError,
                "34023": PermissionDenied,
                "34026": ExchangeError,
                "34036": ExchangeError,
                "34037": ExchangeError,
                "34038": ExchangeError,
                "34039": ExchangeError,
                "35001": ExchangeError,
                "35002": ExchangeError,
                "35003": ExchangeError,
                "35004": ExchangeError,
                "35005": AuthenticationError,
                "35008": InvalidOrder,
                "35010": InvalidOrder,
                "35012": InvalidOrder,
                "35014": InvalidOrder,
                "35015": InvalidOrder,
                "35017": ExchangeError,
                "35019": InvalidOrder,
                "35020": InvalidOrder,
                "35021": InvalidOrder,
                "35022": ExchangeError,
                "35024": ExchangeError,
                "35025": InsufficientFunds,
                "35026": ExchangeError,
                "35029": OrderNotFound,
                "35030": InvalidOrder,
                "35031": InvalidOrder,
                "35032": ExchangeError,
                "35037": ExchangeError,
                "35039": ExchangeError,
                "35040": InvalidOrder,
                "35044": ExchangeError,
                "35046": InsufficientFunds,
                "35047": InsufficientFunds,
                "35048": ExchangeError,
                "35049": InvalidOrder,
                "35050": InvalidOrder,
                "35052": InsufficientFunds,
                "35053": ExchangeError,
                "35055": InsufficientFunds,
                "35057": ExchangeError,
                "35058": ExchangeError,
                "35059": BadRequest,
                "35060": BadRequest,
                "35061": BadRequest,
                "35062": InvalidOrder,
                "35063": InvalidOrder,
                "35064": InvalidOrder,
                "35066": InvalidOrder,
                "35067": InvalidOrder,
                "35068": InvalidOrder,
                "35069": InvalidOrder,
                "35070": InvalidOrder,
                "35071": InvalidOrder,
                "35072": InvalidOrder,
                "35073": InvalidOrder,
                "35074": InvalidOrder,
                "35075": InvalidOrder,
                "35076": InvalidOrder,
                "35077": InvalidOrder,
                "35078": InvalidOrder,
                "35079": InvalidOrder,
                "35080": InvalidOrder,
                "35081": InvalidOrder,
                "35082": InvalidOrder,
                "35083": InvalidOrder,
                "35084": InvalidOrder,
                "35085": InvalidOrder,
                "35086": InvalidOrder,
                "35087": InvalidOrder,
                "35088": InvalidOrder,
                "35089": InvalidOrder,
                "35090": ExchangeError,
                "35091": ExchangeError,
                "35092": ExchangeError,
                "35093": ExchangeError,
                "35094": ExchangeError,
                "35095": BadRequest,
                "35096": ExchangeError,
                "35097": ExchangeError,
                "35098": ExchangeError,
                "35099": ExchangeError,
                "36001": BadRequest,
                "36002": BadRequest,
                "36005": ExchangeError,
                "36101": AuthenticationError,
                "36102": PermissionDenied,
                "36103": AccountSuspended,
                "36104": PermissionDenied,
                "36105": PermissionDenied,
                "36106": AccountSuspended,
                "36107": PermissionDenied,
                "36108": InsufficientFunds,
                "36109": PermissionDenied,
                "36201": PermissionDenied,
                "36202": PermissionDenied,
                "36203": InvalidOrder,
                "36204": ExchangeError,
                "36205": BadRequest,
                "36206": BadRequest,
                "36207": InvalidOrder,
                "36208": InvalidOrder,
                "36209": InvalidOrder,
                "36210": InvalidOrder,
                "36211": InvalidOrder,
                "36212": InvalidOrder,
                "36213": InvalidOrder,
                "36214": ExchangeError,
                "36216": OrderNotFound,
                "36217": InvalidOrder,
                "36218": InvalidOrder,
                "36219": InvalidOrder,
                "36220": InvalidOrder,
                "36221": InvalidOrder,
                "36222": InvalidOrder,
                "36223": InvalidOrder,
                "36224": InvalidOrder,
                "36225": InvalidOrder,
                "36226": InvalidOrder,
                "36227": InvalidOrder,
                "36228": InvalidOrder,
                "36229": InvalidOrder,
                "36230": InvalidOrder,
                "400": BadRequest,
                "401": AuthenticationError,
                "403": PermissionDenied,
                "404": BadRequest,
                "405": BadRequest,
                "415": BadRequest,
                "429": DDoSProtection,
                "500": ExchangeNotAvailable,
                "1001": RateLimitExceeded,
                "1002": ExchangeError,
                "1003": ExchangeError,
                "40001": AuthenticationError,
                "40002": AuthenticationError,
                "40003": AuthenticationError,
                "40004": InvalidNonce,
                "40005": InvalidNonce,
                "40006": AuthenticationError,
                "40007": BadRequest,
                "40008": InvalidNonce,
                "40009": AuthenticationError,
                "40010": AuthenticationError,
                "40011": AuthenticationError,
                "40012": AuthenticationError,
                "40013": ExchangeError,
                "40014": PermissionDenied,
                "40015": ExchangeError,
                "40016": PermissionDenied,
                "40017": ExchangeError,
                "40018": PermissionDenied,
                "40019": BadRequest,
                "40031": AccountSuspended,
                "40037": AuthenticationError,
                "40102": BadRequest,
                "40103": BadRequest,
                "40104": ExchangeError,
                "40105": ExchangeError,
                "40106": ExchangeError,
                "40107": ExchangeError,
                "40108": InvalidOrder,
                "40109": OrderNotFound,
                "40200": OnMaintenance,
                "40201": InvalidOrder,
                "40202": ExchangeError,
                "40203": BadRequest,
                "40204": BadRequest,
                "40205": BadRequest,
                "40206": BadRequest,
                "40207": BadRequest,
                "40208": BadRequest,
                "40209": BadRequest,
                "40300": ExchangeError,
                "40301": PermissionDenied,
                "40302": BadRequest,
                "40303": BadRequest,
                "40304": BadRequest,
                "40305": BadRequest,
                "40306": ExchangeError,
                "40308": OnMaintenance,
                "40309": BadSymbol,
                "40400": ExchangeError,
                "40401": ExchangeError,
                "40402": BadRequest,
                "40403": BadRequest,
                "40404": BadRequest,
                "40405": BadRequest,
                "40406": BadRequest,
                "40407": ExchangeError,
                "40408": ExchangeError,
                "40409": ExchangeError,
                "40500": InvalidOrder,
                "40501": ExchangeError,
                "40502": ExchangeError,
                "40503": ExchangeError,
                "40504": ExchangeError,
                "40505": ExchangeError,
                "40506": AuthenticationError,
                "40507": AuthenticationError,
                "40508": ExchangeError,
                "40509": ExchangeError,
                "40600": ExchangeError,
                "40601": ExchangeError,
                "40602": ExchangeError,
                "40603": ExchangeError,
                "40604": ExchangeNotAvailable,
                "40605": ExchangeError,
                "40606": ExchangeError,
                "40607": ExchangeError,
                "40608": ExchangeError,
                "40609": ExchangeError,
                "40700": BadRequest,
                "40701": ExchangeError,
                "40702": ExchangeError,
                "40703": ExchangeError,
                "40704": ExchangeError,
                "40705": BadRequest,
                "40706": InvalidOrder,
                "40707": BadRequest,
                "40708": BadRequest,
                "40709": ExchangeError,
                "40710": ExchangeError,
                "40711": InsufficientFunds,
                "40712": InsufficientFunds,
                "40713": ExchangeError,
                "40714": ExchangeError,
                "40762": InsufficientFunds,
                "40768": OrderNotFound,
                "40808": InvalidOrder,
                "41103": InvalidOrder,
                "41114": OnMaintenance,
                "43011": InvalidOrder,
                "43001": OrderNotFound,
                "43012": InsufficientFunds,
                "43025": InvalidOrder,
                "43115": OnMaintenance,
                "45110": InvalidOrder,
                "invalid sign": AuthenticationError,
                "invalid currency": BadSymbol,
                "invalid symbol": BadSymbol,
                "invalid period": BadRequest,
                "invalid user": ExchangeError,
                "invalid amount": InvalidOrder,
                "invalid type": InvalidOrder,
                "invalid orderId": InvalidOrder,
                "invalid record": ExchangeError,
                "invalid accountId": BadRequest,
                "invalid address": BadRequest,
                "accesskey not null": AuthenticationError,
                "illegal accesskey": AuthenticationError,
                "sign not null": AuthenticationError,
                "req_time is too much difference from server time": InvalidNonce,
                "permissions not right": PermissionDenied,
                "illegal sign invalid": AuthenticationError,
                "user locked": AccountSuspended,
                "Request Frequency Is Too High": RateLimitExceeded,
                "more than a daily rate of cash": BadRequest,
                "more than the maximum daily withdrawal amount": BadRequest,
                "need to bind email or mobile": ExchangeError,
                "user forbid": PermissionDenied,
                "User Prohibited Cash Withdrawal": PermissionDenied,
                "Cash Withdrawal Is Less Than The Minimum Value": BadRequest,
                "Cash Withdrawal Is More Than The Maximum Value": BadRequest,
                "the account with in 24 hours ban coin": PermissionDenied,
                "order cancel fail": BadRequest,
                "base symbol error": BadSymbol,
                "base date error": ExchangeError,
                "api signature not valid": AuthenticationError,
                "gateway internal error": ExchangeError,
                "audit failed": ExchangeError,
                "order queryorder invalid": BadRequest,
                "market no need price": InvalidOrder,
                "limit need price": InvalidOrder,
                "userid not equal to account_id": ExchangeError,
                "your balance is low": InsufficientFunds,
                "address invalid cointype": ExchangeError,
                "system exception": ExchangeError,
                "50003": ExchangeError,
                "50004": BadSymbol,
                "50006": PermissionDenied,
                "50007": PermissionDenied,
                "50008": RequestTimeout,
                "50009": RateLimitExceeded,
                "50010": ExchangeError,
                "50014": InvalidOrder,
                "50015": InvalidOrder,
                "50016": InvalidOrder,
                "50017": InvalidOrder,
                "50018": InvalidOrder,
                "50019": InvalidOrder,
                "50020": InsufficientFunds,
                "50021": InvalidOrder,
                "50026": InvalidOrder,
                "invalid order query time": ExchangeError,
                "invalid start time": BadRequest,
                "invalid end time": BadRequest,
                "20003": ExchangeError,
                "01001": ExchangeError,
                "43111": PermissionDenied,
            },
            "broad": map[string]interface{} {
                "invalid size, valid range": ExchangeError,
            },
        },
        "precisionMode": TICK_SIZE,
        "commonCurrencies": map[string]interface{} {
            "APX": "AstroPepeX",
            "DEGEN": "DegenReborn",
            "JADE": "Jade Protocol",
            "OMNI": "omni",
            "TONCOIN": "TON",
        },
        "options": map[string]interface{} {
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "timeframes": map[string]interface{} {
                "spot": map[string]interface{} {
                    "1m": "1min",
                    "5m": "5min",
                    "15m": "15min",
                    "30m": "30min",
                    "1h": "1h",
                    "4h": "4h",
                    "6h": "6Hutc",
                    "12h": "12Hutc",
                    "1d": "1Dutc",
                    "3d": "3Dutc",
                    "1w": "1Wutc",
                    "1M": "1Mutc",
                },
                "swap": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "1H",
                    "2h": "2H",
                    "4h": "4H",
                    "6h": "6Hutc",
                    "12h": "12Hutc",
                    "1d": "1Dutc",
                    "3d": "3Dutc",
                    "1w": "1Wutc",
                    "1M": "1Mutc",
                },
            },
            "fetchMarkets": []interface{}{"spot", "swap"},
            "defaultType": "spot",
            "defaultSubType": "linear",
            "createMarketBuyOrderRequiresPrice": true,
            "broker": "p4sve",
            "withdraw": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "fetchOHLCV": map[string]interface{} {
                "spot": map[string]interface{} {
                    "method": "publicSpotGetV2SpotMarketCandles",
                },
                "swap": map[string]interface{} {
                    "method": "publicMixGetV2MixMarketCandles",
                },
                "maxDaysPerTimeframe": map[string]interface{} {
                    "1m": 30,
                    "3m": 30,
                    "5m": 30,
                    "10m": 30,
                    "15m": 52,
                    "30m": 62,
                    "1h": 83,
                    "2h": 120,
                    "4h": 240,
                    "6h": 360,
                    "12h": 360,
                    "1d": 300,
                    "3d": 300,
                    "1w": 300,
                    "1M": 300,
                },
            },
            "fetchTrades": map[string]interface{} {
                "spot": map[string]interface{} {
                    "method": "publicSpotGetV2SpotMarketFillsHistory",
                },
                "swap": map[string]interface{} {
                    "method": "publicMixGetV2MixMarketFillsHistory",
                },
            },
            "accountsByType": map[string]interface{} {
                "spot": "spot",
                "cross": "crossed_margin",
                "isolated": "isolated_margin",
                "swap": "usdt_futures",
                "usdc_swap": "usdc_futures",
                "future": "coin_futures",
                "p2p": "p2p",
            },
            "accountsById": map[string]interface{} {
                "spot": "spot",
                "crossed_margin": "cross",
                "isolated_margin": "isolated",
                "usdt_futures": "swap",
                "usdc_futures": "usdc_swap",
                "coin_futures": "future",
                "p2p": "p2p",
            },
            "sandboxMode": false,
            "networks": map[string]interface{} {
                "TRC20": "TRC20",
                "ERC20": "ERC20",
                "BEP20": "BSC",
                "BSC": "BEP20",
                "ATOM": "ATOM",
                "ACA": "AcalaToken",
                "APT": "Aptos",
                "ARBONE": "ArbitrumOne",
                "ARBNOVA": "ArbitrumNova",
                "AVAXC": "C-Chain",
                "AVAXX": "X-Chain",
                "AR": "Arweave",
                "BCH": "BCH",
                "BCHA": "BCHA",
                "BITCI": "BITCI",
                "BTC": "BTC",
                "CELO": "CELO",
                "CSPR": "CSPR",
                "ADA": "Cardano",
                "CHZ": "ChilizChain",
                "CRC20": "CronosChain",
                "DOGE": "DOGE",
                "DOT": "DOT",
                "EOS": "EOS",
                "ETHF": "ETHFAIR",
                "ETHW": "ETHW",
                "ETC": "ETC",
                "EGLD": "Elrond",
                "FIL": "FIL",
                "FIO": "FIO",
                "FTM": "Fantom",
                "HRC20": "HECO",
                "ONE": "Harmony",
                "HNT": "Helium",
                "ICP": "ICP",
                "IOTX": "IoTeX",
                "KARDIA": "KAI",
                "KAVA": "KAVA",
                "KDA": "KDA",
                "KLAY": "Klaytn",
                "KSM": "Kusama",
                "LAT": "LAT",
                "LTC": "LTC",
                "MINA": "MINA",
                "MOVR": "MOVR",
                "METIS": "MetisToken",
                "GLMR": "Moonbeam",
                "NEAR": "NEARProtocol",
                "NULS": "NULS",
                "OASYS": "OASYS",
                "OASIS": "ROSE",
                "OMNI": "OMNI",
                "ONT": "Ontology",
                "OPTIMISM": "Optimism",
                "OSMO": "Osmosis",
                "POKT": "PocketNetwork",
                "MATIC": "Polygon",
                "QTUM": "QTUM",
                "REEF": "REEF",
                "SOL": "SOL",
                "SYS": "SYS",
                "SXP": "Solar",
                "XYM": "Symbol",
                "TON": "TON",
                "TT": "TT",
                "TLOS": "Telos",
                "THETA": "ThetaToken",
                "VITE": "VITE",
                "WAVES": "WAVES",
                "WAX": "WAXP",
                "WEMIX": "WEMIXMainnet",
                "XDC": "XDCNetworkXDC",
                "XRP": "XRP",
                "FET": "FETCH",
                "NEM": "NEM",
                "REI": "REINetwork",
                "ZIL": "ZIL",
                "ABBC": "ABBCCoin",
                "RSK": "RSK",
                "AZERO": "AZERO",
                "TRC10": "TRC10",
                "JUNO": "JUNO",
                "ZKSYNC": "zkSyncEra",
                "STARKNET": "Starknet",
                "VIC": "VICTION",
            },
            "networksById": map[string]interface{} {},
            "fetchPositions": map[string]interface{} {
                "method": "privateMixGetV2MixPositionAllPosition",
            },
            "defaultTimeInForce": "GTC",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": map[string]interface{} {
                            "last": false,
                            "mark": false,
                            "index": false,
                        },
                        "price": true,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "marketBuyRequiresPrice": true,
                    "marketBuyByCost": true,
                },
                "createOrders": map[string]interface{} {
                    "max": 50,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": 90,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 90,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "forPerps": map[string]interface{} {
                "extends": "spot",
                "createOrder": map[string]interface{} {
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": map[string]interface{} {
                            "last": true,
                            "mark": true,
                            "index": true,
                        },
                        "price": false,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": true,
                    "trailing": true,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                },
                "fetchMyTrades": map[string]interface{} {
                    "untilDays": 7,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "trailing": true,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forPerps",
                },
                "inverse": map[string]interface{} {
                    "extends": "forPerps",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forPerps",
                },
                "inverse": map[string]interface{} {
                    "extends": "forPerps",
                },
            },
        },
    })
}
func  (this *bitget) SetSandboxMode(enabled interface{})  {
    AddElementToObject(this.Options, "sandboxMode", enabled)
}
func  (this *bitget) ConvertSymbolForSandbox(symbol interface{}) interface{}  {
    if IsTrue(StartsWith(symbol, "S")) {
        // handle using the exchange specified sandbox symbols
        return symbol
    }
    var convertedSymbol interface{} = nil
    if IsTrue(IsGreaterThan(GetIndexOf(symbol, "/"), OpNeg(1))) {
        if IsTrue(IsEqual(GetIndexOf(symbol, ":"), OpNeg(1))) {
            panic(NotSupported(Add(this.Id, " sandbox supports swap and future markets only")))
        }
        var splitBase interface{} = Split(symbol, "/")
        var previousBase interface{} = this.SafeString(splitBase, 0)
        var previousQuoteSettleExpiry interface{} = this.SafeString(splitBase, 1)
        var splitQuote interface{} = Split(previousQuoteSettleExpiry, ":")
        var previousQuote interface{} = this.SafeString(splitQuote, 0)
        var previousSettleExpiry interface{} = this.SafeString(splitQuote, 1)
        var splitSettle interface{} = Split(previousSettleExpiry, "-")
        var previousSettle interface{} = this.SafeString(splitSettle, 0)
        var expiry interface{} = this.SafeString(splitSettle, 1)
        convertedSymbol = Add(Add(Add(Add(Add("S", previousBase), "/S"), previousQuote), ":S"), previousSettle)
        if IsTrue(!IsEqual(expiry, nil)) {
            convertedSymbol = Add(Add(convertedSymbol, "-"), expiry)
        }
    } else {
        // handle using a market id instead of a unified symbol
        var base interface{} = Slice(symbol, 0, 3)
        var remaining interface{} = Slice(symbol, 3, nil)
        convertedSymbol = Add(Add(Add("S", base), "S"), remaining)
    }
    return convertedSymbol
}
func  (this *bitget) HandleProductTypeAndParams(optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var subType interface{} = nil
    subTypeparamsVariable := this.HandleSubTypeAndParams("handleProductTypeAndParams", nil, params);
    subType = GetValue(subTypeparamsVariable,0);
    params = GetValue(subTypeparamsVariable,1)
    var defaultProductType interface{} = nil
    if IsTrue(IsTrue((!IsEqual(subType, nil))) && IsTrue((IsEqual(market, nil)))) {
        // set default only if subType is defined and market is not defined, since there is also USDC productTypes which are also linear
        var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
        if IsTrue(sandboxMode) {
            defaultProductType = Ternary(IsTrue((IsEqual(subType, "linear"))), "SUSDT-FUTURES", "SCOIN-FUTURES")
        } else {
            defaultProductType = Ternary(IsTrue((IsEqual(subType, "linear"))), "USDT-FUTURES", "COIN-FUTURES")
        }
    }
    var productType interface{} = this.SafeString(params, "productType", defaultProductType)
    if IsTrue(IsTrue((IsEqual(productType, nil))) && IsTrue((!IsEqual(market, nil)))) {
        var settle interface{} = GetValue(market, "settle")
        if IsTrue(IsEqual(settle, "USDT")) {
            productType = "USDT-FUTURES"
        } else if IsTrue(IsEqual(settle, "USDC")) {
            productType = "USDC-FUTURES"
        } else if IsTrue(IsEqual(settle, "SUSDT")) {
            productType = "SUSDT-FUTURES"
        } else if IsTrue(IsEqual(settle, "SUSDC")) {
            productType = "SUSDC-FUTURES"
        } else if IsTrue(IsTrue(IsTrue((IsEqual(settle, "SBTC"))) || IsTrue((IsEqual(settle, "SETH")))) || IsTrue((IsEqual(settle, "SEOS")))) {
            productType = "SCOIN-FUTURES"
        } else {
            productType = "COIN-FUTURES"
        }
    }
    if IsTrue(IsEqual(productType, nil)) {
        panic(ArgumentsRequired(Add(this.Id, " requires a productType param, one of \"USDT-FUTURES\", \"USDC-FUTURES\", \"COIN-FUTURES\", \"SUSDT-FUTURES\", \"SUSDC-FUTURES\" or \"SCOIN-FUTURES\"")))
    }
    params = this.Omit(params, "productType")
    return []interface{}{productType, params}
}
/**
 * @method
 * @name bitget#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://www.bitget.com/api-doc/common/public/Get-Server-Time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *bitget) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicCommonGetV2PublicTime(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700111073740,
            //         "data": {
            //             "serverTime": "1700111073740"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.SafeInteger(data, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchMarkets
 * @description retrieves data on all markets for bitget
 * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
 * @see https://www.bitget.com/api-doc/margin/common/support-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitget) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes178012 := (<-this.LoadTimeDifference())
                PanicOnError(retRes178012)
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var types interface{} = this.SafeValue(this.Options, "fetchMarkets", []interface{}{"spot", "swap"})
            if IsTrue(sandboxMode) {
                types = []interface{}{"swap"}
            }
            var promises interface{} = []interface{}{}
            var fetchMargins interface{} = false
            for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
                var typeVar interface{} = GetValue(types, i)
                if IsTrue(IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future")))) {
                    var subTypes interface{} = nil
                    if IsTrue(sandboxMode) {
                        // the following are simulated trading markets [ 'SUSDT-FUTURES', 'SCOIN-FUTURES', 'SUSDC-FUTURES' ];
                        subTypes = []interface{}{"SUSDT-FUTURES", "SCOIN-FUTURES", "SUSDC-FUTURES"}
                    } else {
                        subTypes = []interface{}{"USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES"}
                    }
                    for j := 0; IsLessThan(j, GetArrayLength(subTypes)); j++ {
                        AppendToArray(&promises,this.PublicMixGetV2MixMarketContracts(this.Extend(params, map[string]interface{} {
                            "productType": GetValue(subTypes, j),
                        })))
                    }
                } else if IsTrue(IsEqual(typeVar, "spot")) {
                    AppendToArray(&promises,this.PublicSpotGetV2SpotPublicSymbols(params))
                    fetchMargins = true
                    AppendToArray(&promises,this.PublicMarginGetV2MarginCurrencies(params))
                } else {
                    panic(NotSupported(Add(Add(Add(this.Id, " does not support "), typeVar), " market")))
                }
            }
        
            results:= (<-promiseAll(promises))
            PanicOnError(results)
            var markets interface{} = []interface{}{}
            AddElementToObject(this.Options, "crossMarginPairsData", []interface{}{})
            AddElementToObject(this.Options, "isolatedMarginPairsData", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
                var res interface{} = this.SafeDict(results, i)
                var data interface{} = this.SafeList(res, "data", []interface{}{})
                var firstData interface{} = this.SafeDict(data, 0, map[string]interface{} {})
                var isBorrowable interface{} = this.SafeString(firstData, "isBorrowable")
                if IsTrue(IsTrue(fetchMargins) && IsTrue(!IsEqual(isBorrowable, nil))) {
                    var keysList interface{} = ObjectKeys(this.IndexBy(data, "symbol"))
                    AddElementToObject(this.Options, "crossMarginPairsData", keysList)
                    AddElementToObject(this.Options, "isolatedMarginPairsData", keysList)
                } else {
                    markets = this.ArrayConcat(markets, data)
                }
            }
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                AppendToArray(&result,this.ParseMarket(GetValue(markets, i)))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseMarket(market interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "symbol": "TRXUSDT",
    //         "baseCoin": "TRX",
    //         "quoteCoin": "USDT",
    //         "minTradeAmount": "0",
    //         "maxTradeAmount": "10000000000",
    //         "takerFeeRate": "0.002",
    //         "makerFeeRate": "0.002",
    //         "pricePrecision": "6",
    //         "quantityPrecision": "4",
    //         "quotePrecision": "6",
    //         "status": "online",
    //         "minTradeUSDT": "5",
    //         "buyLimitPriceRatio": "0.05",
    //         "sellLimitPriceRatio": "0.05"
    //     }
    //
    // swap and future
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "baseCoin": "BTC",
    //         "quoteCoin": "USDT",
    //         "buyLimitPriceRatio": "0.01",
    //         "sellLimitPriceRatio": "0.01",
    //         "feeRateUpRatio": "0.005",
    //         "makerFeeRate": "0.0002",
    //         "takerFeeRate": "0.0006",
    //         "openCostUpRatio": "0.01",
    //         "supportMarginCoins": ["USDT"],
    //         "minTradeNum": "0.001",
    //         "priceEndStep": "1",
    //         "volumePlace": "3",
    //         "pricePlace": "1",
    //         "sizeMultiplier": "0.001",
    //         "symbolType": "perpetual",
    //         "minTradeUSDT": "5",
    //         "maxSymbolOrderNum": "200",
    //         "maxProductOrderNum": "400",
    //         "maxPositionNum": "150",
    //         "symbolStatus": "normal",
    //         "offTime": "-1",
    //         "limitOpenTime": "-1",
    //         "deliveryTime": "",
    //         "deliveryStartTime": "",
    //         "deliveryPeriod": "",
    //         "launchTime": "",
    //         "fundInterval": "8",
    //         "minLever": "1",
    //         "maxLever": "125",
    //         "posLimit": "0.05",
    //         "maintainTime": ""
    //     }
    //
    var marketId interface{} = this.SafeString(market, "symbol")
    var quoteId interface{} = this.SafeString(market, "quoteCoin")
    var baseId interface{} = this.SafeString(market, "baseCoin")
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var supportMarginCoins interface{} = this.SafeValue(market, "supportMarginCoins", []interface{}{})
    var settleId interface{} = nil
    if IsTrue(this.InArray(baseId, supportMarginCoins)) {
        settleId = baseId
    } else if IsTrue(this.InArray(quoteId, supportMarginCoins)) {
        settleId = quoteId
    } else {
        settleId = this.SafeString(supportMarginCoins, 0)
    }
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    var typeVar interface{} = nil
    var swap interface{} = false
    var spot interface{} = false
    var future interface{} = false
    var contract interface{} = false
    var pricePrecision interface{} = nil
    var amountPrecision interface{} = nil
    var linear interface{} = nil
    var inverse interface{} = nil
    var expiry interface{} = nil
    var expiryDatetime interface{} = nil
    var symbolType interface{} = this.SafeString(market, "symbolType")
    var marginModes interface{} = nil
    var isMarginTradingAllowed interface{} = false
    if IsTrue(IsEqual(symbolType, nil)) {
        typeVar = "spot"
        spot = true
        pricePrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision")))
        amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision")))
        var hasCrossMargin interface{} = this.InArray(marketId, GetValue(this.Options, "crossMarginPairsData"))
        var hasIsolatedMargin interface{} = this.InArray(marketId, GetValue(this.Options, "isolatedMarginPairsData"))
        marginModes = map[string]interface{} {
            "cross": hasCrossMargin,
            "isolated": hasIsolatedMargin,
        }
        isMarginTradingAllowed = IsTrue(hasCrossMargin) || IsTrue(hasCrossMargin)
    } else {
        if IsTrue(IsEqual(symbolType, "perpetual")) {
            typeVar = "swap"
            swap = true
            symbol = Add(Add(symbol, ":"), settle)
        } else if IsTrue(IsEqual(symbolType, "delivery")) {
            expiry = this.SafeInteger(market, "deliveryTime")
            expiryDatetime = this.Iso8601(expiry)
            var expiryParts interface{} = Split(expiryDatetime, "-")
            var yearPart interface{} = this.SafeString(expiryParts, 0)
            var dayPart interface{} = this.SafeString(expiryParts, 2)
            var year interface{} = Slice(yearPart, 2, 4)
            var month interface{} = this.SafeString(expiryParts, 1)
            var day interface{} = Slice(dayPart, 0, 2)
            var expiryString interface{} = Add(Add(year, month), day)
            typeVar = "future"
            future = true
            symbol = Add(Add(Add(Add(symbol, ":"), settle), "-"), expiryString)
        }
        contract = true
        inverse = (IsEqual(base, settle))
        linear = !IsTrue(inverse)
        var priceDecimals interface{} = this.SafeInteger(market, "pricePlace")
        var amountDecimals interface{} = this.SafeInteger(market, "volumePlace")
        var priceStep interface{} = this.SafeString(market, "priceEndStep")
        var amountStep interface{} = this.SafeString(market, "minTradeNum")
        precise := NewPrecise(priceStep)
        precise.Decimals = mathMax(precise.Decimals, priceDecimals)
        precise.Reduce()
        var priceString interface{} = precise.ToString()
        pricePrecision = this.ParseNumber(priceString)
        preciseAmount := NewPrecise(amountStep)
        preciseAmount.Decimals = mathMax(preciseAmount.Decimals, amountDecimals)
        preciseAmount.Reduce()
        var amountString interface{} = preciseAmount.ToString()
        amountPrecision = this.ParseNumber(amountString)
        marginModes = map[string]interface{} {
            "cross": true,
            "isolated": true,
        }
    }
    var status interface{} = this.SafeString2(market, "status", "symbolStatus")
    var active interface{} = nil
    if IsTrue(!IsEqual(status, nil)) {
        active = (IsTrue((IsEqual(status, "online"))) || IsTrue((IsEqual(status, "normal"))))
    }
    var minCost interface{} = nil
    if IsTrue(IsEqual(quote, "USDT")) {
        minCost = this.SafeNumber(market, "minTradeUSDT")
    }
    var contractSize interface{} = Ternary(IsTrue(contract), 1, nil)
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": typeVar,
        "spot": spot,
        "margin": IsTrue(spot) && IsTrue(isMarginTradingAllowed),
        "marginModes": marginModes,
        "swap": swap,
        "future": future,
        "option": false,
        "active": active,
        "contract": contract,
        "linear": linear,
        "inverse": inverse,
        "taker": this.SafeNumber(market, "takerFeeRate"),
        "maker": this.SafeNumber(market, "makerFeeRate"),
        "contractSize": contractSize,
        "expiry": expiry,
        "expiryDatetime": expiryDatetime,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": amountPrecision,
            "price": pricePrecision,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": this.SafeNumber(market, "minLever"),
                "max": this.SafeNumber(market, "maxLever"),
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber2(market, "minTradeNum", "minTradeAmount"),
                "max": this.SafeNumber(market, "maxTradeAmount"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": minCost,
                "max": nil,
            },
        },
        "created": this.SafeInteger(market, "launchTime"),
        "info": market,
    }
}
/**
 * @method
 * @name bitget#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *bitget) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetV2SpotPublicCoins(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "data": [
            //             {
            //                 "chains": [
            //                     {
            //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
            //                         "chain": "BTC",
            //                         "depositConfirm": "1",
            //                         "extraWithdrawFee": "0",
            //                         "minDepositAmount": "0.0001",
            //                         "minWithdrawAmount": "0.005",
            //                         "needTag": "false",
            //                         "rechargeable": "true",
            //                         "withdrawConfirm": "1",
            //                         "withdrawFee": "0.0004",
            //                         "withdrawable": "true"
            //                     },
            //                 ],
            //                 "coin": "BTC",
            //                 "coinId": "1",
            //                 "transfer": "true""
            //             }
            //         ],
            //         "msg": "success",
            //         "requestTime": "1700120731773"
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(entry, "coin") // we don't use 'coinId' as it has no use. it is 'coin' field that needs to be used in currency related endpoints (deposit, withdraw, etc..)
                var code interface{} = this.SafeCurrencyCode(id)
                var chains interface{} = this.SafeValue(entry, "chains", []interface{}{})
                var networks interface{} = map[string]interface{} {}
                var deposit interface{} = false
                var withdraw interface{} = false
                var minWithdrawString interface{} = nil
                var minDepositString interface{} = nil
                var minWithdrawFeeString interface{} = nil
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString(chain, "chain")
                    var network interface{} = this.NetworkIdToCode(networkId, code)
                    if IsTrue(!IsEqual(network, nil)) {
                        network = ToUpper(network)
                    }
                    var withdrawEnabled interface{} = this.SafeString(chain, "withdrawable")
                    var canWithdraw interface{} = IsEqual(withdrawEnabled, "true")
                    withdraw = Ternary(IsTrue((canWithdraw)), canWithdraw, withdraw)
                    var depositEnabled interface{} = this.SafeString(chain, "rechargeable")
                    var canDeposit interface{} = IsEqual(depositEnabled, "true")
                    deposit = Ternary(IsTrue((canDeposit)), canDeposit, deposit)
                    var networkWithdrawFeeString interface{} = this.SafeString(chain, "withdrawFee")
                    if IsTrue(!IsEqual(networkWithdrawFeeString, nil)) {
                        minWithdrawFeeString = Ternary(IsTrue((IsEqual(minWithdrawFeeString, nil))), networkWithdrawFeeString, Precise.StringMin(networkWithdrawFeeString, minWithdrawFeeString))
                    }
                    var networkMinWithdrawString interface{} = this.SafeString(chain, "minWithdrawAmount")
                    if IsTrue(!IsEqual(networkMinWithdrawString, nil)) {
                        minWithdrawString = Ternary(IsTrue((IsEqual(minWithdrawString, nil))), networkMinWithdrawString, Precise.StringMin(networkMinWithdrawString, minWithdrawString))
                    }
                    var networkMinDepositString interface{} = this.SafeString(chain, "minDepositAmount")
                    if IsTrue(!IsEqual(networkMinDepositString, nil)) {
                        minDepositString = Ternary(IsTrue((IsEqual(minDepositString, nil))), networkMinDepositString, Precise.StringMin(networkMinDepositString, minDepositString))
                    }
                    AddElementToObject(networks, network, map[string]interface{} {
            "info": chain,
            "id": networkId,
            "network": network,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(networkMinWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(networkMinDepositString),
                    "max": nil,
                },
            },
            "active": IsTrue(canWithdraw) && IsTrue(canDeposit),
            "withdraw": canWithdraw,
            "deposit": canDeposit,
            "fee": this.ParseNumber(networkWithdrawFeeString),
            "precision": nil,
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "id": id,
            "code": code,
            "networks": networks,
            "type": nil,
            "name": nil,
            "active": IsTrue(deposit) && IsTrue(withdraw),
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": this.ParseNumber(minWithdrawFeeString),
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minDepositString),
                    "max": nil,
                },
            },
            "created": nil,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
 * @see https://www.bitget.com/api-doc/contract/position/Get-Query-Position-Lever
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Tier-Data
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Tier-Data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] for spot margin 'cross' or 'isolated', default is 'isolated'
 * @param {string} [params.code] required for cross spot margin
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func  (this *bitget) FetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21868 := (<-this.LoadMarkets())
            PanicOnError(retRes21868)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMarketLeverageTiers", params, "isolated");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicMixGetV2MixMarketQueryPositionLever(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "isolated")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PrivateMarginGetV2MarginIsolatedTierData(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "cross")) {
                var code interface{} = this.SafeString(params, "code")
                if IsTrue(IsEqual(code, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchMarketLeverageTiers() requires a code argument")))
                }
                params = this.Omit(params, "code")
                var currency interface{} = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
                
        response = (<-this.PrivateMarginGetV2MarginCrossedTierData(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(BadRequest(Add(Add(this.Id, " fetchMarketLeverageTiers() symbol does not support market "), GetValue(market, "symbol"))))
            }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700290724614,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "level": "1",
            //                 "startUnit": "0",
            //                 "endUnit": "150000",
            //                 "leverage": "125",
            //                 "keepMarginRate": "0.004"
            //             },
            //         ]
            //     }
            //
            // isolated
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700291531894,
            //         "data": [
            //             {
            //                 "tier": "1",
            //                 "symbol": "BTCUSDT",
            //                 "leverage": "10",
            //                 "baseCoin": "BTC",
            //                 "quoteCoin": "USDT",
            //                 "baseMaxBorrowableAmount": "2",
            //                 "quoteMaxBorrowableAmount": "24000",
            //                 "maintainMarginRate": "0.05",
            //                 "initRate": "0.1111"
            //             },
            //         ]
            //     }
            //
            // cross
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700291818831,
            //         "data": [
            //             {
            //                 "tier": "1",
            //                 "leverage": "3",
            //                 "coin": "BTC",
            //                 "maxBorrowableAmount": "26",
            //                 "maintainMarginRate": "0.1"
            //             }
            //         ]
            //     }
            //
            var result interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarketLeverageTiers(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // swap and future
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "level": "1",
    //         "startUnit": "0",
    //         "endUnit": "150000",
    //         "leverage": "125",
    //         "keepMarginRate": "0.004"
    //     }
    //
    // isolated
    //
    //     {
    //         "tier": "1",
    //         "symbol": "BTCUSDT",
    //         "leverage": "10",
    //         "baseCoin": "BTC",
    //         "quoteCoin": "USDT",
    //         "baseMaxBorrowableAmount": "2",
    //         "quoteMaxBorrowableAmount": "24000",
    //         "maintainMarginRate": "0.05",
    //         "initRate": "0.1111"
    //     }
    //
    // cross
    //
    //     {
    //         "tier": "1",
    //         "leverage": "3",
    //         "coin": "BTC",
    //         "maxBorrowableAmount": "26",
    //         "maintainMarginRate": "0.1"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var tiers interface{} = []interface{}{}
    var minNotional interface{} = 0
    for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
        var item interface{} = GetValue(info, i)
        var minimumNotional interface{} = this.SafeNumber(item, "startUnit")
        if IsTrue(!IsEqual(minimumNotional, nil)) {
            minNotional = minimumNotional
        }
        var maxNotional interface{} = this.SafeNumberN(item, []interface{}{"endUnit", "maxBorrowableAmount", "baseMaxBorrowableAmount"})
        var marginCurrency interface{} = this.SafeString2(item, "coin", "baseCoin")
        var currencyId interface{} = Ternary(IsTrue((!IsEqual(marginCurrency, nil))), marginCurrency, GetValue(market, "base"))
        var marketId interface{} = this.SafeString(item, "symbol")
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.SafeInteger2(item, "level", "tier"),
            "symbol": this.SafeSymbol(marketId, market),
            "currency": this.SafeCurrencyCode(currencyId),
            "minNotional": minNotional,
            "maxNotional": maxNotional,
            "maintenanceMarginRate": this.SafeNumber2(item, "keepMarginRate", "maintainMarginRate"),
            "maxLeverage": this.SafeNumber(item, "leverage"),
            "info": item,
        })
        minNotional = maxNotional
    }
    return tiers
}
/**
 * @method
 * @name bitget#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Record
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in milliseconds
 * @param {string} [params.idLessThan] return records with id less than the provided value
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitget) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23608 := (<-this.LoadMarkets())
            PanicOnError(retRes23608)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes236419 :=  (<-this.FetchPaginatedCallCursor("fetchDeposits", nil, since, limit, params, "idLessThan", "idLessThan", nil, 100))
                    PanicOnError(retRes236419)
                    ch <- retRes236419
                    return nil
            }
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDeposits() requires a `code` argument")))
            }
            var currency interface{} = this.Currency(code)
            if IsTrue(IsEqual(since, nil)) {
                since = Subtract(this.Milliseconds(), 7776000000) // 90 days
            }
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "startTime": since,
                "endTime": this.Milliseconds(),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.PrivateSpotGetV2SpotWalletDepositRecords(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700528340608,
            //         "data": [
            //             {
            //                 "orderId": "1083832260799930368",
            //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
            //                 "coin": "BTC",
            //                 "type": "deposit",
            //                 "size": "0.00030000",
            //                 "status": "success",
            //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
            //                 "dest": "on_chain",
            //                 "chain": "BTC",
            //                 "fromAddress": null,
            //                 "cTime": "1694131668281",
            //                 "uTime": "1694131680247"
            //             }
            //         ]
            //     }
            //
            var rawTransactions interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(rawTransactions, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#withdraw
 * @description make a withdrawal
 * @see https://www.bitget.com/api-doc/spot/account/Wallet-Withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.chain] the blockchain network the withdrawal is taking place on
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitget) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckAddress(address)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a \"network\" parameter")))
            }
        
            retRes24308 := (<-this.LoadMarkets())
            PanicOnError(retRes24308)
            var currency interface{} = this.Currency(code)
            var networkId interface{} = this.NetworkCodeToId(networkCode)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "address": address,
                "chain": networkId,
                "size": amount,
                "transferType": "on_chain",
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "tag", tag)
            }
        
            response:= (<-this.PrivateSpotPostV2SpotWalletWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //          "code":"00000",
            //          "msg":"success",
            //          "requestTime":1696784219602,
            //          "data": {
            //              "orderId":"1094957867615789056",
            //              "clientOid":"64f1e4ce842041d296b4517df1b5c2d7"
            //          }
            //      }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var result interface{} = this.ParseTransaction(data, currency)
            AddElementToObject(result, "type", "withdrawal")
            var withdrawOptions interface{} = this.SafeValue(this.Options, "withdraw", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(withdrawOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(result, "currency", code)
                AddElementToObject(result, "timestamp", this.Milliseconds())
                AddElementToObject(result, "datetime", this.Iso8601(this.Milliseconds()))
                AddElementToObject(result, "amount", amount)
                AddElementToObject(result, "tag", tag)
                AddElementToObject(result, "address", address)
                AddElementToObject(result, "addressTo", address)
                AddElementToObject(result, "network", networkCode)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Withdraw-Record
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in milliseconds
 * @param {string} [params.idLessThan] return records with id less than the provided value
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitget) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes24888 := (<-this.LoadMarkets())
            PanicOnError(retRes24888)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes249219 :=  (<-this.FetchPaginatedCallCursor("fetchWithdrawals", nil, since, limit, params, "idLessThan", "idLessThan", nil, 100))
                    PanicOnError(retRes249219)
                    ch <- retRes249219
                    return nil
            }
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchWithdrawals() requires a `code` argument")))
            }
            var currency interface{} = this.Currency(code)
            if IsTrue(IsEqual(since, nil)) {
                since = Subtract(this.Milliseconds(), 7776000000) // 90 days
            }
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "startTime": since,
                "endTime": this.Milliseconds(),
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateSpotGetV2SpotWalletWithdrawalRecords(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700528340608,
            //         "data": [
            //             {
            //                 "orderId": "1083832260799930368",
            //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
            //                 "clientOid": "123",
            //                 "coin": "BTC",
            //                 "type": "withdraw",
            //                 "size": "0.00030000",
            //                 "fee": "-1.0000000",
            //                 "status": "success",
            //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
            //                 "dest": "on_chain",
            //                 "chain": "BTC",
            //                 "confirm": "100",
            //                 "fromAddress": null,
            //                 "cTime": "1694131668281",
            //                 "uTime": "1694131680247"
            //             }
            //         ]
            //     }
            //
            var rawTransactions interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(rawTransactions, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "orderId": "1083832260799930368",
    //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
    //         "coin": "BTC",
    //         "type": "deposit",
    //         "size": "0.00030000",
    //         "status": "success",
    //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
    //         "dest": "on_chain",
    //         "chain": "BTC",
    //         "fromAddress": null,
    //         "cTime": "1694131668281",
    //         "uTime": "1694131680247"
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "orderId": "1083832260799930368",
    //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
    //         "clientOid": "123",
    //         "coin": "BTC",
    //         "type": "withdraw",
    //         "size": "0.00030000",
    //         "fee": "-1.0000000",
    //         "status": "success",
    //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
    //         "dest": "on_chain",
    //         "chain": "BTC",
    //         "confirm": "100",
    //         "fromAddress": null,
    //         "cTime": "1694131668281",
    //         "uTime": "1694131680247"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(transaction, "cTime")
    var networkId interface{} = this.SafeString(transaction, "chain")
    var status interface{} = this.SafeString(transaction, "status")
    var tag interface{} = this.SafeString(transaction, "tag")
    var feeCostString interface{} = this.SafeString(transaction, "fee")
    var feeCostAbsString interface{} = Precise.StringAbs(feeCostString)
    var fee interface{} = nil
    var amountString interface{} = this.SafeString(transaction, "size")
    if IsTrue(!IsEqual(feeCostAbsString, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(feeCostAbsString),
        }
        amountString = Precise.StringSub(amountString, feeCostAbsString)
    }
    return map[string]interface{} {
        "id": this.SafeString(transaction, "orderId"),
        "info": transaction,
        "txid": this.SafeString(transaction, "tradeId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.NetworkIdToCode(networkId),
        "addressFrom": this.SafeString(transaction, "fromAddress"),
        "address": this.SafeString(transaction, "toAddress"),
        "addressTo": this.SafeString(transaction, "toAddress"),
        "amount": this.ParseNumber(amountString),
        "type": this.SafeString(transaction, "type"),
        "currency": code,
        "status": this.ParseTransactionStatus(status),
        "updated": this.SafeInteger(transaction, "uTime"),
        "tagFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
func  (this *bitget) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "success": "ok",
        "Pending": "pending",
        "pending_review": "pending",
        "pending_review_fail": "failed",
        "reject": "failed",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name bitget#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bitget) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26398 := (<-this.LoadMarkets())
            PanicOnError(retRes26398)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode, code))
            }
        
            response:= (<-this.PrivateSpotGetV2SpotWalletDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700532244807,
            //         "data": {
            //             "coin": "BTC",
            //             "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
            //             "chain": "",
            //             "tag": null,
            //             "url": "https://blockchair.com/bitcoin/transaction/"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "coin": "BTC",
    //         "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
    //         "chain": "",
    //         "tag": null,
    //         "url": "https://blockchair.com/bitcoin/transaction/"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(depositAddress, "coin")
    var networkId interface{} = this.SafeString(depositAddress, "chain")
    var parsedCurrency interface{} = this.SafeCurrencyCode(currencyId, currency)
    var network interface{} = nil
    if IsTrue(!IsEqual(networkId, nil)) {
        network = this.NetworkIdToCode(networkId, parsedCurrency)
    }
    return map[string]interface{} {
        "info": depositAddress,
        "currency": parsedCurrency,
        "network": network,
        "address": this.SafeString(depositAddress, "address"),
        "tag": this.SafeString(depositAddress, "tag"),
    }
}
/**
 * @method
 * @name bitget#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitget.com/api-doc/spot/market/Get-Orderbook
 * @see https://www.bitget.com/api-doc/contract/market/Get-Merge-Depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitget) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27068 := (<-this.LoadMarkets())
            PanicOnError(retRes27068)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PublicSpotGetV2SpotMarketOrderbook(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PublicMixGetV2MixMarketMergeDepth(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //       "code": "00000",
            //       "msg": "success",
            //       "requestTime": 1645854610294,
            //       "data": {
            //         "asks": [ [ "39102", "11.026" ] ],
            //         "bids": [ [ '39100.5', "1.773" ] ],
            //         "ts": "1645854610294"
            //       }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "ts")
        
            ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   {
    //       "symbol": "BTCUSDT",
    //       "price": "26242",
    //       "indexPrice": "34867",
    //       "markPrice": "25555",
    //       "ts": "1695793390482"
    //   }
    //
    // spot: fetchTicker, fetchTickers
    //
    //     {
    //         "open": "37202.46",
    //         "symbol": "BTCUSDT",
    //         "high24h": "37744.75",
    //         "low24h": "36666",
    //         "lastPr": "37583.69",
    //         "quoteVolume": "519127705.303",
    //         "baseVolume": "13907.0386",
    //         "usdtVolume": "519127705.302908",
    //         "ts": "1700532903261",
    //         "bidPr": "37583.68",
    //         "askPr": "37583.69",
    //         "bidSz": "0.0007",
    //         "askSz": "0.0829",
    //         "openUtc": "37449.4",
    //         "changeUtc24h": "0.00359",
    //         "change24h": "0.00321"
    //     }
    //
    // swap and future: fetchTicker
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "lastPr": "37577.2",
    //         "askPr": "37577.3",
    //         "bidPr": "37577.2",
    //         "bidSz": "3.679",
    //         "askSz": "0.02",
    //         "high24h": "37765",
    //         "low24h": "36628.9",
    //         "ts": "1700533070359",
    //         "change24h": "0.00288",
    //         "baseVolume": "108606.181",
    //         "quoteVolume": "4051316303.9608",
    //         "usdtVolume": "4051316303.9608",
    //         "openUtc": "37451.5",
    //         "changeUtc24h": "0.00336",
    //         "indexPrice": "37574.489253",
    //         "fundingRate": "0.0001",
    //         "holdingAmount": "53464.529",
    //         "deliveryStartTime": null,
    //         "deliveryTime": null,
    //         "deliveryStatus": "",
    //         "open24h": "37235.7"
    //     }
    //
    // swap and future: fetchTickers
    //
    //     {
    //         "open": "14.9776",
    //         "symbol": "LINKUSDT",
    //         "high24h": "15.3942",
    //         "low24h": "14.3457",
    //         "lastPr": "14.3748",
    //         "quoteVolume": "7008612.4299",
    //         "baseVolume": "469908.8523",
    //         "usdtVolume": "7008612.42986561",
    //         "ts": "1700533772309",
    //         "bidPr": "14.375",
    //         "askPr": "14.3769",
    //         "bidSz": "50.004",
    //         "askSz": "0.7647",
    //         "openUtc": "14.478",
    //         "changeUtc24h": "-0.00713",
    //         "change24h": "-0.04978"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var close interface{} = this.SafeString(ticker, "lastPr")
    var timestamp interface{} = this.SafeIntegerOmitZero(ticker, "ts") // exchange bitget provided 0
    var change interface{} = this.SafeString(ticker, "change24h")
    var open24 interface{} = this.SafeString(ticker, "open24")
    var open interface{} = this.SafeString(ticker, "open")
    var symbol interface{} = nil
    var openValue interface{} = nil
    if IsTrue(IsEqual(open, nil)) {
        symbol = this.SafeSymbol(marketId, market, nil, "contract")
        openValue = open24
    } else {
        symbol = this.SafeSymbol(marketId, market, nil, "spot")
        openValue = open
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high24h"),
        "low": this.SafeString(ticker, "low24h"),
        "bid": this.SafeString(ticker, "bidPr"),
        "bidVolume": this.SafeString(ticker, "bidSz"),
        "ask": this.SafeString(ticker, "askPr"),
        "askVolume": this.SafeString(ticker, "askSz"),
        "vwap": nil,
        "open": openValue,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": change,
        "percentage": Precise.StringMul(change, "100"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "baseVolume"),
        "quoteVolume": this.SafeString(ticker, "quoteVolume"),
        "indexPrice": this.SafeString(ticker, "indexPrice"),
        "markPrice": this.SafeString(ticker, "markPrice"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitget#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
 * @see https://www.bitget.com/api-doc/contract/market/Get-Ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitget) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28788 := (<-this.LoadMarkets())
            PanicOnError(retRes28788)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PublicSpotGetV2SpotMarketTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PublicMixGetV2MixMarketTicker(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700532903782,
            //         "data": [
            //             {
            //                 "open": "37202.46",
            //                 "symbol": "BTCUSDT",
            //                 "high24h": "37744.75",
            //                 "low24h": "36666",
            //                 "lastPr": "37583.69",
            //                 "quoteVolume": "519127705.303",
            //                 "baseVolume": "13907.0386",
            //                 "usdtVolume": "519127705.302908",
            //                 "ts": "1700532903261",
            //                 "bidPr": "37583.68",
            //                 "askPr": "37583.69",
            //                 "bidSz": "0.0007",
            //                 "askSz": "0.0829",
            //                 "openUtc": "37449.4",
            //                 "changeUtc24h": "0.00359",
            //                 "change24h": "0.00321"
            //             }
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700533070357,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "lastPr": "37577.2",
            //                 "askPr": "37577.3",
            //                 "bidPr": "37577.2",
            //                 "bidSz": "3.679",
            //                 "askSz": "0.02",
            //                 "high24h": "37765",
            //                 "low24h": "36628.9",
            //                 "ts": "1700533070359",
            //                 "change24h": "0.00288",
            //                 "baseVolume": "108606.181",
            //                 "quoteVolume": "4051316303.9608",
            //                 "usdtVolume": "4051316303.9608",
            //                 "openUtc": "37451.5",
            //                 "changeUtc24h": "0.00336",
            //                 "indexPrice": "37574.489253",
            //                 "fundingRate": "0.0001",
            //                 "holdingAmount": "53464.529",
            //                 "deliveryStartTime": null,
            //                 "deliveryTime": null,
            //                 "deliveryStatus": "",
            //                 "open24h": "37235.7"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTicker(GetValue(data, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchMarkPrice
 * @description fetches the mark price for a specific market
 * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitget) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes29768 := (<-this.LoadMarkets())
            PanicOnError(retRes29768)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " fetchMarkPrice() is not supported for spot markets")))
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PublicMixGetV2MixMarketSymbolPrice(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTicker(GetValue(data, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] *contract only* 'linear', 'inverse'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitget) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30148 := (<-this.LoadMarkets())
            PanicOnError(retRes30148)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeValue(symbols, 0)
                var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(symbol)
                }
            }
            var response interface{} = nil
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            // Calls like `.fetchTickers (undefined, {subType:'inverse'})` should be supported for this exchange, so
            // as "options.defaultSubType" is also set in exchange options, we should consider `params.subType`
            // with higher priority and only default to spot, if `subType` is not set in params
            var passedSubType interface{} = this.SafeString(params, "subType")
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            // only if passedSubType && productType is undefined, then use spot
            if IsTrue(IsTrue(IsEqual(typeVar, "spot")) && IsTrue(IsEqual(passedSubType, nil))) {
                
        response = (<-this.PublicSpotGetV2SpotMarketTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PublicMixGetV2MixMarketTickers(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700532903782,
            //         "data": [
            //             {
            //                 "open": "37202.46",
            //                 "symbol": "BTCUSDT",
            //                 "high24h": "37744.75",
            //                 "low24h": "36666",
            //                 "lastPr": "37583.69",
            //                 "quoteVolume": "519127705.303",
            //                 "baseVolume": "13907.0386",
            //                 "usdtVolume": "519127705.302908",
            //                 "ts": "1700532903261",
            //                 "bidPr": "37583.68",
            //                 "askPr": "37583.69",
            //                 "bidSz": "0.0007",
            //                 "askSz": "0.0829",
            //                 "openUtc": "37449.4",
            //                 "changeUtc24h": "0.00359",
            //                 "change24h": "0.00321"
            //             }
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700533773477,
            //         "data": [
            //             {
            //                 "open": "14.9776",
            //                 "symbol": "LINKUSDT",
            //                 "high24h": "15.3942",
            //                 "low24h": "14.3457",
            //                 "lastPr": "14.3748",
            //                 "quoteVolume": "7008612.4299",
            //                 "baseVolume": "469908.8523",
            //                 "usdtVolume": "7008612.42986561",
            //                 "ts": "1700533772309",
            //                 "bidPr": "14.375",
            //                 "askPr": "14.3769",
            //                 "bidSz": "50.004",
            //                 "askSz": "0.7647",
            //                 "openUtc": "14.478",
            //                 "changeUtc24h": "-0.00713",
            //                 "change24h": "-0.04978"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot, swap and future: fetchTrades
    //
    //     {
    //         "tradeId": "1075199767891652609",
    //         "price": "29376.5",
    //         "size": "6.035",
    //         "side": "Buy",
    //         "ts": "1692073521000",
    //         "symbol": "BTCUSDT"
    //     }
    //
    // spot: fetchMyTrades
    //
    //     {
    //         "userId": "7264631750",
    //         "symbol": "BTCUSDT",
    //         "orderId": "1098394344925597696",
    //         "tradeId": "1098394344974925824",
    //         "orderType": "market",
    //         "side": "sell",
    //         "priceAvg": "28467.68",
    //         "size": "0.0002",
    //         "amount": "5.693536",
    //         "feeDetail": {
    //             "deduction": "no",
    //             "feeCoin": "USDT",
    //             "totalDeductionFee": "",
    //             "totalFee": "-0.005693536"
    //         },
    //         "tradeScope": "taker",
    //         "cTime": "1697603539699",
    //         "uTime": "1697603539754"
    //     }
    //
    // spot margin: fetchMyTrades
    //
    //     {
    //         "orderId": "1099353730455318528",
    //         "tradeId": "1099353730627092481",
    //         "orderType": "market",
    //         "side": "sell",
    //         "priceAvg": "29543.7",
    //         "size": "0.0001",
    //         "amount": "2.95437",
    //         "tradeScope": "taker",
    //         "feeDetail": {
    //             "deduction": "no",
    //             "feeCoin": "USDT",
    //             "totalDeductionFee": "0",
    //             "totalFee": "-0.00295437"
    //         },
    //         "cTime": "1697832275063",
    //         "uTime": "1697832275150"
    //     }
    //
    // swap and future: fetchMyTrades
    //
    //     {
    //         "tradeId": "1111468664328269825",
    //         "symbol": "BTCUSDT",
    //         "orderId": "1111468664264753162",
    //         "price": "37271.4",
    //         "baseVolume": "0.001",
    //         "feeDetail": [
    //             {
    //                 "deduction": "no",
    //                 "feeCoin": "USDT",
    //                 "totalDeductionFee": null,
    //                 "totalFee": "-0.02236284"
    //             }
    //         ],
    //         "side": "buy",
    //         "quoteVolume": "37.2714",
    //         "profit": "-0.0007",
    //         "enterPointSource": "web",
    //         "tradeSide": "close",
    //         "posMode": "hedge_mode",
    //         "tradeScope": "taker",
    //         "cTime": "1700720700342"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeInteger2(trade, "cTime", "ts")
    var fee interface{} = nil
    var feeDetail interface{} = this.SafeValue(trade, "feeDetail")
    var posMode interface{} = this.SafeString(trade, "posMode")
    var feeStructure interface{} = Ternary(IsTrue((!IsEqual(posMode, nil))), GetValue(feeDetail, 0), feeDetail)
    if IsTrue(!IsEqual(feeStructure, nil)) {
        var currencyCode interface{} = this.SafeCurrencyCode(this.SafeString(feeStructure, "feeCoin"))
        fee = map[string]interface{} {
            "currency": currencyCode,
        }
        var feeCostString interface{} = this.SafeString(feeStructure, "totalFee")
        var deduction interface{} = Ternary(IsTrue(IsEqual(this.SafeString(feeStructure, "deduction"), "yes")), true, false)
        if IsTrue(deduction) {
            AddElementToObject(fee, "cost", feeCostString)
        } else {
            AddElementToObject(fee, "cost", Precise.StringNeg(feeCostString))
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "tradeId"),
        "order": this.SafeString(trade, "orderId"),
        "symbol": symbol,
        "side": this.SafeStringLower(trade, "side"),
        "type": this.SafeString(trade, "orderType"),
        "takerOrMaker": this.SafeString(trade, "tradeScope"),
        "price": this.SafeString2(trade, "priceAvg", "price"),
        "amount": this.SafeString2(trade, "baseVolume", "size"),
        "cost": this.SafeString2(trade, "quoteVolume", "amount"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitget#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.bitget.com/api-doc/spot/market/Get-Recent-Trades
 * @see https://www.bitget.com/api-doc/spot/market/Get-Market-Trades
 * @see https://www.bitget.com/api-doc/contract/market/Get-Recent-Fills
 * @see https://www.bitget.com/api-doc/contract/market/Get-Fills-History
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* default false, when true will automatically paginate by calling this endpoint multiple times
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitget) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes32418 := (<-this.LoadMarkets())
            PanicOnError(retRes32418)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes324519 :=  (<-this.FetchPaginatedCallCursor("fetchTrades", symbol, since, limit, params, "idLessThan", "idLessThan"))
                    PanicOnError(retRes324519)
                    ch <- retRes324519
                    return nil
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(GetValue(market, "contract")) {
                    AddElementToObject(request, "limit", mathMin(limit, 1000))
                } else {
                    AddElementToObject(request, "limit", limit)
                }
            }
            var options interface{} = this.SafeValue(this.Options, "fetchTrades", map[string]interface{} {})
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                var spotOptions interface{} = this.SafeValue(options, "spot", map[string]interface{} {})
                var defaultSpotMethod interface{} = this.SafeString(spotOptions, "method", "publicSpotGetV2SpotMarketFillsHistory")
                var spotMethod interface{} = this.SafeString(params, "method", defaultSpotMethod)
                params = this.Omit(params, "method")
                if IsTrue(IsEqual(spotMethod, "publicSpotGetV2SpotMarketFillsHistory")) {
                    requestparamsVariable := this.HandleUntilOption("endTime", request, params);
                    request = GetValue(requestparamsVariable,0);
                    params = GetValue(requestparamsVariable,1)
                    if IsTrue(!IsEqual(since, nil)) {
                        AddElementToObject(request, "startTime", since)
                    }
                    
        response = (<-this.PublicSpotGetV2SpotMarketFillsHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(spotMethod, "publicSpotGetV2SpotMarketFills")) {
                    
        response = (<-this.PublicSpotGetV2SpotMarketFills(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var swapOptions interface{} = this.SafeValue(options, "swap", map[string]interface{} {})
                var defaultSwapMethod interface{} = this.SafeString(swapOptions, "method", "publicMixGetV2MixMarketFillsHistory")
                var swapMethod interface{} = this.SafeString(params, "method", defaultSwapMethod)
                params = this.Omit(params, "method")
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(IsEqual(swapMethod, "publicMixGetV2MixMarketFillsHistory")) {
                    requestparamsVariable := this.HandleUntilOption("endTime", request, params);
                    request = GetValue(requestparamsVariable,0);
                    params = GetValue(requestparamsVariable,1)
                    if IsTrue(!IsEqual(since, nil)) {
                        AddElementToObject(request, "startTime", since)
                    }
                    
        response = (<-this.PublicMixGetV2MixMarketFillsHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(swapMethod, "publicMixGetV2MixMarketFills")) {
                    
        response = (<-this.PublicMixGetV2MixMarketFills(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1692073693562,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT_SPBL",
            //                 "tradeId": "1075200479040323585",
            //                 "side": "Sell",
            //                 "price": "29381.54",
            //                 "size": "0.0056",
            //                 "ts": "1692073691000"
            //             },
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1692073522689,
            //         "data": [
            //             {
            //                 "tradeId": "1075199767891652609",
            //                 "price": "29376.5",
            //                 "size": "6.035",
            //                 "side": "Buy",
            //                 "ts": "1692073521000",
            //                 "symbol": "BTCUSDT_UMCBL"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.bitget.com/api-doc/common/public/Get-Trade-Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross', for finding the fee rate of spot margin trading pairs
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitget) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33518 := (<-this.LoadMarkets())
            PanicOnError(retRes33518)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTradingFee", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "businessType", "margin")
                } else {
                    AddElementToObject(request, "businessType", "spot")
                }
            } else {
                AddElementToObject(request, "businessType", "contract")
            }
        
            response:= (<-this.PrivateCommonGetV2CommonTradeRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700549524887,
            //         "data": {
            //             "makerFeeRate": "0.001",
            //             "takerFeeRate": "0.001"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTradingFee(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
 * @see https://www.bitget.com/api-doc/margin/common/support-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.margin] set to true for spot margin
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *bitget) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33968 := (<-this.LoadMarkets())
            PanicOnError(retRes33968)
            var response interface{} = nil
            var marginMode interface{} = nil
            var marketType interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTradingFees", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                var margin interface{} = this.SafeBool(params, "margin", false)
                params = this.Omit(params, "margin")
                if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(margin)) {
                    
        response = (<-this.PublicMarginGetV2MarginCurrencies(params))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PublicSpotGetV2SpotPublicSymbols(params))
                    PanicOnError(response)
                }
            } else if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(params, "productType", productType)
                
        response = (<-this.PublicMixGetV2MixMarketContracts(params))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " does not support "), marketType), " market")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700102364653,
            //         "data": [
            //             {
            //                 "symbol": "TRXUSDT",
            //                 "baseCoin": "TRX",
            //                 "quoteCoin": "USDT",
            //                 "minTradeAmount": "0",
            //                 "maxTradeAmount": "10000000000",
            //                 "takerFeeRate": "0.002",
            //                 "makerFeeRate": "0.002",
            //                 "pricePrecision": "6",
            //                 "quantityPrecision": "4",
            //                 "quotePrecision": "6",
            //                 "status": "online",
            //                 "minTradeUSDT": "5",
            //                 "buyLimitPriceRatio": "0.05",
            //                 "sellLimitPriceRatio": "0.05"
            //             },
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700102364709,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "baseCoin": "BTC",
            //                 "quoteCoin": "USDT",
            //                 "buyLimitPriceRatio": "0.01",
            //                 "sellLimitPriceRatio": "0.01",
            //                 "feeRateUpRatio": "0.005",
            //                 "makerFeeRate": "0.0002",
            //                 "takerFeeRate": "0.0006",
            //                 "openCostUpRatio": "0.01",
            //                 "supportMarginCoins": ["USDT"],
            //                 "minTradeNum": "0.001",
            //                 "priceEndStep": "1",
            //                 "volumePlace": "3",
            //                 "pricePlace": "1",
            //                 "sizeMultiplier": "0.001",
            //                 "symbolType": "perpetual",
            //                 "minTradeUSDT": "5",
            //                 "maxSymbolOrderNum": "200",
            //                 "maxProductOrderNum": "400",
            //                 "maxPositionNum": "150",
            //                 "symbolStatus": "normal",
            //                 "offTime": "-1",
            //                 "limitOpenTime": "-1",
            //                 "deliveryTime": "",
            //                 "deliveryStartTime": "",
            //                 "deliveryPeriod": "",
            //                 "launchTime": "",
            //                 "fundInterval": "8",
            //                 "minLever": "1",
            //                 "maxLever": "125",
            //                 "posLimit": "0.05",
            //                 "maintainTime": ""
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
                var market interface{} = this.Market(symbol)
                var fee interface{} = this.ParseTradingFee(entry, market)
                AddElementToObject(result, symbol, fee)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseTradingFee(data interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(data, "symbol")
    return map[string]interface{} {
        "info": data,
        "symbol": this.SafeSymbol(marketId, market),
        "maker": this.SafeNumber(data, "makerFeeRate"),
        "taker": this.SafeNumber(data, "takerFeeRate"),
        "percentage": nil,
        "tierBased": nil,
    }
}
func  (this *bitget) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1645911960000",
    //         "39406",
    //         "39407",
    //         "39374.5",
    //         "39379",
    //         "35.526",
    //         "1399132.341"
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name bitget#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.bitget.com/api-doc/spot/market/Get-Candle-Data
 * @see https://www.bitget.com/api-doc/spot/market/Get-History-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Index-Candle-Data
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Mark-Candle-Data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.useHistoryEndpoint] whether to force to use historical endpoint (it has max limit of 200)
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.price] *swap only* "mark" (to fetch mark price candles) or "index" (to fetch index price candles)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bitget) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35588 := (<-this.LoadMarkets())
            PanicOnError(retRes35588)
            var defaultLimit interface{} = 100 // default 100, max 1000
            var maxLimitForRecentEndpoint interface{} = 1000
            var maxLimitForHistoryEndpoint interface{} = 200 // note, max 1000 bars are supported for "recent-candles" endpoint, but "historical-candles" support only max 200
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes356519 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimitForRecentEndpoint))
                    PanicOnError(retRes356519)
                    ch <- retRes356519
                    return nil
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var useHistoryEndpoint interface{} = this.SafeBool(params, "useHistoryEndpoint", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var marketType interface{} = Ternary(IsTrue(GetValue(market, "spot")), "spot", "swap")
            var timeframes interface{} = GetValue(GetValue(this.Options, "timeframes"), marketType)
            var msInDay interface{} = 86400000
            var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "granularity": this.SafeString(timeframes, timeframe, timeframe),
            }
            var until interface{} = this.SafeInteger(params, "until")
            var limitDefined interface{} = !IsEqual(limit, nil)
            var sinceDefined interface{} = !IsEqual(since, nil)
            var untilDefined interface{} = !IsEqual(until, nil)
            params = this.Omit(params, []interface{}{"until"})
            var response interface{} = nil
            var now interface{} = this.Milliseconds()
            // retrievable periods listed here:
            // - https://www.bitget.com/api-doc/spot/market/Get-Candle-Data#request-parameters
            // - https://www.bitget.com/api-doc/contract/market/Get-Candle-Data#description
            var ohlcOptions interface{} = this.SafeDict(this.Options, "fetchOHLCV", map[string]interface{} {})
            var retrievableDaysMap interface{} = this.SafeDict(ohlcOptions, "maxDaysPerTimeframe", map[string]interface{} {})
            var maxRetrievableDaysForRecent interface{} = this.SafeInteger(retrievableDaysMap, timeframe, 30) // default to safe minimum
            var endpointTsBoundary interface{} = Subtract(now, Multiply((Subtract(maxRetrievableDaysForRecent, 1)), msInDay))
            if IsTrue(limitDefined) {
                limit = mathMin(limit, maxLimitForRecentEndpoint)
                AddElementToObject(request, "limit", limit)
            } else {
                limit = defaultLimit
            }
            var limitMultipliedDuration interface{} = Multiply(limit, duration)
            // exchange aligns from endTime, so it's important, not startTime
            // startTime is supported only on "recent" endpoint, not on "historical" endpoint
            var calculatedStartTime interface{} = nil
            var calculatedEndTime interface{} = nil
            if IsTrue(sinceDefined) {
                calculatedStartTime = since
                AddElementToObject(request, "startTime", since)
                if !IsTrue(untilDefined) {
                    calculatedEndTime = this.Sum(calculatedStartTime, limitMultipliedDuration)
                    AddElementToObject(request, "endTime", calculatedEndTime)
                }
            }
            if IsTrue(untilDefined) {
                calculatedEndTime = until
                AddElementToObject(request, "endTime", calculatedEndTime)
                if !IsTrue(sinceDefined) {
                    calculatedStartTime = Subtract(calculatedEndTime, limitMultipliedDuration)
                }
            }
            var historicalEndpointNeeded interface{} = IsTrue((!IsEqual(calculatedStartTime, nil))) && IsTrue((IsLessThanOrEqual(calculatedStartTime, endpointTsBoundary)))
            if IsTrue(historicalEndpointNeeded) {
                // only for "historical-candles" - ensure we use correct max limit
                if IsTrue(limitDefined) {
                    AddElementToObject(request, "limit", mathMin(limit, maxLimitForHistoryEndpoint))
                }
            }
            // make request
            if IsTrue(GetValue(market, "spot")) {
                // checks if we need history endpoint
                if IsTrue(IsTrue(historicalEndpointNeeded) || IsTrue(useHistoryEndpoint)) {
                    
        response = (<-this.PublicSpotGetV2SpotMarketHistoryCandles(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PublicSpotGetV2SpotMarketCandles(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var maxDistanceDaysForContracts interface{} = 90 // for contract, maximum 90 days allowed between start-end times
                // only correct the request to fix 90 days if until was auto-calculated
                if IsTrue(sinceDefined) {
                    if !IsTrue(untilDefined) {
                        AddElementToObject(request, "endTime", mathMin(calculatedEndTime, this.Sum(since, Multiply(maxDistanceDaysForContracts, msInDay))))
                    } else if IsTrue(IsGreaterThan(Subtract(calculatedEndTime, calculatedStartTime), Multiply(maxDistanceDaysForContracts, msInDay))) {
                        panic(BadRequest(Add(Add(Add(this.Id, " fetchOHLCV() between start and end must be less than "), ToString(maxDistanceDaysForContracts)), " days")))
                    }
                }
                var priceType interface{} = nil
                priceTypeparamsVariable := this.HandleParamString(params, "price");
                priceType = GetValue(priceTypeparamsVariable,0);
                params = GetValue(priceTypeparamsVariable,1)
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                var extended interface{} = this.Extend(request, params)
                // todo: mark & index also have their "recent" endpoints, but not priority now.
                if IsTrue(IsEqual(priceType, "mark")) {
                    
        response = (<-this.PublicMixGetV2MixMarketHistoryMarkCandles(extended))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(priceType, "index")) {
                    
        response = (<-this.PublicMixGetV2MixMarketHistoryIndexCandles(extended))
                    PanicOnError(response)
                } else {
                    if IsTrue(IsTrue(historicalEndpointNeeded) || IsTrue(useHistoryEndpoint)) {
                        
        response = (<-this.PublicMixGetV2MixMarketHistoryCandles(extended))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PublicMixGetV2MixMarketCandles(extended))
                        PanicOnError(response)
                    }
                }
            }
            if IsTrue(IsEqual(response, "")) {
        
                ch <- []interface{}{}  // happens when a new token is listed
                return nil
            }
            //  [ ["1645911960000","39406","39407","39374.5","39379","35.526","1399132.341"] ]
            var data interface{} = this.SafeList(response, "data", response)
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Assets
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-List
 * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Assets
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Get-Isolated-Assets
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-cross-assets
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-isolated-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitget) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes36928 := (<-this.LoadMarkets())
            PanicOnError(retRes36928)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = nil
            var marginMode interface{} = nil
            var response interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PrivateMixGetV2MixAccountAccounts(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "isolated")) {
                
        response = (<-this.PrivateMarginGetMarginV1IsolatedAccountAssets(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "cross")) {
                
        response = (<-this.PrivateMarginGetMarginV1CrossAccountAssets(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetV2SpotAccountAssets(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchBalance() does not support "), marketType), " accounts")))
            }
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700623852854,
            //         "data": [
            //             {
            //                 "coin": "USDT",
            //                 "available": "0.00000000",
            //                 "limitAvailable": "0",
            //                 "frozen": "0.00000000",
            //                 "locked": "0.00000000",
            //                 "uTime": "1699937566000"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700625127294,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "locked": "0",
            //                 "available": "0",
            //                 "crossedMaxAvailable": "0",
            //                 "isolatedMaxAvailable": "0",
            //                 "maxTransferOut": "0",
            //                 "accountEquity": "0",
            //                 "usdtEquity": "0.000000005166",
            //                 "btcEquity": "0",
            //                 "crossedRiskRate": "0",
            //                 "unrealizedPL": "0",
            //                 "coupon": "0",
            //                 "crossedUnrealizedPL": null,
            //                 "isolatedUnrealizedPL": null
            //             }
            //         ]
            //     }
            //
            // isolated margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1697501436571,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "coin": "BTC",
            //                 "totalAmount": "0.00021654",
            //                 "available": "0.00021654",
            //                 "transferable": "0.00021654",
            //                 "frozen": "0",
            //                 "borrow": "0",
            //                 "interest": "0",
            //                 "net": "0.00021654",
            //                 "ctime": "1697248128071"
            //             },
            //         ]
            //     }
            //
            // cross margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1697515463804,
            //         "data": [
            //             {
            //                 "coin": "BTC",
            //                 "totalAmount": "0.00024996",
            //                 "available": "0.00024996",
            //                 "transferable": "0.00004994",
            //                 "frozen": "0",
            //                 "borrow": "0.0001",
            //                 "interest": "0.00000001",
            //                 "net": "0.00014995",
            //                 "ctime": "1697251265504"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseBalance(balance interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": balance,
    }
    //
    // spot
    //
    //     {
    //         "coin": "USDT",
    //         "available": "0.00000000",
    //         "limitAvailable": "0",
    //         "frozen": "0.00000000",
    //         "locked": "0.00000000",
    //         "uTime": "1699937566000"
    //     }
    //
    // swap
    //
    //     {
    //         "marginCoin": "USDT",
    //         "locked": "0",
    //         "available": "0",
    //         "crossedMaxAvailable": "0",
    //         "isolatedMaxAvailable": "0",
    //         "maxTransferOut": "0",
    //         "accountEquity": "0",
    //         "usdtEquity": "0.000000005166",
    //         "btcEquity": "0",
    //         "crossedRiskRate": "0",
    //         "unrealizedPL": "0",
    //         "coupon": "0",
    //         "crossedUnrealizedPL": null,
    //         "isolatedUnrealizedPL": null
    //     }
    //
    // isolated margin
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "coin": "BTC",
    //         "totalAmount": "0.00021654",
    //         "available": "0.00021654",
    //         "transferable": "0.00021654",
    //         "frozen": "0",
    //         "borrow": "0",
    //         "interest": "0",
    //         "net": "0.00021654",
    //         "ctime": "1697248128071"
    //     }
    //
    // cross margin
    //
    //     {
    //         "coin": "BTC",
    //         "totalAmount": "0.00024995",
    //         "available": "0.00024995",
    //         "transferable": "0.00004993",
    //         "frozen": "0",
    //         "borrow": "0.0001",
    //         "interest": "0.00000001",
    //         "net": "0.00014994",
    //         "ctime": "1697251265504"
    //     }
    //
    for i := 0; IsLessThan(i, GetArrayLength(balance)); i++ {
        var entry interface{} = GetValue(balance, i)
        var account interface{} = this.Account()
        var currencyId interface{} = this.SafeString2(entry, "marginCoin", "coin")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var borrow interface{} = this.SafeString(entry, "borrow")
        if IsTrue(!IsEqual(borrow, nil)) {
            var interest interface{} = this.SafeString(entry, "interest")
            AddElementToObject(account, "free", this.SafeString(entry, "transferable"))
            AddElementToObject(account, "total", this.SafeString(entry, "totalAmount"))
            AddElementToObject(account, "debt", Precise.StringAdd(borrow, interest))
        } else {
            // Use transferable instead of available for swap and margin https://github.com/ccxt/ccxt/pull/19127
            var spotAccountFree interface{} = this.SafeString(entry, "available")
            var contractAccountFree interface{} = this.SafeString(entry, "maxTransferOut")
            if IsTrue(!IsEqual(contractAccountFree, nil)) {
                AddElementToObject(account, "free", contractAccountFree)
                AddElementToObject(account, "total", this.SafeString(entry, "accountEquity"))
            } else {
                AddElementToObject(account, "free", spotAccountFree)
                var frozen interface{} = this.SafeString(entry, "frozen")
                var locked interface{} = this.SafeString(entry, "locked")
                AddElementToObject(account, "used", Precise.StringAdd(frozen, locked))
            }
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
func  (this *bitget) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "new": "open",
        "init": "open",
        "not_trigger": "open",
        "partial_fill": "open",
        "partially_fill": "open",
        "partially_filled": "open",
        "triggered": "closed",
        "full_fill": "closed",
        "filled": "closed",
        "fail_trigger": "rejected",
        "cancel": "canceled",
        "cancelled": "canceled",
        "canceled": "canceled",
        "live": "open",
        "fail_execute": "rejected",
        "executed": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitget) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, editOrder, closePosition
    //
    //     {
    //         "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd479",
    //         "orderId": null
    //     }
    //
    // createOrders
    //
    //     [
    //         {
    //             "orderId": "1111397214281175046",
    //             "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
    //         },
    //         {
    //             "orderId": "",
    //             "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
    //             "errorMsg": "less than the minimum amount 5 USDT",
    //             "errorCode": "45110"
    //         },
    //     ]
    //
    // spot, swap, future and spot margin: cancelOrder, cancelOrders
    //
    //     {
    //         "orderId": "1098758604547850241",
    //         "clientOid": "1098758604585598977"
    //     }
    //
    // spot trigger: cancelOrder
    //
    //     {
    //         "result": "success"
    //     }
    //
    // spot: fetchOrder
    //
    //     {
    //         "userId": "7264631750",
    //         "symbol": "BTCUSDT",
    //         "orderId": "1111461743123927040",
    //         "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
    //         "price": "25000.0000000000000000",
    //         "size": "0.0002000000000000",
    //         "orderType": "limit",
    //         "side": "buy",
    //         "status": "live",
    //         "priceAvg": "0",
    //         "baseVolume": "0.0000000000000000",
    //         "quoteVolume": "0.0000000000000000",
    //         "enterPointSource": "API",
    //         "feeDetail": "",
    //         "orderSource": "normal",
    //         "cTime": "1700719050198",
    //         "uTime": "1700719050198"
    //     }
    //
    // swap and future: fetchOrder
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "size": "0.001",
    //         "orderId": "1111465253393825792",
    //         "clientOid": "1111465253431574529",
    //         "baseVolume": "0",
    //         "fee": "0",
    //         "price": "27000",
    //         "priceAvg": "",
    //         "state": "live",
    //         "side": "buy",
    //         "force": "gtc",
    //         "totalProfits": "0",
    //         "posSide": "long",
    //         "marginCoin": "USDT",
    //         "presetStopSurplusPrice": "",
    //         "presetStopLossPrice": "",
    //         "quoteVolume": "0",
    //         "orderType": "limit",
    //         "leverage": "20",
    //         "marginMode": "crossed",
    //         "reduceOnly": "NO",
    //         "enterPointSource": "API",
    //         "tradeSide": "open",
    //         "posMode": "hedge_mode",
    //         "orderSource": "normal",
    //         "cTime": "1700719887120",
    //         "uTime": "1700719887120"
    //     }
    //
    // spot: fetchOpenOrders
    //
    //     {
    //         "userId": "7264631750",
    //         "symbol": "BTCUSDT",
    //         "orderId": "1111499608327360513",
    //         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
    //         "priceAvg": "25000.0000000000000000",
    //         "size": "0.0002000000000000",
    //         "orderType": "limit",
    //         "side": "buy",
    //         "status": "live",
    //         "basePrice": "0",
    //         "baseVolume": "0.0000000000000000",
    //         "quoteVolume": "0.0000000000000000",
    //         "enterPointSource": "WEB",
    //         "orderSource": "normal",
    //         "cTime": "1700728077966",
    //         "uTime": "1700728077966"
    //     }
    //
    // spot stop: fetchOpenOrders, fetchCanceledAndClosedOrders
    //
    //     {
    //         "orderId": "1111503385931620352",
    //         "clientOid": "1111503385910648832",
    //         "symbol": "BTCUSDT",
    //         "size": "0.0002",
    //         "planType": "AMOUNT",
    //         "executePrice": "25000",
    //         "triggerPrice": "26000",
    //         "status": "live",
    //         "orderType": "limit",
    //         "side": "buy",
    //         "triggerType": "fill_price",
    //         "enterPointSource": "API",
    //         "cTime": "1700728978617",
    //         "uTime": "1700728978617"
    //     }
    //
    // spot margin: fetchOpenOrders, fetchCanceledAndClosedOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderType": "limit",
    //         "enterPointSource": "WEB",
    //         "orderId": "1111506377509580801",
    //         "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
    //         "loanType": "autoLoanAndRepay",
    //         "price": "25000",
    //         "side": "buy",
    //         "status": "live",
    //         "baseSize": "0.0002",
    //         "quoteSize": "5",
    //         "priceAvg": "0",
    //         "size": "0",
    //         "amount": "0",
    //         "force": "gtc",
    //         "cTime": "1700729691866",
    //         "uTime": "1700729691866"
    //     }
    //
    // swap: fetchOpenOrders, fetchCanceledAndClosedOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "size": "0.002",
    //         "orderId": "1111488897767604224",
    //         "clientOid": "1111488897805352960",
    //         "baseVolume": "0",
    //         "fee": "0",
    //         "price": "25000",
    //         "priceAvg": "",
    //         "status": "live",
    //         "side": "buy",
    //         "force": "gtc",
    //         "totalProfits": "0",
    //         "posSide": "long",
    //         "marginCoin": "USDT",
    //         "quoteVolume": "0",
    //         "leverage": "20",
    //         "marginMode": "crossed",
    //         "enterPointSource": "web",
    //         "tradeSide": "open",
    //         "posMode": "hedge_mode",
    //         "orderType": "limit",
    //         "orderSource": "normal",
    //         "presetStopSurplusPrice": "",
    //         "presetStopLossPrice": "",
    //         "reduceOnly": "NO",
    //         "cTime": "1700725524378",
    //         "uTime": "1700725524378"
    //     }
    //
    // swap stop: fetchOpenOrders
    //
    //     {
    //         "planType": "normal_plan",
    //         "symbol": "BTCUSDT",
    //         "size": "0.001",
    //         "orderId": "1111491399869075457",
    //         "clientOid": "1111491399869075456",
    //         "price": "27000",
    //         "callbackRatio": "",
    //         "triggerPrice": "24000",
    //         "triggerType": "mark_price",
    //         "planStatus": "live",
    //         "side": "buy",
    //         "posSide": "long",
    //         "marginCoin": "USDT",
    //         "marginMode": "crossed",
    //         "enterPointSource": "API",
    //         "tradeSide": "open",
    //         "posMode": "hedge_mode",
    //         "orderType": "limit",
    //         "stopSurplusTriggerPrice": "",
    //         "stopSurplusExecutePrice": "",
    //         "stopSurplusTriggerType": "fill_price",
    //         "stopLossTriggerPrice": "",
    //         "stopLossExecutePrice": "",
    //         "stopLossTriggerType": "fill_price",
    //         "cTime": "1700726120917",
    //         "uTime": "1700726120917"
    //     }
    //
    // spot: fetchCanceledAndClosedOrders
    //
    //     {
    //         "userId": "7264631750",
    //         "symbol": "BTCUSDT",
    //         "orderId": "1111499608327360513",
    //         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
    //         "price": "25000.0000000000000000",
    //         "size": "0.0002000000000000",
    //         "orderType": "limit",
    //         "side": "buy",
    //         "status": "cancelled",
    //         "priceAvg": "0",
    //         "baseVolume": "0.0000000000000000",
    //         "quoteVolume": "0.0000000000000000",
    //         "enterPointSource": "WEB",
    //         "feeDetail": "",
    //         "orderSource": "normal",
    //         "cTime": "1700728077966",
    //         "uTime": "1700728911471"
    //     }
    //
    // swap stop: fetchCanceledAndClosedOrders
    //
    //     {
    //         "planType": "normal_plan",
    //         "symbol": "BTCUSDT",
    //         "size": "0.001",
    //         "orderId": "1111491399869075457",
    //         "clientOid": "1111491399869075456",
    //         "planStatus": "cancelled",
    //         "price": "27000",
    //         "feeDetail": null,
    //         "baseVolume": "0",
    //         "callbackRatio": "",
    //         "triggerPrice": "24000",
    //         "triggerType": "mark_price",
    //         "side": "buy",
    //         "posSide": "long",
    //         "marginCoin": "USDT",
    //         "marginMode": "crossed",
    //         "enterPointSource": "API",
    //         "tradeSide": "open",
    //         "posMode": "hedge_mode",
    //         "orderType": "limit",
    //         "stopSurplusTriggerPrice": "",
    //         "stopSurplusExecutePrice": "",
    //         "stopSurplusTriggerType": "fill_price",
    //         "stopLossTriggerPrice": "",
    //         "stopLossExecutePrice": "",
    //         "stopLossTriggerType": "fill_price",
    //         "cTime": "1700726120917",
    //         "uTime": "1700727879652"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var errorMessage interface{} = this.SafeString(order, "errorMsg")
    if IsTrue(!IsEqual(errorMessage, nil)) {
        return this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": this.SafeString(order, "orderId"),
            "clientOrderId": this.SafeString2(order, "clientOrderId", "clientOid"),
            "status": "rejected",
        }, market)
    }
    var isContractOrder interface{} =     (InOp(order, "posSide"))
    var marketType interface{} = Ternary(IsTrue(isContractOrder), "contract", "spot")
    if IsTrue(!IsEqual(market, nil)) {
        marketType = GetValue(market, "type")
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market, nil, marketType)
    var timestamp interface{} = this.SafeInteger2(order, "cTime", "ctime")
    var updateTimestamp interface{} = this.SafeInteger(order, "uTime")
    var rawStatus interface{} = this.SafeString2(order, "status", "state")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(order, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        // swap
        fee = map[string]interface{} {
            "cost": this.ParseNumber(Precise.StringNeg(feeCostString)),
            "currency": GetValue(market, "settle"),
        }
    }
    var feeDetail interface{} = this.SafeValue(order, "feeDetail")
    if IsTrue(!IsEqual(feeDetail, nil)) {
        var parsedFeeDetail interface{} = JsonParse(feeDetail)
        var feeValues interface{} = ObjectValues(parsedFeeDetail)
        var feeObject interface{} = nil
        for i := 0; IsLessThan(i, GetArrayLength(feeValues)); i++ {
            var feeValue interface{} = GetValue(feeValues, i)
            if IsTrue(!IsEqual(this.SafeValue(feeValue, "feeCoinCode"), nil)) {
                feeObject = feeValue
                break
            }
        }
        fee = map[string]interface{} {
            "cost": this.ParseNumber(Precise.StringNeg(this.SafeString(feeObject, "totalFee"))),
            "currency": this.SafeCurrencyCode(this.SafeString(feeObject, "feeCoinCode")),
        }
    }
    var postOnly interface{} = nil
    var timeInForce interface{} = this.SafeStringUpper(order, "force")
    if IsTrue(IsEqual(timeInForce, "POST_ONLY")) {
        postOnly = true
        timeInForce = "PO"
    }
    var reduceOnly interface{} = nil
    var reduceOnlyRaw interface{} = this.SafeString(order, "reduceOnly")
    if IsTrue(!IsEqual(reduceOnlyRaw, nil)) {
        reduceOnly = Ternary(IsTrue((IsEqual(reduceOnlyRaw, "NO"))), false, true)
    }
    var price interface{} = nil
    var average interface{} = nil
    var basePrice interface{} = this.SafeString(order, "basePrice")
    if IsTrue(!IsEqual(basePrice, nil)) {
        // for spot fetchOpenOrders, the price is priceAvg and the filled price is basePrice
        price = this.SafeString(order, "priceAvg")
        average = this.SafeString(order, "basePrice")
    } else {
        price = this.SafeString2(order, "price", "executePrice")
        average = this.SafeString(order, "priceAvg")
    }
    var size interface{} = nil
    var filled interface{} = nil
    var baseSize interface{} = this.SafeString(order, "baseSize")
    if IsTrue(!IsEqual(baseSize, nil)) {
        // for spot margin fetchOpenOrders, the order size is baseSize and the filled amount is size
        size = baseSize
        filled = this.SafeString(order, "size")
    } else {
        size = this.SafeString(order, "size")
        filled = this.SafeString(order, "baseVolume")
    }
    var side interface{} = this.SafeString(order, "side")
    var posMode interface{} = this.SafeString(order, "posMode")
    if IsTrue(IsTrue(IsEqual(posMode, "hedge_mode")) && IsTrue(reduceOnly)) {
        side = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString2(order, "orderId", "data"),
        "clientOrderId": this.SafeString2(order, "clientOrderId", "clientOid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": updateTimestamp,
        "lastUpdateTimestamp": updateTimestamp,
        "symbol": GetValue(market, "symbol"),
        "type": this.SafeString(order, "orderType"),
        "side": side,
        "price": price,
        "amount": size,
        "cost": this.SafeString2(order, "quoteVolume", "quoteSize"),
        "average": average,
        "filled": filled,
        "remaining": nil,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "reduceOnly": reduceOnly,
        "triggerPrice": this.SafeNumber(order, "triggerPrice"),
        "takeProfitPrice": this.SafeNumber2(order, "presetStopSurplusPrice", "stopSurplusTriggerPrice"),
        "stopLossPrice": this.SafeNumber2(order, "presetStopLossPrice", "stopLossTriggerPrice"),
        "status": this.ParseOrderStatus(rawStatus),
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name bitget#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes43168 := (<-this.LoadMarkets())
            PanicOnError(retRes43168)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            var req interface{} = map[string]interface{} {
                "createMarketBuyOrderRequiresPrice": false,
            }
        
                retRes432415 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, this.Extend(req, params)))
                PanicOnError(retRes432415)
                ch <- retRes432415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#createOrder
 * @description create a trade order
 * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
 * @see https://www.bitget.com/api-doc/spot/plan/Place-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Place-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Place-Tpsl-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Place-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *spot only* how much you want to trade in units of the quote currency, for market buy orders only
 * @param {float} [params.triggerPrice] *swap only* The price at which a trigger order is triggered at
 * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {string} [params.loanType] *spot margin only* 'normal', 'autoLoan', 'autoRepay', or 'autoLoanAndRepay' default is 'normal'
 * @param {string} [params.holdSide] *contract stopLossPrice, takeProfitPrice only* Two-way position: ('long' or 'short'), one-way position: ('buy' or 'sell')
 * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
 * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
 * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
 * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
 * @param {string} [params.triggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
 * @param {boolean} [params.oneWayMode] *swap and future only* required to set this to true in one_way_mode and you can leave this as undefined in hedge_mode, can adjust the mode using the setPositionMode() method
 * @param {bool} [params.hedged] *swap and future only* true for hedged mode, false for one way mode, default is false
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes43698 := (<-this.LoadMarkets())
            PanicOnError(retRes43698)
            var market interface{} = this.Market(symbol)
            var marginParams interface{} = this.HandleMarginModeAndParams("createOrder", params)
            var marginMode interface{} = GetValue(marginParams, 0)
            var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
            var stopLossTriggerPrice interface{} = this.SafeValue(params, "stopLossPrice")
            var takeProfitTriggerPrice interface{} = this.SafeValue(params, "takeProfitPrice")
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRatio")
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
            var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
            var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.PrivateSpotPostV2SpotTradePlacePlanOrder(request))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marginMode, "isolated")) {
                    
        response = (<-this.PrivateMarginPostV2MarginIsolatedPlaceOrder(request))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marginMode, "cross")) {
                    
        response = (<-this.PrivateMarginPostV2MarginCrossedPlaceOrder(request))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateSpotPostV2SpotTradePlaceOrder(request))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(IsTrue(isTriggerOrder) || IsTrue(isTrailingPercentOrder)) {
                    
        response = (<-this.PrivateMixPostV2MixOrderPlacePlanOrder(request))
                    PanicOnError(response)
                } else if IsTrue(isStopLossOrTakeProfitTrigger) {
                    
        response = (<-this.PrivateMixPostV2MixOrderPlaceTpslOrder(request))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixPostV2MixOrderPlaceOrder(request))
                    PanicOnError(response)
                }
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1645932209602,
            //         "data": {
            //             "orderId": "881669078313766912",
            //             "clientOid": "iauIBf#a45b595f96474d888d0ada"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
    var market interface{} = nil
    if IsTrue(sandboxMode) {
        var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
        market = this.Market(sandboxSymbol)
    } else {
        market = this.Market(symbol)
    }
    var marketType interface{} = nil
    var marginMode interface{} = nil
    marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params);
    marketType = GetValue(marketTypeparamsVariable,0);
    params = GetValue(marketTypeparamsVariable,1)
    marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "orderType": typeVar,
    }
    var isMarketOrder interface{} = IsEqual(typeVar, "market")
    var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
    var stopLossTriggerPrice interface{} = this.SafeValue(params, "stopLossPrice")
    var takeProfitTriggerPrice interface{} = this.SafeValue(params, "takeProfitPrice")
    var stopLoss interface{} = this.SafeValue(params, "stopLoss")
    var takeProfit interface{} = this.SafeValue(params, "takeProfit")
    var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
    var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
    var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
    var isStopLoss interface{} = !IsEqual(stopLoss, nil)
    var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
    var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
    var isStopLossOrTakeProfit interface{} = IsTrue(isStopLoss) || IsTrue(isTakeProfit)
    var trailingTriggerPrice interface{} = this.SafeString(params, "trailingTriggerPrice", this.NumberToString(price))
    var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRatio")
    var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
    if IsTrue(IsGreaterThan(this.Sum(isTriggerOrder, isStopLossTriggerOrder, isTakeProfitTriggerOrder, isTrailingPercentOrder), 1)) {
        panic(ExchangeError(Add(this.Id, " createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")))
    }
    if IsTrue(IsEqual(typeVar, "limit")) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var triggerPriceType interface{} = this.SafeString2(params, "triggerPriceType", "triggerType", "mark_price")
    var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
    var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
    var exchangeSpecificTifParam interface{} = this.SafeString2(params, "force", "timeInForce")
    var postOnly interface{} = nil
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(exchangeSpecificTifParam, "post_only"), params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    var defaultTimeInForce interface{} = this.SafeStringUpper(this.Options, "defaultTimeInForce")
    var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce", defaultTimeInForce)
    if IsTrue(postOnly) {
        AddElementToObject(request, "force", "post_only")
    } else if IsTrue(IsEqual(timeInForce, "GTC")) {
        AddElementToObject(request, "force", "GTC")
    } else if IsTrue(IsEqual(timeInForce, "FOK")) {
        AddElementToObject(request, "force", "FOK")
    } else if IsTrue(IsEqual(timeInForce, "IOC")) {
        AddElementToObject(request, "force", "IOC")
    }
    params = this.Omit(params, []interface{}{"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "postOnly", "reduceOnly", "clientOrderId", "trailingPercent", "trailingTriggerPrice"})
    if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
        AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
        AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
        var productType interface{} = nil
        productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
        productType = GetValue(productTypeparamsVariable,0);
        params = GetValue(productTypeparamsVariable,1)
        AddElementToObject(request, "productType", productType)
        if IsTrue(!IsEqual(clientOrderId, nil)) {
            AddElementToObject(request, "clientOid", clientOrderId)
        }
        if IsTrue(IsTrue(IsTrue(isTriggerOrder) || IsTrue(isStopLossOrTakeProfitTrigger)) || IsTrue(isTrailingPercentOrder)) {
            AddElementToObject(request, "triggerType", triggerPriceType)
        }
        if IsTrue(isTrailingPercentOrder) {
            if !IsTrue(isMarketOrder) {
                panic(BadRequest(Add(this.Id, " createOrder() bitget trailing orders must be market orders")))
            }
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() bitget trailing orders must have a trailingTriggerPrice param")))
            }
            AddElementToObject(request, "planType", "track_plan")
            AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
            AddElementToObject(request, "callbackRatio", trailingPercent)
        } else if IsTrue(isTriggerOrder) {
            AddElementToObject(request, "planType", "normal_plan")
            AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(isStopLoss) {
                var slTriggerPrice interface{} = this.SafeNumber2(stopLoss, "triggerPrice", "stopPrice")
                AddElementToObject(request, "stopLossTriggerPrice", this.PriceToPrecision(symbol, slTriggerPrice))
                var slPrice interface{} = this.SafeNumber(stopLoss, "price")
                AddElementToObject(request, "stopLossExecutePrice", this.PriceToPrecision(symbol, slPrice))
                var slType interface{} = this.SafeString(stopLoss, "type", "mark_price")
                AddElementToObject(request, "stopLossTriggerType", slType)
            }
            if IsTrue(isTakeProfit) {
                var tpTriggerPrice interface{} = this.SafeNumber2(takeProfit, "triggerPrice", "stopPrice")
                AddElementToObject(request, "stopSurplusTriggerPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
                var tpPrice interface{} = this.SafeNumber(takeProfit, "price")
                AddElementToObject(request, "stopSurplusExecutePrice", this.PriceToPrecision(symbol, tpPrice))
                var tpType interface{} = this.SafeString(takeProfit, "type", "mark_price")
                AddElementToObject(request, "stopSurplusTriggerType", tpType)
            }
        } else if IsTrue(isStopLossOrTakeProfitTrigger) {
            if !IsTrue(isMarketOrder) {
                panic(ExchangeError(Add(this.Id, " createOrder() bitget stopLoss or takeProfit orders must be market orders")))
            }
            AddElementToObject(request, "holdSide", Ternary(IsTrue((IsEqual(side, "buy"))), "long", "short"))
            if IsTrue(isStopLossTriggerOrder) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, stopLossTriggerPrice))
                AddElementToObject(request, "planType", "pos_loss")
            } else if IsTrue(isTakeProfitTriggerOrder) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
                AddElementToObject(request, "planType", "pos_profit")
            }
        } else {
            if IsTrue(isStopLoss) {
                var slTriggerPrice interface{} = this.SafeValue2(stopLoss, "triggerPrice", "stopPrice")
                AddElementToObject(request, "presetStopLossPrice", this.PriceToPrecision(symbol, slTriggerPrice))
            }
            if IsTrue(isTakeProfit) {
                var tpTriggerPrice interface{} = this.SafeValue2(takeProfit, "triggerPrice", "stopPrice")
                AddElementToObject(request, "presetStopSurplusPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
            }
        }
        if !IsTrue(isStopLossOrTakeProfitTrigger) {
            if IsTrue(IsEqual(marginMode, nil)) {
                marginMode = "cross"
            }
            var marginModeRequest interface{} = Ternary(IsTrue((IsEqual(marginMode, "cross"))), "crossed", "isolated")
            AddElementToObject(request, "marginMode", marginModeRequest)
            var hedged interface{} = nil
            hedgedparamsVariable := this.HandleParamBool(params, "hedged", false);
            hedged = GetValue(hedgedparamsVariable,0);
            params = GetValue(hedgedparamsVariable,1)
            // backward compatibility for `oneWayMode`
            var oneWayMode interface{} = nil
            oneWayModeparamsVariable := this.HandleParamBool(params, "oneWayMode");
            oneWayMode = GetValue(oneWayModeparamsVariable,0);
            params = GetValue(oneWayModeparamsVariable,1)
            if IsTrue(!IsEqual(oneWayMode, nil)) {
                hedged = !IsTrue(oneWayMode)
            }
            var requestSide interface{} = side
            if IsTrue(reduceOnly) {
                if !IsTrue(hedged) {
                    AddElementToObject(request, "reduceOnly", "YES")
                } else {
                    // on bitget hedge mode if the position is long the side is always buy, and if the position is short the side is always sell
                    requestSide = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
                    AddElementToObject(request, "tradeSide", "Close")
                }
            } else {
                if IsTrue(hedged) {
                    AddElementToObject(request, "tradeSide", "Open")
                }
            }
            AddElementToObject(request, "side", requestSide)
        }
    } else if IsTrue(IsEqual(marketType, "spot")) {
        if IsTrue(IsTrue(isStopLossOrTakeProfitTrigger) || IsTrue(isStopLossOrTakeProfit)) {
            panic(InvalidOrder(Add(this.Id, " createOrder() does not support stop loss/take profit orders on spot markets, only swap markets")))
        }
        AddElementToObject(request, "side", side)
        var quantity interface{} = nil
        var planType interface{} = nil
        var createMarketBuyOrderRequiresPrice interface{} = true
        createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
        createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
        params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
        if IsTrue(IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))) {
            planType = "total"
            var cost interface{} = this.SafeNumber(params, "cost")
            params = this.Omit(params, "cost")
            if IsTrue(!IsEqual(cost, nil)) {
                quantity = this.CostToPrecision(symbol, cost)
            } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                } else {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
                    quantity = this.CostToPrecision(symbol, quoteAmount)
                }
            } else {
                quantity = this.CostToPrecision(symbol, amount)
            }
        } else {
            planType = "amount"
            quantity = this.AmountToPrecision(symbol, amount)
        }
        if IsTrue(!IsEqual(clientOrderId, nil)) {
            AddElementToObject(request, "clientOid", clientOrderId)
        }
        if IsTrue(!IsEqual(marginMode, nil)) {
            AddElementToObject(request, "loanType", "normal")
            if IsTrue(IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))) {
                AddElementToObject(request, "quoteSize", quantity)
            } else {
                AddElementToObject(request, "baseSize", quantity)
            }
        } else {
            if IsTrue(!IsEqual(quantity, nil)) {
                AddElementToObject(request, "size", quantity)
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "planType", planType)
                AddElementToObject(request, "triggerType", triggerPriceType)
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                if IsTrue(!IsEqual(price, nil)) {
                    AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
                }
            }
        }
    } else {
        panic(NotSupported(Add(Add(Add(this.Id, " createOrder() does not support "), marketType), " orders")))
    }
    return this.Extend(request, params)
}
/**
 * @method
 * @name bitget#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://www.bitget.com/api-doc/spot/trade/Batch-Place-Orders
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes46448 := (<-this.LoadMarkets())
            PanicOnError(retRes46448)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            var marginMode interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{} {})
                var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
                var currentMarginMode interface{} = GetValue(marginResult, 0)
                if IsTrue(!IsEqual(currentMarginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, nil)) {
                        marginMode = currentMarginMode
                    } else {
                        if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
                            panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
                        }
                    }
                }
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderList": ordersRequests,
            }
            var response interface{} = nil
            if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
                if IsTrue(IsEqual(marginMode, nil)) {
                    marginMode = "cross"
                }
                var marginModeRequest interface{} = Ternary(IsTrue((IsEqual(marginMode, "cross"))), "crossed", "isolated")
                AddElementToObject(request, "marginMode", marginModeRequest)
                AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PrivateMixPostV2MixOrderBatchPlaceOrder(request))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "isolated")) {
                
        response = (<-this.PrivateMarginPostV2MarginIsolatedBatchPlaceOrder(request))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "cross")) {
                
        response = (<-this.PrivateMarginPostV2MarginCrossedBatchPlaceOrder(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateSpotPostV2SpotTradeBatchOrders(request))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700703539416,
            //         "data": {
            //             "successList": [
            //                 {
            //                     "orderId": "1111397214281175046",
            //                     "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
            //                 },
            //             ],
            //             "failureList": [
            //                 {
            //                     "orderId": "",
            //                     "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
            //                     "errorMsg": "less than the minimum amount 5 USDT",
            //                     "errorCode": "45110"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var failure interface{} = this.SafeValue(data, "failureList", []interface{}{})
            var orderInfo interface{} = this.SafeValue(data, "successList", []interface{}{})
            var both interface{} = this.ArrayConcat(orderInfo, failure)
        
            ch <- this.ParseOrders(both, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#editOrder
 * @description edit a trade order
 * @see https://www.bitget.com/api-doc/spot/plan/Modify-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Modify-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Modify-Tpsl-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Modify-Plan-Order
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
 * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
 * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
 * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
 * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
 * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
 * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
 * @param {string} [params.newTriggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes47708 := (<-this.LoadMarkets())
            PanicOnError(retRes47708)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
            var isMarketOrder interface{} = IsEqual(typeVar, "market")
            var triggerPrice interface{} = this.SafeValue2(params, "stopPrice", "triggerPrice")
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            var stopLossPrice interface{} = this.SafeValue(params, "stopLossPrice")
            var isStopLossOrder interface{} = !IsEqual(stopLossPrice, nil)
            var takeProfitPrice interface{} = this.SafeValue(params, "takeProfitPrice")
            var isTakeProfitOrder interface{} = !IsEqual(takeProfitPrice, nil)
            var stopLoss interface{} = this.SafeValue(params, "stopLoss")
            var takeProfit interface{} = this.SafeValue(params, "takeProfit")
            var isStopLoss interface{} = !IsEqual(stopLoss, nil)
            var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
            var trailingTriggerPrice interface{} = this.SafeString(params, "trailingTriggerPrice", this.NumberToString(price))
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "newCallbackRatio")
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            if IsTrue(IsGreaterThan(this.Sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder, isTrailingPercentOrder), 1)) {
                panic(ExchangeError(Add(this.Id, " editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
            }
            params = this.Omit(params, []interface{}{"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "clientOrderId", "trailingTriggerPrice", "trailingPercent"})
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(IsEqual(triggerPrice, nil)) {
                    panic(NotSupported(Add(this.Id, " editOrder() only supports plan/trigger spot orders")))
                }
                var editMarketBuyOrderRequiresPrice interface{} = this.SafeBool(this.Options, "editMarketBuyOrderRequiresPrice", true)
                if IsTrue(IsTrue(IsTrue(editMarketBuyOrderRequiresPrice) && IsTrue(isMarketOrder)) && IsTrue((IsEqual(side, "buy")))) {
                    if IsTrue(IsEqual(price, nil)) {
                        panic(InvalidOrder(Add(this.Id, " editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the editMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")))
                    } else {
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var cost interface{} = this.ParseNumber(Precise.StringMul(amountString, priceString))
                        AddElementToObject(request, "size", this.PriceToPrecision(symbol, cost))
                    }
                } else {
                    AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
                }
                AddElementToObject(request, "orderType", typeVar)
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
                
        response = (<-this.PrivateSpotPostV2SpotTradeModifyPlanOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsTrue((!IsTrue(GetValue(market, "swap")))) && IsTrue((!IsTrue(GetValue(market, "future"))))) {
                    panic(NotSupported(Add(Add(Add(this.Id, " editOrder() does not support "), GetValue(market, "type")), " orders")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(!IsTrue(isTakeProfitOrder) && !IsTrue(isStopLossOrder)) {
                    AddElementToObject(request, "newSize", this.AmountToPrecision(symbol, amount))
                    if IsTrue(IsTrue((!IsEqual(price, nil))) && !IsTrue(isTrailingPercentOrder)) {
                        AddElementToObject(request, "newPrice", this.PriceToPrecision(symbol, price))
                    }
                }
                if IsTrue(isTrailingPercentOrder) {
                    if !IsTrue(isMarketOrder) {
                        panic(BadRequest(Add(this.Id, " editOrder() bitget trailing orders must be market orders")))
                    }
                    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
                        AddElementToObject(request, "newTriggerPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
                    }
                    AddElementToObject(request, "newCallbackRatio", trailingPercent)
                    
        response = (<-this.PrivateMixPostV2MixOrderModifyPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsTrue(isTakeProfitOrder) || IsTrue(isStopLossOrder)) {
                    AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                    AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
                    AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
                    if IsTrue(isStopLossOrder) {
                        AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, stopLossPrice))
                    } else if IsTrue(isTakeProfitOrder) {
                        AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, takeProfitPrice))
                    }
                    
        response = (<-this.PrivateMixPostV2MixOrderModifyTpslOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(isTriggerOrder) {
                    AddElementToObject(request, "newTriggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                    if IsTrue(isStopLoss) {
                        var slTriggerPrice interface{} = this.SafeNumber2(stopLoss, "triggerPrice", "stopPrice")
                        AddElementToObject(request, "newStopLossTriggerPrice", this.PriceToPrecision(symbol, slTriggerPrice))
                        var slPrice interface{} = this.SafeNumber(stopLoss, "price")
                        AddElementToObject(request, "newStopLossExecutePrice", this.PriceToPrecision(symbol, slPrice))
                        var slType interface{} = this.SafeString(stopLoss, "type", "mark_price")
                        AddElementToObject(request, "newStopLossTriggerType", slType)
                    }
                    if IsTrue(isTakeProfit) {
                        var tpTriggerPrice interface{} = this.SafeNumber2(takeProfit, "triggerPrice", "stopPrice")
                        AddElementToObject(request, "newSurplusTriggerPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
                        var tpPrice interface{} = this.SafeNumber(takeProfit, "price")
                        AddElementToObject(request, "newStopSurplusExecutePrice", this.PriceToPrecision(symbol, tpPrice))
                        var tpType interface{} = this.SafeString(takeProfit, "type", "mark_price")
                        AddElementToObject(request, "newStopSurplusTriggerType", tpType)
                    }
                    
        response = (<-this.PrivateMixPostV2MixOrderModifyPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    var defaultNewClientOrderId interface{} = this.Uuid()
                    var newClientOrderId interface{} = this.SafeString2(params, "newClientOid", "newClientOrderId", defaultNewClientOrderId)
                    params = this.Omit(params, "newClientOrderId")
                    AddElementToObject(request, "newClientOid", newClientOrderId)
                    if IsTrue(isStopLoss) {
                        var slTriggerPrice interface{} = this.SafeValue2(stopLoss, "triggerPrice", "stopPrice")
                        AddElementToObject(request, "newPresetStopLossPrice", this.PriceToPrecision(symbol, slTriggerPrice))
                    }
                    if IsTrue(isTakeProfit) {
                        var tpTriggerPrice interface{} = this.SafeValue2(takeProfit, "triggerPrice", "stopPrice")
                        AddElementToObject(request, "newPresetStopSurplusPrice", this.PriceToPrecision(symbol, tpTriggerPrice))
                    }
                    
        response = (<-this.PrivateMixPostV2MixOrderModifyOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700708275737,
            //         "data": {
            //             "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd459",
            //             "orderId": null
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#cancelOrder
 * @description cancels an open order
 * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Order
 * @see https://www.bitget.com/api-doc/spot/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Cancel-Order
 * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Cancel-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Cancel-Order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] set to true for canceling trigger orders
 * @param {string} [params.planType] *swap only* either profit_plan, loss_plan, normal_plan, pos_profit, pos_loss, moving_plan or track_plan
 * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes49328 := (<-this.LoadMarkets())
            PanicOnError(retRes49328)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var marginMode interface{} = nil
            var response interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var request interface{} = map[string]interface{} {}
            var trailing interface{} = this.SafeValue(params, "trailing")
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger", "trailing"})
            if !IsTrue((IsTrue(GetValue(market, "spot")) && IsTrue(trigger))) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if !IsTrue((IsTrue((IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future")))) && IsTrue(trigger))) {
                AddElementToObject(request, "orderId", id)
            }
            if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(IsTrue(trigger) || IsTrue(trailing)) {
                    var orderIdList interface{} = []interface{}{}
                    var orderId interface{} = map[string]interface{} {
                        "orderId": id,
                    }
                    AppendToArray(&orderIdList,orderId)
                    AddElementToObject(request, "orderIdList", orderIdList)
                }
                if IsTrue(trailing) {
                    var planType interface{} = this.SafeString(params, "planType", "track_plan")
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(trigger) {
                    
        response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixPostV2MixOrderCancelOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, "isolated")) {
                        
        response = (<-this.PrivateMarginPostV2MarginIsolatedCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginPostV2MarginCrossedCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    if IsTrue(trigger) {
                        
        response = (<-this.PrivateSpotPostV2SpotTradeCancelPlanOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivateSpotPostV2SpotTradeCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelOrder() does not support "), GetValue(market, "type")), " orders")))
            }
            //
            // spot, swap, future and spot margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1697690413177,
            //         "data": {
            //             "orderId": "1098758604547850241",
            //             "clientOid": "1098758604585598977"
            //         }
            //     }
            //
            // swap trigger
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700711311791,
            //         "data": {
            //             "successList": [
            //                 {
            //                     "clientOid": "1111428059067125760",
            //                     "orderId": "1111428059067125761"
            //                 }
            //             ],
            //             "failureList": []
            //         }
            //     }
            //
            // spot trigger
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700711728063,
            //         "data": {
            //             "result": "success"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var order interface{} = nil
            if IsTrue(IsTrue((IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future")))) && IsTrue(trigger)) {
                var orderInfo interface{} = this.SafeValue(data, "successList", []interface{}{})
                order = GetValue(orderInfo, 0)
            } else {
                order = data
            }
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#cancelOrders
 * @description cancel multiple orders
 * @see https://www.bitget.com/api-doc/spot/trade/Batch-Cancel-Orders
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
 * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Cancel-Order
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Cancel-Orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
 * @returns {object} an array of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes50648 := (<-this.LoadMarkets())
            PanicOnError(retRes50648)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var orderIdList interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var individualId interface{} = GetValue(ids, i)
                var orderId interface{} = map[string]interface{} {
                    "orderId": individualId,
                }
                AppendToArray(&orderIdList,orderId)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue((IsEqual(marginMode, nil)))) {
                AddElementToObject(request, "orderList", orderIdList)
            } else {
                AddElementToObject(request, "orderIdList", orderIdList)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginPostV2MarginCrossedBatchCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivateMarginPostV2MarginIsolatedBatchCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    
        response = (<-this.PrivateSpotPostV2SpotTradeBatchCancelOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(trigger) {
                    
        response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixPostV2MixOrderBatchCancelOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": "1680008815965",
            //         "data": {
            //             "successList": [
            //                 {
            //                     "orderId": "1024598257429823488",
            //                     "clientOid": "876493ce-c287-4bfc-9f4a-8b1905881313"
            //                 },
            //             ],
            //             "failureList": []
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "successList", []interface{}{})
        
            ch <- this.ParseOrders(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#cancelAllOrders
 * @description cancel all open orders
 * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Symbol-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Batch-Cancel-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#isolated-batch-cancel-orders
 * @see https://bitgetlimited.github.io/apidoc/en/margin/#cross-batch-cancel-order
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
 * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes51548 := (<-this.LoadMarkets())
            PanicOnError(retRes51548)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginPostMarginV1CrossOrderBatchCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivateMarginPostMarginV1IsolatedOrderBatchCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    if IsTrue(trigger) {
                        var stopRequest interface{} = map[string]interface{} {
                            "symbolList": []interface{}{GetValue(market, "id")},
                        }
                        
        response = (<-this.PrivateSpotPostV2SpotTradeBatchCancelPlanOrder(this.Extend(stopRequest, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivateSpotPostV2SpotTradeCancelSymbolOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1700716953996,
                    //         "data": {
                    //             "symbol": "BTCUSDT"
                    //         }
                    //     }
                    //
                    var timestamp interface{} = this.SafeInteger(response, "requestTime")
                    var responseData interface{} = this.SafeDict(response, "data")
                    var marketId interface{} = this.SafeString(responseData, "symbol")
        
                    ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
            "symbol": this.SafeSymbol(marketId, nil, nil, "spot"),
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
        })}
                    return nil
                }
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(trigger) {
                    
        response = (<-this.PrivateMixPostV2MixOrderCancelPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixPostV2MixOrderBatchCancelOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            var data interface{} = this.SafeDict(response, "data")
            var resultList interface{} = this.SafeList2(data, "resultList", "successList")
            var failureList interface{} = this.SafeList2(data, "failure", "failureList")
            var responseList interface{} = this.ArrayConcat(resultList, failureList)
        
            ch <- this.ParseOrders(responseList)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Order-Info
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Details
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes52718 := (<-this.LoadMarkets())
            PanicOnError(retRes52718)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PrivateSpotGetV2SpotTradeOrderInfo(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PrivateMixGetV2MixOrderDetail(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOrder() does not support "), GetValue(market, "type")), " orders")))
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700719076263,
            //         "data": [
            //             {
            //                 "userId": "7264631750",
            //                 "symbol": "BTCUSDT",
            //                 "orderId": "1111461743123927040",
            //                 "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
            //                 "price": "25000.0000000000000000",
            //                 "size": "0.0002000000000000",
            //                 "orderType": "limit",
            //                 "side": "buy",
            //                 "status": "live",
            //                 "priceAvg": "0",
            //                 "baseVolume": "0.0000000000000000",
            //                 "quoteVolume": "0.0000000000000000",
            //                 "enterPointSource": "API",
            //                 "feeDetail": "",
            //                 "orderSource": "normal",
            //                 "cTime": "1700719050198",
            //                 "uTime": "1700719050198"
            //             }
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700719918781,
            //         "data": {
            //             "symbol": "BTCUSDT",
            //             "size": "0.001",
            //             "orderId": "1111465253393825792",
            //             "clientOid": "1111465253431574529",
            //             "baseVolume": "0",
            //             "fee": "0",
            //             "price": "27000",
            //             "priceAvg": "",
            //             "state": "live",
            //             "side": "buy",
            //             "force": "gtc",
            //             "totalProfits": "0",
            //             "posSide": "long",
            //             "marginCoin": "USDT",
            //             "presetStopSurplusPrice": "",
            //             "presetStopLossPrice": "",
            //             "quoteVolume": "0",
            //             "orderType": "limit",
            //             "leverage": "20",
            //             "marginMode": "crossed",
            //             "reduceOnly": "NO",
            //             "enterPointSource": "API",
            //             "tradeSide": "open",
            //             "posMode": "hedge_mode",
            //             "orderSource": "normal",
            //             "cTime": "1700719887120",
            //             "uTime": "1700719887120"
            //         }
            //     }
            //
            if IsTrue(IsString(response)) {
                response = JsonParse(response)
            }
            var data interface{} = this.SafeDict(response, "data")
            if IsTrue((!IsEqual(data, nil))) {
                if !IsTrue(IsArray(data)) {
        
                    ch <- this.ParseOrder(data, market)
                    return nil
                }
            }
            var dataList interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(dataList, 0, map[string]interface{} {})
        
            ch <- this.ParseOrder(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Unfilled-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-Current-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-Pending
 * @see https://www.bitget.com/api-doc/contract/plan/get-orders-plan-pending
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Open-Orders
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Open-Orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes54018 := (<-this.LoadMarkets())
            PanicOnError(retRes54018)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            var typeVar interface{} = nil
            var request interface{} = map[string]interface{} {}
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(!IsEqual(symbol, nil)) {
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(symbol)
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var defaultType interface{} = this.SafeString2(this.Options, "fetchOpenOrders", "defaultType", "spot")
                var marketType interface{} = Ternary(IsTrue((InOp(market, "type"))), GetValue(market, "type"), defaultType)
                typeVar = this.SafeString(params, "type", marketType)
            } else {
                var defaultType interface{} = this.SafeString2(this.Options, "fetchOpenOrders", "defaultType", "spot")
                typeVar = this.SafeString(params, "type", defaultType)
            }
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
                var cursorReceived interface{} = nil
                if IsTrue(IsEqual(typeVar, "spot")) {
                    if IsTrue(!IsEqual(marginMode, nil)) {
                        cursorReceived = "minId"
                    }
                } else {
                    cursorReceived = "endId"
                }
        
                    retRes543419 :=  (<-this.FetchPaginatedCallCursor("fetchOpenOrders", symbol, since, limit, params, cursorReceived, "idLessThan"))
                    PanicOnError(retRes543419)
                    ch <- retRes543419
                    return nil
            }
            var response interface{} = nil
            var trailing interface{} = this.SafeBool(params, "trailing")
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            var planTypeDefined interface{} = !IsEqual(this.SafeString(params, "planType"), nil)
            var isTrigger interface{} =     (IsTrue(trigger) || IsTrue(planTypeDefined))
            params = this.Omit(params, []interface{}{"stop", "trigger", "trailing"})
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future")))) || IsTrue((!IsEqual(marginMode, nil)))) {
                var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
                params = this.Omit(params, "clientOrderId")
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "clientOid", clientOrderId)
                }
            }
            var query interface{} = nil
            query = this.Omit(params, []interface{}{"type"})
            if IsTrue(IsEqual(typeVar, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(since, nil)) {
                        since = Subtract(this.Milliseconds(), 7776000000)
                        AddElementToObject(request, "startTime", since)
                    }
                    if IsTrue(IsEqual(marginMode, "isolated")) {
                        
        response = (<-this.PrivateMarginGetV2MarginIsolatedOpenOrders(this.Extend(request, query)))
                        PanicOnError(response)
                    } else if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginGetV2MarginCrossedOpenOrders(this.Extend(request, query)))
                        PanicOnError(response)
                    }
                } else {
                    if IsTrue(trigger) {
                        
        response = (<-this.PrivateSpotGetV2SpotTradeCurrentPlanOrder(this.Extend(request, query)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivateSpotGetV2SpotTradeUnfilledOrders(this.Extend(request, query)))
                        PanicOnError(response)
                    }
                }
            } else {
                var productType interface{} = nil
                productTypequeryVariable := this.HandleProductTypeAndParams(market, query);
                productType = GetValue(productTypequeryVariable,0);
                query = GetValue(productTypequeryVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(trailing) {
                    var planType interface{} = this.SafeString(params, "planType", "track_plan")
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersPlanPending(this.Extend(request, query)))
                    PanicOnError(response)
                } else if IsTrue(isTrigger) {
                    var planType interface{} = this.SafeString(query, "planType", "normal_plan")
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersPlanPending(this.Extend(request, query)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersPending(this.Extend(request, query)))
                    PanicOnError(response)
                }
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700728123994,
            //         "data": [
            //             {
            //                 "userId": "7264631750",
            //                 "symbol": "BTCUSDT",
            //                 "orderId": "1111499608327360513",
            //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
            //                 "priceAvg": "25000.0000000000000000",
            //                 "size": "0.0002000000000000",
            //                 "orderType": "limit",
            //                 "side": "buy",
            //                 "status": "live",
            //                 "basePrice": "0",
            //                 "baseVolume": "0.0000000000000000",
            //                 "quoteVolume": "0.0000000000000000",
            //                 "enterPointSource": "WEB",
            //                 "orderSource": "normal",
            //                 "cTime": "1700728077966",
            //                 "uTime": "1700728077966"
            //             }
            //         ]
            //     }
            //
            // spot stop
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700729361609,
            //         "data": {
            //             "nextFlag": false,
            //             "idLessThan": "1111503385931620352",
            //             "orderList": [
            //                 {
            //                     "orderId": "1111503385931620352",
            //                     "clientOid": "1111503385910648832",
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.0002",
            //                     "planType": "AMOUNT",
            //                     "executePrice": "25000",
            //                     "triggerPrice": "26000",
            //                     "status": "live",
            //                     "orderType": "limit",
            //                     "side": "buy",
            //                     "triggerType": "fill_price",
            //                     "enterPointSource": "API",
            //                     "cTime": "1700728978617",
            //                     "uTime": "1700728978617"
            //                 }
            //             ]
            //         }
            //     }
            //
            // spot margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700729887686,
            //         "data": {
            //             "orderList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "orderType": "limit",
            //                     "enterPointSource": "WEB",
            //                     "orderId": "1111506377509580801",
            //                     "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
            //                     "loanType": "autoLoanAndRepay",
            //                     "price": "25000",
            //                     "side": "buy",
            //                     "status": "live",
            //                     "baseSize": "0.0002",
            //                     "quoteSize": "5",
            //                     "priceAvg": "0",
            //                     "size": "0",
            //                     "amount": "0",
            //                     "force": "gtc",
            //                     "cTime": "1700729691866",
            //                     "uTime": "1700729691866"
            //                 }
            //             ],
            //             "maxId": "1111506377509580801",
            //             "minId": "1111506377509580801"
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700725609065,
            //         "data": {
            //             "entrustedList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.002",
            //                     "orderId": "1111488897767604224",
            //                     "clientOid": "1111488897805352960",
            //                     "baseVolume": "0",
            //                     "fee": "0",
            //                     "price": "25000",
            //                     "priceAvg": "",
            //                     "status": "live",
            //                     "side": "buy",
            //                     "force": "gtc",
            //                     "totalProfits": "0",
            //                     "posSide": "long",
            //                     "marginCoin": "USDT",
            //                     "quoteVolume": "0",
            //                     "leverage": "20",
            //                     "marginMode": "crossed",
            //                     "enterPointSource": "web",
            //                     "tradeSide": "open",
            //                     "posMode": "hedge_mode",
            //                     "orderType": "limit",
            //                     "orderSource": "normal",
            //                     "presetStopSurplusPrice": "",
            //                     "presetStopLossPrice": "",
            //                     "reduceOnly": "NO",
            //                     "cTime": "1700725524378",
            //                     "uTime": "1700725524378"
            //                 }
            //             ],
            //             "endId": "1111488897767604224"
            //         }
            //     }
            //
            // swap and future stop
            //
            //     {
            //         "code": "00000",\
            //         "msg": "success",
            //         "requestTime": 1700726417495,
            //         "data": {
            //             "entrustedList": [
            //                 {
            //                     "planType": "normal_plan",
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.001",
            //                     "orderId": "1111491399869075457",
            //                     "clientOid": "1111491399869075456",
            //                     "price": "27000",
            //                     "callbackRatio": "",
            //                     "triggerPrice": "24000",
            //                     "triggerType": "mark_price",
            //                     "planStatus": "live",
            //                     "side": "buy",
            //                     "posSide": "long",
            //                     "marginCoin": "USDT",
            //                     "marginMode": "crossed",
            //                     "enterPointSource": "API",
            //                     "tradeSide": "open",
            //                     "posMode": "hedge_mode",
            //                     "orderType": "limit",
            //                     "stopSurplusTriggerPrice": "",
            //                     "stopSurplusExecutePrice": "",
            //                     "stopSurplusTriggerType": "fill_price",
            //                     "stopLossTriggerPrice": "",
            //                     "stopLossExecutePrice": "",
            //                     "stopLossTriggerType": "fill_price",
            //                     "cTime": "1700726120917",
            //                     "uTime": "1700726120917"
            //                 }
            //             ],
            //             "endId": "1111491399869075457"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            if IsTrue(IsEqual(typeVar, "spot")) {
                if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(trigger)) {
                    var resultList interface{} = this.SafeList(data, "orderList", []interface{}{})
        
                    ch <- this.ParseOrders(resultList, market, since, limit)
                    return nil
                }
            } else {
                var result interface{} = this.SafeList(data, "entrustedList", []interface{}{})
        
                ch <- this.ParseOrders(result, market, since, limit)
                return nil
            }
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes57028 := (<-this.LoadMarkets())
            PanicOnError(retRes57028)
        
            orders:= (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
            PanicOnError(orders)
        
            ch <- this.FilterBy(orders, "status", "closed")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @param {string} symbol unified market symbol of the canceled orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of canceled orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes57298 := (<-this.LoadMarkets())
            PanicOnError(retRes57298)
        
            orders:= (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
            PanicOnError(orders)
        
            ch <- this.FilterBy(orders, "status", "canceled")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchCanceledAndClosedOrders
 * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
 * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
 * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
 * @description fetches information on multiple canceled and closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes57518 := (<-this.LoadMarkets())
            PanicOnError(retRes57518)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                if IsTrue(!IsEqual(symbol, nil)) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    symbol = sandboxSymbol
                }
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchCanceledAndClosedOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchCanceledAndClosedOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
                var cursorReceived interface{} = nil
                if IsTrue(IsEqual(marketType, "spot")) {
                    if IsTrue(!IsEqual(marginMode, nil)) {
                        cursorReceived = "minId"
                    }
                } else {
                    cursorReceived = "endId"
                }
        
                    retRes578019 :=  (<-this.FetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, params, cursorReceived, "idLessThan"))
                    PanicOnError(retRes578019)
                    ch <- retRes578019
                    return nil
            }
            var response interface{} = nil
            var trailing interface{} = this.SafeValue(params, "trailing")
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger", "trailing"})
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) || IsTrue((!IsEqual(marginMode, nil)))) {
                var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
                params = this.Omit(params, "clientOrderId")
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "clientOid", clientOrderId)
                }
            }
            var now interface{} = this.Milliseconds()
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(since, nil)) {
                        since = Subtract(now, 7776000000)
                        AddElementToObject(request, "startTime", since)
                    }
                    if IsTrue(IsEqual(marginMode, "isolated")) {
                        
        response = (<-this.PrivateMarginGetV2MarginIsolatedHistoryOrders(this.Extend(request, params)))
                        PanicOnError(response)
                    } else if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginGetV2MarginCrossedHistoryOrders(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else if IsTrue(trigger) {
                    if IsTrue(IsEqual(symbol, nil)) {
                        panic(ArgumentsRequired(Add(this.Id, " fetchCanceledAndClosedOrders() requires a symbol argument")))
                    }
                    var endTime interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "until"})
                    params = this.Omit(params, []interface{}{"until"})
                    if IsTrue(IsEqual(since, nil)) {
                        since = Subtract(now, 7776000000)
                        AddElementToObject(request, "startTime", since)
                    }
                    if IsTrue(IsEqual(endTime, nil)) {
                        AddElementToObject(request, "endTime", now)
                    }
                    
        response = (<-this.PrivateSpotGetV2SpotTradeHistoryPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateSpotGetV2SpotTradeHistoryOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                if IsTrue(trailing) {
                    var planType interface{} = this.SafeString(params, "planType", "track_plan")
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersPlanHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(trigger) {
                    var planType interface{} = this.SafeString(params, "planType", "normal_plan")
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersPlanHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateMixGetV2MixOrderOrdersHistory(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700791085380,
            //         "data": [
            //             {
            //                 "userId": "7264631750",
            //                 "symbol": "BTCUSDT",
            //                 "orderId": "1111499608327360513",
            //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
            //                 "price": "25000.0000000000000000",
            //                 "size": "0.0002000000000000",
            //                 "orderType": "limit",
            //                 "side": "buy",
            //                 "status": "cancelled",
            //                 "priceAvg": "0",
            //                 "baseVolume": "0.0000000000000000",
            //                 "quoteVolume": "0.0000000000000000",
            //                 "enterPointSource": "WEB",
            //                 "feeDetail": "",
            //                 "orderSource": "normal",
            //                 "cTime": "1700728077966",
            //                 "uTime": "1700728911471"
            //             },
            //         ]
            //     }
            //
            // spot stop
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700792099146,
            //         "data": {
            //             "nextFlag": false,
            //             "idLessThan": "1098757597417775104",
            //             "orderList": [
            //                 {
            //                     "orderId": "1111503385931620352",
            //                     "clientOid": "1111503385910648832",
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.0002",
            //                     "planType": "AMOUNT",
            //                     "executePrice": "25000",
            //                     "triggerPrice": "26000",
            //                     "status": "cancelled",
            //                     "orderType": "limit",
            //                     "side": "buy",
            //                     "triggerType": "fill_price",
            //                     "enterPointSource": "API",
            //                     "cTime": "1700728978617",
            //                     "uTime": "1700729666868"
            //                 },
            //             ]
            //         }
            //     }
            //
            // spot margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700792381435,
            //         "data": {
            //             "orderList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "orderType": "limit",
            //                     "enterPointSource": "WEB",
            //                     "orderId": "1111456274707001345",
            //                     "clientOid": "41e428dd305a4f668671b7f1ed00dc50",
            //                     "loanType": "autoLoanAndRepay",
            //                     "price": "27000",
            //                     "side": "buy",
            //                     "status": "cancelled",
            //                     "baseSize": "0.0002",
            //                     "quoteSize": "5.4",
            //                     "priceAvg": "0",
            //                     "size": "0",
            //                     "amount": "0",
            //                     "force": "gtc",
            //                     "cTime": "1700717746427",
            //                     "uTime": "1700717780636"
            //                 },
            //             ],
            //             "maxId": "1111456274707001345",
            //             "minId": "1098396464990269440"
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700792674673,
            //         "data": {
            //             "entrustedList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.002",
            //                     "orderId": "1111498800817143808",
            //                     "clientOid": "1111498800850698240",
            //                     "baseVolume": "0",
            //                     "fee": "0",
            //                     "price": "25000",
            //                     "priceAvg": "",
            //                     "status": "canceled",
            //                     "side": "buy",
            //                     "force": "gtc",
            //                     "totalProfits": "0",
            //                     "posSide": "long",
            //                     "marginCoin": "USDT",
            //                     "quoteVolume": "0",
            //                     "leverage": "20",
            //                     "marginMode": "crossed",
            //                     "enterPointSource": "web",
            //                     "tradeSide": "open",
            //                     "posMode": "hedge_mode",
            //                     "orderType": "limit",
            //                     "orderSource": "normal",
            //                     "presetStopSurplusPrice": "",
            //                     "presetStopLossPrice": "",
            //                     "reduceOnly": "NO",
            //                     "cTime": "1700727885449",
            //                     "uTime": "1700727944563"
            //                 },
            //             ],
            //             "endId": "1098397008323575809"
            //         }
            //     }
            //
            // swap and future stop
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700792938359,
            //         "data": {
            //             "entrustedList": [
            //                 {
            //                     "planType": "normal_plan",
            //                     "symbol": "BTCUSDT",
            //                     "size": "0.001",
            //                     "orderId": "1111491399869075457",
            //                     "clientOid": "1111491399869075456",
            //                     "planStatus": "cancelled",
            //                     "price": "27000",
            //                     "feeDetail": null,
            //                     "baseVolume": "0",
            //                     "callbackRatio": "",
            //                     "triggerPrice": "24000",
            //                     "triggerType": "mark_price",
            //                     "side": "buy",
            //                     "posSide": "long",
            //                     "marginCoin": "USDT",
            //                     "marginMode": "crossed",
            //                     "enterPointSource": "API",
            //                     "tradeSide": "open",
            //                     "posMode": "hedge_mode",
            //                     "orderType": "limit",
            //                     "stopSurplusTriggerPrice": "",
            //                     "stopSurplusExecutePrice": "",
            //                     "stopSurplusTriggerType": "fill_price",
            //                     "stopLossTriggerPrice": "",
            //                     "stopLossExecutePrice": "",
            //                     "stopLossTriggerType": "fill_price",
            //                     "cTime": "1700726120917",
            //                     "uTime": "1700727879652"
            //                 },
            //             ],
            //             "endId": "1098760007867502593"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue(trigger)) {
        
                    ch <- this.ParseOrders(this.SafeValue(data, "orderList", []interface{}{}), market, since, limit)
                    return nil
                }
            } else {
        
                ch <- this.ParseOrders(this.SafeValue(data, "entrustedList", []interface{}{}), market, since, limit)
                return nil
            }
            if IsTrue(IsString(response)) {
                response = JsonParse(response)
            }
            var orders interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Bills
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.symbol] *contract only* unified market symbol
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *bitget) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes60558 := (<-this.LoadMarkets())
            PanicOnError(retRes60558)
            var symbol interface{} = this.SafeString(params, "symbol")
            params = this.Omit(params, "symbol")
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(symbol)
                }
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchLedger", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
                var cursorReceived interface{} = nil
                if IsTrue(!IsEqual(marketType, "spot")) {
                    cursorReceived = "endId"
                }
        
                    retRes607719 :=  (<-this.FetchPaginatedCallCursor("fetchLedger", symbol, since, limit, params, cursorReceived, "idLessThan"))
                    PanicOnError(retRes607719)
                    ch <- retRes607719
                    return nil
            }
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetV2SpotAccountBills(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(symbol, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PrivateMixGetV2MixAccountBill(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700795836415,
            //         "data": [
            //             {
            //                 "billId": "1111506298997215233",
            //                 "coin": "USDT",
            //                 "groupType": "transfer",
            //                 "businessType": "transfer_out",
            //                 "size": "-11.64958799",
            //                 "balance": "0.00000000",
            //                 "fees": "0.00000000",
            //                 "cTime": "1700729673028"
            //             },
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700795977890,
            //         "data": {
            //             "bills": [
            //                 {
            //                     "billId": "1111499428100472833",
            //                     "symbol": "",
            //                     "amount": "-11.64958799",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "businessType": "trans_to_exchange",
            //                     "coin": "USDT",
            //                     "cTime": "1700728034996"
            //                 },
            //             ],
            //             "endId": "1098396773329305606"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            if IsTrue(IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))) {
                var bills interface{} = this.SafeValue(data, "bills", []interface{}{})
        
                ch <- this.ParseLedger(bills, currency, since, limit)
                return nil
            }
        
            ch <- this.ParseLedger(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "billId": "1111506298997215233",
    //         "coin": "USDT",
    //         "groupType": "transfer",
    //         "businessType": "transfer_out",
    //         "size": "-11.64958799",
    //         "balance": "0.00000000",
    //         "fees": "0.00000000",
    //         "cTime": "1700729673028"
    //     }
    //
    // swap and future
    //
    //     {
    //         "billId": "1111499428100472833",
    //         "symbol": "",
    //         "amount": "-11.64958799",
    //         "fee": "0",
    //         "feeByCoupon": "",
    //         "businessType": "trans_to_exchange",
    //         "coin": "USDT",
    //         "cTime": "1700728034996"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(item, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(item, "cTime")
    var after interface{} = this.SafeNumber(item, "balance")
    var fee interface{} = this.SafeNumber2(item, "fees", "fee")
    var amountRaw interface{} = this.SafeString2(item, "size", "amount")
    var amount interface{} = this.ParseNumber(Precise.StringAbs(amountRaw))
    var direction interface{} = "in"
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(amountRaw, "-"), 0)) {
        direction = "out"
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "billId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "direction": direction,
        "account": nil,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": this.ParseLedgerType(this.SafeString(item, "businessType")),
        "currency": code,
        "amount": amount,
        "before": nil,
        "after": after,
        "status": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": fee,
        },
    }, currency)
}
func  (this *bitget) ParseLedgerType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "trans_to_cross": "transfer",
        "trans_from_cross": "transfer",
        "trans_to_exchange": "transfer",
        "trans_from_exchange": "transfer",
        "trans_to_isolated": "transfer",
        "trans_from_isolated": "transfer",
        "trans_to_contract": "transfer",
        "trans_from_contract": "transfer",
        "trans_to_otc": "transfer",
        "trans_from_otc": "transfer",
        "open_long": "trade",
        "close_long": "trade",
        "open_short": "trade",
        "close_short": "trade",
        "force_close_long": "trade",
        "force_close_short": "trade",
        "burst_long_loss_query": "trade",
        "burst_short_loss_query": "trade",
        "force_buy": "trade",
        "force_sell": "trade",
        "burst_buy": "trade",
        "burst_sell": "trade",
        "delivery_long": "settlement",
        "delivery_short": "settlement",
        "contract_settle_fee": "fee",
        "append_margin": "transaction",
        "adjust_down_lever_append_margin": "transaction",
        "reduce_margin": "transaction",
        "auto_append_margin": "transaction",
        "cash_gift_issue": "cashback",
        "cash_gift_recycle": "cashback",
        "bonus_issue": "rebate",
        "bonus_recycle": "rebate",
        "bonus_expired": "rebate",
        "transfer_in": "transfer",
        "transfer_out": "transfer",
        "deposit": "deposit",
        "withdraw": "withdrawal",
        "buy": "trade",
        "sell": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name bitget#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.bitget.com/api-doc/spot/trade/Get-Fills
 * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Fills
 * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-Fills
 * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Transaction-Details
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitget) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes62848 := (<-this.LoadMarkets())
            PanicOnError(retRes62848)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
                var cursorReceived interface{} = nil
                if IsTrue(GetValue(market, "spot")) {
                    if IsTrue(!IsEqual(marginMode, nil)) {
                        cursorReceived = "minId"
                    }
                } else {
                    cursorReceived = "endId"
                }
        
                    retRes630619 :=  (<-this.FetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, params, cursorReceived, "idLessThan"))
                    PanicOnError(retRes630619)
                    ch <- retRes630619
                    return nil
            }
            var response interface{} = nil
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(IsEqual(since, nil)) {
                        AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
                    }
                    if IsTrue(IsEqual(marginMode, "isolated")) {
                        
        response = (<-this.PrivateMarginGetV2MarginIsolatedFills(this.Extend(request, params)))
                        PanicOnError(response)
                    } else if IsTrue(IsEqual(marginMode, "cross")) {
                        
        response = (<-this.PrivateMarginGetV2MarginCrossedFills(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    
        response = (<-this.PrivateSpotGetV2SpotTradeFills(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var productType interface{} = nil
                productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
                
        response = (<-this.PrivateMixGetV2MixOrderFills(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700802995406,
            //         "data": [
            //             {
            //                 "userId": "7264631750",
            //                 "symbol": "BTCUSDT",
            //                 "orderId": "1098394344925597696",
            //                 "tradeId": "1098394344974925824",
            //                 "orderType": "market",
            //                 "side": "sell",
            //                 "priceAvg": "28467.68",
            //                 "size": "0.0002",
            //                 "amount": "5.693536",
            //                 "feeDetail": {
            //                     "deduction": "no",
            //                     "feeCoin": "USDT",
            //                     "totalDeductionFee": "",
            //                     "totalFee": "-0.005693536"
            //                 },
            //                 "tradeScope": "taker",
            //                 "cTime": "1697603539699",
            //                 "uTime": "1697603539754"
            //             }
            //         ]
            //     }
            //
            // spot margin
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700803176399,
            //         "data": {
            //             "fills": [
            //                 {
            //                     "orderId": "1099353730455318528",
            //                     "tradeId": "1099353730627092481",
            //                     "orderType": "market",
            //                     "side": "sell",
            //                     "priceAvg": "29543.7",
            //                     "size": "0.0001",
            //                     "amount": "2.95437",
            //                     "tradeScope": "taker",
            //                     "feeDetail": {
            //                         "deduction": "no",
            //                         "feeCoin": "USDT",
            //                         "totalDeductionFee": "0",
            //                         "totalFee": "-0.00295437"
            //                     },
            //                     "cTime": "1697832275063",
            //                     "uTime": "1697832275150"
            //                 },
            //             ],
            //             "minId": "1099353591699161118",
            //             "maxId": "1099353730627092481"
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700803357487,
            //         "data": {
            //             "fillList": [
            //                 {
            //                     "tradeId": "1111468664328269825",
            //                     "symbol": "BTCUSDT",
            //                     "orderId": "1111468664264753162",
            //                     "price": "37271.4",
            //                     "baseVolume": "0.001",
            //                     "feeDetail": [
            //                         {
            //                             "deduction": "no",
            //                             "feeCoin": "USDT",
            //                             "totalDeductionFee": null,
            //                             "totalFee": "-0.02236284"
            //                         }
            //                     ],
            //                     "side": "buy",
            //                     "quoteVolume": "37.2714",
            //                     "profit": "-0.0007",
            //                     "enterPointSource": "web",
            //                     "tradeSide": "close",
            //                     "posMode": "hedge_mode",
            //                     "tradeScope": "taker",
            //                     "cTime": "1700720700342"
            //                 },
            //             ],
            //             "endId": "1099351587643699201"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            if IsTrue(IsTrue((GetValue(market, "swap"))) || IsTrue((GetValue(market, "future")))) {
                var fillList interface{} = this.SafeList(data, "fillList", []interface{}{})
        
                ch <- this.ParseTrades(fillList, market, since, limit)
                return nil
            } else if IsTrue(!IsEqual(marginMode, nil)) {
                var fills interface{} = this.SafeList(data, "fills", []interface{}{})
        
                ch <- this.ParseTrades(fills, market, since, limit)
                return nil
            }
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://www.bitget.com/api-doc/contract/position/get-single-position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitget) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes64588 := (<-this.LoadMarkets())
            PanicOnError(retRes64588)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixGetV2MixPositionSinglePosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700807531673,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "symbol": "BTCUSDT",
            //                 "holdSide": "long",
            //                 "openDelegateSize": "0",
            //                 "marginSize": "3.73555",
            //                 "available": "0.002",
            //                 "locked": "0",
            //                 "total": "0.002",
            //                 "leverage": "20",
            //                 "achievedProfits": "0",
            //                 "openPriceAvg": "37355.5",
            //                 "marginMode": "crossed",
            //                 "posMode": "hedge_mode",
            //                 "unrealizedPL": "0.007",
            //                 "liquidationPrice": "31724.970702417",
            //                 "keepMarginRate": "0.004",
            //                 "markPrice": "37359",
            //                 "marginRatio": "0.029599540355",
            //                 "cTime": "1700807507275"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParsePosition(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchPositions
 * @description fetch all open positions
 * @see https://www.bitget.com/api-doc/contract/position/get-all-position
 * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
 * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {boolean} [params.useHistoryEndpoint] default false, when true  will use the historic endpoint to fetch positions
 * @param {string} [params.method] either (default) 'privateMixGetV2MixPositionAllPosition' or 'privateMixGetV2MixPositionHistoryPosition'
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitget) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes65268 := (<-this.LoadMarkets())
            PanicOnError(retRes65268)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes653019 :=  (<-this.FetchPaginatedCallCursor("fetchPositions", nil, nil, nil, params, "endId", "idLessThan"))
                    PanicOnError(retRes653019)
                    ch <- retRes653019
                    return nil
            }
            var method interface{} = nil
            var useHistoryEndpoint interface{} = this.SafeBool(params, "useHistoryEndpoint", false)
            if IsTrue(useHistoryEndpoint) {
                method = "privateMixGetV2MixPositionHistoryPosition"
            } else {
                methodparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "method", "privateMixGetV2MixPositionAllPosition");
                method = GetValue(methodparamsVariable,0);
                params = GetValue(methodparamsVariable,1)
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var first interface{} = this.SafeString(symbols, 0)
                var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(first)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(first)
                }
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "productType": productType,
            }
            var response interface{} = nil
            var isHistory interface{} = false
            if IsTrue(IsEqual(method, "privateMixGetV2MixPositionAllPosition")) {
                var marginCoin interface{} = this.SafeString(params, "marginCoin", "USDT")
                if IsTrue(!IsEqual(symbols, nil)) {
                    marginCoin = GetValue(market, "settleId")
                } else if IsTrue(IsEqual(productType, "USDT-FUTURES")) {
                    marginCoin = "USDT"
                } else if IsTrue(IsEqual(productType, "USDC-FUTURES")) {
                    marginCoin = "USDC"
                } else if IsTrue(IsEqual(productType, "SUSDT-FUTURES")) {
                    marginCoin = "SUSDT"
                } else if IsTrue(IsEqual(productType, "SUSDC-FUTURES")) {
                    marginCoin = "SUSDC"
                } else if IsTrue(IsTrue((IsEqual(productType, "SCOIN-FUTURES"))) || IsTrue((IsEqual(productType, "COIN-FUTURES")))) {
                    if IsTrue(IsEqual(marginCoin, nil)) {
                        panic(ArgumentsRequired(Add(this.Id, " fetchPositions() requires a marginCoin parameter that matches the productType")))
                    }
                }
                AddElementToObject(request, "marginCoin", marginCoin)
                
        response = (<-this.PrivateMixGetV2MixPositionAllPosition(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                isHistory = true
                if IsTrue(!IsEqual(market, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                
        response = (<-this.PrivateMixGetV2MixPositionHistoryPosition(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // privateMixGetV2MixPositionAllPosition
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700807810221,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "symbol": "BTCUSDT",
            //                 "holdSide": "long",
            //                 "openDelegateSize": "0",
            //                 "marginSize": "3.73555",
            //                 "available": "0.002",
            //                 "locked": "0",
            //                 "total": "0.002",
            //                 "leverage": "20",
            //                 "achievedProfits": "0",
            //                 "openPriceAvg": "37355.5",
            //                 "marginMode": "crossed",
            //                 "posMode": "hedge_mode",
            //                 "unrealizedPL": "0.03",
            //                 "liquidationPrice": "31725.023602417",
            //                 "keepMarginRate": "0.004",
            //                 "markPrice": "37370.5",
            //                 "marginRatio": "0.029550120396",
            //                 "cTime": "1700807507275"
            //             }
            //         ]
            //     }
            //
            // privateMixGetV2MixPositionHistoryPosition
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700808051002,
            //         "data": {
            //             "list": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "marginCoin": "USDT",
            //                     "holdSide": "long",
            //                     "openAvgPrice": "37272.1",
            //                     "closeAvgPrice": "37271.4",
            //                     "marginMode": "crossed",
            //                     "openTotalPos": "0.001",
            //                     "closeTotalPos": "0.001",
            //                     "pnl": "-0.0007",
            //                     "netProfit": "-0.0454261",
            //                     "totalFunding": "0",
            //                     "openFee": "-0.02236326",
            //                     "closeFee": "-0.02236284",
            //                     "utime": "1700720700400",
            //                     "ctime": "1700720651684"
            //                 },
            //             ],
            //             "endId": "1099351653866962944"
            //         }
            //     }
            //
            var position interface{} = []interface{}{}
            if !IsTrue(isHistory) {
                position = this.SafeList(response, "data", []interface{}{})
            } else {
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                position = this.SafeList(data, "list", []interface{}{})
            }
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(position)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(position, i), market))
            }
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchPosition
    //
    //     {
    //         "marginCoin": "USDT",
    //         "symbol": "BTCUSDT",
    //         "holdSide": "long",
    //         "openDelegateSize": "0",
    //         "marginSize": "3.73555",
    //         "available": "0.002",
    //         "locked": "0",
    //         "total": "0.002",
    //         "leverage": "20",
    //         "achievedProfits": "0",
    //         "openPriceAvg": "37355.5",
    //         "marginMode": "crossed",
    //         "posMode": "hedge_mode",
    //         "unrealizedPL": "0.007",
    //         "liquidationPrice": "31724.970702417",
    //         "keepMarginRate": "0.004",
    //         "markPrice": "37359",
    //         "marginRatio": "0.029599540355",
    //         "cTime": "1700807507275"
    //     }
    //
    // fetchPositions: privateMixGetV2MixPositionAllPosition
    //
    //     {
    //         "marginCoin": "USDT",
    //         "symbol": "BTCUSDT",
    //         "holdSide": "long",
    //         "openDelegateSize": "0",
    //         "marginSize": "3.73555",
    //         "available": "0.002",
    //         "locked": "0",
    //         "total": "0.002",
    //         "leverage": "20",
    //         "achievedProfits": "0",
    //         "openPriceAvg": "37355.5",
    //         "marginMode": "crossed",
    //         "posMode": "hedge_mode",
    //         "unrealizedPL": "0.03",
    //         "liquidationPrice": "31725.023602417",
    //         "keepMarginRate": "0.004",
    //         "markPrice": "37370.5",
    //         "marginRatio": "0.029550120396",
    //         "cTime": "1700807507275"
    //     }
    //
    // fetchPositionsHistory: privateMixGetV2MixPositionHistoryPosition
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "marginCoin": "USDT",
    //         "holdSide": "long",
    //         "openAvgPrice": "37272.1",
    //         "closeAvgPrice": "37271.4",
    //         "marginMode": "crossed",
    //         "openTotalPos": "0.001",
    //         "closeTotalPos": "0.001",
    //         "pnl": "-0.0007",
    //         "netProfit": "-0.0454261",
    //         "totalFunding": "0",
    //         "openFee": "-0.02236326",
    //         "closeFee": "-0.02236284",
    //         "utime": "1700720700400",
    //         "ctime": "1700720651684"
    //     }
    //
    // closeAllPositions
    //
    //     {
    //         "orderId": "1120923953904893955",
    //         "clientOid": "1120923953904893956"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger2(position, "cTime", "ctime")
    var marginMode interface{} = this.SafeString(position, "marginMode")
    var collateral interface{} = nil
    var initialMargin interface{} = nil
    var unrealizedPnl interface{} = this.SafeString(position, "unrealizedPL")
    var rawCollateral interface{} = this.SafeString(position, "marginSize")
    if IsTrue(IsEqual(marginMode, "isolated")) {
        collateral = Precise.StringAdd(rawCollateral, unrealizedPnl)
    } else if IsTrue(IsEqual(marginMode, "crossed")) {
        marginMode = "cross"
        initialMargin = rawCollateral
    }
    var holdMode interface{} = this.SafeString(position, "posMode")
    var hedged interface{} = nil
    if IsTrue(IsEqual(holdMode, "hedge_mode")) {
        hedged = true
    } else if IsTrue(IsEqual(holdMode, "one_way_mode")) {
        hedged = false
    }
    var side interface{} = this.SafeString(position, "holdSide")
    var leverage interface{} = this.SafeString(position, "leverage")
    var contractSizeNumber interface{} = this.SafeValue(market, "contractSize")
    var contractSize interface{} = this.NumberToString(contractSizeNumber)
    var baseAmount interface{} = this.SafeString(position, "total")
    var entryPrice interface{} = this.SafeString2(position, "openPriceAvg", "openAvgPrice")
    var maintenanceMarginPercentage interface{} = this.SafeString(position, "keepMarginRate")
    var openNotional interface{} = Precise.StringMul(entryPrice, baseAmount)
    if IsTrue(IsEqual(initialMargin, nil)) {
        initialMargin = Precise.StringDiv(openNotional, leverage)
    }
    var contracts interface{} = this.ParseNumber(Precise.StringDiv(baseAmount, contractSize))
    if IsTrue(IsEqual(contracts, nil)) {
        contracts = this.SafeNumber(position, "closeTotalPos")
    }
    var markPrice interface{} = this.SafeString(position, "markPrice")
    var notional interface{} = Precise.StringMul(baseAmount, markPrice)
    var initialMarginPercentage interface{} = Precise.StringDiv(initialMargin, notional)
    var liquidationPrice interface{} = this.ParseNumber(this.OmitZero(this.SafeString(position, "liquidationPrice")))
    var calcTakerFeeRate interface{} = "0.0006"
    var calcTakerFeeMult interface{} = "0.9994"
    if IsTrue(IsTrue(IsTrue((IsEqual(liquidationPrice, nil))) && IsTrue((IsEqual(marginMode, "isolated")))) && IsTrue(Precise.StringGt(baseAmount, "0"))) {
        var signedMargin interface{} = Precise.StringDiv(rawCollateral, baseAmount)
        var signedMmp interface{} = maintenanceMarginPercentage
        if IsTrue(IsEqual(side, "short")) {
            signedMargin = Precise.StringNeg(signedMargin)
            signedMmp = Precise.StringNeg(signedMmp)
        }
        var mmrMinusOne interface{} = Precise.StringSub("1", signedMmp)
        var numerator interface{} = Precise.StringSub(entryPrice, signedMargin)
        if IsTrue(IsEqual(side, "long")) {
            mmrMinusOne = Precise.StringMul(mmrMinusOne, calcTakerFeeMult)
        } else {
            numerator = Precise.StringMul(numerator, calcTakerFeeMult)
        }
        liquidationPrice = this.ParseNumber(Precise.StringDiv(numerator, mmrMinusOne))
    }
    var feeToClose interface{} = Precise.StringMul(notional, calcTakerFeeRate)
    var maintenanceMargin interface{} = Precise.StringAdd(Precise.StringMul(maintenanceMarginPercentage, notional), feeToClose)
    var percentage interface{} = Precise.StringMul(Precise.StringDiv(unrealizedPnl, initialMargin, 4), "100")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "orderId"),
        "symbol": symbol,
        "notional": this.ParseNumber(notional),
        "marginMode": marginMode,
        "liquidationPrice": liquidationPrice,
        "entryPrice": this.ParseNumber(entryPrice),
        "unrealizedPnl": this.ParseNumber(unrealizedPnl),
        "realizedPnl": this.SafeNumber(position, "pnl"),
        "percentage": this.ParseNumber(percentage),
        "contracts": contracts,
        "contractSize": contractSizeNumber,
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": this.SafeNumber(position, "closeAvgPrice"),
        "side": side,
        "hedged": hedged,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": this.SafeInteger(position, "utime"),
        "maintenanceMargin": this.ParseNumber(maintenanceMargin),
        "maintenanceMarginPercentage": this.ParseNumber(maintenanceMarginPercentage),
        "collateral": this.ParseNumber(collateral),
        "initialMargin": this.ParseNumber(initialMargin),
        "initialMarginPercentage": this.ParseNumber(initialMarginPercentage),
        "leverage": this.ParseNumber(leverage),
        "marginRatio": this.SafeNumber(position, "marginRatio"),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name bitget#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://www.bitget.com/api-doc/contract/market/Get-History-Funding-Rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of funding rate structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *bitget) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes68478 := (<-this.LoadMarkets())
            PanicOnError(retRes68478)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes685119 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, "pageNo", 100))
                    PanicOnError(retRes685119)
                    ch <- retRes685119
                    return nil
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "productType": productType,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
        
            response:= (<-this.PublicMixGetV2MixMarketHistoryFundRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1652406728393,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "fundingRate": "-0.0003",
            //                 "fundingTime": "1652396400000"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var symbolInner interface{} = this.SafeSymbol(marketId, market)
                var timestamp interface{} = this.SafeInteger(entry, "fundingTime")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.bitget.com/api-doc/contract/market/Get-Current-Funding-Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *bitget) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes69168 := (<-this.LoadMarkets())
            PanicOnError(retRes69168)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "productType": productType,
            }
        
            response:= (<-this.PublicMixGetV2MixMarketCurrentFundRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700811542124,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "fundingRate": "0.000106"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseFundingRate(GetValue(data, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchFundingRates
 * @description fetch the current funding rates for all markets
 * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] *contract only* 'linear', 'inverse'
 * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} a dictionary of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *bitget) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes69648 := (<-this.LoadMarkets())
            PanicOnError(retRes69648)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeValue(symbols, 0)
                var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(symbol)
                }
            }
            var request interface{} = map[string]interface{} {}
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            AddElementToObject(request, "productType", productType)
        
            response:= (<-this.PublicMixGetV2MixMarketTickers(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "code": "00000",
            //     "msg": "success",
            //     "requestTime": 1700533773477,
            //     "data": [
            //         {
            //             "symbol": "BTCUSD",
            //             "lastPr": "29904.5",
            //             "askPr": "29904.5",
            //             "bidPr": "29903.5",
            //             "bidSz": "0.5091",
            //             "askSz": "2.2694",
            //             "high24h": "0",
            //             "low24h": "0",
            //             "ts": "1695794271400",
            //             "change24h": "0",
            //             "baseVolume": "0",
            //             "quoteVolume": "0",
            //             "usdtVolume": "0",
            //             "openUtc": "0",
            //             "changeUtc24h": "0",
            //             "indexPrice": "29132.353333",
            //             "fundingRate": "-0.0007",
            //             "holdingAmount": "125.6844",
            //             "deliveryStartTime": null,
            //             "deliveryTime": null,
            //             "deliveryStatus": "delivery_normal",
            //             "open24h": "0",
            //             "markPrice": "12345"
            //         },
            //     ]
            // }
            symbols = this.MarketSymbols(symbols)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseFundingRates(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchFundingRate
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "fundingRate": "-0.000182"
    //     }
    //
    // fetchFundingInterval
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "nextFundingTime": "1727942400000",
    //         "ratePeriod": "8"
    //     }
    // fetchFundingRates
    //     {
    //         "symbol": "BTCUSD",
    //         "lastPr": "29904.5",
    //         "askPr": "29904.5",
    //         "bidPr": "29903.5",
    //         "bidSz": "0.5091",
    //         "askSz": "2.2694",
    //         "high24h": "0",
    //         "low24h": "0",
    //         "ts": "1695794271400",
    //         "change24h": "0",
    //         "baseVolume": "0",
    //         "quoteVolume": "0",
    //         "usdtVolume": "0",
    //         "openUtc": "0",
    //         "changeUtc24h": "0",
    //         "indexPrice": "29132.353333",
    //         "fundingRate": "-0.0007",
    //         "holdingAmount": "125.6844",
    //         "deliveryStartTime": null,
    //         "deliveryTime": null,
    //         "deliveryStatus": "delivery_normal",
    //         "open24h": "0",
    //         "markPrice": "12345"
    //     }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "swap")
    var fundingTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
    var interval interface{} = this.SafeString(contract, "ratePeriod")
    var timestamp interface{} = this.SafeInteger(contract, "ts")
    var markPrice interface{} = this.SafeNumber(contract, "markPrice")
    var indexPrice interface{} = this.SafeNumber(contract, "indexPrice")
    var intervalString interface{} = nil
    if IsTrue(!IsEqual(interval, nil)) {
        intervalString = Add(interval, "h")
    }
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": markPrice,
        "indexPrice": indexPrice,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fundingRate": this.SafeNumber(contract, "fundingRate"),
        "fundingTimestamp": fundingTimestamp,
        "fundingDatetime": this.Iso8601(fundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": intervalString,
    }
}
/**
 * @method
 * @name bitget#fetchFundingHistory
 * @description fetch the funding history
 * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
 * @param {string} symbol unified market symbol
 * @param {int} [since] the starting timestamp in milliseconds
 * @param {int} [limit] the number of entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch funding history for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *bitget) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes71078 := (<-this.LoadMarkets())
            PanicOnError(retRes71078)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingHistory() requires a symbol argument")))
            }
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes711419 :=  (<-this.FetchPaginatedCallCursor("fetchFundingHistory", symbol, since, limit, params, "endId", "idLessThan"))
                    PanicOnError(retRes711419)
                    ch <- retRes711419
                    return nil
            }
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingHistory() supports swap contracts only")))
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "businessType": "contract_settle_fee",
                "productType": productType,
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateMixGetV2MixAccountBill(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700795977890,
            //         "data": {
            //             "bills": [
            //                 {
            //                     "billId": "1111499428100472833",
            //                     "symbol": "BTCUSDT",
            //                     "amount": "-0.004992",
            //                     "fee": "0",
            //                     "feeByCoupon": "",
            //                     "businessType": "contract_settle_fee",
            //                     "coin": "USDT",
            //                     "cTime": "1700728034996"
            //                 },
            //             ],
            //             "endId": "1098396773329305606"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var result interface{} = this.SafeValue(data, "bills", []interface{}{})
        
            ch <- this.ParseFundingHistories(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseFundingHistory(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "billId": "1111499428100472833",
    //         "symbol": "BTCUSDT",
    //         "amount": "-0.004992",
    //         "fee": "0",
    //         "feeByCoupon": "",
    //         "businessType": "contract_settle_fee",
    //         "coin": "USDT",
    //         "cTime": "1700728034996"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var currencyId interface{} = this.SafeString(contract, "coin")
    var timestamp interface{} = this.SafeInteger(contract, "cTime")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "code": this.SafeCurrencyCode(currencyId),
        "amount": this.SafeNumber(contract, "amount"),
        "id": this.SafeString(contract, "billId"),
    }
}
func  (this *bitget) ParseFundingHistories(contracts interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(contracts)); i++ {
        var contract interface{} = GetValue(contracts, i)
        var business interface{} = this.SafeString(contract, "businessType")
        if IsTrue(!IsEqual(business, "contract_settle_fee")) {
            continue
        }
        AppendToArray(&result,this.ParseFundingHistory(contract, market))
    }
    var sorted interface{} = this.SortBy(result, "timestamp")
    return this.FilterBySinceLimit(sorted, since, limit)
}
func  (this *bitget) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes72128 := (<-this.LoadMarkets())
            PanicOnError(retRes72128)
            var holdSide interface{} = this.SafeString(params, "holdSide")
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "amount": this.AmountToPrecision(symbol, amount),
                "holdSide": holdSide,
                "productType": productType,
            }
            params = this.Omit(params, "holdSide")
        
            response:= (<-this.PrivateMixPostV2MixAccountSetMargin(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700813444618,
            //         "data": ""
            //     }
            //
        ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{} {
                "amount": this.ParseNumber(amount),
                "type": typeVar,
            })
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // addMargin/reduceMargin
    //
    //     {
    //         "code": "00000",
    //         "msg": "success",
    //         "requestTime": 1700813444618,
    //         "data": ""
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var errorCode interface{} = this.SafeString(data, "code")
    var status interface{} = Ternary(IsTrue((IsEqual(errorCode, "00000"))), "ok", "failed")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "marginMode": "isolated",
        "amount": nil,
        "total": nil,
        "code": GetValue(market, "settle"),
        "status": status,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name bitget#reduceMargin
 * @description remove margin from a position
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *bitget) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(IsGreaterThan(amount, 0)) {
                panic(BadRequest(Add(this.Id, " reduceMargin() amount parameter must be a negative value")))
            }
            var holdSide interface{} = this.SafeString(params, "holdSide")
            if IsTrue(IsEqual(holdSide, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " reduceMargin() requires a holdSide parameter, either long or short")))
            }
        
                retRes729215 :=  (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
                PanicOnError(retRes729215)
                ch <- retRes729215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#addMargin
 * @description add margin
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *bitget) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var holdSide interface{} = this.SafeString(params, "holdSide")
            if IsTrue(IsEqual(holdSide, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " addMargin() requires a holdSide parameter, either long or short")))
            }
        
                retRes731015 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes731015)
                ch <- retRes731015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *bitget) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes73238 := (<-this.LoadMarkets())
            PanicOnError(retRes73238)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixGetV2MixAccountAccount(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1709366911964,
            //         "data": {
            //             "marginCoin": "USDT",
            //             "locked": "0",
            //             "available": "0",
            //             "crossedMaxAvailable": "0",
            //             "isolatedMaxAvailable": "0",
            //             "maxTransferOut": "0",
            //             "accountEquity": "0",
            //             "usdtEquity": "0.000000009166",
            //             "btcEquity": "0",
            //             "crossedRiskRate": "0",
            //             "crossedMarginLeverage": 20,
            //             "isolatedLongLever": 20,
            //             "isolatedShortLever": 20,
            //             "marginMode": "crossed",
            //             "posMode": "hedge_mode",
            //             "unrealizedPL": "0",
            //             "coupon": "0",
            //             "crossedUnrealizedPL": "0",
            //             "isolatedUnrealizedPL": ""
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": "isolated",
        "longLeverage": this.SafeInteger(leverage, "isolatedLongLever"),
        "shortLeverage": this.SafeInteger(leverage, "isolatedShortLever"),
    }
}
/**
 * @method
 * @name bitget#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.bitget.com/api-doc/contract/account/Change-Leverage
 * @param {int} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.holdSide] *isolated only* position direction, 'long' or 'short'
 * @returns {object} response from the exchange
 */
func  (this *bitget) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes73978 := (<-this.LoadMarkets())
            PanicOnError(retRes73978)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "leverage": this.NumberToString(leverage),
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixPostV2MixAccountSetLeverage(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700864711517,
            //         "data": {
            //             "symbol": "BTCUSDT",
            //             "marginCoin": "USDT",
            //             "longLeverage": "25",
            //             "shortLeverage": "25",
            //             "crossMarginLeverage": "25",
            //             "marginMode": "crossed"
            //         }
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://www.bitget.com/api-doc/contract/account/Change-Margin-Mode
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *bitget) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            marginMode = ToLower(marginMode)
            if IsTrue(IsEqual(marginMode, "cross")) {
                marginMode = "crossed"
            }
            if IsTrue(IsTrue((!IsEqual(marginMode, "isolated"))) && IsTrue((!IsEqual(marginMode, "crossed")))) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() marginMode must be either isolated or crossed (cross)")))
            }
        
            retRes74558 := (<-this.LoadMarkets())
            PanicOnError(retRes74558)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "marginMode": marginMode,
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixPostV2MixAccountSetMarginMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700865205552,
            //         "data": {
            //             "symbol": "BTCUSDT",
            //             "marginCoin": "USDT",
            //             "longLeverage": "20",
            //             "shortLeverage": "3",
            //             "marginMode": "isolated"
            //         }
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://www.bitget.com/api-doc/contract/account/Change-Hold-Mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by bitget setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] required if symbol is undefined: 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object} response from the exchange
 */
func  (this *bitget) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes75028 := (<-this.LoadMarkets())
            PanicOnError(retRes75028)
            var posMode interface{} = Ternary(IsTrue(hedged), "hedge_mode", "one_way_mode")
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
                if IsTrue(sandboxMode) {
                    var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                    market = this.Market(sandboxSymbol)
                } else {
                    market = this.Market(symbol)
                }
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "posMode": posMode,
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixPostV2MixAccountSetPositionMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700865608009,
            //         "data": {
            //             "posMode": "hedge_mode"
            //         }
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchOpenInterest
 * @description retrieves the open interest of a contract trading pair
 * @see https://www.bitget.com/api-doc/contract/market/Get-Open-Interest
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *bitget) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes75448 := (<-this.LoadMarkets())
            PanicOnError(retRes75448)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            if !IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "productType": productType,
            }
        
            response:= (<-this.PublicMixGetV2MixMarketOpenInterest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700866041022,
            //         "data": {
            //             "openInterestList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "size": "52234.134"
            //                 }
            //             ],
            //             "ts": "1700866041023"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOpenInterest(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "openInterestList": [
    //             {
    //                 "symbol": "BTCUSDT",
    //                 "size": "52234.134"
    //             }
    //         ],
    //         "ts": "1700866041023"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var data interface{} = this.SafeValue(interest, "openInterestList", []interface{}{})
    var timestamp interface{} = this.SafeInteger(interest, "ts")
    var marketId interface{} = this.SafeString(GetValue(data, 0), "symbol")
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
        "openInterestAmount": this.SafeNumber(GetValue(data, 0), "size"),
        "openInterestValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": interest,
    }, market)
}
/**
 * @method
 * @name bitget#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://www.bitget.com/api-doc/spot/account/Get-Account-TransferRecords
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *bitget) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTransfers() requires a code argument")))
            }
        
            retRes76248 := (<-this.LoadMarkets())
            PanicOnError(retRes76248)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTransfers", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var fromAccount interface{} = this.SafeString(params, "fromAccount", typeVar)
            params = this.Omit(params, "fromAccount")
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            typeVar = this.SafeString(accountsByType, fromAccount)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "fromType": typeVar,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.PrivateSpotGetV2SpotAccountTransferRecords(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700873854651,
            //         "data": [
            //             {
            //                 "coin": "USDT",
            //                 "status": "Successful",
            //                 "toType": "crossed_margin",
            //                 "toSymbol": "",
            //                 "fromType": "spot",
            //                 "fromSymbol": "",
            //                 "size": "11.64958799",
            //                 "ts": "1700729673028",
            //                 "clientOid": "1111506298504744960",
            //                 "transferId": "24930940"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransfers(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.bitget.com/api-doc/spot/account/Wallet-Transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] unified CCXT market symbol, required when transferring to or from an account type that is a leveraged position-by-position account
 * @param {string} [params.clientOid] custom id
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *bitget) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes76848 := (<-this.LoadMarkets())
            PanicOnError(retRes76848)
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            var fromType interface{} = this.SafeString(accountsByType, fromAccount)
            var toType interface{} = this.SafeString(accountsByType, toAccount)
            var request interface{} = map[string]interface{} {
                "fromType": fromType,
                "toType": toType,
                "amount": amount,
                "coin": GetValue(currency, "id"),
            }
            var symbol interface{} = this.SafeString(params, "symbol")
            params = this.Omit(params, "symbol")
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateSpotPostV2SpotWalletTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700874302021,
            //         "data": {
            //             "transferId": "1112112916581847040",
            //             "clientOrderId": null
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            AddElementToObject(data, "ts", this.SafeInteger(response, "requestTime"))
        
            ch <- this.ParseTransfer(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transfer
    //
    //     {
    //         "transferId": "1112112916581847040",
    //         "clientOrderId": null,
    //         "ts": 1700874302021
    //     }
    //
    // fetchTransfers
    //
    //     {
    //         "coin": "USDT",
    //         "status": "Successful",
    //         "toType": "crossed_margin",
    //         "toSymbol": "",
    //         "fromType": "spot",
    //         "fromSymbol": "",
    //         "size": "11.64958799",
    //         "ts": "1700729673028",
    //         "clientOid": "1111506298504744960",
    //         "transferId": "24930940"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transfer, "ts")
    var status interface{} = this.SafeStringLower(transfer, "status")
    var currencyId interface{} = this.SafeString(transfer, "coin")
    var fromAccountRaw interface{} = this.SafeString(transfer, "fromType")
    var accountsById interface{} = this.SafeValue(this.Options, "accountsById", map[string]interface{} {})
    var fromAccount interface{} = this.SafeString(accountsById, fromAccountRaw, fromAccountRaw)
    var toAccountRaw interface{} = this.SafeString(transfer, "toType")
    var toAccount interface{} = this.SafeString(accountsById, toAccountRaw, toAccountRaw)
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transferId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "size"),
        "fromAccount": fromAccount,
        "toAccount": toAccount,
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *bitget) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "successful": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitget) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "chains": [
    //             {
    //                 "browserUrl": "https://blockchair.com/bitcoin/transaction/",
    //                 "chain": "BTC",
    //                 "depositConfirm": "1",
    //                 "extraWithdrawFee": "0",
    //                 "minDepositAmount": "0.0001",
    //                 "minWithdrawAmount": "0.005",
    //                 "needTag": "false",
    //                 "rechargeable": "true",
    //                 "withdrawConfirm": "1",
    //                 "withdrawFee": "0.0004",
    //                 "withdrawable": "true"
    //             },
    //         ],
    //         "coin": "BTC",
    //         "coinId": "1",
    //         "transfer": "true""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var chains interface{} = this.SafeValue(fee, "chains", []interface{}{})
    var chainsLength interface{} =     GetArrayLength(chains)
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    for i := 0; IsLessThan(i, chainsLength); i++ {
        var chain interface{} = GetValue(chains, i)
        var networkId interface{} = this.SafeString(chain, "chain")
        var currencyCode interface{} = this.SafeString(currency, "code")
        var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
        AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(chain, "withdrawFee"),
        "percentage": false,
    },
})
        if IsTrue(IsEqual(chainsLength, 1)) {
            AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(chain, "withdrawFee"))
            AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
        }
    }
    return result
}
/**
 * @method
 * @name bitget#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitget) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes78368 := (<-this.LoadMarkets())
            PanicOnError(retRes78368)
        
            response:= (<-this.PublicSpotGetV2SpotPublicCoins(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "data": [
            //             {
            //                 "chains": [
            //                     {
            //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
            //                         "chain": "BTC",
            //                         "depositConfirm": "1",
            //                         "extraWithdrawFee": "0",
            //                         "minDepositAmount": "0.0001",
            //                         "minWithdrawAmount": "0.005",
            //                         "needTag": "false",
            //                         "rechargeable": "true",
            //                         "withdrawConfirm": "1",
            //                         "withdrawFee": "0.0004",
            //                         "withdrawable": "true"
            //                     },
            //                 ],
            //                 "coin": "BTC",
            //                 "coinId": "1",
            //                 "transfer": "true""
            //             }
            //         ],
            //         "msg": "success",
            //         "requestTime": "1700120731773"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseDepositWithdrawFees(data, codes, "coin")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Borrow
 * @param {string} code unified currency code of the currency to borrow
 * @param {string} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitget) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes78828 := (<-this.LoadMarkets())
            PanicOnError(retRes78828)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "borrowAmount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivateMarginPostV2MarginCrossedAccountBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700876470931,
            //         "data": {
            //             "loanId": "1112122013642272769",
            //             "coin": "USDT",
            //             "borrowAmount": "4"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Borrow
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to borrow
 * @param {string} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitget) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes79178 := (<-this.LoadMarkets())
            PanicOnError(retRes79178)
            var currency interface{} = this.Currency(code)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "borrowAmount": this.CurrencyToPrecision(code, amount),
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateMarginPostV2MarginIsolatedAccountBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700877255605,
            //         "data": {
            //             "loanId": "1112125304879067137",
            //             "symbol": "BTCUSDT",
            //             "coin": "USDT",
            //             "borrowAmount": "4"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Repay
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {string} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitget) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes79558 := (<-this.LoadMarkets())
            PanicOnError(retRes79558)
            var currency interface{} = this.Currency(code)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "repayAmount": this.CurrencyToPrecision(code, amount),
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateMarginPostV2MarginIsolatedAccountRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700877518012,
            //         "data": {
            //             "remainDebtAmount": "0",
            //             "repayId": "1112126405439270912",
            //             "symbol": "BTCUSDT",
            //             "coin": "USDT",
            //             "repayAmount": "8.000137"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Repay
 * @param {string} code unified currency code of the currency to repay
 * @param {string} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitget) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes79938 := (<-this.LoadMarkets())
            PanicOnError(retRes79938)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "repayAmount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivateMarginPostV2MarginCrossedAccountRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700876704885,
            //         "data": {
            //             "remainDebtAmount": "0",
            //             "repayId": "1112122994945830912",
            //             "coin": "USDT",
            //             "repayAmount": "4.00006834"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // isolated: borrowMargin
    //
    //     {
    //         "loanId": "1112125304879067137",
    //         "symbol": "BTCUSDT",
    //         "coin": "USDT",
    //         "borrowAmount": "4"
    //     }
    //
    // cross: borrowMargin
    //
    //     {
    //         "loanId": "1112122013642272769",
    //         "coin": "USDT",
    //         "borrowAmount": "4"
    //     }
    //
    // isolated: repayMargin
    //
    //     {
    //         "remainDebtAmount": "0",
    //         "repayId": "1112126405439270912",
    //         "symbol": "BTCUSDT",
    //         "coin": "USDT",
    //         "repayAmount": "8.000137"
    //     }
    //
    // cross: repayMargin
    //
    //     {
    //         "remainDebtAmount": "0",
    //         "repayId": "1112122994945830912",
    //         "coin": "USDT",
    //         "repayAmount": "4.00006834"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var currencyId interface{} = this.SafeString(info, "coin")
    var marketId interface{} = this.SafeString(info, "symbol")
    var symbol interface{} = nil
    if IsTrue(!IsEqual(marketId, nil)) {
        symbol = this.SafeSymbol(marketId, market, nil, "spot")
    }
    return map[string]interface{} {
        "id": this.SafeString2(info, "loanId", "repayId"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber2(info, "borrowAmount", "repayAmount"),
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
/**
 * @method
 * @name bitget#fetchMyLiquidations
 * @description retrieves the users liquidated positions
 * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Liquidation-Records
 * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Liquidation-Records
 * @param {string} [symbol] unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitget api endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @param {string} [params.marginMode] 'cross' or 'isolated' default value is 'cross'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func  (this *bitget) FetchMyLiquidations(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes80888 := (<-this.LoadMarkets())
            PanicOnError(retRes80888)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyLiquidations", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes809219 :=  (<-this.FetchPaginatedCallCursor("fetchMyLiquidations", symbol, since, limit, params, "minId", "idLessThan"))
                    PanicOnError(retRes809219)
                    ch <- retRes809219
                    return nil
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchMyLiquidations", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(!IsEqual(typeVar, "spot")) {
                panic(NotSupported(Add(this.Id, " fetchMyLiquidations() supports spot margin markets only")))
            }
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            } else {
                AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyLiquidations", params, "cross");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsEqual(marginMode, "isolated")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchMyLiquidations() requires a symbol argument")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PrivateMarginGetV2MarginIsolatedLiquidationHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "cross")) {
                
        response = (<-this.PrivateMarginGetV2MarginCrossedLiquidationHistory(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // isolated
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1698114119193,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "liqId": "123",
            //                     "symbol": "BTCUSDT",
            //                     "liqStartTime": "1653453245342",
            //                     "liqEndTime": "16312423423432",
            //                     "liqRiskRatio": "1.01",
            //                     "totalAssets": "1242.34",
            //                     "totalDebt": "1100",
            //                     "liqFee": "1.2",
            //                     "uTime": "1668134458717",
            //                     "cTime": "1653453245342"
            //                 }
            //             ],
            //             "maxId": "0",
            //             "minId": "0"
            //         }
            //     }
            //
            // cross
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1698114119193,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "liqId": "123",
            //                     "liqStartTime": "1653453245342",
            //                     "liqEndTime": "16312423423432",
            //                     "liqRiskRatio": "1.01",
            //                     "totalAssets": "1242.34",
            //                     "totalDebt": "1100",
            //                     "LiqFee": "1.2",
            //                     "uTime": "1668134458717",
            //                     "cTime": "1653453245342"
            //                 }
            //             ],
            //             "maxId": "0",
            //             "minId": "0"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var liquidations interface{} = this.SafeList(data, "resultList", []interface{}{})
        
            ch <- this.ParseLiquidations(liquidations, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // isolated
    //
    //     {
    //         "liqId": "123",
    //         "symbol": "BTCUSDT",
    //         "liqStartTime": "1653453245342",
    //         "liqEndTime": "16312423423432",
    //         "liqRiskRatio": "1.01",
    //         "totalAssets": "1242.34",
    //         "totalDebt": "1100",
    //         "liqFee": "1.2",
    //         "uTime": "1692690126000"
    //         "cTime": "1653453245342"
    //     }
    //
    // cross
    //
    //     {
    //         "liqId": "123",
    //         "liqStartTime": "1653453245342",
    //         "liqEndTime": "16312423423432",
    //         "liqRiskRatio": "1.01",
    //         "totalAssets": "1242.34",
    //         "totalDebt": "1100",
    //         "LiqFee": "1.2",
    //         "uTime": "1692690126000"
    //         "cTime": "1653453245342"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(liquidation, "symbol")
    var timestamp interface{} = this.SafeInteger(liquidation, "liqEndTime")
    var liquidationFee interface{} = this.SafeString2(liquidation, "LiqFee", "liqFee")
    var totalDebt interface{} = this.SafeString(liquidation, "totalDebt")
    var quoteValueString interface{} = Precise.StringAdd(liquidationFee, totalDebt)
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": nil,
        "contractSize": nil,
        "price": nil,
        "baseValue": nil,
        "quoteValue": this.ParseNumber(quoteValueString),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
/**
 * @method
 * @name bitget#fetchIsolatedBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Margin-Interest-Rate-And-Max-Borrowable-Amount
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
 */
func  (this *bitget) FetchIsolatedBorrowRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes82418 := (<-this.LoadMarkets())
            PanicOnError(retRes82418)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateMarginGetV2MarginIsolatedInterestRateAndLimit(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700878692567,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "leverage": "10",
            //                 "baseCoin": "BTC",
            //                 "baseTransferable": true,
            //                 "baseBorrowable": true,
            //                 "baseDailyInterestRate": "0.00007",
            //                 "baseAnnuallyInterestRate": "0.02555",
            //                 "baseMaxBorrowableAmount": "27",
            //                 "baseVipList": [
            //                     {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
            //                     {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
            //                     {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
            //                     {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
            //                     {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
            //                     {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
            //                 ],
            //                 "quoteCoin": "USDT",
            //                 "quoteTransferable": true,
            //                 "quoteBorrowable": true,
            //                 "quoteDailyInterestRate": "0.00041095",
            //                 "quoteAnnuallyInterestRate": "0.14999675",
            //                 "quoteMaxBorrowableAmount": "300000",
            //                 "quoteList": [
            //                     {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
            //                     {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
            //                     {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
            //                     {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
            //                     {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
            //                     {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
            //                 ]
            //             }
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "requestTime")
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var first interface{} = this.SafeValue(data, 0, map[string]interface{} {})
            AddElementToObject(first, "timestamp", timestamp)
        
            ch <- this.ParseIsolatedBorrowRate(first, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "leverage": "10",
    //         "baseCoin": "BTC",
    //         "baseTransferable": true,
    //         "baseBorrowable": true,
    //         "baseDailyInterestRate": "0.00007",
    //         "baseAnnuallyInterestRate": "0.02555",
    //         "baseMaxBorrowableAmount": "27",
    //         "baseVipList": [
    //             {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
    //             {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
    //             {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
    //             {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
    //             {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
    //             {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
    //         ],
    //         "quoteCoin": "USDT",
    //         "quoteTransferable": true,
    //         "quoteBorrowable": true,
    //         "quoteDailyInterestRate": "0.00041095",
    //         "quoteAnnuallyInterestRate": "0.14999675",
    //         "quoteMaxBorrowableAmount": "300000",
    //         "quoteList": [
    //             {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
    //             {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
    //             {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
    //             {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
    //             {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
    //             {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "spot")
    var baseId interface{} = this.SafeString(info, "baseCoin")
    var quoteId interface{} = this.SafeString(info, "quoteCoin")
    var timestamp interface{} = this.SafeInteger(info, "timestamp")
    return map[string]interface{} {
        "symbol": symbol,
        "base": this.SafeCurrencyCode(baseId),
        "baseRate": this.SafeNumber(info, "baseDailyInterestRate"),
        "quote": this.SafeCurrencyCode(quoteId),
        "quoteRate": this.SafeNumber(info, "quoteDailyInterestRate"),
        "period": 86400000,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
/**
 * @method
 * @name bitget#fetchCrossBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Margin-Interest-Rate-And-Borrowable
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] required for isolated margin
 * @returns {object} a [borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#borrow-rate-structure}
 */
func  (this *bitget) FetchCrossBorrowRate(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes83598 := (<-this.LoadMarkets())
            PanicOnError(retRes83598)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivateMarginGetV2MarginCrossedInterestRateAndLimit(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700879047861,
            //         "data": [
            //             {
            //                 "coin": "BTC",
            //                 "leverage": "3",
            //                 "transferable": true,
            //                 "borrowable": true,
            //                 "dailyInterestRate": "0.00007",
            //                 "annualInterestRate": "0.02555",
            //                 "maxBorrowableAmount": "26",
            //                 "vipList": [
            //                     {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
            //                     {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
            //                     {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
            //                     {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
            //                     {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
            //                     {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
            //                 ]
            //             }
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "requestTime")
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var first interface{} = this.SafeValue(data, 0, map[string]interface{} {})
            AddElementToObject(first, "timestamp", timestamp)
        
            ch <- this.ParseBorrowRate(first, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "coin": "BTC",
    //         "leverage": "3",
    //         "transferable": true,
    //         "borrowable": true,
    //         "dailyInterestRate": "0.00007",
    //         "annualInterestRate": "0.02555",
    //         "maxBorrowableAmount": "26",
    //         "vipList": [
    //             {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
    //             {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
    //             {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
    //             {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
    //             {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
    //             {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
    //         ]
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(info, "coin")
    var timestamp interface{} = this.SafeInteger(info, "timestamp")
    return map[string]interface{} {
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "rate": this.SafeNumber(info, "dailyInterestRate"),
        "period": 86400000,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
/**
 * @method
 * @name bitget#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Interest-Records
 * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Interest-Records
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol when fetching interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func  (this *bitget) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes84458 := (<-this.LoadMarkets())
            PanicOnError(retRes84458)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchBorrowInterest", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes844919 :=  (<-this.FetchPaginatedCallCursor("fetchBorrowInterest", symbol, since, limit, params, "minId", "idLessThan"))
                    PanicOnError(retRes844919)
                    ch <- retRes844919
                    return nil
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            } else {
                AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), 7776000000))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params, "cross");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsEqual(marginMode, "isolated")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchBorrowInterest() requires a symbol argument")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PrivateMarginGetV2MarginIsolatedInterestHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marginMode, "cross")) {
                
        response = (<-this.PrivateMarginGetV2MarginCrossedInterestHistory(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // isolated
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700879935189,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "interestId": "1112125304879067137",
            //                     "interestCoin": "USDT",
            //                     "dailyInterestRate": "0.00041095",
            //                     "loanCoin": "USDT",
            //                     "interestAmount": "0.0000685",
            //                     "interstType": "first",
            //                     "symbol": "BTCUSDT",
            //                     "cTime": "1700877255648",
            //                     "uTime": "1700877255648"
            //                 },
            //             ],
            //             "maxId": "1112125304879067137",
            //             "minId": "1100138015672119298"
            //         }
            //     }
            //
            // cross
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700879597044,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "interestId": "1112122013642272769",
            //                     "interestCoin": "USDT",
            //                     "dailyInterestRate": "0.00041",
            //                     "loanCoin": "USDT",
            //                     "interestAmount": "0.00006834",
            //                     "interstType": "first",
            //                     "cTime": "1700876470957",
            //                     "uTime": "1700876470957"
            //                 },
            //             ],
            //             "maxId": "1112122013642272769",
            //             "minId": "1096917004629716993"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeValue(data, "resultList", []interface{}{})
            var interest interface{} = this.ParseBorrowInterests(rows, market)
        
            ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // isolated
    //
    //     {
    //         "interestId": "1112125304879067137",
    //         "interestCoin": "USDT",
    //         "dailyInterestRate": "0.00041095",
    //         "loanCoin": "USDT",
    //         "interestAmount": "0.0000685",
    //         "interstType": "first",
    //         "symbol": "BTCUSDT",
    //         "cTime": "1700877255648",
    //         "uTime": "1700877255648"
    //     }
    //
    // cross
    //
    //     {
    //         "interestId": "1112122013642272769",
    //         "interestCoin": "USDT",
    //         "dailyInterestRate": "0.00041",
    //         "loanCoin": "USDT",
    //         "interestAmount": "0.00006834",
    //         "interstType": "first",
    //         "cTime": "1700876470957",
    //         "uTime": "1700876470957"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    market = this.SafeMarket(marketId, market)
    var marginMode interface{} = Ternary(IsTrue((!IsEqual(marketId, nil))), "isolated", "cross")
    var timestamp interface{} = this.SafeInteger(info, "cTime")
    return map[string]interface{} {
        "info": info,
        "symbol": this.SafeString(market, "symbol"),
        "currency": this.SafeCurrencyCode(this.SafeString(info, "interestCoin")),
        "interest": this.SafeNumber(info, "interestAmount"),
        "interestRate": this.SafeNumber(info, "dailyInterestRate"),
        "amountBorrowed": nil,
        "marginMode": marginMode,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name bitget#closePosition
 * @description closes an open position for a market
 * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
 * @param {string} symbol unified CCXT market symbol
 * @param {string} [side] one-way mode: 'buy' or 'sell', hedge-mode: 'long' or 'short'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitget) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    side := GetArg(optionalArgs, 0, nil)
            _ = side
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes85948 := (<-this.LoadMarkets())
            PanicOnError(retRes85948)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "productType": productType,
            }
            if IsTrue(!IsEqual(side, nil)) {
                AddElementToObject(request, "holdSide", side)
            }
        
            response:= (<-this.PrivateMixPostV2MixOrderClosePositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1702975017017,
            //         "data": {
            //             "successList": [
            //                 {
            //                     "orderId": "1120923953904893955",
            //                     "clientOid": "1120923953904893956"
            //                 }
            //             ],
            //             "failureList": [],
            //             "result": false
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var order interface{} = this.SafeList(data, "successList", []interface{}{})
        
            ch <- this.ParseOrder(GetValue(order, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#closeAllPositions
 * @description closes all open positions for a market type
 * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitget) CloseAllPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes86458 := (<-this.LoadMarkets())
            PanicOnError(retRes86458)
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(nil, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixPostV2MixOrderClosePositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1702975017017,
            //         "data": {
            //             "successList": [
            //                 {
            //                     "orderId": "1120923953904893955",
            //                     "clientOid": "1120923953904893956"
            //                 }
            //             ],
            //             "failureList": [],
            //             "result": false
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orderInfo interface{} = this.SafeList(data, "successList", []interface{}{})
        
            ch <- this.ParsePositions(orderInfo, nil, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchMarginMode
 * @description fetches the margin mode of a trading pair
 * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *bitget) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes86848 := (<-this.LoadMarkets())
            PanicOnError(retRes86848)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "productType": productType,
            }
        
            response:= (<-this.PrivateMixGetV2MixAccountAccount(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1709791216652,
            //         "data": {
            //             "marginCoin": "USDT",
            //             "locked": "0",
            //             "available": "19.88811074",
            //             "crossedMaxAvailable": "19.88811074",
            //             "isolatedMaxAvailable": "19.88811074",
            //             "maxTransferOut": "19.88811074",
            //             "accountEquity": "19.88811074",
            //             "usdtEquity": "19.888110749166",
            //             "btcEquity": "0.000302183391",
            //             "crossedRiskRate": "0",
            //             "crossedMarginLeverage": 20,
            //             "isolatedLongLever": 20,
            //             "isolatedShortLever": 20,
            //             "marginMode": "crossed",
            //             "posMode": "hedge_mode",
            //             "unrealizedPL": "0",
            //             "coupon": "0",
            //             "crossedUnrealizedPL": "0",
            //             "isolatedUnrealizedPL": ""
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginMode(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginType interface{} = this.SafeString(marginMode, "marginMode")
    marginType = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", marginType)
    return map[string]interface{} {
        "info": marginMode,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginType,
    }
}
/**
 * @method
 * @name bitget#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
 * @param {string[]} [symbols] unified contract symbols
 * @param {int} [since] timestamp in ms of the earliest position to fetch, default=3 months ago, max range for params["until"] - since is 3 months
 * @param {int} [limit] the maximum amount of records to fetch, default=20, max=100
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest position to fetch, max range for params["until"] - since is 3 months
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.productType] USDT-FUTURES (default), COIN-FUTURES, USDC-FUTURES, SUSDT-FUTURES, SCOIN-FUTURES, or SUSDC-FUTURES
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitget) FetchPositionsHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes87598 := (<-this.LoadMarkets())
            PanicOnError(retRes87598)
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         GetArrayLength(symbols)
                if IsTrue(IsGreaterThan(symbolsLength, 0)) {
                    var market interface{} = this.Market(GetValue(symbols, 0))
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateMixGetV2MixPositionHistoryPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        code: '00000',
            //        msg: 'success',
            //        requestTime: '1712794148791',
            //        data: {
            //            list: [
            //                {
            //                    symbol: 'XRPUSDT',
            //                    marginCoin: 'USDT',
            //                    holdSide: 'long',
            //                    openAvgPrice: '0.64967',
            //                    closeAvgPrice: '0.58799',
            //                    marginMode: 'isolated',
            //                    openTotalPos: '10',
            //                    closeTotalPos: '10',
            //                    pnl: '-0.62976205',
            //                    netProfit: '-0.65356802',
            //                    totalFunding: '-0.01638',
            //                    openFee: '-0.00389802',
            //                    closeFee: '-0.00352794',
            //                    ctime: '1709590322199',
            //                    utime: '1709667583395'
            //                },
            //                ...
            //            ]
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data")
            var responseList interface{} = this.SafeList(data, "list")
            var positions interface{} = this.ParsePositions(responseList, symbols, params)
        
            ch <- this.FilterBySinceLimit(positions, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://www.bitget.com/api-doc/common/convert/Get-Quoted-Price
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *bitget) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes88278 := (<-this.LoadMarkets())
            PanicOnError(retRes88278)
            var request interface{} = map[string]interface{} {
                "fromCoin": fromCode,
                "toCoin": toCode,
                "fromCoinSize": this.NumberToString(amount),
            }
        
            response:= (<-this.PrivateConvertGetV2ConvertQuotedPrice(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1712121940158,
            //         "data": {
            //             "fromCoin": "USDT",
            //             "fromCoinSize": "5",
            //             "cnvtPrice": "0.9993007892377704",
            //             "toCoin": "USDC",
            //             "toCoinSize": "4.99650394",
            //             "traceId": "1159288930228187140",
            //             "fee": "0"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fromCurrencyId interface{} = this.SafeString(data, "fromCoin", fromCode)
            var fromCurrency interface{} = this.Currency(fromCurrencyId)
            var toCurrencyId interface{} = this.SafeString(data, "toCoin", toCode)
            var toCurrency interface{} = this.Currency(toCurrencyId)
        
            ch <- this.ParseConversion(data, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#createConvertTrade
 * @description convert from one currency to another
 * @see https://www.bitget.com/api-doc/common/convert/Trade
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} amount how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.price the price of the conversion, obtained from fetchConvertQuote()
 * @param {string} params.toAmount the amount you want to trade in units of the toCurrency, obtained from fetchConvertQuote()
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *bitget) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes88738 := (<-this.LoadMarkets())
            PanicOnError(retRes88738)
            var price interface{} = this.SafeString2(params, "price", "cnvtPrice")
            if IsTrue(IsEqual(price, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createConvertTrade() requires a price parameter")))
            }
            var toAmount interface{} = this.SafeString2(params, "toAmount", "toCoinSize")
            if IsTrue(IsEqual(toAmount, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createConvertTrade() requires a toAmount parameter")))
            }
            params = this.Omit(params, []interface{}{"price", "toAmount"})
            var request interface{} = map[string]interface{} {
                "traceId": id,
                "fromCoin": fromCode,
                "toCoin": toCode,
                "fromCoinSize": this.NumberToString(amount),
                "toCoinSize": toAmount,
                "cnvtPrice": price,
            }
        
            response:= (<-this.PrivateConvertPostV2ConvertTrade(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1712123746203,
            //         "data": {
            //             "cnvtPrice": "0.99940076",
            //             "toCoin": "USDC",
            //             "toCoinSize": "4.99700379",
            //             "ts": "1712123746217"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var toCurrencyId interface{} = this.SafeString(data, "toCoin", toCode)
            var toCurrency interface{} = this.Currency(toCurrencyId)
        
            ch <- this.ParseConversion(data, nil, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Record
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *bitget) FetchConvertTradeHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes89238 := (<-this.LoadMarkets())
            PanicOnError(retRes89238)
            var request interface{} = map[string]interface{} {}
            var msInDay interface{} = 86400000
            var now interface{} = this.Milliseconds()
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            } else {
                AddElementToObject(request, "startTime", Subtract(now, msInDay))
            }
            var endTime interface{} = this.SafeString2(params, "endTime", "until")
            if IsTrue(!IsEqual(endTime, nil)) {
                AddElementToObject(request, "endTime", endTime)
            } else {
                AddElementToObject(request, "endTime", now)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            params = this.Omit(params, "until")
        
            response:= (<-this.PrivateConvertGetV2ConvertConvertRecord(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1712124371799,
            //         "data": {
            //             "dataList": [
            //                 {
            //                     "id": "1159296505255219205",
            //                     "fromCoin": "USDT",
            //                     "fromCoinSize": "5",
            //                     "cnvtPrice": "0.99940076",
            //                     "toCoin": "USDC",
            //                     "toCoinSize": "4.99700379",
            //                     "ts": "1712123746217",
            //                     "fee": "0"
            //                 }
            //             ],
            //             "endId": "1159296505255219205"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var dataList interface{} = this.SafeList(data, "dataList", []interface{}{})
        
            ch <- this.ParseConversions(dataList, code, "fromCoin", "toCoin", since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchConvertQuote
    //
    //     {
    //         "fromCoin": "USDT",
    //         "fromCoinSize": "5",
    //         "cnvtPrice": "0.9993007892377704",
    //         "toCoin": "USDC",
    //         "toCoinSize": "4.99650394",
    //         "traceId": "1159288930228187140",
    //         "fee": "0"
    //     }
    //
    // createConvertTrade
    //
    //     {
    //         "cnvtPrice": "0.99940076",
    //         "toCoin": "USDC",
    //         "toCoinSize": "4.99700379",
    //         "ts": "1712123746217"
    //     }
    //
    // fetchConvertTradeHistory
    //
    //     {
    //         "id": "1159296505255219205",
    //         "fromCoin": "USDT",
    //         "fromCoinSize": "5",
    //         "cnvtPrice": "0.99940076",
    //         "toCoin": "USDC",
    //         "toCoinSize": "4.99700379",
    //         "ts": "1712123746217",
    //         "fee": "0"
    //     }
    //
    fromCurrency := GetArg(optionalArgs, 0, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 1, nil)
    _ = toCurrency
    var timestamp interface{} = this.SafeInteger(conversion, "ts")
    var fromCoin interface{} = this.SafeString(conversion, "fromCoin")
    var fromCode interface{} = this.SafeCurrencyCode(fromCoin, fromCurrency)
    var to interface{} = this.SafeString(conversion, "toCoin")
    var toCode interface{} = this.SafeCurrencyCode(to, toCurrency)
    return map[string]interface{} {
        "info": conversion,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString2(conversion, "id", "traceId"),
        "fromCurrency": fromCode,
        "fromAmount": this.SafeNumber(conversion, "fromCoinSize"),
        "toCurrency": toCode,
        "toAmount": this.SafeNumber(conversion, "toCoinSize"),
        "price": this.SafeNumber(conversion, "cnvtPrice"),
        "fee": this.SafeNumber(conversion, "fee"),
    }
}
/**
 * @method
 * @name bitget#fetchConvertCurrencies
 * @description fetches all available currencies that can be converted
 * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *bitget) FetchConvertCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes90348 := (<-this.LoadMarkets())
            PanicOnError(retRes90348)
        
            response:= (<-this.PrivateConvertGetV2ConvertCurrencies(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1712121755897,
            //         "data": [
            //             {
            //                 "coin": "BTC",
            //                 "available": "0.00009850",
            //                 "maxAmount": "0.756266",
            //                 "minAmount": "0.00001"
            //             },
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(entry, "coin")
                var code interface{} = this.SafeCurrencyCode(id)
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "id": id,
            "code": code,
            "networks": nil,
            "type": nil,
            "name": nil,
            "active": nil,
            "deposit": nil,
            "withdraw": this.SafeNumber(entry, "available"),
            "fee": nil,
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": this.SafeNumber(entry, "minAmount"),
                    "max": this.SafeNumber(entry, "maxAmount"),
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "created": nil,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Next-Funding-Time
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *bitget) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes90998 := (<-this.LoadMarkets())
            PanicOnError(retRes90998)
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var market interface{} = nil
            if IsTrue(sandboxMode) {
                var sandboxSymbol interface{} = this.ConvertSymbolForSandbox(symbol)
                market = this.Market(sandboxSymbol)
            } else {
                market = this.Market(symbol)
            }
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleProductTypeAndParams(market, params);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "productType": productType,
            }
        
            response:= (<-this.PublicMixGetV2MixMarketFundingTime(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1727930153888,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "nextFundingTime": "1727942400000",
            //                 "ratePeriod": "8"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseFundingRate(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#fetchLongShortRatioHistory
 * @description fetches the long short ratio history for a unified market symbol
 * @see https://www.bitget.com/api-doc/common/apidata/Margin-Ls-Ratio
 * @see https://www.bitget.com/api-doc/common/apidata/Account-Long-Short
 * @param {string} symbol unified symbol of the market to fetch the long short ratio for
 * @param {string} [timeframe] the period for the ratio
 * @param {int} [since] the earliest time in ms to fetch ratios for
 * @param {int} [limit] the maximum number of long short ratio structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/#/?id=long-short-ratio-structure}
 */
func  (this *bitget) FetchLongShortRatioHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            timeframe := GetArg(optionalArgs, 1, nil)
            _ = timeframe
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes91488 := (<-this.LoadMarkets())
            PanicOnError(retRes91488)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(timeframe, nil)) {
                AddElementToObject(request, "period", timeframe)
            }
            var response interface{} = nil
            if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
                
        response = (<-this.PublicMixGetV2MixMarketAccountLongShort(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicMarginGetV2MarginMarketLongShortRatio(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseLongShortRatioHistory(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitget) ParseLongShortRatio(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var timestamp interface{} = this.SafeIntegerOmitZero(info, "ts")
    return map[string]interface{} {
        "info": info,
        "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "timeframe": nil,
        "longShortRatio": this.SafeNumber2(info, "longShortRatio", "longShortAccountRatio"),
    }
}
func  (this *bitget) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    // spot
    //
    //     {"code":"00000","msg":"success","requestTime":1713294492511,"data":[...]}"
    //
    //     {"status":"fail","err_code":"01001","err_msg":"系统异常，请稍后重试"}
    //     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
    //     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
    //     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
    //     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
    //     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
    //     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
    //     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
    //     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
    //     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
    //
    // swap
    //
    //     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
    //     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
    //     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
    //     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
    //     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
    //     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
    //     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":"订单不存在！"}
    //
    var message interface{} = this.SafeString2(response, "err_msg", "msg")
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var nonEmptyMessage interface{} =     (IsTrue(IsTrue((!IsEqual(message, nil))) && IsTrue((!IsEqual(message, "")))) && IsTrue((!IsEqual(message, "success"))))
    if IsTrue(nonEmptyMessage) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
    }
    var errorCode interface{} = this.SafeString2(response, "code", "err_code")
    var nonZeroErrorCode interface{} = IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "00000")))
    if IsTrue(nonZeroErrorCode) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    }
    if IsTrue(IsTrue(nonZeroErrorCode) || IsTrue(nonEmptyMessage)) {
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *bitget) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *bitget) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var signed interface{} = IsEqual(GetValue(api, 0), "private")
    var endpoint interface{} = GetValue(api, 1)
    var pathPart interface{} = "/api"
    var request interface{} = Add("/", this.ImplodeParams(path, params))
    var payload interface{} = Add(pathPart, request)
    var url interface{} = Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), endpoint)), payload)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(!IsTrue(signed) && IsTrue((IsEqual(method, "GET")))) {
        var keys interface{} = ObjectKeys(query)
        var keysLength interface{} =         GetArrayLength(keys)
        if IsTrue(IsGreaterThan(keysLength, 0)) {
            url = Add(Add(url, "?"), this.Urlencode(query))
        }
    }
    if IsTrue(signed) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Nonce())
        var auth interface{} = Add(Add(timestamp, method), payload)
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(params)
            auth = Add(auth, body)
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(params))) {
                var queryInner interface{} = Add("?", this.Urlencode(this.Keysort(params)))
                // check #21169 pr
                if IsTrue(IsGreaterThan(GetIndexOf(queryInner, "%24"), OpNeg(1))) {
                    queryInner = Replace(queryInner, "%24", "$")
                }
                url = Add(url, queryInner)
                auth = Add(auth, queryInner)
            }
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256, "base64")
        var broker interface{} = this.SafeString(this.Options, "broker")
        headers = map[string]interface{} {
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-SIGN": signature,
            "ACCESS-TIMESTAMP": timestamp,
            "ACCESS-PASSPHRASE": this.Password,
            "X-CHANNEL-API-CODE": broker,
        }
        if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-Type", "application/json")
        }
    }
    var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
    if IsTrue(sandboxMode) {
        if IsTrue(IsEqual(headers, nil)) {
            headers = map[string]interface{} {}
        }
        AddElementToObject(headers, "PAPTRADING", "1")
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *bitget) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
