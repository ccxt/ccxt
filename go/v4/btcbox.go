package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type btcbox struct {
    Exchange

}

func NewBtcboxCore() btcbox {
   p := btcbox{}
   setDefaults(&p)
   return p
}

func  (this *btcbox) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "btcbox",
        "name": "BtcBox",
        "countries": []interface{}{"JP"},
        "rateLimit": 1000,
        "version": "v1",
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
            "ws": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/1e2cb499-8d0f-4f8f-9464-3c015cfbc76b",
            "api": map[string]interface{} {
                "rest": "https://www.btcbox.co.jp/api",
            },
            "www": "https://www.btcbox.co.jp/",
            "doc": "https://blog.btcbox.jp/en/archives/8762",
            "fees": "https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"depth", "orders", "ticker", "tickers"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"balance", "trade_add", "trade_cancel", "trade_list", "trade_view", "wallet"},
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "104": AuthenticationError,
            "105": PermissionDenied,
            "106": InvalidNonce,
            "107": InvalidOrder,
            "200": InsufficientFunds,
            "201": InvalidOrder,
            "202": InvalidOrder,
            "203": OrderNotFound,
            "401": OrderNotFound,
            "402": DDoSProtection,
        },
    })
}
/**
 * @method
 * @name btcbox#fetchMarkets
 * @description retrieves data on all markets for ace
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *btcbox) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTickers())
            PanicOnError(response)
            //
            var marketIds interface{} = ObjectKeys(response)
            var markets interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var symbolParts interface{} = Split(marketId, "_")
                var baseCurr interface{} = this.SafeString(symbolParts, 0)
                var quote interface{} = this.SafeString(symbolParts, 1)
                var quoteId interface{} = ToLower(quote)
                var id interface{} = ToLower(baseCurr)
                var res interface{} = GetValue(response, marketId)
                var symbol interface{} = Add(Add(baseCurr, "/"), quote)
                var fee interface{} = Ternary(IsTrue((IsEqual(id, "BTC"))), this.ParseNumber("0.0005"), this.ParseNumber("0.0010"))
                AppendToArray(&markets,this.SafeMarketStructure(map[string]interface{} {
                    "id": id,
                    "uppercaseId": nil,
                    "symbol": symbol,
                    "base": baseCurr,
                    "baseId": id,
                    "quote": quote,
                    "quoteId": quoteId,
                    "settle": nil,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "taker": fee,
                    "maker": fee,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "limits": map[string]interface{} {
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "precision": map[string]interface{} {
                        "price": nil,
                        "amount": nil,
                    },
                    "active": nil,
                    "created": nil,
                    "info": res,
                }))
            }
        
            ch <- markets
            return nil
        
            }()
            return ch
        }
func  (this *btcbox) ParseMarket(market interface{}) interface{}  {
    var baseId interface{} = this.SafeString(market, "base")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quoteId interface{} = this.SafeString(market, "quote")
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    return map[string]interface{} {
        "id": this.SafeString(market, "symbol"),
        "uppercaseId": nil,
        "symbol": symbol,
        "base": base,
        "baseId": baseId,
        "quote": quote,
        "quoteId": quoteId,
        "settle": nil,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minLimitBaseAmount"),
                "max": this.SafeNumber(market, "maxLimitBaseAmount"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "precision": map[string]interface{} {
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quotePrecision"))),
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "basePrecision"))),
        },
        "active": nil,
        "created": nil,
        "info": market,
    }
}
func  (this *btcbox) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var codes interface{} = ObjectKeys(this.Currencies)
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        var code interface{} = GetValue(codes, i)
        var currency interface{} = this.Currency(code)
        var currencyId interface{} = GetValue(currency, "id")
        var free interface{} = Add(currencyId, "_balance")
        if IsTrue(InOp(response, free)) {
            var account interface{} = this.Account()
            var used interface{} = Add(currencyId, "_lock")
            AddElementToObject(account, "free", this.SafeString(response, free))
            AddElementToObject(account, "used", this.SafeString(response, used))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name btcbox#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://blog.btcbox.jp/en/archives/8762#toc13
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *btcbox) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3528 := (<-this.LoadMarkets())
            PanicOnError(retRes3528)
        
            response:= (<-this.PrivatePostBalance(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://blog.btcbox.jp/en/archives/8762#toc6
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *btcbox) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3688 := (<-this.LoadMarkets())
            PanicOnError(retRes3688)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var numSymbols interface{} =     GetArrayLength(this.Symbols)
            if IsTrue(IsGreaterThan(numSymbols, 1)) {
                AddElementToObject(request, "coin", GetValue(market, "baseId"))
            }
        
            response:= (<-this.PublicGetDepth(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
func  (this *btcbox) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "vol"),
        "quoteVolume": this.SafeString(ticker, "volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name btcbox#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://blog.btcbox.jp/en/archives/8762#toc5
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcbox) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4168 := (<-this.LoadMarkets())
            PanicOnError(retRes4168)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var numSymbols interface{} =     GetArrayLength(this.Symbols)
            if IsTrue(IsGreaterThan(numSymbols, 1)) {
                AddElementToObject(request, "coin", GetValue(market, "baseId"))
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcbox) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4368 := (<-this.LoadMarkets())
            PanicOnError(retRes4368)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
        
            ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *btcbox) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "date":"0",
    //          "price":3,
    //          "amount":0.1,
    //          "tid":"1",
    //          "type":"buy"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp(trade, "date")
    market = this.SafeMarket(nil, market)
    var id interface{} = this.SafeString(trade, "tid")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var typeVar interface{} = nil
    var side interface{} = this.SafeString(trade, "type")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name btcbox#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://blog.btcbox.jp/en/archives/8762#toc7
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *btcbox) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4898 := (<-this.LoadMarkets())
            PanicOnError(retRes4898)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var numSymbols interface{} =     GetArrayLength(this.Symbols)
            if IsTrue(IsGreaterThan(numSymbols, 1)) {
                AddElementToObject(request, "coin", GetValue(market, "baseId"))
            }
        
            response:= (<-this.PublicGetOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //          {
            //              "date":"0",
            //              "price":3,
            //              "amount":0.1,
            //              "tid":"1",
            //              "type":"buy"
            //          },
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#createOrder
 * @description create a trade order
 * @see https://blog.btcbox.jp/en/archives/8762#toc18
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcbox) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5258 := (<-this.LoadMarkets())
            PanicOnError(retRes5258)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "amount": amount,
                "price": price,
                "type": side,
                "coin": GetValue(market, "baseId"),
            }
        
            response:= (<-this.PrivatePostTradeAdd(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result":true,
            //         "id":"11"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#cancelOrder
 * @description cancels an open order
 * @see https://blog.btcbox.jp/en/archives/8762#toc17
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcbox) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5548 := (<-this.LoadMarkets())
            PanicOnError(retRes5548)
            // a special case for btcbox – default symbol is BTC/JPY
            if IsTrue(IsEqual(symbol, nil)) {
                symbol = "BTC/JPY"
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": id,
                "coin": GetValue(market, "baseId"),
            }
        
            response:= (<-this.PrivatePostTradeCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {"result":true, "id":"11"}
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *btcbox) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "part": "open",
        "all": "closed",
        "cancelled": "canceled",
        "closed": "closed",
        "no": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcbox) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id":11,
    //         "datetime":"2014-10-21 10:47:20",
    //         "type":"sell",
    //         "price":42000,
    //         "amount_original":1.2,
    //         "amount_outstanding":1.2,
    //         "status":"closed",
    //         "trades":[] // no clarification of trade value structure of order endpoint
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var datetimeString interface{} = this.SafeString(order, "datetime")
    var timestamp interface{} = nil
    if IsTrue(!IsEqual(datetimeString, nil)) {
        timestamp = this.Parse8601(Add(GetValue(order, "datetime"), "+09:00")) // Tokyo time
    }
    var amount interface{} = this.SafeString(order, "amount_original")
    var remaining interface{} = this.SafeString(order, "amount_outstanding")
    var price interface{} = this.SafeString(order, "price")
    // status is set by fetchOrder method only
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    // fetchOrders do not return status, use heuristic
    if IsTrue(IsEqual(status, nil)) {
        if IsTrue(Precise.StringEquals(remaining, "0")) {
            status = "closed"
        }
    }
    var trades interface{} = nil // todo: this.parseTrades (order['trades']);
    market = this.SafeMarket(nil, market)
    var side interface{} = this.SafeString(order, "type")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "amount": amount,
        "remaining": remaining,
        "filled": nil,
        "side": side,
        "type": nil,
        "timeInForce": nil,
        "postOnly": nil,
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "trades": trades,
        "fee": nil,
        "info": order,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name btcbox#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://blog.btcbox.jp/en/archives/8762#toc16
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcbox) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6528 := (<-this.LoadMarkets())
            PanicOnError(retRes6528)
            // a special case for btcbox – default symbol is BTC/JPY
            if IsTrue(IsEqual(symbol, nil)) {
                symbol = "BTC/JPY"
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = this.Extend(map[string]interface{} {
                "id": id,
                "coin": GetValue(market, "baseId"),
            }, params)
        
            response:= (<-this.PrivatePostTradeView(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //      {
            //          "id":11,
            //          "datetime":"2014-10-21 10:47:20",
            //          "type":"sell",
            //          "price":42000,
            //          "amount_original":1.2,
            //          "amount_outstanding":1.2,
            //          "status":"closed",
            //          "trades":[]
            //      }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *btcbox) FetchOrdersByType(typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6798 := (<-this.LoadMarkets())
            PanicOnError(retRes6798)
            // a special case for btcbox – default symbol is BTC/JPY
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "type": typeVar,
                "coin": GetValue(market, "baseId"),
            }
        
            response:= (<-this.PrivatePostTradeList(this.Extend(request, params)))
            PanicOnError(response)
            //
            // [
            //      {
            //          "id":"7",
            //          "datetime":"2014-10-20 13:27:38",
            //          "type":"buy",
            //          "price":42750,
            //          "amount_original":0.235,
            //          "amount_outstanding":0.235
            //      },
            // ]
            //
            var orders interface{} = this.ParseOrders(response, market, since, limit)
            // status (open/closed/canceled) is undefined
            // btcbox does not return status, but we know it's 'open' as we queried for open orders
            if IsTrue(IsEqual(typeVar, "open")) {
                for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                    AddElementToObject(GetValue(orders, i), "status", "open")
                }
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://blog.btcbox.jp/en/archives/8762#toc15
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcbox) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes72215 :=  (<-this.FetchOrdersByType("all", symbol, since, limit, params))
                PanicOnError(retRes72215)
                ch <- retRes72215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcbox#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://blog.btcbox.jp/en/archives/8762#toc15
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcbox) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes73715 :=  (<-this.FetchOrdersByType("open", symbol, since, limit, params))
                PanicOnError(retRes73715)
                ch <- retRes73715
                return nil
        
            }()
            return ch
        }
func  (this *btcbox) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *btcbox) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.Version), "/"), path)
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var query interface{} = this.Extend(map[string]interface{} {
            "key": this.ApiKey,
            "nonce": nonce,
        }, params)
        var request interface{} = this.Urlencode(query)
        var secret interface{} = this.Hash(this.Encode(this.Secret), md5)
        AddElementToObject(query, "signature", this.Hmac(this.Encode(request), this.Encode(secret), sha256))
        body = this.Urlencode(query)
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *btcbox) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // resort to defaultErrorHandler
    }
    // typical error response: {"result":false,"code":"401"}
    if IsTrue(IsGreaterThanOrEqual(httpCode, 400)) {
        return nil  // resort to defaultErrorHandler
    }
    var result interface{} = this.SafeValue(response, "result")
    if IsTrue(IsTrue(IsEqual(result, nil)) || IsTrue(IsEqual(result, true))) {
        return nil  // either public API (no error codes expected) or success
    }
    var code interface{} = this.SafeValue(response, "code")
    var feedback interface{} = Add(Add(this.Id, " "), body)
    this.ThrowExactlyMatchedException(this.Exceptions, code, feedback)
    panic(ExchangeError(feedback))
}
func  (this *btcbox) Request(path interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    api := GetArg(optionalArgs, 0, "public")
            _ = api
            method := GetArg(optionalArgs, 1, "GET")
            _ = method
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            headers := GetArg(optionalArgs, 3, nil)
            _ = headers
            body := GetArg(optionalArgs, 4, nil)
            _ = body
            config := GetArg(optionalArgs, 5, map[string]interface{} {})
            _ = config
        
            response:= (<-this.Fetch2(path, api, method, params, headers, body, config))
            PanicOnError(response)
            if IsTrue(IsString(response)) {
                // sometimes the exchange returns whitespace prepended to json
                response = this.Strip(response)
                if !IsTrue(this.IsJsonEncodedObject(response)) {
                    panic(ExchangeError(Add(Add(this.Id, " "), response)))
                }
                response = JsonParse(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }


func (this *btcbox) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
