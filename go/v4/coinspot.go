package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinspot struct {
    Exchange

}

func NewCoinspotCore() coinspot {
   p := coinspot{}
   setDefaults(&p)
   return p
}

func  (this *coinspot) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinspot",
        "name": "CoinSpot",
        "countries": []interface{}{"AU"},
        "rateLimit": 1000,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketOrder": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "ws": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",
            "api": map[string]interface{} {
                "public": "https://www.coinspot.com.au/pubapi",
                "private": "https://www.coinspot.com.au/api",
            },
            "www": "https://www.coinspot.com.au",
            "doc": "https://www.coinspot.com.au/api",
            "referral": "https://www.coinspot.com.au/register?code=PJURCU",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"latest"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"orders", "orders/history", "my/coin/deposit", "my/coin/send", "quote/buy", "quote/sell", "my/balances", "my/orders", "my/buy", "my/sell", "my/buy/cancel", "my/sell/cancel", "ro/my/balances", "ro/my/balances/{cointype}", "ro/my/deposits", "ro/my/withdrawals", "ro/my/transactions", "ro/my/transactions/{cointype}", "ro/my/transactions/open", "ro/my/transactions/{cointype}/open", "ro/my/sendreceive", "ro/my/affiliatepayments", "ro/my/referralpayments"},
            },
        },
        "markets": map[string]interface{} {
            "ADA/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "ada",
                "symbol": "ADA/AUD",
                "base": "ADA",
                "quote": "AUD",
                "baseId": "ada",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "BTC/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "btc",
                "symbol": "BTC/AUD",
                "base": "BTC",
                "quote": "AUD",
                "baseId": "btc",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "ETH/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "eth",
                "symbol": "ETH/AUD",
                "base": "ETH",
                "quote": "AUD",
                "baseId": "eth",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "XRP/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "xrp",
                "symbol": "XRP/AUD",
                "base": "XRP",
                "quote": "AUD",
                "baseId": "xrp",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "LTC/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "ltc",
                "symbol": "LTC/AUD",
                "base": "LTC",
                "quote": "AUD",
                "baseId": "ltc",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "DOGE/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "doge",
                "symbol": "DOGE/AUD",
                "base": "DOGE",
                "quote": "AUD",
                "baseId": "doge",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "RFOX/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "rfox",
                "symbol": "RFOX/AUD",
                "base": "RFOX",
                "quote": "AUD",
                "baseId": "rfox",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "POWR/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "powr",
                "symbol": "POWR/AUD",
                "base": "POWR",
                "quote": "AUD",
                "baseId": "powr",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "NEO/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "neo",
                "symbol": "NEO/AUD",
                "base": "NEO",
                "quote": "AUD",
                "baseId": "neo",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "TRX/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "trx",
                "symbol": "TRX/AUD",
                "base": "TRX",
                "quote": "AUD",
                "baseId": "trx",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "EOS/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "eos",
                "symbol": "EOS/AUD",
                "base": "EOS",
                "quote": "AUD",
                "baseId": "eos",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "XLM/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "xlm",
                "symbol": "XLM/AUD",
                "base": "XLM",
                "quote": "AUD",
                "baseId": "xlm",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "RHOC/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "rhoc",
                "symbol": "RHOC/AUD",
                "base": "RHOC",
                "quote": "AUD",
                "baseId": "rhoc",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
            "GAS/AUD": this.SafeMarketStructure(map[string]interface{} {
                "id": "gas",
                "symbol": "GAS/AUD",
                "base": "GAS",
                "quote": "AUD",
                "baseId": "gas",
                "quoteId": "aud",
                "type": "spot",
                "spot": true,
            }),
        },
        "commonCurrencies": map[string]interface{} {
            "DRK": "DASH",
        },
        "options": map[string]interface{} {
            "fetchBalance": "private_post_my_balances",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": nil,
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *coinspot) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeValue2(response, "balance", "balances")
    if IsTrue(IsArray(balances)) {
        for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
            var currencies interface{} = GetValue(balances, i)
            var currencyIds interface{} = ObjectKeys(currencies)
            for j := 0; IsLessThan(j, GetArrayLength(currencyIds)); j++ {
                var currencyId interface{} = GetValue(currencyIds, j)
                var balance interface{} = GetValue(currencies, currencyId)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                AddElementToObject(account, "total", this.SafeString(balance, "balance"))
                AddElementToObject(result, code, account)
            }
        }
    } else {
        var currencyIds interface{} = ObjectKeys(balances)
        for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
            var currencyId interface{} = GetValue(currencyIds, i)
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "total", this.SafeString(balances, currencyId))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinspot#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.coinspot.com.au/api#listmybalance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinspot) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2358 := (<-this.LoadMarkets())
            PanicOnError(retRes2358)
            var method interface{} = this.SafeString(this.Options, "fetchBalance", "private_post_my_balances")
        
            response:= (<-this.callDynamically(method, params))
            PanicOnError(response)
        
                //
            // read-write api keys
            //
            //     ...
            //
            // read-only api keys
            //
            //     {
            //         "status":"ok",
            //         "balances":[
            //             {
            //                 "LTC":{"balance":0.1,"audbalance":16.59,"rate":165.95}
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinspot#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.coinspot.com.au/api#listopenorders
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinspot) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2688 := (<-this.LoadMarkets())
            PanicOnError(retRes2688)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "cointype": GetValue(market, "id"),
            }
        
            orderbook:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(orderbook)
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "buyorders", "sellorders", "rate", "amount")
            return nil
        
            }()
            return ch
        }
func  (this *coinspot) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "btc":{
    //             "bid":"51970",
    //             "ask":"53000",
    //             "last":"52806.47"
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinspot#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.coinspot.com.au/api#latestprices
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinspot) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3238 := (<-this.LoadMarkets())
            PanicOnError(retRes3238)
            var market interface{} = this.Market(symbol)
        
            response:= (<-this.PublicGetLatest(params))
            PanicOnError(response)
            var id interface{} = GetValue(market, "id")
            id = ToLower(id)
            var prices interface{} = this.SafeDict(response, "prices", map[string]interface{} {})
            //
            //     {
            //         "status":"ok",
            //         "prices":{
            //             "btc":{
            //                 "bid":"52732.47000022",
            //                 "ask":"53268.0699976",
            //                 "last":"53284.03"
            //             }
            //         }
            //     }
            //
            var ticker interface{} = this.SafeDict(prices, id)
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinspot#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.coinspot.com.au/api#latestprices
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinspot) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3558 := (<-this.LoadMarkets())
            PanicOnError(retRes3558)
        
            response:= (<-this.PublicGetLatest(params))
            PanicOnError(response)
            //
            //    {
            //        "status": "ok",
            //        "prices":   {
            //            "btc":   {
            //                "bid": "25050",
            //                "ask": "25370",
            //                "last": "25234"
            //            },
            //            "ltc":   {
            //                "bid": "79.39192993",
            //                "ask": "87.98",
            //                "last": "87.95"
            //            }
            //        }
            //    }
            //
            var result interface{} = map[string]interface{} {}
            var prices interface{} = this.SafeDict(response, "prices", map[string]interface{} {})
            var ids interface{} = ObjectKeys(prices)
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                var market interface{} = this.SafeMarket(id)
                if IsTrue(GetValue(market, "spot")) {
                    var symbol interface{} = GetValue(market, "symbol")
                    var ticker interface{} = GetValue(prices, id)
                    AddElementToObject(result, symbol, this.ParseTicker(ticker, market))
                }
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinspot#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.coinspot.com.au/api#orderhistory
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinspot) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4018 := (<-this.LoadMarkets())
            PanicOnError(retRes4018)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "cointype": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostOrdersHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"ok",
            //         "orders":[
            //             {"amount":0.00102091,"rate":21549.09999991,"total":21.99969168,"coin":"BTC","solddate":1604890646143,"market":"BTC/AUD"},
            //         ],
            //     }
            //
            var trades interface{} = this.SafeList(response, "orders", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinspot#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.coinspot.com.au/api#rotransaction
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinspot) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4318 := (<-this.LoadMarkets())
            PanicOnError(retRes4318)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startdate", this.Yyyymmdd(since))
            }
        
            response:= (<-this.PrivatePostRoMyTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //  {
            //      "status": "ok",
            //      "buyorders": [
            //          {
            //              "otc": false,
            //              "market": "ALGO/AUD",
            //              "amount": 386.95197925,
            //              "created": "2022-10-20T09:56:44.502Z",
            //              "audfeeExGst": 1.80018002,
            //              "audGst": 0.180018,
            //              "audtotal": 200
            //          },
            //      ],
            //      "sellorders": [
            //          {
            //              "otc": false,
            //              "market": "SOLO/ALGO",
            //              "amount": 154.52345614,
            //              "total": 115.78858204658796,
            //              "created": "2022-04-16T09:36:43.698Z",
            //              "audfeeExGst": 1.08995731,
            //              "audGst": 0.10899573,
            //              "audtotal": 118.7
            //          },
            //      ]
            // }
            var buyTrades interface{} = this.SafeList(response, "buyorders", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(buyTrades)); i++ {
                AddElementToObject(GetValue(buyTrades, i), "side", "buy")
            }
            var sellTrades interface{} = this.SafeList(response, "sellorders", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(sellTrades)); i++ {
                AddElementToObject(GetValue(sellTrades, i), "side", "sell")
            }
            var trades interface{} = this.ArrayConcat(buyTrades, sellTrades)
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinspot) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "amount":0.00102091,
    //         "rate":21549.09999991,
    //         "total":21.99969168,
    //         "coin":"BTC",
    //         "solddate":1604890646143,
    //         "market":"BTC/AUD"
    //     }
    //
    // private fetchMyTrades
    //     {
    //       "otc": false,
    //       "market": "ALGO/AUD",
    //       "amount": 386.95197925,
    //       "created": "2022-10-20T09:56:44.502Z",
    //       "audfeeExGst": 1.80018002,
    //       "audGst": 0.180018,
    //       "audtotal": 200,
    //       "total": 200,
    //       "side": "buy",
    //       "price": 0.5168600000125209
    //     }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil
    var priceString interface{} = nil
    var fee interface{} = nil
    var audTotal interface{} = this.SafeString(trade, "audtotal")
    var costString interface{} = this.SafeString(trade, "total", audTotal)
    var side interface{} = this.SafeString(trade, "side")
    var amountString interface{} = this.SafeString(trade, "amount")
    var marketId interface{} = this.SafeString(trade, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var solddate interface{} = this.SafeInteger(trade, "solddate")
    if IsTrue(!IsEqual(solddate, nil)) {
        priceString = this.SafeString(trade, "rate")
        timestamp = solddate
    } else {
        priceString = Precise.StringDiv(costString, amountString)
        var createdString interface{} = this.SafeString(trade, "created")
        timestamp = this.Parse8601(createdString)
        var audfeeExGst interface{} = this.SafeString(trade, "audfeeExGst")
        var audGst interface{} = this.SafeString(trade, "audGst")
        // The transaction fee which consumers pay is inclusive of GST by default
        var feeCost interface{} = Precise.StringAdd(audfeeExGst, audGst)
        var feeCurrencyId interface{} = "AUD"
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeCost),
            "currency": this.SafeCurrencyCode(feeCurrencyId),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": nil,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": nil,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": this.ParseNumber(priceString),
        "amount": this.ParseNumber(amountString),
        "cost": this.ParseNumber(costString),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coinspot#createOrder
 * @description create a trade order
 * @see https://www.coinspot.com.au/api#placebuyorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinspot) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5638 := (<-this.LoadMarkets())
            PanicOnError(retRes5638)
            var method interface{} = Add("privatePostMy", this.Capitalize(side))
            if IsTrue(IsEqual(typeVar, "market")) {
                panic(ExchangeError(Add(this.Id, " createOrder() allows limit orders only")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "cointype": GetValue(market, "id"),
                "amount": amount,
                "rate": price,
            }
        
                retRes57415 :=  (<-this.callDynamically(method, this.Extend(request, params)))
                PanicOnError(retRes57415)
                ch <- retRes57415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinspot#cancelOrder
 * @description cancels an open order
 * @see https://www.coinspot.com.au/api#cancelbuyorder
 * @see https://www.coinspot.com.au/api#cancelsellorder
 * @param {string} id order id
 * @param {string} symbol not used by coinspot cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinspot) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var side interface{} = this.SafeString(params, "side")
            if IsTrue(IsTrue(!IsEqual(side, "buy")) && IsTrue(!IsEqual(side, "sell"))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a side parameter, \"buy\" or \"sell\"")))
            }
            params = this.Omit(params, "side")
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var response interface{} = nil
            if IsTrue(IsEqual(side, "buy")) {
                
        response = (<-this.PrivatePostMyBuyCancel(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostMySellCancel(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // status - ok, error
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coinspot) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Nonce()
        body = this.Json(this.Extend(map[string]interface{} {
            "nonce": nonce,
        }, params))
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "key": this.ApiKey,
            "sign": this.Hmac(this.Encode(body), this.Encode(this.Secret), sha512),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *coinspot) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
