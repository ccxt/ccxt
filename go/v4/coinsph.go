package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinsph struct {
	Exchange
}

func NewCoinsphCore() *coinsph {
	p := &coinsph{}
	setDefaults(p)
	return p
}

func (this *coinsph) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "coinsph",
		"name":      "Coins.ph",
		"countries": []interface{}{"PH"},
		"version":   "v1",
		"rateLimit": 50,
		"certified": false,
		"pro":       false,
		"has": map[string]interface{}{
			"CORS":                                   nil,
			"spot":                                   true,
			"margin":                                 false,
			"swap":                                   false,
			"future":                                 false,
			"option":                                 false,
			"addMargin":                              false,
			"borrowCrossMargin":                      false,
			"borrowIsolatedMargin":                   false,
			"borrowMargin":                           false,
			"cancelAllOrders":                        true,
			"cancelOrder":                            true,
			"cancelOrders":                           false,
			"closeAllPositions":                      false,
			"closePosition":                          false,
			"createDepositAddress":                   false,
			"createMarketBuyOrderWithCost":           true,
			"createMarketOrderWithCost":              false,
			"createMarketSellOrderWithCost":          false,
			"createOrder":                            true,
			"createOrderWithTakeProfitAndStopLoss":   false,
			"createOrderWithTakeProfitAndStopLossWs": false,
			"createPostOnlyOrder":                    false,
			"createReduceOnlyOrder":                  false,
			"createStopLimitOrder":                   true,
			"createStopMarketOrder":                  true,
			"createStopOrder":                        true,
			"deposit":                                true,
			"editOrder":                              false,
			"fetchAccounts":                          false,
			"fetchBalance":                           true,
			"fetchBidsAsks":                          false,
			"fetchBorrowInterest":                    false,
			"fetchBorrowRate":                        false,
			"fetchBorrowRateHistories":               false,
			"fetchBorrowRateHistory":                 false,
			"fetchBorrowRates":                       false,
			"fetchBorrowRatesPerSymbol":              false,
			"fetchCanceledOrders":                    false,
			"fetchClosedOrder":                       false,
			"fetchClosedOrders":                      true,
			"fetchCrossBorrowRate":                   false,
			"fetchCrossBorrowRates":                  false,
			"fetchCurrencies":                        true,
			"fetchDeposit":                           nil,
			"fetchDepositAddress":                    true,
			"fetchDepositAddresses":                  false,
			"fetchDepositAddressesByNetwork":         false,
			"fetchDeposits":                          true,
			"fetchDepositWithdrawFee":                false,
			"fetchDepositWithdrawFees":               false,
			"fetchFundingHistory":                    false,
			"fetchFundingInterval":                   false,
			"fetchFundingIntervals":                  false,
			"fetchFundingRate":                       false,
			"fetchFundingRateHistory":                false,
			"fetchFundingRates":                      false,
			"fetchGreeks":                            false,
			"fetchIndexOHLCV":                        false,
			"fetchIsolatedBorrowRate":                false,
			"fetchIsolatedBorrowRates":               false,
			"fetchIsolatedPositions":                 false,
			"fetchL3OrderBook":                       false,
			"fetchLedger":                            false,
			"fetchLeverage":                          false,
			"fetchLeverages":                         false,
			"fetchLeverageTiers":                     false,
			"fetchLiquidations":                      false,
			"fetchLongShortRatio":                    false,
			"fetchLongShortRatioHistory":             false,
			"fetchMarginAdjustmentHistory":           false,
			"fetchMarginMode":                        false,
			"fetchMarginModes":                       false,
			"fetchMarketLeverageTiers":               false,
			"fetchMarkets":                           true,
			"fetchMarkOHLCV":                         false,
			"fetchMarkPrices":                        false,
			"fetchMyLiquidations":                    false,
			"fetchMySettlementHistory":               false,
			"fetchMyTrades":                          true,
			"fetchOHLCV":                             true,
			"fetchOpenInterest":                      false,
			"fetchOpenInterestHistory":               false,
			"fetchOpenInterests":                     false,
			"fetchOpenOrder":                         nil,
			"fetchOpenOrders":                        true,
			"fetchOption":                            false,
			"fetchOptionChain":                       false,
			"fetchOrder":                             true,
			"fetchOrderBook":                         true,
			"fetchOrderBooks":                        false,
			"fetchOrders":                            false,
			"fetchOrderTrades":                       true,
			"fetchPosition":                          false,
			"fetchPositionHistory":                   false,
			"fetchPositionMode":                      false,
			"fetchPositions":                         false,
			"fetchPositionsForSymbol":                false,
			"fetchPositionsHistory":                  false,
			"fetchPositionsRisk":                     false,
			"fetchPremiumIndexOHLCV":                 false,
			"fetchSettlementHistory":                 false,
			"fetchStatus":                            true,
			"fetchTicker":                            true,
			"fetchTickers":                           true,
			"fetchTime":                              true,
			"fetchTrades":                            true,
			"fetchTradingFee":                        true,
			"fetchTradingFees":                       true,
			"fetchTradingLimits":                     false,
			"fetchTransactionFee":                    false,
			"fetchTransactionFees":                   false,
			"fetchTransactions":                      false,
			"fetchTransfers":                         false,
			"fetchVolatilityHistory":                 false,
			"fetchWithdrawal":                        nil,
			"fetchWithdrawals":                       true,
			"fetchWithdrawalWhitelist":               false,
			"reduceMargin":                           false,
			"repayCrossMargin":                       false,
			"repayIsolatedMargin":                    false,
			"repayMargin":                            false,
			"setLeverage":                            false,
			"setMargin":                              false,
			"setMarginMode":                          false,
			"setPositionMode":                        false,
			"signIn":                                 false,
			"transfer":                               false,
			"withdraw":                               true,
			"ws":                                     false,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"8h":  "8h",
			"12h": "12h",
			"1d":  "1d",
			"3d":  "3d",
			"1w":  "1w",
			"1M":  "1M",
		},
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/225719995-48ab2026-4ddb-496c-9da7-0d7566617c9b.jpg",
			"api": map[string]interface{}{
				"public":  "https://api.pro.coins.ph",
				"private": "https://api.pro.coins.ph",
			},
			"www":  "https://coins.ph/",
			"doc":  []interface{}{"https://coins-docs.github.io/rest-api"},
			"fees": "https://support.coins.ph/hc/en-us/sections/4407198694681-Limits-Fees",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"openapi/v1/ping": 1,
					"openapi/v1/time": 1,
					"openapi/quote/v1/ticker/24hr": map[string]interface{}{
						"cost":                 1,
						"noSymbolAndNoSymbols": 40,
						"byNumberOfSymbols":    []interface{}{[]interface{}{101, 40}, []interface{}{21, 20}, []interface{}{0, 1}},
					},
					"openapi/quote/v1/ticker/price": map[string]interface{}{
						"cost":     1,
						"noSymbol": 2,
					},
					"openapi/quote/v1/ticker/bookTicker": map[string]interface{}{
						"cost":     1,
						"noSymbol": 2,
					},
					"openapi/v1/exchangeInfo": 10,
					"openapi/quote/v1/depth": map[string]interface{}{
						"cost":    1,
						"byLimit": []interface{}{[]interface{}{101, 5}, []interface{}{0, 1}},
					},
					"openapi/quote/v1/klines":   1,
					"openapi/quote/v1/trades":   1,
					"openapi/v1/pairs":          1,
					"openapi/quote/v1/avgPrice": 1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"openapi/wallet/v1/config/getall":    10,
					"openapi/wallet/v1/deposit/address":  10,
					"openapi/wallet/v1/deposit/history":  1,
					"openapi/wallet/v1/withdraw/history": 1,
					"openapi/v1/account":                 10,
					"openapi/v1/openOrders": map[string]interface{}{
						"cost":     3,
						"noSymbol": 40,
					},
					"openapi/v1/asset/tradeFee": 1,
					"openapi/v1/order":          2,
					"openapi/v1/historyOrders": map[string]interface{}{
						"cost":     10,
						"noSymbol": 40,
					},
					"openapi/v1/myTrades":                            10,
					"openapi/v1/capital/deposit/history":             1,
					"openapi/v1/capital/withdraw/history":            1,
					"openapi/v3/payment-request/get-payment-request": 1,
					"merchant-api/v1/get-invoices":                   1,
					"openapi/account/v3/crypto-accounts":             1,
					"openapi/transfer/v3/transfers/{id}":             1,
				},
				"post": map[string]interface{}{
					"openapi/wallet/v1/withdraw/apply":                    600,
					"openapi/v1/order/test":                               1,
					"openapi/v1/order":                                    1,
					"openapi/v1/capital/withdraw/apply":                   1,
					"openapi/v1/capital/deposit/apply":                    1,
					"openapi/v3/payment-request/payment-requests":         1,
					"openapi/v3/payment-request/delete-payment-request":   1,
					"openapi/v3/payment-request/payment-request-reminder": 1,
					"openapi/v1/userDataStream":                           1,
					"merchant-api/v1/invoices":                            1,
					"merchant-api/v1/invoices-cancel":                     1,
					"openapi/convert/v1/get-supported-trading-pairs":      1,
					"openapi/convert/v1/get-quote":                        1,
					"openapi/convert/v1/accpet-quote":                     1,
					"openapi/fiat/v1/support-channel":                     1,
					"openapi/fiat/v1/cash-out":                            1,
					"openapi/fiat/v1/history":                             1,
					"openapi/migration/v4/sellorder":                      1,
					"openapi/migration/v4/validate-field":                 1,
					"openapi/transfer/v3/transfers":                       1,
				},
				"delete": map[string]interface{}{
					"openapi/v1/order":          1,
					"openapi/v1/openOrders":     1,
					"openapi/v1/userDataStream": 1,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"feeSide":    "get",
				"tierBased":  true,
				"percentage": true,
				"maker":      this.ParseNumber("0.0025"),
				"taker":      this.ParseNumber("0.003"),
				"tiers": map[string]interface{}{
					"taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0027")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0024")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("1000000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("2500000000"), this.ParseNumber("0.0005")}},
					"maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0022")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1000000000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("2500000000"), this.ParseNumber("0.0005")}},
				},
			},
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": true,
			"withdraw": map[string]interface{}{
				"warning": false,
			},
			"deposit": map[string]interface{}{
				"warning": false,
			},
			"createOrder": map[string]interface{}{
				"timeInForce": "GTC",
				"newOrderRespType": map[string]interface{}{
					"market": "FULL",
					"limit":  "FULL",
				},
			},
			"fetchTicker": map[string]interface{}{
				"method": "publicGetOpenapiQuoteV1Ticker24hr",
			},
			"fetchTickers": map[string]interface{}{
				"method": "publicGetOpenapiQuoteV1Ticker24hr",
			},
			"networks": map[string]interface{}{
				"TRC20": "TRX",
				"ERC20": "ETH",
				"BEP20": "BSC",
				"ARB":   "ARBITRUM",
			},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           false,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  false,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    true,
					"iceberg":                false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       100000,
					"untilDays":      100000,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            1000,
					"daysBack":         100000,
					"daysBackCanceled": 1,
					"untilDays":        100000,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1000,
				},
			},
			"swap": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"-1000":   BadRequest,
				"-1001":   BadRequest,
				"-1002":   AuthenticationError,
				"-1003":   RateLimitExceeded,
				"-1004":   InvalidOrder,
				"-1006":   BadResponse,
				"-1007":   BadResponse,
				"-1014":   InvalidOrder,
				"-1015":   RateLimitExceeded,
				"-1016":   NotSupported,
				"-1020":   NotSupported,
				"-1021":   BadRequest,
				"-1022":   BadRequest,
				"-1023":   AuthenticationError,
				"-1024":   BadRequest,
				"-1025":   BadRequest,
				"-1030":   ExchangeError,
				"-1100":   BadRequest,
				"-1101":   BadRequest,
				"-1102":   BadRequest,
				"-1103":   BadRequest,
				"-1104":   BadRequest,
				"-1105":   BadRequest,
				"-1106":   BadRequest,
				"-1111":   BadRequest,
				"-1112":   BadResponse,
				"-1114":   BadRequest,
				"-1115":   InvalidOrder,
				"-1116":   InvalidOrder,
				"-1117":   InvalidOrder,
				"-1118":   InvalidOrder,
				"-1119":   InvalidOrder,
				"-1120":   BadRequest,
				"-1121":   BadSymbol,
				"-1122":   InvalidOrder,
				"-1125":   BadRequest,
				"-1127":   BadRequest,
				"-1128":   BadRequest,
				"-1130":   BadRequest,
				"-1131":   InsufficientFunds,
				"-1132":   InvalidOrder,
				"-1133":   InvalidOrder,
				"-1134":   InvalidOrder,
				"-1135":   InvalidOrder,
				"-1136":   InvalidOrder,
				"-1137":   InvalidOrder,
				"-1138":   InvalidOrder,
				"-1139":   InvalidOrder,
				"-1140":   InvalidOrder,
				"-1141":   DuplicateOrderId,
				"-1142":   InvalidOrder,
				"-1143":   OrderNotFound,
				"-1144":   InvalidOrder,
				"-1145":   InvalidOrder,
				"-1146":   InvalidOrder,
				"-1147":   InvalidOrder,
				"-1148":   InvalidOrder,
				"-1149":   InvalidOrder,
				"-1150":   InvalidOrder,
				"-1151":   BadSymbol,
				"-1152":   NotSupported,
				"-1153":   AuthenticationError,
				"-1154":   BadRequest,
				"-1155":   BadRequest,
				"-1156":   InvalidOrder,
				"-1157":   BadSymbol,
				"-1158":   InvalidOrder,
				"-1159":   InvalidOrder,
				"-1160":   BadRequest,
				"-1161":   BadRequest,
				"-2010":   InvalidOrder,
				"-2013":   OrderNotFound,
				"-2011":   BadRequest,
				"-2014":   BadRequest,
				"-2015":   AuthenticationError,
				"-2016":   BadResponse,
				"-3126":   InvalidOrder,
				"-3127":   InvalidOrder,
				"-4001":   BadRequest,
				"-100011": BadSymbol,
				"-100012": BadSymbol,
				"-30008":  InsufficientFunds,
				"-30036":  InsufficientFunds,
				"403":     ExchangeNotAvailable,
			},
			"broad": map[string]interface{}{
				"Unknown order sent":   OrderNotFound,
				"Duplicate order sent": DuplicateOrderId,
				"Market is closed":     BadSymbol,
				"Account has insufficient balance for requested action":      InsufficientFunds,
				"Market orders are not supported for this symbol":            BadSymbol,
				"Iceberg orders are not supported for this symbol":           BadSymbol,
				"Stop loss orders are not supported for this symbol":         BadSymbol,
				"Stop loss limit orders are not supported for this symbol":   BadSymbol,
				"Take profit orders are not supported for this symbol":       BadSymbol,
				"Take profit limit orders are not supported for this symbol": BadSymbol,
				"Price* QTY is zero or less":                                 BadRequest,
				"IcebergQty exceeds QTY":                                     BadRequest,
				"This action disabled is on this account":                    PermissionDenied,
				"Unsupported order combination":                              InvalidOrder,
				"Order would trigger immediately":                            InvalidOrder,
				"Cancel order is invalid. Check origClOrdId and orderId":     InvalidOrder,
				"Order would immediately match and take":                     OrderImmediatelyFillable,
				"PRICE_FILTER":                                               InvalidOrder,
				"LOT_SIZE":                                                   InvalidOrder,
				"MIN_NOTIONAL":                                               InvalidOrder,
				"MAX_NUM_ORDERS":                                             InvalidOrder,
				"MAX_ALGO_ORDERS":                                            InvalidOrder,
				"BROKER_MAX_NUM_ORDERS":                                      InvalidOrder,
				"BROKER_MAX_ALGO_ORDERS":                                     InvalidOrder,
				"ICEBERG_PARTS":                                              BadRequest,
			},
		},
	})
}

/**
 * @method
 * @name coinsph#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.coins.ph/rest-api/#all-coins-information-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *coinsph) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if !IsTrue(this.CheckRequiredCredentials(false)) {

			ch <- map[string]interface{}{}
			return nil
		}

		response := (<-this.PrivateGetOpenapiWalletV1ConfigGetall(params))
		PanicOnError(response)
		//
		//    [
		//        {
		//            "coin": "PHP",
		//            "name": "PHP",
		//            "depositAllEnable": false,
		//            "withdrawAllEnable": false,
		//            "free": "0",
		//            "locked": "0",
		//            "transferPrecision": "2",
		//            "transferMinQuantity": "0",
		//            "networkList": [],
		//            "legalMoney": true
		//        },
		//        {
		//            "coin": "USDT",
		//            "name": "USDT",
		//            "depositAllEnable": true,
		//            "withdrawAllEnable": true,
		//            "free": "0",
		//            "locked": "0",
		//            "transferPrecision": "8",
		//            "transferMinQuantity": "0",
		//            "networkList": [
		//                {
		//                    "addressRegex": "^0x[0-9a-fA-F]{40}$",
		//                    "memoRegex": " ",
		//                    "network": "ETH",
		//                    "name": "Ethereum (ERC20)",
		//                    "depositEnable": true,
		//                    "minConfirm": "12",
		//                    "unLockConfirm": "-1",
		//                    "withdrawDesc": "",
		//                    "withdrawEnable": true,
		//                    "withdrawFee": "6",
		//                    "withdrawIntegerMultiple": "0.000001",
		//                    "withdrawMax": "500000",
		//                    "withdrawMin": "10",
		//                    "sameAddress": false
		//                },
		//                {
		//                    "addressRegex": "^T[0-9a-zA-Z]{33}$",
		//                    "memoRegex": "",
		//                    "network": "TRX",
		//                    "name": "TRON",
		//                    "depositEnable": true,
		//                    "minConfirm": "19",
		//                    "unLockConfirm": "-1",
		//                    "withdrawDesc": "",
		//                    "withdrawEnable": true,
		//                    "withdrawFee": "3",
		//                    "withdrawIntegerMultiple": "0.000001",
		//                    "withdrawMax": "1000000",
		//                    "withdrawMin": "20",
		//                    "sameAddress": false
		//                }
		//            ],
		//            "legalMoney": false
		//        }
		//    ]
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var entry interface{} = GetValue(response, i)
			var id interface{} = this.SafeString(entry, "coin")
			var code interface{} = this.SafeCurrencyCode(id)
			var isFiat interface{} = this.SafeBool(entry, "isLegalMoney")
			var networkList interface{} = this.SafeList(entry, "networkList", []interface{}{})
			var networks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
				var networkItem interface{} = GetValue(networkList, j)
				var network interface{} = this.SafeString(networkItem, "network")
				var networkCode interface{} = this.NetworkIdToCode(network)
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"info":      networkItem,
					"id":        network,
					"network":   networkCode,
					"active":    nil,
					"deposit":   this.SafeBool(networkItem, "depositEnable"),
					"withdraw":  this.SafeBool(networkItem, "withdrawEnable"),
					"fee":       this.SafeNumber(networkItem, "withdrawFee"),
					"precision": this.SafeNumber(networkItem, "withdrawIntegerMultiple"),
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(networkItem, "withdrawMin"),
							"max": this.SafeNumber(networkItem, "withdrawMax"),
						},
						"deposit": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
					},
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        id,
				"name":      this.SafeString(entry, "name"),
				"code":      code,
				"type":      Ternary(IsTrue(isFiat), "fiat", "crypto"),
				"precision": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "transferPrecision"))),
				"info":      entry,
				"active":    nil,
				"deposit":   this.SafeBool(entry, "depositAllEnable"),
				"withdraw":  this.SafeBool(entry, "withdrawAllEnable"),
				"networks":  networks,
				"fee":       nil,
				"fees":      nil,
				"limits":    map[string]interface{}{},
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *coinsph) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{} {
	config := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = config
	if IsTrue(IsTrue((InOp(config, "noSymbol"))) && !IsTrue((InOp(params, "symbol")))) {
		return GetValue(config, "noSymbol")
	} else if IsTrue(IsTrue(IsTrue((InOp(config, "noSymbolAndNoSymbols"))) && !IsTrue((InOp(params, "symbol")))) && !IsTrue((InOp(params, "symbols")))) {
		return GetValue(config, "noSymbolAndNoSymbols")
	} else if IsTrue(IsTrue((InOp(config, "byNumberOfSymbols"))) && IsTrue((InOp(params, "symbols")))) {
		var symbols interface{} = GetValue(params, "symbols")
		var symbolsAmount interface{} = GetArrayLength(symbols)
		var byNumberOfSymbols interface{} = GetValue(config, "byNumberOfSymbols")
		for i := 0; IsLessThan(i, GetArrayLength(byNumberOfSymbols)); i++ {
			var entry interface{} = GetValue(byNumberOfSymbols, i)
			if IsTrue(IsGreaterThanOrEqual(symbolsAmount, GetValue(entry, 0))) {
				return GetValue(entry, 1)
			}
		}
	} else if IsTrue(IsTrue((InOp(config, "byLimit"))) && IsTrue((InOp(params, "limit")))) {
		var limit interface{} = GetValue(params, "limit")
		var byLimit interface{} = GetValue(config, "byLimit")
		for i := 0; IsLessThan(i, GetArrayLength(byLimit)); i++ {
			var entry interface{} = GetValue(byLimit, i)
			if IsTrue(IsGreaterThanOrEqual(limit, GetValue(entry, 0))) {
				return GetValue(entry, 1)
			}
		}
	}
	return this.SafeValue(config, "cost", 1)
}

/**
 * @method
 * @name coinsph#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://coins-docs.github.io/rest-api/#test-connectivity
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func (this *coinsph) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetOpenapiV1Ping(params))
		PanicOnError(response)

		ch <- map[string]interface{}{
			"status":  "ok",
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://coins-docs.github.io/rest-api/#check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *coinsph) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetOpenapiV1Time(params))
		PanicOnError(response)

		//
		//     {"serverTime":1677705408268}
		//
		ch <- this.SafeInteger(response, "serverTime")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchMarkets
 * @description retrieves data on all markets for coinsph
 * @see https://coins-docs.github.io/rest-api/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *coinsph) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetOpenapiV1ExchangeInfo(params))
		PanicOnError(response)
		//
		//     {
		//         "timezone": "UTC",
		//         "serverTime": "1677449496897",
		//         "exchangeFilters": [],
		//         "symbols": [
		//             {
		//                 "symbol": "XRPPHP",
		//                 "status": "TRADING",
		//                 "baseAsset": "XRP",
		//                 "baseAssetPrecision": "2",
		//                 "quoteAsset": "PHP",
		//                 "quoteAssetPrecision": "4",
		//                 "orderTypes": [
		//                     "LIMIT",
		//                     "MARKET",
		//                     "LIMIT_MAKER",
		//                     "STOP_LOSS_LIMIT",
		//                     "STOP_LOSS",
		//                     "TAKE_PROFIT_LIMIT",
		//                     "TAKE_PROFIT"
		//                 ],
		//                 "filters": [
		//                     {
		//                         "minPrice": "0.01",
		//                         "maxPrice": "99999999.00000000",
		//                         "tickSize": "0.01",
		//                         "filterType": "PRICE_FILTER"
		//                     },
		//                     {
		//                         "minQty": "0.01",
		//                         "maxQty": "99999999999.00000000",
		//                         "stepSize": "0.01",
		//                         "filterType": "LOT_SIZE"
		//                     },
		//                     { minNotional: "50", filterType: "NOTIONAL" },
		//                     { minNotional: "50", filterType: "MIN_NOTIONAL" },
		//                     {
		//                         "priceUp": "99999999",
		//                         "priceDown": "0.01",
		//                         "filterType": "STATIC_PRICE_RANGE"
		//                     },
		//                     {
		//                         "multiplierUp": "1.1",
		//                         "multiplierDown": "0.9",
		//                         "filterType": "PERCENT_PRICE_INDEX"
		//                     },
		//                     {
		//                         "multiplierUp": "1.1",
		//                         "multiplierDown": "0.9",
		//                         "filterType": "PERCENT_PRICE_ORDER_SIZE"
		//                     },
		//                     { maxNumOrders: "200", filterType: "MAX_NUM_ORDERS" },
		//                     { maxNumAlgoOrders: "5", filterType: "MAX_NUM_ALGO_ORDERS" }
		//                 ]
		//             },
		//         ]
		//     }
		//
		var markets interface{} = this.SafeList(response, "symbols", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseAsset")
			var quoteId interface{} = this.SafeString(market, "quoteAsset")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var limits interface{} = this.IndexBy(this.SafeList(market, "filters", []interface{}{}), "filterType")
			var amountLimits interface{} = this.SafeValue(limits, "LOT_SIZE", map[string]interface{}{})
			var priceLimits interface{} = this.SafeValue(limits, "PRICE_FILTER", map[string]interface{}{})
			var costLimits interface{} = this.SafeValue(limits, "NOTIONAL", map[string]interface{}{})
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         Add(Add(base, "/"), quote),
				"base":           base,
				"quote":          quote,
				"settle":         nil,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"margin":         false,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         IsEqual(this.SafeStringLower(market, "status"), "trading"),
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"taker":          nil,
				"maker":          nil,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.SafeString(amountLimits, "stepSize")),
					"price":  this.ParseNumber(this.SafeString(priceLimits, "tickSize")),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.ParseNumber(this.SafeString(amountLimits, "minQty")),
						"max": this.ParseNumber(this.SafeString(amountLimits, "maxQty")),
					},
					"price": map[string]interface{}{
						"min": this.ParseNumber(this.SafeString(priceLimits, "minPrice")),
						"max": this.ParseNumber(this.SafeString(priceLimits, "maxPrice")),
					},
					"cost": map[string]interface{}{
						"min": this.ParseNumber(this.SafeString(costLimits, "minNotional")),
						"max": nil,
					},
				},
				"created": nil,
				"info":    market,
			})
		}
		this.SetMarkets(result)

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://coins-docs.github.io/rest-api/#24hr-ticker-price-change-statistics
 * @see https://coins-docs.github.io/rest-api/#symbol-price-ticker
 * @see https://coins-docs.github.io/rest-api/#symbol-order-book-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *coinsph) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8558 := (<-this.LoadMarkets())
		PanicOnError(retRes8558)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var ids interface{} = []interface{}{}
			for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
				var market interface{} = this.Market(GetValue(symbols, i))
				var id interface{} = GetValue(market, "id")
				AppendToArray(&ids, id)
			}
			AddElementToObject(request, "symbols", ids)
		}
		var defaultMethod interface{} = "publicGetOpenapiQuoteV1Ticker24hr"
		var options interface{} = this.SafeDict(this.Options, "fetchTickers", map[string]interface{}{})
		var method interface{} = this.SafeString(options, "method", defaultMethod)
		var tickers interface{} = nil
		if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerPrice")) {

			tickers = (<-this.PublicGetOpenapiQuoteV1TickerPrice(this.Extend(request, params)))
			PanicOnError(tickers)
		} else if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerBookTicker")) {

			tickers = (<-this.PublicGetOpenapiQuoteV1TickerBookTicker(this.Extend(request, params)))
			PanicOnError(tickers)
		} else {

			tickers = (<-this.PublicGetOpenapiQuoteV1Ticker24hr(this.Extend(request, params)))
			PanicOnError(tickers)
		}

		ch <- this.ParseTickers(tickers, symbols, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coins-docs.github.io/rest-api/#24hr-ticker-price-change-statistics
 * @see https://coins-docs.github.io/rest-api/#symbol-price-ticker
 * @see https://coins-docs.github.io/rest-api/#symbol-order-book-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *coinsph) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8928 := (<-this.LoadMarkets())
		PanicOnError(retRes8928)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var defaultMethod interface{} = "publicGetOpenapiQuoteV1Ticker24hr"
		var options interface{} = this.SafeDict(this.Options, "fetchTicker", map[string]interface{}{})
		var method interface{} = this.SafeString(options, "method", defaultMethod)
		var ticker interface{} = nil
		if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerPrice")) {

			ticker = (<-this.PublicGetOpenapiQuoteV1TickerPrice(this.Extend(request, params)))
			PanicOnError(ticker)
		} else if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerBookTicker")) {

			ticker = (<-this.PublicGetOpenapiQuoteV1TickerBookTicker(this.Extend(request, params)))
			PanicOnError(ticker)
		} else {

			ticker = (<-this.PublicGetOpenapiQuoteV1Ticker24hr(this.Extend(request, params)))
			PanicOnError(ticker)
		}

		ch <- this.ParseTicker(ticker, market)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// publicGetOpenapiQuoteV1Ticker24hr
	//     {
	//         "symbol": "ETHUSDT",
	//         "priceChange": "41.440000000000000000",
	//         "priceChangePercent": "0.0259",
	//         "weightedAvgPrice": "1631.169825783972125436",
	//         "prevClosePrice": "1601.520000000000000000",
	//         "lastPrice": "1642.96",
	//         "lastQty": "0.000001000000000000",
	//         "bidPrice": "1638.790000000000000000",
	//         "bidQty": "0.280075000000000000",
	//         "askPrice": "1647.340000000000000000",
	//         "askQty": "0.165183000000000000",
	//         "openPrice": "1601.52",
	//         "highPrice": "1648.28",
	//         "lowPrice": "1601.52",
	//         "volume": "0.000287",
	//         "quoteVolume": "0.46814574",
	//         "openTime": "1677417000000",
	//         "closeTime": "1677503415200",
	//         "firstId": "1364680572697591809",
	//         "lastId": "1365389809203560449",
	//         "count": "100"
	//     }
	//
	// publicGetOpenapiQuoteV1TickerPrice
	//     { "symbol": "ETHUSDT", "price": "1599.68" }
	//
	// publicGetOpenapiQuoteV1TickerBookTicker
	//     {
	//         "symbol": "ETHUSDT",
	//         "bidPrice": "1596.57",
	//         "bidQty": "0.246405",
	//         "askPrice": "1605.12",
	//         "askQty": "0.242681"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(ticker, "closeTime")
	var bid interface{} = this.SafeString(ticker, "bidPrice")
	var ask interface{} = this.SafeString(ticker, "askPrice")
	var bidVolume interface{} = this.SafeString(ticker, "bidQty")
	var askVolume interface{} = this.SafeString(ticker, "askQty")
	var baseVolume interface{} = this.SafeString(ticker, "volume")
	var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume")
	var open interface{} = this.SafeString(ticker, "openPrice")
	var high interface{} = this.SafeString(ticker, "highPrice")
	var low interface{} = this.SafeString(ticker, "lowPrice")
	var prevClose interface{} = this.SafeString(ticker, "prevClosePrice")
	var vwap interface{} = this.SafeString(ticker, "weightedAvgPrice")
	var changeValue interface{} = this.SafeString(ticker, "priceChange")
	var changePcnt interface{} = this.SafeString(ticker, "priceChangePercent")
	changePcnt = Precise.StringMul(changePcnt, "100")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"open":          open,
		"high":          high,
		"low":           low,
		"close":         this.SafeString2(ticker, "lastPrice", "price"),
		"bid":           bid,
		"bidVolume":     bidVolume,
		"ask":           ask,
		"askVolume":     askVolume,
		"vwap":          vwap,
		"previousClose": prevClose,
		"change":        changeValue,
		"percentage":    changePcnt,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name coinsph#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coins-docs.github.io/rest-api/#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *coinsph) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes10018 := (<-this.LoadMarkets())
		PanicOnError(retRes10018)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetOpenapiQuoteV1Depth(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "lastUpdateId": "1667022157000699400",
		//         "bids": [
		//             [ '1651.810000000000000000', '0.214556000000000000' ],
		//             [ '1651.730000000000000000', '0.257343000000000000' ],
		//         ],
		//         "asks": [
		//             [ '1660.510000000000000000', '0.299092000000000000' ],
		//             [ '1660.600000000000000000', '0.253667000000000000' ],
		//         ]
		//     }
		//
		var orderbook interface{} = this.ParseOrderBook(response, symbol)
		AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))

		ch <- orderbook
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://coins-docs.github.io/rest-api/#klinecandlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *coinsph) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10428 := (<-this.LoadMarkets())
		PanicOnError(retRes10428)
		var market interface{} = this.Market(symbol)
		var interval interface{} = this.SafeString(this.Timeframes, timeframe)
		var until interface{} = this.SafeInteger(params, "until")
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": interval,
		}
		if IsTrue(IsEqual(limit, nil)) {
			limit = 1000
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
			// since work properly only when it is "younger" than last "limit" candle
			if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "endTime", until)
			} else {
				var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
				var endTimeByLimit interface{} = this.Sum(since, Multiply(duration, (Subtract(limit, 1))))
				var now interface{} = this.Milliseconds()
				AddElementToObject(request, "endTime", mathMin(endTimeByLimit, now))
			}
		} else if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			// since work properly only when it is "younger" than last "limit" candle
			var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
			AddElementToObject(request, "startTime", Subtract(until, (Multiply(duration, (Subtract(limit, 1))))))
		}
		AddElementToObject(request, "limit", limit)
		params = this.Omit(params, "until")

		response := (<-this.PublicGetOpenapiQuoteV1Klines(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         [
		//             1499040000000,      // Open time
		//             "0.01634790",       // Open
		//             "0.80000000",       // High
		//             "0.01575800",       // Low
		//             "0.01577100",       // Close
		//             "148976.11427815",  // Volume
		//             1499644799999,      // Close time
		//             "2434.19055334",    // Quote asset volume
		//             308,                // Number of trades
		//             "1756.87402397",    // Taker buy base asset volume
		//             "28.46694368"       // Taker buy quote asset volume
		//         ]
		//     ]
		//
		ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}

/**
 * @method
 * @name coinsph#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coins-docs.github.io/rest-api/#recent-trades-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *coinsph) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes11168 := (<-this.LoadMarkets())
		PanicOnError(retRes11168)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			// since work properly only when it is "younger" than last 'limit' trade
			AddElementToObject(request, "limit", 1000)
		} else {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
		}

		response := (<-this.PublicGetOpenapiQuoteV1Trades(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "price": "89685.8",
		//             "id": "1365561108437680129",
		//             "qty": "0.000004",
		//             "quoteQty": "0.000004000000000000",
		//             "time": "1677523569575",
		//             "isBuyerMaker": false,
		//             "isBestMatch": true
		//         },
		//     ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://coins-docs.github.io/rest-api/#account-trade-list-user_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *coinsph) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes11618 := (<-this.LoadMarkets())
		PanicOnError(retRes11618)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
			// since work properly only when it is "younger" than last 'limit' trade
			AddElementToObject(request, "limit", 1000)
		} else if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetOpenapiV1MyTrades(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://coins-docs.github.io/rest-api/#account-trade-list-user_data
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *coinsph) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrderTrades() requires a symbol argument")))
		}
		var request interface{} = map[string]interface{}{
			"orderId": id,
		}

		retRes119615 := (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes119615)
		ch <- retRes119615
		return nil

	}()
	return ch
}
func (this *coinsph) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//     {
	//         "price": "89685.8",
	//         "id": "1365561108437680129",
	//         "qty": "0.000004",
	//         "quoteQty": "0.000004000000000000", // warning: report to exchange - this is not quote quantity, this is base quantity
	//         "time": "1677523569575",
	//         "isBuyerMaker": false,
	//         "isBestMatch": true
	//     },
	//
	// fetchMyTrades
	//     {
	//         "symbol": "ETHUSDT",
	//         "id": 1375426310524125185,
	//         "orderId": 1375426310415879614,
	//         "price": "1580.91",
	//         "qty": "0.01",
	//         "quoteQty": "15.8091",
	//         "commission": "0",
	//         "commissionAsset": "USDT",
	//         "time": 1678699593307,
	//         "isBuyer": false,
	//         "isMaker":false,
	//         "isBestMatch":false
	//     }
	//
	// createOrder
	//     {
	//         "price": "1579.51",
	//         "qty": "0.001899",
	//         "commission": "0",
	//         "commissionAsset": "ETH",
	//         "tradeId":1375445992035598337
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var id interface{} = this.SafeString2(trade, "id", "tradeId")
	var orderId interface{} = this.SafeString(trade, "orderId")
	var timestamp interface{} = this.SafeInteger(trade, "time")
	var priceString interface{} = this.SafeString(trade, "price")
	var amountString interface{} = this.SafeString(trade, "qty")
	var typeVar interface{} = nil
	var fee interface{} = nil
	var feeCost interface{} = this.SafeString(trade, "commission")
	if IsTrue(!IsEqual(feeCost, nil)) {
		var feeCurrencyId interface{} = this.SafeString(trade, "commissionAsset")
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": this.SafeCurrencyCode(feeCurrencyId),
		}
	}
	var isBuyer interface{} = this.SafeBool2(trade, "isBuyer", "isBuyerMaker", nil)
	var side interface{} = nil
	if IsTrue(!IsEqual(isBuyer, nil)) {
		side = Ternary(IsTrue((IsEqual(isBuyer, true))), "buy", "sell")
	}
	var isMaker interface{} = this.SafeString2(trade, "isMaker", nil)
	var takerOrMaker interface{} = nil
	if IsTrue(!IsEqual(isMaker, nil)) {
		takerOrMaker = Ternary(IsTrue((IsEqual(isMaker, "true"))), "maker", "taker")
	}
	var costString interface{} = nil
	if IsTrue(!IsEqual(orderId, nil)) {
		costString = this.SafeString(trade, "quoteQty")
	}
	return this.SafeTrade(map[string]interface{}{
		"id":           id,
		"order":        orderId,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"type":         typeVar,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        priceString,
		"amount":       amountString,
		"cost":         costString,
		"fee":          fee,
		"info":         trade,
	}, market)
}

/**
 * @method
 * @name coinsph#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coins-docs.github.io/rest-api/#accept-the-quote
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *coinsph) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes12958 := (<-this.LoadMarkets())
		PanicOnError(retRes12958)

		response := (<-this.PrivateGetOpenapiV1Account(params))
		PanicOnError(response)

		//
		//     {
		//         "accountType": "SPOT",
		//         "balances": [
		//             {
		//                 "asset": "BTC",
		//                 "free": "4723846.89208129",
		//                 "locked": "0.00000000"
		//             },
		//             {
		//                 "asset": "LTC",
		//                 "free": "4763368.68006011",
		//                 "locked": "0.00000000"
		//             }
		//         ],
		//         "canDeposit": true,
		//         "canTrade": true,
		//         "canWithdraw": true,
		//         "updateTime": "1677430932528"
		//     }
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseBalance(response interface{}) interface{} {
	var balances interface{} = this.SafeList(response, "balances", []interface{}{})
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var currencyId interface{} = this.SafeString(balance, "asset")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		AddElementToObject(account, "free", this.SafeString(balance, "free"))
		AddElementToObject(account, "used", this.SafeString(balance, "locked"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name coinsph#createOrder
 * @description create a trade order
 * @see https://coins-docs.github.io/rest-api/#new-order--trade
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_loss', 'take_profit', 'stop_loss_limit', 'take_profit_limit' or 'limit_maker'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
 * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// todo: add test order low priority
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13578 := (<-this.LoadMarkets())
		PanicOnError(retRes13578)
		var market interface{} = this.Market(symbol)
		var testOrder interface{} = this.SafeBool(params, "test", false)
		params = this.Omit(params, "test")
		var orderType interface{} = this.SafeString(params, "type", typeVar)
		orderType = this.EncodeOrderType(orderType)
		params = this.Omit(params, "type")
		var orderSide interface{} = this.EncodeOrderSide(side)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"type":   orderType,
			"side":   orderSide,
		}
		var options interface{} = this.SafeValue(this.Options, "createOrder", map[string]interface{}{})
		var newOrderRespType interface{} = this.SafeValue(options, "newOrderRespType", map[string]interface{}{})
		// if limit order
		if IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(orderType, "LIMIT")) || IsTrue(IsEqual(orderType, "STOP_LOSS_LIMIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT_LIMIT"))) || IsTrue(IsEqual(orderType, "LIMIT_MAKER"))) {
			if IsTrue(IsEqual(price, nil)) {
				panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
			}
			newOrderRespType = this.SafeString(newOrderRespType, "limit", "FULL")
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
			AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
			if IsTrue(!IsEqual(orderType, "LIMIT_MAKER")) {
				AddElementToObject(request, "timeInForce", this.SafeString(options, "timeInForce", "GTC"))
			}
		} else if IsTrue(IsTrue(IsTrue(IsEqual(orderType, "MARKET")) || IsTrue(IsEqual(orderType, "STOP_LOSS"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT"))) {
			newOrderRespType = this.SafeString(newOrderRespType, "market", "FULL")
			if IsTrue(IsEqual(orderSide, "SELL")) {
				AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
			} else if IsTrue(IsEqual(orderSide, "BUY")) {
				var quoteAmount interface{} = nil
				var createMarketBuyOrderRequiresPrice interface{} = true
				createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
				createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
				params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
				var cost interface{} = this.SafeNumber2(params, "cost", "quoteOrderQty")
				params = this.Omit(params, "cost")
				if IsTrue(!IsEqual(cost, nil)) {
					quoteAmount = this.CostToPrecision(symbol, cost)
				} else if IsTrue(createMarketBuyOrderRequiresPrice) {
					if IsTrue(IsEqual(price, nil)) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
					} else {
						var amountString interface{} = this.NumberToString(amount)
						var priceString interface{} = this.NumberToString(price)
						var costRequest interface{} = Precise.StringMul(amountString, priceString)
						quoteAmount = this.CostToPrecision(symbol, costRequest)
					}
				} else {
					quoteAmount = this.CostToPrecision(symbol, amount)
				}
				AddElementToObject(request, "quoteOrderQty", quoteAmount)
			}
		}
		if IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(orderType, "STOP_LOSS")) || IsTrue(IsEqual(orderType, "STOP_LOSS_LIMIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT_LIMIT"))) {
			var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
			if IsTrue(IsEqual(triggerPrice, nil)) {
				panic(InvalidOrder(Add(this.Id, " createOrder () requires a triggerPrice or stopPrice param for stop_loss, take_profit, stop_loss_limit, and take_profit_limit orders")))
			}
			AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
		}
		AddElementToObject(request, "newOrderRespType", newOrderRespType)
		params = this.Omit(params, "price", "stopPrice", "triggerPrice", "quantity", "quoteOrderQty")
		var response interface{} = nil
		if IsTrue(testOrder) {

			response = (<-this.PrivatePostOpenapiV1OrderTest(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostOpenapiV1Order(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//     {
		//         "symbol": "ETHUSDT",
		//         "orderId": "1375407140139731486",
		//         "clientOrderId": "1375407140139733169",
		//         "transactTime": "1678697308023",
		//         "price": "1600",
		//         "origQty": "0.02",
		//         "executedQty": "0.02",
		//         "cummulativeQuoteQty": "31.9284",
		//         "status": "FILLED",
		//         "timeInForce": "GTC",
		//         "type": "LIMIT",
		//         "side": "BUY",
		//         "stopPrice": "0",
		//         "origQuoteOrderQty": "0",
		//         "fills": [
		//             {
		//                 "price": "1596.42",
		//                 "qty": "0.02",
		//                 "commission": "0",
		//                 "commissionAsset": "ETH",
		//                 "tradeId": "1375407140281532417"
		//             }
		//         ]
		//     },
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://coins-docs.github.io/rest-api/#query-order-user_data
 * @param {int|string} id order id
 * @param {string} symbol not used by coinsph fetchOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14678 := (<-this.LoadMarkets())
		PanicOnError(retRes14678)
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "origClientOrderId", clientOrderId)
		} else {
			AddElementToObject(request, "orderId", id)
		}
		params = this.Omit(params, []interface{}{"clientOrderId", "origClientOrderId"})

		response := (<-this.PrivateGetOpenapiV1Order(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://coins-docs.github.io/rest-api/#current-open-orders-user_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14928 := (<-this.LoadMarkets())
		PanicOnError(retRes14928)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}

		response := (<-this.PrivateGetOpenapiV1OpenOrders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://coins-docs.github.io/rest-api/#history-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrders() requires a symbol argument")))
		}

		retRes15188 := (<-this.LoadMarkets())
		PanicOnError(retRes15188)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
			// since work properly only when it is "younger" than last 'limit' order
			AddElementToObject(request, "limit", 1000)
		} else if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetOpenapiV1HistoryOrders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#cancelOrder
 * @description cancels an open order
 * @see https://coins-docs.github.io/rest-api/#cancel-order-trade
 * @param {string} id order id
 * @param {string} symbol not used by coinsph cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes15458 := (<-this.LoadMarkets())
		PanicOnError(retRes15458)
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "origClientOrderId", clientOrderId)
		} else {
			AddElementToObject(request, "orderId", id)
		}
		params = this.Omit(params, []interface{}{"clientOrderId", "origClientOrderId"})

		response := (<-this.PrivateDeleteOpenapiV1Order(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#cancelAllOrders
 * @description cancel open orders of market
 * @see https://coins-docs.github.io/rest-api/#cancel-all-open-orders-on-a-symbol-trade
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *coinsph) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}

		retRes15718 := (<-this.LoadMarkets())
		PanicOnError(retRes15718)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}

		response := (<-this.PrivateDeleteOpenapiV1OpenOrders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder POST /openapi/v1/order
	//     {
	//         "symbol": "ETHUSDT",
	//         "orderId": 1375445991893797391,
	//         "clientOrderId": "1375445991893799115",
	//         "transactTime": 1678701939513,
	//         "price": "0",
	//         "origQty": "0",
	//         "executedQty": "0.001899",
	//         "cummulativeQuoteQty": "2.99948949",
	//         "status": "FILLED",
	//         "timeInForce": "GTC",
	//         "type": "MARKET",
	//         "side": "BUY",
	//         "stopPrice": "0",
	//         "origQuoteOrderQty": "3",
	//         "fills": [
	//             {
	//                 "price": "1579.51",
	//                 "qty": "0.001899",
	//                 "commission": "0",
	//                 "commissionAsset": "ETH",
	//                 "tradeId":1375445992035598337
	//             }
	//         ]
	//     }
	//
	// fetchOrder GET /openapi/v1/order
	// fetchOpenOrders GET /openapi/v1/openOrders
	// fetchClosedOrders GET /openapi/v1/historyOrders
	// cancelAllOrders DELETE /openapi/v1/openOrders
	//     {
	//         "symbol": "DOGEPHP",
	//         "orderId":1375465375097982423,
	//         "clientOrderId": "1375465375098001241",
	//         "price": "0",
	//         "origQty": "0",
	//         "executedQty": "13",
	//         "cummulativeQuoteQty": "49.621",
	//         "status": "FILLED",
	//         "timeInForce": "GTC",
	//         "type": "MARKET",
	//         "side": "BUY",
	//         "stopPrice": "0",
	//         "time":1678704250171,
	//         "updateTime":1678704250256,
	//         "isWorking":false,
	//         "origQuoteOrderQty": "50"
	//     }
	//
	// cancelOrder DELETE /openapi/v1/order
	//     {
	//         "symbol": "ETHPHP",
	//         "orderId":1375609441915774332,
	//         "clientOrderId": "1375609441915899557",
	//         "price": "96000",
	//         "origQty": "0.001",
	//         "executedQty": "0",
	//         "cummulativeQuoteQty": "0",
	//         "status": "CANCELED",
	//         "timeInForce": "GTC",
	//         "type": "LIMIT",
	//         "side": "SELL",
	//         "stopPrice": "0",
	//         "origQuoteOrderQty": "0"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(order, "orderId")
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger2(order, "time", "transactTime")
	var trades interface{} = this.SafeValue(order, "fills", nil)
	var triggerPrice interface{} = this.SafeString(order, "stopPrice")
	if IsTrue(Precise.StringEq(triggerPrice, "0")) {
		triggerPrice = nil
	}
	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      this.SafeString(order, "clientOrderId"),
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"status":             this.ParseOrderStatus(this.SafeString(order, "status")),
		"symbol":             GetValue(market, "symbol"),
		"type":               this.ParseOrderType(this.SafeString(order, "type")),
		"timeInForce":        this.ParseOrderTimeInForce(this.SafeString(order, "timeInForce")),
		"side":               this.ParseOrderSide(this.SafeString(order, "side")),
		"price":              this.SafeString(order, "price"),
		"triggerPrice":       triggerPrice,
		"average":            nil,
		"amount":             this.SafeString(order, "origQty"),
		"cost":               this.SafeString(order, "cummulativeQuoteQty"),
		"filled":             this.SafeString(order, "executedQty"),
		"remaining":          nil,
		"fee":                nil,
		"fees":               nil,
		"trades":             trades,
		"info":               order,
	}, market)
}
func (this *coinsph) ParseOrderSide(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"BUY":  "buy",
		"SELL": "sell",
	}
	return this.SafeString(statuses, status, status)
}
func (this *coinsph) EncodeOrderSide(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"buy":  "BUY",
		"sell": "SELL",
	}
	return this.SafeString(statuses, status, status)
}
func (this *coinsph) ParseOrderType(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"MARKET":            "market",
		"LIMIT":             "limit",
		"LIMIT_MAKER":       "limit",
		"STOP_LOSS":         "market",
		"STOP_LOSS_LIMIT":   "limit",
		"TAKE_PROFIT":       "market",
		"TAKE_PROFIT_LIMIT": "limit",
	}
	return this.SafeString(statuses, status, status)
}
func (this *coinsph) EncodeOrderType(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"market":            "MARKET",
		"limit":             "LIMIT",
		"limit_maker":       "LIMIT_MAKER",
		"stop_loss":         "STOP_LOSS",
		"stop_loss_limit":   "STOP_LOSS_LIMIT",
		"take_profit":       "TAKE_PROFIT",
		"take_profit_limit": "TAKE_PROFIT_LIMIT",
	}
	return this.SafeString(statuses, status, status)
}
func (this *coinsph) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"NEW":                "open",
		"FILLED":             "closed",
		"CANCELED":           "canceled",
		"PARTIALLY_FILLED":   "open",
		"PARTIALLY_CANCELED": "canceled",
		"REJECTED":           "rejected",
	}
	return this.SafeString(statuses, status, status)
}
func (this *coinsph) ParseOrderTimeInForce(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"GTC": "GTC",
		"FOK": "FOK",
		"IOC": "IOC",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name coinsph#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://coins-docs.github.io/rest-api/#trade-fee-user_data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *coinsph) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17588 := (<-this.LoadMarkets())
		PanicOnError(retRes17588)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateGetOpenapiV1AssetTradeFee(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//       {
		//         "symbol": "ETHUSDT",
		//         "makerCommission": "0.0025",
		//         "takerCommission": "0.003"
		//       }
		//     ]
		//
		var tradingFee interface{} = this.SafeDict(response, 0, map[string]interface{}{})

		ch <- this.ParseTradingFee(tradingFee, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://coins-docs.github.io/rest-api/#trade-fee-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func (this *coinsph) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17868 := (<-this.LoadMarkets())
		PanicOnError(retRes17868)

		response := (<-this.PrivateGetOpenapiV1AssetTradeFee(params))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "symbol": "ETHPHP",
		//             "makerCommission": "0.0025",
		//             "takerCommission": "0.003"
		//         },
		//         {
		//             "symbol": "UNIPHP",
		//             "makerCommission": "0.0025",
		//             "takerCommission": "0.003"
		//         },
		//     ]
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var fee interface{} = this.ParseTradingFee(GetValue(response, i))
			var symbol interface{} = GetValue(fee, "symbol")
			AddElementToObject(result, symbol, fee)
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *coinsph) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "ETHUSDT",
	//         "makerCommission": "0.0025",
	//         "takerCommission": "0.003"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(fee, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	return map[string]interface{}{
		"info":       fee,
		"symbol":     symbol,
		"maker":      this.SafeNumber(fee, "makerCommission"),
		"taker":      this.SafeNumber(fee, "takerCommission"),
		"percentage": nil,
		"tierBased":  nil,
	}
}

/**
 * @method
 * @name coinsph#withdraw
 * @description make a withdrawal to coins_ph account
 * @see https://coins-docs.github.io/rest-api/#withdrawuser_data
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address not used by coinsph withdraw ()
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *coinsph) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var options interface{} = this.SafeValue(this.Options, "withdraw")
		var warning interface{} = this.SafeBool(options, "warning", true)
		if IsTrue(warning) {
			panic(InvalidAddress(Add(this.Id, " withdraw() makes a withdrawals only to coins_ph account, add .options[\\'withdraw\\'][\\'warning\\'] = false to make a withdrawal to your coins_ph account")))
		}
		var networkCode interface{} = this.SafeString(params, "network")
		var networkId interface{} = this.NetworkCodeToId(networkCode, code)
		if IsTrue(IsEqual(networkId, nil)) {
			panic(BadRequest(Add(this.Id, " withdraw() require network parameter")))
		}

		retRes18558 := (<-this.LoadMarkets())
		PanicOnError(retRes18558)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":    GetValue(currency, "id"),
			"amount":  this.NumberToString(amount),
			"network": networkId,
			"address": address,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "withdrawOrderId", tag)
		}
		params = this.Omit(params, "network")

		response := (<-this.PrivatePostOpenapiWalletV1WithdrawApply(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://coins-docs.github.io/rest-api/#deposit-history-user_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *coinsph) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// todo: returns an empty array - find out why
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18848 := (<-this.LoadMarkets())
		PanicOnError(retRes18848)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetOpenapiWalletV1DepositHistory(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//         "id": "d_769800519366885376",
		//         "amount": "0.001",
		//         "coin": "BNB",
		//         "network": "BNB",
		//         "status": 0,
		//         "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
		//         "addressTag": "101764890",
		//         "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
		//         "insertTime": 1661493146000,
		//         "confirmNo": 10,
		//     },
		//     {
		//         "id": "d_769754833590042625",
		//         "amount":"0.5",
		//         "coin":"IOTA",
		//         "network":"IOTA",
		//         "status":1,
		//         "address":"SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
		//         "addressTag":"",
		//         "txId":"ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
		//         "insertTime":1599620082000,
		//         "confirmNo": 20,
		//     }
		// ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name coinsph#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://coins-docs.github.io/rest-api/#withdraw-history-user_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *coinsph) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// todo: returns an empty array - find out why
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes19428 := (<-this.LoadMarkets())
		PanicOnError(retRes19428)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetOpenapiWalletV1WithdrawHistory(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//         "id": "459890698271244288",
		//         "amount": "0.01",
		//         "transactionFee": "0",
		//         "coin": "ETH",
		//         "status": 1,
		//         "address": "0x386AE30AE2dA293987B5d51ddD03AEb70b21001F",
		//         "addressTag": "",
		//         "txId": "0x4ae2fed36a90aada978fc31c38488e8b60d7435cfe0b4daed842456b4771fcf7",
		//         "applyTime": 1673601139000,
		//         "network": "ETH",
		//         "withdrawOrderId": "thomas123",
		//         "info": "",
		//         "confirmNo": 100
		//     },
		//     {
		//         "id": "451899190746456064",
		//         "amount": "0.00063",
		//         "transactionFee": "0.00037",
		//         "coin": "ETH",
		//         "status": 1,
		//         "address": "0x386AE30AE2dA293987B5d51ddD03AEb70b21001F",
		//         "addressTag": "",
		//         "txId": "0x62690ca4f9d6a8868c258e2ce613805af614d9354dda7b39779c57b2e4da0260",
		//         "applyTime": 1671695815000,
		//         "network": "ETH",
		//         "withdrawOrderId": "",
		//         "info": "",
		//         "confirmNo": 100
		//     }
		// ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//     {
	//         "coin": "PHP",
	//         "address": "Internal Transfer",
	//         "addressTag": "Internal Transfer",
	//         "amount": "0.02",
	//         "id": "31312321312312312312322",
	//         "network": "Internal",
	//         "transferType": "0",
	//         "status": 3,
	//         "confirmTimes": "",
	//         "unlockConfirm": "",
	//         "txId": "Internal Transfer",
	//         "insertTime": 1657623798000,
	//         "depositOrderId": "the deposit id which created by client"
	//     }
	//
	// fetchWithdrawals
	//     {
	//         "coin": "BTC",
	//         "address": "Internal Transfer",
	//         "amount": "0.1",
	//         "id": "1201515362324421632",
	//         "withdrawOrderId": null,
	//         "network": "Internal",
	//         "transferType": "0",
	//         "status": 0,
	//         "transactionFee": "0",
	//         "confirmNo": 0,
	//         "info": "{}",
	//         "txId": "Internal Transfer",
	//         "applyTime": 1657967792000
	//     }
	//
	// todo: this is in progress
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(transaction, "id")
	var address interface{} = this.SafeString(transaction, "address")
	var tag interface{} = this.SafeString(transaction, "addressTag")
	if IsTrue(!IsEqual(tag, nil)) {
		if IsTrue(IsLessThan(GetLength(tag), 1)) {
			tag = nil
		}
	}
	var txid interface{} = this.SafeString(transaction, "txId")
	var currencyId interface{} = this.SafeString(transaction, "coin")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var timestamp interface{} = nil
	timestamp = this.SafeInteger2(transaction, "insertTime", "applyTime")
	var updated interface{} = nil
	var typeVar interface{} = nil
	var withdrawOrderId interface{} = this.SafeString(transaction, "withdrawOrderId")
	var depositOrderId interface{} = this.SafeString(transaction, "depositOrderId")
	if IsTrue(!IsEqual(withdrawOrderId, nil)) {
		typeVar = "withdrawal"
	} else if IsTrue(!IsEqual(depositOrderId, nil)) {
		typeVar = "deposit"
	}
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
	var amount interface{} = this.SafeNumber(transaction, "amount")
	var feeCost interface{} = this.SafeNumber(transaction, "transactionFee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": code,
			"cost":     feeCost,
		}
	}
	var network interface{} = this.SafeString(transaction, "network")
	var internal interface{} = IsEqual(network, "Internal")
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     network,
		"address":     address,
		"addressTo":   address,
		"addressFrom": nil,
		"tag":         tag,
		"tagTo":       tag,
		"tagFrom":     nil,
		"type":        typeVar,
		"amount":      amount,
		"currency":    code,
		"status":      status,
		"updated":     updated,
		"internal":    internal,
		"comment":     nil,
		"fee":         fee,
	}
}
func (this *coinsph) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"0": "pending",
		"1": "ok",
		"2": "failed",
		"3": "pending",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name coinsph#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://coins-docs.github.io/rest-api/#deposit-address-user_data
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for fetch deposit address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *coinsph) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var networkCode interface{} = this.SafeString(params, "network")
		var networkId interface{} = this.NetworkCodeToId(networkCode, code)
		if IsTrue(IsEqual(networkId, nil)) {
			panic(BadRequest(Add(this.Id, " fetchDepositAddress() require network parameter")))
		}

		retRes21118 := (<-this.LoadMarkets())
		PanicOnError(retRes21118)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":    GetValue(currency, "id"),
			"network": networkId,
		}
		params = this.Omit(params, "network")

		response := (<-this.PrivateGetOpenapiWalletV1DepositAddress(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "coin": "ETH",
		//         "address": "0xfe98628173830bf79c59f04585ce41f7de168784",
		//         "addressTag": ""
		//     }
		//
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}
func (this *coinsph) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "coin": "ETH",
	//         "address": "0xfe98628173830bf79c59f04585ce41f7de168784",
	//         "addressTag": ""
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(depositAddress, "coin")
	var parsedCurrency interface{} = this.SafeCurrencyCode(currencyId, currency)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": parsedCurrency,
		"network":  nil,
		"address":  this.SafeString(depositAddress, "address"),
		"tag":      this.SafeString(depositAddress, "addressTag"),
	}
}
func (this *coinsph) UrlEncodeQuery(optionalArgs ...interface{}) interface{} {
	query := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = query
	var encodedArrayParams interface{} = ""
	var keys interface{} = ObjectKeys(query)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var key interface{} = GetValue(keys, i)
		if IsTrue(IsArray(GetValue(query, key))) {
			if IsTrue(!IsEqual(i, 0)) {
				encodedArrayParams = Add(encodedArrayParams, "&")
			}
			var innerArray interface{} = GetValue(query, key)
			query = this.Omit(query, key)
			var encodedArrayParam interface{} = this.ParseArrayParam(innerArray, key)
			encodedArrayParams = Add(encodedArrayParams, encodedArrayParam)
		}
	}
	var encodedQuery interface{} = this.Urlencode(query)
	if IsTrue(!IsEqual(GetArrayLength(encodedQuery), 0)) {
		return Add(Add(encodedQuery, "&"), encodedArrayParams)
	} else {
		return encodedArrayParams
	}
}
func (this *coinsph) ParseArrayParam(array interface{}, key interface{}) interface{} {
	var stringifiedArray interface{} = this.Json(array)
	stringifiedArray = Replace(stringifiedArray, "[", "%5B")
	stringifiedArray = Replace(stringifiedArray, "]", "%5D")
	var urlEncodedParam interface{} = Add(Add(key, "="), stringifiedArray)
	return urlEncodedParam
}
func (this *coinsph) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	var endpoint interface{} = this.ImplodeParams(path, params)
	url = Add(Add(url, "/"), endpoint)
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		AddElementToObject(query, "timestamp", this.Milliseconds())
		var recvWindow interface{} = this.SafeInteger(query, "recvWindow")
		if IsTrue(IsEqual(recvWindow, nil)) {
			var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
			if IsTrue(!IsEqual(defaultRecvWindow, nil)) {
				AddElementToObject(query, "recvWindow", defaultRecvWindow)
			}
		}
		query = this.UrlEncodeQuery(query)
		var signature interface{} = this.Hmac(this.Encode(query), this.Encode(this.Secret), sha256)
		url = Add(Add(Add(Add(url, "?"), query), "&signature="), signature)
		headers = map[string]interface{}{
			"X-COINS-APIKEY": this.ApiKey,
		}
	} else {
		query = this.UrlEncodeQuery(query)
		if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
			url = Add(url, Add("?", query))
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *coinsph) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	var responseCode interface{} = this.SafeString(response, "code", nil)
	if IsTrue(IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(responseCode, "200")))) && IsTrue((!IsEqual(responseCode, "0")))) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCode, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *coinsph) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
