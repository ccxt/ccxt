package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinsph struct {
    Exchange

}

func NewCoinsphCore() coinsph {
   p := coinsph{}
   setDefaults(&p)
   return p
}

func  (this *coinsph) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinsph",
        "name": "Coins.ph",
        "countries": []interface{}{"PH"},
        "version": "v1",
        "rateLimit": 50,
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "deposit": true,
            "editOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": false,
            "fetchDeposit": nil,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": nil,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawal": nil,
            "fetchWithdrawals": true,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": false,
            "withdraw": true,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "8h": "8h",
            "12h": "12h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/225719995-48ab2026-4ddb-496c-9da7-0d7566617c9b.jpg",
            "api": map[string]interface{} {
                "public": "https://api.pro.coins.ph",
                "private": "https://api.pro.coins.ph",
            },
            "www": "https://coins.ph/",
            "doc": []interface{}{"https://coins-docs.github.io/rest-api"},
            "fees": "https://support.coins.ph/hc/en-us/sections/4407198694681-Limits-Fees",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "openapi/v1/ping": 1,
                    "openapi/v1/time": 1,
                    "openapi/quote/v1/ticker/24hr": map[string]interface{} {
                        "cost": 1,
                        "noSymbolAndNoSymbols": 40,
                        "byNumberOfSymbols": []interface{}{[]interface{}{101, 40}, []interface{}{21, 20}, []interface{}{0, 1}},
                    },
                    "openapi/quote/v1/ticker/price": map[string]interface{} {
                        "cost": 1,
                        "noSymbol": 2,
                    },
                    "openapi/quote/v1/ticker/bookTicker": map[string]interface{} {
                        "cost": 1,
                        "noSymbol": 2,
                    },
                    "openapi/v1/exchangeInfo": 10,
                    "openapi/quote/v1/depth": map[string]interface{} {
                        "cost": 1,
                        "byLimit": []interface{}{[]interface{}{101, 5}, []interface{}{0, 1}},
                    },
                    "openapi/quote/v1/klines": 1,
                    "openapi/quote/v1/trades": 1,
                    "openapi/v1/pairs": 1,
                    "openapi/quote/v1/avgPrice": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "openapi/wallet/v1/config/getall": 10,
                    "openapi/wallet/v1/deposit/address": 10,
                    "openapi/wallet/v1/deposit/history": 1,
                    "openapi/wallet/v1/withdraw/history": 1,
                    "openapi/v1/account": 10,
                    "openapi/v1/openOrders": map[string]interface{} {
                        "cost": 3,
                        "noSymbol": 40,
                    },
                    "openapi/v1/asset/tradeFee": 1,
                    "openapi/v1/order": 2,
                    "openapi/v1/historyOrders": map[string]interface{} {
                        "cost": 10,
                        "noSymbol": 40,
                    },
                    "openapi/v1/myTrades": 10,
                    "openapi/v1/capital/deposit/history": 1,
                    "openapi/v1/capital/withdraw/history": 1,
                    "openapi/v3/payment-request/get-payment-request": 1,
                    "merchant-api/v1/get-invoices": 1,
                    "openapi/account/v3/crypto-accounts": 1,
                    "openapi/transfer/v3/transfers/{id}": 1,
                },
                "post": map[string]interface{} {
                    "openapi/wallet/v1/withdraw/apply": 600,
                    "openapi/v1/order/test": 1,
                    "openapi/v1/order": 1,
                    "openapi/v1/capital/withdraw/apply": 1,
                    "openapi/v1/capital/deposit/apply": 1,
                    "openapi/v3/payment-request/payment-requests": 1,
                    "openapi/v3/payment-request/delete-payment-request": 1,
                    "openapi/v3/payment-request/payment-request-reminder": 1,
                    "openapi/v1/userDataStream": 1,
                    "merchant-api/v1/invoices": 1,
                    "merchant-api/v1/invoices-cancel": 1,
                    "openapi/convert/v1/get-supported-trading-pairs": 1,
                    "openapi/convert/v1/get-quote": 1,
                    "openapi/convert/v1/accpet-quote": 1,
                    "openapi/fiat/v1/support-channel": 1,
                    "openapi/fiat/v1/cash-out": 1,
                    "openapi/fiat/v1/history": 1,
                    "openapi/migration/v4/sellorder": 1,
                    "openapi/migration/v4/validate-field": 1,
                    "openapi/transfer/v3/transfers": 1,
                },
                "delete": map[string]interface{} {
                    "openapi/v1/order": 1,
                    "openapi/v1/openOrders": 1,
                    "openapi/v1/userDataStream": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0025"),
                "taker": this.ParseNumber("0.003"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0027")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0024")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("1000000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("2500000000"), this.ParseNumber("0.0005")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0022")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1000000000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("2500000000"), this.ParseNumber("0.0005")}},
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "createMarketBuyOrderRequiresPrice": true,
            "withdraw": map[string]interface{} {
                "warning": false,
            },
            "deposit": map[string]interface{} {
                "warning": false,
            },
            "createOrder": map[string]interface{} {
                "timeInForce": "GTC",
                "newOrderRespType": map[string]interface{} {
                    "market": "FULL",
                    "limit": "FULL",
                },
            },
            "fetchTicker": map[string]interface{} {
                "method": "publicGetOpenapiQuoteV1Ticker24hr",
            },
            "fetchTickers": map[string]interface{} {
                "method": "publicGetOpenapiQuoteV1Ticker24hr",
            },
            "networks": map[string]interface{} {
                "TRC20": "TRX",
                "ERC20": "ETH",
                "BEP20": "BSC",
                "ARB": "ARBITRUM",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": true,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1000": BadRequest,
                "-1001": BadRequest,
                "-1002": AuthenticationError,
                "-1003": RateLimitExceeded,
                "-1004": InvalidOrder,
                "-1006": BadResponse,
                "-1007": BadResponse,
                "-1014": InvalidOrder,
                "-1015": RateLimitExceeded,
                "-1016": NotSupported,
                "-1020": NotSupported,
                "-1021": BadRequest,
                "-1022": BadRequest,
                "-1023": AuthenticationError,
                "-1024": BadRequest,
                "-1025": BadRequest,
                "-1030": ExchangeError,
                "-1100": BadRequest,
                "-1101": BadRequest,
                "-1102": BadRequest,
                "-1103": BadRequest,
                "-1104": BadRequest,
                "-1105": BadRequest,
                "-1106": BadRequest,
                "-1111": BadRequest,
                "-1112": BadResponse,
                "-1114": BadRequest,
                "-1115": InvalidOrder,
                "-1116": InvalidOrder,
                "-1117": InvalidOrder,
                "-1118": InvalidOrder,
                "-1119": InvalidOrder,
                "-1120": BadRequest,
                "-1121": BadSymbol,
                "-1122": InvalidOrder,
                "-1125": BadRequest,
                "-1127": BadRequest,
                "-1128": BadRequest,
                "-1130": BadRequest,
                "-1131": InsufficientFunds,
                "-1132": InvalidOrder,
                "-1133": InvalidOrder,
                "-1134": InvalidOrder,
                "-1135": InvalidOrder,
                "-1136": InvalidOrder,
                "-1137": InvalidOrder,
                "-1138": InvalidOrder,
                "-1139": InvalidOrder,
                "-1140": InvalidOrder,
                "-1141": DuplicateOrderId,
                "-1142": InvalidOrder,
                "-1143": OrderNotFound,
                "-1144": InvalidOrder,
                "-1145": InvalidOrder,
                "-1146": InvalidOrder,
                "-1147": InvalidOrder,
                "-1148": InvalidOrder,
                "-1149": InvalidOrder,
                "-1150": InvalidOrder,
                "-1151": BadSymbol,
                "-1152": NotSupported,
                "-1153": AuthenticationError,
                "-1154": BadRequest,
                "-1155": BadRequest,
                "-1156": InvalidOrder,
                "-1157": BadSymbol,
                "-1158": InvalidOrder,
                "-1159": InvalidOrder,
                "-1160": BadRequest,
                "-1161": BadRequest,
                "-2010": InvalidOrder,
                "-2013": OrderNotFound,
                "-2011": BadRequest,
                "-2014": BadRequest,
                "-2015": AuthenticationError,
                "-2016": BadResponse,
                "-3126": InvalidOrder,
                "-3127": InvalidOrder,
                "-4001": BadRequest,
                "-100011": BadSymbol,
                "-100012": BadSymbol,
                "-30008": InsufficientFunds,
                "-30036": InsufficientFunds,
                "403": ExchangeNotAvailable,
            },
            "broad": map[string]interface{} {
                "Unknown order sent": OrderNotFound,
                "Duplicate order sent": DuplicateOrderId,
                "Market is closed": BadSymbol,
                "Account has insufficient balance for requested action": InsufficientFunds,
                "Market orders are not supported for this symbol": BadSymbol,
                "Iceberg orders are not supported for this symbol": BadSymbol,
                "Stop loss orders are not supported for this symbol": BadSymbol,
                "Stop loss limit orders are not supported for this symbol": BadSymbol,
                "Take profit orders are not supported for this symbol": BadSymbol,
                "Take profit limit orders are not supported for this symbol": BadSymbol,
                "Price* QTY is zero or less": BadRequest,
                "IcebergQty exceeds QTY": BadRequest,
                "This action disabled is on this account": PermissionDenied,
                "Unsupported order combination": InvalidOrder,
                "Order would trigger immediately": InvalidOrder,
                "Cancel order is invalid. Check origClOrdId and orderId": InvalidOrder,
                "Order would immediately match and take": OrderImmediatelyFillable,
                "PRICE_FILTER": InvalidOrder,
                "LOT_SIZE": InvalidOrder,
                "MIN_NOTIONAL": InvalidOrder,
                "MAX_NUM_ORDERS": InvalidOrder,
                "MAX_ALGO_ORDERS": InvalidOrder,
                "BROKER_MAX_NUM_ORDERS": InvalidOrder,
                "BROKER_MAX_ALGO_ORDERS": InvalidOrder,
                "ICEBERG_PARTS": BadRequest,
            },
        },
    })
}
func  (this *coinsph) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = config
    if IsTrue(IsTrue((InOp(config, "noSymbol"))) && !IsTrue((InOp(params, "symbol")))) {
        return GetValue(config, "noSymbol")
    } else if IsTrue(IsTrue(IsTrue((InOp(config, "noSymbolAndNoSymbols"))) && !IsTrue((InOp(params, "symbol")))) && !IsTrue((InOp(params, "symbols")))) {
        return GetValue(config, "noSymbolAndNoSymbols")
    } else if IsTrue(IsTrue((InOp(config, "byNumberOfSymbols"))) && IsTrue((InOp(params, "symbols")))) {
        var symbols interface{} = GetValue(params, "symbols")
        var symbolsAmount interface{} =         GetArrayLength(symbols)
        var byNumberOfSymbols interface{} = GetValue(config, "byNumberOfSymbols")
        for i := 0; IsLessThan(i, GetArrayLength(byNumberOfSymbols)); i++ {
            var entry interface{} = GetValue(byNumberOfSymbols, i)
            if IsTrue(IsGreaterThanOrEqual(symbolsAmount, GetValue(entry, 0))) {
                return GetValue(entry, 1)
            }
        }
    } else if IsTrue(IsTrue((InOp(config, "byLimit"))) && IsTrue((InOp(params, "limit")))) {
        var limit interface{} = GetValue(params, "limit")
        var byLimit interface{} = GetValue(config, "byLimit")
        for i := 0; IsLessThan(i, GetArrayLength(byLimit)); i++ {
            var entry interface{} = GetValue(byLimit, i)
            if IsTrue(IsGreaterThanOrEqual(limit, GetValue(entry, 0))) {
                return GetValue(entry, 1)
            }
        }
    }
    return this.SafeValue(config, "cost", 1)
}
/**
 * @method
 * @name coinsph#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://coins-docs.github.io/rest-api/#test-connectivity
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *coinsph) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetOpenapiV1Ping(params))
            PanicOnError(response)
        
            ch <- map[string]interface{} {
                "status": "ok",
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://coins-docs.github.io/rest-api/#check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *coinsph) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetOpenapiV1Time(params))
            PanicOnError(response)
        
                //
            //     {"serverTime":1677705408268}
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchMarkets
 * @description retrieves data on all markets for coinsph
 * @see https://coins-docs.github.io/rest-api/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinsph) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetOpenapiV1ExchangeInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": "1677449496897",
            //         "exchangeFilters": [],
            //         "symbols": [
            //             {
            //                 "symbol": "XRPPHP",
            //                 "status": "TRADING",
            //                 "baseAsset": "XRP",
            //                 "baseAssetPrecision": "2",
            //                 "quoteAsset": "PHP",
            //                 "quoteAssetPrecision": "4",
            //                 "orderTypes": [
            //                     "LIMIT",
            //                     "MARKET",
            //                     "LIMIT_MAKER",
            //                     "STOP_LOSS_LIMIT",
            //                     "STOP_LOSS",
            //                     "TAKE_PROFIT_LIMIT",
            //                     "TAKE_PROFIT"
            //                 ],
            //                 "filters": [
            //                     {
            //                         "minPrice": "0.01",
            //                         "maxPrice": "99999999.00000000",
            //                         "tickSize": "0.01",
            //                         "filterType": "PRICE_FILTER"
            //                     },
            //                     {
            //                         "minQty": "0.01",
            //                         "maxQty": "99999999999.00000000",
            //                         "stepSize": "0.01",
            //                         "filterType": "LOT_SIZE"
            //                     },
            //                     { minNotional: "50", filterType: "NOTIONAL" },
            //                     { minNotional: "50", filterType: "MIN_NOTIONAL" },
            //                     {
            //                         "priceUp": "99999999",
            //                         "priceDown": "0.01",
            //                         "filterType": "STATIC_PRICE_RANGE"
            //                     },
            //                     {
            //                         "multiplierUp": "1.1",
            //                         "multiplierDown": "0.9",
            //                         "filterType": "PERCENT_PRICE_INDEX"
            //                     },
            //                     {
            //                         "multiplierUp": "1.1",
            //                         "multiplierDown": "0.9",
            //                         "filterType": "PERCENT_PRICE_ORDER_SIZE"
            //                     },
            //                     { maxNumOrders: "200", filterType: "MAX_NUM_ORDERS" },
            //                     { maxNumAlgoOrders: "5", filterType: "MAX_NUM_ALGO_ORDERS" }
            //                 ]
            //             },
            //         ]
            //     }
            //
            var markets interface{} = this.SafeList(response, "symbols", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseAsset")
                var quoteId interface{} = this.SafeString(market, "quoteAsset")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var limits interface{} = this.IndexBy(this.SafeList(market, "filters", []interface{}{}), "filterType")
                var amountLimits interface{} = this.SafeValue(limits, "LOT_SIZE", map[string]interface{} {})
                var priceLimits interface{} = this.SafeValue(limits, "PRICE_FILTER", map[string]interface{} {})
                var costLimits interface{} = this.SafeValue(limits, "NOTIONAL", map[string]interface{} {})
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": IsEqual(this.SafeStringLower(market, "status"), "trading"),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": nil,
                    "maker": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.SafeString(amountLimits, "stepSize")),
                        "price": this.ParseNumber(this.SafeString(priceLimits, "tickSize")),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.ParseNumber(this.SafeString(amountLimits, "minQty")),
                            "max": this.ParseNumber(this.SafeString(amountLimits, "maxQty")),
                        },
                        "price": map[string]interface{} {
                            "min": this.ParseNumber(this.SafeString(priceLimits, "minPrice")),
                            "max": this.ParseNumber(this.SafeString(priceLimits, "maxPrice")),
                        },
                        "cost": map[string]interface{} {
                            "min": this.ParseNumber(this.SafeString(costLimits, "minNotional")),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
            this.SetMarkets(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://coins-docs.github.io/rest-api/#24hr-ticker-price-change-statistics
 * @see https://coins-docs.github.io/rest-api/#symbol-price-ticker
 * @see https://coins-docs.github.io/rest-api/#symbol-order-book-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinsph) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6978 := (<-this.LoadMarkets())
            PanicOnError(retRes6978)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var ids interface{} = []interface{}{}
                for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                    var market interface{} = this.Market(GetValue(symbols, i))
                    var id interface{} = GetValue(market, "id")
                    AppendToArray(&ids,id)
                }
                AddElementToObject(request, "symbols", ids)
            }
            var defaultMethod interface{} = "publicGetOpenapiQuoteV1Ticker24hr"
            var options interface{} = this.SafeDict(this.Options, "fetchTickers", map[string]interface{} {})
            var method interface{} = this.SafeString(options, "method", defaultMethod)
            var tickers interface{} = nil
            if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerPrice")) {
                
        tickers = (<-this.PublicGetOpenapiQuoteV1TickerPrice(this.Extend(request, params)))
                PanicOnError(tickers)
            } else if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerBookTicker")) {
                
        tickers = (<-this.PublicGetOpenapiQuoteV1TickerBookTicker(this.Extend(request, params)))
                PanicOnError(tickers)
            } else {
                
        tickers = (<-this.PublicGetOpenapiQuoteV1Ticker24hr(this.Extend(request, params)))
                PanicOnError(tickers)
            }
        
            ch <- this.ParseTickers(tickers, symbols, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coins-docs.github.io/rest-api/#24hr-ticker-price-change-statistics
 * @see https://coins-docs.github.io/rest-api/#symbol-price-ticker
 * @see https://coins-docs.github.io/rest-api/#symbol-order-book-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinsph) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7348 := (<-this.LoadMarkets())
            PanicOnError(retRes7348)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var defaultMethod interface{} = "publicGetOpenapiQuoteV1Ticker24hr"
            var options interface{} = this.SafeDict(this.Options, "fetchTicker", map[string]interface{} {})
            var method interface{} = this.SafeString(options, "method", defaultMethod)
            var ticker interface{} = nil
            if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerPrice")) {
                
        ticker = (<-this.PublicGetOpenapiQuoteV1TickerPrice(this.Extend(request, params)))
                PanicOnError(ticker)
            } else if IsTrue(IsEqual(method, "publicGetOpenapiQuoteV1TickerBookTicker")) {
                
        ticker = (<-this.PublicGetOpenapiQuoteV1TickerBookTicker(this.Extend(request, params)))
                PanicOnError(ticker)
            } else {
                
        ticker = (<-this.PublicGetOpenapiQuoteV1Ticker24hr(this.Extend(request, params)))
                PanicOnError(ticker)
            }
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // publicGetOpenapiQuoteV1Ticker24hr
    //     {
    //         "symbol": "ETHUSDT",
    //         "priceChange": "41.440000000000000000",
    //         "priceChangePercent": "0.0259",
    //         "weightedAvgPrice": "1631.169825783972125436",
    //         "prevClosePrice": "1601.520000000000000000",
    //         "lastPrice": "1642.96",
    //         "lastQty": "0.000001000000000000",
    //         "bidPrice": "1638.790000000000000000",
    //         "bidQty": "0.280075000000000000",
    //         "askPrice": "1647.340000000000000000",
    //         "askQty": "0.165183000000000000",
    //         "openPrice": "1601.52",
    //         "highPrice": "1648.28",
    //         "lowPrice": "1601.52",
    //         "volume": "0.000287",
    //         "quoteVolume": "0.46814574",
    //         "openTime": "1677417000000",
    //         "closeTime": "1677503415200",
    //         "firstId": "1364680572697591809",
    //         "lastId": "1365389809203560449",
    //         "count": "100"
    //     }
    //
    // publicGetOpenapiQuoteV1TickerPrice
    //     { "symbol": "ETHUSDT", "price": "1599.68" }
    //
    // publicGetOpenapiQuoteV1TickerBookTicker
    //     {
    //         "symbol": "ETHUSDT",
    //         "bidPrice": "1596.57",
    //         "bidQty": "0.246405",
    //         "askPrice": "1605.12",
    //         "askQty": "0.242681"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(ticker, "closeTime")
    var bid interface{} = this.SafeString(ticker, "bidPrice")
    var ask interface{} = this.SafeString(ticker, "askPrice")
    var bidVolume interface{} = this.SafeString(ticker, "bidQty")
    var askVolume interface{} = this.SafeString(ticker, "askQty")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume")
    var open interface{} = this.SafeString(ticker, "openPrice")
    var high interface{} = this.SafeString(ticker, "highPrice")
    var low interface{} = this.SafeString(ticker, "lowPrice")
    var prevClose interface{} = this.SafeString(ticker, "prevClosePrice")
    var vwap interface{} = this.SafeString(ticker, "weightedAvgPrice")
    var changeValue interface{} = this.SafeString(ticker, "priceChange")
    var changePcnt interface{} = this.SafeString(ticker, "priceChangePercent")
    changePcnt = Precise.StringMul(changePcnt, "100")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "open": open,
        "high": high,
        "low": low,
        "close": this.SafeString2(ticker, "lastPrice", "price"),
        "bid": bid,
        "bidVolume": bidVolume,
        "ask": ask,
        "askVolume": askVolume,
        "vwap": vwap,
        "previousClose": prevClose,
        "change": changeValue,
        "percentage": changePcnt,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinsph#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coins-docs.github.io/rest-api/#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinsph) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8438 := (<-this.LoadMarkets())
            PanicOnError(retRes8438)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetOpenapiQuoteV1Depth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "lastUpdateId": "1667022157000699400",
            //         "bids": [
            //             [ '1651.810000000000000000', '0.214556000000000000' ],
            //             [ '1651.730000000000000000', '0.257343000000000000' ],
            //         ],
            //         "asks": [
            //             [ '1660.510000000000000000', '0.299092000000000000' ],
            //             [ '1660.600000000000000000', '0.253667000000000000' ],
            //         ]
            //     }
            //
            var orderbook interface{} = this.ParseOrderBook(response, symbol)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://coins-docs.github.io/rest-api/#klinecandlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coinsph) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8848 := (<-this.LoadMarkets())
            PanicOnError(retRes8848)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe)
            var until interface{} = this.SafeInteger(params, "until")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": interval,
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 1000
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
                // since work properly only when it is "younger" than last "limit" candle
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                } else {
                    var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
                    var endTimeByLimit interface{} = this.Sum(since, Multiply(duration, (Subtract(limit, 1))))
                    var now interface{} = this.Milliseconds()
                    AddElementToObject(request, "endTime", mathMin(endTimeByLimit, now))
                }
            } else if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
                // since work properly only when it is "younger" than last "limit" candle
                var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
                AddElementToObject(request, "startTime", Subtract(until, (Multiply(duration, (Subtract(limit, 1))))))
            }
            AddElementToObject(request, "limit", limit)
            params = this.Omit(params, "until")
        
            response:= (<-this.PublicGetOpenapiQuoteV1Klines(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [
            //             1499040000000,      // Open time
            //             "0.01634790",       // Open
            //             "0.80000000",       // High
            //             "0.01575800",       // Low
            //             "0.01577100",       // Close
            //             "148976.11427815",  // Volume
            //             1499644799999,      // Close time
            //             "2434.19055334",    // Quote asset volume
            //             308,                // Number of trades
            //             "1756.87402397",    // Taker buy base asset volume
            //             "28.46694368"       // Taker buy quote asset volume
            //         ]
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name coinsph#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coins-docs.github.io/rest-api/#recent-trades-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinsph) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9588 := (<-this.LoadMarkets())
            PanicOnError(retRes9588)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                // since work properly only when it is "younger" than last 'limit' trade
                AddElementToObject(request, "limit", 1000)
            } else {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
            }
        
            response:= (<-this.PublicGetOpenapiQuoteV1Trades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "price": "89685.8",
            //             "id": "1365561108437680129",
            //             "qty": "0.000004",
            //             "quoteQty": "0.000004000000000000",
            //             "time": "1677523569575",
            //             "isBuyerMaker": false,
            //             "isBestMatch": true
            //         },
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://coins-docs.github.io/rest-api/#account-trade-list-user_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinsph) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes10038 := (<-this.LoadMarkets())
            PanicOnError(retRes10038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
                // since work properly only when it is "younger" than last 'limit' trade
                AddElementToObject(request, "limit", 1000)
            } else if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOpenapiV1MyTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://coins-docs.github.io/rest-api/#account-trade-list-user_data
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinsph) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrderTrades() requires a symbol argument")))
            }
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
                retRes103815 :=  (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes103815)
                ch <- retRes103815
                return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //     {
    //         "price": "89685.8",
    //         "id": "1365561108437680129",
    //         "qty": "0.000004",
    //         "quoteQty": "0.000004000000000000", // warning: report to exchange - this is not quote quantity, this is base quantity
    //         "time": "1677523569575",
    //         "isBuyerMaker": false,
    //         "isBestMatch": true
    //     },
    //
    // fetchMyTrades
    //     {
    //         "symbol": "ETHUSDT",
    //         "id": 1375426310524125185,
    //         "orderId": 1375426310415879614,
    //         "price": "1580.91",
    //         "qty": "0.01",
    //         "quoteQty": "15.8091",
    //         "commission": "0",
    //         "commissionAsset": "USDT",
    //         "time": 1678699593307,
    //         "isBuyer": false,
    //         "isMaker":false,
    //         "isBestMatch":false
    //     }
    //
    // createOrder
    //     {
    //         "price": "1579.51",
    //         "qty": "0.001899",
    //         "commission": "0",
    //         "commissionAsset": "ETH",
    //         "tradeId":1375445992035598337
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeString2(trade, "id", "tradeId")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "qty")
    var typeVar interface{} = nil
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "commission")
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "commissionAsset")
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeCurrencyCode(feeCurrencyId),
        }
    }
    var isBuyer interface{} = this.SafeBool2(trade, "isBuyer", "isBuyerMaker", nil)
    var side interface{} = nil
    if IsTrue(!IsEqual(isBuyer, nil)) {
        side = Ternary(IsTrue((IsEqual(isBuyer, true))), "buy", "sell")
    }
    var isMaker interface{} = this.SafeString2(trade, "isMaker", nil)
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(isMaker, nil)) {
        takerOrMaker = Ternary(IsTrue((IsEqual(isMaker, "true"))), "maker", "taker")
    }
    var costString interface{} = nil
    if IsTrue(!IsEqual(orderId, nil)) {
        costString = this.SafeString(trade, "quoteQty")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name coinsph#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coins-docs.github.io/rest-api/#accept-the-quote
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinsph) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11378 := (<-this.LoadMarkets())
            PanicOnError(retRes11378)
        
            response:= (<-this.PrivateGetOpenapiV1Account(params))
            PanicOnError(response)
        
                //
            //     {
            //         "accountType": "SPOT",
            //         "balances": [
            //             {
            //                 "asset": "BTC",
            //                 "free": "4723846.89208129",
            //                 "locked": "0.00000000"
            //             },
            //             {
            //                 "asset": "LTC",
            //                 "free": "4763368.68006011",
            //                 "locked": "0.00000000"
            //             }
            //         ],
            //         "canDeposit": true,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "updateTime": "1677430932528"
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeList(response, "balances", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "free"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinsph#createOrder
 * @description create a trade order
 * @see https://coins-docs.github.io/rest-api/#new-order--trade
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_loss', 'take_profit', 'stop_loss_limit', 'take_profit_limit' or 'limit_maker'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
 * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // todo: add test order low priority
            price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11998 := (<-this.LoadMarkets())
            PanicOnError(retRes11998)
            var market interface{} = this.Market(symbol)
            var testOrder interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var orderType interface{} = this.SafeString(params, "type", typeVar)
            orderType = this.EncodeOrderType(orderType)
            params = this.Omit(params, "type")
            var orderSide interface{} = this.EncodeOrderSide(side)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": orderType,
                "side": orderSide,
            }
            var options interface{} = this.SafeValue(this.Options, "createOrder", map[string]interface{} {})
            var newOrderRespType interface{} = this.SafeValue(options, "newOrderRespType", map[string]interface{} {})
            // if limit order
            if IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(orderType, "LIMIT")) || IsTrue(IsEqual(orderType, "STOP_LOSS_LIMIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT_LIMIT"))) || IsTrue(IsEqual(orderType, "LIMIT_MAKER"))) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
                }
                newOrderRespType = this.SafeString(newOrderRespType, "limit", "FULL")
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
                if IsTrue(!IsEqual(orderType, "LIMIT_MAKER")) {
                    AddElementToObject(request, "timeInForce", this.SafeString(options, "timeInForce", "GTC"))
                }
            } else if IsTrue(IsTrue(IsTrue(IsEqual(orderType, "MARKET")) || IsTrue(IsEqual(orderType, "STOP_LOSS"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT"))) {
                newOrderRespType = this.SafeString(newOrderRespType, "market", "FULL")
                if IsTrue(IsEqual(orderSide, "SELL")) {
                    AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
                } else if IsTrue(IsEqual(orderSide, "BUY")) {
                    var quoteAmount interface{} = nil
                    var createMarketBuyOrderRequiresPrice interface{} = true
                    createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                    params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                    var cost interface{} = this.SafeNumber2(params, "cost", "quoteOrderQty")
                    params = this.Omit(params, "cost")
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsEqual(price, nil)) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var costRequest interface{} = Precise.StringMul(amountString, priceString)
                            quoteAmount = this.CostToPrecision(symbol, costRequest)
                        }
                    } else {
                        quoteAmount = this.CostToPrecision(symbol, amount)
                    }
                    AddElementToObject(request, "quoteOrderQty", quoteAmount)
                }
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(orderType, "STOP_LOSS")) || IsTrue(IsEqual(orderType, "STOP_LOSS_LIMIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT"))) || IsTrue(IsEqual(orderType, "TAKE_PROFIT_LIMIT"))) {
                var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
                if IsTrue(IsEqual(triggerPrice, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder () requires a triggerPrice or stopPrice param for stop_loss, take_profit, stop_loss_limit, and take_profit_limit orders")))
                }
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            AddElementToObject(request, "newOrderRespType", newOrderRespType)
            params = this.Omit(params, "price", "stopPrice", "triggerPrice", "quantity", "quoteOrderQty")
            var response interface{} = nil
            if IsTrue(testOrder) {
                
        response = (<-this.PrivatePostOpenapiV1OrderTest(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOpenapiV1Order(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "symbol": "ETHUSDT",
            //         "orderId": "1375407140139731486",
            //         "clientOrderId": "1375407140139733169",
            //         "transactTime": "1678697308023",
            //         "price": "1600",
            //         "origQty": "0.02",
            //         "executedQty": "0.02",
            //         "cummulativeQuoteQty": "31.9284",
            //         "status": "FILLED",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "side": "BUY",
            //         "stopPrice": "0",
            //         "origQuoteOrderQty": "0",
            //         "fills": [
            //             {
            //                 "price": "1596.42",
            //                 "qty": "0.02",
            //                 "commission": "0",
            //                 "commissionAsset": "ETH",
            //                 "tradeId": "1375407140281532417"
            //             }
            //         ]
            //     },
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://coins-docs.github.io/rest-api/#query-order-user_data
 * @param {int|string} id order id
 * @param {string} symbol not used by coinsph fetchOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13098 := (<-this.LoadMarkets())
            PanicOnError(retRes13098)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "origClientOrderId"})
        
            response:= (<-this.PrivateGetOpenapiV1Order(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://coins-docs.github.io/rest-api/#current-open-orders-user_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13348 := (<-this.LoadMarkets())
            PanicOnError(retRes13348)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetOpenapiV1OpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://coins-docs.github.io/rest-api/#history-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrders() requires a symbol argument")))
            }
        
            retRes13608 := (<-this.LoadMarkets())
            PanicOnError(retRes13608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
                // since work properly only when it is "younger" than last 'limit' order
                AddElementToObject(request, "limit", 1000)
            } else if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOpenapiV1HistoryOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#cancelOrder
 * @description cancels an open order
 * @see https://coins-docs.github.io/rest-api/#cancel-order-trade
 * @param {string} id order id
 * @param {string} symbol not used by coinsph cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13878 := (<-this.LoadMarkets())
            PanicOnError(retRes13878)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "origClientOrderId"})
        
            response:= (<-this.PrivateDeleteOpenapiV1Order(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#cancelAllOrders
 * @description cancel open orders of market
 * @see https://coins-docs.github.io/rest-api/#cancel-all-open-orders-on-a-symbol-trade
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinsph) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes14138 := (<-this.LoadMarkets())
            PanicOnError(retRes14138)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateDeleteOpenapiV1OpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder POST /openapi/v1/order
    //     {
    //         "symbol": "ETHUSDT",
    //         "orderId": 1375445991893797391,
    //         "clientOrderId": "1375445991893799115",
    //         "transactTime": 1678701939513,
    //         "price": "0",
    //         "origQty": "0",
    //         "executedQty": "0.001899",
    //         "cummulativeQuoteQty": "2.99948949",
    //         "status": "FILLED",
    //         "timeInForce": "GTC",
    //         "type": "MARKET",
    //         "side": "BUY",
    //         "stopPrice": "0",
    //         "origQuoteOrderQty": "3",
    //         "fills": [
    //             {
    //                 "price": "1579.51",
    //                 "qty": "0.001899",
    //                 "commission": "0",
    //                 "commissionAsset": "ETH",
    //                 "tradeId":1375445992035598337
    //             }
    //         ]
    //     }
    //
    // fetchOrder GET /openapi/v1/order
    // fetchOpenOrders GET /openapi/v1/openOrders
    // fetchClosedOrders GET /openapi/v1/historyOrders
    // cancelAllOrders DELETE /openapi/v1/openOrders
    //     {
    //         "symbol": "DOGEPHP",
    //         "orderId":1375465375097982423,
    //         "clientOrderId": "1375465375098001241",
    //         "price": "0",
    //         "origQty": "0",
    //         "executedQty": "13",
    //         "cummulativeQuoteQty": "49.621",
    //         "status": "FILLED",
    //         "timeInForce": "GTC",
    //         "type": "MARKET",
    //         "side": "BUY",
    //         "stopPrice": "0",
    //         "time":1678704250171,
    //         "updateTime":1678704250256,
    //         "isWorking":false,
    //         "origQuoteOrderQty": "50"
    //     }
    //
    // cancelOrder DELETE /openapi/v1/order
    //     {
    //         "symbol": "ETHPHP",
    //         "orderId":1375609441915774332,
    //         "clientOrderId": "1375609441915899557",
    //         "price": "96000",
    //         "origQty": "0.001",
    //         "executedQty": "0",
    //         "cummulativeQuoteQty": "0",
    //         "status": "CANCELED",
    //         "timeInForce": "GTC",
    //         "type": "LIMIT",
    //         "side": "SELL",
    //         "stopPrice": "0",
    //         "origQuoteOrderQty": "0"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "orderId")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger2(order, "time", "transactTime")
    var trades interface{} = this.SafeValue(order, "fills", nil)
    var triggerPrice interface{} = this.SafeString(order, "stopPrice")
    if IsTrue(Precise.StringEq(triggerPrice, "0")) {
        triggerPrice = nil
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "status")),
        "symbol": GetValue(market, "symbol"),
        "type": this.ParseOrderType(this.SafeString(order, "type")),
        "timeInForce": this.ParseOrderTimeInForce(this.SafeString(order, "timeInForce")),
        "side": this.ParseOrderSide(this.SafeString(order, "side")),
        "price": this.SafeString(order, "price"),
        "triggerPrice": triggerPrice,
        "average": nil,
        "amount": this.SafeString(order, "origQty"),
        "cost": this.SafeString(order, "cummulativeQuoteQty"),
        "filled": this.SafeString(order, "executedQty"),
        "remaining": nil,
        "fee": nil,
        "fees": nil,
        "trades": trades,
        "info": order,
    }, market)
}
func  (this *coinsph) ParseOrderSide(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "BUY": "buy",
        "SELL": "sell",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinsph) EncodeOrderSide(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "buy": "BUY",
        "sell": "SELL",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinsph) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "LIMIT_MAKER": "limit",
        "STOP_LOSS": "market",
        "STOP_LOSS_LIMIT": "limit",
        "TAKE_PROFIT": "market",
        "TAKE_PROFIT_LIMIT": "limit",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinsph) EncodeOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "market": "MARKET",
        "limit": "LIMIT",
        "limit_maker": "LIMIT_MAKER",
        "stop_loss": "STOP_LOSS",
        "stop_loss_limit": "STOP_LOSS_LIMIT",
        "take_profit": "TAKE_PROFIT",
        "take_profit_limit": "TAKE_PROFIT_LIMIT",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinsph) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "PARTIALLY_FILLED": "open",
        "PARTIALLY_CANCELED": "canceled",
        "REJECTED": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinsph) ParseOrderTimeInForce(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "GTC": "GTC",
        "FOK": "FOK",
        "IOC": "IOC",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinsph#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://coins-docs.github.io/rest-api/#trade-fee-user_data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *coinsph) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16008 := (<-this.LoadMarkets())
            PanicOnError(retRes16008)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetOpenapiV1AssetTradeFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //       {
            //         "symbol": "ETHUSDT",
            //         "makerCommission": "0.0025",
            //         "takerCommission": "0.003"
            //       }
            //     ]
            //
            var tradingFee interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParseTradingFee(tradingFee, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://coins-docs.github.io/rest-api/#trade-fee-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *coinsph) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16288 := (<-this.LoadMarkets())
            PanicOnError(retRes16288)
        
            response:= (<-this.PrivateGetOpenapiV1AssetTradeFee(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "symbol": "ETHPHP",
            //             "makerCommission": "0.0025",
            //             "takerCommission": "0.003"
            //         },
            //         {
            //             "symbol": "UNIPHP",
            //             "makerCommission": "0.0025",
            //             "takerCommission": "0.003"
            //         },
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var fee interface{} = this.ParseTradingFee(GetValue(response, i))
                var symbol interface{} = GetValue(fee, "symbol")
                AddElementToObject(result, symbol, fee)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ETHUSDT",
    //         "makerCommission": "0.0025",
    //         "takerCommission": "0.003"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "makerCommission"),
        "taker": this.SafeNumber(fee, "takerCommission"),
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name coinsph#withdraw
 * @description make a withdrawal to coins_ph account
 * @see https://coins-docs.github.io/rest-api/#withdrawuser_data
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address not used by coinsph withdraw ()
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinsph) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "withdraw")
            var warning interface{} = this.SafeBool(options, "warning", true)
            if IsTrue(warning) {
                panic(InvalidAddress(Add(this.Id, " withdraw() makes a withdrawals only to coins_ph account, add .options[\\'withdraw\\'][\\'warning\\'] = false to make a withdrawal to your coins_ph account")))
            }
            var networkCode interface{} = this.SafeString(params, "network")
            var networkId interface{} = this.NetworkCodeToId(networkCode, code)
            if IsTrue(IsEqual(networkId, nil)) {
                panic(BadRequest(Add(this.Id, " withdraw() require network parameter")))
            }
        
            retRes16978 := (<-this.LoadMarkets())
            PanicOnError(retRes16978)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "amount": this.NumberToString(amount),
                "network": networkId,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "withdrawOrderId", tag)
            }
            params = this.Omit(params, "network")
        
            response:= (<-this.PrivatePostOpenapiWalletV1WithdrawApply(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://coins-docs.github.io/rest-api/#deposit-history-user_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinsph) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // todo: returns an empty array - find out why
            code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17268 := (<-this.LoadMarkets())
            PanicOnError(retRes17268)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOpenapiWalletV1DepositHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //         "id": "d_769800519366885376",
            //         "amount": "0.001",
            //         "coin": "BNB",
            //         "network": "BNB",
            //         "status": 0,
            //         "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
            //         "addressTag": "101764890",
            //         "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
            //         "insertTime": 1661493146000,
            //         "confirmNo": 10,
            //     },
            //     {
            //         "id": "d_769754833590042625",
            //         "amount":"0.5",
            //         "coin":"IOTA",
            //         "network":"IOTA",
            //         "status":1,
            //         "address":"SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
            //         "addressTag":"",
            //         "txId":"ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
            //         "insertTime":1599620082000,
            //         "confirmNo": 20,
            //     }
            // ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinsph#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://coins-docs.github.io/rest-api/#withdraw-history-user_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinsph) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // todo: returns an empty array - find out why
            code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17848 := (<-this.LoadMarkets())
            PanicOnError(retRes17848)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOpenapiWalletV1WithdrawHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //         "id": "459890698271244288",
            //         "amount": "0.01",
            //         "transactionFee": "0",
            //         "coin": "ETH",
            //         "status": 1,
            //         "address": "0x386AE30AE2dA293987B5d51ddD03AEb70b21001F",
            //         "addressTag": "",
            //         "txId": "0x4ae2fed36a90aada978fc31c38488e8b60d7435cfe0b4daed842456b4771fcf7",
            //         "applyTime": 1673601139000,
            //         "network": "ETH",
            //         "withdrawOrderId": "thomas123",
            //         "info": "",
            //         "confirmNo": 100
            //     },
            //     {
            //         "id": "451899190746456064",
            //         "amount": "0.00063",
            //         "transactionFee": "0.00037",
            //         "coin": "ETH",
            //         "status": 1,
            //         "address": "0x386AE30AE2dA293987B5d51ddD03AEb70b21001F",
            //         "addressTag": "",
            //         "txId": "0x62690ca4f9d6a8868c258e2ce613805af614d9354dda7b39779c57b2e4da0260",
            //         "applyTime": 1671695815000,
            //         "network": "ETH",
            //         "withdrawOrderId": "",
            //         "info": "",
            //         "confirmNo": 100
            //     }
            // ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //     {
    //         "coin": "PHP",
    //         "address": "Internal Transfer",
    //         "addressTag": "Internal Transfer",
    //         "amount": "0.02",
    //         "id": "31312321312312312312322",
    //         "network": "Internal",
    //         "transferType": "0",
    //         "status": 3,
    //         "confirmTimes": "",
    //         "unlockConfirm": "",
    //         "txId": "Internal Transfer",
    //         "insertTime": 1657623798000,
    //         "depositOrderId": "the deposit id which created by client"
    //     }
    //
    // fetchWithdrawals
    //     {
    //         "coin": "BTC",
    //         "address": "Internal Transfer",
    //         "amount": "0.1",
    //         "id": "1201515362324421632",
    //         "withdrawOrderId": null,
    //         "network": "Internal",
    //         "transferType": "0",
    //         "status": 0,
    //         "transactionFee": "0",
    //         "confirmNo": 0,
    //         "info": "{}",
    //         "txId": "Internal Transfer",
    //         "applyTime": 1657967792000
    //     }
    //
    // todo: this is in progress
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "addressTag")
    if IsTrue(!IsEqual(tag, nil)) {
        if IsTrue(IsLessThan(GetLength(tag), 1)) {
            tag = nil
        }
    }
    var txid interface{} = this.SafeString(transaction, "txId")
    var currencyId interface{} = this.SafeString(transaction, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = nil
    timestamp = this.SafeInteger2(transaction, "insertTime", "applyTime")
    var updated interface{} = nil
    var typeVar interface{} = nil
    var withdrawOrderId interface{} = this.SafeString(transaction, "withdrawOrderId")
    var depositOrderId interface{} = this.SafeString(transaction, "depositOrderId")
    if IsTrue(!IsEqual(withdrawOrderId, nil)) {
        typeVar = "withdrawal"
    } else if IsTrue(!IsEqual(depositOrderId, nil)) {
        typeVar = "deposit"
    }
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var feeCost interface{} = this.SafeNumber(transaction, "transactionFee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    var network interface{} = this.SafeString(transaction, "network")
    var internal interface{} = IsEqual(network, "Internal")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": network,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": updated,
        "internal": internal,
        "comment": nil,
        "fee": fee,
    }
}
func  (this *coinsph) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "pending",
        "1": "ok",
        "2": "failed",
        "3": "pending",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinsph#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://coins-docs.github.io/rest-api/#deposit-address-user_data
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for fetch deposit address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinsph) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var networkCode interface{} = this.SafeString(params, "network")
            var networkId interface{} = this.NetworkCodeToId(networkCode, code)
            if IsTrue(IsEqual(networkId, nil)) {
                panic(BadRequest(Add(this.Id, " fetchDepositAddress() require network parameter")))
            }
        
            retRes19538 := (<-this.LoadMarkets())
            PanicOnError(retRes19538)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "network": networkId,
            }
            params = this.Omit(params, "network")
        
            response:= (<-this.PrivateGetOpenapiWalletV1DepositAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "coin": "ETH",
            //         "address": "0xfe98628173830bf79c59f04585ce41f7de168784",
            //         "addressTag": ""
            //     }
            //
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinsph) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "coin": "ETH",
    //         "address": "0xfe98628173830bf79c59f04585ce41f7de168784",
    //         "addressTag": ""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(depositAddress, "coin")
    var parsedCurrency interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": parsedCurrency,
        "network": nil,
        "address": this.SafeString(depositAddress, "address"),
        "tag": this.SafeString(depositAddress, "addressTag"),
    }
}
func  (this *coinsph) UrlEncodeQuery(optionalArgs ...interface{}) interface{}  {
    query := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = query
    var encodedArrayParams interface{} = ""
    var keys interface{} = ObjectKeys(query)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        if IsTrue(IsArray(GetValue(query, key))) {
            if IsTrue(!IsEqual(i, 0)) {
                encodedArrayParams = Add(encodedArrayParams, "&")
            }
            var innerArray interface{} = GetValue(query, key)
            query = this.Omit(query, key)
            var encodedArrayParam interface{} = this.ParseArrayParam(innerArray, key)
            encodedArrayParams = Add(encodedArrayParams, encodedArrayParam)
        }
    }
    var encodedQuery interface{} = this.Urlencode(query)
    if IsTrue(!IsEqual(GetArrayLength(encodedQuery), 0)) {
        return Add(Add(encodedQuery, "&"), encodedArrayParams)
    } else {
        return encodedArrayParams
    }
}
func  (this *coinsph) ParseArrayParam(array interface{}, key interface{}) interface{}  {
    var stringifiedArray interface{} = this.Json(array)
    stringifiedArray = Replace(stringifiedArray, "[", "%5B")
    stringifiedArray = Replace(stringifiedArray, "]", "%5D")
    var urlEncodedParam interface{} = Add(Add(key, "="), stringifiedArray)
    return urlEncodedParam
}
func  (this *coinsph) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var endpoint interface{} = this.ImplodeParams(path, params)
    url = Add(Add(url, "/"), endpoint)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        AddElementToObject(query, "timestamp", this.Milliseconds())
        var recvWindow interface{} = this.SafeInteger(query, "recvWindow")
        if IsTrue(IsEqual(recvWindow, nil)) {
            var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
            if IsTrue(!IsEqual(defaultRecvWindow, nil)) {
                AddElementToObject(query, "recvWindow", defaultRecvWindow)
            }
        }
        query = this.UrlEncodeQuery(query)
        var signature interface{} = this.Hmac(this.Encode(query), this.Encode(this.Secret), sha256)
        url = Add(Add(Add(Add(url, "?"), query), "&signature="), signature)
        headers = map[string]interface{} {
            "X-COINS-APIKEY": this.ApiKey,
        }
    } else {
        query = this.UrlEncodeQuery(query)
        if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
            url = Add(url, Add("?", query))
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinsph) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var responseCode interface{} = this.SafeString(response, "code", nil)
    if IsTrue(IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(responseCode, "200")))) && IsTrue((!IsEqual(responseCode, "0")))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinsph) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
