package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type AsterCore struct {
    Exchange

}

func NewAsterCore() *AsterCore {
    p := &AsterCore{}
    setDefaults(p)
    return p
}

func  (this *AsterCore) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "aster",
        "name": "Aster",
        "dex": true,
        "countries": []interface{}{"US"},
        "rateLimit": 333,
        "hostname": "aster.markets",
        "pro": true,
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/4982201b-73cd-4d7a-8907-e69e239e9609",
            "www": "https://www.asterdex.com/en",
            "api": map[string]interface{} {
                "fapiPublic": "https://fapi.asterdex.com/fapi",
                "fapiPrivate": "https://fapi.asterdex.com/fapi",
                "sapiPublic": "https://sapi.asterdex.com/api",
                "sapiPrivate": "https://sapi.asterdex.com/api",
            },
            "doc": "https://github.com/asterdex/api-docs",
            "fees": "https://docs.asterdex.com/product/asterex-simple/fees-and-slippage",
            "referral": map[string]interface{} {
                "url": "https://www.asterdex.com/en/referral/aA1c2B",
                "discount": 0.1,
            },
        },
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": true,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createLimitBuyOrder": false,
            "createLimitSellOrder": false,
            "createMarketBuyOrder": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrder": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": false,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopLossOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": false,
            "editOrder": false,
            "editOrders": false,
            "fetchAccounts": nil,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledAndClosedOrders": "emulated",
            "fetchCanceledOrders": "emulated",
            "fetchClosedOrder": false,
            "fetchClosedOrders": "emulated",
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingInterval": "emulated",
            "fetchFundingIntervals": true,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": "emulated",
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": false,
            "fetchLastPrices": false,
            "fetchLedger": true,
            "fetchLedgerEntry": false,
            "fetchLeverage": "emulated",
            "fetchLeverages": true,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchLongShortRatio": false,
            "fetchLongShortRatioHistory": false,
            "fetchMarginAdjustmentHistory": true,
            "fetchMarginMode": "emulated",
            "fetchMarginModes": true,
            "fetchMarketLeverageTiers": "emulated",
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrice": false,
            "fetchMarkPrices": false,
            "fetchMyLiquidations": false,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": true,
            "fetchOpenOrders": true,
            "fetchOption": false,
            "fetchOptionChain": false,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": true,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": true,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTradingLimits": "emulated",
            "fetchTransactionFee": "emulated",
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawAddresses": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": true,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": false,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": true,
            "setPositionMode": true,
            "signIn": false,
            "transfer": true,
            "withdraw": true,
        },
        "api": map[string]interface{} {
            "fapiPublic": map[string]interface{} {
                "get": []interface{}{"v1/ping", "v1/time", "v1/exchangeInfo", "v1/depth", "v1/trades", "v1/historicalTrades", "v1/aggTrades", "v1/klines", "v1/indexPriceKlines", "v1/markPriceKlines", "v1/premiumIndex", "v1/fundingRate", "v1/fundingInfo", "v1/ticker/24hr", "v1/ticker/price", "v1/ticker/bookTicker", "v1/adlQuantile", "v1/forceOrders"},
                "post": []interface{}{"v1/listenKey"},
                "put": []interface{}{"v1/listenKey"},
                "delete": []interface{}{"v1/listenKey"},
            },
            "fapiPrivate": map[string]interface{} {
                "get": []interface{}{"v1/positionSide/dual", "v1/multiAssetsMargin", "v1/order", "v1/openOrder", "v1/openOrders", "v1/allOrders", "v2/balance", "v3/balance", "v3/account", "v4/account", "v1/positionMargin/history", "v2/positionRisk", "v3/positionRisk", "v1/userTrades", "v1/income", "v1/leverageBracket", "v1/commissionRate"},
                "post": []interface{}{"v1/positionSide/dual", "v1/multiAssetsMargin", "v1/order", "v1/order/test", "v1/batchOrders", "v1/asset/wallet/transfer", "v1/countdownCancelAll", "v1/leverage", "v1/marginType", "v1/positionMargin"},
                "delete": []interface{}{"v1/order", "v1/allOpenOrders", "v1/batchOrders"},
            },
            "sapiPublic": map[string]interface{} {
                "get": []interface{}{"v1/ping", "v1/time", "v1/exchangeInfo", "v1/depth", "v1/trades", "v1/historicalTrades", "v1/aggTrades", "v1/klines", "v1/ticker/24hr", "v1/ticker/price", "v1/ticker/bookTicker", "v1/aster/withdraw/estimateFee"},
                "post": []interface{}{"v1/getNonce", "v1/createApiKey", "v1/listenKey"},
                "put": []interface{}{"v1/listenKey"},
                "delete": []interface{}{"v1/listenKey"},
            },
            "sapiPrivate": map[string]interface{} {
                "get": []interface{}{"v1/commissionRate", "v1/order", "v1/openOrders", "v1/allOrders", "v1/transactionHistory", "v1/account", "v1/userTrades"},
                "post": []interface{}{"v1/order", "v1/asset/wallet/transfer", "v1/asset/sendToAddress", "v1/aster/user-withdraw"},
                "delete": []interface{}{"v1/order", "v1/allOpenOrders"},
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "8h": "8h",
            "12h": "12h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1M",
        },
        "precisionMode": TICK_SIZE,
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0001"),
                "taker": this.ParseNumber("0.00035"),
            },
        },
        "options": map[string]interface{} {
            "recvWindow": Multiply(10, 1000),
            "defaultTimeInForce": "GTC",
            "zeroAddress": "0x0000000000000000000000000000000000000000",
            "quoteOrderQty": true,
            "accountsByType": map[string]interface{} {
                "spot": "SPOT",
                "future": "FUTURE",
                "linear": "FUTURE",
                "swap": "FUTURE",
            },
            "networks": map[string]interface{} {
                "ERC20": "ETH",
                "BEP20": "BSC",
                "ARB": "Arbitrum",
            },
            "networksToChainId": map[string]interface{} {
                "ETH": 1,
                "BSC": 56,
                "Arbitrum": 42161,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1000": OperationFailed,
                "-1001": NetworkError,
                "-1002": AuthenticationError,
                "-1003": RateLimitExceeded,
                "-1004": DuplicateOrderId,
                "-1005": BadRequest,
                "-1006": BadResponse,
                "-1007": RequestTimeout,
                "-1010": OperationFailed,
                "-1011": PermissionDenied,
                "-1013": BadRequest,
                "-1014": OrderNotFillable,
                "-1015": RateLimitExceeded,
                "-1016": ExchangeClosedByUser,
                "-1020": NotSupported,
                "-1021": InvalidNonce,
                "-1022": AuthenticationError,
                "-1023": BadRequest,
                "-1100": BadRequest,
                "-1101": BadRequest,
                "-1102": ArgumentsRequired,
                "-1103": BadRequest,
                "-1104": BadRequest,
                "-1105": ArgumentsRequired,
                "-1106": BadRequest,
                "-1108": BadRequest,
                "-1109": BadRequest,
                "-1110": BadSymbol,
                "-1111": BadRequest,
                "-1112": BadRequest,
                "-1113": BadRequest,
                "-1114": BadRequest,
                "-1115": InvalidOrder,
                "-1116": InvalidOrder,
                "-1117": InvalidOrder,
                "-1118": InvalidOrder,
                "-1119": InvalidOrder,
                "-1120": BadRequest,
                "-1121": BadSymbol,
                "-1125": AuthenticationError,
                "-1127": BadRequest,
                "-1128": BadRequest,
                "-1130": BadRequest,
                "-1136": InvalidOrder,
                "-2010": InvalidOrder,
                "-2011": OrderNotFound,
                "-2013": OrderNotFound,
                "-2014": AuthenticationError,
                "-2015": AuthenticationError,
                "-2016": MarketClosed,
                "-2018": InsufficientFunds,
                "-2019": InsufficientFunds,
                "-2020": OrderNotFillable,
                "-2021": OrderImmediatelyFillable,
                "-2022": OperationRejected,
                "-2023": AccountSuspended,
                "-2024": InsufficientFunds,
                "-2025": RateLimitExceeded,
                "-2026": NotSupported,
                "-2027": BadRequest,
                "-2028": BadRequest,
                "-4000": InvalidOrder,
                "-4001": InvalidOrder,
                "-4002": InvalidOrder,
                "-4003": InvalidOrder,
                "-4004": InvalidOrder,
                "-4005": InvalidOrder,
                "-4006": InvalidOrder,
                "-4007": InvalidOrder,
                "-4008": InvalidOrder,
                "-4009": InvalidOrder,
                "-4010": InvalidOrder,
                "-4011": InvalidOrder,
                "-4012": RateLimitExceeded,
                "-4013": InvalidOrder,
                "-4014": InvalidOrder,
                "-4015": InvalidOrder,
                "-4016": InvalidOrder,
                "-4017": InvalidOrder,
                "-4018": InvalidOrder,
                "-4019": BadRequest,
                "-4020": BadRequest,
                "-4021": BadRequest,
                "-4022": MarketClosed,
                "-4023": InvalidOrder,
                "-4024": InvalidOrder,
                "-4025": BadRequest,
                "-4026": BadRequest,
                "-4027": BadRequest,
                "-4028": BadRequest,
                "-4029": BadRequest,
                "-4030": BadRequest,
                "-4031": BadRequest,
                "-4032": RateLimitExceeded,
                "-4033": AccountNotEnabled,
                "-4044": BadRequest,
                "-4045": RateLimitExceeded,
                "-4046": NoChange,
                "-4047": OperationRejected,
                "-4048": OperationRejected,
                "-4049": OperationRejected,
                "-4050": InsufficientFunds,
                "-4051": InsufficientFunds,
                "-4052": NoChange,
                "-4053": OperationRejected,
                "-4054": OperationRejected,
                "-4055": ArgumentsRequired,
                "-4056": AuthenticationError,
                "-4057": AuthenticationError,
                "-4058": InvalidOrder,
                "-4059": NoChange,
                "-4060": InvalidOrder,
                "-4061": InvalidOrder,
                "-4062": OperationRejected,
                "-4063": BadRequest,
                "-4064": BadRequest,
                "-4065": BadRequest,
                "-4066": BadRequest,
                "-4067": OperationRejected,
                "-4068": OperationRejected,
                "-4069": BadRequest,
                "-4070": InvalidOrder,
                "-4071": InvalidOrder,
                "-4072": NoChange,
                "-4073": BadRequest,
                "-4074": InvalidOrder,
                "-4075": OperationRejected,
                "-4076": OperationRejected,
                "-4077": RateLimitExceeded,
                "-4078": BadRequest,
                "-4079": BadRequest,
                "-4080": BadRequest,
                "-4081": BadRequest,
                "-4082": RateLimitExceeded,
                "-4083": OperationFailed,
                "-4084": NotSupported,
                "-4085": BadRequest,
                "-4086": BadRequest,
                "-4087": PermissionDenied,
                "-4088": PermissionDenied,
                "-4104": BadSymbol,
                "-4114": InvalidOrder,
                "-4115": DuplicateOrderId,
                "-4118": InsufficientFunds,
                "-4131": InvalidOrder,
                "-4135": InvalidOrder,
                "-4137": InvalidOrder,
                "-4138": OperationRejected,
                "-4139": InvalidOrder,
                "-4140": OperationRejected,
                "-4141": MarketClosed,
                "-4142": InvalidOrder,
                "-4144": BadSymbol,
                "-4161": OperationRejected,
                "-4164": InvalidOrder,
                "-4165": BadRequest,
                "-4183": InvalidOrder,
                "-4184": InvalidOrder,
                "-5060": OperationRejected,
                "-5076": OperationRejected,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *AsterCore) IsInverse(typeVar interface{}, optionalArgs ...interface{}) interface{}  {
    subType := GetArg(optionalArgs, 0, nil)
    _ = subType
    if IsTrue(IsEqual(subType, nil)) {
        return (IsEqual(typeVar, "delivery"))
    } else {
        return IsEqual(subType, "inverse")
    }
}
func  (this *AsterCore) IsLinear(typeVar interface{}, optionalArgs ...interface{}) interface{}  {
    subType := GetArg(optionalArgs, 0, nil)
    _ = subType
    if IsTrue(IsEqual(subType, nil)) {
        return IsTrue((IsEqual(typeVar, "future"))) || IsTrue((IsEqual(typeVar, "swap")))
    } else {
        return IsEqual(subType, "linear")
    }
}
/**
 * @method
 * @name aster#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#trading-specification-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *AsterCore) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promises interface{} = []interface{}{this.SapiPublicGetV1ExchangeInfo(params), this.FapiPublicGetV1ExchangeInfo(params)}
        
            results:= (<-promiseAll(promises))
            PanicOnError(results)
            var sapiResult interface{} = this.SafeDict(results, 0, map[string]interface{} {})
            var sapiRows interface{} = this.SafeList(sapiResult, "assets", []interface{}{})
            var fapiResult interface{} = this.SafeDict(results, 1, map[string]interface{} {})
            var fapiRows interface{} = this.SafeList(fapiResult, "assets", []interface{}{})
            var rows interface{} = this.ArrayConcat(sapiRows, fapiRows)
            //
            //     [
            //         {
            //             "asset": "USDT",
            //             "marginAvailable": true,
            //             "autoAssetExchange": "-10000"
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var currency interface{} = GetValue(rows, i)
                var currencyId interface{} = this.SafeString(currency, "asset")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "info": currency,
            "code": code,
            "id": currencyId,
            "name": code,
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": nil,
            "type": "crypto",
        }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchMarkets
 * @description retrieves data on all markets for bigone
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#trading-specification-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *AsterCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promises interface{} = []interface{}{this.SapiPublicGetV1ExchangeInfo(params), this.FapiPublicGetV1ExchangeInfo(params)}
        
            results:= (<-promiseAll(promises))
            PanicOnError(results)
            var sapiResult interface{} = this.SafeDict(results, 0, map[string]interface{} {})
            var sapiRows interface{} = this.SafeList(sapiResult, "symbols", []interface{}{})
            var fapiResult interface{} = this.SafeDict(results, 1, map[string]interface{} {})
            var fapiRows interface{} = this.SafeList(fapiResult, "symbols", []interface{}{})
            var rows interface{} = this.ArrayConcat(sapiRows, fapiRows)
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "pair": "BTCUSDT",
            //             "contractType": "PERPETUAL",
            //             "deliveryDate": 4133404800000,
            //             "onboardDate": 1627628400000,
            //             "status": "TRADING",
            //             "maintMarginPercent": "2.5000",
            //             "requiredMarginPercent": "5.0000",
            //             "baseAsset": "BTC",
            //             "quoteAsset": "USDT",
            //             "marginAsset": "USDT",
            //             "pricePrecision": 1,
            //             "quantityPrecision": 3,
            //             "baseAssetPrecision": 8,
            //             "quotePrecision": 8,
            //             "underlyingType": "COIN",
            //             "underlyingSubType": [],
            //             "settlePlan": 0,
            //             "triggerProtect": "0.0200",
            //             "liquidationFee": "0.025000",
            //             "marketTakeBound": "0.02",
            //             "filters": [
            //                 {
            //                     "minPrice": "1",
            //                     "maxPrice": "1000000",
            //                     "filterType": "PRICE_FILTER",
            //                     "tickSize": "0.1"
            //                 },
            //                 {
            //                     "stepSize": "0.001",
            //                     "filterType": "LOT_SIZE",
            //                     "maxQty": "100",
            //                     "minQty": "0.001"
            //                 },
            //                 {
            //                     "stepSize": "0.001",
            //                     "filterType": "MARKET_LOT_SIZE",
            //                     "maxQty": "10",
            //                     "minQty": "0.001"
            //                 },
            //                 {
            //                     "limit": 200,
            //                     "filterType": "MAX_NUM_ORDERS"
            //                 },
            //                 {
            //                     "limit": 10,
            //                     "filterType": "MAX_NUM_ALGO_ORDERS"
            //                 },
            //                 {
            //                     "notional": "5",
            //                     "filterType": "MIN_NOTIONAL"
            //                 },
            //                 {
            //                     "multiplierDown": "0.9800",
            //                     "multiplierUp": "1.0200",
            //                     "multiplierDecimal": "4",
            //                     "filterType": "PERCENT_PRICE"
            //                 }
            //             ],
            //             "orderTypes": [
            //                 "LIMIT",
            //                 "MARKET",
            //                 "STOP",
            //                 "STOP_MARKET",
            //                 "TAKE_PROFIT",
            //                 "TAKE_PROFIT_MARKET",
            //                 "TRAILING_STOP_MARKET"
            //             ],
            //             "timeInForce": [
            //                 "GTC",
            //                 "IOC",
            //                 "FOK",
            //                 "GTX",
            //                 "RPI"
            //             ]
            //         }
            //     ]
            //
            var fees interface{} = this.Fees
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var swap interface{} = false
                var market interface{} = GetValue(rows, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseAsset")
                var quoteId interface{} = this.SafeString(market, "quoteAsset")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var contractType interface{} = this.SafeString(market, "contractType")
                var contract interface{} = !IsEqual(contractType, nil)
                var spot interface{} = true
                if IsTrue(IsEqual(contractType, "PERPETUAL")) {
                    swap = true
                    spot = false
                }
                var contractSize interface{} = nil
                var linear interface{} = nil
                var inverse interface{} = nil
                var symbol interface{} = Add(Add(base, "/"), quote)
                var settle interface{} = nil
                var settleId interface{} = nil
                if IsTrue(contract) {
                    settleId = this.SafeString(market, "marginAsset")
                    settle = this.SafeCurrencyCode(settleId)
                    if IsTrue(swap) {
                        symbol = Add(Add(symbol, ":"), settle)
                    }
                    linear = IsEqual(settle, quote)
                    inverse = IsEqual(settle, base)
                    contractSize = this.SafeNumber2(market, "contractSize", "unit", this.ParseNumber("1"))
                }
                var unifiedType interface{} = nil
                if IsTrue(spot) {
                    unifiedType = "spot"
                } else if IsTrue(swap) {
                    unifiedType = "swap"
                }
                var status interface{} = this.SafeString(market, "status")
                var active interface{} = IsEqual(status, "TRADING")
                var filters interface{} = this.SafeList(market, "filters", []interface{}{})
                var filtersByType interface{} = this.IndexBy(filters, "filterType")
                var entry interface{} = this.SafeMarketStructure(map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": unifiedType,
                    "spot": spot,
                    "margin": false,
                    "swap": swap,
                    "future": false,
                    "option": false,
                    "active": active,
                    "contract": contract,
                    "linear": linear,
                    "inverse": inverse,
                    "taker": GetValue(GetValue(fees, "trading"), "taker"),
                    "maker": GetValue(GetValue(fees, "trading"), "maker"),
                    "contractSize": contractSize,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision"))),
                        "base": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetPrecision"))),
                        "quote": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quotePrecision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": this.SafeInteger(market, "onboardDate"),
                    "info": market,
                })
                if IsTrue(InOp(filtersByType, "PRICE_FILTER")) {
                    var filter interface{} = this.SafeDict(filtersByType, "PRICE_FILTER", map[string]interface{} {})
                    AddElementToObject(GetValue(entry, "limits"), "price", map[string]interface{} {
            "min": this.SafeNumber(filter, "minPrice"),
            "max": this.SafeNumber(filter, "maxPrice"),
        })
                    AddElementToObject(GetValue(entry, "precision"), "price", this.SafeNumber(filter, "tickSize"))
                }
                if IsTrue(InOp(filtersByType, "LOT_SIZE")) {
                    var filter interface{} = this.SafeDict(filtersByType, "LOT_SIZE", map[string]interface{} {})
                    AddElementToObject(GetValue(entry, "precision"), "amount", this.SafeNumber(filter, "stepSize"))
                    AddElementToObject(GetValue(entry, "limits"), "amount", map[string]interface{} {
            "min": this.SafeNumber(filter, "minQty"),
            "max": this.SafeNumber(filter, "maxQty"),
        })
                }
                if IsTrue(InOp(filtersByType, "MARKET_LOT_SIZE")) {
                    var filter interface{} = this.SafeDict(filtersByType, "MARKET_LOT_SIZE", map[string]interface{} {})
                    AddElementToObject(GetValue(entry, "limits"), "market", map[string]interface{} {
            "min": this.SafeNumber(filter, "minQty"),
            "max": this.SafeNumber(filter, "maxQty"),
        })
                }
                if IsTrue(IsTrue((InOp(filtersByType, "MIN_NOTIONAL"))) || IsTrue((InOp(filtersByType, "NOTIONAL")))) {
                    var filter interface{} = this.SafeDict2(filtersByType, "MIN_NOTIONAL", "NOTIONAL", map[string]interface{} {})
                    AddElementToObject(GetValue(GetValue(entry, "limits"), "cost"), "min", this.SafeNumber(filter, "notional"))
                }
                AppendToArray(&result, entry)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *AsterCore) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FapiPublicGetV1Time(params))
            PanicOnError(response)
        
                //
            //     {
            //         "serverTime": 1499827319559
            //     }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1631158560000,
    //         "208.1850",
    //         "208.1850",
    //         "208.1850",
    //         "208.1850",
    //         "11.84",
    //         1631158619999,
    //         "2464.910400",
    //         1,
    //         "11.84",
    //         "2464.910400",
    //         "0"
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name aster#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.price] "mark" or "index" for mark price and index price candles
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOHLCV() requires a symbol argument")))
            }
        
            retRes9098 := (<-this.LoadMarkets())
            PanicOnError(retRes9098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1500)) {
                    limit = 1500 // Default 500; max 1500.
                }
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            AddElementToObject(request, "interval", this.SafeString(this.Timeframes, timeframe, timeframe))
            var price interface{} = this.SafeString(params, "price")
            var isMark interface{} =     (IsEqual(price, "mark"))
            var isIndex interface{} =     (IsEqual(price, "index"))
            params = this.Omit(params, "price")
            var response interface{} = nil
            if IsTrue(isMark) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
            response = (<-this.FapiPublicGetV1MarkPriceKlines(this.Extend(request, params)))
                    PanicOnError(response)
            } else if IsTrue(isIndex) {
                AddElementToObject(request, "pair", GetValue(market, "id"))
                
            response = (<-this.FapiPublicGetV1IndexPriceKlines(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                if IsTrue(GetValue(market, "linear")) {
                    
            response = (<-this.FapiPublicGetV1Klines(this.Extend(request, params)))
                        PanicOnError(response)
                } else {
                    
            response = (<-this.SapiPublicGetV1Klines(this.Extend(request, params)))
                        PanicOnError(response)
                }
            }
        
                //
            //     [
            //         [
            //             1631158560000,
            //             "208.1850",
            //             "208.1850",
            //             "208.1850",
            //             "208.1850",
            //             "11.84",
            //             1631158619999,
            //             "2464.910400",
            //             1,
            //             "11.84",
            //             "2464.910400",
            //             "0"
            //         ]
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //     {
    //         "id": 3913206,
    //         "price": "644.100",
    //         "qty": "0.08",
    //         "quoteQty": "51.528",
    //         "time": 1749784506633,
    //         "isBuyerMaker": true
    //     }
    //
    //     {
    //         "id": 657,
    //         "price": "1.01000000",
    //         "qty": "5.00000000",
    //         "baseQty": "4.95049505",
    //         "time": 1755156533943,
    //         "isBuyerMaker": false
    //     }
    //
    // fetchMyTrades
    //
    //     {
    //         "buyer": false,
    //         "commission": "-0.07819010",
    //         "commissionAsset": "USDT",
    //         "id": 698759,
    //         "maker": false,
    //         "orderId": 25851813,
    //         "price": "7819.01",
    //         "qty": "0.002",
    //         "quoteQty": "15.63802",
    //         "realizedPnl": "-0.91539999",
    //         "side": "SELL",
    //         "positionSide": "SHORT",
    //         "symbol": "BTCUSDT",
    //         "time": 1569514978020
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "id")
    var symbol interface{} = GetValue(market, "symbol")
    var currencyId interface{} = this.SafeString(trade, "commissionAsset")
    var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
    var amountString interface{} = this.SafeString(trade, "qty")
    var priceString interface{} = this.SafeString(trade, "price")
    var costString interface{} = this.SafeString2(trade, "quoteQty", "baseQty")
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var side interface{} = this.SafeStringLower(trade, "side")
    var isMaker interface{} = this.SafeBool(trade, "maker")
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(isMaker, nil)) {
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    var isBuyerMaker interface{} = this.SafeBool(trade, "isBuyerMaker")
    if IsTrue(!IsEqual(isBuyerMaker, nil)) {
        side = Ternary(IsTrue(isBuyerMaker), "sell", "buy")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": this.SafeString(trade, "orderId"),
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": map[string]interface{} {
            "cost": this.ParseNumber(Precise.StringAbs(this.SafeString(trade, "commission"))),
            "currency": currencyCode,
        },
    }, market)
}
/**
 * @method
 * @name aster#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#recent-trades-list
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#recent-trades-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *AsterCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires a symbol argument")))
            }
        
            retRes10588 := (<-this.LoadMarkets())
            PanicOnError(retRes10588)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000 // Default 500; max 1000.
                }
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPublicGetV1Trades(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPublicGetV1Trades(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#account-trade-history-user_data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#account-trade-list-user_data
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is undefined
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *AsterCore) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes11178 := (<-this.LoadMarkets())
            PanicOnError(retRes11178)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000 // Default 500; max 1000.
                }
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateGetV1UserTrades(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateGetV1UserTrades(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
                //
            //     [
            //         {
            //             "buyer": false,
            //             "commission": "-0.07819010",
            //             "commissionAsset": "USDT",
            //             "id": 698759,
            //             "maker": false,
            //             "orderId": 25851813,
            //             "price": "7819.01",
            //             "qty": "0.002",
            //             "quoteQty": "15.63802",
            //             "realizedPnl": "-0.91539999",
            //             "side": "SELL",
            //             "positionSide": "SHORT",
            //             "symbol": "BTCUSDT",
            //             "time": 1569514978020
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrderBook() requires a symbol argument")))
            }
        
            retRes11768 := (<-this.LoadMarkets())
            PanicOnError(retRes11768)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                // limit: [5, 10, 20, 50, 100, 500, 1000]. Default: 500
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000 // Default 500; max 1000.
                }
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPublicGetV1Depth(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPublicGetV1Depth(this.Extend(request, params)))
                    PanicOnError(response)
            }
            //
            //     {
            //         "lastUpdateId": 1027024,
            //         "E": 1589436922972, //     Message output time
            //         "T": 1589436922959, //     Transaction time
            //         "bids": [
            //             [
            //                 "4.00000000", //     PRICE
            //                 "431.00000000" //     QTY
            //             ]
            //         ],
            //         "asks": [
            //             [
            //                 "4.00000200",
            //                 "12.00000000"
            //             ]
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "T")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "bids", "asks")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *AsterCore) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12308 := (<-this.LoadMarkets())
            PanicOnError(retRes12308)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000 // Default 100; max 1000
                }
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.FapiPublicGetV1FundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "fundingTime": 1747209600000,
            //             "fundingRate": "0.00010000"
            //         }
            //     ]
            //
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var timestamp interface{} = this.SafeInteger(entry, "fundingTime")
                AppendToArray(&rates, map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(this.SafeString(entry, "symbol"), nil, nil, "swap"),
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         "symbol": "BTCUSDT",
    //         "priceChange": "-2274.38",
    //         "priceChangePercent": "-2.049",
    //         "weightedAvgPrice": "109524.37084136",
    //         "lastPrice": "108738.78",
    //         "lastQty": "0.00034",
    //         "openPrice": "111013.16",
    //         "highPrice": "111975.81",
    //         "lowPrice": "107459.25",
    //         "volume": "28.67876",
    //         "quoteVolume": "3141023.14551030",
    //         "openTime": "1760578800000",
    //         "closeTime": "1760665024749",
    //         "firstId": "37447",
    //         "lastId": "39698",
    //         "count": "2252",
    //         "baseAsset": "BTC",
    //         "quoteAsset": "USDT",
    //         "bidPrice": "108705.11",
    //         "bidQty": "0.03351",
    //         "askPrice": "108725.99",
    //         "askQty": "0.08724"
    //     }
    // swap
    //     {
    //         "symbol": "BTCUSDT",
    //         "priceChange": "1845.7",
    //         "priceChangePercent": "1.755",
    //         "weightedAvgPrice": "105515.5",
    //         "lastPrice": "107037.7",
    //         "lastQty": "0.004",
    //         "openPrice": "105192.0",
    //         "highPrice": "107223.5",
    //         "lowPrice": "104431.6",
    //         "volume": "8753.286",
    //         "quoteVolume": "923607368.61",
    //         "openTime": 1749976620000,
    //         "closeTime": 1750063053754,
    //         "firstId": 24195078,
    //         "lastId": 24375783,
    //         "count": 180706
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "closeTime")
    var marketType interface{} = nil
    if IsTrue(InOp(ticker, "bidQty")) {
        marketType = "spot"
    } else {
        marketType = "contract"
    }
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market, nil, marketType)
    var symbol interface{} = GetValue(market, "symbol")
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var open interface{} = this.SafeString(ticker, "openPrice")
    var percentage interface{} = this.SafeString(ticker, "priceChangePercent")
    percentage = Precise.StringMul(percentage, "100")
    var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var high interface{} = this.SafeString(ticker, "highPrice")
    var low interface{} = this.SafeString(ticker, "lowPrice")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": this.SafeString(ticker, "bidPrice"),
        "bidVolume": this.SafeString(ticker, "bidQty"),
        "ask": this.SafeString(ticker, "askPrice"),
        "askVolume": this.SafeString(ticker, "askQty"),
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "markPrice": nil,
        "indexPrice": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name aster#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#24h-price-change
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTicker() requires a symbol argument")))
            }
        
            retRes13778 := (<-this.LoadMarkets())
            PanicOnError(retRes13778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPublicGetV1Ticker24hr(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPublicGetV1Ticker24hr(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#24h-price-change
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
 * @param {string[]} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] "linear" or "inverse"
 * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
 * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14488 := (<-this.LoadMarkets())
            PanicOnError(retRes14488)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchTickers", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(this.IsLinear(typeVar, subType)) {
                
            response = (<-this.FapiPublicGetV1Ticker24hr(params))
                    PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "spot")) {
                
            response = (<-this.SapiPublicGetV1Ticker24hr(params))
                    PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTickers() does not support "), typeVar), " markets yet")))
            }
        
                //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "priceChange": "1845.7",
            //             "priceChangePercent": "1.755",
            //             "weightedAvgPrice": "105515.5",
            //             "lastPrice": "107037.7",
            //             "lastQty": "0.004",
            //             "openPrice": "105192.0",
            //             "highPrice": "107223.5",
            //             "lowPrice": "104431.6",
            //             "volume": "8753.286",
            //             "quoteVolume": "923607368.61",
            //             "openTime": 1749976620000,
            //             "closeTime": 1750063053754,
            //             "firstId": 24195078,
            //             "lastId": 24375783,
            //             "count": 180706
            //         }
            //     ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "markPrice": "106729.84047826",
    //         "indexPrice": "106775.72673913",
    //         "estimatedSettlePrice": "106708.84997006",
    //         "lastFundingRate": "0.00010000",
    //         "interestRate": "0.00010000",
    //         "nextFundingTime": 1750147200000,
    //         "time": 1750146970000
    //     }
    //     {
    //         "symbol": "INJUSDT",
    //         "interestRate": "0.00010000",
    //         "time": 1756197479000,
    //         "fundingIntervalHours": 8,
    //         "fundingFeeCap": 0.03,
    //         "fundingFeeFloor": -0.03
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
    var timestamp interface{} = this.SafeInteger(contract, "time")
    var interval interface{} = this.SafeString(contract, "fundingIntervalHours")
    var intervalString interface{} = nil
    if IsTrue(!IsEqual(interval, nil)) {
        intervalString = Add(interval, "h")
    }
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
        "markPrice": this.SafeNumber(contract, "markPrice"),
        "indexPrice": this.SafeNumber(contract, "indexPrice"),
        "interestRate": this.SafeNumber(contract, "interestRate"),
        "estimatedSettlePrice": this.SafeNumber(contract, "estimatedSettlePrice"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fundingRate": this.SafeNumber(contract, "lastFundingRate"),
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nextFundingTimestamp,
        "nextFundingDatetime": this.Iso8601(nextFundingTimestamp),
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": intervalString,
    }
}
/**
 * @method
 * @name aster#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *AsterCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRate() requires a symbol argument")))
            }
        
            retRes15528 := (<-this.LoadMarkets())
            PanicOnError(retRes15528)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.FapiPublicGetV1PremiumIndex(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "symbol": "BTCUSDT",
            //         "markPrice": "106729.84047826",
            //         "indexPrice": "106775.72673913",
            //         "estimatedSettlePrice": "106708.84997006",
            //         "lastFundingRate": "0.00010000",
            //         "interestRate": "0.00010000",
            //         "nextFundingTime": 1750147200000,
            //         "time": 1750146970000
            //     }
            //
        ch <- this.ParseFundingRate(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchFundingRates
 * @description fetch the current funding rate for multiple symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *AsterCore) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15838 := (<-this.LoadMarkets())
            PanicOnError(retRes15838)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.FapiPublicGetV1PremiumIndex(this.Extend(params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "markPrice": "106729.84047826",
            //             "indexPrice": "106775.72673913",
            //             "estimatedSettlePrice": "106708.84997006",
            //             "lastFundingRate": "0.00010000",
            //             "interestRate": "0.00010000",
            //             "nextFundingTime": 1750147200000,
            //             "time": 1750146970000
            //         }
            //     ]
            //
        ch <- this.ParseFundingRates(response, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchFundingIntervals
 * @description fetch the funding rate interval for multiple markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-funding-rate-config
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *AsterCore) FetchFundingIntervals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16138 := (<-this.LoadMarkets())
            PanicOnError(retRes16138)
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
            }
        
            response:= (<-this.FapiPublicGetV1FundingInfo(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "INJUSDT",
            //             "interestRate": "0.00010000",
            //             "time": 1756197479000,
            //             "fundingIntervalHours": 8,
            //             "fundingFeeCap": 0.03,
            //             "fundingFeeFloor": -0.03
            //         }
            //     ]
            //
        ch <- this.ParseFundingRates(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString2(balance, "free", "maxWithdrawAmount"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(account, "total", this.SafeString(balance, "walletBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name aster#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#account-information-v4-user_data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#account-information-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] "linear" or "inverse"
 * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *AsterCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchBalance", nil, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            var data interface{} = nil
            if IsTrue(this.IsLinear(typeVar, subType)) {
                
            response = (<-this.FapiPrivateGetV4Account(params))
                    PanicOnError(response)
                data = this.SafeList(response, "assets", []interface{}{})
            } else if IsTrue(IsEqual(typeVar, "spot")) {
                
            response = (<-this.SapiPrivateGetV1Account(params))
                    PanicOnError(response)
                data = this.SafeList(response, "balances", []interface{}{})
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchBalance() does not support "), typeVar), " markets yet")))
            }
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-margin-type-trade
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *AsterCore) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            marginMode = ToUpper(marginMode)
            if IsTrue(IsEqual(marginMode, "CROSS")) {
                marginMode = "CROSSED"
            }
            if IsTrue(IsTrue((!IsEqual(marginMode, "ISOLATED"))) && IsTrue((!IsEqual(marginMode, "CROSSED")))) {
                panic(BadRequest(Add(this.Id, " marginMode must be either isolated or cross")))
            }
        
            retRes17288 := (<-this.LoadMarkets())
            PanicOnError(retRes17288)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginType": marginMode,
            }
        
            response:= (<-this.FapiPrivatePostV1MarginType(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "amount": 100.0,
            //         "code": 200,
            //         "msg": "Successfully modify position margin.",
            //         "type": 1
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for aster is set identically for all linear markets or all inverse markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-current-position-modeuser_data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func  (this *AsterCore) FetchPositionMode(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FapiPrivateGetV1PositionSideDual(params))
            PanicOnError(response)
            //
            //     {
            //         "dualSidePosition": true // "true": Hedge Mode; "false": One-way Mode
            //     }
            //
            var dualSidePosition interface{} = this.SafeBool(response, "dualSidePosition")
        
            ch <- map[string]interface{} {
                "info": response,
                "hedged": (IsEqual(dualSidePosition, true)),
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-position-modetrade
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by bingx setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *AsterCore) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "dualSidePosition": hedged,
            }
        
                retRes178915 :=  (<-this.FapiPrivatePostV1PositionSideDual(this.Extend(request, params)))
                PanicOnError(retRes178915)
                    //
            //     {
            //         "code": 200,
            //         "msg": "success"
            //     }
            //
        ch <- retRes178915
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "makerCommissionRate"),
        "taker": this.SafeNumber(fee, "takerCommissionRate"),
        "percentage": false,
        "tierBased": false,
    }
}
/**
 * @method
 * @name aster#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#get-symbol-fees
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#user-commission-rate-user_data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *AsterCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18178 := (<-this.LoadMarkets())
            PanicOnError(retRes18178)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateGetV1CommissionRate(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateGetV1CommissionRate(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
                //
            //     {
            //         "symbol": "BTCUSDT",
            //         "makerCommissionRate": "0.0002",
            //         "takerCommissionRate": "0.0004"
            //     }
            //
        ch <- this.ParseTradingFee(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "REJECTED": "canceled",
        "EXPIRED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *AsterCore) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "LIMIT": "limit",
        "MARKET": "market",
        "STOP": "limit",
        "STOP_MARKET": "market",
        "TAKE_PROFIT": "limit",
        "TAKE_PROFIT_MARKET": "market",
        "TRAILING_STOP_MARKET": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *AsterCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // swap
    //     {
    //         "avgPrice": "0.00000",
    //         "clientOrderId": "abc",
    //         "cumQuote": "0",
    //         "executedQty": "0",
    //         "orderId": 1917641,
    //         "origQty": "0.40",
    //         "origType": "TRAILING_STOP_MARKET",
    //         "price": "0",
    //         "reduceOnly": false,
    //         "side": "BUY",
    //         "positionSide": "SHORT",
    //         "status": "NEW",
    //         "stopPrice": "9300",
    //         "closePosition": false,
    //         "symbol": "BTCUSDT",
    //         "time": 1579276756075,
    //         "timeInForce": "GTC",
    //         "type": "TRAILING_STOP_MARKET",
    //         "activatePrice": "9020",
    //         "priceRate": "0.3",
    //         "updateTime": 1579276756075,
    //         "workingType": "CONTRACT_PRICE",
    //         "priceProtect": false
    //     }
    // spot
    //     {
    //         "orderId": 38,
    //         "symbol": "ADA25SLP25",
    //         "status": "FILLED",
    //         "clientOrderId": "afMd4GBQyHkHpGWdiy34Li",
    //         "price": "20",
    //         "avgPrice": "12.0000000000000000",
    //         "origQty": "10",
    //         "executedQty": "10",
    //         "cumQuote": "120",
    //         "timeInForce": "GTC",
    //         "type": "LIMIT",
    //         "side": "BUY",
    //         "stopPrice": "0",
    //         "origType": "LIMIT",
    //         "time": 1649913186270,
    //         "updateTime": 1649913186297
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var info interface{} = order
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var side interface{} = this.SafeStringLower(order, "side")
    var timestamp interface{} = this.SafeInteger(order, "time")
    var lastTradeTimestamp interface{} = this.SafeInteger(order, "updateTime")
    var statusId interface{} = this.SafeStringUpper(order, "status")
    var rawType interface{} = this.SafeStringUpper(order, "type")
    var stopPriceString interface{} = this.SafeString(order, "stopPrice")
    var triggerPrice interface{} = this.ParseNumber(this.OmitZero(stopPriceString))
    return this.SafeOrder(map[string]interface{} {
        "info": info,
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "lastUpdateTimestamp": this.SafeInteger(order, "updateTime"),
        "type": this.ParseOrderType(rawType),
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "price"),
        "triggerPrice": triggerPrice,
        "average": this.SafeString(order, "avgPrice"),
        "cost": this.SafeString(order, "cumQuote"),
        "amount": this.SafeString(order, "origQty"),
        "filled": this.SafeString(order, "executedQty"),
        "remaining": nil,
        "status": this.ParseOrderStatus(statusId),
        "fee": nil,
        "trades": nil,
        "reduceOnly": this.SafeBool2(order, "reduceOnly", "ro"),
    }, market)
}
/**
 * @method
 * @name aster#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#query-order-user_data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#query-order-user_data
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes19648 := (<-this.LoadMarkets())
            PanicOnError(retRes19648)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientOid")
            params = this.Omit(params, []interface{}{"clientOrderId", "clientOid"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateGetV1Order(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateGetV1Order(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchOpenOrder
 * @description fetch an open order by the id
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#query-current-open-order-user_data
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrder() requires a symbol argument")))
            }
        
            retRes19998 := (<-this.LoadMarkets())
            PanicOnError(retRes19998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientOid")
            params = this.Omit(params, []interface{}{"clientOrderId", "clientOid"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
        
            response:= (<-this.FapiPrivateGetV1OpenOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#query-all-orders-user_data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#all-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20298 := (<-this.LoadMarkets())
            PanicOnError(retRes20298)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000 // Default 500; max 1000
                }
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateGetV1AllOrders(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateGetV1AllOrders(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#current-open-orders-user_data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#current-all-open-orders-user_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] "linear" or "inverse"
 * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20718 := (<-this.LoadMarkets())
            PanicOnError(retRes20718)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var typeVar interface{} = nil
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOpenOrders", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(this.IsLinear(typeVar, subType)) {
                
            response = (<-this.FapiPrivateGetV1OpenOrders(this.Extend(request, params)))
                    PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "spot")) {
                
            response = (<-this.SapiPrivateGetV1OpenOrders(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOpenOrders() does not support "), typeVar), " markets yet")))
            }
        
                //
            //     [
            //         {
            //             "avgPrice": "0.00000",
            //             "clientOrderId": "abc",
            //             "cumQuote": "0",
            //             "executedQty": "0",
            //             "orderId": 1917641,
            //             "origQty": "0.40",
            //             "origType": "TRAILING_STOP_MARKET",
            //             "price": "0",
            //             "reduceOnly": false,
            //             "side": "BUY",
            //             "positionSide": "SHORT",
            //             "status": "NEW",
            //             "stopPrice": "9300",
            //             "closePosition": false,
            //             "symbol": "BTCUSDT",
            //             "time": 1579276756075,
            //             "timeInForce": "GTC",
            //             "type": "TRAILING_STOP_MARKET",
            //             "activatePrice": "9020",
            //             "priceRate": "0.3",
            //             "updateTime": 1579276756075,
            //             "workingType": "CONTRACT_PRICE",
            //             "priceProtect": false
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#createOrder
 * @description create a trade order
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#place-order-trade
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#new-order--trade
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'STOP' or 'STOP_MARKET' or 'TAKE_PROFIT' or 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.reduceOnly] for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to true or in hedge mode. For spot margin and option reduceOnly is a boolean.
 * @param {boolean} [params.test] whether to use the test endpoint or not, default is false
 * @param {float} [params.trailingPercent] the percent to trail away from the current market price
 * @param {float} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @param {string} [params.positionSide] "BOTH" for one-way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
 * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
 * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21458 := (<-this.LoadMarkets())
            PanicOnError(retRes21458)
            var market interface{} = this.Market(symbol)
            var test interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                if IsTrue(test) {
                    
            response = (<-this.FapiPrivatePostV1OrderTest(request))
                        PanicOnError(response)
                } else {
                    
            response = (<-this.FapiPrivatePostV1Order(request))
                        PanicOnError(response)
                }
            } else {
                
            response = (<-this.SapiPrivatePostV1Order(request))
                    PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#createOrders
 * @description create a list of trade orders
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#place-multiple-orders--trade
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21738 := (<-this.LoadMarkets())
            PanicOnError(retRes21738)
            var ordersRequests interface{} = []interface{}{}
            var orderSymbols interface{} = []interface{}{}
            if IsTrue(IsGreaterThan(GetArrayLength(orders), 5)) {
                panic(InvalidOrder(Add(this.Id, " createOrders() order list max 5 orders")))
            }
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests, orderRequest)
            }
            orderSymbols = this.MarketSymbols(orderSymbols, nil, false, true, true)
            var market interface{} = this.Market(GetValue(orderSymbols, 0))
            if IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " createOrders() does not support "), GetValue(market, "type")), " orders")))
            }
            var request interface{} = map[string]interface{} {
                "batchOrders": ordersRequests,
            }
        
            response:= (<-this.FapiPrivatePostV1BatchOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name aster#createOrderRequest
    * @description helper function to build the request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var initialUppercaseType interface{} = ToUpper(typeVar)
    var isMarketOrder interface{} = IsEqual(initialUppercaseType, "MARKET")
    var isLimitOrder interface{} = IsEqual(initialUppercaseType, "LIMIT")
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": ToUpper(side),
    }
    var clientOrderId interface{} = this.SafeString2(params, "newClientOrderId", "clientOrderId")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "newClientOrderId", clientOrderId)
    }
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice", triggerPrice)
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var trailingDelta interface{} = this.SafeString(params, "trailingDelta")
    var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activationPrice")
    var trailingPercent interface{} = this.SafeStringN(params, []interface{}{"trailingPercent", "callbackRate", "trailingDelta"})
    var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
    var isStopLoss interface{} = IsTrue(!IsEqual(stopLossPrice, nil)) || IsTrue(!IsEqual(trailingDelta, nil))
    var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
    var uppercaseType interface{} = initialUppercaseType
    var stopPrice interface{} = nil
    if IsTrue(isTrailingPercentOrder) {
        if IsTrue(GetValue(market, "swap")) {
            uppercaseType = "TRAILING_STOP_MARKET"
            AddElementToObject(request, "callbackRate", trailingPercent)
            if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
                AddElementToObject(request, "activationPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
            }
        }
    } else if IsTrue(isStopLoss) {
        stopPrice = stopLossPrice
        if IsTrue(isMarketOrder) {
            uppercaseType = "STOP_MARKET"
        } else if IsTrue(isLimitOrder) {
            uppercaseType = "STOP"
        }
    } else if IsTrue(isTakeProfit) {
        stopPrice = takeProfitPrice
        if IsTrue(isMarketOrder) {
            uppercaseType = "TAKE_PROFIT_MARKET"
        } else if IsTrue(isLimitOrder) {
            uppercaseType = "TAKE_PROFIT"
        }
    }
    var postOnly interface{} = this.IsPostOnly(isMarketOrder, nil, params)
    if IsTrue(postOnly) {
        AddElementToObject(request, "timeInForce", "GTX")
    }
    //
    // spot
    // LIMIT timeInForce, quantity, price
    // MARKET quantity or quoteOrderQty
    // STOP and TAKE_PROFIT quantity, price, stopPrice
    // STOP_MARKET and TAKE_PROFIT_MARKET quantity, stopPrice
    // future
    // LIMIT timeInForce, quantity, price
    // MARKET quantity
    // STOP/TAKE_PROFIT quantity, price, stopPrice
    // STOP_MARKET/TAKE_PROFIT_MARKET stopPrice
    // TRAILING_STOP_MARKET callbackRate
    //
    // additional required fields depending on the order type
    var closePosition interface{} = this.SafeBool(params, "closePosition", false)
    var timeInForceIsRequired interface{} = false
    var priceIsRequired interface{} = false
    var triggerPriceIsRequired interface{} = false
    var quantityIsRequired interface{} = false
    AddElementToObject(request, "type", uppercaseType)
    if IsTrue(IsEqual(uppercaseType, "MARKET")) {
        if IsTrue(GetValue(market, "spot")) {
            var quoteOrderQty interface{} = this.SafeBool(this.Options, "quoteOrderQty", true)
            if IsTrue(quoteOrderQty) {
                var quoteOrderQtyNew interface{} = this.SafeString2(params, "quoteOrderQty", "cost")
                var precision interface{} = GetValue(GetValue(market, "precision"), "price")
                if IsTrue(!IsEqual(quoteOrderQtyNew, nil)) {
                    AddElementToObject(request, "quoteOrderQty", this.DecimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.PrecisionMode))
                } else if IsTrue(!IsEqual(price, nil)) {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var quoteOrderQuantity interface{} = Precise.StringMul(amountString, priceString)
                    AddElementToObject(request, "quoteOrderQty", this.DecimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.PrecisionMode))
                } else {
                    quantityIsRequired = true
                }
            } else {
                quantityIsRequired = true
            }
        } else {
            quantityIsRequired = true
        }
    } else if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
        timeInForceIsRequired = true
        quantityIsRequired = true
        priceIsRequired = true
    } else if IsTrue(IsTrue((IsEqual(uppercaseType, "STOP"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT")))) {
        quantityIsRequired = true
        priceIsRequired = true
        triggerPriceIsRequired = true
    } else if IsTrue(IsTrue((IsEqual(uppercaseType, "STOP_MARKET"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_MARKET")))) {
        if !IsTrue(closePosition) {
            quantityIsRequired = true
        }
        triggerPriceIsRequired = true
    } else if IsTrue(IsEqual(uppercaseType, "TRAILING_STOP_MARKET")) {
        AddElementToObject(request, "callbackRate", trailingPercent)
        if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
            AddElementToObject(request, "activationPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
        }
    }
    if IsTrue(quantityIsRequired) {
        var marketAmountPrecision interface{} = this.SafeString(GetValue(market, "precision"), "amount")
        var isPrecisionAvailable interface{} =         (!IsEqual(marketAmountPrecision, nil))
        if IsTrue(isPrecisionAvailable) {
            AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
        } else {
            AddElementToObject(request, "quantity", this.ParseToNumeric(amount))
        }
    }
    if IsTrue(priceIsRequired) {
        if IsTrue(IsEqual(price, nil)) {
            panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
        }
        var pricePrecision interface{} = this.SafeString(GetValue(market, "precision"), "price")
        var isPricePrecisionAvailable interface{} =         (!IsEqual(pricePrecision, nil))
        if IsTrue(isPricePrecisionAvailable) {
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        } else {
            AddElementToObject(request, "price", this.ParseToNumeric(price))
        }
    }
    if IsTrue(triggerPriceIsRequired) {
        if IsTrue(IsEqual(stopPrice, nil)) {
            panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() requires a stopPrice extra param for a "), typeVar), " order")))
        }
        if IsTrue(!IsEqual(stopPrice, nil)) {
            AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, stopPrice))
        }
    }
    if IsTrue(IsTrue(IsTrue(timeInForceIsRequired) && IsTrue((IsEqual(this.SafeString(params, "timeInForce"), nil)))) && IsTrue((IsEqual(this.SafeString(request, "timeInForce"), nil)))) {
        AddElementToObject(request, "timeInForce", this.SafeString(this.Options, "defaultTimeInForce")) // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
    }
    var requestParams interface{} = this.Omit(params, []interface{}{"newClientOrderId", "clientOrderId", "stopPrice", "triggerPrice", "trailingTriggerPrice", "trailingPercent", "trailingDelta", "stopPrice", "stopLossPrice", "takeProfitPrice"})
    return this.Extend(request, requestParams)
}
/**
 * @method
 * @name aster#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#cancel-all-open-orders-trade
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-all-open-orders-trade
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes23778 := (<-this.LoadMarkets())
            PanicOnError(retRes23778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateDeleteV1AllOpenOrders(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateDeleteV1AllOpenOrders(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
                //
            //     {
            //         "code": "200",
            //         "msg": "The operation of cancel all open order is done."
            //     }
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#cancelOrder
 * @description cancels an open order
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#cancel-order-trade
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-order-trade
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes24168 := (<-this.LoadMarkets())
            PanicOnError(retRes24168)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"origClientOrderId", "clientOrderId", "newClientStrategyId"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            params = this.Omit(params, []interface{}{"origClientOrderId", "clientOrderId", "newClientStrategyId"})
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
            response = (<-this.FapiPrivateDeleteV1Order(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.SapiPrivateDeleteV1Order(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#cancelOrders
 * @description cancel multiple orders
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-multiple-orders-trade
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string[]} [params.origClientOrderIdList] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
 * @param {int[]} [params.recvWindow]
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *AsterCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes24558 := (<-this.LoadMarkets())
            PanicOnError(retRes24558)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelOrders() does not support "), GetValue(market, "type")), " orders")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderIdList interface{} = this.SafeList(params, "origClientOrderIdList")
            if IsTrue(!IsEqual(clientOrderIdList, nil)) {
                AddElementToObject(request, "origClientOrderIdList", clientOrderIdList)
            } else {
                AddElementToObject(request, "orderIdList", ids)
            }
        
            response:= (<-this.FapiPrivateDeleteV1BatchOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "clientOrderId": "myOrder1",
            //            "cumQty": "0",
            //            "cumQuote": "0",
            //            "executedQty": "0",
            //            "orderId": 283194212,
            //            "origQty": "11",
            //            "origType": "TRAILING_STOP_MARKET",
            //            "price": "0",
            //            "reduceOnly": false,
            //            "side": "BUY",
            //            "positionSide": "SHORT",
            //            "status": "CANCELED",
            //            "stopPrice": "9300",                  // please ignore when order type is TRAILING_STOP_MARKET
            //            "closePosition": false,               // if Close-All
            //            "symbol": "BTCUSDT",
            //            "timeInForce": "GTC",
            //            "type": "TRAILING_STOP_MARKET",
            //            "activatePrice": "9020",              // activation price, only return with TRAILING_STOP_MARKET order
            //            "priceRate": "0.3",                   // callback rate, only return with TRAILING_STOP_MARKET order
            //            "updateTime": 1571110484038,
            //            "workingType": "CONTRACT_PRICE",
            //            "priceProtect": false,                // if conditional order trigger is protected
            //        },
            //        {
            //            "code": -2011,
            //            "msg": "Unknown order sent."
            //        }
            //    ]
            //
        ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#setLeverage
 * @description set the level of leverage for a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-initial-leverage-trade
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *AsterCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 125)))) {
                panic(BadRequest(Add(this.Id, " leverage should be between 1 and 125")))
            }
        
            retRes25228 := (<-this.LoadMarkets())
            PanicOnError(retRes25228)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "leverage": leverage,
            }
        
            response:= (<-this.FapiPrivatePostV1Leverage(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "leverage": 21,
            //         "maxNotionalValue": "1000000",
            //         "symbol": "BTCUSDT"
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchLeverages
 * @description fetch the set leverage for all markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
 * @param {string[]} [symbols] a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *AsterCore) FetchLeverages(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes25498 := (<-this.LoadMarkets())
            PanicOnError(retRes25498)
        
            response:= (<-this.FapiPrivateGetV2PositionRisk(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "INJUSDT",
            //             "positionAmt": "0.0",
            //             "entryPrice": "0.0",
            //             "markPrice": "0.00000000",
            //             "unRealizedProfit": "0.00000000",
            //             "liquidationPrice": "0",
            //             "leverage": "20",
            //             "maxNotionalValue": "25000",
            //             "marginType": "cross",
            //             "isolatedMargin": "0.00000000",
            //             "isAutoAddMargin": "false",
            //             "positionSide": "BOTH",
            //             "notional": "0",
            //             "isolatedWallet": "0",
            //             "updateTime": 0
            //         }
            //     ]
            //
        ch <- this.ParseLeverages(response, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "INJUSDT",
    //         "positionAmt": "0.0",
    //         "entryPrice": "0.0",
    //         "markPrice": "0.00000000",
    //         "unRealizedProfit": "0.00000000",
    //         "liquidationPrice": "0",
    //         "leverage": "20",
    //         "maxNotionalValue": "25000",
    //         "marginType": "cross",
    //         "isolatedMargin": "0.00000000",
    //         "isAutoAddMargin": "false",
    //         "positionSide": "BOTH",
    //         "notional": "0",
    //         "isolatedWallet": "0",
    //         "updateTime": 0
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    var marginMode interface{} = this.SafeStringLower(leverage, "marginType")
    var side interface{} = this.SafeStringLower(leverage, "positionSide")
    var longLeverage interface{} = nil
    var shortLeverage interface{} = nil
    var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
    if IsTrue(IsTrue((IsEqual(side, nil))) || IsTrue((IsEqual(side, "both")))) {
        longLeverage = leverageValue
        shortLeverage = leverageValue
    } else if IsTrue(IsEqual(side, "long")) {
        longLeverage = leverageValue
    } else if IsTrue(IsEqual(side, "short")) {
        shortLeverage = leverageValue
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
/**
 * @method
 * @name aster#fetchMarginModes
 * @description fetches margin mode of the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *AsterCore) FetchMarginModes(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26288 := (<-this.LoadMarkets())
            PanicOnError(retRes26288)
        
            response:= (<-this.FapiPrivateGetV2PositionRisk(params))
            PanicOnError(response)
        
                //
            //
            //     [
            //         {
            //             "symbol": "INJUSDT",
            //             "positionAmt": "0.0",
            //             "entryPrice": "0.0",
            //             "markPrice": "0.00000000",
            //             "unRealizedProfit": "0.00000000",
            //             "liquidationPrice": "0",
            //             "leverage": "20",
            //             "maxNotionalValue": "25000",
            //             "marginType": "cross",
            //             "isolatedMargin": "0.00000000",
            //             "isAutoAddMargin": "false",
            //             "positionSide": "BOTH",
            //             "notional": "0",
            //             "isolatedWallet": "0",
            //             "updateTime": 0
            //         }
            //     ]
            //
            //
        ch <- this.ParseMarginModes(response, symbols, "symbol", "swap")
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "INJUSDT",
    //         "positionAmt": "0.0",
    //         "entryPrice": "0.0",
    //         "markPrice": "0.00000000",
    //         "unRealizedProfit": "0.00000000",
    //         "liquidationPrice": "0",
    //         "leverage": "20",
    //         "maxNotionalValue": "25000",
    //         "marginType": "cross",
    //         "isolatedMargin": "0.00000000",
    //         "isAutoAddMargin": "false",
    //         "positionSide": "BOTH",
    //         "notional": "0",
    //         "isolatedWallet": "0",
    //         "updateTime": 0
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(marginMode, "symbol")
    market = this.SafeMarket(marketId, market)
    return map[string]interface{} {
        "info": marginMode,
        "symbol": GetValue(market, "symbol"),
        "marginMode": this.SafeStringLower(marginMode, "marginType"),
    }
}
/**
 * @method
 * @name aster#fetchMarginAdjustmentHistory
 * @description fetches the history of margin added or reduced from contract isolated positions
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-position-margin-change-history-trade
 * @param {string} symbol unified market symbol
 * @param {string} [type] "add" or "reduce"
 * @param {int} [since] timestamp in ms of the earliest change to fetch
 * @param {int} [limit] the maximum amount of changes to fetch
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest change to fetch
 * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *AsterCore) FetchMarginAdjustmentHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            typeVar := GetArg(optionalArgs, 1, nil)
            _ = typeVar
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes26998 := (<-this.LoadMarkets())
            PanicOnError(retRes26998)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMarginAdjustmentHistory () requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(typeVar, nil)) {
                AddElementToObject(request, "type", Ternary(IsTrue((IsEqual(typeVar, "add"))), 1, 2))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.FapiPrivateGetV1PositionMarginHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "amount": "23.36332311",
            //             "asset": "USDT",
            //             "symbol": "BTCUSDT",
            //             "time": 1578047897183,
            //             "type": 1,
            //             "positionSide": "BOTH"
            //         }
            //     ]
            //
            var modifications interface{} = this.ParseMarginModifications(response)
        
            ch <- this.FilterBySymbolSinceLimit(modifications, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "amount": "100",
    //         "asset": "USDT",
    //         "symbol": "BTCUSDT",
    //         "time": 1578047900425,
    //         "type": 1,
    //         "positionSide": "LONG"
    //     }
    //
    //     {
    //         "amount": 100.0,
    //         "code": 200,
    //         "msg": "Successfully modify position margin.",
    //         "type": 1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var rawType interface{} = this.SafeInteger(data, "type")
    var errorCode interface{} = this.SafeString(data, "code")
    var marketId interface{} = this.SafeString(data, "symbol")
    var timestamp interface{} = this.SafeInteger(data, "time")
    market = this.SafeMarket(marketId, market, nil, "swap")
    var noErrorCode interface{} = IsEqual(errorCode, nil)
    var success interface{} = IsEqual(errorCode, "200")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": Ternary(IsTrue((IsEqual(rawType, 1))), "add", "reduce"),
        "marginMode": "isolated",
        "amount": this.SafeNumber(data, "amount"),
        "code": this.SafeString(data, "asset"),
        "total": nil,
        "status": Ternary(IsTrue((IsTrue(success) || IsTrue(noErrorCode))), "ok", "failed"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
func  (this *AsterCore) ModifyMarginHelper(symbol interface{}, amount interface{}, addOrReduce interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27788 := (<-this.LoadMarkets())
            PanicOnError(retRes27788)
            var market interface{} = this.Market(symbol)
            amount = this.AmountToPrecision(symbol, amount)
            var request interface{} = map[string]interface{} {
                "type": addOrReduce,
                "symbol": GetValue(market, "id"),
                "amount": amount,
            }
            var code interface{} = GetValue(market, "quote")
        
            response:= (<-this.FapiPrivatePostV1PositionMargin(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "amount": 100.0,
            //         "code": 200,
            //         "msg": "Successfully modify position margin.",
            //         "type": 1
            //     }
            //
        ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{} {
                "code": code,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#reduceMargin
 * @description remove margin from a position
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#modify-isolated-position-margin-trade
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *AsterCore) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes281215 :=  (<-this.ModifyMarginHelper(symbol, amount, 2, params))
                PanicOnError(retRes281215)
                ch <- retRes281215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#addMargin
 * @description add margin
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#modify-isolated-position-margin-trade
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *AsterCore) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes282615 :=  (<-this.ModifyMarginHelper(symbol, amount, 1, params))
                PanicOnError(retRes282615)
                ch <- retRes282615
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //       "symbol": "ETHUSDT",
    //       "incomeType": "FUNDING_FEE",
    //       "income": "0.00134317",
    //       "asset": "USDT",
    //       "time": "1621584000000",
    //       "info": "FUNDING_FEE",
    //       "tranId": "4480321991774044580",
    //       "tradeId": ""
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    var currencyId interface{} = this.SafeString(income, "asset")
    var timestamp interface{} = this.SafeInteger(income, "time")
    return map[string]interface{} {
        "info": income,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "code": this.SafeCurrencyCode(currencyId),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(income, "tranId"),
        "amount": this.SafeNumber(income, "income"),
    }
}
/**
 * @method
 * @name aster#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-income-historyuser_data
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding history entry
 * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the funding history for a portfolio margin account
 * @param {string} [params.subType] "linear" or "inverse"
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *AsterCore) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28718 := (<-this.LoadMarkets())
            PanicOnError(retRes28718)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "incomeType": "FUNDING_FEE",
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000)) // max 1000
            }
        
            response:= (<-this.FapiPrivateGetV1Income(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseIncomes(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "",
    //         "incomeType": "TRANSFER",
    //         "income": "10.00000000",
    //         "asset": "USDT",
    //         "time": 1677645250000,
    //         "info": "TRANSFER",
    //         "tranId": 131001573082,
    //         "tradeId": ""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var amount interface{} = this.SafeString(item, "income")
    var direction interface{} = nil
    if IsTrue(Precise.StringLe(amount, "0")) {
        direction = "out"
        amount = Precise.StringMul("-1", amount)
    } else {
        direction = "in"
    }
    var currencyId interface{} = this.SafeString(item, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(item, "time")
    var typeVar interface{} = this.SafeString(item, "incomeType")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "tranId"),
        "direction": direction,
        "account": nil,
        "referenceAccount": nil,
        "referenceId": this.SafeString(item, "tradeId"),
        "type": this.ParseLedgerEntryType(typeVar),
        "currency": code,
        "amount": this.ParseNumber(amount),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": nil,
        "status": nil,
        "fee": nil,
    }, currency)
}
func  (this *AsterCore) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var ledgerType interface{} = map[string]interface{} {
        "TRANSFER": "transfer",
        "WELCOME_BONUS": "cashback",
        "REALIZED_PNL": "trade",
        "FUNDING_FEE": "fee",
        "COMMISSION": "commission",
        "INSURANCE_CLEAR": "settlement",
        "MARKET_MERCHANT_RETURN_REWARD": "cashback",
    }
    return this.SafeString(ledgerType, typeVar, typeVar)
}
/**
 * @method
 * @name aster#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-income-historyuser_data
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest ledger entry
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *AsterCore) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes29628 := (<-this.LoadMarkets())
            PanicOnError(retRes29628)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000)) // max 1000
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.FapiPrivateGetV1Income(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "",
            //             "incomeType": "TRANSFER",
            //             "income": "10.00000000",
            //             "asset": "USDT",
            //             "time": 1677645250000,
            //             "info": "TRANSFER",
            //             "tranId": 131001573082,
            //             "tradeId": ""
            //         }
            //     ]
            //
        ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) ParsePositionRisk(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "entryPrice": "6563.66500",
    //         "marginType": "isolated",
    //         "isAutoAddMargin": "false",
    //         "isolatedMargin": "15517.54150468",
    //         "leverage": "10",
    //         "liquidationPrice": "5930.78",
    //         "markPrice": "6679.50671178",
    //         "maxNotionalValue": "20000000",
    //         "positionSide": "LONG",
    //         "positionAmt": "20.000",
    //         "symbol": "BTCUSDT",
    //         "unRealizedProfit": "2316.83423560",
    //         "updateTime": 1625474304765
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var symbol interface{} = this.SafeString(market, "symbol")
    var isolatedMarginString interface{} = this.SafeString(position, "isolatedMargin")
    var leverageBrackets interface{} = this.SafeDict(this.Options, "leverageBrackets", map[string]interface{} {})
    var leverageBracket interface{} = this.SafeList(leverageBrackets, symbol, []interface{}{})
    var notionalString interface{} = this.SafeString2(position, "notional", "notionalValue")
    var notionalStringAbs interface{} = Precise.StringAbs(notionalString)
    var maintenanceMarginPercentageString interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(leverageBracket)); i++ {
        var bracket interface{} = GetValue(leverageBracket, i)
        if IsTrue(Precise.StringLt(notionalStringAbs, GetValue(bracket, 0))) {
            break
        }
        maintenanceMarginPercentageString = GetValue(bracket, 1)
    }
    var notional interface{} = this.ParseNumber(notionalStringAbs)
    var contractsAbs interface{} = Precise.StringAbs(this.SafeString(position, "positionAmt"))
    var contracts interface{} = this.ParseNumber(contractsAbs)
    var unrealizedPnlString interface{} = this.SafeString(position, "unRealizedProfit")
    var unrealizedPnl interface{} = this.ParseNumber(unrealizedPnlString)
    var liquidationPriceString interface{} = this.OmitZero(this.SafeString(position, "liquidationPrice"))
    var liquidationPrice interface{} = this.ParseNumber(liquidationPriceString)
    var collateralString interface{} = nil
    var marginMode interface{} = this.SafeString(position, "marginType")
    if IsTrue(IsTrue(IsEqual(marginMode, nil)) && IsTrue(!IsEqual(isolatedMarginString, nil))) {
        marginMode = Ternary(IsTrue(Precise.StringEq(isolatedMarginString, "0")), "cross", "isolated")
    }
    var side interface{} = nil
    if IsTrue(Precise.StringGt(notionalString, "0")) {
        side = "long"
    } else if IsTrue(Precise.StringLt(notionalString, "0")) {
        side = "short"
    }
    var entryPriceString interface{} = this.SafeString(position, "entryPrice")
    var entryPrice interface{} = this.ParseNumber(entryPriceString)
    var contractSize interface{} = this.SafeValue(market, "contractSize")
    var contractSizeString interface{} = this.NumberToString(contractSize)
    // as oppose to notionalValue
    var linear interface{} =     (InOp(position, "notional"))
    if IsTrue(IsEqual(marginMode, "cross")) {
        // calculate collateral
        var precision interface{} = this.SafeDict(market, "precision", map[string]interface{} {})
        var basePrecisionValue interface{} = this.SafeString(precision, "base")
        var quotePrecisionValue interface{} = this.SafeString2(precision, "quote", "price")
        var precisionIsUndefined interface{} = IsTrue((IsEqual(basePrecisionValue, nil))) && IsTrue((IsEqual(quotePrecisionValue, nil)))
        if !IsTrue(precisionIsUndefined) {
            if IsTrue(linear) {
                // walletBalance = (liquidationPrice * (1 + mmp)  entryPrice) * contracts
                var onePlusMaintenanceMarginPercentageString interface{} = nil
                var entryPriceSignString interface{} = entryPriceString
                if IsTrue(IsEqual(side, "short")) {
                    onePlusMaintenanceMarginPercentageString = Precise.StringAdd("1", maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.StringMul("-1", entryPriceSignString)
                } else {
                    onePlusMaintenanceMarginPercentageString = Precise.StringAdd("-1", maintenanceMarginPercentageString)
                }
                var inner interface{} = Precise.StringMul(liquidationPriceString, onePlusMaintenanceMarginPercentageString)
                var leftSide interface{} = Precise.StringAdd(inner, entryPriceSignString)
                var quotePrecision interface{} = this.PrecisionFromString(this.SafeString2(precision, "quote", "price"))
                if IsTrue(!IsEqual(quotePrecision, nil)) {
                    collateralString = Precise.StringDiv(Precise.StringMul(leftSide, contractsAbs), "1", quotePrecision)
                }
            } else {
                // walletBalance = (contracts * contractSize) * (1/entryPrice - (1 - mmp) / liquidationPrice)
                var onePlusMaintenanceMarginPercentageString interface{} = nil
                var entryPriceSignString interface{} = entryPriceString
                if IsTrue(IsEqual(side, "short")) {
                    onePlusMaintenanceMarginPercentageString = Precise.StringSub("1", maintenanceMarginPercentageString)
                } else {
                    onePlusMaintenanceMarginPercentageString = Precise.StringSub("-1", maintenanceMarginPercentageString)
                    entryPriceSignString = Precise.StringMul("-1", entryPriceSignString)
                }
                var leftSide interface{} = Precise.StringMul(contractsAbs, contractSizeString)
                var rightSide interface{} = Precise.StringSub(Precise.StringDiv("1", entryPriceSignString), Precise.StringDiv(onePlusMaintenanceMarginPercentageString, liquidationPriceString))
                var basePrecision interface{} = this.PrecisionFromString(this.SafeString(precision, "base"))
                if IsTrue(!IsEqual(basePrecision, nil)) {
                    collateralString = Precise.StringDiv(Precise.StringMul(leftSide, rightSide), "1", basePrecision)
                }
            }
        }
    } else {
        collateralString = this.SafeString(position, "isolatedMargin")
    }
    collateralString = Ternary(IsTrue((IsEqual(collateralString, nil))), "0", collateralString)
    var collateral interface{} = this.ParseNumber(collateralString)
    var markPrice interface{} = this.ParseNumber(this.OmitZero(this.SafeString(position, "markPrice")))
    var timestamp interface{} = this.SafeInteger(position, "updateTime")
    if IsTrue(IsEqual(timestamp, 0)) {
        timestamp = nil
    }
    var maintenanceMarginPercentage interface{} = this.ParseNumber(maintenanceMarginPercentageString)
    var maintenanceMarginString interface{} = Precise.StringMul(maintenanceMarginPercentageString, notionalStringAbs)
    if IsTrue(IsEqual(maintenanceMarginString, nil)) {
        // for a while, this new value was a backup to the existing calculations, but in future we might prioritize this
        maintenanceMarginString = this.SafeString(position, "maintMargin")
    }
    var maintenanceMargin interface{} = this.ParseNumber(maintenanceMarginString)
    var initialMarginString interface{} = nil
    var initialMarginPercentageString interface{} = nil
    var leverageString interface{} = this.SafeString(position, "leverage")
    if IsTrue(!IsEqual(leverageString, nil)) {
        var leverage interface{} = ParseInt(leverageString)
        var rational interface{} = this.IsRoundNumber(Mod(1000, leverage))
        initialMarginPercentageString = Precise.StringDiv("1", leverageString, 8)
        if !IsTrue(rational) {
            initialMarginPercentageString = Precise.StringAdd(initialMarginPercentageString, "1e-8")
        }
        var unrounded interface{} = Precise.StringMul(notionalStringAbs, initialMarginPercentageString)
        initialMarginString = Precise.StringDiv(unrounded, "1", 8)
    } else {
        initialMarginString = this.SafeString(position, "initialMargin")
        var unrounded interface{} = Precise.StringMul(initialMarginString, "1")
        initialMarginPercentageString = Precise.StringDiv(unrounded, notionalStringAbs, 8)
    }
    var marginRatio interface{} = nil
    var percentage interface{} = nil
    if !IsTrue(Precise.StringEquals(collateralString, "0")) {
        marginRatio = this.ParseNumber(Precise.StringDiv(Precise.StringAdd(Precise.StringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4))
        percentage = this.ParseNumber(Precise.StringMul(Precise.StringDiv(unrealizedPnlString, initialMarginString, 4), "100"))
    }
    var positionSide interface{} = this.SafeString(position, "positionSide")
    var hedged interface{} = !IsEqual(positionSide, "BOTH")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "contracts": contracts,
        "contractSize": contractSize,
        "unrealizedPnl": unrealizedPnl,
        "leverage": this.ParseNumber(leverageString),
        "liquidationPrice": liquidationPrice,
        "collateral": collateral,
        "notional": notional,
        "markPrice": markPrice,
        "entryPrice": entryPrice,
        "timestamp": timestamp,
        "initialMargin": this.ParseNumber(initialMarginString),
        "initialMarginPercentage": this.ParseNumber(initialMarginPercentageString),
        "maintenanceMargin": maintenanceMargin,
        "maintenanceMarginPercentage": maintenanceMarginPercentage,
        "marginRatio": marginRatio,
        "datetime": this.Iso8601(timestamp),
        "marginMode": marginMode,
        "side": side,
        "hedged": hedged,
        "percentage": percentage,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name aster#fetchPositionsRisk
 * @description fetch positions risk
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} data on the positions risk
 */
func  (this *AsterCore) FetchPositionsRisk(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(symbols, nil)) {
                if !IsTrue(IsArray(symbols)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchPositionsRisk() requires an array argument for symbols")))
                }
            }
        
            retRes31828 := (<-this.LoadMarkets())
            PanicOnError(retRes31828)
        
            retRes31838 := (<-this.LoadLeverageBrackets(false, params))
            PanicOnError(retRes31838)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.FapiPrivateGetV2PositionRisk(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "entryPrice": "6563.66500",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "isolatedMargin": "15517.54150468",
            //             "leverage": "10",
            //             "liquidationPrice": "5930.78",
            //             "markPrice": "6679.50671178",
            //             "maxNotionalValue": "20000000",
            //             "positionSide": "LONG",
            //             "positionAmt": "20.000", // negative value for 'SHORT'
            //             "symbol": "BTCUSDT",
            //             "unRealizedProfit": "2316.83423560",
            //             "updateTime": 1625474304765
            //         }
            //     ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var rawPosition interface{} = GetValue(response, i)
                var entryPriceString interface{} = this.SafeString(rawPosition, "entryPrice")
                if IsTrue(Precise.StringGt(entryPriceString, "0")) {
                    AppendToArray(&result, this.ParsePositionRisk(GetValue(response, i)))
                }
            }
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#fetchPositions
 * @description fetch all open positions
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] method name to call, "positionRisk", "account" or "option", default is "positionRisk"
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *AsterCore) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var defaultMethod interface{} = nil
            defaultMethodparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "method");
            defaultMethod = GetValue(defaultMethodparamsVariable,0);
            params = GetValue(defaultMethodparamsVariable,1)
            if IsTrue(IsEqual(defaultMethod, nil)) {
                var options interface{} = this.SafeDict(this.Options, "fetchPositions")
                if IsTrue(IsEqual(options, nil)) {
                    defaultMethod = this.SafeString(this.Options, "fetchPositions", "positionRisk")
                } else {
                    defaultMethod = "positionRisk"
                }
            }
            if IsTrue(IsEqual(defaultMethod, "positionRisk")) {
        
                    retRes323919 :=  (<-this.FetchPositionsRisk(symbols, params))
                    PanicOnError(retRes323919)
                    ch <- retRes323919
                    return nil
            } else if IsTrue(IsEqual(defaultMethod, "account")) {
        
                    retRes324119 :=  (<-this.FetchAccountPositions(symbols, params))
                    PanicOnError(retRes324119)
                    ch <- retRes324119
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, ".options[\"fetchPositions\"][\"method\"] or params[\"method\"] = \""), defaultMethod), "\" is invalid, please choose between \"account\" and \"positionRisk\"")))
            }
        
            }()
            return ch
        }
func  (this *AsterCore) ParseAccountPositions(account interface{}, optionalArgs ...interface{}) interface{}  {
    filterClosed := GetArg(optionalArgs, 0, false)
    _ = filterClosed
    var positions interface{} = this.SafeList(account, "positions")
    var assets interface{} = this.SafeList(account, "assets", []interface{}{})
    var balances interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
        var entry interface{} = GetValue(assets, i)
        var currencyId interface{} = this.SafeString(entry, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var crossWalletBalance interface{} = this.SafeString(entry, "crossWalletBalance")
        var crossUnPnl interface{} = this.SafeString(entry, "crossUnPnl")
        AddElementToObject(balances, code, map[string]interface{} {
    "crossMargin": Precise.StringAdd(crossWalletBalance, crossUnPnl),
    "crossWalletBalance": crossWalletBalance,
})
    }
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
        var position interface{} = GetValue(positions, i)
        var marketId interface{} = this.SafeString(position, "symbol")
        var market interface{} = this.SafeMarket(marketId, nil, nil, "contract")
        var code interface{} = Ternary(IsTrue(GetValue(market, "linear")), GetValue(market, "quote"), GetValue(market, "base"))
        var maintenanceMargin interface{} = this.SafeString(position, "maintMargin")
        // check for maintenance margin so empty positions are not returned
        var isPositionOpen interface{} = IsTrue((!IsEqual(maintenanceMargin, "0"))) && IsTrue((!IsEqual(maintenanceMargin, "0.00000000")))
        if IsTrue(!IsTrue(filterClosed) || IsTrue(isPositionOpen)) {
            // sometimes not all the codes are correctly returned...
            if IsTrue(InOp(balances, code)) {
                var parsed interface{} = this.ParseAccountPosition(this.Extend(position, map[string]interface{} {
                    "crossMargin": GetValue(GetValue(balances, code), "crossMargin"),
                    "crossWalletBalance": GetValue(GetValue(balances, code), "crossWalletBalance"),
                }), market)
                AppendToArray(&result, parsed)
            }
        }
    }
    return result
}
func  (this *AsterCore) ParseAccountPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var symbol interface{} = this.SafeString(market, "symbol")
    var leverageString interface{} = this.SafeString(position, "leverage")
    var leverage interface{} = Ternary(IsTrue((!IsEqual(leverageString, nil))), ParseInt(leverageString), nil)
    var initialMarginString interface{} = this.SafeString(position, "initialMargin")
    var initialMargin interface{} = this.ParseNumber(initialMarginString)
    var initialMarginPercentageString interface{} = nil
    if IsTrue(!IsEqual(leverageString, nil)) {
        initialMarginPercentageString = Precise.StringDiv("1", leverageString, 8)
        var rational interface{} = this.IsRoundNumber(Mod(1000, leverage))
        if !IsTrue(rational) {
            initialMarginPercentageString = Precise.StringDiv(Precise.StringAdd(initialMarginPercentageString, "1e-8"), "1", 8)
        }
    }
    // as oppose to notionalValue
    var usdm interface{} =     (InOp(position, "notional"))
    var maintenanceMarginString interface{} = this.SafeString(position, "maintMargin")
    var maintenanceMargin interface{} = this.ParseNumber(maintenanceMarginString)
    var entryPriceString interface{} = this.SafeString(position, "entryPrice")
    var entryPrice interface{} = this.ParseNumber(entryPriceString)
    var notionalString interface{} = this.SafeString2(position, "notional", "notionalValue")
    var notionalStringAbs interface{} = Precise.StringAbs(notionalString)
    var notional interface{} = this.ParseNumber(notionalStringAbs)
    var contractsString interface{} = this.SafeString(position, "positionAmt")
    var contractsStringAbs interface{} = Precise.StringAbs(contractsString)
    if IsTrue(IsEqual(contractsString, nil)) {
        var entryNotional interface{} = Precise.StringMul(Precise.StringMul(leverageString, initialMarginString), entryPriceString)
        var contractSizeNew interface{} = this.SafeString(market, "contractSize")
        contractsString = Precise.StringDiv(entryNotional, contractSizeNew)
        contractsStringAbs = Precise.StringDiv(Precise.StringAdd(contractsString, "0.5"), "1", 0)
    }
    var contracts interface{} = this.ParseNumber(contractsStringAbs)
    var leverageBrackets interface{} = this.SafeDict(this.Options, "leverageBrackets", map[string]interface{} {})
    var leverageBracket interface{} = this.SafeList(leverageBrackets, symbol, []interface{}{})
    var maintenanceMarginPercentageString interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(leverageBracket)); i++ {
        var bracket interface{} = GetValue(leverageBracket, i)
        if IsTrue(Precise.StringLt(notionalStringAbs, GetValue(bracket, 0))) {
            break
        }
        maintenanceMarginPercentageString = GetValue(bracket, 1)
    }
    var maintenanceMarginPercentage interface{} = this.ParseNumber(maintenanceMarginPercentageString)
    var unrealizedPnlString interface{} = this.SafeString(position, "unrealizedProfit")
    var unrealizedPnl interface{} = this.ParseNumber(unrealizedPnlString)
    var timestamp interface{} = this.SafeInteger(position, "updateTime")
    if IsTrue(IsEqual(timestamp, 0)) {
        timestamp = nil
    }
    var isolated interface{} = this.SafeBool(position, "isolated")
    if IsTrue(IsEqual(isolated, nil)) {
        var isolatedMarginRaw interface{} = this.SafeString(position, "isolatedMargin")
        isolated = !IsTrue(Precise.StringEq(isolatedMarginRaw, "0"))
    }
    var marginMode interface{} = nil
    var collateralString interface{} = nil
    var walletBalance interface{} = nil
    if IsTrue(isolated) {
        marginMode = "isolated"
        walletBalance = this.SafeString(position, "isolatedWallet")
        collateralString = Precise.StringAdd(walletBalance, unrealizedPnlString)
    } else {
        marginMode = "cross"
        walletBalance = this.SafeString(position, "crossWalletBalance")
        collateralString = this.SafeString(position, "crossMargin")
    }
    var collateral interface{} = this.ParseNumber(collateralString)
    var marginRatio interface{} = nil
    var side interface{} = nil
    var percentage interface{} = nil
    var liquidationPriceStringRaw interface{} = nil
    var liquidationPrice interface{} = nil
    var contractSize interface{} = this.SafeValue(market, "contractSize")
    var contractSizeString interface{} = this.NumberToString(contractSize)
    if IsTrue(Precise.StringEquals(notionalString, "0")) {
        entryPrice = nil
    } else {
        side = Ternary(IsTrue(Precise.StringLt(notionalString, "0")), "short", "long")
        marginRatio = this.ParseNumber(Precise.StringDiv(Precise.StringAdd(Precise.StringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4))
        percentage = this.ParseNumber(Precise.StringMul(Precise.StringDiv(unrealizedPnlString, initialMarginString, 4), "100"))
        if IsTrue(usdm) {
            // calculate liquidation price
            //
            // liquidationPrice = (walletBalance / (contracts * (1 + mmp))) + (entryPrice / (1 + mmp))
            //
            // mmp = maintenanceMarginPercentage
            // where  is negative for long and positive for short
            // TODO: calculate liquidation price for coinm contracts
            var onePlusMaintenanceMarginPercentageString interface{} = nil
            var entryPriceSignString interface{} = entryPriceString
            if IsTrue(IsEqual(side, "short")) {
                onePlusMaintenanceMarginPercentageString = Precise.StringAdd("1", maintenanceMarginPercentageString)
            } else {
                onePlusMaintenanceMarginPercentageString = Precise.StringAdd("-1", maintenanceMarginPercentageString)
                entryPriceSignString = Precise.StringMul("-1", entryPriceSignString)
            }
            var leftSide interface{} = Precise.StringDiv(walletBalance, Precise.StringMul(contractsStringAbs, onePlusMaintenanceMarginPercentageString))
            var rightSide interface{} = Precise.StringDiv(entryPriceSignString, onePlusMaintenanceMarginPercentageString)
            liquidationPriceStringRaw = Precise.StringAdd(leftSide, rightSide)
        } else {
            // calculate liquidation price
            //
            // liquidationPrice = (contracts * contractSize(1 - mmp)) / (1/entryPrice * contracts * contractSize - walletBalance)
            //
            var onePlusMaintenanceMarginPercentageString interface{} = nil
            var entryPriceSignString interface{} = entryPriceString
            if IsTrue(IsEqual(side, "short")) {
                onePlusMaintenanceMarginPercentageString = Precise.StringSub("1", maintenanceMarginPercentageString)
            } else {
                onePlusMaintenanceMarginPercentageString = Precise.StringSub("-1", maintenanceMarginPercentageString)
                entryPriceSignString = Precise.StringMul("-1", entryPriceSignString)
            }
            var size interface{} = Precise.StringMul(contractsStringAbs, contractSizeString)
            var leftSide interface{} = Precise.StringMul(size, onePlusMaintenanceMarginPercentageString)
            var rightSide interface{} = Precise.StringSub(Precise.StringMul(Precise.StringDiv("1", entryPriceSignString), size), walletBalance)
            liquidationPriceStringRaw = Precise.StringDiv(leftSide, rightSide)
        }
        var pricePrecision interface{} = this.PrecisionFromString(this.SafeString(GetValue(market, "precision"), "price"))
        var pricePrecisionPlusOne interface{} = Add(pricePrecision, 1)
        var pricePrecisionPlusOneString interface{} = ToString(pricePrecisionPlusOne)
        // round half up
        rounder := NewPrecise(Add("5e-", pricePrecisionPlusOneString))
        var rounderString interface{} = ToString(rounder)
        var liquidationPriceRoundedString interface{} = Precise.StringAdd(rounderString, liquidationPriceStringRaw)
        var truncatedLiquidationPrice interface{} = Precise.StringDiv(liquidationPriceRoundedString, "1", pricePrecision)
        if IsTrue(IsEqual(GetValue(truncatedLiquidationPrice, 0), "-")) {
            // user cannot be liquidated
            // since he has more collateral than the size of the position
            truncatedLiquidationPrice = nil
        }
        liquidationPrice = this.ParseNumber(truncatedLiquidationPrice)
    }
    var positionSide interface{} = this.SafeString(position, "positionSide")
    var hedged interface{} = !IsEqual(positionSide, "BOTH")
    return map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "initialMargin": initialMargin,
        "initialMarginPercentage": this.ParseNumber(initialMarginPercentageString),
        "maintenanceMargin": maintenanceMargin,
        "maintenanceMarginPercentage": maintenanceMarginPercentage,
        "entryPrice": entryPrice,
        "notional": notional,
        "leverage": this.ParseNumber(leverageString),
        "unrealizedPnl": unrealizedPnl,
        "contracts": contracts,
        "contractSize": contractSize,
        "marginRatio": marginRatio,
        "liquidationPrice": liquidationPrice,
        "markPrice": nil,
        "collateral": collateral,
        "marginMode": marginMode,
        "side": side,
        "hedged": hedged,
        "percentage": percentage,
    }
}
/**
 * @method
 * @name aster#fetchAccountPositions
 * @ignore
 * @description fetch account positions
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} data on account positions
 */
func  (this *AsterCore) FetchAccountPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(symbols, nil)) {
                if !IsTrue(IsArray(symbols)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchPositions() requires an array argument for symbols")))
                }
            }
        
            retRes34648 := (<-this.LoadMarkets())
            PanicOnError(retRes34648)
        
            retRes34658 := (<-this.LoadLeverageBrackets(false, params))
            PanicOnError(retRes34658)
        
            response:= (<-this.FapiPrivateGetV4Account(params))
            PanicOnError(response)
            var filterClosed interface{} = nil
            filterClosedparamsVariable := this.HandleOptionAndParams(params, "fetchAccountPositions", "filterClosed", false);
            filterClosed = GetValue(filterClosedparamsVariable,0);
            params = GetValue(filterClosedparamsVariable,1)
            var result interface{} = this.ParseAccountPositions(response, filterClosed)
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) LoadLeverageBrackets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    reload := GetArg(optionalArgs, 0, false)
            _ = reload
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34758 := (<-this.LoadMarkets())
            PanicOnError(retRes34758)
            // by default cache the leverage bracket
            // it contains useful stuff like the maintenance margin and initial margin for positions
            var leverageBrackets interface{} = this.SafeDict(this.Options, "leverageBrackets")
            if IsTrue(IsTrue((IsEqual(leverageBrackets, nil))) || IsTrue((reload))) {
        
                response:= (<-this.FapiPrivateGetV1LeverageBracket(params))
                PanicOnError(response)
                AddElementToObject(this.Options, "leverageBrackets", this.CreateSafeDictionary())
                for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                    var entry interface{} = GetValue(response, i)
                    var marketId interface{} = this.SafeString(entry, "symbol")
                    var symbol interface{} = this.SafeSymbol(marketId, nil, nil, "contract")
                    var brackets interface{} = this.SafeList(entry, "brackets", []interface{}{})
                    var result interface{} = []interface{}{}
                    for j := 0; IsLessThan(j, GetArrayLength(brackets)); j++ {
                        var bracket interface{} = GetValue(brackets, j)
                        var floorValue interface{} = this.SafeString(bracket, "notionalFloor")
                        var maintenanceMarginPercentage interface{} = this.SafeString(bracket, "maintMarginRatio")
                        AppendToArray(&result, []interface{}{floorValue, maintenanceMarginPercentage})
                    }
                    AddElementToObject(GetValue(this.Options, "leverageBrackets"), symbol, result)
                }
            }
        
            ch <- GetValue(this.Options, "leverageBrackets")
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) KeccakMessage(message interface{}) interface{}  {
    return Add("0x", this.Hash(message, keccak, "hex"))
}
func  (this *AsterCore) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.KeccakMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func  (this *AsterCore) SignWithdrawPayload(withdrawPayload interface{}, network interface{}) interface{}  {
    var zeroAddress interface{} = this.SafeString(this.Options, "zeroAddress")
    var chainId interface{} = this.SafeInteger(withdrawPayload, "chainId")
    var domain interface{} = map[string]interface{} {
        "chainId": chainId,
        "name": "Aster",
        "verifyingContract": zeroAddress,
        "version": "1",
    }
    var messageTypes interface{} = map[string]interface{} {
        "Action": []interface{}{map[string]interface{} {
    "name": "type",
    "type": "string",
}, map[string]interface{} {
    "name": "destination",
    "type": "address",
}, map[string]interface{} {
    "name": "destination Chain",
    "type": "string",
}, map[string]interface{} {
    "name": "token",
    "type": "string",
}, map[string]interface{} {
    "name": "amount",
    "type": "string",
}, map[string]interface{} {
    "name": "fee",
    "type": "string",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint256",
}, map[string]interface{} {
    "name": "aster chain",
    "type": "string",
}},
    }
    var withdraw interface{} = map[string]interface{} {
        "type": "Withdraw",
        "destination": this.SafeString(withdrawPayload, "receiver"),
        "destination Chain": network,
        "token": this.SafeString(withdrawPayload, "asset"),
        "amount": this.SafeString(withdrawPayload, "amount"),
        "fee": this.SafeString(withdrawPayload, "fee"),
        "nonce": this.SafeInteger(withdrawPayload, "nonce"),
        "aster chain": "Mainnet",
    }
    var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, withdraw)
    var signature interface{} = this.SignMessage(msg, this.PrivateKey)
    return signature
}
/**
 * @method
 * @name aster#withdraw
 * @description make a withdrawal
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#withdraw-user_data
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *AsterCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes35598 := (<-this.LoadMarkets())
            PanicOnError(retRes35598)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "receiver": address,
                "nonce": Multiply(this.Milliseconds(), 1000),
            }
            var chainId interface{} = this.SafeInteger(params, "chainId")
            // TODO: check how ARBI signature would work
            var networks interface{} = this.SafeDict(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network")
            network = this.SafeString(networks, network, network)
            if IsTrue(IsTrue((IsEqual(chainId, nil))) && IsTrue((!IsEqual(network, nil)))) {
                var chainIds interface{} = this.SafeDict(this.Options, "networksToChainId", map[string]interface{} {})
                chainId = this.SafeInteger(chainIds, network)
            }
            if IsTrue(IsEqual(chainId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " withdraw require chainId or network parameter")))
            }
            AddElementToObject(request, "chainId", chainId)
            var fee interface{} = this.SafeString(params, "fee")
            if IsTrue(IsEqual(fee, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " withdraw require fee parameter")))
            }
            AddElementToObject(request, "fee", fee)
            params = this.Omit(params, []interface{}{"chainId", "network", "fee"})
            AddElementToObject(request, "amount", this.CurrencyToPrecision(code, amount, network))
            AddElementToObject(request, "userSignature", this.SignWithdrawPayload(request, network))
        
            response:= (<-this.SapiPrivatePostV1AsterUserWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- map[string]interface{} {
                "info": response,
                "id": this.SafeString(response, "withdrawId"),
                "txid": this.SafeString(response, "hash"),
                "timestamp": nil,
                "datetime": nil,
                "network": network,
                "address": address,
                "addressTo": address,
                "addressFrom": nil,
                "tag": tag,
                "tagTo": tag,
                "tagFrom": nil,
                "type": "withdrawal",
                "amount": amount,
                "currency": code,
                "status": nil,
                "updated": nil,
                "internal": nil,
                "comment": nil,
                "fee": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#transfer-asset-to-other-address-trade
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#transfer-between-futures-and-spot-user_data
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *AsterCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes36268 := (<-this.LoadMarkets())
            PanicOnError(retRes36268)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
            var typeVar interface{} = nil
            var fromId interface{} = nil
            if IsTrue(!IsEqual(fromAccount, nil)) {
                fromId = ToUpper(this.ConvertTypeToAccount(fromAccount))
            }
            var toId interface{} = nil
            if IsTrue(!IsEqual(toAccount, nil)) {
                toId = ToUpper(this.ConvertTypeToAccount(toAccount))
            }
            if IsTrue(IsTrue(IsEqual(fromId, "SPOT")) && IsTrue(IsEqual(toId, "FUTURE"))) {
                typeVar = "SPOT_FUTURE"
            } else if IsTrue(IsTrue(IsEqual(fromId, "FUTURE")) && IsTrue(IsEqual(toId, "SPOT"))) {
                typeVar = "FUTURE_SPOT"
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(typeVar, nil)) {
                var defaultClientTranId interface{} = this.NumberToString(this.Milliseconds())
                var clientTranId interface{} = this.SafeString(params, "clientTranId", defaultClientTranId)
                AddElementToObject(request, "kindType", typeVar)
                AddElementToObject(request, "clientTranId", clientTranId)
                
            response = (<-this.FapiPrivatePostV1AssetWalletTransfer(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                // transfer asset to other address
                AddElementToObject(request, "toAddress", toAccount)
                
            response = (<-this.SapiPrivatePostV1AssetSendToAddress(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
                //
            //     {
            //         "tranId":13526853623,
            //         "status": "SUCCESS"
            //     }
            //
        ch <- map[string]interface{} {
                "info": response,
                "id": this.SafeString(response, "tranId"),
                "txid": nil,
                "timestamp": nil,
                "datetime": nil,
                "network": nil,
                "address": nil,
                "addressTo": fromAccount,
                "addressFrom": toAccount,
                "tag": nil,
                "tagTo": nil,
                "tagFrom": nil,
                "type": "transfer",
                "amount": amount,
                "currency": code,
                "status": nil,
                "updated": nil,
                "internal": nil,
                "comment": nil,
                "fee": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HashMessage(binaryMessage interface{}) interface{}  {
    // const binaryMessage = this.encode (message);
    var binaryMessageLength interface{} = this.BinaryLength(binaryMessage)
    var x19 interface{} = this.Base16ToBinary("19")
    var newline interface{} = this.Base16ToBinary("0a")
    var prefix interface{} = this.BinaryConcat(x19, this.Encode("Ethereum Signed Message:"), newline, this.Encode(this.NumberToString(binaryMessageLength)))
    return Add("0x", this.Hash(this.BinaryConcat(prefix, binaryMessage), keccak, "hex"))
}
func  (this *AsterCore) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    this.CheckRequiredCredentials()
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    var r interface{} = GetValue(signature, "r")
    var s interface{} = GetValue(signature, "s")
    var v interface{} = this.IntToBase16(this.Sum(27, GetValue(signature, "v")))
    return Add(Add(Add("0x", PadStart(r, 64, "0")), PadStart(s, 64, "0")), v)
}
func  (this *AsterCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api)), "/"), path)
    if IsTrue(IsTrue(IsEqual(api, "fapiPublic")) || IsTrue(IsEqual(api, "sapiPublic"))) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Rawencode(params)))
        }
    } else if IsTrue(IsTrue(IsEqual(api, "fapiPrivate")) || IsTrue(IsEqual(api, "sapiPrivate"))) {
        this.CheckRequiredCredentials()
        headers = map[string]interface{} {
            "X-MBX-APIKEY": this.ApiKey,
        }
        var nonce interface{} = this.Milliseconds()
        var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
        var extendedParams interface{} = this.Extend(map[string]interface{} {
            "timestamp": nonce,
        }, params)
        if IsTrue(!IsEqual(defaultRecvWindow, nil)) {
            AddElementToObject(extendedParams, "recvWindow", defaultRecvWindow)
        }
        var recvWindow interface{} = this.SafeInteger(params, "recvWindow")
        if IsTrue(!IsEqual(recvWindow, nil)) {
            AddElementToObject(extendedParams, "recvWindow", recvWindow)
        }
        var query interface{} = nil
        if IsTrue(IsTrue((IsEqual(method, "DELETE"))) && IsTrue((IsEqual(path, "v1/batchOrders")))) {
            var orderidlist interface{} = this.SafeList(extendedParams, "orderIdList", []interface{}{})
            var origclientorderidlist interface{} = this.SafeList(extendedParams, "origClientOrderIdList", []interface{}{})
            extendedParams = this.Omit(extendedParams, []interface{}{"orderIdList", "origClientOrderIdList"})
            query = this.Rawencode(extendedParams)
            var orderidlistLength interface{} =             GetArrayLength(orderidlist)
            var origclientorderidlistLength interface{} =             GetArrayLength(origclientorderidlist)
            if IsTrue(IsGreaterThan(orderidlistLength, 0)) {
                query = Add(Add(Add(Add(query, "&"), "orderidlist=%5B"), Join(orderidlist, "%2C")), "%5D")
            }
            if IsTrue(IsGreaterThan(origclientorderidlistLength, 0)) {
                query = Add(Add(Add(Add(query, "&"), "origclientorderidlist=%5B"), Join(origclientorderidlist, "%2C")), "%5D")
            }
        } else {
            query = this.Rawencode(extendedParams)
        }
        var signature interface{} = ""
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(path, "v3"), 0)) {
            var signerAddress interface{} = GetValue(this.Options, "signerAddress")
            if IsTrue(IsEqual(signerAddress, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " requires signerAddress in options when use v3 api")))
            }
            // the keys order matter
            var keys interface{} = ObjectKeys(extendedParams)
            var sortedKeys interface{} = this.Sort(keys)
            var signingPayload interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(sortedKeys)); i++ {
                var key interface{} = GetValue(sortedKeys, i)
                AddElementToObject(signingPayload, key, ToString(GetValue(extendedParams, key)))
            }
            var signingHash interface{} = this.HashMessage(this.Hash(this.EthAbiEncode([]interface{}{"string", "address", "address", "uint256"}, []interface{}{this.Json(signingPayload), this.WalletAddress, signerAddress, nonce}), keccak, "binary"))
            signature = this.SignHash(signingHash, this.PrivateKey)
            AddElementToObject(extendedParams, "user", this.WalletAddress)
            AddElementToObject(extendedParams, "signer", signerAddress)
            AddElementToObject(extendedParams, "nonce", nonce)
            query = this.Rawencode(extendedParams)
        } else {
            signature = this.Hmac(this.Encode(query), this.Encode(this.Secret), sha256)
        }
        query = Add(query, Add(Add("&", "signature="), signature))
        if IsTrue(IsEqual(method, "GET")) {
            url = Add(url, Add("?", query))
        } else {
            body = query
            AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *AsterCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //    {
    //        "code": -1121,
    //        "msg": "Invalid symbol.",
    //    }
    //
    var code interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "msg")
    if IsTrue(IsTrue(!IsEqual(code, nil)) && IsTrue(!IsEqual(code, "200"))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *AsterCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
