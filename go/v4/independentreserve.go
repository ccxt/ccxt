package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type independentreserve struct {
    Exchange

}

func NewIndependentreserveCore() independentreserve {
   p := independentreserve{}
   setDefaults(&p)
   return p
}

func  (this *independentreserve) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "independentreserve",
        "name": "Independent Reserve",
        "countries": []interface{}{"AU", "NZ"},
        "rateLimit": 1000,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg",
            "api": map[string]interface{} {
                "public": "https://api.independentreserve.com/Public",
                "private": "https://api.independentreserve.com/Private",
            },
            "www": "https://www.independentreserve.com",
            "doc": "https://www.independentreserve.com/API",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"GetValidPrimaryCurrencyCodes", "GetValidSecondaryCurrencyCodes", "GetValidLimitOrderTypes", "GetValidMarketOrderTypes", "GetValidOrderTypes", "GetValidTransactionTypes", "GetMarketSummary", "GetOrderBook", "GetAllOrders", "GetTradeHistorySummary", "GetRecentTrades", "GetFxRates", "GetOrderMinimumVolumes", "GetCryptoWithdrawalFees", "GetCryptoWithdrawalFees2", "GetNetworks", "GetPrimaryCurrencyConfig2"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"GetOpenOrders", "GetClosedOrders", "GetClosedFilledOrders", "GetOrderDetails", "GetAccounts", "GetTransactions", "GetFiatBankAccounts", "GetDigitalCurrencyDepositAddress", "GetDigitalCurrencyDepositAddress2", "GetDigitalCurrencyDepositAddresses", "GetDigitalCurrencyDepositAddresses2", "GetTrades", "GetBrokerageFees", "GetDigitalCurrencyWithdrawal", "PlaceLimitOrder", "PlaceMarketOrder", "CancelOrder", "SynchDigitalCurrencyDepositAddressWithBlockchain", "RequestFiatWithdrawal", "WithdrawFiatCurrency", "WithdrawDigitalCurrency", "WithdrawCrypto"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "taker": this.ParseNumber("0.005"),
                "maker": this.ParseNumber("0.005"),
                "percentage": true,
                "tierBased": false,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "PLA": "PlayChip",
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "defaultNetworks": map[string]interface{} {
                "USDT": "Ethereum",
                "USDC": "Ethereum",
                "BTC": "Bitcoin",
                "BCH": "BitcoinCash",
                "ETH": "Ethereum",
                "LTC": "Litecoin",
                "XRP": "XrpLedger",
                "ZRX": "Ethereum",
                "EOS": "EosIo",
                "XLM": "Stellar",
                "BAT": "Ethereum",
                "ETC": "EthereumClassic",
                "LINK": "Ethereum",
                "MKR": "Ethereum",
                "DAI": "Ethereum",
                "COMP": "Ethereum",
                "SNX": "Ethereum",
                "YFI": "Ethereum",
                "AAVE": "Ethereum",
                "GRT": "Ethereum",
                "DOT": "Polkadot",
                "UNI": "Ethereum",
                "ADA": "Cardano",
                "MATIC": "Ethereum",
                "DOGE": "Dogecoin",
                "SOL": "Solana",
                "MANA": "Ethereum",
                "SAND": "Ethereum",
                "SHIB": "Ethereum",
                "TRX": "Tron",
                "RENDER": "Solana",
                "WIF": "Solana",
                "RLUSD": "Ethereum",
                "PEPE": "Ethereum",
            },
            "networks": map[string]interface{} {
                "BTC": "Bitcoin",
                "ETH": "Ethereum",
                "BCH": "BitcoinCash",
                "LTC": "Litecoin",
                "XRP": "XrpLedger",
                "EOS": "EosIo",
                "XLM": "Stellar",
                "ETC": "EthereumClassic",
                "BSV": "BitcoinSV",
                "DOGE": "Dogecoin",
                "DOT": "Polkadot",
                "ADA": "Cardano",
                "SOL": "Solana",
                "TRX": "Tron",
            },
        },
    })
}
/**
 * @method
 * @name independentreserve#fetchMarkets
 * @description retrieves data on all markets for independentreserve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *independentreserve) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var baseCurrenciesPromise interface{} = this.PublicGetGetValidPrimaryCurrencyCodes(params)
            //     ['Xbt', 'Eth', 'Usdt', ...]
            var quoteCurrenciesPromise interface{} = this.PublicGetGetValidSecondaryCurrencyCodes(params)
            //     ['Aud', 'Usd', 'Nzd', 'Sgd']
            var limitsPromise interface{} = this.PublicGetGetOrderMinimumVolumes(params)
            baseCurrenciesquoteCurrencieslimitsVariable := (<-promiseAll([]interface{}{baseCurrenciesPromise, quoteCurrenciesPromise, limitsPromise}));
            baseCurrencies := GetValue(baseCurrenciesquoteCurrencieslimitsVariable,0);
            quoteCurrencies := GetValue(baseCurrenciesquoteCurrencieslimitsVariable,1);
            limits := GetValue(baseCurrenciesquoteCurrencieslimitsVariable,2)
            //
            //     {
            //         "Xbt": 0.0001,
            //         "Eth": 0.001,
            //         "Ltc": 0.01,
            //         "Xrp": 1.0,
            //     }
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(baseCurrencies)); i++ {
                var baseId interface{} = GetValue(baseCurrencies, i)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var minAmount interface{} = this.SafeNumber(limits, baseId)
                for j := 0; IsLessThan(j, GetArrayLength(quoteCurrencies)); j++ {
                    var quoteId interface{} = GetValue(quoteCurrencies, j)
                    var quote interface{} = this.SafeCurrencyCode(quoteId)
                    var id interface{} = Add(Add(baseId, "/"), quoteId)
                    AppendToArray(&result,map[string]interface{} {
                        "id": id,
                        "symbol": Add(Add(base, "/"), quote),
                        "base": base,
                        "quote": quote,
                        "settle": nil,
                        "baseId": baseId,
                        "quoteId": quoteId,
                        "settleId": nil,
                        "type": "spot",
                        "spot": true,
                        "margin": false,
                        "swap": false,
                        "future": false,
                        "option": false,
                        "active": nil,
                        "contract": false,
                        "linear": nil,
                        "inverse": nil,
                        "contractSize": nil,
                        "expiry": nil,
                        "expiryDatetime": nil,
                        "strike": nil,
                        "optionType": nil,
                        "precision": map[string]interface{} {
                            "amount": nil,
                            "price": nil,
                        },
                        "limits": map[string]interface{} {
                            "leverage": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                            "amount": map[string]interface{} {
                                "min": minAmount,
                                "max": nil,
                            },
                            "price": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                            "cost": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                        },
                        "created": nil,
                        "info": id,
                    })
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "CurrencyCode")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "AvailableBalance"))
        AddElementToObject(account, "total", this.SafeString(balance, "TotalBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name independentreserve#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *independentreserve) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3868 := (<-this.LoadMarkets())
            PanicOnError(retRes3868)
        
            response:= (<-this.PrivatePostGetAccounts(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *independentreserve) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4018 := (<-this.LoadMarkets())
            PanicOnError(retRes4018)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "primaryCurrencyCode": GetValue(market, "baseId"),
                "secondaryCurrencyCode": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.PublicGetGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            var timestamp interface{} = this.Parse8601(this.SafeString(response, "CreatedTimestampUtc"))
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp, "BuyOrders", "SellOrders", "Price", "Volume")
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //     "DayHighestPrice":43489.49,
    //     "DayLowestPrice":41998.32,
    //     "DayAvgPrice":42743.9,
    //     "DayVolumeXbt":44.54515625000,
    //     "DayVolumeXbtInSecondaryCurrrency":0.12209818,
    //     "CurrentLowestOfferPrice":43619.64,
    //     "CurrentHighestBidPrice":43153.58,
    //     "LastPrice":43378.43,
    //     "PrimaryCurrencyCode":"Xbt",
    //     "SecondaryCurrencyCode":"Usd",
    //     "CreatedTimestampUtc":"2022-01-14T22:52:29.5029223Z"
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "CreatedTimestampUtc"))
    var baseId interface{} = this.SafeString(ticker, "PrimaryCurrencyCode")
    var quoteId interface{} = this.SafeString(ticker, "SecondaryCurrencyCode")
    var defaultMarketId interface{} = nil
    if IsTrue(IsTrue((!IsEqual(baseId, nil))) && IsTrue((!IsEqual(quoteId, nil)))) {
        defaultMarketId = Add(Add(baseId, "/"), quoteId)
    }
    market = this.SafeMarket(defaultMarketId, market, "/")
    var symbol interface{} = GetValue(market, "symbol")
    var last interface{} = this.SafeString(ticker, "LastPrice")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "DayHighestPrice"),
        "low": this.SafeString(ticker, "DayLowestPrice"),
        "bid": this.SafeString(ticker, "CurrentHighestBidPrice"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "CurrentLowestOfferPrice"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": this.SafeString(ticker, "DayAvgPrice"),
        "baseVolume": this.SafeString(ticker, "DayVolumeXbtInSecondaryCurrrency"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name independentreserve#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *independentreserve) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4698 := (<-this.LoadMarkets())
            PanicOnError(retRes4698)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "primaryCurrencyCode": GetValue(market, "baseId"),
                "secondaryCurrencyCode": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.PublicGetGetMarketSummary(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "DayHighestPrice":43489.49,
            //     "DayLowestPrice":41998.32,
            //     "DayAvgPrice":42743.9,
            //     "DayVolumeXbt":44.54515625000,
            //     "DayVolumeXbtInSecondaryCurrrency":0.12209818,
            //     "CurrentLowestOfferPrice":43619.64,
            //     "CurrentHighestBidPrice":43153.58,
            //     "LastPrice":43378.43,
            //     "PrimaryCurrencyCode":"Xbt",
            //     "SecondaryCurrencyCode":"Usd",
            //     "CreatedTimestampUtc":"2022-01-14T22:52:29.5029223Z"
            // }
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrder
    //
    //     {
    //         "OrderGuid": "c7347e4c-b865-4c94-8f74-d934d4b0b177",
    //         "CreatedTimestampUtc": "2014-09-23T12:39:34.3817763Z",
    //         "Type": "MarketBid",
    //         "VolumeOrdered": 5.0,
    //         "VolumeFilled": 5.0,
    //         "Price": null,
    //         "AvgPrice": 100.0,
    //         "ReservedAmount": 0.0,
    //         "Status": "Filled",
    //         "PrimaryCurrencyCode": "Xbt",
    //         "SecondaryCurrencyCode": "Usd"
    //     }
    //
    // fetchOpenOrders & fetchClosedOrders
    //
    //     {
    //         "OrderGuid": "b8f7ad89-e4e4-4dfe-9ea3-514d38b5edb3",
    //         "CreatedTimestampUtc": "2020-09-08T03:04:18.616367Z",
    //         "OrderType": "LimitOffer",
    //         "Volume": 0.0005,
    //         "Outstanding": 0.0005,
    //         "Price": 113885.83,
    //         "AvgPrice": 113885.83,
    //         "Value": 56.94,
    //         "Status": "Open",
    //         "PrimaryCurrencyCode": "Xbt",
    //         "SecondaryCurrencyCode": "Usd",
    //         "FeePercent": 0.005,
    //     }
    //
    // cancelOrder
    //
    //    {
    //        "AvgPrice": 455.48,
    //        "CreatedTimestampUtc": "2022-08-05T06:42:11.3032208Z",
    //        "OrderGuid": "719c495c-a39e-4884-93ac-280b37245037",
    //        "Price": 485.76,
    //        "PrimaryCurrencyCode": "Xbt",
    //        "ReservedAmount": 0.358,
    //        "SecondaryCurrencyCode": "Usd",
    //        "Status": "Cancelled",
    //        "Type": "LimitOffer",
    //        "VolumeFilled": 0,
    //        "VolumeOrdered": 0.358
    //    }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = nil
    var baseId interface{} = this.SafeString(order, "PrimaryCurrencyCode")
    var quoteId interface{} = this.SafeString(order, "SecondaryCurrencyCode")
    var base interface{} = nil
    var quote interface{} = nil
    if IsTrue(IsTrue((!IsEqual(baseId, nil))) && IsTrue((!IsEqual(quoteId, nil)))) {
        base = this.SafeCurrencyCode(baseId)
        quote = this.SafeCurrencyCode(quoteId)
        symbol = Add(Add(base, "/"), quote)
    } else if IsTrue(!IsEqual(market, nil)) {
        symbol = GetValue(market, "symbol")
        base = GetValue(market, "base")
        quote = GetValue(market, "quote")
    }
    var orderType interface{} = this.SafeString2(order, "Type", "OrderType")
    var side interface{} = nil
    if IsTrue(!IsEqual(orderType, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(orderType, "Bid"), 0)) {
            side = "buy"
        } else if IsTrue(IsGreaterThanOrEqual(GetIndexOf(orderType, "Offer"), 0)) {
            side = "sell"
        }
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(orderType, "Market"), 0)) {
            orderType = "market"
        } else if IsTrue(IsGreaterThanOrEqual(GetIndexOf(orderType, "Limit"), 0)) {
            orderType = "limit"
        }
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "CreatedTimestampUtc"))
    var filled interface{} = this.SafeString(order, "VolumeFilled")
    var feeRate interface{} = this.SafeString(order, "FeePercent")
    var feeCost interface{} = nil
    if IsTrue(IsTrue(!IsEqual(feeRate, nil)) && IsTrue(!IsEqual(filled, nil))) {
        feeCost = Precise.StringMul(feeRate, filled)
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "OrderGuid"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": orderType,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "Price"),
        "triggerPrice": nil,
        "cost": this.SafeString(order, "Value"),
        "average": this.SafeString(order, "AvgPrice"),
        "amount": this.SafeString2(order, "VolumeOrdered", "Volume"),
        "filled": filled,
        "remaining": this.SafeString(order, "Outstanding"),
        "status": this.ParseOrderStatus(this.SafeString(order, "Status")),
        "fee": map[string]interface{} {
            "rate": feeRate,
            "cost": feeCost,
            "currency": base,
        },
        "trades": nil,
    }, market)
}
func  (this *independentreserve) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Open": "open",
        "PartiallyFilled": "open",
        "Filled": "closed",
        "PartiallyFilledAndCancelled": "canceled",
        "Cancelled": "canceled",
        "PartiallyFilledAndExpired": "canceled",
        "Expired": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name independentreserve#fetchOrder
 * @description fetches information on an order made by the user
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *independentreserve) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6298 := (<-this.LoadMarkets())
            PanicOnError(retRes6298)
        
            response:= (<-this.PrivatePostGetOrderDetails(this.Extend(map[string]interface{} {
            "orderGuid": id,
        }, params)))
            PanicOnError(response)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *independentreserve) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6518 := (<-this.LoadMarkets())
            PanicOnError(retRes6518)
            var request interface{} = this.Ordered(map[string]interface{} {})
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "primaryCurrencyCode", GetValue(market, "baseId"))
                AddElementToObject(request, "secondaryCurrencyCode", GetValue(market, "quoteId"))
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 50
            }
            AddElementToObject(request, "pageIndex", 1)
            AddElementToObject(request, "pageSize", limit)
        
            response:= (<-this.PrivatePostGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "Data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *independentreserve) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6808 := (<-this.LoadMarkets())
            PanicOnError(retRes6808)
            var request interface{} = this.Ordered(map[string]interface{} {})
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "primaryCurrencyCode", GetValue(market, "baseId"))
                AddElementToObject(request, "secondaryCurrencyCode", GetValue(market, "quoteId"))
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 50
            }
            AddElementToObject(request, "pageIndex", 1)
            AddElementToObject(request, "pageSize", limit)
        
            response:= (<-this.PrivatePostGetClosedOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "Data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchMyTrades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *independentreserve) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 50)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7098 := (<-this.LoadMarkets())
            PanicOnError(retRes7098)
            var pageIndex interface{} = this.SafeInteger(params, "pageIndex", 1)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 50
            }
            var request interface{} = this.Ordered(map[string]interface{} {
                "pageIndex": pageIndex,
                "pageSize": limit,
            })
        
            response:= (<-this.PrivatePostGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            ch <- this.ParseTrades(GetValue(response, "Data"), market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(GetValue(trade, "TradeTimestampUtc"))
    var id interface{} = this.SafeString(trade, "TradeGuid")
    var orderId interface{} = this.SafeString(trade, "OrderGuid")
    var priceString interface{} = this.SafeString2(trade, "Price", "SecondaryCurrencyTradePrice")
    var amountString interface{} = this.SafeString2(trade, "VolumeTraded", "PrimaryCurrencyAmount")
    var price interface{} = this.ParseNumber(priceString)
    var amount interface{} = this.ParseNumber(amountString)
    var cost interface{} = this.ParseNumber(Precise.StringMul(priceString, amountString))
    var baseId interface{} = this.SafeString(trade, "PrimaryCurrencyCode")
    var quoteId interface{} = this.SafeString(trade, "SecondaryCurrencyCode")
    var marketId interface{} = nil
    if IsTrue(IsTrue((!IsEqual(baseId, nil))) && IsTrue((!IsEqual(quoteId, nil)))) {
        marketId = Add(Add(baseId, "/"), quoteId)
    }
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var side interface{} = this.SafeString(trade, "OrderType")
    if IsTrue(!IsEqual(side, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(side, "Bid"), 0)) {
            side = "buy"
        } else if IsTrue(IsGreaterThanOrEqual(GetIndexOf(side, "Offer"), 0)) {
            side = "sell"
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name independentreserve#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *independentreserve) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7788 := (<-this.LoadMarkets())
            PanicOnError(retRes7788)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "primaryCurrencyCode": GetValue(market, "baseId"),
                "secondaryCurrencyCode": GetValue(market, "quoteId"),
                "numberOfRecentTradesToRetrieve": 50,
            }
        
            response:= (<-this.PublicGetGetRecentTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "Trades"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *independentreserve) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7978 := (<-this.LoadMarkets())
            PanicOnError(retRes7978)
        
            response:= (<-this.PrivatePostGetBrokerageFees(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "CurrencyCode": "Xbt",
            //             "Fee": 0.005
            //         }
            //         ...
            //     ]
            //
            var fees interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var fee interface{} = GetValue(response, i)
                var currencyId interface{} = this.SafeString(fee, "CurrencyCode")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var tradingFee interface{} = this.SafeNumber(fee, "Fee")
                AddElementToObject(fees, code, map[string]interface{} {
            "info": fee,
            "fee": tradingFee,
        })
            }
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                var market interface{} = this.Market(symbol)
                var fee interface{} = this.SafeValue(fees, GetValue(market, "base"), map[string]interface{} {})
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": this.SafeValue(fee, "info"),
            "symbol": symbol,
            "maker": this.SafeNumber(fee, "fee"),
            "taker": this.SafeNumber(fee, "fee"),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#createOrder
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *independentreserve) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8498 := (<-this.LoadMarkets())
            PanicOnError(retRes8498)
            var market interface{} = this.Market(symbol)
            var orderType interface{} = this.Capitalize(typeVar)
            orderType = Add(orderType, Ternary(IsTrue((IsEqual(side, "sell"))), "Offer", "Bid"))
            var request interface{} = this.Ordered(map[string]interface{} {
                "primaryCurrencyCode": GetValue(market, "baseId"),
                "secondaryCurrencyCode": GetValue(market, "quoteId"),
                "orderType": orderType,
            })
            var response interface{} = nil
            AddElementToObject(request, "volume", amount)
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", price)
                
        response = (<-this.PrivatePostPlaceLimitOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostPlaceMarketOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": GetValue(response, "OrderGuid"),
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#cancelOrder
 * @description cancels an open order
 * @see https://www.independentreserve.com/features/api#CancelOrder
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *independentreserve) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8838 := (<-this.LoadMarkets())
            PanicOnError(retRes8838)
            var request interface{} = map[string]interface{} {
                "orderGuid": id,
            }
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "AvgPrice": 455.48,
            //        "CreatedTimestampUtc": "2022-08-05T06:42:11.3032208Z",
            //        "OrderGuid": "719c495c-a39e-4884-93ac-280b37245037",
            //        "Price": 485.76,
            //        "PrimaryCurrencyCode": "Xbt",
            //        "ReservedAmount": 0.358,
            //        "SecondaryCurrencyCode": "Usd",
            //        "Status": "Cancelled",
            //        "Type": "LimitOffer",
            //        "VolumeFilled": 0,
            //        "VolumeOrdered": 0.358
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name independentreserve#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.independentreserve.com/features/api#GetDigitalCurrencyDepositAddress
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *independentreserve) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9168 := (<-this.LoadMarkets())
            PanicOnError(retRes9168)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "primaryCurrencyCode": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivatePostGetDigitalCurrencyDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        Tag: '3307446684',
            //        DepositAddress: 'GCCQH4HACMRAD56EZZZ4TOIDQQRVNADMJ35QOFWF4B2VQGODMA2WVQ22',
            //        LastCheckedTimestampUtc: '2024-02-20T11:13:35.6912985Z',
            //        NextUpdateTimestampUtc: '2024-02-20T11:14:56.5112394Z'
            //    }
            //
        ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        Tag: '3307446684',
    //        DepositAddress: 'GCCQH4HACMRAD56EZZZ4TOIDQQRVNADMJ35QOFWF4B2VQGODMA2WVQ22',
    //        LastCheckedTimestampUtc: '2024-02-20T11:13:35.6912985Z',
    //        NextUpdateTimestampUtc: '2024-02-20T11:14:56.5112394Z'
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "DepositAddress")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeString(currency, "code"),
        "network": nil,
        "address": address,
        "tag": this.SafeString(depositAddress, "Tag"),
    }
}
/**
 * @method
 * @name independentreserve#withdraw
 * @description make a withdrawal
 * @see https://www.independentreserve.com/features/api#WithdrawDigitalCurrency
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {object} [params.comment] withdrawal comment, should not exceed 500 characters
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *independentreserve) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes9708 := (<-this.LoadMarkets())
            PanicOnError(retRes9708)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "primaryCurrencyCode": GetValue(currency, "id"),
                "withdrawalAddress": address,
                "amount": this.CurrencyToPrecision(code, amount),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "destinationTag", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                panic(BadRequest(Add(this.Id, " withdraw () does not accept params[\"networkCode\"]")))
            }
        
            response:= (<-this.PrivatePostWithdrawDigitalCurrency(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "TransactionGuid": "dc932e19-562b-4c50-821e-a73fd048b93b",
            //        "PrimaryCurrencyCode": "Bch",
            //        "CreatedTimestampUtc": "2020-04-01T05:26:30.5093622+00:00",
            //        "Amount": {
            //            "Total": 0.1231,
            //            "Fee": 0.0001
            //        },
            //        "Destination": {
            //            "Address": "bc1qhpqxkjpvgkckw530yfmxyr53c94q8f4273a7ez",
            //            "Tag": null
            //        },
            //        "Status": "Pending",
            //        "Transaction": null
            //    }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *independentreserve) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "TransactionGuid": "dc932e19-562b-4c50-821e-a73fd048b93b",
    //        "PrimaryCurrencyCode": "Bch",
    //        "CreatedTimestampUtc": "2020-04-01T05:26:30.5093622+00:00",
    //        "Amount": {
    //            "Total": 0.1231,
    //            "Fee": 0.0001
    //        },
    //        "Destination": {
    //            "Address": "bc1qhpqxkjpvgkckw530yfmxyr53c94q8f4273a7ez",
    //            "Tag": null
    //        },
    //        "Status": "Pending",
    //        "Transaction": null
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var amount interface{} = this.SafeDict(transaction, "Amount")
    var destination interface{} = this.SafeDict(transaction, "Destination")
    var currencyId interface{} = this.SafeString(transaction, "PrimaryCurrencyCode")
    var datetime interface{} = this.SafeString(transaction, "CreatedTimestampUtc")
    var address interface{} = this.SafeString(destination, "Address")
    var tag interface{} = this.SafeString(destination, "Tag")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "TransactionGuid"),
        "txid": nil,
        "type": "withdraw",
        "currency": code,
        "network": nil,
        "amount": this.SafeNumber(amount, "Total"),
        "status": this.SafeString(transaction, "Status"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "address": address,
        "addressFrom": nil,
        "addressTo": address,
        "tag": tag,
        "tagFrom": nil,
        "tagTo": tag,
        "updated": nil,
        "comment": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.SafeNumber(amount, "Fee"),
            "rate": nil,
        },
        "internal": false,
    }
}
func  (this *independentreserve) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Nonce()
        var auth interface{} = []interface{}{url, Add("apiKey=", this.ApiKey), Add("nonce=", ToString(nonce))}
        var keys interface{} = ObjectKeys(params)
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            var key interface{} = GetValue(keys, i)
            var value interface{} = ToString(GetValue(params, key))
            AppendToArray(&auth,Add(Add(key, "="), value))
        }
        var message interface{} = Join(auth, ",")
        var signature interface{} = this.Hmac(this.Encode(message), this.Encode(this.Secret), sha256)
        var query interface{} = this.Ordered(map[string]interface{} {})
        AddElementToObject(query, "apiKey", this.ApiKey)
        AddElementToObject(query, "nonce", nonce)
        AddElementToObject(query, "signature", ToUpper(signature))
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            var key interface{} = GetValue(keys, i)
            AddElementToObject(query, key, GetValue(params, key))
        }
        body = this.Json(query)
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *independentreserve) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
