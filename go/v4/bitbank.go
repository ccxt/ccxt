package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitbank struct {
    Exchange

}

func NewBitbankCore() bitbank {
   p := bitbank{}
   setDefaults(&p)
   return p
}

func  (this *bitbank) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitbank",
        "name": "bitbank",
        "countries": []interface{}{"JP"},
        "version": "v1",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "5m": "5min",
            "15m": "15min",
            "30m": "30min",
            "1h": "1hour",
            "4h": "4hour",
            "8h": "8hour",
            "12h": "12hour",
            "1d": "1day",
            "1w": "1week",
        },
        "hostname": "bitbank.cc",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/9d616de0-8a88-4468-8e38-d269acab0348",
            "api": map[string]interface{} {
                "public": "https://public.{hostname}",
                "private": "https://api.{hostname}",
                "markets": "https://api.{hostname}",
            },
            "www": "https://bitbank.cc/",
            "doc": "https://docs.bitbank.cc/",
            "fees": "https://bitbank.cc/docs/fees/",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"{pair}/ticker", "tickers", "tickers_jpy", "{pair}/depth", "{pair}/transactions", "{pair}/transactions/{yyyymmdd}", "{pair}/candlestick/{candletype}/{yyyymmdd}", "{pair}/circuit_break_info"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"user/assets", "user/spot/order", "user/spot/active_orders", "user/margin/positions", "user/spot/trade_history", "user/deposit_history", "user/unconfirmed_deposits", "user/deposit_originators", "user/withdrawal_account", "user/withdrawal_history", "spot/status", "spot/pairs"},
                "post": []interface{}{"user/spot/order", "user/spot/cancel_order", "user/spot/cancel_orders", "user/spot/orders_info", "user/confirm_deposits", "user/confirm_deposits_all", "user/request_withdrawal"},
            },
            "markets": map[string]interface{} {
                "get": []interface{}{"spot/pairs"},
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "20001": AuthenticationError,
                "20002": AuthenticationError,
                "20003": AuthenticationError,
                "20005": AuthenticationError,
                "20004": InvalidNonce,
                "40020": InvalidOrder,
                "40021": InvalidOrder,
                "40025": ExchangeError,
                "40013": OrderNotFound,
                "40014": OrderNotFound,
                "50008": PermissionDenied,
                "50009": OrderNotFound,
                "50010": OrderNotFound,
                "60001": InsufficientFunds,
                "60005": InvalidOrder,
            },
        },
    })
}
/**
 * @method
 * @name bitbank#fetchMarkets
 * @description retrieves data on all markets for bitbank
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#get-all-pairs-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitbank) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.MarketsGetSpotPairs(params))
            PanicOnError(response)
            //
            //     {
            //       "success": 1,
            //       "data": {
            //         "pairs": [
            //           {
            //             "name": "btc_jpy",
            //             "base_asset": "btc",
            //             "quote_asset": "jpy",
            //             "maker_fee_rate_base": "0",
            //             "taker_fee_rate_base": "0",
            //             "maker_fee_rate_quote": "-0.0002",
            //             "taker_fee_rate_quote": "0.0012",
            //             "unit_amount": "0.0001",
            //             "limit_max_amount": "1000",
            //             "market_max_amount": "10",
            //             "market_allowance_rate": "0.2",
            //             "price_digits": 0,
            //             "amount_digits": 4,
            //             "is_enabled": true,
            //             "stop_order": false,
            //             "stop_order_and_cancel": false
            //           }
            //         ]
            //       }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            var pairs interface{} = this.SafeValue(data, "pairs", []interface{}{})
        
            ch <- this.ParseMarkets(pairs)
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseMarket(entry interface{}) interface{}  {
    var id interface{} = this.SafeString(entry, "name")
    var baseId interface{} = this.SafeString(entry, "base_asset")
    var quoteId interface{} = this.SafeString(entry, "quote_asset")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": this.SafeValue(entry, "is_enabled"),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.SafeNumber(entry, "taker_fee_rate_quote"),
        "maker": this.SafeNumber(entry, "maker_fee_rate_quote"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "amount_digits"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "price_digits"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(entry, "unit_amount"),
                "max": this.SafeNumber(entry, "limit_max_amount"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": entry,
    }
}
func  (this *bitbank) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "vol"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitbank#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/public-api.md#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitbank) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3738 := (<-this.LoadMarkets())
            PanicOnError(retRes3738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPairTicker(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/public-api.md#depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitbank) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3948 := (<-this.LoadMarkets())
            PanicOnError(retRes3948)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPairDepth(this.Extend(request, params)))
            PanicOnError(response)
            var orderbook interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //    {
    //        "transaction_id": "1143247037",
    //        "side": "buy",
    //        "price": "3836025",
    //        "amount": "0.0005",
    //        "executed_at": "1694249441593"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "executed_at")
    market = this.SafeMarket(nil, market)
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var id interface{} = this.SafeString2(trade, "transaction_id", "trade_id")
    var takerOrMaker interface{} = this.SafeString(trade, "maker_taker")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee_amount_quote")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        fee = map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": feeCostString,
        }
    }
    var orderId interface{} = this.SafeString(trade, "order_id")
    var typeVar interface{} = this.SafeString(trade, "type")
    var side interface{} = this.SafeString(trade, "side")
    return this.SafeTrade(map[string]interface{} {
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "id": id,
        "order": orderId,
        "type": typeVar,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name bitbank#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/public-api.md#transactions
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitbank) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4638 := (<-this.LoadMarkets())
            PanicOnError(retRes4638)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPairTransactions(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "transactions", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#get-all-pairs-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *bitbank) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4838 := (<-this.LoadMarkets())
            PanicOnError(retRes4838)
        
            response:= (<-this.MarketsGetSpotPairs(params))
            PanicOnError(response)
            //
            //     {
            //         "success": "1",
            //         "data": {
            //           "pairs": [
            //             {
            //               "name": "btc_jpy",
            //               "base_asset": "btc",
            //               "quote_asset": "jpy",
            //               "maker_fee_rate_base": "0",
            //               "taker_fee_rate_base": "0",
            //               "maker_fee_rate_quote": "-0.0002",
            //               "taker_fee_rate_quote": "0.0012",
            //               "unit_amount": "0.0001",
            //               "limit_max_amount": "1000",
            //               "market_max_amount": "10",
            //               "market_allowance_rate": "0.2",
            //               "price_digits": "0",
            //               "amount_digits": "4",
            //               "is_enabled": true,
            //               "stop_order": false,
            //               "stop_order_and_cancel": false
            //             },
            //             ...
            //           ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var pairs interface{} = this.SafeValue(data, "pairs", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(pairs)); i++ {
                var pair interface{} = GetValue(pairs, i)
                var marketId interface{} = this.SafeString(pair, "name")
                var market interface{} = this.SafeMarket(marketId)
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": pair,
            "symbol": symbol,
            "maker": this.SafeNumber(pair, "maker_fee_rate_quote"),
            "taker": this.SafeNumber(pair, "taker_fee_rate_quote"),
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "0.02501786",
    //         "0.02501786",
    //         "0.02501786",
    //         "0.02501786",
    //         "0.0000",
    //         1591488000000
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 5), this.SafeNumber(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4)}
}
/**
 * @method
 * @name bitbank#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/public-api.md#candlestick
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bitbank) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(since, nil)) {
                if IsTrue(IsEqual(limit, nil)) {
                    limit = 1000 // it doesn't have any defaults, might return 200, might 2000 (i.e. https://public.bitbank.cc/btc_jpy/candlestick/4hour/2020)
                }
                var duration interface{} = this.ParseTimeframe(timeframe)
                since = Subtract(this.Milliseconds(), Multiply(Multiply(duration, 1000), limit))
            }
        
            retRes5748 := (<-this.LoadMarkets())
            PanicOnError(retRes5748)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "candletype": this.SafeString(this.Timeframes, timeframe, timeframe),
                "yyyymmdd": this.Yyyymmdd(since, ""),
            }
        
            response:= (<-this.PublicGetPairCandlestickCandletypeYyyymmdd(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success":1,
            //         "data":{
            //             "candlestick":[
            //                 {
            //                     "type":"5min",
            //                     "ohlcv":[
            //                         ["0.02501786","0.02501786","0.02501786","0.02501786","0.0000",1591488000000],
            //                         ["0.02501747","0.02501953","0.02501747","0.02501953","0.3017",1591488300000],
            //                         ["0.02501762","0.02501762","0.02500392","0.02500392","0.1500",1591488600000],
            //                     ]
            //                 }
            //             ],
            //             "timestamp":1591508668190
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var candlestick interface{} = this.SafeValue(data, "candlestick", []interface{}{})
            var first interface{} = this.SafeValue(candlestick, 0, map[string]interface{} {})
            var ohlcv interface{} = this.SafeList(first, "ohlcv", []interface{}{})
        
            ch <- this.ParseOHLCVs(ohlcv, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
    var assets interface{} = this.SafeValue(data, "assets", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
        var balance interface{} = GetValue(assets, i)
        var currencyId interface{} = this.SafeString(balance, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "free_amount"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked_amount"))
        AddElementToObject(account, "total", this.SafeString(balance, "onhand_amount"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bitbank#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitbank) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6378 := (<-this.LoadMarkets())
            PanicOnError(retRes6378)
        
            response:= (<-this.PrivateGetUserAssets(params))
            PanicOnError(response)
        
                //
            //     {
            //       "success": "1",
            //       "data": {
            //         "assets": [
            //           {
            //             "asset": "jpy",
            //             "amount_precision": "4",
            //             "onhand_amount": "0.0000",
            //             "locked_amount": "0.0000",
            //             "free_amount": "0.0000",
            //             "stop_deposit": false,
            //             "stop_withdrawal": false,
            //             "withdrawal_fee": {
            //               "threshold": "30000.0000",
            //               "under": "550.0000",
            //               "over": "770.0000"
            //             }
            //           },
            //           {
            //             "asset": "btc",
            //             "amount_precision": "8",
            //             "onhand_amount": "0.00000000",
            //             "locked_amount": "0.00000000",
            //             "free_amount": "0.00000000",
            //             "stop_deposit": false,
            //             "stop_withdrawal": false,
            //             "withdrawal_fee": "0.00060000"
            //           },
            //         ]
            //       }
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "UNFILLED": "open",
        "PARTIALLY_FILLED": "open",
        "FULLY_FILLED": "closed",
        "CANCELED_UNFILLED": "canceled",
        "CANCELED_PARTIALLY_FILLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitbank) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var marketId interface{} = this.SafeString(order, "pair")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(order, "ordered_at")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "start_amount")
    var filled interface{} = this.SafeString(order, "executed_amount")
    var remaining interface{} = this.SafeString(order, "remaining_amount")
    var average interface{} = this.SafeString(order, "average_price")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var side interface{} = this.SafeStringLower(order, "side")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "trades": nil,
        "fee": nil,
        "info": order,
    }, market)
}
/**
 * @method
 * @name bitbank#createOrder
 * @description create a trade order
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#create-new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbank) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7388 := (<-this.LoadMarkets())
            PanicOnError(retRes7388)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "amount": this.AmountToPrecision(symbol, amount),
                "side": side,
                "type": typeVar,
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePostUserSpotOrder(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#cancelOrder
 * @description cancels an open order
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbank) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7658 := (<-this.LoadMarkets())
            PanicOnError(retRes7658)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostUserSpotCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": 1,
            //        "data": {
            //            "order_id": 0,
            //            "pair": "string",
            //            "side": "string",
            //            "type": "string",
            //            "start_amount": "string",
            //            "remaining_amount": "string",
            //            "executed_amount": "string",
            //            "price": "string",
            //            "post_only": false,
            //            "average_price": "string",
            //            "ordered_at": 0,
            //            "expire_at": 0,
            //            "canceled_at": 0,
            //            "triggered_at": 0,
            //            "trigger_price": "string",
            //            "status": "string"
            //        }
            //    }
            //
            var data interface{} = this.SafeValue(response, "data")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#fetch-order-information
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbank) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8108 := (<-this.LoadMarkets())
            PanicOnError(retRes8108)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetUserSpotOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": 1,
            //        "data": {
            //          "order_id": 0,
            //          "pair": "string",
            //          "side": "string",
            //          "type": "string",
            //          "start_amount": "string",
            //          "remaining_amount": "string",
            //          "executed_amount": "string",
            //          "price": "string",
            //          "post_only": false,
            //          "average_price": "string",
            //          "ordered_at": 0,
            //          "expire_at": 0,
            //          "triggered_at": 0,
            //          "triger_price": "string",
            //          "status": "string"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#fetch-active-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbank) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8558 := (<-this.LoadMarkets())
            PanicOnError(retRes8558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", this.ParseToInt(Divide(since, 1000)))
            }
        
            response:= (<-this.PrivateGetUserSpotActiveOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#fetch-trade-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitbank) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8848 := (<-this.LoadMarkets())
            PanicOnError(retRes8848)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", this.ParseToInt(Divide(since, 1000)))
            }
        
            response:= (<-this.PrivateGetUserSpotTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#get-withdrawal-accounts
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bitbank) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9138 := (<-this.LoadMarkets())
            PanicOnError(retRes9138)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivateGetUserWithdrawalAccount(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            // Not sure about this if there could be more than one account...
            var accounts interface{} = this.SafeValue(data, "accounts", []interface{}{})
            var firstAccount interface{} = this.SafeValue(accounts, 0, map[string]interface{} {})
            var address interface{} = this.SafeString(firstAccount, "address")
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": currency,
                "network": nil,
                "address": address,
                "tag": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbank#withdraw
 * @description make a withdrawal
 * @see https://github.com/bitbankinc/bitbank-api-docs/blob/38d6d7c6f486c793872fd4b4087a0d090a04cd0a/rest-api.md#new-withdrawal-request
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitbank) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            if !IsTrue((InOp(params, "uuid"))) {
                panic(ExchangeError(Add(this.Id, " uuid is required for withdrawal")))
            }
        
            retRes9508 := (<-this.LoadMarkets())
            PanicOnError(retRes9508)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "amount": amount,
            }
        
            response:= (<-this.PrivatePostUserRequestWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": 1,
            //         "data": {
            //             "uuid": "string",
            //             "asset": "btc",
            //             "amount": 0,
            //             "account_uuid": "string",
            //             "fee": 0,
            //             "status": "DONE",
            //             "label": "string",
            //             "txid": "string",
            //             "address": "string",
            //             "requested_at": 0
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitbank) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "uuid": "string",
    //         "asset": "btc",
    //         "amount": 0,
    //         "account_uuid": "string",
    //         "fee": 0,
    //         "status": "DONE",
    //         "label": "string",
    //         "txid": "string",
    //         "address": "string",
    //         "requested_at": 0
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var txid interface{} = this.SafeString(transaction, "txid")
    currency = this.SafeCurrency(nil, currency)
    return map[string]interface{} {
        "id": txid,
        "txid": txid,
        "timestamp": nil,
        "datetime": nil,
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "amount": nil,
        "type": nil,
        "currency": GetValue(currency, "code"),
        "status": nil,
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "info": transaction,
    }
}
func  (this *bitbank) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *bitbank) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var url interface{} = Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api)), "/")
    if IsTrue(IsTrue((IsEqual(api, "public"))) || IsTrue((IsEqual(api, "markets")))) {
        url = Add(url, this.ImplodeParams(path, params))
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var auth interface{} = nonce
        url = Add(url, Add(Add(this.Version, "/"), this.ImplodeParams(path, params)))
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(query)
            auth = Add(auth, body)
        } else {
            auth = Add(auth, Add(Add(Add("/", this.Version), "/"), path))
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                query = this.Urlencode(query)
                url = Add(url, Add("?", query))
                auth = Add(auth, Add("?", query))
            }
        }
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-NONCE": nonce,
            "ACCESS-SIGNATURE": this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitbank) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var success interface{} = this.SafeInteger(response, "success")
    var data interface{} = this.SafeValue(response, "data")
    if IsTrue(!IsTrue(success) || !IsTrue(data)) {
        var errorMessages interface{} = map[string]interface{} {
            "10000": "URL does not exist",
            "10001": "A system error occurred. Please contact support",
            "10002": "Invalid JSON format. Please check the contents of transmission",
            "10003": "A system error occurred. Please contact support",
            "10005": "A timeout error occurred. Please wait for a while and try again",
            "20001": "API authentication failed",
            "20002": "Illegal API key",
            "20003": "API key does not exist",
            "20004": "API Nonce does not exist",
            "20005": "API signature does not exist",
            "20011": "Two-step verification failed",
            "20014": "SMS authentication failed",
            "30001": "Please specify the order quantity",
            "30006": "Please specify the order ID",
            "30007": "Please specify the order ID array",
            "30009": "Please specify the stock",
            "30012": "Please specify the order price",
            "30013": "Trade Please specify either",
            "30015": "Please specify the order type",
            "30016": "Please specify asset name",
            "30019": "Please specify uuid",
            "30039": "Please specify the amount to be withdrawn",
            "40001": "The order quantity is invalid",
            "40006": "Count value is invalid",
            "40007": "End time is invalid",
            "40008": "end_id Value is invalid",
            "40009": "The from_id value is invalid",
            "40013": "The order ID is invalid",
            "40014": "The order ID array is invalid",
            "40015": "Too many specified orders",
            "40017": "Incorrect issue name",
            "40020": "The order price is invalid",
            "40021": "The trading classification is invalid",
            "40022": "Start date is invalid",
            "40024": "The order type is invalid",
            "40025": "Incorrect asset name",
            "40028": "uuid is invalid",
            "40048": "The amount of withdrawal is illegal",
            "50003": "Currently, this account is in a state where you can not perform the operation you specified. Please contact support",
            "50004": "Currently, this account is temporarily registered. Please try again after registering your account",
            "50005": "Currently, this account is locked. Please contact support",
            "50006": "Currently, this account is locked. Please contact support",
            "50008": "User identification has not been completed",
            "50009": "Your order does not exist",
            "50010": "Can not cancel specified order",
            "50011": "API not found",
            "60001": "The number of possessions is insufficient",
            "60002": "It exceeds the quantity upper limit of the tender buying order",
            "60003": "The specified quantity exceeds the limit",
            "60004": "The specified quantity is below the threshold",
            "60005": "The specified price is above the limit",
            "60006": "The specified price is below the lower limit",
            "70001": "A system error occurred. Please contact support",
            "70002": "A system error occurred. Please contact support",
            "70003": "A system error occurred. Please contact support",
            "70004": "We are unable to accept orders as the transaction is currently suspended",
            "70005": "Order can not be accepted because purchase order is currently suspended",
            "70006": "We can not accept orders because we are currently unsubscribed ",
            "70009": "We are currently temporarily restricting orders to be carried out. Please use the limit order.",
            "70010": "We are temporarily raising the minimum order quantity as the system load is now rising.",
        }
        var code interface{} = this.SafeString(data, "code")
        var message interface{} = this.SafeString(errorMessages, code, "Error")
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, message)
        panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
    }
    return nil
}


func (this *bitbank) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
