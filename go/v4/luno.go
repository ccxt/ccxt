package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type luno struct {
	Exchange
}

func NewLunoCore() *luno {
	p := &luno{}
	setDefaults(p)
	return p
}

func (this *luno) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "luno",
		"name":      "luno",
		"countries": []interface{}{"GB", "SG", "ZA"},
		"rateLimit": 200,
		"version":   "1",
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                         nil,
			"spot":                         true,
			"margin":                       false,
			"swap":                         false,
			"future":                       false,
			"option":                       false,
			"addMargin":                    false,
			"borrowCrossMargin":            false,
			"borrowIsolatedMargin":         false,
			"borrowMargin":                 false,
			"cancelOrder":                  true,
			"closeAllPositions":            false,
			"closePosition":                false,
			"createDepositAddress":         true,
			"createOrder":                  true,
			"createReduceOnlyOrder":        false,
			"fetchAccounts":                true,
			"fetchAllGreeks":               false,
			"fetchBalance":                 true,
			"fetchBorrowInterest":          false,
			"fetchBorrowRate":              false,
			"fetchBorrowRateHistories":     false,
			"fetchBorrowRateHistory":       false,
			"fetchBorrowRates":             false,
			"fetchBorrowRatesPerSymbol":    false,
			"fetchClosedOrders":            true,
			"fetchCrossBorrowRate":         false,
			"fetchCrossBorrowRates":        false,
			"fetchCurrencies":              true,
			"fetchDepositAddress":          true,
			"fetchFundingHistory":          false,
			"fetchFundingInterval":         false,
			"fetchFundingIntervals":        false,
			"fetchFundingRate":             false,
			"fetchFundingRateHistory":      false,
			"fetchFundingRates":            false,
			"fetchGreeks":                  false,
			"fetchIndexOHLCV":              false,
			"fetchIsolatedBorrowRate":      false,
			"fetchIsolatedBorrowRates":     false,
			"fetchIsolatedPositions":       false,
			"fetchLedger":                  true,
			"fetchLeverage":                false,
			"fetchLeverages":               false,
			"fetchLeverageTiers":           false,
			"fetchLiquidations":            false,
			"fetchLongShortRatio":          false,
			"fetchLongShortRatioHistory":   false,
			"fetchMarginAdjustmentHistory": false,
			"fetchMarginMode":              false,
			"fetchMarginModes":             false,
			"fetchMarketLeverageTiers":     false,
			"fetchMarkets":                 true,
			"fetchMarkOHLCV":               false,
			"fetchMarkPrice":               false,
			"fetchMarkPrices":              false,
			"fetchMyLiquidations":          false,
			"fetchMySettlementHistory":     false,
			"fetchMyTrades":                true,
			"fetchOHLCV":                   true,
			"fetchOpenInterest":            false,
			"fetchOpenInterestHistory":     false,
			"fetchOpenInterests":           false,
			"fetchOpenOrders":              true,
			"fetchOption":                  false,
			"fetchOptionChain":             false,
			"fetchOrder":                   true,
			"fetchOrderBook":               true,
			"fetchOrders":                  true,
			"fetchPosition":                false,
			"fetchPositionForSymbolWs":     false,
			"fetchPositionHistory":         false,
			"fetchPositionMode":            false,
			"fetchPositions":               false,
			"fetchPositionsForSymbol":      false,
			"fetchPositionsForSymbolWs":    false,
			"fetchPositionsHistory":        false,
			"fetchPositionsRisk":           false,
			"fetchPremiumIndexOHLCV":       false,
			"fetchSettlementHistory":       false,
			"fetchTicker":                  true,
			"fetchTickers":                 true,
			"fetchTrades":                  true,
			"fetchTradingFee":              true,
			"fetchTradingFees":             false,
			"fetchUnderlyingAssets":        false,
			"fetchVolatilityHistory":       false,
			"reduceMargin":                 false,
			"repayCrossMargin":             false,
			"repayIsolatedMargin":          false,
			"setLeverage":                  false,
			"setMargin":                    false,
			"setMarginMode":                false,
			"setPositionMode":              false,
		},
		"urls": map[string]interface{}{
			"referral": "https://www.luno.com/invite/44893A",
			"logo":     "https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",
			"api": map[string]interface{}{
				"public":          "https://api.luno.com/api",
				"private":         "https://api.luno.com/api",
				"exchange":        "https://api.luno.com/api/exchange",
				"exchangePrivate": "https://api.luno.com/api/exchange",
			},
			"www": "https://www.luno.com",
			"doc": []interface{}{"https://www.luno.com/en/api", "https://npmjs.org/package/bitx", "https://github.com/bausmeier/node-bitx"},
		},
		"api": map[string]interface{}{
			"exchange": map[string]interface{}{
				"get": map[string]interface{}{
					"markets": 1,
				},
			},
			"exchangePrivate": map[string]interface{}{
				"get": map[string]interface{}{
					"candles": 1,
				},
			},
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"orderbook":     1,
					"orderbook_top": 1,
					"ticker":        1,
					"tickers":       1,
					"trades":        1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"accounts/{id}/pending":      1,
					"accounts/{id}/transactions": 1,
					"balance":                    1,
					"beneficiaries":              1,
					"send/networks":              1,
					"fee_info":                   1,
					"funding_address":            1,
					"listorders":                 1,
					"listtrades":                 1,
					"send_fee":                   1,
					"orders/{id}":                1,
					"withdrawals":                1,
					"withdrawals/{id}":           1,
					"transfers":                  1,
				},
				"post": map[string]interface{}{
					"accounts":         1,
					"address/validate": 1,
					"postorder":        1,
					"marketorder":      1,
					"stoporder":        1,
					"funding_address":  1,
					"withdrawals":      1,
					"send":             1,
					"oauth2/grant":     1,
					"beneficiaries":    1,
				},
				"put": map[string]interface{}{
					"accounts/{id}/name": 1,
				},
				"delete": map[string]interface{}{
					"withdrawals/{id}":   1,
					"beneficiaries/{id}": 1,
				},
			},
		},
		"timeframes": map[string]interface{}{
			"1m":  60,
			"5m":  300,
			"15m": 900,
			"30m": 1800,
			"1h":  3600,
			"3h":  10800,
			"4h":  14400,
			"1d":  86400,
			"3d":  259200,
			"1w":  604800,
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"tierBased":  true,
				"percentage": true,
				"taker":      this.ParseNumber("0.001"),
				"maker":      this.ParseNumber("0"),
			},
		},
		"precisionMode": TICK_SIZE,
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           true,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       100000,
					"untilDays":      100000,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       100000,
					"untilDays":      nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            1000,
					"daysBack":         100000,
					"daysBackCanceled": 1,
					"untilDays":        nil,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": nil,
				},
			},
			"swap": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
	})
}

/**
 * @method
 * @name luno#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {dict} [params] extra parameters specific to the exchange API endpoint
 * @returns {dict} an associative dictionary of currencies
 */
func (this *luno) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if !IsTrue(this.CheckRequiredCredentials(false)) {

			ch <- map[string]interface{}{}
			return nil
		}

		response := (<-this.PrivateGetSendNetworks(params))
		PanicOnError(response)
		//
		//     {
		//         "networks": [
		//           {
		//             "id": 0,
		//             "name": "Ethereum",
		//             "native_currency": "ETH"
		//           },
		//           ...
		//         ]
		//     }
		//
		var currenciesData interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
			var networkEntry interface{} = GetValue(currenciesData, i)
			var id interface{} = this.SafeString(networkEntry, "native_currency")
			var code interface{} = this.SafeCurrencyCode(id)
			if !IsTrue((InOp(result, code))) {
				AddElementToObject(result, code, map[string]interface{}{
					"id":        id,
					"code":      code,
					"precision": nil,
					"type":      nil,
					"name":      nil,
					"active":    nil,
					"deposit":   nil,
					"withdraw":  nil,
					"fee":       nil,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
						"deposit": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
					},
					"networks": map[string]interface{}{},
					"info":     map[string]interface{}{},
				})
			}
			var networkId interface{} = this.SafeString(networkEntry, "name")
			var networkCode interface{} = this.NetworkIdToCode(networkId)
			AddElementToObject(GetValue(GetValue(result, code), "networks"), networkCode, map[string]interface{}{
				"id":      networkId,
				"network": networkCode,
				"limits": map[string]interface{}{
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"info":      networkEntry,
			})
			// add entry in info
			var info interface{} = this.SafeList(GetValue(result, code), "info", []interface{}{})
			AppendToArray(&info, networkEntry)
			AddElementToObject(GetValue(result, code), "info", info)
		}
		// only after all entries are formed in currencies, restructure each entry
		var allKeys interface{} = ObjectKeys(result)
		for i := 0; IsLessThan(i, GetArrayLength(allKeys)); i++ {
			var code interface{} = GetValue(allKeys, i)
			AddElementToObject(result, code, this.SafeCurrencyStructure(GetValue(result, code))) // this is needed after adding network entry
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchMarkets
 * @description retrieves data on all markets for luno
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/Markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *luno) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.ExchangeGetMarkets(params))
		PanicOnError(response)
		//
		//     {
		//         "markets":[
		//             {
		//                 "market_id":"BCHXBT",
		//                 "trading_status":"ACTIVE",
		//                 "base_currency":"BCH",
		//                 "counter_currency":"XBT",
		//                 "min_volume":"0.01",
		//                 "max_volume":"100.00",
		//                 "volume_scale":2,
		//                 "min_price":"0.0001",
		//                 "max_price":"1.00",
		//                 "price_scale":6,
		//                 "fee_scale":8,
		//             },
		//         ]
		//     }
		//
		var result interface{} = []interface{}{}
		var markets interface{} = this.SafeValue(response, "markets", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var id interface{} = this.SafeString(market, "market_id")
			var baseId interface{} = this.SafeString(market, "base_currency")
			var quoteId interface{} = this.SafeString(market, "counter_currency")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var status interface{} = this.SafeString(market, "trading_status")
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         Add(Add(base, "/"), quote),
				"base":           base,
				"quote":          quote,
				"settle":         nil,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"margin":         false,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         (IsEqual(status, "ACTIVE")),
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "volume_scale"))),
					"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_scale"))),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "min_volume"),
						"max": this.SafeNumber(market, "max_volume"),
					},
					"price": map[string]interface{}{
						"min": this.SafeNumber(market, "min_price"),
						"max": this.SafeNumber(market, "max_price"),
					},
					"cost": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/getBalances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func (this *luno) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PrivateGetBalance(params))
		PanicOnError(response)
		var wallets interface{} = this.SafeValue(response, "balance", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(wallets)); i++ {
			var account interface{} = GetValue(wallets, i)
			var accountId interface{} = this.SafeString(account, "account_id")
			var currencyId interface{} = this.SafeString(account, "asset")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			AppendToArray(&result, map[string]interface{}{
				"id":       accountId,
				"type":     nil,
				"currency": code,
				"info":     account,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *luno) ParseBalance(response interface{}) interface{} {
	var wallets interface{} = this.SafeValue(response, "balance", []interface{}{})
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	for i := 0; IsLessThan(i, GetArrayLength(wallets)); i++ {
		var wallet interface{} = GetValue(wallets, i)
		var currencyId interface{} = this.SafeString(wallet, "asset")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var reserved interface{} = this.SafeString(wallet, "reserved")
		var unconfirmed interface{} = this.SafeString(wallet, "unconfirmed")
		var balance interface{} = this.SafeString(wallet, "balance")
		var reservedUnconfirmed interface{} = Precise.StringAdd(reserved, unconfirmed)
		var balanceUnconfirmed interface{} = Precise.StringAdd(balance, unconfirmed)
		if IsTrue(InOp(result, code)) {
			AddElementToObject(GetValue(result, code), "used", Precise.StringAdd(GetValue(GetValue(result, code), "used"), reservedUnconfirmed))
			AddElementToObject(GetValue(result, code), "total", Precise.StringAdd(GetValue(GetValue(result, code), "total"), balanceUnconfirmed))
		} else {
			var account interface{} = this.Account()
			AddElementToObject(account, "used", reservedUnconfirmed)
			AddElementToObject(account, "total", balanceUnconfirmed)
			AddElementToObject(result, code, account)
		}
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name luno#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/getBalances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *luno) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes5568 := (<-this.LoadMarkets())
		PanicOnError(retRes5568)

		response := (<-this.PrivateGetBalance(params))
		PanicOnError(response)

		//
		//     {
		//         "balance": [
		//             {'account_id': '119...1336','asset': 'XBT','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
		//             {'account_id': '66...289','asset': 'XBT','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
		//             {'account_id': '718...5300','asset': 'ETH','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
		//             {'account_id': '818...7072','asset': 'ZAR','balance': '0.001417','reserved': '0.00',"unconfirmed": "0.00"}]}
		//         ]
		//     }
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetOrderBookFull
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetOrderBook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *luno) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes5838 := (<-this.LoadMarkets())
		PanicOnError(retRes5838)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(IsTrue(!IsEqual(limit, nil)) && IsTrue(IsLessThanOrEqual(limit, 100))) {

			response = (<-this.PublicGetOrderbookTop(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicGetOrderbook(this.Extend(request, params)))
			PanicOnError(response)
		}
		var timestamp interface{} = this.SafeInteger(response, "timestamp")

		ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "volume")
		return nil

	}()
	return ch
}
func (this *luno) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"PENDING": "open",
	}
	return this.SafeString(statuses, status, status)
}
func (this *luno) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "base": "string",
	//         "completed_timestamp": "string",
	//         "counter": "string",
	//         "creation_timestamp": "string",
	//         "expiration_timestamp": "string",
	//         "fee_base": "string",
	//         "fee_counter": "string",
	//         "limit_price": "string",
	//         "limit_volume": "string",
	//         "order_id": "string",
	//         "pair": "string",
	//         "state": "PENDING",
	//         "type": "BID"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(order, "creation_timestamp")
	var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
	status = Ternary(IsTrue((IsEqual(status, "open"))), status, status)
	var side interface{} = nil
	var orderType interface{} = this.SafeString(order, "type")
	if IsTrue(IsTrue((IsEqual(orderType, "ASK"))) || IsTrue((IsEqual(orderType, "SELL")))) {
		side = "sell"
	} else if IsTrue(IsTrue((IsEqual(orderType, "BID"))) || IsTrue((IsEqual(orderType, "BUY")))) {
		side = "buy"
	}
	var marketId interface{} = this.SafeString(order, "pair")
	market = this.SafeMarket(marketId, market)
	var price interface{} = this.SafeString(order, "limit_price")
	var amount interface{} = this.SafeString(order, "limit_volume")
	var quoteFee interface{} = this.SafeNumber(order, "fee_counter")
	var baseFee interface{} = this.SafeNumber(order, "fee_base")
	var filled interface{} = this.SafeString(order, "base")
	var cost interface{} = this.SafeString(order, "counter")
	var fee interface{} = nil
	if IsTrue(!IsEqual(quoteFee, nil)) {
		fee = map[string]interface{}{
			"cost":     quoteFee,
			"currency": GetValue(market, "quote"),
		}
	} else if IsTrue(!IsEqual(baseFee, nil)) {
		fee = map[string]interface{}{
			"cost":     baseFee,
			"currency": GetValue(market, "base"),
		}
	}
	var id interface{} = this.SafeString(order, "order_id")
	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      nil,
		"datetime":           this.Iso8601(timestamp),
		"timestamp":          timestamp,
		"lastTradeTimestamp": nil,
		"status":             status,
		"symbol":             GetValue(market, "symbol"),
		"type":               nil,
		"timeInForce":        nil,
		"postOnly":           nil,
		"side":               side,
		"price":              price,
		"triggerPrice":       nil,
		"amount":             amount,
		"filled":             filled,
		"cost":               cost,
		"remaining":          nil,
		"trades":             nil,
		"fee":                fee,
		"info":               order,
		"average":            nil,
	}, market)
}

/**
 * @method
 * @name luno#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/GetOrder
 * @param {string} id order id
 * @param {string} symbol not used by luno fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes6918 := (<-this.LoadMarkets())
		PanicOnError(retRes6918)
		var request interface{} = map[string]interface{}{
			"id": id,
		}

		response := (<-this.PrivateGetOrdersId(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}
func (this *luno) FetchOrdersByState(state interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes7008 := (<-this.LoadMarkets())
		PanicOnError(retRes7008)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(state, nil)) {
			AddElementToObject(request, "state", state)
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "pair", GetValue(market, "id"))
		}

		response := (<-this.PrivateGetListorders(this.Extend(request, params)))
		PanicOnError(response)
		var orders interface{} = this.SafeList(response, "orders", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes72715 := (<-this.FetchOrdersByState(nil, symbol, since, limit, params))
		PanicOnError(retRes72715)
		ch <- retRes72715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes74215 := (<-this.FetchOrdersByState("PENDING", symbol, since, limit, params))
		PanicOnError(retRes74215)
		ch <- retRes74215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes75715 := (<-this.FetchOrdersByState("COMPLETE", symbol, since, limit, params))
		PanicOnError(retRes75715)
		ch <- retRes75715
		return nil

	}()
	return ch
}
func (this *luno) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	// {
	//     "pair":"XBTAUD",
	//     "timestamp":1642201439301,
	//     "bid":"59972.30000000",
	//     "ask":"59997.99000000",
	//     "last_trade":"59997.99000000",
	//     "rolling_24_hour_volume":"1.89510000",
	//     "status":"ACTIVE"
	// }
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
	var marketId interface{} = this.SafeString(ticker, "pair")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var last interface{} = this.SafeString(ticker, "last_trade")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          nil,
		"low":           nil,
		"bid":           this.SafeString(ticker, "bid"),
		"bidVolume":     nil,
		"ask":           this.SafeString(ticker, "ask"),
		"askVolume":     nil,
		"vwap":          nil,
		"open":          nil,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    this.SafeString(ticker, "rolling_24_hour_volume"),
		"quoteVolume":   nil,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name luno#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetTickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *luno) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8088 := (<-this.LoadMarkets())
		PanicOnError(retRes8088)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.PublicGetTickers(params))
		PanicOnError(response)
		var tickers interface{} = this.IndexBy(GetValue(response, "tickers"), "pair")
		var ids interface{} = ObjectKeys(tickers)
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
			var id interface{} = GetValue(ids, i)
			var market interface{} = this.SafeMarket(id)
			var symbol interface{} = GetValue(market, "symbol")
			var ticker interface{} = GetValue(tickers, id)
			AddElementToObject(result, symbol, this.ParseTicker(ticker, market))
		}

		ch <- this.FilterByArrayTickers(result, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetTicker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *luno) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8348 := (<-this.LoadMarkets())
		PanicOnError(retRes8348)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}

		response := (<-this.PublicGetTicker(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "pair":"XBTAUD",
		//     "timestamp":1642201439301,
		//     "bid":"59972.30000000",
		//     "ask":"59997.99000000",
		//     "last_trade":"59997.99000000",
		//     "rolling_24_hour_volume":"1.89510000",
		//     "status":"ACTIVE"
		// }
		ch <- this.ParseTicker(response, market)
		return nil

	}()
	return ch
}
func (this *luno) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades (public)
	//
	//      {
	//          "sequence":276989,
	//          "timestamp":1648651276949,
	//          "price":"35773.20000000",
	//          "volume":"0.00300000",
	//          "is_buy":false
	//      }
	//
	// fetchMyTrades (private)
	//
	//      {
	//          "pair":"LTCXBT",
	//          "sequence":3256813,
	//          "order_id":"BXEX6XHHDT5EGW2",
	//          "type":"ASK",
	//          "timestamp":1648652135235,
	//          "price":"0.002786",
	//          "volume":"0.10",
	//          "base":"0.10",
	//          "counter":"0.0002786",
	//          "fee_base":"0.0001",
	//          "fee_counter":"0.00",
	//          "is_buy":false,
	//          "client_order_id":""
	//      }
	//
	// For public trade data (is_buy === True) indicates 'buy' side but for private trade data
	// is_buy indicates maker or taker. The value of "type" (ASK/BID) indicate sell/buy side.
	// Private trade data includes ID field which public trade data does not.
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var orderId interface{} = this.SafeString(trade, "order_id")
	var id interface{} = this.SafeString(trade, "sequence")
	var takerOrMaker interface{} = nil
	var side interface{} = nil
	if IsTrue(!IsEqual(orderId, nil)) {
		var typeVar interface{} = this.SafeString(trade, "type")
		if IsTrue(IsTrue((IsEqual(typeVar, "ASK"))) || IsTrue((IsEqual(typeVar, "SELL")))) {
			side = "sell"
		} else if IsTrue(IsTrue((IsEqual(typeVar, "BID"))) || IsTrue((IsEqual(typeVar, "BUY")))) {
			side = "buy"
		}
		if IsTrue(IsTrue(IsEqual(side, "sell")) && IsTrue(GetValue(trade, "is_buy"))) {
			takerOrMaker = "maker"
		} else if IsTrue(IsTrue(IsEqual(side, "buy")) && !IsTrue(GetValue(trade, "is_buy"))) {
			takerOrMaker = "maker"
		} else {
			takerOrMaker = "taker"
		}
	} else {
		side = Ternary(IsTrue(GetValue(trade, "is_buy")), "buy", "sell")
	}
	var feeBaseString interface{} = this.SafeString(trade, "fee_base")
	var feeCounterString interface{} = this.SafeString(trade, "fee_counter")
	var feeCurrency interface{} = nil
	var feeCost interface{} = nil
	if IsTrue(!IsEqual(feeBaseString, nil)) {
		if !IsTrue(Precise.StringEquals(feeBaseString, "0.0")) {
			feeCurrency = GetValue(market, "base")
			feeCost = feeBaseString
		}
	} else if IsTrue(!IsEqual(feeCounterString, nil)) {
		if !IsTrue(Precise.StringEquals(feeCounterString, "0.0")) {
			feeCurrency = GetValue(market, "quote")
			feeCost = feeCounterString
		}
	}
	var timestamp interface{} = this.SafeInteger(trade, "timestamp")
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"id":           id,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"order":        orderId,
		"type":         nil,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        this.SafeString(trade, "price"),
		"amount":       this.SafeString2(trade, "volume", "base"),
		"cost":         this.SafeString(trade, "counter"),
		"fee": map[string]interface{}{
			"cost":     feeCost,
			"currency": feeCurrency,
		},
	}, market)
}

/**
 * @method
 * @name luno#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/ListTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *luno) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes9558 := (<-this.LoadMarkets())
		PanicOnError(retRes9558)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "since", since)
		}

		response := (<-this.PublicGetTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//      {
		//          "trades":[
		//              {
		//                  "sequence":276989,
		//                  "timestamp":1648651276949,
		//                  "price":"35773.20000000",
		//                  "volume":"0.00300000",
		//                  "is_buy":false
		//              },...
		//          ]
		//      }
		//
		var trades interface{} = this.SafeList(response, "trades", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchOHLCV
 * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetCandles
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} params extra parameters specific to the luno api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *luno) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes9948 := (<-this.LoadMarkets())
		PanicOnError(retRes9948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"duration": this.SafeValue(this.Timeframes, timeframe, timeframe),
			"pair":     GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "since", this.ParseToInt(since))
		} else {
			var duration interface{} = Multiply(Multiply(1000, 1000), this.ParseTimeframe(timeframe))
			AddElementToObject(request, "since", Subtract(this.Milliseconds(), duration))
		}

		response := (<-this.ExchangePrivateGetCandles(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//          "candles": [
		//              {
		//                  "timestamp": 1664055240000,
		//                  "open": "19612.65",
		//                  "close": "19612.65",
		//                  "high": "19612.65",
		//                  "low": "19612.65",
		//                  "volume": "0.00"
		//              },...
		//          ],
		//          "duration": 60,
		//          "pair": "XBTEUR"
		//     }
		//
		var ohlcvs interface{} = this.SafeList(response, "candles", []interface{}{})

		ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *luno) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	// {
	//     "timestamp": 1664055240000,
	//     "open": "19612.65",
	//     "close": "19612.65",
	//     "high": "19612.65",
	//     "low": "19612.65",
	//     "volume": "0.00"
	// }
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, "timestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}

/**
 * @method
 * @name luno#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListUserTrades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *luno) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes10618 := (<-this.LoadMarkets())
		PanicOnError(retRes10618)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "since", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetListtrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//      {
		//          "trades":[
		//              {
		//                  "pair":"LTCXBT",
		//                  "sequence":3256813,
		//                  "order_id":"BXEX6XHHDT5EGW2",
		//                  "type":"ASK",
		//                  "timestamp":1648652135235,
		//                  "price":"0.002786",
		//                  "volume":"0.10",
		//                  "base":"0.10",
		//                  "counter":"0.0002786",
		//                  "fee_base":"0.0001",
		//                  "fee_counter":"0.00",
		//                  "is_buy":false,
		//                  "client_order_id":""
		//              },...
		//          ]
		//      }
		//
		var trades interface{} = this.SafeList(response, "trades", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/getFeeInfo
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *luno) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes11088 := (<-this.LoadMarkets())
		PanicOnError(retRes11088)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}

		response := (<-this.PrivateGetFeeInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//          "maker_fee": "0.00250000",
		//          "taker_fee": "0.00500000",
		//          "thirty_day_volume": "0"
		//     }
		//
		ch <- map[string]interface{}{
			"info":       response,
			"symbol":     symbol,
			"maker":      this.SafeNumber(response, "maker_fee"),
			"taker":      this.SafeNumber(response, "taker_fee"),
			"percentage": nil,
			"tierBased":  nil,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#createOrder
 * @description create a trade order
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/PostMarketOrder
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/PostLimitOrder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11468 := (<-this.LoadMarkets())
		PanicOnError(retRes11468)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"pair": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "market")) {
			AddElementToObject(request, "type", ToUpper(side))
			// todo add createMarketBuyOrderRequires price logic as it is implemented in the other exchanges
			if IsTrue(IsEqual(side, "buy")) {
				AddElementToObject(request, "counter_volume", this.AmountToPrecision(GetValue(market, "symbol"), amount))
			} else {
				AddElementToObject(request, "base_volume", this.AmountToPrecision(GetValue(market, "symbol"), amount))
			}

			response = (<-this.PrivatePostMarketorder(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "volume", this.AmountToPrecision(GetValue(market, "symbol"), amount))
			AddElementToObject(request, "price", this.PriceToPrecision(GetValue(market, "symbol"), price))
			AddElementToObject(request, "type", Ternary(IsTrue((IsEqual(side, "buy"))), "BID", "ASK"))

			response = (<-this.PrivatePostPostorder(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.SafeOrder(map[string]interface{}{
			"info": response,
			"id":   GetValue(response, "order_id"),
		}, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#cancelOrder
 * @description cancels an open order
 * @see https://www.luno.com/en/developers/api#tag/Orders/operation/StopOrder
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *luno) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11848 := (<-this.LoadMarkets())
		PanicOnError(retRes11848)
		var request interface{} = map[string]interface{}{
			"order_id": id,
		}

		response := (<-this.PrivatePostStoporder(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//        "success": true
		//    }
		//
		ch <- this.SafeOrder(map[string]interface{}{
			"info": response,
		})
		return nil

	}()
	return ch
}
func (this *luno) FetchLedgerByEntries(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// by default without entry number or limit number, return most recent entry
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		entry := GetArg(optionalArgs, 1, nil)
		_ = entry
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(entry, nil)) {
			entry = OpNeg(1)
		}
		if IsTrue(IsEqual(limit, nil)) {
			limit = 1
		}
		var since interface{} = nil
		var request interface{} = map[string]interface{}{
			"min_row": entry,
			"max_row": this.Sum(entry, limit),
		}

		retRes121215 := (<-this.FetchLedger(code, since, limit, this.Extend(request, params)))
		PanicOnError(retRes121215)
		ch <- retRes121215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/ListTransactions
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func (this *luno) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes12278 := (<-this.LoadMarkets())
		PanicOnError(retRes12278)

		retRes12288 := (<-this.LoadAccounts())
		PanicOnError(retRes12288)
		var currency interface{} = nil
		var id interface{} = this.SafeString(params, "id") // account id
		var min_row interface{} = this.SafeValue(params, "min_row")
		var max_row interface{} = this.SafeValue(params, "max_row")
		if IsTrue(IsEqual(id, nil)) {
			if IsTrue(IsEqual(code, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchLedger() requires a currency code argument if no account id specified in params")))
			}
			currency = this.Currency(code)
			var accountsByCurrencyCode interface{} = this.IndexBy(this.Accounts, "currency")
			var account interface{} = this.SafeValue(accountsByCurrencyCode, code)
			if IsTrue(IsEqual(account, nil)) {
				panic(ExchangeError(Add(Add(this.Id, " fetchLedger() could not find account id for "), code)))
			}
			id = GetValue(account, "id")
		}
		if IsTrue(IsTrue(IsEqual(min_row, nil)) && IsTrue(IsEqual(max_row, nil))) {
			max_row = 0           // Default to most recent transactions
			min_row = OpNeg(1000) // Maximum number of records supported
		} else if IsTrue(IsTrue(IsEqual(min_row, nil)) || IsTrue(IsEqual(max_row, nil))) {
			panic(ExchangeError(Add(this.Id, " fetchLedger() require both params \\'max_row\\' and \\'min_row\\' or neither to be defined")))
		}
		if IsTrue(IsTrue(!IsEqual(limit, nil)) && IsTrue(IsGreaterThan(Subtract(max_row, min_row), limit))) {
			if IsTrue(IsLessThanOrEqual(max_row, 0)) {
				min_row = Subtract(max_row, limit)
			} else if IsTrue(IsGreaterThan(min_row, 0)) {
				max_row = Add(min_row, limit)
			}
		}
		if IsTrue(IsGreaterThan(Subtract(max_row, min_row), 1000)) {
			panic(ExchangeError(Add(this.Id, " fetchLedger() requires the params \\'max_row\\' - \\'min_row\\' <= 1000")))
		}
		var request interface{} = map[string]interface{}{
			"id":      id,
			"min_row": min_row,
			"max_row": max_row,
		}

		response := (<-this.PrivateGetAccountsIdTransactions(this.Extend(params, request)))
		PanicOnError(response)
		var entries interface{} = this.SafeValue(response, "transactions", []interface{}{})

		ch <- this.ParseLedger(entries, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *luno) ParseLedgerComment(comment interface{}) interface{} {
	var words interface{} = Split(comment, " ")
	var types interface{} = map[string]interface{}{
		"Withdrawal": "fee",
		"Trading":    "fee",
		"Payment":    "transaction",
		"Sent":       "transaction",
		"Deposit":    "transaction",
		"Received":   "transaction",
		"Released":   "released",
		"Reserved":   "reserved",
		"Sold":       "trade",
		"Bought":     "trade",
		"Failure":    "failed",
	}
	var referenceId interface{} = nil
	var firstWord interface{} = this.SafeString(words, 0)
	var thirdWord interface{} = this.SafeString(words, 2)
	var fourthWord interface{} = this.SafeString(words, 3)
	var typeVar interface{} = this.SafeString(types, firstWord, nil)
	if IsTrue(IsTrue((IsEqual(typeVar, nil))) && IsTrue((IsEqual(thirdWord, "fee")))) {
		typeVar = "fee"
	}
	if IsTrue(IsTrue((IsEqual(typeVar, "reserved"))) && IsTrue((IsEqual(fourthWord, "order")))) {
		referenceId = this.SafeString(words, 4)
	}
	return map[string]interface{}{
		"type":        typeVar,
		"referenceId": referenceId,
	}
}
func (this *luno) ParseLedgerEntry(entry interface{}, optionalArgs ...interface{}) interface{} {
	// const details = this.safeValue (entry, 'details', {});
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(entry, "row_index")
	var account_id interface{} = this.SafeString(entry, "account_id")
	var timestamp interface{} = this.SafeInteger(entry, "timestamp")
	var currencyId interface{} = this.SafeString(entry, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var available_delta interface{} = this.SafeString(entry, "available_delta")
	var balance_delta interface{} = this.SafeString(entry, "balance_delta")
	var after interface{} = this.SafeString(entry, "balance")
	var comment interface{} = this.SafeString(entry, "description")
	var before interface{} = after
	var amount interface{} = "0.0"
	var result interface{} = this.ParseLedgerComment(comment)
	var typeVar interface{} = GetValue(result, "type")
	var referenceId interface{} = GetValue(result, "referenceId")
	var direction interface{} = nil
	var status interface{} = nil
	if !IsTrue(Precise.StringEquals(balance_delta, "0.0")) {
		before = Precise.StringSub(after, balance_delta)
		status = "ok"
		amount = Precise.StringAbs(balance_delta)
	} else if IsTrue(Precise.StringLt(available_delta, "0.0")) {
		status = "pending"
		amount = Precise.StringAbs(available_delta)
	} else if IsTrue(Precise.StringGt(available_delta, "0.0")) {
		status = "canceled"
		amount = Precise.StringAbs(available_delta)
	}
	if IsTrue(IsTrue(Precise.StringGt(balance_delta, "0")) || IsTrue(Precise.StringGt(available_delta, "0"))) {
		direction = "in"
	} else if IsTrue(IsTrue(Precise.StringLt(balance_delta, "0")) || IsTrue(Precise.StringLt(available_delta, "0"))) {
		direction = "out"
	}
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             entry,
		"id":               id,
		"direction":        direction,
		"account":          account_id,
		"referenceId":      referenceId,
		"referenceAccount": nil,
		"type":             typeVar,
		"currency":         code,
		"amount":           this.ParseToNumeric(amount),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"before":           this.ParseToNumeric(before),
		"after":            this.ParseToNumeric(after),
		"status":           status,
		"fee":              nil,
	}, currency)
}

/**
 * @method
 * @name luno#createDepositAddress
 * @description create a currency deposit address
 * @see https://www.luno.com/en/developers/api#tag/Receive/operation/createFundingAddress
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] an optional name for the new address
 * @param {int} [params.account_id] an optional account id for the new address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *luno) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes13698 := (<-this.LoadMarkets())
		PanicOnError(retRes13698)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"asset": GetValue(currency, "id"),
		}

		response := (<-this.PrivatePostFundingAddress(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "account_id": "string",
		//         "address": "string",
		//         "address_meta": [
		//             {
		//                 "label": "string",
		//                 "value": "string"
		//             }
		//         ],
		//         "asset": "string",
		//         "assigned_at": 0,
		//         "name": "string",
		//         "network": 0,
		//         "qr_code_uri": "string",
		//         "receive_fee": "string",
		//         "total_received": "string",
		//         "total_unconfirmed": "string"
		//     }
		//
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name luno#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.luno.com/en/developers/api#tag/Receive/operation/getFundingAddress
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] a specific cryptocurrency address to retrieve
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *luno) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14098 := (<-this.LoadMarkets())
		PanicOnError(retRes14098)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"asset": GetValue(currency, "id"),
		}

		response := (<-this.PrivateGetFundingAddress(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "account_id": "string",
		//         "address": "string",
		//         "address_meta": [
		//             {
		//                 "label": "string",
		//                 "value": "string"
		//             }
		//         ],
		//         "asset": "string",
		//         "assigned_at": 0,
		//         "name": "string",
		//         "network": 0,
		//         "qr_code_uri": "string",
		//         "receive_fee": "string",
		//         "total_received": "string",
		//         "total_unconfirmed": "string"
		//     }
		//
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}
func (this *luno) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "account_id": "string",
	//         "address": "string",
	//         "address_meta": [
	//             {
	//                 "label": "string",
	//                 "value": "string"
	//             }
	//         ],
	//         "asset": "string",
	//         "assigned_at": 0,
	//         "name": "string",
	//         "network": 0,
	//         "qr_code_uri": "string",
	//         "receive_fee": "string",
	//         "total_received": "string",
	//         "total_unconfirmed": "string"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeStringUpper(depositAddress, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": code,
		"network":  nil,
		"address":  this.SafeString(depositAddress, "address"),
		"tag":      this.SafeString(depositAddress, "name"),
	}
}
func (this *luno) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.Version), "/"), this.ImplodeParams(path, params))
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	if IsTrue(GetArrayLength(ObjectKeys(query))) {
		url = Add(url, Add("?", this.Urlencode(query)))
	}
	if IsTrue(IsTrue((IsEqual(api, "private"))) || IsTrue((IsEqual(api, "exchangePrivate")))) {
		this.CheckRequiredCredentials()
		var auth interface{} = this.StringToBase64(Add(Add(this.ApiKey, ":"), this.Secret))
		headers = map[string]interface{}{
			"Authorization": Add("Basic ", auth),
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *luno) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	var error interface{} = this.SafeValue(response, "error")
	if IsTrue(!IsEqual(error, nil)) {
		panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
	}
	return nil
}

func (this *luno) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
