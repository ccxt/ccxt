package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinex struct {
    Exchange

}

func NewCoinexCore() coinex {
   p := coinex{}
   setDefaults(&p)
   return p
}

func  (this *coinex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinex",
        "name": "CoinEx",
        "version": "v2",
        "countries": []interface{}{"CN"},
        "rateLimit": 2.5,
        "pro": true,
        "certified": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": true,
            "createDepositAddress": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createReduceOnlyOrder": true,
            "createStopLossOrder": true,
            "createStopOrder": true,
            "createTakeProfitOrder": true,
            "createTriggerOrder": true,
            "editOrder": true,
            "fetchBalance": true,
            "fetchBorrowInterest": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": true,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": true,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": true,
            "fetchLeverages": false,
            "fetchLeverageTiers": true,
            "fetchMarginAdjustmentHistory": true,
            "fetchMarketLeverageTiers": "emulated",
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": true,
            "fetchPositionHistory": true,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransfer": false,
            "fetchTransfers": true,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "repayCrossMargin": false,
            "repayIsolatedMargin": true,
            "setLeverage": true,
            "setMarginMode": true,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "3m": "3min",
            "5m": "5min",
            "15m": "15min",
            "30m": "30min",
            "1h": "1hour",
            "2h": "2hour",
            "4h": "4hour",
            "6h": "6hour",
            "12h": "12hour",
            "1d": "1day",
            "3d": "3day",
            "1w": "1week",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",
            "api": map[string]interface{} {
                "public": "https://api.coinex.com",
                "private": "https://api.coinex.com",
                "perpetualPublic": "https://api.coinex.com/perpetual",
                "perpetualPrivate": "https://api.coinex.com/perpetual",
            },
            "www": "https://www.coinex.com",
            "doc": "https://docs.coinex.com/api/v2",
            "fees": "https://www.coinex.com/fees",
            "referral": "https://www.coinex.com/register?refer_code=yw5fz",
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "amm/market": 1,
                        "common/currency/rate": 1,
                        "common/asset/config": 1,
                        "common/maintain/info": 1,
                        "common/temp-maintain/info": 1,
                        "margin/market": 1,
                        "market/info": 1,
                        "market/list": 1,
                        "market/ticker": 1,
                        "market/ticker/all": 1,
                        "market/depth": 1,
                        "market/deals": 1,
                        "market/kline": 1,
                        "market/detail": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "account/amm/balance": 40,
                        "account/investment/balance": 40,
                        "account/balance/history": 40,
                        "account/market/fee": 40,
                        "balance/coin/deposit": 40,
                        "balance/coin/withdraw": 40,
                        "balance/info": 40,
                        "balance/deposit/address/{coin_type}": 40,
                        "contract/transfer/history": 40,
                        "credit/info": 40,
                        "credit/balance": 40,
                        "investment/transfer/history": 40,
                        "margin/account": 1,
                        "margin/config": 1,
                        "margin/loan/history": 40,
                        "margin/transfer/history": 40,
                        "order/deals": 40,
                        "order/finished": 40,
                        "order/pending": 8,
                        "order/status": 8,
                        "order/status/batch": 8,
                        "order/user/deals": 40,
                        "order/stop/finished": 40,
                        "order/stop/pending": 8,
                        "order/user/trade/fee": 1,
                        "order/market/trade/info": 1,
                        "sub_account/balance": 1,
                        "sub_account/transfer/history": 40,
                        "sub_account/auth/api": 40,
                        "sub_account/auth/api/{user_auth_id}": 40,
                    },
                    "post": map[string]interface{} {
                        "balance/coin/withdraw": 40,
                        "contract/balance/transfer": 40,
                        "margin/flat": 40,
                        "margin/loan": 40,
                        "margin/transfer": 40,
                        "order/limit/batch": 40,
                        "order/ioc": 13.334,
                        "order/limit": 13.334,
                        "order/market": 13.334,
                        "order/modify": 13.334,
                        "order/stop/limit": 13.334,
                        "order/stop/market": 13.334,
                        "order/stop/modify": 13.334,
                        "sub_account/transfer": 40,
                        "sub_account/register": 1,
                        "sub_account/unfrozen": 40,
                        "sub_account/frozen": 40,
                        "sub_account/auth/api": 40,
                    },
                    "put": map[string]interface{} {
                        "balance/deposit/address/{coin_type}": 40,
                        "sub_account/unfrozen": 40,
                        "sub_account/frozen": 40,
                        "sub_account/auth/api/{user_auth_id}": 40,
                        "v1/account/settings": 40,
                    },
                    "delete": map[string]interface{} {
                        "balance/coin/withdraw": 40,
                        "order/pending/batch": 40,
                        "order/pending": 13.334,
                        "order/stop/pending": 40,
                        "order/stop/pending/{id}": 13.334,
                        "order/pending/by_client_id": 40,
                        "order/stop/pending/by_client_id": 40,
                        "sub_account/auth/api/{user_auth_id}": 40,
                        "sub_account/authorize/{id}": 40,
                    },
                },
                "perpetualPublic": map[string]interface{} {
                    "get": map[string]interface{} {
                        "ping": 1,
                        "time": 1,
                        "market/list": 1,
                        "market/limit_config": 1,
                        "market/ticker": 1,
                        "market/ticker/all": 1,
                        "market/depth": 1,
                        "market/deals": 1,
                        "market/funding_history": 1,
                        "market/kline": 1,
                    },
                },
                "perpetualPrivate": map[string]interface{} {
                    "get": map[string]interface{} {
                        "market/user_deals": 1,
                        "asset/query": 40,
                        "order/pending": 8,
                        "order/finished": 40,
                        "order/stop_finished": 40,
                        "order/stop_pending": 8,
                        "order/status": 8,
                        "order/stop_status": 8,
                        "position/finished": 40,
                        "position/pending": 40,
                        "position/funding": 40,
                        "position/adl_history": 40,
                        "market/preference": 40,
                        "position/margin_history": 40,
                        "position/settle_history": 40,
                    },
                    "post": map[string]interface{} {
                        "market/adjust_leverage": 1,
                        "market/position_expect": 1,
                        "order/put_limit": 20,
                        "order/put_market": 20,
                        "order/put_stop_limit": 20,
                        "order/put_stop_market": 20,
                        "order/modify": 20,
                        "order/modify_stop": 20,
                        "order/cancel": 20,
                        "order/cancel_all": 40,
                        "order/cancel_batch": 40,
                        "order/cancel_stop": 20,
                        "order/cancel_stop_all": 40,
                        "order/close_limit": 20,
                        "order/close_market": 20,
                        "position/adjust_margin": 20,
                        "position/stop_loss": 20,
                        "position/take_profit": 20,
                        "position/market_close": 20,
                        "order/cancel/by_client_id": 20,
                        "order/cancel_stop/by_client_id": 20,
                        "market/preference": 20,
                    },
                },
            },
            "v2": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "maintain/info": 1,
                        "ping": 1,
                        "time": 1,
                        "spot/market": 1,
                        "spot/ticker": 1,
                        "spot/depth": 1,
                        "spot/deals": 1,
                        "spot/kline": 1,
                        "spot/index": 1,
                        "futures/market": 1,
                        "futures/ticker": 1,
                        "futures/depth": 1,
                        "futures/deals": 1,
                        "futures/kline": 1,
                        "futures/index": 1,
                        "futures/funding-rate": 1,
                        "futures/funding-rate-history": 1,
                        "futures/position-level": 1,
                        "futures/liquidation-history": 1,
                        "futures/basis-history": 1,
                        "assets/deposit-withdraw-config": 1,
                        "assets/all-deposit-withdraw-config": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "account/subs": 1,
                        "account/subs/api-detail": 40,
                        "account/subs/info": 1,
                        "account/subs/api": 40,
                        "account/subs/transfer-history": 40,
                        "account/subs/spot-balance": 1,
                        "account/trade-fee-rate": 40,
                        "assets/spot/balance": 40,
                        "assets/futures/balance": 40,
                        "assets/margin/balance": 1,
                        "assets/financial/balance": 40,
                        "assets/amm/liquidity": 40,
                        "assets/credit/info": 40,
                        "assets/margin/borrow-history": 40,
                        "assets/margin/interest-limit": 1,
                        "assets/deposit-address": 40,
                        "assets/deposit-history": 40,
                        "assets/withdraw": 40,
                        "assets/transfer-history": 40,
                        "spot/order-status": 8,
                        "spot/batch-order-status": 8,
                        "spot/pending-order": 8,
                        "spot/finished-order": 40,
                        "spot/pending-stop-order": 8,
                        "spot/finished-stop-order": 40,
                        "spot/user-deals": 40,
                        "spot/order-deals": 40,
                        "futures/order-status": 8,
                        "futures/batch-order-status": 1,
                        "futures/pending-order": 8,
                        "futures/finished-order": 40,
                        "futures/pending-stop-order": 8,
                        "futures/finished-stop-order": 40,
                        "futures/user-deals": 1,
                        "futures/order-deals": 1,
                        "futures/pending-position": 40,
                        "futures/finished-position": 1,
                        "futures/position-margin-history": 1,
                        "futures/position-funding-history": 40,
                        "futures/position-adl-history": 1,
                        "futures/position-settle-history": 1,
                    },
                    "post": map[string]interface{} {
                        "account/subs": 40,
                        "account/subs/frozen": 40,
                        "account/subs/unfrozen": 40,
                        "account/subs/api": 40,
                        "account/subs/edit-api": 40,
                        "account/subs/delete-api": 40,
                        "account/subs/transfer": 40,
                        "account/settings": 40,
                        "assets/margin/borrow": 40,
                        "assets/margin/repay": 40,
                        "assets/renewal-deposit-address": 40,
                        "assets/withdraw": 40,
                        "assets/cancel-withdraw": 40,
                        "assets/transfer": 40,
                        "assets/amm/add-liquidity": 1,
                        "assets/amm/remove-liquidity": 1,
                        "spot/order": 13.334,
                        "spot/stop-order": 13.334,
                        "spot/batch-order": 40,
                        "spot/batch-stop-order": 1,
                        "spot/modify-order": 13.334,
                        "spot/modify-stop-order": 13.334,
                        "spot/cancel-all-order": 1,
                        "spot/cancel-order": 6.667,
                        "spot/cancel-stop-order": 6.667,
                        "spot/cancel-batch-order": 10,
                        "spot/cancel-batch-stop-order": 10,
                        "spot/cancel-order-by-client-id": 1,
                        "spot/cancel-stop-order-by-client-id": 1,
                        "futures/order": 20,
                        "futures/stop-order": 20,
                        "futures/batch-order": 1,
                        "futures/batch-stop-order": 1,
                        "futures/modify-order": 20,
                        "futures/modify-stop-order": 20,
                        "futures/cancel-all-order": 1,
                        "futures/cancel-order": 10,
                        "futures/cancel-stop-order": 10,
                        "futures/cancel-batch-order": 20,
                        "futures/cancel-batch-stop-order": 20,
                        "futures/cancel-order-by-client-id": 1,
                        "futures/cancel-stop-order-by-client-id": 1,
                        "futures/close-position": 20,
                        "futures/adjust-position-margin": 20,
                        "futures/adjust-position-leverage": 20,
                        "futures/set-position-stop-loss": 20,
                        "futures/set-position-take-profit": 20,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": 0.001,
                "taker": 0.001,
            },
            "funding": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "BCH": 0,
                    "BTC": 0.001,
                    "LTC": 0.001,
                    "ETH": 0.001,
                    "ZEC": 0.0001,
                    "DASH": 0.0001,
                },
            },
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": 0.001,
                "max": nil,
            },
        },
        "options": map[string]interface{} {
            "brokerId": "x-167673045",
            "createMarketBuyOrderRequiresPrice": true,
            "defaultType": "spot",
            "defaultSubType": "linear",
            "fetchDepositAddress": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "accountsByType": map[string]interface{} {
                "spot": "SPOT",
                "margin": "MARGIN",
                "swap": "FUTURES",
            },
            "accountsById": map[string]interface{} {
                "SPOT": "spot",
                "MARGIN": "margin",
                "FUTURES": "swap",
            },
            "networks": map[string]interface{} {
                "BTC": "BTC",
                "BEP20": "BSC",
                "TRC20": "TRC20",
                "ERC20": "ERC20",
                "BRC20": "BRC20",
                "SOL": "SOL",
                "TON": "TON",
                "BSV": "BSV",
                "AVAXC": "AVA_C",
                "AVAXX": "AVA",
                "SUI": "SUI",
                "ACA": "ACA",
                "CHZ": "CHILIZ",
                "ADA": "ADA",
                "ARB": "ARBITRUM",
                "ARBNOVA": "ARBITRUM_NOVA",
                "OP": "OPTIMISM",
                "APT": "APTOS",
                "ATOM": "ATOM",
                "FTM": "FTM",
                "BCH": "BCH",
                "ASTR": "ASTR",
                "LTC": "LTC",
                "MATIC": "MATIC",
                "CRONOS": "CRONOS",
                "DASH": "DASH",
                "DOT": "DOT",
                "ETC": "ETC",
                "ETHW": "ETHPOW",
                "FIL": "FIL",
                "ZIL": "ZIL",
                "DOGE": "DOGE",
                "TIA": "CELESTIA",
                "SEI": "SEI",
                "XRP": "XRP",
                "XMR": "XMR",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": true,
                    "selfTradePrevention": true,
                    "iceberg": true,
                },
                "createOrders": map[string]interface{} {
                    "max": 5,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": nil,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "forDerivatives": map[string]interface{} {
                "extends": "spot",
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "ACM": "Actinium",
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "23": PermissionDenied,
                "24": AuthenticationError,
                "25": AuthenticationError,
                "34": AuthenticationError,
                "35": ExchangeNotAvailable,
                "36": RequestTimeout,
                "213": RateLimitExceeded,
                "107": InsufficientFunds,
                "158": PermissionDenied,
                "600": OrderNotFound,
                "601": InvalidOrder,
                "602": InvalidOrder,
                "606": InvalidOrder,
                "3008": RequestTimeout,
                "3109": InsufficientFunds,
                "3127": InvalidOrder,
                "3600": OrderNotFound,
                "3606": InvalidOrder,
                "3610": ExchangeError,
                "3612": InvalidOrder,
                "3613": InvalidOrder,
                "3614": InvalidOrder,
                "3615": InvalidOrder,
                "3616": InvalidOrder,
                "3617": InvalidOrder,
                "3618": InvalidOrder,
                "3619": InvalidOrder,
                "3620": InvalidOrder,
                "3621": InvalidOrder,
                "3622": InvalidOrder,
                "3627": InvalidOrder,
                "3628": InvalidOrder,
                "3629": InvalidOrder,
                "3632": InvalidOrder,
                "3633": InvalidOrder,
                "3634": InvalidOrder,
                "3635": InvalidOrder,
                "4001": ExchangeNotAvailable,
                "4002": RequestTimeout,
                "4003": ExchangeError,
                "4004": BadRequest,
                "4005": AuthenticationError,
                "4006": AuthenticationError,
                "4007": PermissionDenied,
                "4008": AuthenticationError,
                "4009": ExchangeError,
                "4010": ExchangeError,
                "4011": PermissionDenied,
                "4017": ExchangeError,
                "4115": AccountSuspended,
                "4117": BadSymbol,
                "4123": RateLimitExceeded,
                "4130": ExchangeError,
                "4158": ExchangeError,
                "4213": RateLimitExceeded,
                "4512": PermissionDenied,
            },
            "broad": map[string]interface{} {
                "ip not allow visit": PermissionDenied,
                "service too busy": ExchangeNotAvailable,
            },
        },
    })
}
/**
 * @method
 * @name coinex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-all-deposit-withdrawal-config
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V2PublicGetAssetsAllDepositWithdrawConfig(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "asset": {
            //                     "ccy": "CET",
            //                     "deposit_enabled": true,
            //                     "withdraw_enabled": true,
            //                     "inter_transfer_enabled": true,
            //                     "is_st": false
            //                 },
            //                 "chains": [
            //                     {
            //                         "chain": "CSC",
            //                         "min_deposit_amount": "0.8",
            //                         "min_withdraw_amount": "8",
            //                         "deposit_enabled": true,
            //                         "withdraw_enabled": true,
            //                         "deposit_delay_minutes": 0,
            //                         "safe_confirmations": 10,
            //                         "irreversible_confirmations": 20,
            //                         "deflation_rate": "0",
            //                         "withdrawal_fee": "0.026",
            //                         "withdrawal_precision": 8,
            //                         "memo": "",
            //                         "is_memo_required_for_deposit": false,
            //                         "explorer_asset_url": ""
            //                     },
            //                 ]
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var coin interface{} = GetValue(data, i)
                var asset interface{} = this.SafeDict(coin, "asset", map[string]interface{} {})
                var chains interface{} = this.SafeList(coin, "chains", []interface{}{})
                var currencyId interface{} = this.SafeString(asset, "ccy")
                if IsTrue(IsEqual(currencyId, nil)) {
                    continue
                }
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var canDeposit interface{} = this.SafeBool(asset, "deposit_enabled")
                var canWithdraw interface{} = this.SafeBool(asset, "withdraw_enabled")
                var firstChain interface{} = this.SafeDict(chains, 0, map[string]interface{} {})
                var firstPrecisionString interface{} = this.ParsePrecision(this.SafeString(firstChain, "withdrawal_precision"))
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "code": code,
            "name": nil,
            "active": IsTrue(canDeposit) && IsTrue(canWithdraw),
            "deposit": canDeposit,
            "withdraw": canWithdraw,
            "fee": nil,
            "precision": this.ParseNumber(firstPrecisionString),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
            "info": coin,
        })
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString(chain, "chain")
                    var precisionString interface{} = this.ParsePrecision(this.SafeString(chain, "withdrawal_precision"))
                    var feeString interface{} = this.SafeString(chain, "withdrawal_fee")
                    var minNetworkDepositString interface{} = this.SafeString(chain, "min_deposit_amount")
                    var minNetworkWithdrawString interface{} = this.SafeString(chain, "min_withdraw_amount")
                    var canDepositChain interface{} = this.SafeBool(chain, "deposit_enabled")
                    var canWithdrawChain interface{} = this.SafeBool(chain, "withdraw_enabled")
                    var network interface{} = map[string]interface{} {
                        "id": networkId,
                        "network": networkId,
                        "name": nil,
                        "active": IsTrue(canDepositChain) && IsTrue(canWithdrawChain),
                        "deposit": canDepositChain,
                        "withdraw": canWithdrawChain,
                        "fee": this.ParseNumber(feeString),
                        "precision": this.ParseNumber(precisionString),
                        "limits": map[string]interface{} {
                            "amount": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                            "deposit": map[string]interface{} {
                                "min": this.ParseNumber(minNetworkDepositString),
                                "max": nil,
                            },
                            "withdraw": map[string]interface{} {
                                "min": this.ParseNumber(minNetworkWithdrawString),
                                "max": nil,
                            },
                        },
                        "info": chain,
                    }
                    var networks interface{} = this.SafeDict(GetValue(result, code), "networks", map[string]interface{} {})
                    AddElementToObject(networks, networkId, network)
                    AddElementToObject(GetValue(result, code), "networks", networks)
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchMarkets
 * @description retrieves data on all markets for coinex
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promisesUnresolved interface{} = []interface{}{this.FetchSpotMarkets(params), this.FetchContractMarkets(params)}
        
            promises:= (<-promiseAll(promisesUnresolved))
            PanicOnError(promises)
            var spotMarkets interface{} = GetValue(promises, 0)
            var swapMarkets interface{} = GetValue(promises, 1)
        
            ch <- this.ArrayConcat(spotMarkets, swapMarkets)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchSpotMarkets(params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            response:= (<-this.V2PublicGetSpotMarket(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "base_ccy": "SORA",
            //                 "base_ccy_precision": 8,
            //                 "is_amm_available": true,
            //                 "is_margin_available": false,
            //                 "maker_fee_rate": "0.003",
            //                 "market": "SORAUSDT",
            //                 "min_amount": "500",
            //                 "quote_ccy": "USDT",
            //                 "quote_ccy_precision": 6,
            //                 "taker_fee_rate": "0.003"
            //             },
            //         ],
            //         "message": "OK"
            //     }
            //
            var markets interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "market")
                var baseId interface{} = this.SafeString(market, "base_ccy")
                var quoteId interface{} = this.SafeString(market, "quote_ccy")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": nil,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": this.SafeNumber(market, "taker_fee_rate"),
                    "maker": this.SafeNumber(market, "maker_fee_rate"),
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "base_ccy_precision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quote_ccy_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_amount"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchContractMarkets(params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            response:= (<-this.V2PublicGetFuturesMarket(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "base_ccy": "BTC",
            //                 "base_ccy_precision": 8,
            //                 "contract_type": "inverse",
            //                 "leverage": ["1","2","3","5","8","10","15","20","30","50","100"],
            //                 "maker_fee_rate": "0",
            //                 "market": "BTCUSD",
            //                 "min_amount": "10",
            //                 "open_interest_volume": "2566879",
            //                 "quote_ccy": "USD",
            //                 "quote_ccy_precision": 2,
            //                 "taker_fee_rate": "0"
            //             },
            //         ],
            //         "message": "OK"
            //     }
            //
            var markets interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var entry interface{} = GetValue(markets, i)
                var fees interface{} = this.Fees
                var leverages interface{} = this.SafeList(entry, "leverage", []interface{}{})
                var subType interface{} = this.SafeString(entry, "contract_type")
                var linear interface{} =         (IsEqual(subType, "linear"))
                var inverse interface{} =         (IsEqual(subType, "inverse"))
                var id interface{} = this.SafeString(entry, "market")
                var baseId interface{} = this.SafeString(entry, "base_ccy")
                var quoteId interface{} = this.SafeString(entry, "quote_ccy")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settleId interface{} = Ternary(IsTrue((IsEqual(subType, "linear"))), "USDT", baseId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
                var leveragesLength interface{} =         GetArrayLength(leverages)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": "swap",
                    "spot": false,
                    "margin": false,
                    "swap": true,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": true,
                    "linear": linear,
                    "inverse": inverse,
                    "taker": GetValue(GetValue(fees, "trading"), "taker"),
                    "maker": GetValue(GetValue(fees, "trading"), "maker"),
                    "contractSize": this.ParseNumber("1"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "base_ccy_precision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "quote_ccy_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.SafeNumber(leverages, 0),
                            "max": this.SafeNumber(leverages, Subtract(leveragesLength, 1)),
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(entry, "min_amount"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": entry,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Spot fetchTicker, fetchTickers
    //
    //     {
    //         "close": "62393.47",
    //         "high": "64106.41",
    //         "last": "62393.47",
    //         "low": "59650.01",
    //         "market": "BTCUSDT",
    //         "open": "61616.15",
    //         "period": 86400,
    //         "value": "28711273.4065667262",
    //         "volume": "461.76557205",
    //         "volume_buy": "11.41506354",
    //         "volume_sell": "7.3240169"
    //     }
    //
    // Swap fetchTicker, fetchTickers
    //
    //     {
    //         "close": "62480.08",
    //         "high": "64100",
    //         "index_price": "62443.05",
    //         "last": "62480.08",
    //         "low": "59600",
    //         "mark_price": "62443.05",
    //         "market": "BTCUSDT",
    //         "open": "61679.98",
    //         "period": 86400,
    //         "value": "180226025.69791713065326633165",
    //         "volume": "2900.2218",
    //         "volume_buy": "7.3847",
    //         "volume_sell": "6.1249"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketType interface{} = Ternary(IsTrue((InOp(ticker, "mark_price"))), "swap", "spot")
    var marketId interface{} = this.SafeString(ticker, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, marketType)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": this.SafeString(ticker, "volume_buy"),
        "ask": nil,
        "askVolume": this.SafeString(ticker, "volume_sell"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": this.SafeString(ticker, "close"),
        "last": this.SafeString(ticker, "last"),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
        "markPrice": this.SafeString(ticker, "mark_price"),
        "indexPrice": this.SafeString(ticker, "index_price"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10738 := (<-this.LoadMarkets())
            PanicOnError(retRes10738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PublicGetFuturesTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotTicker(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // Spot
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "62393.47",
            //                 "high": "64106.41",
            //                 "last": "62393.47",
            //                 "low": "59650.01",
            //                 "market": "BTCUSDT",
            //                 "open": "61616.15",
            //                 "period": 86400,
            //                 "value": "28711273.4065667262",
            //                 "volume": "461.76557205",
            //                 "volume_buy": "11.41506354",
            //                 "volume_sell": "7.3240169"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            // Swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "62480.08",
            //                 "high": "64100",
            //                 "index_price": "62443.05",
            //                 "last": "62480.08",
            //                 "low": "59600",
            //                 "mark_price": "62443.05",
            //                 "market": "BTCUSDT",
            //                 "open": "61679.98",
            //                 "period": 86400,
            //                 "value": "180226025.69791713065326633165",
            //                 "volume": "2900.2218",
            //                 "volume_buy": "7.3847",
            //                 "volume_sell": "6.1249"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11478 := (<-this.LoadMarkets())
            PanicOnError(retRes11478)
            symbols = this.MarketSymbols(symbols)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeValue(symbols, 0)
                market = this.Market(symbol)
            }
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.V2PublicGetFuturesTicker(query))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotTicker(query))
                PanicOnError(response)
            }
            //
            // Spot
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "62393.47",
            //                 "high": "64106.41",
            //                 "last": "62393.47",
            //                 "low": "59650.01",
            //                 "market": "BTCUSDT",
            //                 "open": "61616.15",
            //                 "period": 86400,
            //                 "value": "28711273.4065667262",
            //                 "volume": "461.76557205",
            //                 "volume_buy": "11.41506354",
            //                 "volume_sell": "7.3240169"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            // Swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "62480.08",
            //                 "high": "64100",
            //                 "index_price": "62443.05",
            //                 "last": "62480.08",
            //                 "low": "59600",
            //                 "mark_price": "62443.05",
            //                 "market": "BTCUSDT",
            //                 "open": "61679.98",
            //                 "period": 86400,
            //                 "value": "180226025.69791713065326633165",
            //                 "volume": "2900.2218",
            //                 "volume_buy": "7.3847",
            //                 "volume_sell": "6.1249"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.coinex.com/api/v2/common/http/time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *coinex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V2PublicGetTime(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "timestamp": 1711699867777
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeInteger(data, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-depth
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, 20)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12478 := (<-this.LoadMarkets())
            PanicOnError(retRes12478)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 20 // default
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "limit": limit,
                "interval": "0",
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PublicGetFuturesDepth(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotDepth(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var depth interface{} = this.SafeDict(data, "depth", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(depth, "updated_at")
        
            ch <- this.ParseOrderBook(depth, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Spot and Swap fetchTrades (public)
    //
    //     {
    //         "amount": "0.00049432",
    //         "created_at": 1713849825667,
    //         "deal_id": 4137517302,
    //         "price": "66251",
    //         "side": "buy"
    //     }
    //
    // Spot and Margin fetchMyTrades (private)
    //
    //     {
    //         "amount": "0.00010087",
    //         "created_at": 1714618087585,
    //         "deal_id": 4161200602,
    //         "margin_market": "",
    //         "market": "BTCUSDT",
    //         "order_id": 117654919342,
    //         "price": "57464.04",
    //         "side": "sell"
    //     }
    //
    // Swap fetchMyTrades (private)
    //
    //     {
    //         "deal_id": 1180222387,
    //         "created_at": 1714119054558,
    //         "market": "BTCUSDT",
    //         "side": "buy",
    //         "order_id": 136915589622,
    //         "price": "64376",
    //         "amount": "0.0001",
    //         "role": "taker",
    //         "fee": "0.0299",
    //         "fee_ccy": "USDT"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "created_at")
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    if IsTrue(!IsEqual(market, nil)) {
        defaultType = GetValue(market, "type")
    }
    var marketId interface{} = this.SafeString(trade, "market")
    market = this.SafeMarket(marketId, market, nil, defaultType)
    var feeCostString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "fee_ccy")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "id": this.SafeString(trade, "deal_id"),
        "order": this.SafeString(trade, "order_id"),
        "type": nil,
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": this.SafeString(trade, "role"),
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "amount"),
        "cost": this.SafeString(trade, "deal_money"),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coinex#fetchTrades
 * @description get the list of the most recent trades for a particular symbol
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-deals
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-deals
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14068 := (<-this.LoadMarkets())
            PanicOnError(retRes14068)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PublicGetFuturesDeals(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotDeals(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // Spot and Swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "amount": "0.00049432",
            //                 "created_at": 1713849825667,
            //                 "deal_id": 4137517302,
            //                 "price": "66251",
            //                 "side": "buy"
            //             },
            //         ],
            //         "message": "OK"
            //     }
            //
        ch <- this.ParseTrades(GetValue(response, "data"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *coinex) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14528 := (<-this.LoadMarkets())
            PanicOnError(retRes14528)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.V2PublicGetSpotMarket(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetFuturesMarket(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTradingFee(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *coinex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15198 := (<-this.LoadMarkets())
            PanicOnError(retRes15198)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "swap")) {
                
        response = (<-this.V2PublicGetFuturesMarket(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotMarket(params))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(entry, "market")
                var market interface{} = this.SafeMarket(marketId, nil, nil, typeVar)
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, this.ParseTradingFee(entry, market))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeValue(fee, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "maker_fee_rate"),
        "taker": this.SafeNumber(fee, "taker_fee_rate"),
        "percentage": true,
        "tierBased": true,
    }
}
func  (this *coinex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": "66999.95",
    //         "created_at": 1713934620000,
    //         "high": "66999.95",
    //         "low": "66988.53",
    //         "market": "BTCUSDT",
    //         "open": "66988.53",
    //         "value": "0.1572393",        // base volume
    //         "volume": "10533.2501364336" // quote volume
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "created_at"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "value")}
}
/**
 * @method
 * @name coinex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-kline
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-kline
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coinex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16318 := (<-this.LoadMarkets())
            PanicOnError(retRes16318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PublicGetFuturesKline(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetSpotKline(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // Spot and Swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "66999.95",
            //                 "created_at": 1713934620000,
            //                 "high": "66999.95",
            //                 "low": "66988.53",
            //                 "market": "BTCUSDT",
            //                 "open": "66988.53",
            //                 "value": "0.1572393",
            //                 "volume": "10533.2501364336"
            //             },
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchMarginBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16718 := (<-this.LoadMarkets())
            PanicOnError(retRes16718)
        
            response:= (<-this.V2PrivateGetAssetsMarginBalance(params))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "margin_account": "BTCUSDT",
            //                 "base_ccy": "BTC",
            //                 "quote_ccy": "USDT",
            //                 "available": {
            //                     "base_ccy": "0.00000026",
            //                     "quote_ccy": "0"
            //                 },
            //                 "frozen": {
            //                     "base_ccy": "0",
            //                     "quote_ccy": "0"
            //                 },
            //                 "repaid": {
            //                     "base_ccy": "0",
            //                     "quote_ccy": "0"
            //                 },
            //                 "interest": {
            //                     "base_ccy": "0",
            //                     "quote_ccy": "0"
            //                 },
            //                 "rik_rate": "",
            //                 "liq_price": ""
            //             },
            //         ],
            //         "code": 0,
            //         "message": "OK"
            //     }
            //
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            var balances interface{} = this.SafeList(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var entry interface{} = GetValue(balances, i)
                var free interface{} = this.SafeDict(entry, "available", map[string]interface{} {})
                var used interface{} = this.SafeDict(entry, "frozen", map[string]interface{} {})
                var loan interface{} = this.SafeDict(entry, "repaid", map[string]interface{} {})
                var interest interface{} = this.SafeDict(entry, "interest", map[string]interface{} {})
                var baseAccount interface{} = this.Account()
                var baseCurrencyId interface{} = this.SafeString(entry, "base_ccy")
                var baseCurrencyCode interface{} = this.SafeCurrencyCode(baseCurrencyId)
                AddElementToObject(baseAccount, "free", this.SafeString(free, "base_ccy"))
                AddElementToObject(baseAccount, "used", this.SafeString(used, "base_ccy"))
                var baseDebt interface{} = this.SafeString(loan, "base_ccy")
                var baseInterest interface{} = this.SafeString(interest, "base_ccy")
                AddElementToObject(baseAccount, "debt", Precise.StringAdd(baseDebt, baseInterest))
                AddElementToObject(result, baseCurrencyCode, baseAccount)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchSpotBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17268 := (<-this.LoadMarkets())
            PanicOnError(retRes17268)
        
            response:= (<-this.V2PrivateGetAssetsSpotBalance(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "available": "0.00000046",
            //                 "ccy": "USDT",
            //                 "frozen": "0"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            var balances interface{} = this.SafeList(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var entry interface{} = GetValue(balances, i)
                var currencyId interface{} = this.SafeString(entry, "ccy")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                AddElementToObject(account, "free", this.SafeString(entry, "available"))
                AddElementToObject(account, "used", this.SafeString(entry, "frozen"))
                AddElementToObject(result, code, account)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchSwapBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17568 := (<-this.LoadMarkets())
            PanicOnError(retRes17568)
        
            response:= (<-this.V2PrivateGetAssetsFuturesBalance(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "available": "0.00000046",
            //                 "ccy": "USDT",
            //                 "frozen": "0",
            //                 "margin": "0",
            //                 "transferrable": "0.00000046",
            //                 "unrealized_pnl": "0"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            var balances interface{} = this.SafeList(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var entry interface{} = GetValue(balances, i)
                var currencyId interface{} = this.SafeString(entry, "ccy")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                AddElementToObject(account, "free", this.SafeString(entry, "available"))
                AddElementToObject(account, "used", this.SafeString(entry, "frozen"))
                AddElementToObject(result, code, account)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) FetchFinancialBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17898 := (<-this.LoadMarkets())
            PanicOnError(retRes17898)
        
            response:= (<-this.V2PrivateGetAssetsFinancialBalance(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "available": "0.00000046",
            //                 "ccy": "USDT",
            //                 "frozen": "0"
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            var balances interface{} = this.SafeList(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var entry interface{} = GetValue(balances, i)
                var currencyId interface{} = this.SafeString(entry, "ccy")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                AddElementToObject(account, "free", this.SafeString(entry, "available"))
                AddElementToObject(account, "used", this.SafeString(entry, "frozen"))
                AddElementToObject(result, code, account)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.coinex.com/api/v2/assets/balance/http/get-spot-balance         // spot
 * @see https://docs.coinex.com/api/v2/assets/balance/http/get-futures-balance      // swap
 * @see https://docs.coinex.com/api/v2/assets/balance/http/get-marigin-balance      // margin
 * @see https://docs.coinex.com/api/v2/assets/balance/http/get-financial-balance    // financial
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'margin', 'swap', 'financial', or 'spot'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var isMargin interface{} = IsTrue((!IsEqual(marginMode, nil))) || IsTrue((IsEqual(marketType, "margin")))
            if IsTrue(IsEqual(marketType, "swap")) {
        
                    retRes183719 :=  (<-this.FetchSwapBalance(params))
                    PanicOnError(retRes183719)
                    ch <- retRes183719
                    return nil
            } else if IsTrue(IsEqual(marketType, "financial")) {
        
                    retRes183919 :=  (<-this.FetchFinancialBalance(params))
                    PanicOnError(retRes183919)
                    ch <- retRes183919
                    return nil
            } else if IsTrue(isMargin) {
        
                    retRes184119 :=  (<-this.FetchMarginBalance(params))
                    PanicOnError(retRes184119)
                    ch <- retRes184119
                    return nil
            } else {
        
                    retRes184319 :=  (<-this.FetchSpotBalance(params))
                    PanicOnError(retRes184319)
                    ch <- retRes184319
                    return nil
            }
                return nil
            }()
            return ch
        }
func  (this *coinex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "rejected": "rejected",
        "open": "open",
        "not_deal": "open",
        "part_deal": "open",
        "done": "closed",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Spot and Margin createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders
    //
    //     {
    //         "amount": "0.0001",
    //         "base_fee": "0",
    //         "ccy": "BTC",
    //         "client_id": "x-167673045-a0a3c6461459a801",
    //         "created_at": 1714114386250,
    //         "discount_fee": "0",
    //         "filled_amount": "0",
    //         "filled_value": "0",
    //         "last_fill_amount": "0",
    //         "last_fill_price": "0",
    //         "maker_fee_rate": "0.002",
    //         "market": "BTCUSDT",
    //         "market_type": "SPOT",
    //         "order_id": 117178743547,
    //         "price": "61000",
    //         "quote_fee": "0",
    //         "side": "buy",
    //         "taker_fee_rate": "0.002",
    //         "type": "limit",
    //         "unfilled_amount": "0.0001",
    //         "updated_at": 1714114386250
    //     }
    //
    // Spot and Margin fetchClosedOrders
    //
    //     {
    //         "order_id": 117180532345,
    //         "market": "BTCUSDT",
    //         "market_type": "SPOT",
    //         "side": "sell",
    //         "type": "market",
    //         "ccy": "BTC",
    //         "amount": "0.00015484",
    //         "price": "0",
    //         "client_id": "",
    //         "created_at": 1714116494219,
    //         "updated_at": 0,
    //         "base_fee": "0",
    //         "quote_fee": "0.0199931699632",
    //         "discount_fee": "0",
    //         "maker_fee_rate": "0",
    //         "taker_fee_rate": "0.002",
    //         "unfilled_amount": "0",
    //         "filled_amount": "0.00015484",
    //         "filled_value": "9.9965849816"
    //     }
    //
    // Spot, Margin and Swap trigger createOrder, createOrders, editOrder
    //
    //     {
    //         "stop_id": 117180138153
    //     }
    //
    // Swap createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders, fetchClosedOrders, closePosition
    //
    //     {
    //         "amount": "0.0001",
    //         "client_id": "x-167673045-1471b81d747080a0",
    //         "created_at": 1714116769986,
    //         "fee": "0",
    //         "fee_ccy": "USDT",
    //         "filled_amount": "0",
    //         "filled_value": "0",
    //         "last_filled_amount": "0",
    //         "last_filled_price": "0",
    //         "maker_fee_rate": "0.0003",
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "order_id": 136913377780,
    //         "price": "61000.42",
    //         "realized_pnl": "0",
    //         "side": "buy",
    //         "taker_fee_rate": "0.0005",
    //         "type": "limit",
    //         "unfilled_amount": "0.0001",
    //         "updated_at": 1714116769986
    //     }
    //
    // Swap stopLossPrice and takeProfitPrice createOrder
    //
    //     {
    //         "adl_level": 1,
    //         "ath_margin_size": "2.14586666",
    //         "ath_position_amount": "0.0001",
    //         "avg_entry_price": "64376",
    //         "bkr_price": "0",
    //         "close_avbl": "0.0001",
    //         "cml_position_value": "6.4376",
    //         "created_at": 1714119054558,
    //         "leverage": "3",
    //         "liq_price": "0",
    //         "maintenance_margin_rate": "0.005",
    //         "maintenance_margin_value": "0.03218632",
    //         "margin_avbl": "2.14586666",
    //         "margin_mode": "cross",
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "max_position_value": "6.4376",
    //         "open_interest": "0.0001",
    //         "position_id": 303884204,
    //         "position_margin_rate": "3.10624785634397912265",
    //         "realized_pnl": "-0.0032188",
    //         "settle_price": "64376",
    //         "settle_value": "6.4376",
    //         "side": "long",
    //         "stop_loss_price": "62000",
    //         "stop_loss_type": "latest_price",
    //         "take_profit_price": "0",
    //         "take_profit_type": "",
    //         "unrealized_pnl": "0",
    //         "updated_at": 1714119054559
    //     }
    //
    // Swap fetchOrder
    //
    //     {
    //         "amount": "0.0001",
    //         "client_id": "x-167673045-da5f31dcd478a829",
    //         "created_at": 1714460987164,
    //         "fee": "0",
    //         "fee_ccy": "USDT",
    //         "filled_amount": "0",
    //         "filled_value": "0",
    //         "last_filled_amount": "0",
    //         "last_filled_price": "0",
    //         "maker_fee_rate": "0.0003",
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "order_id": 137319868771,
    //         "price": "61000",
    //         "realized_pnl": "0",
    //         "side": "buy",
    //         "status": "open",
    //         "taker_fee_rate": "0.0005",
    //         "type": "limit",
    //         "unfilled_amount": "0.0001",
    //         "updated_at": 1714460987164
    //     }
    //
    // Spot and Margin fetchOrder
    //
    //     {
    //         "amount": "0.0001",
    //         "base_fee": "0",
    //         "ccy": "BTC",
    //         "client_id": "x-167673045-da918d6724e3af81",
    //         "created_at": 1714461638958,
    //         "discount_fee": "0",
    //         "filled_amount": "0",
    //         "filled_value": "0",
    //         "last_fill_amount": "0",
    //         "last_fill_price": "0",
    //         "maker_fee_rate": "0.002",
    //         "market": "BTCUSDT",
    //         "market_type": "SPOT",
    //         "order_id": 117492012985,
    //         "price": "61000",
    //         "quote_fee": "0",
    //         "side": "buy",
    //         "status": "open",
    //         "taker_fee_rate": "0.002",
    //         "type": "limit",
    //         "unfilled_amount": "0.0001",
    //         "updated_at": 1714461638958
    //     }
    //
    // Swap trigger fetchOpenOrders, fetchClosedOrders - Spot and Swap trigger cancelOrders, cancelOrder
    //
    //     {
    //         "amount": "0.0001",
    //         "client_id": "x-167673045-a7d7714c6478acf6",
    //         "created_at": 1714187923820,
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "price": "61000",
    //         "side": "buy",
    //         "stop_id": 136984426097,
    //         "trigger_direction": "higher",
    //         "trigger_price": "62000",
    //         "trigger_price_type": "latest_price",
    //         "type": "limit",
    //         "updated_at": 1714187974363
    //     }
    //
    // Spot and Margin trigger fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "stop_id": 117586439530,
    //         "market": "BTCUSDT",
    //         "market_type": "SPOT",
    //         "ccy": "BTC",
    //         "side": "buy",
    //         "type": "limit",
    //         "amount": "0.0001",
    //         "price": "51000",
    //         "trigger_price": "52000",
    //         "trigger_direction": "higher",
    //         "trigger_price_type": "mark_price",
    //         "client_id": "x-167673045-df61777094c69312",
    //         "created_at": 1714551237335,
    //         "updated_at": 1714551237335
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var rawStatus interface{} = this.SafeString(order, "status")
    var timestamp interface{} = this.SafeInteger(order, "created_at")
    var updatedTimestamp interface{} = this.SafeInteger(order, "updated_at")
    if IsTrue(IsEqual(updatedTimestamp, 0)) {
        updatedTimestamp = timestamp
    }
    var marketId interface{} = this.SafeString(order, "market")
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var orderType interface{} = this.SafeStringLower(order, "market_type", defaultType)
    if IsTrue(IsEqual(orderType, "futures")) {
        orderType = "swap"
    }
    var marketType interface{} = Ternary(IsTrue((IsEqual(orderType, "swap"))), "swap", "spot")
    market = this.SafeMarket(marketId, market, nil, marketType)
    var feeCurrencyId interface{} = this.SafeString(order, "fee_ccy")
    var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
    if IsTrue(IsEqual(feeCurrency, nil)) {
        feeCurrency = GetValue(market, "quote")
    }
    var side interface{} = this.SafeString(order, "side")
    if IsTrue(IsEqual(side, "long")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "short")) {
        side = "sell"
    }
    var clientOrderId interface{} = this.SafeString(order, "client_id")
    if IsTrue(IsEqual(clientOrderId, "")) {
        clientOrderId = nil
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeStringN(order, []interface{}{"position_id", "order_id", "stop_id"}),
        "clientOrderId": clientOrderId,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": updatedTimestamp,
        "status": this.ParseOrderStatus(rawStatus),
        "symbol": GetValue(market, "symbol"),
        "type": this.SafeString(order, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "reduceOnly": nil,
        "side": side,
        "price": this.SafeString(order, "price"),
        "triggerPrice": this.SafeString(order, "trigger_price"),
        "takeProfitPrice": this.SafeNumber(order, "take_profit_price"),
        "stopLossPrice": this.SafeNumber(order, "stop_loss_price"),
        "cost": this.SafeString(order, "filled_value"),
        "average": this.SafeString(order, "avg_entry_price"),
        "amount": this.SafeString(order, "amount"),
        "filled": this.SafeString(order, "filled_amount"),
        "remaining": this.SafeString(order, "unfilled_amount"),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": feeCurrency,
            "cost": this.SafeString2(order, "quote_fee", "fee"),
        },
        "info": order,
    }, market)
}
/**
 * @method
 * @name coinex#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade003_market_order
 * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21398 := (<-this.LoadMarkets())
            PanicOnError(retRes21398)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes214515 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes214515)
                ch <- retRes214515
                return nil
        
            }()
            return ch
        }
func  (this *coinex) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var swap interface{} = GetValue(market, "swap")
    var clientOrderId interface{} = this.SafeString2(params, "client_id", "clientOrderId")
    var triggerPrice interface{} = this.SafeString2(params, "stopPrice", "triggerPrice")
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var option interface{} = this.SafeString(params, "option")
    var isMarketOrder interface{} = IsEqual(typeVar, "market")
    var postOnly interface{} = this.IsPostOnly(isMarketOrder, IsEqual(option, "maker_only"), params)
    var timeInForceRaw interface{} = this.SafeStringUpper(params, "timeInForce")
    var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
    if IsTrue(reduceOnly) {
        if !IsTrue(GetValue(market, "swap")) {
            panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() does not support reduceOnly for "), GetValue(market, "type")), " orders, reduceOnly orders are supported for swap markets only")))
        }
    }
    var request interface{} = map[string]interface{} {
        "market": GetValue(market, "id"),
    }
    if IsTrue(IsEqual(clientOrderId, nil)) {
        var defaultId interface{} = "x-167673045"
        var brokerId interface{} = this.SafeString(this.Options, "brokerId", defaultId)
        AddElementToObject(request, "client_id", Add(Add(brokerId, "-"), this.Uuid16()))
    } else {
        AddElementToObject(request, "client_id", clientOrderId)
    }
    if IsTrue(IsTrue((IsEqual(stopLossPrice, nil))) && IsTrue((IsEqual(takeProfitPrice, nil)))) {
        if !IsTrue(reduceOnly) {
            AddElementToObject(request, "side", side)
        }
        var requestType interface{} = typeVar
        if IsTrue(postOnly) {
            requestType = "maker_only"
        } else if IsTrue(!IsEqual(timeInForceRaw, nil)) {
            if IsTrue(IsEqual(timeInForceRaw, "IOC")) {
                requestType = "ioc"
            } else if IsTrue(IsEqual(timeInForceRaw, "FOK")) {
                requestType = "fok"
            }
        }
        if !IsTrue(isMarketOrder) {
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        }
        AddElementToObject(request, "type", requestType)
    }
    if IsTrue(swap) {
        AddElementToObject(request, "market_type", "FUTURES")
        if IsTrue(IsTrue(stopLossPrice) || IsTrue(takeProfitPrice)) {
            if IsTrue(stopLossPrice) {
                AddElementToObject(request, "stop_loss_price", this.PriceToPrecision(symbol, stopLossPrice))
                AddElementToObject(request, "stop_loss_type", this.SafeString(params, "stop_type", "latest_price"))
            } else if IsTrue(takeProfitPrice) {
                AddElementToObject(request, "take_profit_price", this.PriceToPrecision(symbol, takeProfitPrice))
                AddElementToObject(request, "take_profit_type", this.SafeString(params, "stop_type", "latest_price"))
            }
        } else {
            AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "trigger_price_type", this.SafeString(params, "stop_type", "latest_price"))
            }
        }
    } else {
        var marginMode interface{} = nil
        marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
        marginMode = GetValue(marginModeparamsVariable,0);
        params = GetValue(marginModeparamsVariable,1)
        if IsTrue(!IsEqual(marginMode, nil)) {
            AddElementToObject(request, "market_type", "MARGIN")
        } else {
            AddElementToObject(request, "market_type", "SPOT")
        }
        if IsTrue(IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))) {
            var createMarketBuyOrderRequiresPrice interface{} = true
            createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
            params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
            var cost interface{} = this.SafeNumber(params, "cost")
            params = this.Omit(params, "cost")
            if IsTrue(createMarketBuyOrderRequiresPrice) {
                if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                } else {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var quoteAmount interface{} = this.ParseToNumeric(Precise.StringMul(amountString, priceString))
                    var costRequest interface{} = Ternary(IsTrue((!IsEqual(cost, nil))), cost, quoteAmount)
                    AddElementToObject(request, "amount", this.CostToPrecision(symbol, costRequest))
                }
            } else {
                AddElementToObject(request, "amount", this.CostToPrecision(symbol, amount))
            }
        } else {
            AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
        }
        if IsTrue(!IsEqual(triggerPrice, nil)) {
            AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
        }
    }
    params = this.Omit(params, []interface{}{"reduceOnly", "timeInForce", "postOnly", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name coinex#createOrder
 * @description create a trade order
 * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/put-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/put-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/put-stop-order
 * @see https://docs.coinex.com/api/v2/futures/position/http/close-position
 * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-stop-loss
 * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-take-profit
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] price to trigger stop orders
 * @param {float} [params.stopLossPrice] price to trigger stop loss orders
 * @param {float} [params.takeProfitPrice] price to trigger take profit orders
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', 'PO'
 * @param {boolean} [params.postOnly] set to true if you wish to make a post only order
 * @param {boolean} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22748 := (<-this.LoadMarkets())
            PanicOnError(retRes22748)
            var market interface{} = this.Market(symbol)
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
            var triggerPrice interface{} = this.SafeString2(params, "stopPrice", "triggerPrice")
            var stopLossTriggerPrice interface{} = this.SafeString(params, "stopLossPrice")
            var takeProfitTriggerPrice interface{} = this.SafeString(params, "takeProfitPrice")
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
            var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
            var isStopLossOrTakeProfitTrigger interface{} = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostSpotStopOrder(request))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostSpotOrder(request))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostFuturesStopOrder(request))
                    PanicOnError(response)
                } else if IsTrue(isStopLossOrTakeProfitTrigger) {
                    if IsTrue(isStopLossTriggerOrder) {
                        
        response = (<-this.V2PrivatePostFuturesSetPositionStopLoss(request))
                        PanicOnError(response)
                    } else if IsTrue(isTakeProfitTriggerOrder) {
                        
        response = (<-this.V2PrivatePostFuturesSetPositionTakeProfit(request))
                        PanicOnError(response)
                    }
                } else {
                    if IsTrue(reduceOnly) {
                        
        response = (<-this.V2PrivatePostFuturesClosePosition(request))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivatePostFuturesOrder(request))
                        PanicOnError(response)
                    }
                }
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-stop-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25058 := (<-this.LoadMarkets())
            PanicOnError(retRes25058)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            var reduceOnly interface{} = false
            var isTriggerOrder interface{} = false
            var isStopLossOrTakeProfitTrigger interface{} = false
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{} {})
                if IsTrue(!IsEqual(typeVar, "limit")) {
                    panic(NotSupported(Add(Add(Add(this.Id, " createOrders() does not support "), typeVar), " orders, only limit orders are accepted")))
                }
                reduceOnly = this.SafeValue(orderParams, "reduceOnly")
                var triggerPrice interface{} = this.SafeNumber2(orderParams, "stopPrice", "triggerPrice")
                var stopLossTriggerPrice interface{} = this.SafeNumber(orderParams, "stopLossPrice")
                var takeProfitTriggerPrice interface{} = this.SafeNumber(orderParams, "takeProfitPrice")
                isTriggerOrder = !IsEqual(triggerPrice, nil)
                var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
                var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
                isStopLossOrTakeProfitTrigger = IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "orders": ordersRequests,
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostSpotBatchStopOrder(request))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostSpotBatchOrder(request))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostFuturesBatchStopOrder(request))
                    PanicOnError(response)
                } else if IsTrue(isStopLossOrTakeProfitTrigger) {
                    panic(NotSupported(Add(this.Id, " createOrders() does not support stopLossPrice or takeProfitPrice orders")))
                } else {
                    if IsTrue(reduceOnly) {
                        panic(NotSupported(Add(this.Id, " createOrders() does not support reduceOnly orders")))
                    } else {
                        
        response = (<-this.V2PrivatePostFuturesBatchOrder(request))
                        PanicOnError(response)
                    }
                }
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var results interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var status interface{} = nil
                var code interface{} = this.SafeInteger(entry, "code")
                if IsTrue(!IsEqual(code, nil)) {
                    if IsTrue(!IsEqual(code, 0)) {
                        status = "rejected"
                    } else {
                        status = "open"
                    }
                }
                var innerData interface{} = this.SafeDict(entry, "data", map[string]interface{} {})
                var order interface{} = nil
                if IsTrue(IsTrue(GetValue(market, "spot")) && !IsTrue(isTriggerOrder)) {
                    AddElementToObject(entry, "status", status)
                    order = this.ParseOrder(entry, market)
                } else {
                    AddElementToObject(innerData, "status", status)
                    order = this.ParseOrder(innerData, market)
                }
                AppendToArray(&results,order)
            }
        
            ch <- results
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#cancelOrders
 * @description cancel multiple orders
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-stop-order
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for canceling stop orders
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes27108 := (<-this.LoadMarkets())
            PanicOnError(retRes27108)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            var requestIds interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                AppendToArray(&requestIds,ParseInt(GetValue(ids, i)))
            }
            if IsTrue(trigger) {
                AddElementToObject(request, "stop_ids", requestIds)
            } else {
                AddElementToObject(request, "order_ids", requestIds)
            }
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(trigger) {
                    
        response = (<-this.V2PrivatePostSpotCancelBatchStopOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostSpotCancelBatchOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                AddElementToObject(request, "market_type", "FUTURES")
                if IsTrue(trigger) {
                    
        response = (<-this.V2PrivatePostFuturesCancelBatchStopOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostFuturesCancelBatchOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var results interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var item interface{} = this.SafeDict(entry, "data", map[string]interface{} {})
                var order interface{} = this.ParseOrder(item, market)
                AppendToArray(&results,order)
            }
        
            ch <- results
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#editOrder
 * @description edit a trade order
 * @see https://docs.coinex.com/api/v2/spot/order/http/edit-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/edit-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/edit-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/edit-stop-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price to trigger stop orders
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a symbol argument")))
            }
        
            retRes28988 := (<-this.LoadMarkets())
            PanicOnError(retRes28988)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var response interface{} = nil
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"stopPrice", "triggerPrice", "trigger_price"})
            params = this.Omit(params, []interface{}{"stopPrice", "triggerPrice"})
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            if IsTrue(isTriggerOrder) {
                AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "stop_id", this.ParseToNumeric(id))
            } else {
                AddElementToObject(request, "order_id", this.ParseToNumeric(id))
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("editOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "market_type", "MARGIN")
                } else {
                    AddElementToObject(request, "market_type", "SPOT")
                }
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostSpotModifyStopOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostSpotModifyOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                AddElementToObject(request, "market_type", "FUTURES")
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.V2PrivatePostFuturesModifyStopOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V2PrivatePostFuturesModifyOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#cancelOrder
 * @description cancels an open order
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order-by-client-id
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order-by-client-id
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order-by-client-id
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order-by-client-id
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
 * @param {boolean} [params.trigger] set to true for canceling a trigger order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes30438 := (<-this.LoadMarkets())
            PanicOnError(retRes30438)
            var market interface{} = this.Market(symbol)
            var isTriggerOrder interface{} = this.SafeBool2(params, "stop", "trigger")
            var swap interface{} = GetValue(market, "swap")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(swap) {
                AddElementToObject(request, "market_type", "FUTURES")
            } else {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "market_type", "MARGIN")
                } else {
                    AddElementToObject(request, "market_type", "SPOT")
                }
            }
            var clientOrderId interface{} = this.SafeString2(params, "client_id", "clientOrderId")
            params = this.Omit(params, []interface{}{"stop", "trigger", "clientOrderId"})
            var response interface{} = nil
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_id", clientOrderId)
                if IsTrue(isTriggerOrder) {
                    if IsTrue(swap) {
                        
        response = (<-this.V2PrivatePostFuturesCancelStopOrderByClientId(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivatePostSpotCancelStopOrderByClientId(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    if IsTrue(swap) {
                        
        response = (<-this.V2PrivatePostFuturesCancelOrderByClientId(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivatePostSpotCancelOrderByClientId(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            } else {
                if IsTrue(isTriggerOrder) {
                    AddElementToObject(request, "stop_id", this.ParseToNumeric(id))
                    if IsTrue(swap) {
                        
        response = (<-this.V2PrivatePostFuturesCancelStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivatePostSpotCancelStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    AddElementToObject(request, "order_id", this.ParseToNumeric(id))
                    if IsTrue(swap) {
                        
        response = (<-this.V2PrivatePostFuturesCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivatePostSpotCancelOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            }
            var data interface{} = nil
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                var rows interface{} = this.SafeList(response, "data", []interface{}{})
                data = this.SafeDict(GetValue(rows, 0), "data", map[string]interface{} {})
            } else {
                data = this.SafeDict(response, "data", map[string]interface{} {})
            }
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-all-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-all-order
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' for canceling spot margin orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes33308 := (<-this.LoadMarkets())
            PanicOnError(retRes33308)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "market_type", "FUTURES")
                
        response = (<-this.V2PrivatePostFuturesCancelAllOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "market_type", "MARGIN")
                } else {
                    AddElementToObject(request, "market_type", "SPOT")
                }
                
        response = (<-this.V2PrivatePostSpotCancelAllOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.coinex.com/api/v2/spot/order/http/get-order-status
 * @see https://docs.coinex.com/api/v2/futures/order/http/get-order-status
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes33778 := (<-this.LoadMarkets())
            PanicOnError(retRes33778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "order_id": this.ParseToNumeric(id),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PrivateGetFuturesOrderStatus(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PrivateGetSpotOrderStatus(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchOrdersByStatus
 * @description fetch a list of orders
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
 * @param {string} status order status to fetch for
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes34708 := (<-this.LoadMarkets())
            PanicOnError(retRes34708)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrdersByStatus", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            var isClosed interface{} = IsTrue((IsEqual(status, "finished"))) || IsTrue((IsEqual(status, "closed")))
            var isOpen interface{} = IsTrue((IsEqual(status, "pending"))) || IsTrue((IsEqual(status, "open")))
            if IsTrue(IsEqual(marketType, "swap")) {
                AddElementToObject(request, "market_type", "FUTURES")
                if IsTrue(isClosed) {
                    if IsTrue(trigger) {
                        
        response = (<-this.V2PrivateGetFuturesFinishedStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivateGetFuturesFinishedOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else if IsTrue(isOpen) {
                    if IsTrue(trigger) {
                        
        response = (<-this.V2PrivateGetFuturesPendingStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivateGetFuturesPendingOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrdersByStatus", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "market_type", "MARGIN")
                } else {
                    AddElementToObject(request, "market_type", "SPOT")
                }
                if IsTrue(isClosed) {
                    if IsTrue(trigger) {
                        
        response = (<-this.V2PrivateGetSpotFinishedStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivateGetSpotFinishedOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else if IsTrue(IsEqual(status, "pending")) {
                    if IsTrue(trigger) {
                        
        response = (<-this.V2PrivateGetSpotPendingStopOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V2PrivateGetSpotPendingOrder(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-stop-order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            openOrders:= (<-this.FetchOrdersByStatus("pending", symbol, since, limit, params))
            PanicOnError(openOrders)
            for i := 0; IsLessThan(i, GetArrayLength(openOrders)); i++ {
                AddElementToObject(GetValue(openOrders, i), "status", "open")
            }
        
            ch <- openOrders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
 * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
 * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for fetching trigger orders
 * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes380815 :=  (<-this.FetchOrdersByStatus("finished", symbol, since, limit, params))
                PanicOnError(retRes380815)
                ch <- retRes380815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#createDepositAddress
 * @description create a currency deposit address
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/update-deposit-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network to create a deposit address on
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinex) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes38228 := (<-this.LoadMarkets())
            PanicOnError(retRes38228)
            var currency interface{} = this.Currency(code)
            var network interface{} = this.SafeString2(params, "chain", "network")
            if IsTrue(IsEqual(network, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createDepositAddress() requires a network parameter")))
            }
            params = this.Omit(params, "network")
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
                "chain": this.NetworkCodeToId(network, GetValue(currency, "code")),
            }
        
            response:= (<-this.V2PrivatePostAssetsRenewalDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
            //             "memo": ""
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/get-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network to create a deposit address on
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes38598 := (<-this.LoadMarkets())
            PanicOnError(retRes38598)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires a \"network\" parameter")))
            }
            AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode)) // required for on-chain, not required for inter-user transfer
        
            response:= (<-this.V2PrivateGetAssetsDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
            //             "memo": ""
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq",
    //         "memo": ""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var coinAddress interface{} = this.SafeString(depositAddress, "address")
    var parts interface{} = Split(coinAddress, ":")
    var address interface{} = nil
    var tag interface{} = nil
    var partsLength interface{} =     GetArrayLength(parts)
    if IsTrue(IsTrue(IsGreaterThan(partsLength, 1)) && IsTrue(!IsEqual(GetValue(parts, 0), "cfx"))) {
        address = GetValue(parts, 0)
        tag = GetValue(parts, 1)
    } else {
        address = coinAddress
    }
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(nil, currency),
        "network": nil,
        "address": address,
        "tag": this.SafeString(depositAddress, "memo", tag),
    }
}
/**
 * @method
 * @name coinex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.coinex.com/api/v2/spot/deal/http/list-user-deals
 * @see https://docs.coinex.com/api/v2/futures/deal/http/list-user-deals
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trades
 * @param {string} [params.side] the side of the trades, either 'buy' or 'sell', required for swap
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes39308 := (<-this.LoadMarkets())
            PanicOnError(retRes39308)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "market_type", "FUTURES")
                
        response = (<-this.V2PrivateGetFuturesUserDeals(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(!IsEqual(marginMode, nil)) {
                    AddElementToObject(request, "market_type", "MARGIN")
                } else {
                    AddElementToObject(request, "market_type", "SPOT")
                }
                
        response = (<-this.V2PrivateGetSpotUserDeals(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchPositions
 * @description fetch all open positions
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] the method to use 'v2PrivateGetFuturesPendingPosition' or 'v2PrivateGetFuturesFinishedPosition' default is 'v2PrivateGetFuturesPendingPosition'
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coinex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes40138 := (<-this.LoadMarkets())
            PanicOnError(retRes40138)
            var defaultMethod interface{} = nil
            defaultMethodparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "method", "v2PrivateGetFuturesPendingPosition");
            defaultMethod = GetValue(defaultMethodparamsVariable,0);
            params = GetValue(defaultMethodparamsVariable,1)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "market_type": "FUTURES",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = nil
                if IsTrue(IsArray(symbols)) {
                    var symbolsLength interface{} =             GetArrayLength(symbols)
                    if IsTrue(IsGreaterThan(symbolsLength, 1)) {
                        panic(BadRequest(Add(this.Id, " fetchPositions() symbols argument cannot contain more than 1 symbol")))
                    }
                    symbol = GetValue(symbols, 0)
                } else {
                    symbol = symbols
                }
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(IsEqual(defaultMethod, "v2PrivateGetFuturesPendingPosition")) {
                
        response = (<-this.V2PrivateGetFuturesPendingPosition(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PrivateGetFuturesFinishedPosition(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "position_id": 305891033,
            //                 "market": "BTCUSDT",
            //                 "market_type": "FUTURES",
            //                 "side": "long",
            //                 "margin_mode": "cross",
            //                 "open_interest": "0.0001",
            //                 "close_avbl": "0.0001",
            //                 "ath_position_amount": "0.0001",
            //                 "unrealized_pnl": "0",
            //                 "realized_pnl": "-0.00311684",
            //                 "avg_entry_price": "62336.8",
            //                 "cml_position_value": "6.23368",
            //                 "max_position_value": "6.23368",
            //                 "created_at": 1715152208041,
            //                 "updated_at": 1715152208041,
            //                 "take_profit_price": "0",
            //                 "stop_loss_price": "0",
            //                 "take_profit_type": "",
            //                 "stop_loss_type": "",
            //                 "settle_price": "62336.8",
            //                 "settle_value": "6.23368",
            //                 "leverage": "3",
            //                 "margin_avbl": "2.07789333",
            //                 "ath_margin_size": "2.07789333",
            //                 "position_margin_rate": "2.40545879023305655728",
            //                 "maintenance_margin_rate": "0.005",
            //                 "maintenance_margin_value": "0.03118094",
            //                 "liq_price": "0",
            //                 "bkr_price": "0",
            //                 "adl_level": 1
            //             }
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": false
            //         }
            //     }
            //
            var position interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(position)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(position, i), market))
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coinex) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes41028 := (<-this.LoadMarkets())
            PanicOnError(retRes41028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_type": "FUTURES",
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.V2PrivateGetFuturesPendingPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "position_id": 305891033,
            //                 "market": "BTCUSDT",
            //                 "market_type": "FUTURES",
            //                 "side": "long",
            //                 "margin_mode": "cross",
            //                 "open_interest": "0.0001",
            //                 "close_avbl": "0.0001",
            //                 "ath_position_amount": "0.0001",
            //                 "unrealized_pnl": "0",
            //                 "realized_pnl": "-0.00311684",
            //                 "avg_entry_price": "62336.8",
            //                 "cml_position_value": "6.23368",
            //                 "max_position_value": "6.23368",
            //                 "created_at": 1715152208041,
            //                 "updated_at": 1715152208041,
            //                 "take_profit_price": "0",
            //                 "stop_loss_price": "0",
            //                 "take_profit_type": "",
            //                 "stop_loss_type": "",
            //                 "settle_price": "62336.8",
            //                 "settle_value": "6.23368",
            //                 "leverage": "3",
            //                 "margin_avbl": "2.07789333",
            //                 "ath_margin_size": "2.07789333",
            //                 "position_margin_rate": "2.40545879023305655728",
            //                 "maintenance_margin_rate": "0.005",
            //                 "maintenance_margin_value": "0.03118094",
            //                 "liq_price": "0",
            //                 "bkr_price": "0",
            //                 "adl_level": 1
            //             }
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": false
            //         }
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParsePosition(GetValue(data, 0), market)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "position_id": 305891033,
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "side": "long",
    //         "margin_mode": "cross",
    //         "open_interest": "0.0001",
    //         "close_avbl": "0.0001",
    //         "ath_position_amount": "0.0001",
    //         "unrealized_pnl": "0",
    //         "realized_pnl": "-0.00311684",
    //         "avg_entry_price": "62336.8",
    //         "cml_position_value": "6.23368",
    //         "max_position_value": "6.23368",
    //         "created_at": 1715152208041,
    //         "updated_at": 1715152208041,
    //         "take_profit_price": "0",
    //         "stop_loss_price": "0",
    //         "take_profit_type": "",
    //         "stop_loss_type": "",
    //         "settle_price": "62336.8",
    //         "settle_value": "6.23368",
    //         "leverage": "3",
    //         "margin_avbl": "2.07789333",
    //         "ath_margin_size": "2.07789333",
    //         "position_margin_rate": "2.40545879023305655728",
    //         "maintenance_margin_rate": "0.005",
    //         "maintenance_margin_value": "0.03118094",
    //         "liq_price": "0",
    //         "bkr_price": "0",
    //         "adl_level": 1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "market")
    market = this.SafeMarket(marketId, market, nil, "swap")
    var timestamp interface{} = this.SafeInteger(position, "created_at")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeInteger(position, "position_id"),
        "symbol": GetValue(market, "symbol"),
        "notional": this.SafeNumber(position, "settle_value"),
        "marginMode": this.SafeString(position, "margin_mode"),
        "liquidationPrice": this.SafeNumber(position, "liq_price"),
        "entryPrice": this.SafeNumber(position, "avg_entry_price"),
        "unrealizedPnl": this.SafeNumber(position, "unrealized_pnl"),
        "realizedPnl": this.SafeNumber(position, "realized_pnl"),
        "percentage": nil,
        "contracts": this.SafeNumber(position, "close_avbl"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "markPrice": nil,
        "lastPrice": nil,
        "side": this.SafeString(position, "side"),
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": this.SafeInteger(position, "updated_at"),
        "maintenanceMargin": this.SafeNumber(position, "maintenance_margin_value"),
        "maintenanceMarginPercentage": this.SafeNumber(position, "maintenance_margin_rate"),
        "collateral": this.SafeNumber(position, "margin_avbl"),
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": this.SafeNumber(position, "leverage"),
        "marginRatio": this.SafeNumber(position, "position_margin_rate"),
        "stopLossPrice": this.OmitZero(this.SafeString(position, "stop_loss_price")),
        "takeProfitPrice": this.OmitZero(this.SafeString(position, "take_profit_price")),
    })
}
/**
 * @method
 * @name coinex#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-leverage
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} params.leverage the rate of leverage
 * @returns {object} response from the exchange
 */
func  (this *coinex) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            marginMode = ToLower(marginMode)
            if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "cross"))) {
                panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
            }
        
            retRes42458 := (<-this.LoadMarkets())
            PanicOnError(retRes42458)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(BadSymbol(Add(this.Id, " setMarginMode() supports swap contracts only")))
            }
            var leverage interface{} = this.SafeInteger(params, "leverage")
            var maxLeverage interface{} = this.SafeInteger(GetValue(GetValue(market, "limits"), "leverage"), "max", 100)
            if IsTrue(IsEqual(leverage, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a leverage parameter")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, maxLeverage)))) {
                panic(BadRequest(Add(Add(Add(Add(this.Id, " setMarginMode() leverage should be between 1 and "), ToString(maxLeverage)), " for "), symbol)))
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
                "margin_mode": marginMode,
                "leverage": leverage,
            }
        
                retRes426415 :=  (<-this.V2PrivatePostFuturesAdjustPositionLeverage(this.Extend(request, params)))
                PanicOnError(retRes426415)
                ch <- retRes426415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#setLeverage
 * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-leverage
 * @description set the level of leverage for a market
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' (default is 'cross')
 * @returns {object} response from the exchange
 */
func  (this *coinex) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes42928 := (<-this.LoadMarkets())
            PanicOnError(retRes42928)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports swap contracts only")))
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params, "cross");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var minLeverage interface{} = this.SafeInteger(GetValue(GetValue(market, "limits"), "leverage"), "min", 1)
            var maxLeverage interface{} = this.SafeInteger(GetValue(GetValue(market, "limits"), "leverage"), "max", 100)
            if IsTrue(IsTrue((IsLessThan(leverage, minLeverage))) || IsTrue((IsGreaterThan(leverage, maxLeverage)))) {
                panic(BadRequest(Add(Add(Add(Add(Add(Add(this.Id, " setLeverage() leverage should be between "), ToString(minLeverage)), " and "), ToString(maxLeverage)), " for "), symbol)))
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
                "margin_mode": marginMode,
                "leverage": leverage,
            }
        
                retRes431015 :=  (<-this.V2PrivatePostFuturesAdjustPositionLeverage(this.Extend(request, params)))
                PanicOnError(retRes431015)
                ch <- retRes431015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-position-level
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func  (this *coinex) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes43338 := (<-this.LoadMarkets())
            PanicOnError(retRes43338)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var marketIds interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "market", Join(marketIds, ","))
            }
        
            response:= (<-this.V2PublicGetFuturesPositionLevel(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "level": [
            //                     {
            //                         "amount": "20001",
            //                         "leverage": "20",
            //                         "maintenance_margin_rate": "0.02",
            //                         "min_initial_margin_rate": "0.05"
            //                     },
            //                     {
            //                         "amount": "50001",
            //                         "leverage": "10",
            //                         "maintenance_margin_rate": "0.04",
            //                         "min_initial_margin_rate": "0.1"
            //                     },
            //                 ],
            //                 "market": "MINAUSDT"
            //             },
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseLeverageTiers(data, symbols, "market")
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var tiers interface{} = []interface{}{}
    var brackets interface{} = this.SafeList(info, "level", []interface{}{})
    var minNotional interface{} = 0
    for i := 0; IsLessThan(i, GetArrayLength(brackets)); i++ {
        var tier interface{} = GetValue(brackets, i)
        var marketId interface{} = this.SafeString(info, "market")
        market = this.SafeMarket(marketId, market, nil, "swap")
        var maxNotional interface{} = this.SafeNumber(tier, "amount")
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.Sum(i, 1),
            "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
            "currency": Ternary(IsTrue(GetValue(market, "linear")), GetValue(market, "base"), GetValue(market, "quote")),
            "minNotional": minNotional,
            "maxNotional": maxNotional,
            "maintenanceMarginRate": this.SafeNumber(tier, "maintenance_margin_rate"),
            "maxLeverage": this.SafeInteger(tier, "leverage"),
            "info": tier,
        })
        minNotional = maxNotional
    }
    return tiers
}
func  (this *coinex) ModifyMarginHelper(symbol interface{}, amount interface{}, addOrReduce interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes43948 := (<-this.LoadMarkets())
            PanicOnError(retRes43948)
            var market interface{} = this.Market(symbol)
            var rawAmount interface{} = this.AmountToPrecision(symbol, amount)
            var requestAmount interface{} = rawAmount
            if IsTrue(IsEqual(addOrReduce, "reduce")) {
                requestAmount = Precise.StringNeg(rawAmount)
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
                "amount": requestAmount,
            }
        
            response:= (<-this.V2PrivatePostFuturesAdjustPositionMargin(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "adl_level": 1,
            //             "ath_margin_size": "2.034928",
            //             "ath_position_amount": "0.0001",
            //             "avg_entry_price": "61047.84",
            //             "bkr_price": "30698.5600000000000004142",
            //             "close_avbl": "0.0001",
            //             "cml_position_value": "6.104784",
            //             "created_at": 1715488472908,
            //             "leverage": "3",
            //             "liq_price": "30852.82412060301507579316",
            //             "maintenance_margin_rate": "0.005",
            //             "maintenance_margin_value": "0.03051465",
            //             "margin_avbl": "3.034928",
            //             "margin_mode": "isolated",
            //             "market": "BTCUSDT",
            //             "market_type": "FUTURES",
            //             "max_position_value": "6.104784",
            //             "open_interest": "0.0001",
            //             "position_id": 306458800,
            //             "position_margin_rate": "0.49713929272518077625",
            //             "realized_pnl": "-0.003052392",
            //             "settle_price": "61047.84",
            //             "settle_value": "6.104784",
            //             "side": "long",
            //             "stop_loss_price": "0",
            //             "stop_loss_type": "",
            //             "take_profit_price": "0",
            //             "take_profit_type": "",
            //             "unrealized_pnl": "0",
            //             "updated_at": 1715488805563
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
            var status interface{} = this.SafeStringLower(response, "message")
            var typeVar interface{} = Ternary(IsTrue((IsEqual(addOrReduce, "reduce"))), "reduce", "add")
        
            ch <- this.Extend(this.ParseMarginModification(data, market), map[string]interface{} {
                "type": typeVar,
                "amount": this.ParseNumber(amount),
                "status": status,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // addMargin/reduceMargin
    //
    //     {
    //         "adl_level": 1,
    //         "ath_margin_size": "2.034928",
    //         "ath_position_amount": "0.0001",
    //         "avg_entry_price": "61047.84",
    //         "bkr_price": "30698.5600000000000004142",
    //         "close_avbl": "0.0001",
    //         "cml_position_value": "6.104784",
    //         "created_at": 1715488472908,
    //         "leverage": "3",
    //         "liq_price": "30852.82412060301507579316",
    //         "maintenance_margin_rate": "0.005",
    //         "maintenance_margin_value": "0.03051465",
    //         "margin_avbl": "3.034928",
    //         "margin_mode": "isolated",
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "max_position_value": "6.104784",
    //         "open_interest": "0.0001",
    //         "position_id": 306458800,
    //         "position_margin_rate": "0.49713929272518077625",
    //         "realized_pnl": "-0.003052392",
    //         "settle_price": "61047.84",
    //         "settle_value": "6.104784",
    //         "side": "long",
    //         "stop_loss_price": "0",
    //         "stop_loss_type": "",
    //         "take_profit_price": "0",
    //         "take_profit_type": "",
    //         "unrealized_pnl": "0",
    //         "updated_at": 1715488805563
    //     }
    //
    // fetchMarginAdjustmentHistory
    //
    //     {
    //         "bkr_pirce": "24698.56000000000000005224",
    //         "created_at": 1715489978697,
    //         "leverage": "3",
    //         "liq_price": "24822.67336683417085432386",
    //         "margin_avbl": "3.634928",
    //         "margin_change": "-1.5",
    //         "margin_mode": "isolated",
    //         "market": "BTCUSDT",
    //         "market_type": "FUTURES",
    //         "open_interest": "0.0001",
    //         "position_id": 306458800,
    //         "settle_price": "61047.84"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(data, "market")
    var timestamp interface{} = this.SafeInteger2(data, "updated_at", "created_at")
    var change interface{} = this.SafeString(data, "margin_change")
    return map[string]interface{} {
        "info": data,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "type": nil,
        "marginMode": "isolated",
        "amount": this.ParseNumber(Precise.StringAbs(change)),
        "total": this.SafeNumber(data, "margin_avbl"),
        "code": GetValue(market, "quote"),
        "status": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name coinex#addMargin
 * @description add margin
 * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *coinex) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes453715 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes453715)
                ch <- retRes453715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#reduceMargin
 * @description remove margin from a position
 * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *coinex) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes455115 :=  (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
                PanicOnError(retRes455115)
                ch <- retRes455115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchFundingHistory
 * @description fetch the history of funding fee payments paid and received on this account
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-position-funding-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *coinex) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingHistory() requires a symbol argument")))
            }
        
            retRes45698 := (<-this.LoadMarkets())
            PanicOnError(retRes45698)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2PrivateGetFuturesPositionFundingHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "ccy": "USDT",
            //                 "created_at": 1715673620183,
            //                 "funding_rate": "0",
            //                 "funding_value": "0",
            //                 "market": "BTCUSDT",
            //                 "market_type": "FUTURES",
            //                 "position_id": 306458800,
            //                 "side": "long"
            //             },
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": true
            //         }
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var timestamp interface{} = this.SafeInteger(entry, "created_at")
                var currencyId interface{} = this.SafeString(entry, "ccy")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                AppendToArray(&result,map[string]interface{} {
                    "info": entry,
                    "symbol": symbol,
                    "code": code,
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                    "id": this.SafeNumber(entry, "position_id"),
                    "amount": this.SafeNumber(entry, "funding_value"),
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *coinex) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes46348 := (<-this.LoadMarkets())
            PanicOnError(retRes46348)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.V2PublicGetFuturesFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "latest_funding_rate": "0",
            //                 "latest_funding_time": 1715731200000,
            //                 "mark_price": "61602.22",
            //                 "market": "BTCUSDT",
            //                 "max_funding_rate": "0.00375",
            //                 "min_funding_rate": "-0.00375",
            //                 "next_funding_rate": "0.00021074",
            //                 "next_funding_time": 1715760000000
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseFundingRate(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *coinex) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes467615 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes467615)
                ch <- retRes467615
                return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchFundingRate, fetchFundingRates, fetchFundingInterval
    //
    //     {
    //         "latest_funding_rate": "0",
    //         "latest_funding_time": 1715731200000,
    //         "mark_price": "61602.22",
    //         "market": "BTCUSDT",
    //         "max_funding_rate": "0.00375",
    //         "min_funding_rate": "-0.00375",
    //         "next_funding_rate": "0.00021074",
    //         "next_funding_time": 1715760000000
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var currentFundingTimestamp interface{} = this.SafeInteger(contract, "latest_funding_time")
    var futureFundingTimestamp interface{} = this.SafeInteger(contract, "next_funding_time")
    var fundingTimeString interface{} = this.SafeString(contract, "latest_funding_time")
    var nextFundingTimeString interface{} = this.SafeString(contract, "next_funding_time")
    var millisecondsInterval interface{} = Precise.StringSub(nextFundingTimeString, fundingTimeString)
    var marketId interface{} = this.SafeString(contract, "market")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "markPrice": this.SafeNumber(contract, "mark_price"),
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": this.SafeNumber(contract, "latest_funding_rate"),
        "fundingTimestamp": currentFundingTimestamp,
        "fundingDatetime": this.Iso8601(currentFundingTimestamp),
        "nextFundingRate": this.SafeNumber(contract, "next_funding_rate"),
        "nextFundingTimestamp": futureFundingTimestamp,
        "nextFundingDatetime": this.Iso8601(futureFundingTimestamp),
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": this.ParseFundingInterval(millisecondsInterval),
    }
}
func  (this *coinex) ParseFundingInterval(interval interface{}) interface{}  {
    var intervals interface{} = map[string]interface{} {
        "3600000": "1h",
        "14400000": "4h",
        "28800000": "8h",
        "57600000": "16h",
        "86400000": "24h",
    }
    return this.SafeString(intervals, interval, interval)
}
/**
 * @method
 * @name coinex#fetchFundingRates
 * @description fetch the current funding rates for multiple markets
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *coinex) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes47438 := (<-this.LoadMarkets())
            PanicOnError(retRes47438)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeValue(symbols, 0)
                market = this.Market(symbol)
                if !IsTrue(GetValue(market, "swap")) {
                    panic(BadSymbol(Add(this.Id, " fetchFundingRates() supports swap contracts only")))
                }
                var marketIds interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "market", Join(marketIds, ","))
            }
        
            response:= (<-this.V2PublicGetFuturesFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "latest_funding_rate": "0",
            //                 "latest_funding_time": 1715731200000,
            //                 "mark_price": "61602.22",
            //                 "market": "BTCUSDT",
            //                 "max_funding_rate": "0.00375",
            //                 "min_funding_rate": "-0.00375",
            //                 "next_funding_rate": "0.00021074",
            //                 "next_funding_time": 1715760000000
            //             }
            //         ],
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseFundingRates(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#withdraw
 * @description make a withdrawal
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes47958 := (<-this.LoadMarkets())
            PanicOnError(retRes47958)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
                "to_address": address,
                "amount": this.CurrencyToPrecision(code, amount),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode)) // required for on-chain, not required for inter-user transfer
            }
        
            response:= (<-this.V2PrivatePostAssetsWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "withdraw_id": 31193755,
            //             "created_at": 1716874165038,
            //             "withdraw_method": "ON_CHAIN",
            //             "ccy": "USDT",
            //             "amount": "17.3",
            //             "actual_amount": "15",
            //             "chain": "TRC20",
            //             "tx_fee": "2.3",
            //             "fee_asset": "USDT",
            //             "fee_amount": "2.3",
            //             "to_address": "TY5vq3MT6b5cQVAHWHtpGyPg1ERcQgi3UN",
            //             "memo": "",
            //             "tx_id": "",
            //             "confirmations": 0,
            //             "explorer_address_url": "https://tronscan.org/#/address/TY5vq3MT6b5cQVAHWHtpGyPg1ERcQgi3UN",
            //             "explorer_tx_url": "https://tronscan.org/#/transaction/",
            //             "remark": "",
            //             "status": "audit_required"
            //         },
            //         "message": "OK"
            //     }
            //
            var transaction interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(transaction, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "audit": "pending",
        "pass": "pending",
        "audit_required": "pending",
        "processing": "pending",
        "confirming": "pending",
        "not_pass": "failed",
        "cancel": "canceled",
        "finish": "ok",
        "finished": "ok",
        "fail": "failed",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinex#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *coinex) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes48748 := (<-this.LoadMarkets())
            PanicOnError(retRes48748)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes487819 :=  (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params, 1000))
                    PanicOnError(retRes487819)
                    ch <- retRes487819
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V2PublicGetFuturesFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "actual_funding_rate": "0",
            //                 "funding_time": 1715731221761,
            //                 "market": "BTCUSDT",
            //                 "theoretical_funding_rate": "0"
            //             },
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": true
            //         }
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(entry, "market")
                var symbolInner interface{} = this.SafeSymbol(marketId, market, nil, "swap")
                var timestamp interface{} = this.SafeInteger(entry, "funding_time")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "actual_funding_rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "deposit_id": 5173806,
    //         "created_at": 1714021652557,
    //         "tx_id": "d9f47d2550397c635cb89a8963118f8fe78ef048bc8b6f0caaeaa7dc6",
    //         "tx_id_display": "",
    //         "ccy": "USDT",
    //         "chain": "TRC20",
    //         "deposit_method": "ON_CHAIN",
    //         "amount": "30",
    //         "actual_amount": "",
    //         "to_address": "TYewD2pVWDUwfNr9A",
    //         "confirmations": 20,
    //         "status": "FINISHED",
    //         "tx_explorer_url": "https://tronscan.org/#/transaction",
    //         "to_addr_explorer_url": "https://tronscan.org/#/address",
    //         "remark": ""
    //     }
    //
    // fetchWithdrawals and withdraw
    //
    //     {
    //         "withdraw_id": 259364,
    //         "created_at": 1701323541548,
    //         "withdraw_method": "ON_CHAIN",
    //         "ccy": "USDT",
    //         "amount": "23.845744",
    //         "actual_amount": "22.445744",
    //         "chain": "TRC20",
    //         "tx_fee": "1.4",
    //         "fee_asset": "USDT",
    //         "fee_amount": "1.4",
    //         "to_address": "T8t5i2454dhdhnnnGdi49vMbihvY",
    //         "memo": "",
    //         "tx_id": "1237623941964de9954ed2e36640228d78765c1026",
    //         "confirmations": 18,
    //         "explorer_address_url": "https://tronscan.org/#/address",
    //         "explorer_tx_url": "https://tronscan.org/#/transaction",
    //         "remark": "",
    //         "status": "finished"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(transaction, "to_address")
    var tag interface{} = this.SafeString(transaction, "memo")
    if IsTrue(!IsEqual(tag, nil)) {
        if IsTrue(IsLessThan(GetLength(tag), 1)) {
            tag = nil
        }
    }
    var remark interface{} = this.SafeString(transaction, "remark")
    if IsTrue(!IsEqual(remark, nil)) {
        if IsTrue(IsLessThan(GetLength(remark), 1)) {
            remark = nil
        }
    }
    var txid interface{} = this.SafeString(transaction, "tx_id")
    if IsTrue(!IsEqual(txid, nil)) {
        if IsTrue(IsLessThan(GetLength(txid), 1)) {
            txid = nil
        }
    }
    var currencyId interface{} = this.SafeString(transaction, "ccy")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(transaction, "created_at")
    var typeVar interface{} = Ternary(IsTrue((InOp(transaction, "withdraw_id"))), "withdrawal", "deposit")
    var networkId interface{} = this.SafeString(transaction, "chain")
    var feeCost interface{} = this.SafeString(transaction, "tx_fee")
    var transferMethod interface{} = this.SafeStringLower2(transaction, "withdraw_method", "deposit_method")
    var internal interface{} = IsEqual(transferMethod, "local")
    var amount interface{} = this.SafeNumber(transaction, "actual_amount")
    if IsTrue(IsEqual(amount, nil)) {
        amount = this.SafeNumber(transaction, "amount")
    }
    if IsTrue(IsEqual(typeVar, "deposit")) {
        feeCost = "0"
    }
    var feeCurrencyId interface{} = this.SafeString(transaction, "fee_asset")
    var fee interface{} = map[string]interface{} {
        "cost": this.ParseNumber(feeCost),
        "currency": this.SafeCurrencyCode(feeCurrencyId),
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "withdraw_id", "deposit_id"),
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.NetworkIdToCode(networkId),
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": nil,
        "fee": fee,
        "comment": remark,
        "internal": internal,
    }
}
/**
 * @method
 * @name coinex#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://docs.coinex.com/api/v2/assets/transfer/http/transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] unified ccxt symbol, required when either the fromAccount or toAccount is margin
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coinex) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes50508 := (<-this.LoadMarkets())
            PanicOnError(retRes50508)
            var currency interface{} = this.Currency(code)
            var amountToPrecision interface{} = this.CurrencyToPrecision(code, amount)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
                "amount": amountToPrecision,
                "from_account_type": fromId,
                "to_account_type": toId,
            }
            if IsTrue(IsTrue((IsEqual(fromAccount, "margin"))) || IsTrue((IsEqual(toAccount, "margin")))) {
                var symbol interface{} = this.SafeString(params, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " transfer() the symbol parameter must be defined for a margin account")))
                }
                params = this.Omit(params, "symbol")
                AddElementToObject(request, "market", this.MarketId(symbol))
            }
            if IsTrue(IsTrue((!IsEqual(fromAccount, "spot"))) && IsTrue((!IsEqual(toAccount, "spot")))) {
                panic(BadRequest(Add(this.Id, " transfer() can only be between spot and swap, or spot and margin, either the fromAccount or toAccount must be spot")))
            }
        
            response:= (<-this.V2PrivatePostAssetsTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": 0,
            //         "data": {},
            //         "message": "OK"
            //     }
            //
        ch <- this.Extend(this.ParseTransfer(response, currency), map[string]interface{} {
                "amount": this.ParseNumber(amountToPrecision),
                "fromAccount": fromAccount,
                "toAccount": toAccount,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "ok",
        "SUCCESS": "ok",
        "OK": "ok",
        "finished": "ok",
        "FINISHED": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinex) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transfer, "created_at")
    var currencyId interface{} = this.SafeString(transfer, "ccy")
    var fromId interface{} = this.SafeString(transfer, "from_account_type")
    var toId interface{} = this.SafeString(transfer, "to_account_type")
    var accountsById interface{} = this.SafeValue(this.Options, "accountsById", map[string]interface{} {})
    return map[string]interface{} {
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.SafeString(accountsById, fromId, fromId),
        "toAccount": this.SafeString(accountsById, toId, toId),
        "status": this.ParseTransferStatus(this.SafeString2(transfer, "code", "status")),
    }
}
/**
 * @method
 * @name coinex#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://docs.coinex.com/api/v2/assets/transfer/http/list-transfer-history
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfer structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching transfers to and from your margin account
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coinex) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes51308 := (<-this.LoadMarkets())
            PanicOnError(retRes51308)
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTransfers() requires a code argument")))
            }
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchTransfers", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(!IsEqual(marginMode, nil)) {
                AddElementToObject(request, "transfer_type", "MARGIN")
            } else {
                AddElementToObject(request, "transfer_type", "FUTURES")
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V2PrivateGetAssetsTransferHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "created_at": 1715848480646,
            //                 "from_account_type": "SPOT",
            //                 "to_account_type": "FUTURES",
            //                 "ccy": "USDT",
            //                 "amount": "10",
            //                 "status": "finished"
            //             },
            //         ],
            //         "pagination": {
            //             "total": 8,
            //             "has_next": false
            //         },
            //         "code": 0,
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransfers(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-withdrawal-history
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes51898 := (<-this.LoadMarkets())
            PanicOnError(retRes51898)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "ccy", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2PrivateGetAssetsWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "withdraw_id": 259364,
            //                 "created_at": 1701323541548,
            //                 "withdraw_method": "ON_CHAIN",
            //                 "ccy": "USDT",
            //                 "amount": "23.845744",
            //                 "actual_amount": "22.445744",
            //                 "chain": "TRC20",
            //                 "tx_fee": "1.4",
            //                 "fee_asset": "USDT",
            //                 "fee_amount": "1.4",
            //                 "to_address": "T8t5i2454dhdhnnnGdi49vMbihvY",
            //                 "memo": "",
            //                 "tx_id": "1237623941964de9954ed2e36640228d78765c1026",
            //                 "confirmations": 18,
            //                 "explorer_address_url": "https://tronscan.org/#/address",
            //                 "explorer_tx_url": "https://tronscan.org/#/transaction",
            //                 "remark": "",
            //                 "status": "finished"
            //             },
            //         ],
            //         "pagination": {
            //             "total": 9,
            //             "has_next": true
            //         },
            //         "code": 0,
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-deposit-history
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposit structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes52488 := (<-this.LoadMarkets())
            PanicOnError(retRes52488)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "ccy", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2PrivateGetAssetsDepositHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "deposit_id": 5173806,
            //                 "created_at": 1714021652557,
            //                 "tx_id": "d9f47d2550397c635cb89a8963118f8fe78ef048bc8b6f0caaeaa7dc6",
            //                 "tx_id_display": "",
            //                 "ccy": "USDT",
            //                 "chain": "TRC20",
            //                 "deposit_method": "ON_CHAIN",
            //                 "amount": "30",
            //                 "actual_amount": "",
            //                 "to_address": "TYewD2pVWDUwfNr9A",
            //                 "confirmations": 20,
            //                 "status": "FINISHED",
            //                 "tx_explorer_url": "https://tronscan.org/#/transaction",
            //                 "to_addr_explorer_url": "https://tronscan.org/#/address",
            //                 "remark": ""
            //             },
            //         ],
            //         "paginatation": {
            //             "total": 8,
            //             "has_next": true
            //         },
            //         "code": 0,
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "BTCUSDT",
    //         "ccy": "USDT",
    //         "leverage": 10,
    //         "min_amount": "60",
    //         "max_amount": "500000",
    //         "daily_interest_rate": "0.001"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "market")
    market = this.SafeMarket(marketId, market, nil, "spot")
    var currency interface{} = this.SafeString(info, "ccy")
    var rate interface{} = this.SafeNumber(info, "daily_interest_rate")
    var baseRate interface{} = nil
    var quoteRate interface{} = nil
    if IsTrue(IsEqual(currency, GetValue(market, "baseId"))) {
        baseRate = rate
    } else if IsTrue(IsEqual(currency, GetValue(market, "quoteId"))) {
        quoteRate = rate
    }
    return map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "base": GetValue(market, "base"),
        "baseRate": baseRate,
        "quote": GetValue(market, "quote"),
        "quoteRate": quoteRate,
        "period": 86400000,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
/**
 * @method
 * @name coinex#fetchIsolatedBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-interest-limit
 * @param {string} symbol unified symbol of the market to fetch the borrow rate for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.code unified currency code
 * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
 */
func  (this *coinex) FetchIsolatedBorrowRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes53388 := (<-this.LoadMarkets())
            PanicOnError(retRes53388)
            var code interface{} = this.SafeString(params, "code")
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchIsolatedBorrowRate() requires a code parameter")))
            }
            params = this.Omit(params, "code")
            var currency interface{} = this.Currency(code)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "ccy": GetValue(currency, "id"),
            }
        
            response:= (<-this.V2PrivateGetAssetsMarginInterestLimit(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "market": "BTCUSDT",
            //             "ccy": "USDT",
            //             "leverage": 10,
            //             "min_amount": "60",
            //             "max_amount": "500000",
            //             "daily_interest_rate": "0.001"
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseIsolatedBorrowRate(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-borrow-history
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol when fetch interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func  (this *coinex) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes53828 := (<-this.LoadMarkets())
            PanicOnError(retRes53828)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2PrivateGetAssetsMarginBorrowHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "borrow_id": 2642934,
            //                 "created_at": 1654761016000,
            //                 "market": "BTCUSDT",
            //                 "ccy": "USDT",
            //                 "daily_interest_rate": "0.001",
            //                 "expired_at": 1655625016000,
            //                 "borrow_amount": "100",
            //                 "to_repaied_amount": "0",
            //                 "is_auto_renew": false,
            //                 "status": "finish"
            //             },
            //         ],
            //         "pagination": {
            //             "total": 4,
            //             "has_next": true
            //         },
            //         "code": 0,
            //         "message": "OK"
            //     }
            //
            var rows interface{} = this.SafeValue(response, "data", []interface{}{})
            var interest interface{} = this.ParseBorrowInterests(rows, market)
        
            ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "borrow_id": 2642934,
    //         "created_at": 1654761016000,
    //         "market": "BTCUSDT",
    //         "ccy": "USDT",
    //         "daily_interest_rate": "0.001",
    //         "expired_at": 1655625016000,
    //         "borrow_amount": "100",
    //         "to_repaied_amount": "0",
    //         "is_auto_renew": false,
    //         "status": "finish"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "market")
    market = this.SafeMarket(marketId, market, nil, "spot")
    var timestamp interface{} = this.SafeInteger(info, "expired_at")
    return map[string]interface{} {
        "info": info,
        "symbol": GetValue(market, "symbol"),
        "currency": this.SafeCurrencyCode(this.SafeString(info, "ccy")),
        "interest": this.SafeNumber(info, "to_repaied_amount"),
        "interestRate": this.SafeNumber(info, "daily_interest_rate"),
        "amountBorrowed": this.SafeNumber(info, "borrow_amount"),
        "marginMode": "isolated",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name coinex#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/margin-borrow
 * @param {string} symbol unified market symbol, required for coinex
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.isAutoRenew] whether to renew the margin loan automatically or not, default is false
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *coinex) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes54668 := (<-this.LoadMarkets())
            PanicOnError(retRes54668)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var isAutoRenew interface{} = this.SafeBool2(params, "isAutoRenew", "is_auto_renew", false)
            params = this.Omit(params, "isAutoRenew")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "ccy": GetValue(currency, "id"),
                "borrow_amount": this.CurrencyToPrecision(code, amount),
                "is_auto_renew": isAutoRenew,
            }
        
            response:= (<-this.V2PrivatePostAssetsMarginBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "borrow_id": 13784021,
            //             "market": "BTCUSDT",
            //             "ccy": "USDT",
            //             "daily_interest_rate": "0.001",
            //             "expired_at": 1717299948340,
            //             "borrow_amount": "60",
            //             "to_repaied_amount": "60.0025",
            //             "status": "loan"
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transaction interface{} = this.ParseMarginLoan(data, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/margin-repay
 * @param {string} symbol unified market symbol, required for coinex
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.borrow_id] extra parameter that is not required
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *coinex) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes55158 := (<-this.LoadMarkets())
            PanicOnError(retRes55158)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "ccy": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.V2PrivatePostAssetsMarginRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {},
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transaction interface{} = this.ParseMarginLoan(data, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "borrow_id": 13784021,
    //         "market": "BTCUSDT",
    //         "ccy": "USDT",
    //         "daily_interest_rate": "0.001",
    //         "expired_at": 1717299948340,
    //         "borrow_amount": "60",
    //         "to_repaied_amount": "60.0025",
    //         "status": "loan"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(info, "ccy")
    var marketId interface{} = this.SafeString(info, "market")
    var timestamp interface{} = this.SafeInteger(info, "expired_at")
    return map[string]interface{} {
        "id": this.SafeInteger(info, "borrow_id"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeString(info, "borrow_amount"),
        "symbol": this.SafeSymbol(marketId, nil, nil, "spot"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
/**
 * @method
 * @name coinex#fetchDepositWithdrawFee
 * @description fetch the fee for deposits and withdrawals
 * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/get-deposit-withdrawal-config
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *coinex) FetchDepositWithdrawFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes55768 := (<-this.LoadMarkets())
            PanicOnError(retRes55768)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "ccy": GetValue(currency, "id"),
            }
        
            response:= (<-this.V2PublicGetAssetsDepositWithdrawConfig(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "asset": {
            //                 "ccy": "USDT",
            //                 "deposit_enabled": true,
            //                 "withdraw_enabled": true,
            //                 "inter_transfer_enabled": true,
            //                 "is_st": false
            //             },
            //             "chains": [
            //                 {
            //                     "chain": "TRC20",
            //                     "min_deposit_amount": "2.4",
            //                     "min_withdraw_amount": "2.4",
            //                     "deposit_enabled": true,
            //                     "withdraw_enabled": true,
            //                     "deposit_delay_minutes": 0,
            //                     "safe_confirmations": 10,
            //                     "irreversible_confirmations": 20,
            //                     "deflation_rate": "0",
            //                     "withdrawal_fee": "2.4",
            //                     "withdrawal_precision": 6,
            //                     "memo": "",
            //                     "is_memo_required_for_deposit": false,
            //                     "explorer_asset_url": "https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
            //                 },
            //             ]
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositWithdrawFee(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "asset": {
    //             "ccy": "USDT",
    //             "deposit_enabled": true,
    //             "withdraw_enabled": true,
    //             "inter_transfer_enabled": true,
    //             "is_st": false
    //         },
    //         "chains": [
    //             {
    //                 "chain": "TRC20",
    //                 "min_deposit_amount": "2.4",
    //                 "min_withdraw_amount": "2.4",
    //                 "deposit_enabled": true,
    //                 "withdraw_enabled": true,
    //                 "deposit_delay_minutes": 0,
    //                 "safe_confirmations": 10,
    //                 "irreversible_confirmations": 20,
    //                 "deflation_rate": "0",
    //                 "withdrawal_fee": "2.4",
    //                 "withdrawal_precision": 6,
    //                 "memo": "",
    //                 "is_memo_required_for_deposit": false,
    //                 "explorer_asset_url": "https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
    //             },
    //         ]
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    var chains interface{} = this.SafeList(fee, "chains", []interface{}{})
    var asset interface{} = this.SafeDict(fee, "asset", map[string]interface{} {})
    for i := 0; IsLessThan(i, GetArrayLength(chains)); i++ {
        var entry interface{} = GetValue(chains, i)
        var isWithdrawEnabled interface{} = this.SafeBool(entry, "withdraw_enabled")
        if IsTrue(isWithdrawEnabled) {
            AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(entry, "withdrawal_fee"))
            AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
            var networkId interface{} = this.SafeString(entry, "chain")
            if IsTrue(networkId) {
                var networkCode interface{} = this.NetworkIdToCode(networkId, this.SafeString(asset, "ccy"))
                AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(entry, "withdrawal_fee"),
        "percentage": false,
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
            }
        }
    }
    return result
}
/**
 * @method
 * @name coinex#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-interest-limit
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.code unified currency code
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *coinex) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes56998 := (<-this.LoadMarkets())
            PanicOnError(retRes56998)
            var code interface{} = this.SafeString(params, "code")
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchLeverage() requires a code parameter")))
            }
            params = this.Omit(params, "code")
            var currency interface{} = this.Currency(code)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "ccy": GetValue(currency, "id"),
            }
        
            response:= (<-this.V2PrivateGetAssetsMarginInterestLimit(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "market": "BTCUSDT",
            //             "ccy": "USDT",
            //             "leverage": 10,
            //             "min_amount": "50",
            //             "max_amount": "500000",
            //             "daily_interest_rate": "0.001"
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "BTCUSDT",
    //         "ccy": "USDT",
    //         "leverage": 10,
    //         "min_amount": "50",
    //         "max_amount": "500000",
    //         "daily_interest_rate": "0.001"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "market")
    var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market, nil, "spot"),
        "marginMode": "isolated",
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name coinex#fetchPositionHistory
 * @description fetches historical positions
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
 * @param {string} symbol unified contract symbol
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum amount of records to fetch, default is 10
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] the latest time in ms to fetch positions for
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coinex) FetchPositionHistory(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes57658 := (<-this.LoadMarkets())
            PanicOnError(retRes57658)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_type": "FUTURES",
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V2PrivateGetFuturesFinishedPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "position_id": 305891033,
            //                 "market": "BTCUSDT",
            //                 "market_type": "FUTURES",
            //                 "side": "long",
            //                 "margin_mode": "cross",
            //                 "open_interest": "0.0001",
            //                 "close_avbl": "0.0001",
            //                 "ath_position_amount": "0.0001",
            //                 "unrealized_pnl": "0",
            //                 "realized_pnl": "-0.00311684",
            //                 "avg_entry_price": "62336.8",
            //                 "cml_position_value": "6.23368",
            //                 "max_position_value": "6.23368",
            //                 "created_at": 1715152208041,
            //                 "updated_at": 1715152208041,
            //                 "take_profit_price": "0",
            //                 "stop_loss_price": "0",
            //                 "take_profit_type": "",
            //                 "stop_loss_type": "",
            //                 "settle_price": "62336.8",
            //                 "settle_value": "6.23368",
            //                 "leverage": "3",
            //                 "margin_avbl": "2.07789333",
            //                 "ath_margin_size": "2.07789333",
            //                 "position_margin_rate": "2.40545879023305655728",
            //                 "maintenance_margin_rate": "0.005",
            //                 "maintenance_margin_value": "0.03118094",
            //                 "liq_price": "0",
            //                 "bkr_price": "0",
            //                 "adl_level": 1
            //             }
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": false
            //         }
            //     }
            //
            var records interface{} = this.SafeList(response, "data", []interface{}{})
            var positions interface{} = this.ParsePositions(records)
        
            ch <- this.FilterBySymbolSinceLimit(positions, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#closePosition
 * @description closes an open position for a market
 * @see https://docs.coinex.com/api/v2/futures/position/http/close-position
 * @param {string} symbol unified CCXT market symbol
 * @param {string} [side] buy or sell, not used by coinex
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.type required by coinex, one of: limit, market, maker_only, ioc or fok, default is *market*
 * @param {string} [params.price] the price to fulfill the order, ignored in market orders
 * @param {string} [params.amount] the amount to trade in units of the base currency
 * @param {string} [params.clientOrderId] the client id of the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinex) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    side := GetArg(optionalArgs, 0, nil)
            _ = side
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes58428 := (<-this.LoadMarkets())
            PanicOnError(retRes58428)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.SafeString(params, "type", "market")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
                "type": typeVar,
            }
            var clientOrderId interface{} = this.SafeString2(params, "client_id", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_id", clientOrderId)
            }
            params = this.Omit(params, "clientOrderId")
        
            response:= (<-this.V2PrivatePostFuturesClosePosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "amount": "0.0001",
            //             "client_id": "",
            //             "created_at": 1729666043969,
            //             "fee": "0.00335858",
            //             "fee_ccy": "USDT",
            //             "filled_amount": "0.0001",
            //             "filled_value": "6.717179",
            //             "last_filled_amount": "0.0001",
            //             "last_filled_price": "67171.79",
            //             "maker_fee_rate": "0",
            //             "market": "BTCUSDT",
            //             "market_type": "FUTURES",
            //             "order_id": 155477479761,
            //             "price": "0",
            //             "realized_pnl": "-0.001823",
            //             "side": "sell",
            //             "taker_fee_rate": "0.0005",
            //             "type": "market",
            //             "unfilled_amount": "0",
            //             "updated_at": 1729666043969
            //         },
            //         "message": "OK"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinex) HandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
    * @param {object} params extra parameters specific to the exchange api endpoint
    * @returns {Array} the marginMode in lowercase
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 1, nil)
    _ = defaultValue
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var isMargin interface{} = this.SafeBool(params, "margin", false)
    var marginMode interface{} = nil
    marginModeparamsVariable := this.Exchange.HandleMarginModeAndParams(methodName, params, defaultValue);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsEqual(marginMode, nil)) {
        if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
            marginMode = "isolated"
        }
    }
    return []interface{}{marginMode, params}
}
func  (this *coinex) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *coinex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    path = this.ImplodeParams(path, params)
    var version interface{} = GetValue(api, 0)
    var requestUrl interface{} = GetValue(api, 1)
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), requestUrl), "/"), version), "/"), path)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var nonce interface{} = ToString(this.Nonce())
    if IsTrue(IsEqual(method, "POST")) {
        var parts interface{} = Split(path, "/")
        var firstPart interface{} = this.SafeString(parts, 0, "")
        var numParts interface{} =         GetArrayLength(parts)
        var lastPart interface{} = this.SafeString(parts, Subtract(numParts, 1), "")
        var lastWords interface{} = Split(lastPart, "_")
        var numWords interface{} =         GetArrayLength(lastWords)
        var lastWord interface{} = this.SafeString(lastWords, Subtract(numWords, 1), "")
        if IsTrue(IsTrue((IsEqual(firstPart, "order"))) && IsTrue((IsTrue(IsEqual(lastWord, "limit")) || IsTrue(IsEqual(lastWord, "market"))))) {
            // inject in implicit API calls
            // POST /order/limit - Place limit orders
            // POST /order/market - Place market orders
            // POST /order/stop/limit - Place stop limit orders
            // POST /order/stop/market - Place stop market orders
            // POST /perpetual/v1/order/put_limit - Place limit orders
            // POST /perpetual/v1/order/put_market - Place market orders
            // POST /perpetual/v1/order/put_stop_limit - Place stop limit orders
            // POST /perpetual/v1/order/put_stop_market - Place stop market orders
            var clientOrderId interface{} = this.SafeString(params, "client_id")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                var defaultId interface{} = "x-167673045"
                var brokerId interface{} = this.SafeValue(this.Options, "brokerId", defaultId)
                AddElementToObject(query, "client_id", Add(Add(brokerId, "_"), this.Uuid16()))
            }
        }
    }
    if IsTrue(IsEqual(requestUrl, "perpetualPrivate")) {
        this.CheckRequiredCredentials()
        query = this.Extend(map[string]interface{} {
            "access_id": this.ApiKey,
            "timestamp": nonce,
        }, query)
        query = this.Keysort(query)
        var urlencoded interface{} = this.Rawencode(query)
        var signature interface{} = this.Hash(this.Encode(Add(Add(urlencoded, "&secret_key="), this.Secret)), sha256)
        headers = map[string]interface{} {
            "Authorization": ToLower(signature),
            "AccessId": this.ApiKey,
        }
        if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "PUT")))) {
            url = Add(url, Add("?", urlencoded))
        } else {
            AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
            body = urlencoded
        }
    } else if IsTrue(IsTrue(IsEqual(requestUrl, "public")) || IsTrue(IsEqual(requestUrl, "perpetualPublic"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        if IsTrue(IsEqual(version, "v1")) {
            this.CheckRequiredCredentials()
            query = this.Extend(map[string]interface{} {
                "access_id": this.ApiKey,
                "tonce": nonce,
            }, query)
            query = this.Keysort(query)
            var urlencoded interface{} = this.Rawencode(query)
            var signature interface{} = this.Hash(this.Encode(Add(Add(urlencoded, "&secret_key="), this.Secret)), md5)
            headers = map[string]interface{} {
                "Authorization": ToUpper(signature),
                "Content-Type": "application/json",
            }
            if IsTrue(IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) || IsTrue((IsEqual(method, "PUT")))) {
                url = Add(url, Add("?", urlencoded))
            } else {
                body = this.Json(query)
            }
        } else if IsTrue(IsEqual(version, "v2")) {
            this.CheckRequiredCredentials()
            query = this.Keysort(query)
            var urlencoded interface{} = this.Rawencode(query)
            var preparedString interface{} = Add(Add(Add(Add(method, "/"), version), "/"), path)
            if IsTrue(IsEqual(method, "POST")) {
                body = this.Json(query)
                preparedString = Add(preparedString, body)
            } else if IsTrue(urlencoded) {
                preparedString = Add(preparedString, Add("?", urlencoded))
            }
            preparedString = Add(preparedString, Add(nonce, this.Secret))
            var signature interface{} = this.Hash(this.Encode(preparedString), sha256)
            headers = map[string]interface{} {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "X-COINEX-KEY": this.ApiKey,
                "X-COINEX-SIGN": signature,
                "X-COINEX-TIMESTAMP": nonce,
            }
            if IsTrue(!IsEqual(method, "POST")) {
                if IsTrue(urlencoded) {
                    url = Add(url, Add("?", urlencoded))
                }
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinex) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var code interface{} = this.SafeString(response, "code")
    var data interface{} = this.SafeValue(response, "data")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(IsTrue((!IsEqual(code, "0"))) || IsTrue((IsTrue(IsTrue(IsTrue((!IsEqual(message, "Success"))) && IsTrue((!IsEqual(message, "Succeeded")))) && IsTrue((!IsEqual(ToLower(message), "ok")))) && !IsTrue(data)))) {
        var feedback interface{} = Add(Add(this.Id, " "), message)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
/**
 * @method
 * @name coinex#fetchMarginAdjustmentHistory
 * @description fetches the history of margin added or reduced from contract isolated positions
 * @see https://docs.coinex.com/api/v2/futures/position/http/list-position-margin-history
 * @param {string} symbol unified market symbol
 * @param {string} [type] not used by coinex fetchMarginAdjustmentHistory
 * @param {int} [since] timestamp in ms of the earliest change to fetch
 * @param {int} [limit] the maximum amount of changes to fetch, default is 10
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest change to fetch
 * @param {int} [params.positionId] the id of the position that you want to retrieve margin adjustment history for
 * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *coinex) FetchMarginAdjustmentHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            typeVar := GetArg(optionalArgs, 1, nil)
            _ = typeVar
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes60488 := (<-this.LoadMarkets())
            PanicOnError(retRes60488)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMarginAdjustmentHistory() requires a symbol argument")))
            }
            var positionId interface{} = this.SafeInteger2(params, "positionId", "position_id")
            params = this.Omit(params, "positionId")
            if IsTrue(IsEqual(positionId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMarginAdjustmentHistory() requires a positionId parameter")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "market_type": "FUTURES",
                "position_id": positionId,
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2PrivateGetFuturesPositionMarginHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "bkr_pirce": "24698.56000000000000005224",
            //                 "created_at": 1715489978697,
            //                 "leverage": "3",
            //                 "liq_price": "24822.67336683417085432386",
            //                 "margin_avbl": "3.634928",
            //                 "margin_change": "-1.5",
            //                 "margin_mode": "isolated",
            //                 "market": "BTCUSDT",
            //                 "market_type": "FUTURES",
            //                 "open_interest": "0.0001",
            //                 "position_id": 306458800,
            //                 "settle_price": "61047.84"
            //             },
            //         ],
            //         "message": "OK",
            //         "pagination": {
            //             "has_next": true
            //         }
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var modifications interface{} = this.ParseMarginModifications(data, nil, "market", "swap")
        
            ch <- this.FilterBySymbolSinceLimit(modifications, symbol, since, limit)
            return nil
        
            }()
            return ch
        }


func (this *coinex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
