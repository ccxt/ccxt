package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type cryptocom struct {
    Exchange

}

func NewCryptocomCore() cryptocom {
   p := cryptocom{}
   setDefaults(&p)
   return p
}

func  (this *cryptocom) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "cryptocom",
        "name": "Crypto.com",
        "countries": []interface{}{"MT"},
        "version": "v2",
        "rateLimit": 10,
        "certified": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": true,
            "option": true,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelOrdersForSymbols": true,
            "closeAllPositions": false,
            "closePosition": true,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": "emulated",
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": true,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": true,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1D",
            "1w": "7D",
            "2w": "14D",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",
            "test": map[string]interface{} {
                "v1": "https://uat-api.3ona.co/exchange/v1",
                "v2": "https://uat-api.3ona.co/v2",
                "derivatives": "https://uat-api.3ona.co/v2",
            },
            "api": map[string]interface{} {
                "v1": "https://api.crypto.com/exchange/v1",
                "v2": "https://api.crypto.com/v2",
                "derivatives": "https://deriv-api.crypto.com/v1",
            },
            "www": "https://crypto.com/",
            "referral": map[string]interface{} {
                "url": "https://crypto.com/exch/kdacthrnxt",
                "discount": 0.75,
            },
            "doc": []interface{}{"https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html", "https://exchange-docs.crypto.com/spot/index.html", "https://exchange-docs.crypto.com/derivatives/index.html"},
            "fees": "https://crypto.com/exchange/document/fees-limits",
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "public/auth": Divide(10, 3),
                        "public/get-instruments": Divide(10, 3),
                        "public/get-book": 1,
                        "public/get-candlestick": 1,
                        "public/get-trades": 1,
                        "public/get-tickers": 1,
                        "public/get-valuations": 1,
                        "public/get-expired-settlement-price": Divide(10, 3),
                        "public/get-insurance": 1,
                        "public/get-risk-parameters": 1,
                    },
                    "post": map[string]interface{} {
                        "public/staking/get-conversion-rate": 2,
                    },
                },
                "private": map[string]interface{} {
                    "post": map[string]interface{} {
                        "private/set-cancel-on-disconnect": Divide(10, 3),
                        "private/get-cancel-on-disconnect": Divide(10, 3),
                        "private/user-balance": Divide(10, 3),
                        "private/user-balance-history": Divide(10, 3),
                        "private/get-positions": Divide(10, 3),
                        "private/create-order": Divide(2, 3),
                        "private/create-order-list": Divide(10, 3),
                        "private/cancel-order": Divide(2, 3),
                        "private/cancel-order-list": Divide(10, 3),
                        "private/cancel-all-orders": Divide(2, 3),
                        "private/close-position": Divide(10, 3),
                        "private/get-order-history": 100,
                        "private/get-open-orders": Divide(10, 3),
                        "private/get-order-detail": Divide(1, 3),
                        "private/get-trades": 100,
                        "private/change-account-leverage": Divide(10, 3),
                        "private/get-transactions": Divide(10, 3),
                        "private/create-subaccount-transfer": Divide(10, 3),
                        "private/get-subaccount-balances": Divide(10, 3),
                        "private/get-order-list": Divide(10, 3),
                        "private/create-withdrawal": Divide(10, 3),
                        "private/get-currency-networks": Divide(10, 3),
                        "private/get-deposit-address": Divide(10, 3),
                        "private/get-accounts": Divide(10, 3),
                        "private/get-withdrawal-history": Divide(10, 3),
                        "private/get-deposit-history": Divide(10, 3),
                        "private/get-fee-rate": 2,
                        "private/get-instrument-fee-rate": 2,
                        "private/staking/stake": 2,
                        "private/staking/unstake": 2,
                        "private/staking/get-staking-position": 2,
                        "private/staking/get-staking-instruments": 2,
                        "private/staking/get-open-stake": 2,
                        "private/staking/get-stake-history": 2,
                        "private/staking/get-reward-history": 2,
                        "private/staking/convert": 2,
                        "private/staking/get-open-convert": 2,
                        "private/staking/get-convert-history": 2,
                    },
                },
            },
            "v2": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "public/auth": 1,
                        "public/get-instruments": 1,
                        "public/get-book": 1,
                        "public/get-candlestick": 1,
                        "public/get-ticker": 1,
                        "public/get-trades": 1,
                        "public/margin/get-transfer-currencies": 1,
                        "public/margin/get-load-currenices": 1,
                        "public/respond-heartbeat": 1,
                    },
                },
                "private": map[string]interface{} {
                    "post": map[string]interface{} {
                        "private/set-cancel-on-disconnect": Divide(10, 3),
                        "private/get-cancel-on-disconnect": Divide(10, 3),
                        "private/create-withdrawal": Divide(10, 3),
                        "private/get-withdrawal-history": Divide(10, 3),
                        "private/get-currency-networks": Divide(10, 3),
                        "private/get-deposit-history": Divide(10, 3),
                        "private/get-deposit-address": Divide(10, 3),
                        "private/export/create-export-request": Divide(10, 3),
                        "private/export/get-export-requests": Divide(10, 3),
                        "private/export/download-export-output": Divide(10, 3),
                        "private/get-account-summary": Divide(10, 3),
                        "private/create-order": Divide(2, 3),
                        "private/cancel-order": Divide(2, 3),
                        "private/cancel-all-orders": Divide(2, 3),
                        "private/create-order-list": Divide(10, 3),
                        "private/get-order-history": Divide(10, 3),
                        "private/get-open-orders": Divide(10, 3),
                        "private/get-order-detail": Divide(1, 3),
                        "private/get-trades": 100,
                        "private/get-accounts": Divide(10, 3),
                        "private/get-subaccount-balances": Divide(10, 3),
                        "private/create-subaccount-transfer": Divide(10, 3),
                        "private/otc/get-otc-user": Divide(10, 3),
                        "private/otc/get-instruments": Divide(10, 3),
                        "private/otc/request-quote": 100,
                        "private/otc/accept-quote": 100,
                        "private/otc/get-quote-history": Divide(10, 3),
                        "private/otc/get-trade-history": Divide(10, 3),
                        "private/otc/create-order": Divide(10, 3),
                    },
                },
            },
            "derivatives": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "public/auth": Divide(10, 3),
                        "public/get-instruments": Divide(10, 3),
                        "public/get-book": 1,
                        "public/get-candlestick": 1,
                        "public/get-trades": 1,
                        "public/get-tickers": 1,
                        "public/get-valuations": 1,
                        "public/get-expired-settlement-price": Divide(10, 3),
                        "public/get-insurance": 1,
                    },
                },
                "private": map[string]interface{} {
                    "post": map[string]interface{} {
                        "private/set-cancel-on-disconnect": Divide(10, 3),
                        "private/get-cancel-on-disconnect": Divide(10, 3),
                        "private/user-balance": Divide(10, 3),
                        "private/user-balance-history": Divide(10, 3),
                        "private/get-positions": Divide(10, 3),
                        "private/create-order": Divide(2, 3),
                        "private/create-order-list": Divide(10, 3),
                        "private/cancel-order": Divide(2, 3),
                        "private/cancel-order-list": Divide(10, 3),
                        "private/cancel-all-orders": Divide(2, 3),
                        "private/close-position": Divide(10, 3),
                        "private/convert-collateral": Divide(10, 3),
                        "private/get-order-history": 100,
                        "private/get-open-orders": Divide(10, 3),
                        "private/get-order-detail": Divide(1, 3),
                        "private/get-trades": 100,
                        "private/change-account-leverage": Divide(10, 3),
                        "private/get-transactions": Divide(10, 3),
                        "private/create-subaccount-transfer": Divide(10, 3),
                        "private/get-subaccount-balances": Divide(10, 3),
                        "private/get-order-list": Divide(10, 3),
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.004"),
                "taker": this.ParseNumber("0.004"),
                "tiers": map[string]interface{} {
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0035")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("20000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.0004")}},
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0035")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.00015")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00014")}, []interface{}{this.ParseNumber("20000000"), this.ParseNumber("0.00013")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00012")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.0001")}},
                },
            },
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "accountsById": map[string]interface{} {
                "funding": "SPOT",
                "spot": "SPOT",
                "margin": "MARGIN",
                "derivatives": "DERIVATIVES",
                "swap": "DERIVATIVES",
                "future": "DERIVATIVES",
            },
            "networks": map[string]interface{} {
                "BEP20": "BSC",
                "ERC20": "ETH",
                "TRC20": "TRON",
            },
            "broker": "CCXT",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": true,
                    "trailing": false,
                    "iceberg": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": true,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": 1,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": 1,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 1,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 300,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
        },
        "commonCurrencies": map[string]interface{} {
            "USD_STABLE_COIN": "USDC",
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "219": InvalidOrder,
                "314": InvalidOrder,
                "10001": ExchangeError,
                "10002": PermissionDenied,
                "10003": PermissionDenied,
                "10004": BadRequest,
                "10005": PermissionDenied,
                "10006": DDoSProtection,
                "10007": InvalidNonce,
                "10008": BadRequest,
                "10009": BadRequest,
                "20001": BadRequest,
                "20002": InsufficientFunds,
                "20005": AccountNotEnabled,
                "30003": BadSymbol,
                "30004": BadRequest,
                "30005": BadRequest,
                "30006": InvalidOrder,
                "30007": InvalidOrder,
                "30008": InvalidOrder,
                "30009": InvalidOrder,
                "30010": BadRequest,
                "30013": InvalidOrder,
                "30014": InvalidOrder,
                "30016": InvalidOrder,
                "30017": InvalidOrder,
                "30023": InvalidOrder,
                "30024": InvalidOrder,
                "30025": InvalidOrder,
                "40001": BadRequest,
                "40002": BadRequest,
                "40003": BadRequest,
                "40004": BadRequest,
                "40005": BadRequest,
                "40006": BadRequest,
                "40007": BadRequest,
                "40101": AuthenticationError,
                "40102": InvalidNonce,
                "40103": AuthenticationError,
                "40104": AuthenticationError,
                "40107": BadRequest,
                "40401": OrderNotFound,
                "40801": RequestTimeout,
                "42901": RateLimitExceeded,
                "43005": InvalidOrder,
                "43003": InvalidOrder,
                "43004": InvalidOrder,
                "43012": BadRequest,
                "50001": ExchangeError,
                "9010001": OnMaintenance,
            },
            "broad": map[string]interface{} {},
        },
    })
}
/**
 * @method
 * @name cryptocom#fetchMarkets
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-instruments
 * @description retrieves data on all markets for cryptocom
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *cryptocom) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetPublicGetInstruments(params))
            PanicOnError(response)
            //
            //     {
            //         "id": 1,
            //         "method": "public/get-instruments",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "symbol": "BTC_USDT",
            //                     "inst_type": "CCY_PAIR",
            //                     "display_name": "BTC/USDT",
            //                     "base_ccy": "BTC",
            //                     "quote_ccy": "USDT",
            //                     "quote_decimals": 2,
            //                     "quantity_decimals": 5,
            //                     "price_tick_size": "0.01",
            //                     "qty_tick_size": "0.00001",
            //                     "max_leverage": "50",
            //                     "tradable": true,
            //                     "expiry_timestamp_ms": 0,
            //                     "beta_product": false,
            //                     "margin_buy_enabled": false,
            //                     "margin_sell_enabled": true
            //                 },
            //                 {
            //                     "symbol": "RUNEUSD-PERP",
            //                     "inst_type": "PERPETUAL_SWAP",
            //                     "display_name": "RUNEUSD Perpetual",
            //                     "base_ccy": "RUNE",
            //                     "quote_ccy": "USD",
            //                     "quote_decimals": 3,
            //                     "quantity_decimals": 1,
            //                     "price_tick_size": "0.001",
            //                     "qty_tick_size": "0.1",
            //                     "max_leverage": "50",
            //                     "tradable": true,
            //                     "expiry_timestamp_ms": 0,
            //                     "beta_product": false,
            //                     "underlying_symbol": "RUNEUSD-INDEX",
            //                     "contract_size": "1",
            //                     "margin_buy_enabled": false,
            //                     "margin_sell_enabled": false
            //                 },
            //                 {
            //                     "symbol": "ETHUSD-230825",
            //                     "inst_type": "FUTURE",
            //                     "display_name": "ETHUSD Futures 20230825",
            //                     "base_ccy": "ETH",
            //                     "quote_ccy": "USD",
            //                     "quote_decimals": 2,
            //                     "quantity_decimals": 4,
            //                     "price_tick_size": "0.01",
            //                     "qty_tick_size": "0.0001",
            //                     "max_leverage": "100",
            //                     "tradable": true,
            //                     "expiry_timestamp_ms": 1692950400000,
            //                     "beta_product": false,
            //                     "underlying_symbol": "ETHUSD-INDEX",
            //                     "contract_size": "1",
            //                     "margin_buy_enabled": false,
            //                     "margin_sell_enabled": false
            //                 },
            //                 {
            //                     "symbol": "BTCUSD-230630-CW30000",
            //                     "inst_type": "WARRANT",
            //                     "display_name": "BTCUSD-230630-CW30000",
            //                     "base_ccy": "BTC",
            //                     "quote_ccy": "USD",
            //                     "quote_decimals": 3,
            //                     "quantity_decimals": 0,
            //                     "price_tick_size": "0.001",
            //                     "qty_tick_size": "10",
            //                     "max_leverage": "50",
            //                     "tradable": true,
            //                     "expiry_timestamp_ms": 1688112000000,
            //                     "beta_product": false,
            //                     "underlying_symbol": "BTCUSD-INDEX",
            //                     "put_call": "CALL",
            //                     "strike": "30000",
            //                     "contract_size": "0.0001",
            //                     "margin_buy_enabled": false,
            //                     "margin_sell_enabled": false
            //                 },
            //             ]
            //         }
            //     }
            //
            var resultResponse interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(resultResponse, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var inst_type interface{} = this.SafeString(market, "inst_type")
                var spot interface{} = IsEqual(inst_type, "CCY_PAIR")
                var swap interface{} = IsEqual(inst_type, "PERPETUAL_SWAP")
                var future interface{} = IsEqual(inst_type, "FUTURE")
                var option interface{} = IsEqual(inst_type, "WARRANT")
                var baseId interface{} = this.SafeString(market, "base_ccy")
                var quoteId interface{} = this.SafeString(market, "quote_ccy")
                var settleId interface{} = Ternary(IsTrue(spot), nil, quoteId)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = Ternary(IsTrue(spot), nil, this.SafeCurrencyCode(settleId))
                var optionType interface{} = this.SafeStringLower(market, "put_call")
                var strike interface{} = this.SafeString(market, "strike")
                var marginBuyEnabled interface{} = this.SafeBool(market, "margin_buy_enabled")
                var marginSellEnabled interface{} = this.SafeBool(market, "margin_sell_enabled")
                var expiryString interface{} = this.OmitZero(this.SafeString(market, "expiry_timestamp_ms"))
                var expiry interface{} = Ternary(IsTrue((!IsEqual(expiryString, nil))), ParseInt(expiryString), nil)
                var symbol interface{} = Add(Add(base, "/"), quote)
                var typeVar interface{} = nil
                var contract interface{} = nil
                if IsTrue(IsEqual(inst_type, "CCY_PAIR")) {
                    typeVar = "spot"
                    contract = false
                } else if IsTrue(IsEqual(inst_type, "PERPETUAL_SWAP")) {
                    typeVar = "swap"
                    symbol = Add(Add(symbol, ":"), quote)
                    contract = true
                } else if IsTrue(IsEqual(inst_type, "FUTURE")) {
                    typeVar = "future"
                    symbol = Add(Add(Add(Add(symbol, ":"), quote), "-"), this.Yymmdd(expiry))
                    contract = true
                } else if IsTrue(IsEqual(inst_type, "WARRANT")) {
                    typeVar = "option"
                    var symbolOptionType interface{} = Ternary(IsTrue((IsEqual(optionType, "call"))), "C", "P")
                    symbol = Add(Add(Add(Add(Add(Add(Add(Add(symbol, ":"), quote), "-"), this.Yymmdd(expiry)), "-"), strike), "-"), symbolOptionType)
                    contract = true
                }
                AppendToArray(&result,map[string]interface{} {
                    "id": this.SafeString(market, "symbol"),
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": typeVar,
                    "spot": spot,
                    "margin": (IsTrue((marginBuyEnabled)) || IsTrue((marginSellEnabled))),
                    "swap": swap,
                    "future": future,
                    "option": option,
                    "active": this.SafeBool(market, "tradable"),
                    "contract": contract,
                    "linear": Ternary(IsTrue((contract)), true, nil),
                    "inverse": Ternary(IsTrue((contract)), false, nil),
                    "contractSize": this.SafeNumber(market, "contract_size"),
                    "expiry": expiry,
                    "expiryDatetime": this.Iso8601(expiry),
                    "strike": this.ParseNumber(strike),
                    "optionType": optionType,
                    "precision": map[string]interface{} {
                        "price": this.ParseNumber(this.SafeString(market, "price_tick_size")),
                        "amount": this.ParseNumber(this.SafeString(market, "qty_tick_size")),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.ParseNumber("1"),
                            "max": this.SafeNumber(market, "max_leverage"),
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-tickers
 * @see https://exchange-docs.crypto.com/derivatives/index.html#public-get-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *cryptocom) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7138 := (<-this.LoadMarkets())
            PanicOnError(retRes7138)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = nil
                if IsTrue(IsArray(symbols)) {
                    var symbolsLength interface{} =             GetArrayLength(symbols)
                    if IsTrue(IsGreaterThan(symbolsLength, 1)) {
                        panic(BadRequest(Add(this.Id, " fetchTickers() symbols argument cannot contain more than 1 symbol")))
                    }
                    symbol = GetValue(symbols, 0)
                } else {
                    symbol = symbols
                }
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
        
            response:= (<-this.V1PublicGetPublicGetTickers(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-tickers",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "i": "AVAXUSD-PERP",
            //                     "h": "13.209",
            //                     "l": "12.148",
            //                     "a": "13.209",
            //                     "v": "1109.8",
            //                     "vv": "14017.33",
            //                     "c": "0.0732",
            //                     "b": "13.210",
            //                     "k": "13.230",
            //                     "oi": "10888.9",
            //                     "t": 1687402657575
            //                 },
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchTicker
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-tickers
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *cryptocom) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7708 := (<-this.LoadMarkets())
            PanicOnError(retRes7708)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.FetchTickers([]interface{}{symbol}, params))
            PanicOnError(tickers)
        
            ch <- this.SafeValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-order-history
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for, max date range is one day
 * @param {int} [limit] the maximum number of order structures to retrieve, default 100 max 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7908 := (<-this.LoadMarkets())
            PanicOnError(retRes7908)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes79419 :=  (<-this.FetchPaginatedCallDynamic("fetchOrders", symbol, since, limit, params))
                    PanicOnError(retRes79419)
                    ch <- retRes79419
                    return nil
            }
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_time", until)
            }
        
            response:= (<-this.V1PrivatePostPrivateGetOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686881486183,
            //         "method": "private/get-order-history",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
            //                     "order_id": "6142909895014042762",
            //                     "client_oid": "4e918597-1234-4321-8201-a7577e1e1d91",
            //                     "order_type": "MARKET",
            //                     "time_in_force": "GOOD_TILL_CANCEL",
            //                     "side": "SELL",
            //                     "exec_inst": [ ],
            //                     "quantity": "0.00024",
            //                     "order_value": "5.7054672",
            //                     "maker_fee_rate": "0",
            //                     "taker_fee_rate": "0",
            //                     "avg_price": "25023.97",
            //                     "trigger_price": "0",
            //                     "ref_price": "0",
            //                     "ref_price_type": "NULL_VAL",
            //                     "cumulative_quantity": "0.00024",
            //                     "cumulative_value": "6.0057528",
            //                     "cumulative_fee": "0.001501438200",
            //                     "status": "FILLED",
            //                     "update_user_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
            //                     "order_date": "2023-06-15",
            //                     "instrument_name": "BTC_USD",
            //                     "fee_instrument_name": "USD",
            //                     "create_time": 1686805465891,
            //                     "create_time_ns": "1686805465891812578",
            //                     "update_time": 1686805465891
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "data", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchTrades
 * @description get a list of the most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch, maximum date range is one day
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *cryptocom) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8728 := (<-this.LoadMarkets())
            PanicOnError(retRes8728)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes87619 :=  (<-this.FetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, params))
                    PanicOnError(retRes87619)
                    ch <- retRes87619
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_ts", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_ts", until)
            }
        
            response:= (<-this.V1PublicGetPublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-trades",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "s": "sell",
            //                     "p": "26386.00",
            //                     "q": "0.00453",
            //                     "t": 1686944282062,
            //                     "tn" : 1704476468851524373,
            //                     "d": "4611686018455979970",
            //                     "i": "BTC_USD"
            //                 },
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var trades interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-candlestick
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *cryptocom) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9348 := (<-this.LoadMarkets())
            PanicOnError(retRes9348)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes93819 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 300))
                    PanicOnError(retRes93819)
                    ch <- retRes93819
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "timeframe": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 300)) {
                    limit = 300
                }
                AddElementToObject(request, "count", limit)
            }
            var now interface{} = this.Microseconds()
            var duration interface{} = this.ParseTimeframe(timeframe)
            var until interface{} = this.SafeInteger(params, "until", now)
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_ts", Subtract(since, Multiply(duration, 1000)))
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "end_ts", this.Sum(since, Multiply(Multiply(duration, limit), 1000)))
                } else {
                    AddElementToObject(request, "end_ts", until)
                }
            } else {
                AddElementToObject(request, "end_ts", until)
            }
        
            response:= (<-this.V1PublicGetPublicGetCandlestick(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-candlestick",
            //         "code": 0,
            //         "result": {
            //             "interval": "1m",
            //             "data": [
            //                 {
            //                     "o": "26949.89",
            //                     "h": "26957.64",
            //                     "l": "26948.24",
            //                     "c": "26950.00",
            //                     "v": "0.0670",
            //                     "t": 1687237080000
            //                 },
            //             ],
            //             "instrument_name": "BTC_USD"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the number of order book entries to return, max 50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *cryptocom) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10038 := (<-this.LoadMarkets())
            PanicOnError(retRes10038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
            if IsTrue(limit) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.V1PublicGetPublicGetBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-book",
            //         "code": 0,
            //         "result": {
            //             "depth": 3,
            //             "data": [
            //                 {
            //                     "bids": [ [ "30025.00", "0.00004", "1" ], [ "30020.15", "0.02498", "1" ], [ "30020.00", "0.00004", "1" ] ],
            //                     "asks": [ [ "30025.01", "0.04090", "1" ], [ "30025.70", "0.01000", "1" ], [ "30026.94", "0.02681", "1" ] ],
            //                     "t": 1687491287380
            //                 }
            //             ],
            //             "instrument_name": "BTC_USD"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
            var orderBook interface{} = this.SafeValue(data, 0)
            var timestamp interface{} = this.SafeInteger(orderBook, "t")
        
            ch <- this.ParseOrderBook(orderBook, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseBalance(response interface{}) interface{}  {
    var responseResult interface{} = this.SafeDict(response, "result", map[string]interface{} {})
    var data interface{} = this.SafeList(responseResult, "data", []interface{}{})
    var positionBalances interface{} = this.SafeValue(GetValue(data, 0), "position_balances", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(positionBalances)); i++ {
        var balance interface{} = GetValue(positionBalances, i)
        var currencyId interface{} = this.SafeString(balance, "instrument_name")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "quantity"))
        AddElementToObject(account, "used", this.SafeString(balance, "reserved_qty"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name cryptocom#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-user-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *cryptocom) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10638 := (<-this.LoadMarkets())
            PanicOnError(retRes10638)
        
            response:= (<-this.V1PrivatePostPrivateUserBalance(params))
            PanicOnError(response)
        
                //
            //     {
            //         "id": 1687300499018,
            //         "method": "private/user-balance",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "total_available_balance": "5.84684368",
            //                     "total_margin_balance": "5.84684368",
            //                     "total_initial_margin": "0",
            //                     "total_maintenance_margin": "0",
            //                     "total_position_cost": "0",
            //                     "total_cash_balance": "6.44412101",
            //                     "total_collateral_value": "5.846843685",
            //                     "total_session_unrealized_pnl": "0",
            //                     "instrument_name": "USD",
            //                     "total_session_realized_pnl": "0",
            //                     "position_balances": [
            //                         {
            //                             "quantity": "0.0002119875",
            //                             "reserved_qty": "0",
            //                             "collateral_weight": "0.9",
            //                             "collateral_amount": "5.37549592",
            //                             "market_value": "5.97277325",
            //                             "max_withdrawal_balance": "0.00021198",
            //                             "instrument_name": "BTC",
            //                             "hourly_interest_rate": "0"
            //                         },
            //                     ],
            //                     "total_effective_leverage": "0",
            //                     "position_limit": "3000000",
            //                     "used_position_limit": "0",
            //                     "total_borrow": "0",
            //                     "margin_score": "0",
            //                     "is_liquidating": false,
            //                     "has_risk": false,
            //                     "terminatable": true
            //                 }
            //             ]
            //         }
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-order-detail
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11228 := (<-this.LoadMarkets())
            PanicOnError(retRes11228)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.V1PrivatePostPrivateGetOrderDetail(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686872583882,
            //         "method": "private/get-order-detail",
            //         "code": 0,
            //         "result": {
            //             "account_id": "ae075bef-1234-4321-bd6g-bb9007252a63",
            //             "order_id": "6142909895025252686",
            //             "client_oid": "CCXT_c2d2152cc32d40a3ae7fbf",
            //             "order_type": "LIMIT",
            //             "time_in_force": "GOOD_TILL_CANCEL",
            //             "side": "BUY",
            //             "exec_inst": [ ],
            //             "quantity": "0.00020",
            //             "limit_price": "20000.00",
            //             "order_value": "4",
            //             "avg_price": "0",
            //             "trigger_price": "0",
            //             "ref_price": "0",
            //             "cumulative_quantity": "0",
            //             "cumulative_value": "0",
            //             "cumulative_fee": "0",
            //             "status": "ACTIVE",
            //             "update_user_id": "ae075bef-1234-4321-bd6g-bb9007252a63",
            //             "order_date": "2023-06-15",
            //             "instrument_name": "BTC_USD",
            //             "fee_instrument_name": "BTC",
            //             "create_time": 1686870220684,
            //             "create_time_ns": "1686870220684239675",
            //             "update_time": 1686870220684
            //         }
            //     }
            //
            var order interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var uppercaseType interface{} = ToUpper(typeVar)
    var request interface{} = map[string]interface{} {
        "instrument_name": GetValue(market, "id"),
        "side": ToUpper(side),
        "quantity": this.AmountToPrecision(symbol, amount),
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var broker interface{} = this.SafeString(this.Options, "broker", "CCXT")
    AddElementToObject(request, "broker_id", broker)
    var marketType interface{} = nil
    var marginMode interface{} = nil
    marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params);
    marketType = GetValue(marketTypeparamsVariable,0);
    params = GetValue(marketTypeparamsVariable,1)
    marginModeparamsVariable := this.CustomHandleMarginModeAndParams("createOrder", params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsTrue((IsEqual(marketType, "margin"))) || IsTrue((!IsEqual(marginMode, nil)))) {
        AddElementToObject(request, "spot_margin", "MARGIN")
    } else if IsTrue(IsEqual(marketType, "spot")) {
        AddElementToObject(request, "spot_margin", "SPOT")
    }
    var timeInForce interface{} = this.SafeStringUpper2(params, "timeInForce", "time_in_force")
    if IsTrue(!IsEqual(timeInForce, nil)) {
        if IsTrue(IsEqual(timeInForce, "GTC")) {
            AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
        } else if IsTrue(IsEqual(timeInForce, "IOC")) {
            AddElementToObject(request, "time_in_force", "IMMEDIATE_OR_CANCEL")
        } else if IsTrue(IsEqual(timeInForce, "FOK")) {
            AddElementToObject(request, "time_in_force", "FILL_OR_KILL")
        } else {
            AddElementToObject(request, "time_in_force", timeInForce)
        }
    }
    var postOnly interface{} = this.SafeBool(params, "postOnly", false)
    if IsTrue(IsTrue((postOnly)) || IsTrue((IsEqual(timeInForce, "PO")))) {
        AddElementToObject(request, "exec_inst", []interface{}{"POST_ONLY"})
        AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
    }
    var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"stopPrice", "triggerPrice", "ref_price"})
    var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
    var isTrigger interface{} =     (!IsEqual(triggerPrice, nil))
    var isStopLossTrigger interface{} =     (!IsEqual(stopLossPrice, nil))
    var isTakeProfitTrigger interface{} =     (!IsEqual(takeProfitPrice, nil))
    if IsTrue(isTrigger) {
        AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, triggerPrice))
        var priceString interface{} = this.NumberToString(price)
        if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
            if IsTrue(IsEqual(side, "buy")) {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
                } else {
                    AddElementToObject(request, "type", "STOP_LIMIT")
                }
            } else {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "STOP_LIMIT")
                } else {
                    AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
                }
            }
        } else {
            if IsTrue(IsEqual(side, "buy")) {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "TAKE_PROFIT")
                } else {
                    AddElementToObject(request, "type", "STOP_LOSS")
                }
            } else {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "STOP_LOSS")
                } else {
                    AddElementToObject(request, "type", "TAKE_PROFIT")
                }
            }
        }
    } else if IsTrue(isStopLossTrigger) {
        if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
            AddElementToObject(request, "type", "STOP_LIMIT")
        } else {
            AddElementToObject(request, "type", "STOP_LOSS")
        }
        AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, stopLossPrice))
    } else if IsTrue(isTakeProfitTrigger) {
        if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
            AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
        } else {
            AddElementToObject(request, "type", "TAKE_PROFIT")
        }
        AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, takeProfitPrice))
    } else {
        AddElementToObject(request, "type", uppercaseType)
    }
    params = this.Omit(params, []interface{}{"postOnly", "clientOrderId", "timeInForce", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name cryptocom#createOrder
 * @description create a trade order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_loss', 'stop_limit', 'take_profit', 'take_profit_limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
 * @param {string} [params.ref_price_type] 'MARK_PRICE', 'INDEX_PRICE', 'LAST_PRICE' which trigger price type to use, default is MARK_PRICE
 * @param {float} [params.triggerPrice] price to trigger a trigger order
 * @param {float} [params.stopLossPrice] price to trigger a stop-loss trigger order
 * @param {float} [params.takeProfitPrice] price to trigger a take-profit trigger order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12858 := (<-this.LoadMarkets())
            PanicOnError(retRes12858)
            var market interface{} = this.Market(symbol)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
        
            response:= (<-this.V1PrivatePostPrivateCreateOrder(request))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686804664362,
            //         "method": "private/create-order",
            //         "code" : 0,
            //         "result": {
            //             "order_id": "6540219377766741832",
            //             "client_oid": "CCXT_d6ef7c3db6c1495aa8b757"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#createOrders
 * @description create a list of trade orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order-list-list
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order-list-oco
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13158 := (<-this.LoadMarkets())
            PanicOnError(retRes13158)
            var ordersRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateAdvancedOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var contigency interface{} = this.SafeString(params, "contingency_type", "LIST")
            var request interface{} = map[string]interface{} {
                "contingency_type": contigency,
                "order_list": ordersRequests,
            }
        
            response:= (<-this.V1PrivatePostPrivateCreateOrderList(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "id": 12,
            //     "method": "private/create-order-list",
            //     "code": 10001,
            //     "result": {
            //       "result_list": [
            //         {
            //           "index": 0,
            //           "code": 0,
            //           "order_id": "2015106383706015873",
            //           "client_oid": "my_order_0001"
            //         },
            //         {
            //           "index": 1,
            //           "code": 20007,
            //           "message": "INVALID_REQUEST",
            //           "client_oid": "my_order_0002"
            //         }
            //       ]
            //     }
            // }
            //
            //   {
            //       "id" : 1698068111133,
            //       "method" : "private/create-order-list",
            //       "code" : 0,
            //       "result" : [ {
            //         "code" : 0,
            //         "index" : 0,
            //         "client_oid" : "1698068111133_0",
            //         "order_id" : "6142909896519488206"
            //       }, {
            //         "code" : 306,
            //         "index" : 1,
            //         "client_oid" : "1698068111133_1",
            //         "message" : "INSUFFICIENT_AVAILABLE_BALANCE",
            //         "order_id" : "6142909896519488207"
            //       } ]
            //   }
            //
            var result interface{} = this.SafeValue(response, "result", []interface{}{})
            var listId interface{} = this.SafeString(result, "list_id")
            if IsTrue(!IsEqual(listId, nil)) {
                var ocoOrders interface{} = []interface{}{map[string]interface{} {
            "order_id": listId,
        }}
        
                ch <- this.ParseOrders(ocoOrders)
                return nil
            }
        
            ch <- this.ParseOrders(result)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) CreateAdvancedOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    // differs slightly from createOrderRequest
    // since the advanced order endpoint requires a different set of parameters
    // namely here we don't support ref_price or spot_margin
    // and market-buy orders need to send notional instead of quantity
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var uppercaseType interface{} = ToUpper(typeVar)
    var request interface{} = map[string]interface{} {
        "instrument_name": GetValue(market, "id"),
        "side": ToUpper(side),
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var broker interface{} = this.SafeString(this.Options, "broker", "CCXT")
    AddElementToObject(request, "broker_id", broker)
    var timeInForce interface{} = this.SafeStringUpper2(params, "timeInForce", "time_in_force")
    if IsTrue(!IsEqual(timeInForce, nil)) {
        if IsTrue(IsEqual(timeInForce, "GTC")) {
            AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
        } else if IsTrue(IsEqual(timeInForce, "IOC")) {
            AddElementToObject(request, "time_in_force", "IMMEDIATE_OR_CANCEL")
        } else if IsTrue(IsEqual(timeInForce, "FOK")) {
            AddElementToObject(request, "time_in_force", "FILL_OR_KILL")
        } else {
            AddElementToObject(request, "time_in_force", timeInForce)
        }
    }
    var postOnly interface{} = this.SafeBool(params, "postOnly", false)
    if IsTrue(IsTrue((postOnly)) || IsTrue((IsEqual(timeInForce, "PO")))) {
        AddElementToObject(request, "exec_inst", []interface{}{"POST_ONLY"})
        AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
    }
    var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"stopPrice", "triggerPrice", "ref_price"})
    var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
    var isTrigger interface{} =     (!IsEqual(triggerPrice, nil))
    var isStopLossTrigger interface{} =     (!IsEqual(stopLossPrice, nil))
    var isTakeProfitTrigger interface{} =     (!IsEqual(takeProfitPrice, nil))
    if IsTrue(isTrigger) {
        var priceString interface{} = this.NumberToString(price)
        if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
            if IsTrue(IsEqual(side, "buy")) {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
                } else {
                    AddElementToObject(request, "type", "STOP_LIMIT")
                }
            } else {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "STOP_LIMIT")
                } else {
                    AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
                }
            }
        } else {
            if IsTrue(IsEqual(side, "buy")) {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "TAKE_PROFIT")
                } else {
                    AddElementToObject(request, "type", "STOP_LOSS")
                }
            } else {
                if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
                    AddElementToObject(request, "type", "STOP_LOSS")
                } else {
                    AddElementToObject(request, "type", "TAKE_PROFIT")
                }
            }
        }
    } else if IsTrue(isStopLossTrigger) {
        if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
            AddElementToObject(request, "type", "STOP_LIMIT")
        } else {
            AddElementToObject(request, "type", "STOP_LOSS")
        }
    } else if IsTrue(isTakeProfitTrigger) {
        if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
            AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
        } else {
            AddElementToObject(request, "type", "TAKE_PROFIT")
        }
    } else {
        AddElementToObject(request, "type", uppercaseType)
    }
    if IsTrue(IsTrue((IsEqual(side, "buy"))) && IsTrue((IsTrue(IsTrue((IsEqual(uppercaseType, "MARKET"))) || IsTrue((IsEqual(uppercaseType, "STOP_LOSS")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT")))))) {
        // use createmarketBuy logic here
        var quoteAmount interface{} = nil
        var createMarketBuyOrderRequiresPrice interface{} = true
        createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
        createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
        params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
        var cost interface{} = this.SafeNumber2(params, "cost", "notional")
        params = this.Omit(params, "cost")
        if IsTrue(!IsEqual(cost, nil)) {
            quoteAmount = this.CostToPrecision(symbol, cost)
        } else if IsTrue(createMarketBuyOrderRequiresPrice) {
            if IsTrue(IsEqual(price, nil)) {
                panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
            } else {
                var amountString interface{} = this.NumberToString(amount)
                var priceString interface{} = this.NumberToString(price)
                var costRequest interface{} = Precise.StringMul(amountString, priceString)
                quoteAmount = this.CostToPrecision(symbol, costRequest)
            }
        } else {
            quoteAmount = this.CostToPrecision(symbol, amount)
        }
        AddElementToObject(request, "notional", quoteAmount)
    } else {
        AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
    }
    params = this.Omit(params, []interface{}{"postOnly", "clientOrderId", "timeInForce", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name cryptocom#cancelAllOrders
 * @description cancel all open orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-all-orders
 * @param {string} symbol unified market symbol of the orders to cancel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} Returns exchange raw message{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15088 := (<-this.LoadMarkets())
            PanicOnError(retRes15088)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
        
                retRes151515 :=  (<-this.V1PrivatePostPrivateCancelAllOrders(this.Extend(request, params)))
                PanicOnError(retRes151515)
                ch <- retRes151515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#cancelOrder
 * @description cancels an open order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order
 * @param {string} id the order id of the order to cancel
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15298 := (<-this.LoadMarkets())
            PanicOnError(retRes15298)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.V1PrivatePostPrivateCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686882846638,
            //         "method": "private/cancel-order",
            //         "code": 0,
            //         "message": "NO_ERROR",
            //         "result": {
            //             "client_oid": "CCXT_c2d2152cc32d40a3ae7fbf",
            //             "order_id": "6142909895025252686"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#cancelOrders
 * @description cancel multiple orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order-list-list
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes15688 := (<-this.LoadMarkets())
            PanicOnError(retRes15688)
            var market interface{} = this.Market(symbol)
            var orderRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                var order interface{} = map[string]interface{} {
                    "instrument_name": GetValue(market, "id"),
                    "order_id": ToString(id),
                }
                AppendToArray(&orderRequests,order)
            }
            var request interface{} = map[string]interface{} {
                "contingency_type": "LIST",
                "order_list": orderRequests,
            }
        
            response:= (<-this.V1PrivatePostPrivateCancelOrderList(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, market, nil, nil, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#cancelOrdersForSymbols
 * @description cancel multiple orders for multiple symbols
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order-list-list
 * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) CancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15988 := (<-this.LoadMarkets())
            PanicOnError(retRes15988)
            var orderRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var order interface{} = GetValue(orders, i)
                var id interface{} = this.SafeString(order, "id")
                var symbol interface{} = this.SafeString(order, "symbol")
                var market interface{} = this.Market(symbol)
                var orderItem interface{} = map[string]interface{} {
                    "instrument_name": GetValue(market, "id"),
                    "order_id": ToString(id),
                }
                AppendToArray(&orderRequests,orderItem)
            }
            var request interface{} = map[string]interface{} {
                "contingency_type": "LIST",
                "order_list": orderRequests,
            }
        
            response:= (<-this.V1PrivatePostPrivateCancelOrderList(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, nil, nil, nil, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *cryptocom) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16328 := (<-this.LoadMarkets())
            PanicOnError(retRes16328)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
        
            response:= (<-this.V1PrivatePostPrivateGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686806134961,
            //         "method": "private/get-open-orders",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
            //                     "order_id": "6530219477767564494",
            //                     "client_oid": "CCXT_7ce730f0388441df9bc218",
            //                     "order_type": "LIMIT",
            //                     "time_in_force": "GOOD_TILL_CANCEL",
            //                     "side": "BUY",
            //                     "exec_inst": [ ],
            //                     "quantity": "0.00020",
            //                     "limit_price": "20000.00",
            //                     "order_value": "4",
            //                     "avg_price": "0",
            //                     "trigger_price": "0",
            //                     "ref_price": "0",
            //                     "cumulative_quantity": "0",
            //                     "cumulative_value": "0",
            //                     "cumulative_fee": "0",
            //                     "status": "ACTIVE",
            //                     "update_user_id": "ce075bef-1234-4321-bd6g-gg9007252e63",
            //                     "order_date": "2023-06-15",
            //                     "instrument_name": "BTC_USD",
            //                     "fee_instrument_name": "BTC",
            //                     "create_time": 1686806053992,
            //                     "create_time_ns": "1686806053992921880",
            //                     "update_time": 1686806053993
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "data", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for, maximum date range is one day
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *cryptocom) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16968 := (<-this.LoadMarkets())
            PanicOnError(retRes16968)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes170019 :=  (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params, 100))
                    PanicOnError(retRes170019)
                    ch <- retRes170019
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_time", until)
            }
        
            response:= (<-this.V1PrivatePostPrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686942003520,
            //         "method": "private/get-trades",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ds075abc-1234-4321-bd6g-ff9007252r63",
            //                     "event_date": "2023-06-16",
            //                     "journal_type": "TRADING",
            //                     "side": "BUY",
            //                     "instrument_name": "BTC_USD",
            //                     "fees": "-0.0000000525",
            //                     "trade_id": "6142909898247428343",
            //                     "trade_match_id": "4611686018455978480",
            //                     "create_time": 1686941992887,
            //                     "traded_price": "26347.16",
            //                     "traded_quantity": "0.00021",
            //                     "fee_instrument_name": "BTC",
            //                     "client_oid": "d1c70a60-810e-4c92-b2a0-72b931cb31e0",
            //                     "taker_side": "TAKER",
            //                     "order_id": "6142909895036331486",
            //                     "create_time_ns": "1686941992887207066"
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var trades interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseAddress(addressString interface{}) interface{}  {
    var address interface{} = nil
    var tag interface{} = nil
    var rawTag interface{} = nil
    if IsTrue(IsGreaterThan(GetIndexOf(addressString, "?"), 0)) {
        addressrawTagVariable := Split(addressString, "?");
        address = GetValue(addressrawTagVariable,0);
        rawTag = GetValue(addressrawTagVariable,1)
        var splitted interface{} = Split(rawTag, "=")
        tag = GetValue(splitted, 1)
    } else {
        address = addressString
    }
    return []interface{}{address, tag}
}
/**
 * @method
 * @name cryptocom#withdraw
 * @description make a withdrawal
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *cryptocom) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes17828 := (<-this.LoadMarkets())
            PanicOnError(retRes17828)
            var currency interface{} = this.SafeCurrency(code) // for instance, USDC is not inferred from markets but it's still available
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "address_tag", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            var networkId interface{} = this.NetworkCodeToId(networkCode)
            if IsTrue(!IsEqual(networkId, nil)) {
                AddElementToObject(request, "network_id", networkId)
            }
        
            response:= (<-this.V1PrivatePostPrivateCreateWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "id":-1,
            //        "method":"private/create-withdrawal",
            //        "code":0,
            //        "result": {
            //            "id": 2220,
            //            "amount": 1,
            //            "fee": 0.0004,
            //            "symbol": "BTC",
            //            "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
            //            "client_wid": "my_withdrawal_002",
            //            "create_time":1607063412000
            //        }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseTransaction(result, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
 */
func  (this *cryptocom) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18298 := (<-this.LoadMarkets())
            PanicOnError(retRes18298)
            var currency interface{} = this.SafeCurrency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.V1PrivatePostPrivateGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1234555011221,
            //         "method": "private/get-deposit-address",
            //         "code": 0,
            //         "result": {
            //             "deposit_address_list": [
            //                 {
            //                     "currency": "BTC",
            //                     "create_time": 1686730755000,
            //                     "id": "3737377",
            //                     "address": "3N9afggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
            //                     "status":"1",
            //                     "network": "BTC"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var addresses interface{} = this.SafeList(data, "deposit_address_list", []interface{}{})
            var addressesLength interface{} =     GetArrayLength(addresses)
            if IsTrue(IsEqual(addressesLength, 0)) {
                panic(ExchangeError(Add(this.Id, " fetchDepositAddressesByNetwork() generating address...")))
            }
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, addressesLength); i++ {
                var value interface{} = this.SafeDict(addresses, i)
                var addressString interface{} = this.SafeString(value, "address")
                var currencyId interface{} = this.SafeString(value, "currency")
                var responseCode interface{} = this.SafeCurrencyCode(currencyId)
                addresstagVariable := this.ParseAddress(addressString);
                address := GetValue(addresstagVariable,0);
                tag := GetValue(addresstagVariable,1)
                this.CheckAddress(address)
                var networkId interface{} = this.SafeString(value, "network")
                var network interface{} = this.NetworkIdToCode(networkId, responseCode)
                AddElementToObject(result, network, map[string]interface{} {
            "info": value,
            "currency": responseCode,
            "network": network,
            "address": address,
            "tag": tag,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *cryptocom) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var network interface{} = this.SafeStringUpper(params, "network")
            params = this.Omit(params, []interface{}{"network"})
        
            depositAddresses:= (<-this.FetchDepositAddressesByNetwork(code, params))
            PanicOnError(depositAddresses)
            if IsTrue(InOp(depositAddresses, network)) {
        
                ch <- GetValue(depositAddresses, network)
                return nil
            } else {
                var keys interface{} = ObjectKeys(depositAddresses)
        
                ch <- GetValue(depositAddresses, GetValue(keys, 0))
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *cryptocom) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19158 := (<-this.LoadMarkets())
            PanicOnError(retRes19158)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.SafeCurrency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                // 90 days date range
                AddElementToObject(request, "start_ts", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_ts", until)
            }
        
            response:= (<-this.V1PrivatePostPrivateGetDepositHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1688701375714,
            //         "method": "private/get-deposit-history",
            //         "code": 0,
            //         "result": {
            //             "deposit_list": [
            //                 {
            //                     "currency": "BTC",
            //                     "fee": 0,
            //                     "create_time": 1688023659000,
            //                     "id": "6201135",
            //                     "update_time": 1688178509000,
            //                     "amount": 0.00114571,
            //                     "address": "1234fggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
            //                     "status": "1",
            //                     "txid": "f0ae4202b76eb999c301eccdde44dc639bee42d1fdd5974105286ca3393f6065/2"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var depositList interface{} = this.SafeList(data, "deposit_list", []interface{}{})
        
            ch <- this.ParseTransactions(depositList, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-withdrawal-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *cryptocom) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19758 := (<-this.LoadMarkets())
            PanicOnError(retRes19758)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.SafeCurrency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                // 90 days date range
                AddElementToObject(request, "start_ts", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_ts", until)
            }
        
            response:= (<-this.V1PrivatePostPrivateGetWithdrawalHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1688613879534,
            //         "method": "private/get-withdrawal-history",
            //         "code": 0,
            //         "result": {
            //             "withdrawal_list": [
            //                 {
            //                     "currency": "BTC",
            //                     "client_wid": "",
            //                     "fee": 0.0005,
            //                     "create_time": 1688613850000,
            //                     "id": "5275977",
            //                     "update_time": 1688613850000,
            //                     "amount": 0.0005,
            //                     "address": "1234NMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn",
            //                     "status": "1",
            //                     "txid": "",
            //                     "network_id": "BTC"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var withdrawalList interface{} = this.SafeList(data, "withdrawal_list", []interface{}{})
        
            ch <- this.ParseTransactions(withdrawalList, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "i": "BTC_USD",
    //         "h": "30821.45",
    //         "l": "28685.11",
    //         "a": "30446.00",
    //         "v": "1767.8734",
    //         "vv": "52436726.42",
    //         "c": "0.0583",
    //         "b": "30442.00",
    //         "k": "30447.66",
    //         "t": 1687403045415
    //     }
    //
    // fetchTickers
    //
    //     {
    //         "i": "AVAXUSD-PERP",
    //         "h": "13.209",
    //         "l": "12.148",
    //         "a": "13.209",
    //         "v": "1109.8",
    //         "vv": "14017.33",
    //         "c": "0.0732",
    //         "b": "13.210",
    //         "k": "13.230",
    //         "oi": "10888.9",
    //         "t": 1687402657575
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var marketId interface{} = this.SafeString(ticker, "i")
    market = this.SafeMarket(marketId, market, "_")
    var quote interface{} = this.SafeString(market, "quote")
    var last interface{} = this.SafeString(ticker, "a")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "h"),
        "low": this.SafeNumber(ticker, "l"),
        "bid": this.SafeNumber(ticker, "b"),
        "bidVolume": nil,
        "ask": this.SafeNumber(ticker, "k"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "c"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": Ternary(IsTrue((IsEqual(quote, "USD"))), this.SafeString(ticker, "vv"), nil),
        "info": ticker,
    }, market)
}
func  (this *cryptocom) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //     {
    //         "s": "sell",
    //         "p": "26386.00",
    //         "q": "0.00453",
    //         "tn": 1686944282062,
    //         "tn": 1704476468851524373,
    //         "d": "4611686018455979970",
    //         "i": "BTC_USD"
    //     }
    //
    // fetchMyTrades
    //
    //     {
    //         "account_id": "ds075abc-1234-4321-bd6g-ff9007252r63",
    //         "event_date": "2023-06-16",
    //         "journal_type": "TRADING",
    //         "side": "BUY",
    //         "instrument_name": "BTC_USD",
    //         "fees": "-0.0000000525",
    //         "trade_id": "6142909898247428343",
    //         "trade_match_id": "4611686018455978480",
    //         "create_time": 1686941992887,
    //         "traded_price": "26347.16",
    //         "traded_quantity": "0.00021",
    //         "fee_instrument_name": "BTC",
    //         "client_oid": "d1c70a60-1234-4c92-b2a0-72b931cb31e0",
    //         "taker_side": "TAKER",
    //         "order_id": "6142909895036331486",
    //         "create_time_ns": "1686941992887207066"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "t", "create_time")
    var marketId interface{} = this.SafeString2(trade, "i", "instrument_name")
    market = this.SafeMarket(marketId, market, "_")
    var feeCurrency interface{} = this.SafeString(trade, "fee_instrument_name")
    var feeCostString interface{} = this.SafeString(trade, "fees")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString2(trade, "d", "trade_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": this.SafeString(trade, "order_id"),
        "side": this.SafeStringLower2(trade, "s", "side"),
        "takerOrMaker": this.SafeStringLower(trade, "taker_side"),
        "price": this.SafeNumber2(trade, "p", "traded_price"),
        "amount": this.SafeNumber2(trade, "q", "traded_quantity"),
        "cost": nil,
        "type": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrency),
            "cost": this.ParseNumber(Precise.StringNeg(feeCostString)),
        },
    }, market)
}
func  (this *cryptocom) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "o": "26949.89",
    //         "h": "26957.64",
    //         "l": "26948.24",
    //         "c": "26950.00",
    //         "v": "0.0670",
    //         "t": 1687237080000
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
func  (this *cryptocom) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ACTIVE": "open",
        "CANCELED": "canceled",
        "FILLED": "closed",
        "REJECTED": "rejected",
        "EXPIRED": "expired",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *cryptocom) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "GOOD_TILL_CANCEL": "GTC",
        "IMMEDIATE_OR_CANCEL": "IOC",
        "FILL_OR_KILL": "FOK",
    }
    return this.SafeString(timeInForces, timeInForce, timeInForce)
}
func  (this *cryptocom) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, cancelOrder
    //
    //     {
    //         "order_id": "6540219377766741832",
    //         "client_oid": "CCXT_d6ef7c3db6c1495aa8b757"
    //     }
    //
    // fetchOpenOrders, fetchOrder, fetchOrders
    //
    //     {
    //         "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
    //         "order_id": "6530219477767564494",
    //         "client_oid": "CCXT_7ce730f0388441df9bc218",
    //         "order_type": "LIMIT",
    //         "time_in_force": "GOOD_TILL_CANCEL",
    //         "side": "BUY",
    //         "exec_inst": [ ],
    //         "quantity": "0.00020",
    //         "limit_price": "20000.00",
    //         "order_value": "4",
    //         "avg_price": "0",
    //         "trigger_price": "0",
    //         "ref_price": "0",
    //         "cumulative_quantity": "0",
    //         "cumulative_value": "0",
    //         "cumulative_fee": "0",
    //         "status": "ACTIVE",
    //         "update_user_id": "ce075bef-1234-4321-bd6g-gg9007252e63",
    //         "order_date": "2023-06-15",
    //         "instrument_name": "BTC_USD",
    //         "fee_instrument_name": "BTC",
    //         "create_time": 1686806053992,
    //         "create_time_ns": "1686806053992921880",
    //         "update_time": 1686806053993
    //     }
    //
    // createOrders
    //     {
    //             "code" : 306,
    //             "index" : 1,
    //             "client_oid" : "1698068111133_1",
    //             "message" : "INSUFFICIENT_AVAILABLE_BALANCE",
    //             "order_id" : "6142909896519488207"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var code interface{} = this.SafeInteger(order, "code")
    if IsTrue(IsTrue((!IsEqual(code, nil))) && IsTrue((!IsEqual(code, 0)))) {
        return this.SafeOrder(map[string]interface{} {
            "id": this.SafeString(order, "order_id"),
            "clientOrderId": this.SafeString(order, "client_oid"),
            "info": order,
            "status": "rejected",
        })
    }
    var created interface{} = this.SafeInteger(order, "create_time")
    var marketId interface{} = this.SafeString(order, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var execInst interface{} = this.SafeValue(order, "exec_inst")
    var postOnly interface{} = nil
    if IsTrue(!IsEqual(execInst, nil)) {
        postOnly = false
        for i := 0; IsLessThan(i, GetArrayLength(execInst)); i++ {
            var inst interface{} = GetValue(execInst, i)
            if IsTrue(IsEqual(inst, "POST_ONLY")) {
                postOnly = true
                break
            }
        }
    }
    var feeCurrency interface{} = this.SafeString(order, "fee_instrument_name")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(order, "client_oid"),
        "timestamp": created,
        "datetime": this.Iso8601(created),
        "lastTradeTimestamp": this.SafeInteger(order, "update_time"),
        "status": this.ParseOrderStatus(this.SafeString(order, "status")),
        "symbol": symbol,
        "type": this.SafeStringLower(order, "order_type"),
        "timeInForce": this.ParseTimeInForce(this.SafeString(order, "time_in_force")),
        "postOnly": postOnly,
        "side": this.SafeStringLower(order, "side"),
        "price": this.SafeNumber(order, "limit_price"),
        "amount": this.SafeNumber(order, "quantity"),
        "filled": this.SafeNumber(order, "cumulative_quantity"),
        "remaining": nil,
        "average": this.SafeNumber(order, "avg_price"),
        "cost": this.SafeNumber(order, "cumulative_value"),
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrency),
            "cost": this.SafeNumber(order, "cumulative_fee"),
        },
        "trades": []interface{}{},
    }, market)
}
func  (this *cryptocom) ParseDepositStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "pending",
        "1": "ok",
        "2": "failed",
        "3": "pending",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *cryptocom) ParseWithdrawalStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "pending",
        "1": "pending",
        "2": "failed",
        "3": "pending",
        "4": "failed",
        "5": "ok",
        "6": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *cryptocom) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "currency": "BTC",
    //         "fee": 0,
    //         "create_time": 1688023659000,
    //         "id": "6201135",
    //         "update_time": 1688178509000,
    //         "amount": 0.00114571,
    //         "address": "1234fggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
    //         "status": "1",
    //         "txid": "f0ae4202b76eb999c301eccdde44dc639bee42d1fdd5974105286ca3393f6065/2"
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "currency": "BTC",
    //         "client_wid": "",
    //         "fee": 0.0005,
    //         "create_time": 1688613850000,
    //         "id": "5775977",
    //         "update_time": 1688613850000,
    //         "amount": 0.0005,
    //         "address": "1234NMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn",
    //         "status": "1",
    //         "txid": "",
    //         "network_id": "BTC"
    //     }
    //
    // withdraw
    //
    //     {
    //         "id": 2220,
    //         "amount": 1,
    //         "fee": 0.0004,
    //         "symbol": "BTC",
    //         "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
    //         "client_wid": "my_withdrawal_002",
    //         "create_time":1607063412000
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var typeVar interface{} = nil
    var rawStatus interface{} = this.SafeString(transaction, "status")
    var status interface{} = nil
    if IsTrue(InOp(transaction, "client_wid")) {
        typeVar = "withdrawal"
        status = this.ParseWithdrawalStatus(rawStatus)
    } else {
        typeVar = "deposit"
        status = this.ParseDepositStatus(rawStatus)
    }
    var addressString interface{} = this.SafeString(transaction, "address")
    addresstagVariable := this.ParseAddress(addressString);
    address := GetValue(addresstagVariable,0);
    tag := GetValue(addresstagVariable,1)
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(transaction, "create_time")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "txid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "tagFrom": nil,
        "type": typeVar,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": status,
        "updated": this.SafeInteger(transaction, "update_time"),
        "internal": nil,
        "comment": this.SafeString(transaction, "client_wid"),
        "fee": fee,
    }
}
func  (this *cryptocom) CustomHandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {Array} the marginMode in lowercase
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var isMargin interface{} = this.SafeBool(params, "margin", false)
    params = this.Omit(params, "margin")
    var marginMode interface{} = nil
    marginModeparamsVariable := this.HandleMarginModeAndParams(methodName, params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(!IsEqual(marginMode, nil)) {
        if IsTrue(!IsEqual(marginMode, "cross")) {
            panic(NotSupported(Add(this.Id, " only cross margin is supported")))
        }
    } else {
        if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
            marginMode = "cross"
        }
    }
    return []interface{}{marginMode, params}
}
func  (this *cryptocom) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "full_name": "Alchemix",
    //        "default_network": "ETH",
    //        "network_list": [
    //          {
    //            "network_id": "ETH",
    //            "withdrawal_fee": "0.25000000",
    //            "withdraw_enabled": true,
    //            "min_withdrawal_amount": "0.5",
    //            "deposit_enabled": true,
    //            "confirmation_required": "0"
    //          }
    //        ]
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkList interface{} = this.SafeList(fee, "network_list", []interface{}{})
    var networkListLength interface{} =     GetArrayLength(networkList)
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    if IsTrue(!IsEqual(networkList, nil)) {
        for i := 0; IsLessThan(i, networkListLength); i++ {
            var networkInfo interface{} = GetValue(networkList, i)
            var networkId interface{} = this.SafeString(networkInfo, "network_id")
            var currencyCode interface{} = this.SafeString(currency, "code")
            var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
            AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(networkInfo, "withdrawal_fee"),
        "percentage": false,
    },
})
            if IsTrue(IsEqual(networkListLength, 1)) {
                AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(networkInfo, "withdrawal_fee"))
                AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
            }
        }
    }
    return result
}
/**
 * @method
 * @name cryptocom#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-currency-networks
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *cryptocom) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24828 := (<-this.LoadMarkets())
            PanicOnError(retRes24828)
        
            response:= (<-this.V1PrivatePostPrivateGetCurrencyNetworks(params))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "result")
            var currencyMap interface{} = this.SafeList(data, "currency_map")
        
            ch <- this.ParseDepositWithdrawFees(currencyMap, codes, "full_name")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-transactions
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *cryptocom) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes25028 := (<-this.LoadMarkets())
            PanicOnError(retRes25028)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.SafeCurrency(code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_time", until)
            }
        
            response:= (<-this.V1PrivatePostPrivateGetTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1686813195698,
            //         "method": "private/get-transactions",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ce075cef-1234-4321-bd6e-gf9007351e64",
            //                     "event_date": "2023-06-15",
            //                     "journal_type": "TRADING",
            //                     "journal_id": "6530219460124075091",
            //                     "transaction_qty": "6.0091224",
            //                     "transaction_cost": "6.0091224",
            //                     "realized_pnl": "0",
            //                     "order_id": "6530219477766741833",
            //                     "trade_id": "6530219495775954765",
            //                     "trade_match_id": "4611686018455865176",
            //                     "event_timestamp_ms": 1686804665013,
            //                     "event_timestamp_ns": "1686804665013642422",
            //                     "client_oid": "CCXT_d6ea7c5db6c1495aa8b758",
            //                     "taker_side": "",
            //                     "side": "BUY",
            //                     "instrument_name": "USD"
            //                 },
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var ledger interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseLedger(ledger, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "account_id": "ce075cef-1234-4321-bd6e-gf9007351e64",
    //         "event_date": "2023-06-15",
    //         "journal_type": "TRADING",
    //         "journal_id": "6530219460124075091",
    //         "transaction_qty": "6.0091224",
    //         "transaction_cost": "6.0091224",
    //         "realized_pnl": "0",
    //         "order_id": "6530219477766741833",
    //         "trade_id": "6530219495775954765",
    //         "trade_match_id": "4611686018455865176",
    //         "event_timestamp_ms": 1686804665013,
    //         "event_timestamp_ns": "1686804665013642422",
    //         "client_oid": "CCXT_d6ea7c5db6c1495aa8b758",
    //         "taker_side": "",
    //         "side": "BUY",
    //         "instrument_name": "USD"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(item, "event_timestamp_ms")
    var currencyId interface{} = this.SafeString(item, "instrument_name")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var amount interface{} = this.SafeString(item, "transaction_qty")
    var direction interface{} = nil
    if IsTrue(Precise.StringLt(amount, "0")) {
        direction = "out"
        amount = Precise.StringAbs(amount)
    } else {
        direction = "in"
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "order_id"),
        "direction": direction,
        "account": this.SafeString(item, "account_id"),
        "referenceId": this.SafeString(item, "trade_id"),
        "referenceAccount": this.SafeString(item, "trade_match_id"),
        "type": this.ParseLedgerEntryType(this.SafeString(item, "journal_type")),
        "currency": code,
        "amount": this.ParseNumber(amount),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": nil,
        "status": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
        },
    }, currency)
}
func  (this *cryptocom) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var ledgerType interface{} = map[string]interface{} {
        "TRADING": "trade",
        "TRADE_FEE": "fee",
        "WITHDRAW_FEE": "fee",
        "WITHDRAW": "withdrawal",
        "DEPOSIT": "deposit",
        "ROLLBACK_WITHDRAW": "rollback",
        "ROLLBACK_DEPOSIT": "rollback",
        "FUNDING": "fee",
        "REALIZED_PNL": "trade",
        "INSURANCE_FUND": "insurance",
        "SOCIALIZED_LOSS": "trade",
        "LIQUIDATION_FEE": "fee",
        "SESSION_RESET": "reset",
        "ADJUSTMENT": "adjustment",
        "SESSION_SETTLE": "settlement",
        "UNCOVERED_LOSS": "trade",
        "ADMIN_ADJUSTMENT": "adjustment",
        "DELIST": "delist",
        "SETTLEMENT_FEE": "fee",
        "AUTO_CONVERSION": "conversion",
        "MANUAL_CONVERSION": "conversion",
    }
    return this.SafeString(ledgerType, typeVar, typeVar)
}
/**
 * @method
 * @name cryptocom#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *cryptocom) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26458 := (<-this.LoadMarkets())
            PanicOnError(retRes26458)
        
            response:= (<-this.V1PrivatePostPrivateGetAccounts(params))
            PanicOnError(response)
            //
            //     {
            //         "id": 1234567894321,
            //         "method": "private/get-accounts",
            //         "code": 0,
            //         "result": {
            //             "master_account": {
            //                 "uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
            //                 "user_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
            //                 "enabled": true,
            //                 "tradable": true,
            //                 "name": "YOUR_NAME",
            //                 "country_code": "CAN",
            //                 "phone_country_code": "CAN",
            //                 "incorp_country_code": "",
            //                 "margin_access": "DEFAULT",
            //                 "derivatives_access": "DEFAULT",
            //                 "create_time": 1656445188000,
            //                 "update_time": 1660794567262,
            //                 "two_fa_enabled": true,
            //                 "kyc_level": "ADVANCED",
            //                 "suspended": false,
            //                 "terminated": false,
            //                 "spot_enabled": false,
            //                 "margin_enabled": false,
            //                 "derivatives_enabled": false
            //             },
            //             "sub_account_list": []
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var masterAccount interface{} = this.SafeDict(result, "master_account", map[string]interface{} {})
            var accounts interface{} = this.SafeList(result, "sub_account_list", []interface{}{})
            AppendToArray(&accounts,masterAccount)
        
            ch <- this.ParseAccounts(accounts, params)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseAccount(account interface{}) interface{}  {
    //
    //     {
    //         "uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
    //         "user_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
    //         "master_account_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
    //         "label": "FORMER_MASTER_MARGIN",
    //         "enabled": true,
    //         "tradable": true,
    //         "name": "YOUR_NAME",
    //         "country_code": "YOUR_COUNTRY_CODE",
    //         "incorp_country_code": "",
    //         "margin_access": "DEFAULT",
    //         "derivatives_access": "DEFAULT",
    //         "create_time": 1656481992000,
    //         "update_time": 1667272884594,
    //         "two_fa_enabled": false,
    //         "kyc_level": "ADVANCED",
    //         "suspended": false,
    //         "terminated": false,
    //         "spot_enabled": false,
    //         "margin_enabled": false,
    //         "derivatives_enabled": false,
    //         "system_label": "FORMER_MASTER_MARGIN"
    //     }
    //
    return map[string]interface{} {
        "id": this.SafeString(account, "uuid"),
        "type": this.SafeString(account, "label"),
        "code": nil,
        "info": account,
    }
}
/**
 * @method
 * @name cryptocom#fetchSettlementHistory
 * @description fetches historical settlement records
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-expired-settlement-price
 * @param {string} symbol unified market symbol of the settlement history
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @param {int} [params.type] 'future', 'option'
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
 */
func  (this *cryptocom) FetchSettlementHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27328 := (<-this.LoadMarkets())
            PanicOnError(retRes27328)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchSettlementHistory", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            this.CheckRequiredArgument("fetchSettlementHistory", typeVar, "type", []interface{}{"future", "option", "WARRANT", "FUTURE"})
            if IsTrue(IsEqual(typeVar, "option")) {
                typeVar = "WARRANT"
            }
            var request interface{} = map[string]interface{} {
                "instrument_type": ToUpper(typeVar),
            }
        
            response:= (<-this.V1PublicGetPublicGetExpiredSettlementPrice(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-expired-settlement-price",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "i": "BTCUSD-230526",
            //                     "x": 1685088000000,
            //                     "v": "26464.1",
            //                     "t": 1685087999500
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
            var settlements interface{} = this.ParseSettlements(data, market)
            var sorted interface{} = this.SortBy(settlements, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseSettlement(settlement interface{}, market interface{}) interface{}  {
    //
    //     {
    //         "i": "BTCUSD-230526",
    //         "x": 1685088000000,
    //         "v": "26464.1",
    //         "t": 1685087999500
    //     }
    //
    var timestamp interface{} = this.SafeInteger(settlement, "x")
    var marketId interface{} = this.SafeString(settlement, "i")
    return map[string]interface{} {
        "info": settlement,
        "symbol": this.SafeSymbol(marketId, market),
        "price": this.SafeNumber(settlement, "v"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
func  (this *cryptocom) ParseSettlements(settlements interface{}, market interface{}) interface{}  {
    //
    //     [
    //         {
    //             "i": "BTCUSD-230526",
    //             "x": 1685088000000,
    //             "v": "26464.1",
    //             "t": 1685087999500
    //         }
    //     ]
    //
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(settlements)); i++ {
        AppendToArray(&result,this.ParseSettlement(GetValue(settlements, i), market))
    }
    return result
}
/**
 * @method
 * @name cryptocom#fetchFundingRateHistory
 * @description fetches historical funding rates
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-valuations
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures] to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *cryptocom) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes28268 := (<-this.LoadMarkets())
            PanicOnError(retRes28268)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes283019 :=  (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params))
                    PanicOnError(retRes283019)
                    ch <- retRes283019
                    return nil
            }
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRateHistory() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "valuation_type": "funding_hist",
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_ts", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_ts", until)
            }
        
            response:= (<-this.V1PublicGetPublicGetValuations(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": -1,
            //         "method": "public/get-valuations",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "v": "-0.000001884",
            //                     "t": 1687892400000
            //                 },
            //             ],
            //             "instrument_name": "BTCUSD-PERP"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
            var marketId interface{} = this.SafeString(result, "instrument_name")
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var timestamp interface{} = this.SafeInteger(entry, "t")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(marketId, market),
                    "fundingRate": this.SafeNumber(entry, "v"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-positions
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *cryptocom) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28978 := (<-this.LoadMarkets())
            PanicOnError(retRes28978)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PrivatePostPrivateGetPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1688015952050,
            //         "method": "private/get-positions",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
            //                     "quantity": "0.0001",
            //                     "cost": "3.02392",
            //                     "open_pos_cost": "3.02392",
            //                     "open_position_pnl": "-0.0010281328",
            //                     "session_pnl": "-0.0010281328",
            //                     "update_timestamp_ms": 1688015919091,
            //                     "instrument_name": "BTCUSD-PERP",
            //                     "type": "PERPETUAL_SWAP"
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParsePosition(this.SafeDict(data, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchPositions
 * @description fetch all open positions
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *cryptocom) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29408 := (<-this.LoadMarkets())
            PanicOnError(retRes29408)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = nil
                if IsTrue(IsArray(symbols)) {
                    var symbolsLength interface{} =             GetArrayLength(symbols)
                    if IsTrue(IsGreaterThan(symbolsLength, 1)) {
                        panic(BadRequest(Add(this.Id, " fetchPositions() symbols argument cannot contain more than 1 symbol")))
                    }
                    symbol = GetValue(symbols, 0)
                } else {
                    symbol = symbols
                }
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
        
            response:= (<-this.V1PrivatePostPrivateGetPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "id": 1688015952050,
            //         "method": "private/get-positions",
            //         "code": 0,
            //         "result": {
            //             "data": [
            //                 {
            //                     "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
            //                     "quantity": "0.0001",
            //                     "cost": "3.02392",
            //                     "open_pos_cost": "3.02392",
            //                     "open_position_pnl": "-0.0010281328",
            //                     "session_pnl": "-0.0010281328",
            //                     "update_timestamp_ms": 1688015919091,
            //                     "instrument_name": "BTCUSD-PERP",
            //                     "type": "PERPETUAL_SWAP"
            //                 }
            //             ]
            //         }
            //     }
            //
            var responseResult interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var positions interface{} = this.SafeList(responseResult, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                var entry interface{} = GetValue(positions, i)
                var marketId interface{} = this.SafeString(entry, "instrument_name")
                var marketInner interface{} = this.SafeMarket(marketId, nil, nil, "contract")
                AppendToArray(&result,this.ParsePosition(entry, marketInner))
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", nil, false)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
    //         "quantity": "0.0001",
    //         "cost": "3.02392",
    //         "open_pos_cost": "3.02392",
    //         "open_position_pnl": "-0.0010281328",
    //         "session_pnl": "-0.0010281328",
    //         "update_timestamp_ms": 1688015919091,
    //         "instrument_name": "BTCUSD-PERP",
    //         "type": "PERPETUAL_SWAP"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "instrument_name")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "contract")
    var timestamp interface{} = this.SafeInteger(position, "update_timestamp_ms")
    var amount interface{} = this.SafeString(position, "quantity")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "hedged": nil,
        "side": Ternary(IsTrue(Precise.StringGt(amount, "0")), "buy", "sell"),
        "contracts": Precise.StringAbs(amount),
        "contractSize": GetValue(market, "contractSize"),
        "entryPrice": nil,
        "markPrice": nil,
        "notional": nil,
        "leverage": nil,
        "collateral": this.SafeNumber(position, "open_pos_cost"),
        "initialMargin": this.SafeNumber(position, "cost"),
        "maintenanceMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMarginPercentage": nil,
        "unrealizedPnl": this.SafeNumber(position, "open_position_pnl"),
        "liquidationPrice": nil,
        "marginMode": nil,
        "percentage": nil,
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
func  (this *cryptocom) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *cryptocom) ParamsToString(object interface{}, level interface{}) interface{}  {
    var maxLevel interface{} = 3
    if IsTrue(IsGreaterThanOrEqual(level, maxLevel)) {
        return ToString(object)
    }
    if IsTrue(IsString(object)) {
        return object
    }
    var returnString interface{} = ""
    var paramsKeys interface{} = nil
    if IsTrue(IsArray(object)) {
        paramsKeys = object
    } else {
        var sorted interface{} = this.Keysort(object)
        paramsKeys = ObjectKeys(sorted)
    }
    for i := 0; IsLessThan(i, GetArrayLength(paramsKeys)); i++ {
        var key interface{} = GetValue(paramsKeys, i)
        returnString = Add(returnString, key)
        var value interface{} = GetValue(object, key)
        if IsTrue(IsEqual(value, "undefined")) {
            returnString = Add(returnString, "null")
        } else if IsTrue(IsArray(value)) {
            for j := 0; IsLessThan(j, GetArrayLength(value)); j++ {
                returnString = Add(returnString, this.ParamsToString(GetValue(value, j), Add(level, 1)))
            }
        } else {
            returnString = Add(returnString, ToString(value))
        }
    }
    return returnString
}
/**
 * @method
 * @name cryptocom#closePositions
 * @description closes open positions for a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-close-position
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} [side] not used by cryptocom.closePositions
 * @param {object} [params] extra parameters specific to the okx api endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.type] LIMIT or MARKET
 * @param {number} [params.price] for limit orders only
 * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *cryptocom) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    side := GetArg(optionalArgs, 0, nil)
            _ = side
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30938 := (<-this.LoadMarkets())
            PanicOnError(retRes30938)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "type": "MARKET",
            }
            var typeVar interface{} = this.SafeStringUpper(params, "type")
            var price interface{} = this.SafeString(params, "price")
            if IsTrue(!IsEqual(typeVar, nil)) {
                AddElementToObject(request, "type", typeVar)
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(GetValue(market, "symbol"), price))
            }
        
            response:= (<-this.V1PrivatePostPrivateClosePosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "id" : 1700830813298,
            //        "method" : "private/close-position",
            //        "code" : 0,
            //        "result" : {
            //            "client_oid" : "179a909d-5614-655b-0d0e-9e85c9a25c85",
            //            "order_id" : "6142909897021751347"
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-instrument-fee-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *cryptocom) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes31338 := (<-this.LoadMarkets())
            PanicOnError(retRes31338)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PrivatePostPrivateGetInstrumentFeeRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "id": 1,
            //        "code": 0,
            //        "method": "private/staking/unstake",
            //        "result": {
            //          "staking_id": "1",
            //          "instrument_name": "SOL.staked",
            //          "status": "NEW",
            //          "quantity": "1",
            //          "underlying_inst_name": "SOL",
            //          "reason": "NO_ERROR"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTradingFee(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#fetchTradingFees
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-fee-rate
 * @description fetch the trading fees for multiple markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *cryptocom) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes31678 := (<-this.LoadMarkets())
            PanicOnError(retRes31678)
        
            response:= (<-this.V1PrivatePostPrivateGetFeeRate(params))
            PanicOnError(response)
            //
            //   {
            //       "id": 1,
            //       "method": "/private/get-fee-rate",
            //       "code": 0,
            //       "result": {
            //         "spot_tier": "3",
            //         "deriv_tier": "3",
            //         "effective_spot_maker_rate_bps": "6.5",
            //         "effective_spot_taker_rate_bps": "6.9",
            //         "effective_deriv_maker_rate_bps": "1.1",
            //         "effective_deriv_taker_rate_bps": "3"
            //       }
            //   }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTradingFees(result)
            return nil
        
            }()
            return ch
        }
func  (this *cryptocom) ParseTradingFees(response interface{}) interface{}  {
    //
    // {
    //         "spot_tier": "3",
    //         "deriv_tier": "3",
    //         "effective_spot_maker_rate_bps": "6.5",
    //         "effective_spot_taker_rate_bps": "6.9",
    //         "effective_deriv_maker_rate_bps": "1.1",
    //         "effective_deriv_taker_rate_bps": "3"
    //  }
    //
    var result interface{} = map[string]interface{} {}
    AddElementToObject(result, "info", response)
    for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
        var symbol interface{} = GetValue(this.Symbols, i)
        var market interface{} = this.Market(symbol)
        var isSwap interface{} = GetValue(market, "swap")
        var takerFeeKey interface{} = Ternary(IsTrue(isSwap), "effective_deriv_taker_rate_bps", "effective_spot_taker_rate_bps")
        var makerFeeKey interface{} = Ternary(IsTrue(isSwap), "effective_deriv_maker_rate_bps", "effective_spot_maker_rate_bps")
        var tradingFee interface{} = map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(Precise.StringDiv(this.SafeString(response, makerFeeKey), "10000")),
            "taker": this.ParseNumber(Precise.StringDiv(this.SafeString(response, takerFeeKey), "10000")),
            "percentage": nil,
            "tierBased": nil,
        }
        AddElementToObject(result, symbol, tradingFee)
    }
    return result
}
func  (this *cryptocom) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //      "instrument_name": "BTC_USD",
    //      "effective_maker_rate_bps": "6.5",
    //      "effective_taker_rate_bps": "6.9"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "effective_maker_rate_bps"), "10000")),
        "taker": this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "effective_taker_rate_bps"), "10000")),
        "percentage": nil,
        "tierBased": nil,
    }
}
func  (this *cryptocom) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var typeVar interface{} = this.SafeString(api, 0)
    var access interface{} = this.SafeString(api, 1)
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), typeVar), "/"), path)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(access, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var requestParams interface{} = this.Extend(map[string]interface{} {}, params)
        var paramsKeys interface{} = ObjectKeys(requestParams)
        var strSortKey interface{} = this.ParamsToString(requestParams, 0)
        var payload interface{} = Add(Add(Add(Add(path, nonce), this.ApiKey), strSortKey), nonce)
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256)
        var paramsKeysLength interface{} =         GetArrayLength(paramsKeys)
        body = this.Json(map[string]interface{} {
            "id": nonce,
            "method": path,
            "params": params,
            "api_key": this.ApiKey,
            "sig": signature,
            "nonce": nonce,
        })
        // fix issue https://github.com/ccxt/ccxt/issues/11179
        // php always encodes dictionaries as arrays
        // if an array is empty, php will put it in square brackets
        // python and js will put it in curly brackets
        // the code below checks and replaces those brackets in empty requests
        if IsTrue(IsEqual(paramsKeysLength, 0)) {
            var paramsString interface{} = "{}"
            var arrayString interface{} = "[]"
            body = Replace(body, arrayString, paramsString)
        }
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *cryptocom) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    var errorCode interface{} = this.SafeString(response, "code")
    if IsTrue(!IsEqual(errorCode, "0")) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        panic(ExchangeError(Add(Add(this.Id, " "), body)))
    }
    return nil
}


func (this *cryptocom) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
