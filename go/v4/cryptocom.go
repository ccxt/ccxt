package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CryptocomCore struct {
	Exchange
}

func NewCryptocomCore() *CryptocomCore {
	p := &CryptocomCore{}
	setDefaults(p)
	return p
}

func (this *CryptocomCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "cryptocom",
		"name":      "Crypto.com",
		"countries": []interface{}{"MT"},
		"version":   "v2",
		"rateLimit": 10,
		"certified": true,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                           false,
			"spot":                           true,
			"margin":                         true,
			"swap":                           true,
			"future":                         true,
			"option":                         true,
			"addMargin":                      false,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"cancelOrders":                   true,
			"cancelOrdersForSymbols":         true,
			"closeAllPositions":              false,
			"closePosition":                  true,
			"createMarketBuyOrderWithCost":   false,
			"createMarketOrderWithCost":      false,
			"createMarketSellOrderWithCost":  false,
			"createOrder":                    true,
			"createOrders":                   true,
			"createStopOrder":                true,
			"createTriggerOrder":             true,
			"editOrder":                      true,
			"fetchAccounts":                  true,
			"fetchBalance":                   true,
			"fetchBidsAsks":                  false,
			"fetchBorrowInterest":            false,
			"fetchBorrowRateHistories":       false,
			"fetchBorrowRateHistory":         false,
			"fetchClosedOrders":              "emulated",
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          false,
			"fetchDepositAddressesByNetwork": true,
			"fetchDeposits":                  true,
			"fetchDepositsWithdrawals":       false,
			"fetchDepositWithdrawFee":        "emulated",
			"fetchDepositWithdrawFees":       true,
			"fetchFundingHistory":            false,
			"fetchFundingRate":               true,
			"fetchFundingRateHistory":        true,
			"fetchFundingRates":              false,
			"fetchGreeks":                    false,
			"fetchIndexOHLCV":                false,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchLedger":                    true,
			"fetchLeverage":                  false,
			"fetchLeverageTiers":             false,
			"fetchMarginAdjustmentHistory":   false,
			"fetchMarginMode":                false,
			"fetchMarketLeverageTiers":       false,
			"fetchMarkets":                   true,
			"fetchMarkOHLCV":                 false,
			"fetchMySettlementHistory":       false,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenOrders":                true,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrders":                    true,
			"fetchPosition":                  true,
			"fetchPositionHistory":           false,
			"fetchPositionMode":              false,
			"fetchPositions":                 true,
			"fetchPositionsHistory":          false,
			"fetchPremiumIndexOHLCV":         false,
			"fetchSettlementHistory":         true,
			"fetchStatus":                    false,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      false,
			"fetchTrades":                    true,
			"fetchTradingFee":                true,
			"fetchTradingFees":               true,
			"fetchTransactionFees":           false,
			"fetchTransactions":              false,
			"fetchTransfers":                 false,
			"fetchUnderlyingAssets":          false,
			"fetchVolatilityHistory":         false,
			"fetchWithdrawals":               true,
			"reduceMargin":                   false,
			"repayCrossMargin":               false,
			"repayIsolatedMargin":            false,
			"sandbox":                        true,
			"setLeverage":                    false,
			"setMarginMode":                  false,
			"setPositionMode":                false,
			"transfer":                       false,
			"withdraw":                       true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"4h":  "4h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1D",
			"1w":  "7D",
			"2w":  "14D",
			"1M":  "1M",
		},
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",
			"test": map[string]interface{}{
				"v1":          "https://uat-api.3ona.co/exchange/v1",
				"v2":          "https://uat-api.3ona.co/v2",
				"derivatives": "https://uat-api.3ona.co/v2",
			},
			"api": map[string]interface{}{
				"base":        "https://api.crypto.com",
				"v1":          "https://api.crypto.com/exchange/v1",
				"v2":          "https://api.crypto.com/v2",
				"derivatives": "https://deriv-api.crypto.com/v1",
			},
			"www": "https://crypto.com/",
			"referral": map[string]interface{}{
				"url":      "https://crypto.com/exch/kdacthrnxt",
				"discount": 0.75,
			},
			"doc":  []interface{}{"https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html", "https://exchange-docs.crypto.com/spot/index.html", "https://exchange-docs.crypto.com/derivatives/index.html"},
			"fees": "https://crypto.com/exchange/document/fees-limits",
		},
		"api": map[string]interface{}{
			"base": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"v1/public/get-announcements": 1,
					},
				},
			},
			"v1": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"public/auth":                         Divide(10, 3),
						"public/get-instruments":              Divide(10, 3),
						"public/get-book":                     1,
						"public/get-candlestick":              1,
						"public/get-trades":                   1,
						"public/get-tickers":                  1,
						"public/get-valuations":               1,
						"public/get-expired-settlement-price": Divide(10, 3),
						"public/get-insurance":                1,
						"public/get-announcements":            1,
						"public/get-risk-parameters":          1,
					},
					"post": map[string]interface{}{
						"public/staking/get-conversion-rate": 2,
					},
				},
				"private": map[string]interface{}{
					"post": map[string]interface{}{
						"private/set-cancel-on-disconnect":        Divide(10, 3),
						"private/get-cancel-on-disconnect":        Divide(10, 3),
						"private/user-balance":                    Divide(10, 3),
						"private/user-balance-history":            Divide(10, 3),
						"private/get-positions":                   Divide(10, 3),
						"private/create-order":                    Divide(2, 3),
						"private/amend-order":                     Divide(4, 3),
						"private/create-order-list":               Divide(10, 3),
						"private/cancel-order":                    Divide(2, 3),
						"private/cancel-order-list":               Divide(10, 3),
						"private/cancel-all-orders":               Divide(2, 3),
						"private/close-position":                  Divide(10, 3),
						"private/get-order-history":               100,
						"private/get-open-orders":                 Divide(10, 3),
						"private/get-order-detail":                Divide(1, 3),
						"private/get-trades":                      100,
						"private/change-account-leverage":         Divide(10, 3),
						"private/get-transactions":                Divide(10, 3),
						"private/create-subaccount-transfer":      Divide(10, 3),
						"private/get-subaccount-balances":         Divide(10, 3),
						"private/get-order-list":                  Divide(10, 3),
						"private/create-withdrawal":               Divide(10, 3),
						"private/get-currency-networks":           Divide(10, 3),
						"private/get-deposit-address":             Divide(10, 3),
						"private/get-accounts":                    Divide(10, 3),
						"private/get-withdrawal-history":          Divide(10, 3),
						"private/get-deposit-history":             Divide(10, 3),
						"private/get-fee-rate":                    2,
						"private/get-instrument-fee-rate":         2,
						"private/fiat/fiat-deposit-info":          Divide(10, 3),
						"private/fiat/fiat-deposit-history":       Divide(10, 3),
						"private/fiat/fiat-withdraw-history":      Divide(10, 3),
						"private/fiat/fiat-create-withdraw":       Divide(10, 3),
						"private/fiat/fiat-transaction-quota":     Divide(10, 3),
						"private/fiat/fiat-transaction-limit":     Divide(10, 3),
						"private/fiat/fiat-get-bank-accounts":     Divide(10, 3),
						"private/staking/stake":                   2,
						"private/staking/unstake":                 2,
						"private/staking/get-staking-position":    2,
						"private/staking/get-staking-instruments": 2,
						"private/staking/get-open-stake":          2,
						"private/staking/get-stake-history":       2,
						"private/staking/get-reward-history":      2,
						"private/staking/convert":                 2,
						"private/staking/get-open-convert":        2,
						"private/staking/get-convert-history":     2,
						"private/create-isolated-margin-transfer": Divide(10, 3),
						"private/change-isolated-margin-leverage": Divide(10, 3),
					},
				},
			},
			"v2": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"public/auth":                           1,
						"public/get-instruments":                1,
						"public/get-book":                       1,
						"public/get-candlestick":                1,
						"public/get-ticker":                     1,
						"public/get-trades":                     1,
						"public/margin/get-transfer-currencies": 1,
						"public/margin/get-load-currenices":     1,
						"public/respond-heartbeat":              1,
					},
				},
				"private": map[string]interface{}{
					"post": map[string]interface{}{
						"private/set-cancel-on-disconnect":      Divide(10, 3),
						"private/get-cancel-on-disconnect":      Divide(10, 3),
						"private/create-withdrawal":             Divide(10, 3),
						"private/get-withdrawal-history":        Divide(10, 3),
						"private/get-currency-networks":         Divide(10, 3),
						"private/get-deposit-history":           Divide(10, 3),
						"private/get-deposit-address":           Divide(10, 3),
						"private/export/create-export-request":  Divide(10, 3),
						"private/export/get-export-requests":    Divide(10, 3),
						"private/export/download-export-output": Divide(10, 3),
						"private/get-account-summary":           Divide(10, 3),
						"private/create-order":                  Divide(2, 3),
						"private/cancel-order":                  Divide(2, 3),
						"private/cancel-all-orders":             Divide(2, 3),
						"private/create-order-list":             Divide(10, 3),
						"private/get-order-history":             Divide(10, 3),
						"private/get-open-orders":               Divide(10, 3),
						"private/get-order-detail":              Divide(1, 3),
						"private/get-trades":                    100,
						"private/get-accounts":                  Divide(10, 3),
						"private/get-subaccount-balances":       Divide(10, 3),
						"private/create-subaccount-transfer":    Divide(10, 3),
						"private/otc/get-otc-user":              Divide(10, 3),
						"private/otc/get-instruments":           Divide(10, 3),
						"private/otc/request-quote":             100,
						"private/otc/accept-quote":              100,
						"private/otc/get-quote-history":         Divide(10, 3),
						"private/otc/get-trade-history":         Divide(10, 3),
						"private/otc/create-order":              Divide(10, 3),
					},
				},
			},
			"derivatives": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"public/auth":                         Divide(10, 3),
						"public/get-instruments":              Divide(10, 3),
						"public/get-book":                     1,
						"public/get-candlestick":              1,
						"public/get-trades":                   1,
						"public/get-tickers":                  1,
						"public/get-valuations":               1,
						"public/get-expired-settlement-price": Divide(10, 3),
						"public/get-insurance":                1,
					},
				},
				"private": map[string]interface{}{
					"post": map[string]interface{}{
						"private/set-cancel-on-disconnect":   Divide(10, 3),
						"private/get-cancel-on-disconnect":   Divide(10, 3),
						"private/user-balance":               Divide(10, 3),
						"private/user-balance-history":       Divide(10, 3),
						"private/get-positions":              Divide(10, 3),
						"private/create-order":               Divide(2, 3),
						"private/create-order-list":          Divide(10, 3),
						"private/cancel-order":               Divide(2, 3),
						"private/cancel-order-list":          Divide(10, 3),
						"private/cancel-all-orders":          Divide(2, 3),
						"private/close-position":             Divide(10, 3),
						"private/convert-collateral":         Divide(10, 3),
						"private/get-order-history":          100,
						"private/get-open-orders":            Divide(10, 3),
						"private/get-order-detail":           Divide(1, 3),
						"private/get-trades":                 100,
						"private/change-account-leverage":    Divide(10, 3),
						"private/get-transactions":           Divide(10, 3),
						"private/create-subaccount-transfer": Divide(10, 3),
						"private/get-subaccount-balances":    Divide(10, 3),
						"private/get-order-list":             Divide(10, 3),
					},
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"maker": this.ParseNumber("0.0025"),
				"taker": this.ParseNumber("0.005"),
				"tiers": map[string]interface{}{
					"maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.00065")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("25000000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("250000000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0")}},
					"taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.005")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("25000000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00035")}, []interface{}{this.ParseNumber("250000000"), this.ParseNumber("0.00031")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.00025")}},
				},
			},
		},
		"options": map[string]interface{}{
			"defaultType": "spot",
			"accountsById": map[string]interface{}{
				"funding":     "SPOT",
				"spot":        "SPOT",
				"margin":      "MARGIN",
				"derivatives": "DERIVATIVES",
				"swap":        "DERIVATIVES",
				"future":      "DERIVATIVES",
			},
			"networks": map[string]interface{}{
				"BEP20": "BSC",
				"ERC20": "ETH",
				"TRC20": "TRON",
			},
			"broker": "CCXT",
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":   true,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": true,
					},
					"triggerDirection":           false,
					"stopLossPrice":              true,
					"takeProfitPrice":            true,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"selfTradePrevention":    true,
					"trailing":               false,
					"iceberg":                false,
					"leverage":               false,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": true,
				},
				"createOrders": map[string]interface{}{
					"max": 10,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       nil,
					"untilDays":      1,
					"symbolRequired": false,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          100,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       nil,
					"untilDays":      1,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        1,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 300,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": map[string]interface{}{
					"extends": "default",
				},
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": map[string]interface{}{
					"extends": "default",
				},
			},
		},
		"commonCurrencies": map[string]interface{}{
			"USD_STABLE_COIN": "USDC",
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"219":     InvalidOrder,
				"306":     InsufficientFunds,
				"314":     InvalidOrder,
				"315":     InvalidOrder,
				"325":     InvalidOrder,
				"415":     InvalidOrder,
				"10001":   ExchangeError,
				"10002":   PermissionDenied,
				"10003":   PermissionDenied,
				"10004":   BadRequest,
				"10005":   PermissionDenied,
				"10006":   DDoSProtection,
				"10007":   InvalidNonce,
				"10008":   BadRequest,
				"10009":   BadRequest,
				"20001":   BadRequest,
				"20002":   InsufficientFunds,
				"20005":   AccountNotEnabled,
				"30003":   BadSymbol,
				"30004":   BadRequest,
				"30005":   BadRequest,
				"30006":   InvalidOrder,
				"30007":   InvalidOrder,
				"30008":   InvalidOrder,
				"30009":   InvalidOrder,
				"30010":   BadRequest,
				"30013":   InvalidOrder,
				"30014":   InvalidOrder,
				"30016":   InvalidOrder,
				"30017":   InvalidOrder,
				"30023":   InvalidOrder,
				"30024":   InvalidOrder,
				"30025":   InvalidOrder,
				"40001":   BadRequest,
				"40002":   BadRequest,
				"40003":   BadRequest,
				"40004":   BadRequest,
				"40005":   BadRequest,
				"40006":   BadRequest,
				"40007":   BadRequest,
				"40101":   AuthenticationError,
				"40102":   InvalidNonce,
				"40103":   AuthenticationError,
				"40104":   AuthenticationError,
				"40107":   BadRequest,
				"40401":   OrderNotFound,
				"40801":   RequestTimeout,
				"42901":   RateLimitExceeded,
				"43005":   InvalidOrder,
				"43003":   InvalidOrder,
				"43004":   InvalidOrder,
				"43012":   BadRequest,
				"50001":   ExchangeError,
				"9010001": OnMaintenance,
			},
			"broad": map[string]interface{}{},
		},
	})
}

/**
 * @method
 * @name cryptocom#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-currency-networks
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *CryptocomCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// this endpoint requires authentication
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if !IsTrue(this.CheckRequiredCredentials(false)) {

			ch <- map[string]interface{}{}
			return nil
		}
		var skipFetchCurrencies interface{} = false
		skipFetchCurrenciesparamsVariable := this.HandleOptionAndParams(params, "fetchCurrencies", "skipFetchCurrencies", false)
		skipFetchCurrencies = GetValue(skipFetchCurrenciesparamsVariable, 0)
		params = GetValue(skipFetchCurrenciesparamsVariable, 1)
		if IsTrue(skipFetchCurrencies) {

			// sub-accounts can't access this endpoint
			ch <- map[string]interface{}{}
			return nil
		}
		var response interface{} = map[string]interface{}{}

		{
			func(this *CryptocomCore) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *CryptocomCore) interface{} {
							// catch block:
							if IsTrue(IsInstance(e, ExchangeError)) {

								// sub-accounts can't access this endpoint
								// {"code":"10001","msg":"SYS_ERROR"}
								ch <- map[string]interface{}{}
								return nil
							}
							panic(e)

						}(this)
					}
				}()
				// try block:

				response = (<-this.V1PrivatePostPrivateGetCurrencyNetworks(params))
				PanicOnError(response)
				return nil
			}(this)

		}
		//
		//    {
		//        "id": "1747502328559",
		//        "method": "private/get-currency-networks",
		//        "code": "0",
		//        "result": {
		//            "update_time": "1747502281000",
		//            "currency_map": {
		//                "USDT": {
		//                    "full_name": "Tether USD",
		//                    "default_network": "ETH",
		//                    "network_list": [
		//                        {
		//                            "network_id": "ETH",
		//                            "withdrawal_fee": "10.00000000",
		//                            "withdraw_enabled": true,
		//                            "min_withdrawal_amount": "20.0",
		//                            "deposit_enabled": true,
		//                            "confirmation_required": "32"
		//                        },
		//                        {
		//                            "network_id": "CRONOS",
		//                            "withdrawal_fee": "0.18000000",
		//                            "withdraw_enabled": true,
		//                            "min_withdrawal_amount": "0.35",
		//                            "deposit_enabled": true,
		//                            "confirmation_required": "15"
		//                        },
		//                        {
		//                            "network_id": "SOL",
		//                            "withdrawal_fee": "5.31000000",
		//                            "withdraw_enabled": true,
		//                            "min_withdrawal_amount": "10.62",
		//                            "deposit_enabled": true,
		//                            "confirmation_required": "1"
		//                        }
		//                    ]
		//                }
		//            }
		//        }
		//    }
		//
		var resultData interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var currencyMap interface{} = this.SafeDict(resultData, "currency_map", map[string]interface{}{})
		var keys interface{} = ObjectKeys(currencyMap)
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
			var key interface{} = GetValue(keys, i)
			var currency interface{} = GetValue(currencyMap, key)
			var id interface{} = key
			var code interface{} = this.SafeCurrencyCode(id)
			var networks interface{} = map[string]interface{}{}
			var chains interface{} = this.SafeList(currency, "network_list", []interface{}{})
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString(chain, "network_id")
				var network interface{} = this.NetworkIdToCode(networkId)
				AddElementToObject(networks, network, map[string]interface{}{
					"info":      chain,
					"id":        networkId,
					"network":   network,
					"active":    nil,
					"deposit":   this.SafeBool(chain, "deposit_enabled", false),
					"withdraw":  this.SafeBool(chain, "withdraw_enabled", false),
					"fee":       this.SafeNumber(chain, "withdrawal_fee"),
					"precision": nil,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(chain, "min_withdrawal_amount"),
							"max": nil,
						},
					},
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      currency,
				"id":        id,
				"code":      code,
				"name":      this.SafeString(currency, "full_name"),
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"type":     "crypto",
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchMarkets
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-instruments
 * @description retrieves data on all markets for cryptocom
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *CryptocomCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V1PublicGetPublicGetInstruments(params))
		PanicOnError(response)
		//
		//     {
		//         "id": 1,
		//         "method": "public/get-instruments",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "symbol": "BTC_USDT",
		//                     "inst_type": "CCY_PAIR",
		//                     "display_name": "BTC/USDT",
		//                     "base_ccy": "BTC",
		//                     "quote_ccy": "USDT",
		//                     "quote_decimals": 2,
		//                     "quantity_decimals": 5,
		//                     "price_tick_size": "0.01",
		//                     "qty_tick_size": "0.00001",
		//                     "max_leverage": "50",
		//                     "tradable": true,
		//                     "expiry_timestamp_ms": 0,
		//                     "beta_product": false,
		//                     "margin_buy_enabled": false,
		//                     "margin_sell_enabled": true
		//                 },
		//                 {
		//                     "symbol": "RUNEUSD-PERP",
		//                     "inst_type": "PERPETUAL_SWAP",
		//                     "display_name": "RUNEUSD Perpetual",
		//                     "base_ccy": "RUNE",
		//                     "quote_ccy": "USD",
		//                     "quote_decimals": 3,
		//                     "quantity_decimals": 1,
		//                     "price_tick_size": "0.001",
		//                     "qty_tick_size": "0.1",
		//                     "max_leverage": "50",
		//                     "tradable": true,
		//                     "expiry_timestamp_ms": 0,
		//                     "beta_product": false,
		//                     "underlying_symbol": "RUNEUSD-INDEX",
		//                     "contract_size": "1",
		//                     "margin_buy_enabled": false,
		//                     "margin_sell_enabled": false
		//                 },
		//                 {
		//                     "symbol": "ETHUSD-230825",
		//                     "inst_type": "FUTURE",
		//                     "display_name": "ETHUSD Futures 20230825",
		//                     "base_ccy": "ETH",
		//                     "quote_ccy": "USD",
		//                     "quote_decimals": 2,
		//                     "quantity_decimals": 4,
		//                     "price_tick_size": "0.01",
		//                     "qty_tick_size": "0.0001",
		//                     "max_leverage": "100",
		//                     "tradable": true,
		//                     "expiry_timestamp_ms": 1692950400000,
		//                     "beta_product": false,
		//                     "underlying_symbol": "ETHUSD-INDEX",
		//                     "contract_size": "1",
		//                     "margin_buy_enabled": false,
		//                     "margin_sell_enabled": false
		//                 },
		//                 {
		//                     "symbol": "BTCUSD-230630-CW30000",
		//                     "inst_type": "WARRANT",
		//                     "display_name": "BTCUSD-230630-CW30000",
		//                     "base_ccy": "BTC",
		//                     "quote_ccy": "USD",
		//                     "quote_decimals": 3,
		//                     "quantity_decimals": 0,
		//                     "price_tick_size": "0.001",
		//                     "qty_tick_size": "10",
		//                     "max_leverage": "50",
		//                     "tradable": true,
		//                     "expiry_timestamp_ms": 1688112000000,
		//                     "beta_product": false,
		//                     "underlying_symbol": "BTCUSD-INDEX",
		//                     "put_call": "CALL",
		//                     "strike": "30000",
		//                     "contract_size": "0.0001",
		//                     "margin_buy_enabled": false,
		//                     "margin_sell_enabled": false
		//                 },
		//             ]
		//         }
		//     }
		//
		var resultResponse interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(resultResponse, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var market interface{} = GetValue(data, i)
			var inst_type interface{} = this.SafeString(market, "inst_type")
			var spot interface{} = IsEqual(inst_type, "CCY_PAIR")
			var swap interface{} = IsEqual(inst_type, "PERPETUAL_SWAP")
			var future interface{} = IsEqual(inst_type, "FUTURE")
			var option interface{} = IsEqual(inst_type, "WARRANT")
			var baseId interface{} = this.SafeString(market, "base_ccy")
			var quoteId interface{} = this.SafeString(market, "quote_ccy")
			var settleId interface{} = Ternary(IsTrue(spot), nil, quoteId)
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var settle interface{} = Ternary(IsTrue(spot), nil, this.SafeCurrencyCode(settleId))
			var optionType interface{} = this.SafeStringLower(market, "put_call")
			var strike interface{} = this.SafeString(market, "strike")
			var marginBuyEnabled interface{} = this.SafeBool(market, "margin_buy_enabled")
			var marginSellEnabled interface{} = this.SafeBool(market, "margin_sell_enabled")
			var expiryString interface{} = this.OmitZero(this.SafeString(market, "expiry_timestamp_ms"))
			var expiry interface{} = Ternary(IsTrue((!IsEqual(expiryString, nil))), ParseInt(expiryString), nil)
			var symbol interface{} = Add(Add(base, "/"), quote)
			var typeVar interface{} = nil
			var contract interface{} = nil
			if IsTrue(IsEqual(inst_type, "CCY_PAIR")) {
				typeVar = "spot"
				contract = false
			} else if IsTrue(IsEqual(inst_type, "PERPETUAL_SWAP")) {
				typeVar = "swap"
				symbol = Add(Add(symbol, ":"), quote)
				contract = true
			} else if IsTrue(IsEqual(inst_type, "FUTURE")) {
				typeVar = "future"
				symbol = Add(Add(Add(Add(symbol, ":"), quote), "-"), this.Yymmdd(expiry))
				contract = true
			} else if IsTrue(IsEqual(inst_type, "WARRANT")) {
				typeVar = "option"
				var symbolOptionType interface{} = Ternary(IsTrue((IsEqual(optionType, "call"))), "C", "P")
				symbol = Add(Add(Add(Add(Add(Add(Add(Add(symbol, ":"), quote), "-"), this.Yymmdd(expiry)), "-"), strike), "-"), symbolOptionType)
				contract = true
			}
			AppendToArray(&result, map[string]interface{}{
				"id":             this.SafeString(market, "symbol"),
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           typeVar,
				"spot":           spot,
				"margin":         (IsTrue((marginBuyEnabled)) || IsTrue((marginSellEnabled))),
				"swap":           swap,
				"future":         future,
				"option":         option,
				"active":         this.SafeBool(market, "tradable"),
				"contract":       contract,
				"linear":         Ternary(IsTrue((contract)), true, nil),
				"inverse":        Ternary(IsTrue((contract)), false, nil),
				"contractSize":   this.SafeNumber(market, "contract_size"),
				"expiry":         expiry,
				"expiryDatetime": this.Iso8601(expiry),
				"strike":         this.ParseNumber(strike),
				"optionType":     optionType,
				"precision": map[string]interface{}{
					"price":  this.ParseNumber(this.SafeString(market, "price_tick_size")),
					"amount": this.ParseNumber(this.SafeString(market, "qty_tick_size")),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": this.ParseNumber("1"),
						"max": this.SafeNumber(market, "max_leverage"),
					},
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-tickers
 * @see https://exchange-docs.crypto.com/derivatives/index.html#public-get-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *CryptocomCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8738 := (<-this.LoadMarkets())
		PanicOnError(retRes8738)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbol interface{} = nil
			if IsTrue(IsArray(symbols)) {
				var symbolsLength interface{} = GetArrayLength(symbols)
				if IsTrue(IsGreaterThan(symbolsLength, 1)) {
					panic(BadRequest(Add(this.Id, " fetchTickers() symbols argument cannot contain more than 1 symbol")))
				}
				symbol = GetValue(symbols, 0)
			} else {
				symbol = symbols
			}
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}

		response := (<-this.V1PublicGetPublicGetTickers(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-tickers",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "i": "AVAXUSD-PERP",
		//                     "h": "13.209",
		//                     "l": "12.148",
		//                     "a": "13.209",
		//                     "v": "1109.8",
		//                     "vv": "14017.33",
		//                     "c": "0.0732",
		//                     "b": "13.210",
		//                     "k": "13.230",
		//                     "oi": "10888.9",
		//                     "t": 1687402657575
		//                 },
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchTicker
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-tickers
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *CryptocomCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes9308 := (<-this.LoadMarkets())
		PanicOnError(retRes9308)
		symbol = this.Symbol(symbol)

		tickers := (<-this.FetchTickers([]interface{}{symbol}, params))
		PanicOnError(tickers)

		ch <- this.SafeValue(tickers, symbol)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-order-history
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for, max date range is one day
 * @param {int} [limit] the maximum number of order structures to retrieve, default 100 max 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes9508 := (<-this.LoadMarkets())
		PanicOnError(retRes9508)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes95419 := (<-this.FetchPaginatedCallDynamic("fetchOrders", symbol, since, limit, params))
			PanicOnError(retRes95419)
			ch <- retRes95419
			return nil
		}
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_time", until)
		}

		response := (<-this.V1PrivatePostPrivateGetOrderHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686881486183,
		//         "method": "private/get-order-history",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
		//                     "order_id": "6142909895014042762",
		//                     "client_oid": "4e918597-1234-4321-8201-a7577e1e1d91",
		//                     "order_type": "MARKET",
		//                     "time_in_force": "GOOD_TILL_CANCEL",
		//                     "side": "SELL",
		//                     "exec_inst": [ ],
		//                     "quantity": "0.00024",
		//                     "order_value": "5.7054672",
		//                     "maker_fee_rate": "0",
		//                     "taker_fee_rate": "0",
		//                     "avg_price": "25023.97",
		//                     "trigger_price": "0",
		//                     "ref_price": "0",
		//                     "ref_price_type": "NULL_VAL",
		//                     "cumulative_quantity": "0.00024",
		//                     "cumulative_value": "6.0057528",
		//                     "cumulative_fee": "0.001501438200",
		//                     "status": "FILLED",
		//                     "update_user_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
		//                     "order_date": "2023-06-15",
		//                     "instrument_name": "BTC_USD",
		//                     "fee_instrument_name": "USD",
		//                     "create_time": 1686805465891,
		//                     "create_time_ns": "1686805465891812578",
		//                     "update_time": 1686805465891
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var orders interface{} = this.SafeList(data, "data", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchTrades
 * @description get a list of the most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch, maximum date range is one day
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *CryptocomCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes10328 := (<-this.LoadMarkets())
		PanicOnError(retRes10328)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes103619 := (<-this.FetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, params))
			PanicOnError(retRes103619)
			ch <- retRes103619
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_ts", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "count", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_ts", until)
		}

		response := (<-this.V1PublicGetPublicGetTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-trades",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "s": "sell",
		//                     "p": "26386.00",
		//                     "q": "0.00453",
		//                     "t": 1686944282062,
		//                     "tn" : 1704476468851524373,
		//                     "d": "4611686018455979970",
		//                     "i": "BTC_USD"
		//                 },
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var trades interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-candlestick
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *CryptocomCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10948 := (<-this.LoadMarkets())
		PanicOnError(retRes10948)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes109819 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 300))
			PanicOnError(retRes109819)
			ch <- retRes109819
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
			"timeframe":       this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(IsGreaterThan(limit, 300)) {
				limit = 300
			}
			AddElementToObject(request, "count", limit)
		}
		var now interface{} = this.Microseconds()
		var duration interface{} = this.ParseTimeframe(timeframe)
		var until interface{} = this.SafeInteger(params, "until", now)
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_ts", Subtract(since, Multiply(duration, 1000)))
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "end_ts", this.Sum(since, Multiply(Multiply(duration, limit), 1000)))
			} else {
				AddElementToObject(request, "end_ts", until)
			}
		} else {
			AddElementToObject(request, "end_ts", until)
		}

		response := (<-this.V1PublicGetPublicGetCandlestick(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-candlestick",
		//         "code": 0,
		//         "result": {
		//             "interval": "1m",
		//             "data": [
		//                 {
		//                     "o": "26949.89",
		//                     "h": "26957.64",
		//                     "l": "26948.24",
		//                     "c": "26950.00",
		//                     "v": "0.0670",
		//                     "t": 1687237080000
		//                 },
		//             ],
		//             "instrument_name": "BTC_USD"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the number of order book entries to return, max 50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *CryptocomCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11638 := (<-this.LoadMarkets())
		PanicOnError(retRes11638)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
		}
		if IsTrue(limit) {
			AddElementToObject(request, "depth", mathMin(limit, 50)) // max 50
		}

		response := (<-this.V1PublicGetPublicGetBook(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-book",
		//         "code": 0,
		//         "result": {
		//             "depth": 3,
		//             "data": [
		//                 {
		//                     "bids": [ [ "30025.00", "0.00004", "1" ], [ "30020.15", "0.02498", "1" ], [ "30020.00", "0.00004", "1" ] ],
		//                     "asks": [ [ "30025.01", "0.04090", "1" ], [ "30025.70", "0.01000", "1" ], [ "30026.94", "0.02681", "1" ] ],
		//                     "t": 1687491287380
		//                 }
		//             ],
		//             "instrument_name": "BTC_USD"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})
		var orderBook interface{} = this.SafeValue(data, 0)
		var timestamp interface{} = this.SafeInteger(orderBook, "t")

		ch <- this.ParseOrderBook(orderBook, symbol, timestamp)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseBalance(response interface{}) interface{} {
	var responseResult interface{} = this.SafeDict(response, "result", map[string]interface{}{})
	var data interface{} = this.SafeList(responseResult, "data", []interface{}{})
	var positionBalances interface{} = this.SafeValue(GetValue(data, 0), "position_balances", []interface{}{})
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	for i := 0; IsLessThan(i, GetArrayLength(positionBalances)); i++ {
		var balance interface{} = GetValue(positionBalances, i)
		var currencyId interface{} = this.SafeString(balance, "instrument_name")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(balance, "quantity"))
		AddElementToObject(account, "used", this.SafeString(balance, "reserved_qty"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name cryptocom#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-user-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *CryptocomCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes12238 := (<-this.LoadMarkets())
		PanicOnError(retRes12238)

		response := (<-this.V1PrivatePostPrivateUserBalance(params))
		PanicOnError(response)

		//
		//     {
		//         "id": 1687300499018,
		//         "method": "private/user-balance",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "total_available_balance": "5.84684368",
		//                     "total_margin_balance": "5.84684368",
		//                     "total_initial_margin": "0",
		//                     "total_maintenance_margin": "0",
		//                     "total_position_cost": "0",
		//                     "total_cash_balance": "6.44412101",
		//                     "total_collateral_value": "5.846843685",
		//                     "total_session_unrealized_pnl": "0",
		//                     "instrument_name": "USD",
		//                     "total_session_realized_pnl": "0",
		//                     "position_balances": [
		//                         {
		//                             "quantity": "0.0002119875",
		//                             "reserved_qty": "0",
		//                             "collateral_weight": "0.9",
		//                             "collateral_amount": "5.37549592",
		//                             "market_value": "5.97277325",
		//                             "max_withdrawal_balance": "0.00021198",
		//                             "instrument_name": "BTC",
		//                             "hourly_interest_rate": "0"
		//                         },
		//                     ],
		//                     "total_effective_leverage": "0",
		//                     "position_limit": "3000000",
		//                     "used_position_limit": "0",
		//                     "total_borrow": "0",
		//                     "margin_score": "0",
		//                     "is_liquidating": false,
		//                     "has_risk": false,
		//                     "terminatable": true
		//                 }
		//             ]
		//         }
		//     }
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-order-detail
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes12828 := (<-this.LoadMarkets())
		PanicOnError(retRes12828)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{
			"order_id": id,
		}

		response := (<-this.V1PrivatePostPrivateGetOrderDetail(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686872583882,
		//         "method": "private/get-order-detail",
		//         "code": 0,
		//         "result": {
		//             "account_id": "ae075bef-1234-4321-bd6g-bb9007252a63",
		//             "order_id": "6142909895025252686",
		//             "client_oid": "CCXT_c2d2152cc32d40a3ae7fbf",
		//             "order_type": "LIMIT",
		//             "time_in_force": "GOOD_TILL_CANCEL",
		//             "side": "BUY",
		//             "exec_inst": [ ],
		//             "quantity": "0.00020",
		//             "limit_price": "20000.00",
		//             "order_value": "4",
		//             "avg_price": "0",
		//             "trigger_price": "0",
		//             "ref_price": "0",
		//             "cumulative_quantity": "0",
		//             "cumulative_value": "0",
		//             "cumulative_fee": "0",
		//             "status": "ACTIVE",
		//             "update_user_id": "ae075bef-1234-4321-bd6g-bb9007252a63",
		//             "order_date": "2023-06-15",
		//             "instrument_name": "BTC_USD",
		//             "fee_instrument_name": "BTC",
		//             "create_time": 1686870220684,
		//             "create_time_ns": "1686870220684239675",
		//             "update_time": 1686870220684
		//         }
		//     }
		//
		var order interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var uppercaseType interface{} = ToUpper(typeVar)
	var request interface{} = map[string]interface{}{
		"instrument_name": GetValue(market, "id"),
		"side":            ToUpper(side),
		"quantity":        this.AmountToPrecision(symbol, amount),
	}
	if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var broker interface{} = this.SafeString(this.Options, "broker", "CCXT")
	AddElementToObject(request, "broker_id", broker)
	var marketType interface{} = nil
	var marginMode interface{} = nil
	marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params)
	marketType = GetValue(marketTypeparamsVariable, 0)
	params = GetValue(marketTypeparamsVariable, 1)
	marginModeparamsVariable := this.CustomHandleMarginModeAndParams("createOrder", params)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	if IsTrue(IsTrue((IsEqual(marketType, "margin"))) || IsTrue((!IsEqual(marginMode, nil)))) {
		AddElementToObject(request, "spot_margin", "MARGIN")
	} else if IsTrue(IsEqual(marketType, "spot")) {
		AddElementToObject(request, "spot_margin", "SPOT")
	}
	var timeInForce interface{} = this.SafeStringUpper2(params, "timeInForce", "time_in_force")
	if IsTrue(!IsEqual(timeInForce, nil)) {
		if IsTrue(IsEqual(timeInForce, "GTC")) {
			AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
		} else if IsTrue(IsEqual(timeInForce, "IOC")) {
			AddElementToObject(request, "time_in_force", "IMMEDIATE_OR_CANCEL")
		} else if IsTrue(IsEqual(timeInForce, "FOK")) {
			AddElementToObject(request, "time_in_force", "FILL_OR_KILL")
		} else {
			AddElementToObject(request, "time_in_force", timeInForce)
		}
	}
	var postOnly interface{} = this.SafeBool(params, "postOnly", false)
	if IsTrue(IsTrue((postOnly)) || IsTrue((IsEqual(timeInForce, "PO")))) {
		AddElementToObject(request, "exec_inst", []interface{}{"POST_ONLY"})
		AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
	}
	var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"stopPrice", "triggerPrice", "ref_price"})
	var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
	var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
	var isTrigger interface{} = (!IsEqual(triggerPrice, nil))
	var isStopLossTrigger interface{} = (!IsEqual(stopLossPrice, nil))
	var isTakeProfitTrigger interface{} = (!IsEqual(takeProfitPrice, nil))
	if IsTrue(isTrigger) {
		AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, triggerPrice))
		var priceString interface{} = this.NumberToString(price)
		if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
			if IsTrue(IsEqual(side, "buy")) {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
				} else {
					AddElementToObject(request, "type", "STOP_LIMIT")
				}
			} else {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "STOP_LIMIT")
				} else {
					AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
				}
			}
		} else {
			if IsTrue(IsEqual(side, "buy")) {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "TAKE_PROFIT")
				} else {
					AddElementToObject(request, "type", "STOP_LOSS")
				}
			} else {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "STOP_LOSS")
				} else {
					AddElementToObject(request, "type", "TAKE_PROFIT")
				}
			}
		}
	} else if IsTrue(isStopLossTrigger) {
		if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
			AddElementToObject(request, "type", "STOP_LIMIT")
		} else {
			AddElementToObject(request, "type", "STOP_LOSS")
		}
		AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, stopLossPrice))
	} else if IsTrue(isTakeProfitTrigger) {
		if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
			AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
		} else {
			AddElementToObject(request, "type", "TAKE_PROFIT")
		}
		AddElementToObject(request, "ref_price", this.PriceToPrecision(symbol, takeProfitPrice))
	} else {
		AddElementToObject(request, "type", uppercaseType)
	}
	params = this.Omit(params, []interface{}{"postOnly", "clientOrderId", "timeInForce", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"})
	return this.Extend(request, params)
}

/**
 * @method
 * @name cryptocom#createOrder
 * @description create a trade order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_loss', 'stop_limit', 'take_profit', 'take_profit_limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
 * @param {string} [params.ref_price_type] 'MARK_PRICE', 'INDEX_PRICE', 'LAST_PRICE' which trigger price type to use, default is MARK_PRICE
 * @param {float} [params.triggerPrice] price to trigger a trigger order
 * @param {float} [params.stopLossPrice] price to trigger a stop-loss trigger order
 * @param {float} [params.takeProfitPrice] price to trigger a take-profit trigger order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14458 := (<-this.LoadMarkets())
		PanicOnError(retRes14458)
		var market interface{} = this.Market(symbol)
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)

		response := (<-this.V1PrivatePostPrivateCreateOrder(request))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686804664362,
		//         "method": "private/create-order",
		//         "code" : 0,
		//         "result": {
		//             "order_id": "6540219377766741832",
		//             "client_oid": "CCXT_d6ef7c3db6c1495aa8b757"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseOrder(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#createOrders
 * @description create a list of trade orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order-list-list
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order-list-oco
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14758 := (<-this.LoadMarkets())
		PanicOnError(retRes14758)
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var orderRequest interface{} = this.CreateAdvancedOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var contigency interface{} = this.SafeString(params, "contingency_type", "LIST")
		var request interface{} = map[string]interface{}{
			"contingency_type": contigency,
			"order_list":       ordersRequests,
		}

		response := (<-this.V1PrivatePostPrivateCreateOrderList(this.Extend(request, params)))
		PanicOnError(response)
		//
		// {
		//     "id": 12,
		//     "method": "private/create-order-list",
		//     "code": 10001,
		//     "result": {
		//       "result_list": [
		//         {
		//           "index": 0,
		//           "code": 0,
		//           "order_id": "2015106383706015873",
		//           "client_oid": "my_order_0001"
		//         },
		//         {
		//           "index": 1,
		//           "code": 20007,
		//           "message": "INVALID_REQUEST",
		//           "client_oid": "my_order_0002"
		//         }
		//       ]
		//     }
		// }
		//
		//   {
		//       "id" : 1698068111133,
		//       "method" : "private/create-order-list",
		//       "code" : 0,
		//       "result" : [ {
		//         "code" : 0,
		//         "index" : 0,
		//         "client_oid" : "1698068111133_0",
		//         "order_id" : "6142909896519488206"
		//       }, {
		//         "code" : 306,
		//         "index" : 1,
		//         "client_oid" : "1698068111133_1",
		//         "message" : "INSUFFICIENT_AVAILABLE_BALANCE",
		//         "order_id" : "6142909896519488207"
		//       } ]
		//   }
		//
		var result interface{} = this.SafeValue(response, "result", []interface{}{})
		var listId interface{} = this.SafeString(result, "list_id")
		if IsTrue(!IsEqual(listId, nil)) {
			var ocoOrders interface{} = []interface{}{map[string]interface{}{
				"order_id": listId,
			}}

			ch <- this.ParseOrders(ocoOrders)
			return nil
		}

		ch <- this.ParseOrders(result)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) CreateAdvancedOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	// differs slightly from createOrderRequest
	// since the advanced order endpoint requires a different set of parameters
	// namely here we don't support ref_price or spot_margin
	// and market-buy orders need to send notional instead of quantity
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var uppercaseType interface{} = ToUpper(typeVar)
	var request interface{} = map[string]interface{}{
		"instrument_name": GetValue(market, "id"),
		"side":            ToUpper(side),
	}
	if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var broker interface{} = this.SafeString(this.Options, "broker", "CCXT")
	AddElementToObject(request, "broker_id", broker)
	var timeInForce interface{} = this.SafeStringUpper2(params, "timeInForce", "time_in_force")
	if IsTrue(!IsEqual(timeInForce, nil)) {
		if IsTrue(IsEqual(timeInForce, "GTC")) {
			AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
		} else if IsTrue(IsEqual(timeInForce, "IOC")) {
			AddElementToObject(request, "time_in_force", "IMMEDIATE_OR_CANCEL")
		} else if IsTrue(IsEqual(timeInForce, "FOK")) {
			AddElementToObject(request, "time_in_force", "FILL_OR_KILL")
		} else {
			AddElementToObject(request, "time_in_force", timeInForce)
		}
	}
	var postOnly interface{} = this.SafeBool(params, "postOnly", false)
	if IsTrue(IsTrue((postOnly)) || IsTrue((IsEqual(timeInForce, "PO")))) {
		AddElementToObject(request, "exec_inst", []interface{}{"POST_ONLY"})
		AddElementToObject(request, "time_in_force", "GOOD_TILL_CANCEL")
	}
	var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"stopPrice", "triggerPrice", "ref_price"})
	var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
	var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
	var isTrigger interface{} = (!IsEqual(triggerPrice, nil))
	var isStopLossTrigger interface{} = (!IsEqual(stopLossPrice, nil))
	var isTakeProfitTrigger interface{} = (!IsEqual(takeProfitPrice, nil))
	if IsTrue(isTrigger) {
		var priceString interface{} = this.NumberToString(price)
		if IsTrue(IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
			if IsTrue(IsEqual(side, "buy")) {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
				} else {
					AddElementToObject(request, "type", "STOP_LIMIT")
				}
			} else {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "STOP_LIMIT")
				} else {
					AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
				}
			}
		} else {
			if IsTrue(IsEqual(side, "buy")) {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "TAKE_PROFIT")
				} else {
					AddElementToObject(request, "type", "STOP_LOSS")
				}
			} else {
				if IsTrue(Precise.StringLt(priceString, triggerPrice)) {
					AddElementToObject(request, "type", "STOP_LOSS")
				} else {
					AddElementToObject(request, "type", "TAKE_PROFIT")
				}
			}
		}
	} else if IsTrue(isStopLossTrigger) {
		if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
			AddElementToObject(request, "type", "STOP_LIMIT")
		} else {
			AddElementToObject(request, "type", "STOP_LOSS")
		}
	} else if IsTrue(isTakeProfitTrigger) {
		if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))) {
			AddElementToObject(request, "type", "TAKE_PROFIT_LIMIT")
		} else {
			AddElementToObject(request, "type", "TAKE_PROFIT")
		}
	} else {
		AddElementToObject(request, "type", uppercaseType)
	}
	if IsTrue(IsTrue((IsEqual(side, "buy"))) && IsTrue((IsTrue(IsTrue((IsEqual(uppercaseType, "MARKET"))) || IsTrue((IsEqual(uppercaseType, "STOP_LOSS")))) || IsTrue((IsEqual(uppercaseType, "TAKE_PROFIT")))))) {
		// use createmarketBuy logic here
		var quoteAmount interface{} = nil
		var createMarketBuyOrderRequiresPrice interface{} = true
		createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
		createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
		params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
		var cost interface{} = this.SafeNumber2(params, "cost", "notional")
		params = this.Omit(params, "cost")
		if IsTrue(!IsEqual(cost, nil)) {
			quoteAmount = this.CostToPrecision(symbol, cost)
		} else if IsTrue(createMarketBuyOrderRequiresPrice) {
			if IsTrue(IsEqual(price, nil)) {
				panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
			} else {
				var amountString interface{} = this.NumberToString(amount)
				var priceString interface{} = this.NumberToString(price)
				var costRequest interface{} = Precise.StringMul(amountString, priceString)
				quoteAmount = this.CostToPrecision(symbol, costRequest)
			}
		} else {
			quoteAmount = this.CostToPrecision(symbol, amount)
		}
		AddElementToObject(request, "notional", quoteAmount)
	} else {
		AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
	}
	params = this.Omit(params, []interface{}{"postOnly", "clientOrderId", "timeInForce", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"})
	return this.Extend(request, params)
}

/**
 * @method
 * @name cryptocom#editOrder
 * @description edit a trade order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-amend-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol of the order to edit
 * @param {string} [type] not used by cryptocom editOrder
 * @param {string} [side] not used by cryptocom editOrder
 * @param {float} amount (mandatory) how much of the currency you want to trade in units of the base currency
 * @param {float} price (mandatory) the price for the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] the original client order id of the order to edit, required if id is not provided
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes16748 := (<-this.LoadMarkets())
		PanicOnError(retRes16748)
		var request interface{} = this.EditOrderRequest(id, symbol, amount, price, params)

		response := (<-this.V1PrivatePostPrivateAmendOrder(request))
		PanicOnError(response)
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseOrder(result)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) EditOrderRequest(id interface{}, symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var request interface{} = map[string]interface{}{}
	if IsTrue(!IsEqual(id, nil)) {
		AddElementToObject(request, "order_id", id)
	} else {
		var originalClientOrderId interface{} = this.SafeString2(params, "orig_client_oid", "clientOrderId")
		if IsTrue(IsEqual(originalClientOrderId, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " editOrder() requires an id argument or orig_client_oid parameter")))
		} else {
			AddElementToObject(request, "orig_client_oid", originalClientOrderId)
			params = this.Omit(params, []interface{}{"orig_client_oid", "clientOrderId"})
		}
	}
	if IsTrue(IsTrue((IsEqual(amount, nil))) || IsTrue((IsEqual(price, nil)))) {
		panic(ArgumentsRequired(Add(this.Id, " editOrder() requires both amount and price arguments. If you do not want to change the amount or price, you should pass the original values")))
	}
	AddElementToObject(request, "new_quantity", this.AmountToPrecision(symbol, amount))
	AddElementToObject(request, "new_price", this.PriceToPrecision(symbol, price))
	return this.Extend(request, params)
}

/**
 * @method
 * @name cryptocom#cancelAllOrders
 * @description cancel all open orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-all-orders
 * @param {string} symbol unified market symbol of the orders to cancel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} Returns exchange raw message{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17128 := (<-this.LoadMarkets())
		PanicOnError(retRes17128)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}

		response := (<-this.V1PrivatePostPrivateCancelAllOrders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- []interface{}{this.SafeOrder(map[string]interface{}{
			"info": response,
		})}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#cancelOrder
 * @description cancels an open order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order
 * @param {string} id the order id of the order to cancel
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17348 := (<-this.LoadMarkets())
		PanicOnError(retRes17348)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{
			"order_id": id,
		}

		response := (<-this.V1PrivatePostPrivateCancelOrder(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686882846638,
		//         "method": "private/cancel-order",
		//         "code": 0,
		//         "message": "NO_ERROR",
		//         "result": {
		//             "client_oid": "CCXT_c2d2152cc32d40a3ae7fbf",
		//             "order_id": "6142909895025252686"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseOrder(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#cancelOrders
 * @description cancel multiple orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order-list-list
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes17738 := (<-this.LoadMarkets())
		PanicOnError(retRes17738)
		var market interface{} = this.Market(symbol)
		var orderRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
			var id interface{} = GetValue(ids, i)
			var order interface{} = map[string]interface{}{
				"instrument_name": GetValue(market, "id"),
				"order_id":        ToString(id),
			}
			AppendToArray(&orderRequests, order)
		}
		var request interface{} = map[string]interface{}{
			"contingency_type": "LIST",
			"order_list":       orderRequests,
		}

		response := (<-this.V1PrivatePostPrivateCancelOrderList(this.Extend(request, params)))
		PanicOnError(response)
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseOrders(result, market, nil, nil, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#cancelOrdersForSymbols
 * @description cancel multiple orders for multiple symbols
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order-list-list
 * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) CancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18038 := (<-this.LoadMarkets())
		PanicOnError(retRes18038)
		var orderRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var order interface{} = GetValue(orders, i)
			var id interface{} = this.SafeString(order, "id")
			var symbol interface{} = this.SafeString(order, "symbol")
			var market interface{} = this.Market(symbol)
			var orderItem interface{} = map[string]interface{}{
				"instrument_name": GetValue(market, "id"),
				"order_id":        ToString(id),
			}
			AppendToArray(&orderRequests, orderItem)
		}
		var request interface{} = map[string]interface{}{
			"contingency_type": "LIST",
			"order_list":       orderRequests,
		}

		response := (<-this.V1PrivatePostPrivateCancelOrderList(this.Extend(request, params)))
		PanicOnError(response)
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseOrders(result, nil, nil, nil, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptocomCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18378 := (<-this.LoadMarkets())
		PanicOnError(retRes18378)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}

		response := (<-this.V1PrivatePostPrivateGetOpenOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686806134961,
		//         "method": "private/get-open-orders",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
		//                     "order_id": "6530219477767564494",
		//                     "client_oid": "CCXT_7ce730f0388441df9bc218",
		//                     "order_type": "LIMIT",
		//                     "time_in_force": "GOOD_TILL_CANCEL",
		//                     "side": "BUY",
		//                     "exec_inst": [ ],
		//                     "quantity": "0.00020",
		//                     "limit_price": "20000.00",
		//                     "order_value": "4",
		//                     "avg_price": "0",
		//                     "trigger_price": "0",
		//                     "ref_price": "0",
		//                     "cumulative_quantity": "0",
		//                     "cumulative_value": "0",
		//                     "cumulative_fee": "0",
		//                     "status": "ACTIVE",
		//                     "update_user_id": "ce075bef-1234-4321-bd6g-gg9007252e63",
		//                     "order_date": "2023-06-15",
		//                     "instrument_name": "BTC_USD",
		//                     "fee_instrument_name": "BTC",
		//                     "create_time": 1686806053992,
		//                     "create_time_ns": "1686806053992921880",
		//                     "update_time": 1686806053993
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var orders interface{} = this.SafeList(data, "data", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for, maximum date range is one day
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *CryptocomCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes19018 := (<-this.LoadMarkets())
		PanicOnError(retRes19018)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes190519 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params, 100))
			PanicOnError(retRes190519)
			ch <- retRes190519
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_time", until)
		}

		response := (<-this.V1PrivatePostPrivateGetTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686942003520,
		//         "method": "private/get-trades",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ds075abc-1234-4321-bd6g-ff9007252r63",
		//                     "event_date": "2023-06-16",
		//                     "journal_type": "TRADING",
		//                     "side": "BUY",
		//                     "instrument_name": "BTC_USD",
		//                     "fees": "-0.0000000525",
		//                     "trade_id": "6142909898247428343",
		//                     "trade_match_id": "4611686018455978480",
		//                     "create_time": 1686941992887,
		//                     "traded_price": "26347.16",
		//                     "traded_quantity": "0.00021",
		//                     "fee_instrument_name": "BTC",
		//                     "client_oid": "d1c70a60-810e-4c92-b2a0-72b931cb31e0",
		//                     "taker_side": "TAKER",
		//                     "order_id": "6142909895036331486",
		//                     "create_time_ns": "1686941992887207066"
		//                 }
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var trades interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseAddress(addressString interface{}) interface{} {
	var address interface{} = nil
	var tag interface{} = nil
	var rawTag interface{} = nil
	if IsTrue(IsGreaterThan(GetIndexOf(addressString, "?"), 0)) {
		addressrawTagVariable := Split(addressString, "?")
		address = GetValue(addressrawTagVariable, 0)
		rawTag = GetValue(addressrawTagVariable, 1)
		var splitted interface{} = Split(rawTag, "=")
		tag = GetValue(splitted, 1)
	} else {
		address = addressString
	}
	return []interface{}{address, tag}
}

/**
 * @method
 * @name cryptocom#withdraw
 * @description make a withdrawal
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *CryptocomCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes19878 := (<-this.LoadMarkets())
		PanicOnError(retRes19878)
		var currency interface{} = this.SafeCurrency(code) // for instance, USDC is not inferred from markets but it's still available
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
			"amount":   amount,
			"address":  address,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "address_tag", tag)
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		var networkId interface{} = this.NetworkCodeToId(networkCode)
		if IsTrue(!IsEqual(networkId, nil)) {
			AddElementToObject(request, "network_id", networkId)
		}

		response := (<-this.V1PrivatePostPrivateCreateWithdrawal(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "id":-1,
		//        "method":"private/create-withdrawal",
		//        "code":0,
		//        "result": {
		//            "id": 2220,
		//            "amount": 1,
		//            "fee": 0.0004,
		//            "symbol": "BTC",
		//            "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
		//            "client_wid": "my_withdrawal_002",
		//            "create_time":1607063412000
		//        }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result")

		ch <- this.ParseTransaction(result, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/?id=address-structure} indexed by the network
 */
func (this *CryptocomCore) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20348 := (<-this.LoadMarkets())
		PanicOnError(retRes20348)
		var currency interface{} = this.SafeCurrency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}

		response := (<-this.V1PrivatePostPrivateGetDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1234555011221,
		//         "method": "private/get-deposit-address",
		//         "code": 0,
		//         "result": {
		//             "deposit_address_list": [
		//                 {
		//                     "currency": "BTC",
		//                     "create_time": 1686730755000,
		//                     "id": "3737377",
		//                     "address": "3N9afggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
		//                     "status":"1",
		//                     "network": "BTC"
		//                 },
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var addresses interface{} = this.SafeList(data, "deposit_address_list", []interface{}{})
		var addressesLength interface{} = GetArrayLength(addresses)
		if IsTrue(IsEqual(addressesLength, 0)) {
			panic(ExchangeError(Add(this.Id, " fetchDepositAddressesByNetwork() generating address...")))
		}
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, addressesLength); i++ {
			var value interface{} = this.SafeDict(addresses, i)
			var addressString interface{} = this.SafeString(value, "address")
			var currencyId interface{} = this.SafeString(value, "currency")
			var responseCode interface{} = this.SafeCurrencyCode(currencyId)
			addresstagVariable := this.ParseAddress(addressString)
			address := GetValue(addresstagVariable, 0)
			tag := GetValue(addresstagVariable, 1)
			this.CheckAddress(address)
			var networkId interface{} = this.SafeString(value, "network")
			var network interface{} = this.NetworkIdToCode(networkId, responseCode)
			AddElementToObject(result, network, map[string]interface{}{
				"info":     value,
				"currency": responseCode,
				"network":  network,
				"address":  address,
				"tag":      tag,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *CryptocomCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var network interface{} = this.SafeStringUpper(params, "network")
		params = this.Omit(params, []interface{}{"network"})

		depositAddresses := (<-this.FetchDepositAddressesByNetwork(code, params))
		PanicOnError(depositAddresses)
		if IsTrue(InOp(depositAddresses, network)) {

			ch <- GetValue(depositAddresses, network)
			return nil
		} else {
			var keys interface{} = ObjectKeys(depositAddresses)

			ch <- GetValue(depositAddresses, GetValue(keys, 0))
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-deposit-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *CryptocomCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21208 := (<-this.LoadMarkets())
		PanicOnError(retRes21208)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.SafeCurrency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			// 90 days date range
			AddElementToObject(request, "start_ts", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_ts", until)
		}

		response := (<-this.V1PrivatePostPrivateGetDepositHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1688701375714,
		//         "method": "private/get-deposit-history",
		//         "code": 0,
		//         "result": {
		//             "deposit_list": [
		//                 {
		//                     "currency": "BTC",
		//                     "fee": 0,
		//                     "create_time": 1688023659000,
		//                     "id": "6201135",
		//                     "update_time": 1688178509000,
		//                     "amount": 0.00114571,
		//                     "address": "1234fggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
		//                     "status": "1",
		//                     "txid": "f0ae4202b76eb999c301eccdde44dc639bee42d1fdd5974105286ca3393f6065/2"
		//                 },
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var depositList interface{} = this.SafeList(data, "deposit_list", []interface{}{})

		ch <- this.ParseTransactions(depositList, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-withdrawal-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *CryptocomCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21808 := (<-this.LoadMarkets())
		PanicOnError(retRes21808)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.SafeCurrency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			// 90 days date range
			AddElementToObject(request, "start_ts", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_ts", until)
		}

		response := (<-this.V1PrivatePostPrivateGetWithdrawalHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1688613879534,
		//         "method": "private/get-withdrawal-history",
		//         "code": 0,
		//         "result": {
		//             "withdrawal_list": [
		//                 {
		//                     "currency": "BTC",
		//                     "client_wid": "",
		//                     "fee": 0.0005,
		//                     "create_time": 1688613850000,
		//                     "id": "5275977",
		//                     "update_time": 1688613850000,
		//                     "amount": 0.0005,
		//                     "address": "1234NMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn",
		//                     "status": "1",
		//                     "txid": "",
		//                     "network_id": "BTC"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var withdrawalList interface{} = this.SafeList(data, "withdrawal_list", []interface{}{})

		ch <- this.ParseTransactions(withdrawalList, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTicker
	//
	//     {
	//         "i": "BTC_USD",
	//         "h": "30821.45",
	//         "l": "28685.11",
	//         "a": "30446.00",
	//         "v": "1767.8734",
	//         "vv": "52436726.42",
	//         "c": "0.0583",
	//         "b": "30442.00",
	//         "k": "30447.66",
	//         "t": 1687403045415
	//     }
	//
	// fetchTickers
	//
	//     {
	//         "i": "AVAXUSD-PERP",
	//         "h": "13.209",
	//         "l": "12.148",
	//         "a": "13.209",
	//         "v": "1109.8",
	//         "vv": "14017.33",
	//         "c": "0.0732",
	//         "b": "13.210",
	//         "k": "13.230",
	//         "oi": "10888.9",
	//         "t": 1687402657575
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(ticker, "t")
	var marketId interface{} = this.SafeString(ticker, "i")
	market = this.SafeMarket(marketId, market, "_")
	var quote interface{} = this.SafeString(market, "quote")
	var last interface{} = this.SafeString(ticker, "a")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeNumber(ticker, "h"),
		"low":           this.SafeNumber(ticker, "l"),
		"bid":           this.SafeNumber(ticker, "b"),
		"bidVolume":     nil,
		"ask":           this.SafeNumber(ticker, "k"),
		"askVolume":     nil,
		"vwap":          nil,
		"open":          nil,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    this.SafeString(ticker, "c"),
		"average":       nil,
		"baseVolume":    this.SafeString(ticker, "v"),
		"quoteVolume":   Ternary(IsTrue((IsEqual(quote, "USD"))), this.SafeString(ticker, "vv"), nil),
		"info":          ticker,
	}, market)
}
func (this *CryptocomCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//
	//     {
	//         "s": "sell",
	//         "p": "26386.00",
	//         "q": "0.00453",
	//         "tn": 1686944282062,
	//         "tn": 1704476468851524373,
	//         "d": "4611686018455979970",
	//         "i": "BTC_USD"
	//     }
	//
	// fetchMyTrades
	//
	//     {
	//         "account_id": "ds075abc-1234-4321-bd6g-ff9007252r63",
	//         "event_date": "2023-06-16",
	//         "journal_type": "TRADING",
	//         "side": "BUY",
	//         "instrument_name": "BTC_USD",
	//         "fees": "-0.0000000525",
	//         "trade_id": "6142909898247428343",
	//         "trade_match_id": "4611686018455978480",
	//         "create_time": 1686941992887,
	//         "traded_price": "26347.16",
	//         "traded_quantity": "0.00021",
	//         "fee_instrument_name": "BTC",
	//         "client_oid": "d1c70a60-1234-4c92-b2a0-72b931cb31e0",
	//         "taker_side": "TAKER",
	//         "order_id": "6142909895036331486",
	//         "create_time_ns": "1686941992887207066"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(trade, "t", "create_time")
	var marketId interface{} = this.SafeString2(trade, "i", "instrument_name")
	market = this.SafeMarket(marketId, market, "_")
	var feeCurrency interface{} = this.SafeString(trade, "fee_instrument_name")
	var feeCostString interface{} = this.SafeString(trade, "fees")
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"id":           this.SafeString2(trade, "d", "trade_id"),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"order":        this.SafeString(trade, "order_id"),
		"side":         this.SafeStringLower2(trade, "s", "side"),
		"takerOrMaker": this.SafeStringLower(trade, "taker_side"),
		"price":        this.SafeNumber2(trade, "p", "traded_price"),
		"amount":       this.SafeNumber2(trade, "q", "traded_quantity"),
		"cost":         nil,
		"type":         nil,
		"fee": map[string]interface{}{
			"currency": this.SafeCurrencyCode(feeCurrency),
			"cost":     this.ParseNumber(Precise.StringNeg(feeCostString)),
		},
	}, market)
}
func (this *CryptocomCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "o": "26949.89",
	//         "h": "26957.64",
	//         "l": "26948.24",
	//         "c": "26950.00",
	//         "v": "0.0670",
	//         "t": 1687237080000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
func (this *CryptocomCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"ACTIVE":   "open",
		"CANCELED": "canceled",
		"FILLED":   "closed",
		"REJECTED": "rejected",
		"EXPIRED":  "expired",
	}
	return this.SafeString(statuses, status, status)
}
func (this *CryptocomCore) ParseTimeInForce(timeInForce interface{}) interface{} {
	var timeInForces interface{} = map[string]interface{}{
		"GOOD_TILL_CANCEL":    "GTC",
		"IMMEDIATE_OR_CANCEL": "IOC",
		"FILL_OR_KILL":        "FOK",
	}
	return this.SafeString(timeInForces, timeInForce, timeInForce)
}
func (this *CryptocomCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder, cancelOrder
	//
	//     {
	//         "order_id": "6540219377766741832",
	//         "client_oid": "CCXT_d6ef7c3db6c1495aa8b757"
	//     }
	//
	// fetchOpenOrders, fetchOrder, fetchOrders
	//
	//     {
	//         "account_id": "ce075bef-1234-4321-bd6g-ff9007252e63",
	//         "order_id": "6530219477767564494",
	//         "client_oid": "CCXT_7ce730f0388441df9bc218",
	//         "order_type": "LIMIT",
	//         "time_in_force": "GOOD_TILL_CANCEL",
	//         "side": "BUY",
	//         "exec_inst": [ ],
	//         "quantity": "0.00020",
	//         "limit_price": "20000.00",
	//         "order_value": "4",
	//         "avg_price": "0",
	//         "trigger_price": "0",
	//         "ref_price": "0",
	//         "cumulative_quantity": "0",
	//         "cumulative_value": "0",
	//         "cumulative_fee": "0",
	//         "status": "ACTIVE",
	//         "update_user_id": "ce075bef-1234-4321-bd6g-gg9007252e63",
	//         "order_date": "2023-06-15",
	//         "instrument_name": "BTC_USD",
	//         "fee_instrument_name": "BTC",
	//         "create_time": 1686806053992,
	//         "create_time_ns": "1686806053992921880",
	//         "update_time": 1686806053993
	//     }
	//
	// createOrders
	//     {
	//             "code" : 306,
	//             "index" : 1,
	//             "client_oid" : "1698068111133_1",
	//             "message" : "INSUFFICIENT_AVAILABLE_BALANCE",
	//             "order_id" : "6142909896519488207"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var code interface{} = this.SafeInteger(order, "code")
	if IsTrue(IsTrue((!IsEqual(code, nil))) && IsTrue((!IsEqual(code, 0)))) {
		return this.SafeOrder(map[string]interface{}{
			"id":            this.SafeString(order, "order_id"),
			"clientOrderId": this.SafeString(order, "client_oid"),
			"info":          order,
			"status":        "rejected",
		})
	}
	var created interface{} = this.SafeInteger(order, "create_time")
	var marketId interface{} = this.SafeString(order, "instrument_name")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var execInst interface{} = this.SafeValue(order, "exec_inst")
	var postOnly interface{} = nil
	if IsTrue(!IsEqual(execInst, nil)) {
		postOnly = false
		for i := 0; IsLessThan(i, GetArrayLength(execInst)); i++ {
			var inst interface{} = GetValue(execInst, i)
			if IsTrue(IsEqual(inst, "POST_ONLY")) {
				postOnly = true
				break
			}
		}
	}
	var feeCurrency interface{} = this.SafeString(order, "fee_instrument_name")
	return this.SafeOrder(map[string]interface{}{
		"info":               order,
		"id":                 this.SafeString(order, "order_id"),
		"clientOrderId":      this.SafeString(order, "client_oid"),
		"timestamp":          created,
		"datetime":           this.Iso8601(created),
		"lastTradeTimestamp": this.SafeInteger(order, "update_time"),
		"status":             this.ParseOrderStatus(this.SafeString(order, "status")),
		"symbol":             symbol,
		"type":               this.SafeStringLower(order, "order_type"),
		"timeInForce":        this.ParseTimeInForce(this.SafeString(order, "time_in_force")),
		"postOnly":           postOnly,
		"side":               this.SafeStringLower(order, "side"),
		"price":              this.SafeNumber(order, "limit_price"),
		"amount":             this.SafeNumber(order, "quantity"),
		"filled":             this.SafeNumber(order, "cumulative_quantity"),
		"remaining":          nil,
		"average":            this.SafeNumber(order, "avg_price"),
		"cost":               this.SafeNumber(order, "cumulative_value"),
		"fee": map[string]interface{}{
			"currency": this.SafeCurrencyCode(feeCurrency),
			"cost":     this.SafeNumber(order, "cumulative_fee"),
		},
		"trades": []interface{}{},
	}, market)
}
func (this *CryptocomCore) ParseDepositStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"0": "pending",
		"1": "ok",
		"2": "failed",
		"3": "pending",
	}
	return this.SafeString(statuses, status, status)
}
func (this *CryptocomCore) ParseWithdrawalStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"0": "pending",
		"1": "pending",
		"2": "failed",
		"3": "pending",
		"4": "failed",
		"5": "ok",
		"6": "canceled",
	}
	return this.SafeString(statuses, status, status)
}
func (this *CryptocomCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "currency": "BTC",
	//         "fee": 0,
	//         "create_time": 1688023659000,
	//         "id": "6201135",
	//         "update_time": 1688178509000,
	//         "amount": 0.00114571,
	//         "address": "1234fggxTSmJ3H4jaMQuWyEiLBzZdAbK6d",
	//         "status": "1",
	//         "txid": "f0ae4202b76eb999c301eccdde44dc639bee42d1fdd5974105286ca3393f6065/2"
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "currency": "BTC",
	//         "client_wid": "",
	//         "fee": 0.0005,
	//         "create_time": 1688613850000,
	//         "id": "5775977",
	//         "update_time": 1688613850000,
	//         "amount": 0.0005,
	//         "address": "1234NMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn",
	//         "status": "1",
	//         "txid": "",
	//         "network_id": "BTC"
	//     }
	//
	// withdraw
	//
	//     {
	//         "id": 2220,
	//         "amount": 1,
	//         "fee": 0.0004,
	//         "symbol": "BTC",
	//         "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
	//         "client_wid": "my_withdrawal_002",
	//         "create_time":1607063412000
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var typeVar interface{} = nil
	var rawStatus interface{} = this.SafeString(transaction, "status")
	var status interface{} = nil
	if IsTrue(InOp(transaction, "client_wid")) {
		typeVar = "withdrawal"
		status = this.ParseWithdrawalStatus(rawStatus)
	} else {
		typeVar = "deposit"
		status = this.ParseDepositStatus(rawStatus)
	}
	var addressString interface{} = this.SafeString(transaction, "address")
	addresstagVariable := this.ParseAddress(addressString)
	address := GetValue(addresstagVariable, 0)
	tag := GetValue(addresstagVariable, 1)
	var currencyId interface{} = this.SafeString(transaction, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var timestamp interface{} = this.SafeInteger(transaction, "create_time")
	var feeCost interface{} = this.SafeNumber(transaction, "fee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": code,
			"cost":     feeCost,
		}
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString(transaction, "id"),
		"txid":        this.SafeString(transaction, "txid"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     nil,
		"address":     address,
		"addressTo":   address,
		"addressFrom": nil,
		"tag":         tag,
		"tagTo":       tag,
		"tagFrom":     nil,
		"type":        typeVar,
		"amount":      this.SafeNumber(transaction, "amount"),
		"currency":    code,
		"status":      status,
		"updated":     this.SafeInteger(transaction, "update_time"),
		"internal":    nil,
		"comment":     this.SafeString(transaction, "client_wid"),
		"fee":         fee,
	}
}
func (this *CryptocomCore) CustomHandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @ignore
	 * @method
	 * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @returns {Array} the marginMode in lowercase
	 */
	params := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = params
	var defaultType interface{} = this.SafeString(this.Options, "defaultType")
	var isMargin interface{} = this.SafeBool(params, "margin", false)
	params = this.Omit(params, "margin")
	var marginMode interface{} = nil
	marginModeparamsVariable := this.HandleMarginModeAndParams(methodName, params)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	if IsTrue(!IsEqual(marginMode, nil)) {
		if IsTrue(!IsEqual(marginMode, "cross")) {
			panic(NotSupported(Add(this.Id, " only cross margin is supported")))
		}
	} else {
		if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
			marginMode = "cross"
		}
	}
	return []interface{}{marginMode, params}
}
func (this *CryptocomCore) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "full_name": "Alchemix",
	//        "default_network": "ETH",
	//        "network_list": [
	//          {
	//            "network_id": "ETH",
	//            "withdrawal_fee": "0.25000000",
	//            "withdraw_enabled": true,
	//            "min_withdrawal_amount": "0.5",
	//            "deposit_enabled": true,
	//            "confirmation_required": "0"
	//          }
	//        ]
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var networkList interface{} = this.SafeList(fee, "network_list", []interface{}{})
	var networkListLength interface{} = GetArrayLength(networkList)
	var result interface{} = map[string]interface{}{
		"info": fee,
		"withdraw": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"networks": map[string]interface{}{},
	}
	if IsTrue(!IsEqual(networkList, nil)) {
		for i := 0; IsLessThan(i, networkListLength); i++ {
			var networkInfo interface{} = GetValue(networkList, i)
			var networkId interface{} = this.SafeString(networkInfo, "network_id")
			var currencyCode interface{} = this.SafeString(currency, "code")
			var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
			AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
				"deposit": map[string]interface{}{
					"fee":        nil,
					"percentage": nil,
				},
				"withdraw": map[string]interface{}{
					"fee":        this.SafeNumber(networkInfo, "withdrawal_fee"),
					"percentage": false,
				},
			})
			if IsTrue(IsEqual(networkListLength, 1)) {
				AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(networkInfo, "withdrawal_fee"))
				AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
			}
		}
	}
	return result
}

/**
 * @method
 * @name cryptocom#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-currency-networks
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *CryptocomCore) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes26878 := (<-this.LoadMarkets())
		PanicOnError(retRes26878)

		response := (<-this.V1PrivatePostPrivateGetCurrencyNetworks(params))
		PanicOnError(response)
		var data interface{} = this.SafeValue(response, "result")
		var currencyMap interface{} = this.SafeList(data, "currency_map")

		ch <- this.ParseDepositWithdrawFees(currencyMap, codes, "full_name")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-transactions
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
 */
func (this *CryptocomCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27078 := (<-this.LoadMarkets())
		PanicOnError(retRes27078)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.SafeCurrency(code)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_time", until)
		}

		response := (<-this.V1PrivatePostPrivateGetTransactions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1686813195698,
		//         "method": "private/get-transactions",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ce075cef-1234-4321-bd6e-gf9007351e64",
		//                     "event_date": "2023-06-15",
		//                     "journal_type": "TRADING",
		//                     "journal_id": "6530219460124075091",
		//                     "transaction_qty": "6.0091224",
		//                     "transaction_cost": "6.0091224",
		//                     "realized_pnl": "0",
		//                     "order_id": "6530219477766741833",
		//                     "trade_id": "6530219495775954765",
		//                     "trade_match_id": "4611686018455865176",
		//                     "event_timestamp_ms": 1686804665013,
		//                     "event_timestamp_ns": "1686804665013642422",
		//                     "client_oid": "CCXT_d6ea7c5db6c1495aa8b758",
		//                     "taker_side": "",
		//                     "side": "BUY",
		//                     "instrument_name": "USD"
		//                 },
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var ledger interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParseLedger(ledger, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "account_id": "ce075cef-1234-4321-bd6e-gf9007351e64",
	//         "event_date": "2023-06-15",
	//         "journal_type": "TRADING",
	//         "journal_id": "6530219460124075091",
	//         "transaction_qty": "6.0091224",
	//         "transaction_cost": "6.0091224",
	//         "realized_pnl": "0",
	//         "order_id": "6530219477766741833",
	//         "trade_id": "6530219495775954765",
	//         "trade_match_id": "4611686018455865176",
	//         "event_timestamp_ms": 1686804665013,
	//         "event_timestamp_ns": "1686804665013642422",
	//         "client_oid": "CCXT_d6ea7c5db6c1495aa8b758",
	//         "taker_side": "",
	//         "side": "BUY",
	//         "instrument_name": "USD"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(item, "event_timestamp_ms")
	var currencyId interface{} = this.SafeString(item, "instrument_name")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var amount interface{} = this.SafeString(item, "transaction_qty")
	var direction interface{} = nil
	if IsTrue(Precise.StringLt(amount, "0")) {
		direction = "out"
		amount = Precise.StringAbs(amount)
	} else {
		direction = "in"
	}
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "order_id"),
		"direction":        direction,
		"account":          this.SafeString(item, "account_id"),
		"referenceId":      this.SafeString(item, "trade_id"),
		"referenceAccount": this.SafeString(item, "trade_match_id"),
		"type":             this.ParseLedgerEntryType(this.SafeString(item, "journal_type")),
		"currency":         code,
		"amount":           this.ParseNumber(amount),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"before":           nil,
		"after":            nil,
		"status":           nil,
		"fee": map[string]interface{}{
			"currency": nil,
			"cost":     nil,
		},
	}, currency)
}
func (this *CryptocomCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var ledgerType interface{} = map[string]interface{}{
		"TRADING":           "trade",
		"TRADE_FEE":         "fee",
		"WITHDRAW_FEE":      "fee",
		"WITHDRAW":          "withdrawal",
		"DEPOSIT":           "deposit",
		"ROLLBACK_WITHDRAW": "rollback",
		"ROLLBACK_DEPOSIT":  "rollback",
		"FUNDING":           "fee",
		"REALIZED_PNL":      "trade",
		"INSURANCE_FUND":    "insurance",
		"SOCIALIZED_LOSS":   "trade",
		"LIQUIDATION_FEE":   "fee",
		"SESSION_RESET":     "reset",
		"ADJUSTMENT":        "adjustment",
		"SESSION_SETTLE":    "settlement",
		"UNCOVERED_LOSS":    "trade",
		"ADMIN_ADJUSTMENT":  "adjustment",
		"DELIST":            "delist",
		"SETTLEMENT_FEE":    "fee",
		"AUTO_CONVERSION":   "conversion",
		"MANUAL_CONVERSION": "conversion",
	}
	return this.SafeString(ledgerType, typeVar, typeVar)
}

/**
 * @method
 * @name cryptocom#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
 */
func (this *CryptocomCore) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes28508 := (<-this.LoadMarkets())
		PanicOnError(retRes28508)

		response := (<-this.V1PrivatePostPrivateGetAccounts(params))
		PanicOnError(response)
		//
		//     {
		//         "id": 1234567894321,
		//         "method": "private/get-accounts",
		//         "code": 0,
		//         "result": {
		//             "master_account": {
		//                 "uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
		//                 "user_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
		//                 "enabled": true,
		//                 "tradable": true,
		//                 "name": "YOUR_NAME",
		//                 "country_code": "CAN",
		//                 "phone_country_code": "CAN",
		//                 "incorp_country_code": "",
		//                 "margin_access": "DEFAULT",
		//                 "derivatives_access": "DEFAULT",
		//                 "create_time": 1656445188000,
		//                 "update_time": 1660794567262,
		//                 "two_fa_enabled": true,
		//                 "kyc_level": "ADVANCED",
		//                 "suspended": false,
		//                 "terminated": false,
		//                 "spot_enabled": false,
		//                 "margin_enabled": false,
		//                 "derivatives_enabled": false
		//             },
		//             "sub_account_list": []
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var masterAccount interface{} = this.SafeDict(result, "master_account", map[string]interface{}{})
		var accounts interface{} = this.SafeList(result, "sub_account_list", []interface{}{})
		AppendToArray(&accounts, masterAccount)

		ch <- this.ParseAccounts(accounts, params)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseAccount(account interface{}) interface{} {
	//
	//     {
	//         "uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
	//         "user_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
	//         "master_account_uuid": "a1234abc-1234-4321-q5r7-b1ab0a0b12b",
	//         "label": "FORMER_MASTER_MARGIN",
	//         "enabled": true,
	//         "tradable": true,
	//         "name": "YOUR_NAME",
	//         "country_code": "YOUR_COUNTRY_CODE",
	//         "incorp_country_code": "",
	//         "margin_access": "DEFAULT",
	//         "derivatives_access": "DEFAULT",
	//         "create_time": 1656481992000,
	//         "update_time": 1667272884594,
	//         "two_fa_enabled": false,
	//         "kyc_level": "ADVANCED",
	//         "suspended": false,
	//         "terminated": false,
	//         "spot_enabled": false,
	//         "margin_enabled": false,
	//         "derivatives_enabled": false,
	//         "system_label": "FORMER_MASTER_MARGIN"
	//     }
	//
	return map[string]interface{}{
		"id":   this.SafeString(account, "uuid"),
		"type": this.SafeString(account, "label"),
		"code": nil,
		"info": account,
	}
}

/**
 * @method
 * @name cryptocom#fetchSettlementHistory
 * @description fetches historical settlement records
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-expired-settlement-price
 * @param {string} symbol unified market symbol of the settlement history
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @param {int} [params.type] 'future', 'option'
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/?id=settlement-history-structure}
 */
func (this *CryptocomCore) FetchSettlementHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes29378 := (<-this.LoadMarkets())
		PanicOnError(retRes29378)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchSettlementHistory", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		this.CheckRequiredArgument("fetchSettlementHistory", typeVar, "type", []interface{}{"future", "option", "WARRANT", "FUTURE"})
		if IsTrue(IsEqual(typeVar, "option")) {
			typeVar = "WARRANT"
		}
		var request interface{} = map[string]interface{}{
			"instrument_type": ToUpper(typeVar),
		}

		response := (<-this.V1PublicGetPublicGetExpiredSettlementPrice(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-expired-settlement-price",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "i": "BTCUSD-230526",
		//                     "x": 1685088000000,
		//                     "v": "26464.1",
		//                     "t": 1685087999500
		//                 }
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})
		var settlements interface{} = this.ParseSettlements(data, market)
		var sorted interface{} = this.SortBy(settlements, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseSettlement(settlement interface{}, market interface{}) interface{} {
	//
	//     {
	//         "i": "BTCUSD-230526",
	//         "x": 1685088000000,
	//         "v": "26464.1",
	//         "t": 1685087999500
	//     }
	//
	var timestamp interface{} = this.SafeInteger(settlement, "x")
	var marketId interface{} = this.SafeString(settlement, "i")
	return map[string]interface{}{
		"info":      settlement,
		"symbol":    this.SafeSymbol(marketId, market),
		"price":     this.SafeNumber(settlement, "v"),
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
	}
}
func (this *CryptocomCore) ParseSettlements(settlements interface{}, market interface{}) interface{} {
	//
	//     [
	//         {
	//             "i": "BTCUSD-230526",
	//             "x": 1685088000000,
	//             "v": "26464.1",
	//             "t": 1685087999500
	//         }
	//     ]
	//
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(settlements)); i++ {
		AppendToArray(&result, this.ParseSettlement(GetValue(settlements, i), market))
	}
	return result
}

/**
 * @method
 * @name cryptocom#fetchFundingRate
 * @description fetches historical funding rates
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-valuations
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *CryptocomCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes30248 := (<-this.LoadMarkets())
		PanicOnError(retRes30248)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
		}
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
			"valuation_type":  "estimated_funding_rate",
			"count":           1,
		}

		response := (<-this.V1PublicGetPublicGetValuations(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-valuations",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "v": "-0.000001884",
		//                     "t": 1687892400000
		//                 },
		//             ],
		//             "instrument_name": "BTCUSD-PERP"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})
		var entry interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseFundingRate(entry, market)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//                 {
	//                     "v": "-0.000001884",
	//                     "t": 1687892400000
	//                 },
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(contract, "t")
	var fundingTimestamp interface{} = nil
	if IsTrue(!IsEqual(timestamp, nil)) {
		fundingTimestamp = Multiply(MathCeil(Divide(timestamp, 3600000)), 3600000) // end of the next hour
	}
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   this.SafeSymbol(nil, market),
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                timestamp,
		"datetime":                 this.Iso8601(timestamp),
		"fundingRate":              this.SafeNumber(contract, "v"),
		"fundingTimestamp":         fundingTimestamp,
		"fundingDatetime":          this.Iso8601(fundingTimestamp),
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nil,
		"nextFundingDatetime":      nil,
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 "1h",
	}
}

/**
 * @method
 * @name cryptocom#fetchFundingRateHistory
 * @description fetches historical funding rates
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#public-get-valuations
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures] to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *CryptocomCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes31088 := (<-this.LoadMarkets())
		PanicOnError(retRes31088)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes311219 := (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params))
			PanicOnError(retRes311219)
			ch <- retRes311219
			return nil
		}
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadSymbol(Add(this.Id, " fetchFundingRateHistory() supports swap contracts only")))
		}
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
			"valuation_type":  "funding_hist",
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_ts", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "count", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_ts", until)
		}

		response := (<-this.V1PublicGetPublicGetValuations(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": -1,
		//         "method": "public/get-valuations",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "v": "-0.000001884",
		//                     "t": 1687892400000
		//                 },
		//             ],
		//             "instrument_name": "BTCUSD-PERP"
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})
		var marketId interface{} = this.SafeString(result, "instrument_name")
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var timestamp interface{} = this.SafeInteger(entry, "t")
			AppendToArray(&rates, map[string]interface{}{
				"info":        entry,
				"symbol":      this.SafeSymbol(marketId, market),
				"fundingRate": this.SafeNumber(entry, "v"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-positions
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *CryptocomCore) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes31798 := (<-this.LoadMarkets())
		PanicOnError(retRes31798)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
		}

		response := (<-this.V1PrivatePostPrivateGetPositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1688015952050,
		//         "method": "private/get-positions",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
		//                     "quantity": "0.0001",
		//                     "cost": "3.02392",
		//                     "open_pos_cost": "3.02392",
		//                     "open_position_pnl": "-0.0010281328",
		//                     "session_pnl": "-0.0010281328",
		//                     "update_timestamp_ms": 1688015919091,
		//                     "instrument_name": "BTCUSD-PERP",
		//                     "type": "PERPETUAL_SWAP"
		//                 }
		//             ]
		//         }
		//     }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var data interface{} = this.SafeList(result, "data", []interface{}{})

		ch <- this.ParsePosition(this.SafeDict(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchPositions
 * @description fetch all open positions
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *CryptocomCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes32228 := (<-this.LoadMarkets())
		PanicOnError(retRes32228)
		symbols = this.MarketSymbols(symbols)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbol interface{} = nil
			if IsTrue(IsArray(symbols)) {
				var symbolsLength interface{} = GetArrayLength(symbols)
				if IsTrue(IsGreaterThan(symbolsLength, 1)) {
					panic(BadRequest(Add(this.Id, " fetchPositions() symbols argument cannot contain more than 1 symbol")))
				}
				symbol = GetValue(symbols, 0)
			} else {
				symbol = symbols
			}
			market = this.Market(symbol)
			AddElementToObject(request, "instrument_name", GetValue(market, "id"))
		}

		response := (<-this.V1PrivatePostPrivateGetPositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "id": 1688015952050,
		//         "method": "private/get-positions",
		//         "code": 0,
		//         "result": {
		//             "data": [
		//                 {
		//                     "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
		//                     "quantity": "0.0001",
		//                     "cost": "3.02392",
		//                     "open_pos_cost": "3.02392",
		//                     "open_position_pnl": "-0.0010281328",
		//                     "session_pnl": "-0.0010281328",
		//                     "update_timestamp_ms": 1688015919091,
		//                     "instrument_name": "BTCUSD-PERP",
		//                     "type": "PERPETUAL_SWAP"
		//                 }
		//             ]
		//         }
		//     }
		//
		var responseResult interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var positions interface{} = this.SafeList(responseResult, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
			var entry interface{} = GetValue(positions, i)
			var marketId interface{} = this.SafeString(entry, "instrument_name")
			var marketInner interface{} = this.SafeMarket(marketId, nil, nil, "contract")
			AppendToArray(&result, this.ParsePosition(entry, marketInner))
		}

		ch <- this.FilterByArrayPositions(result, "symbol", nil, false)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "account_id": "ce075bef-b600-4277-bd6e-ff9007251e63",
	//         "quantity": "0.0001",
	//         "cost": "3.02392",
	//         "open_pos_cost": "3.02392",
	//         "open_position_pnl": "-0.0010281328",
	//         "session_pnl": "-0.0010281328",
	//         "update_timestamp_ms": 1688015919091,
	//         "instrument_name": "BTCUSD-PERP",
	//         "type": "PERPETUAL_SWAP"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "instrument_name")
	market = this.SafeMarket(marketId, market, nil, "contract")
	var symbol interface{} = this.SafeSymbol(marketId, market, nil, "contract")
	var timestamp interface{} = this.SafeInteger(position, "update_timestamp_ms")
	var amount interface{} = this.SafeString(position, "quantity")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      symbol,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"hedged":                      nil,
		"side":                        Ternary(IsTrue(Precise.StringGt(amount, "0")), "buy", "sell"),
		"contracts":                   Precise.StringAbs(amount),
		"contractSize":                GetValue(market, "contractSize"),
		"entryPrice":                  nil,
		"markPrice":                   nil,
		"notional":                    nil,
		"leverage":                    nil,
		"collateral":                  this.SafeNumber(position, "open_pos_cost"),
		"initialMargin":               this.SafeNumber(position, "cost"),
		"maintenanceMargin":           nil,
		"initialMarginPercentage":     nil,
		"maintenanceMarginPercentage": nil,
		"unrealizedPnl":               this.SafeNumber(position, "open_position_pnl"),
		"liquidationPrice":            nil,
		"marginMode":                  nil,
		"percentage":                  nil,
		"marginRatio":                 nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}
func (this *CryptocomCore) Nonce() interface{} {
	return this.Milliseconds()
}
func (this *CryptocomCore) ParamsToString(object interface{}, level interface{}) interface{} {
	var maxLevel interface{} = 3
	if IsTrue(IsGreaterThanOrEqual(level, maxLevel)) {
		return ToString(object)
	}
	if IsTrue(IsString(object)) {
		return object
	}
	var returnString interface{} = ""
	var paramsKeys interface{} = nil
	if IsTrue(IsArray(object)) {
		paramsKeys = object
	} else {
		var sorted interface{} = this.Keysort(object)
		paramsKeys = ObjectKeys(sorted)
	}
	for i := 0; IsLessThan(i, GetArrayLength(paramsKeys)); i++ {
		var key interface{} = GetValue(paramsKeys, i)
		returnString = Add(returnString, key)
		var value interface{} = GetValue(object, key)
		if IsTrue(IsEqual(value, "undefined")) {
			returnString = Add(returnString, "null")
		} else if IsTrue(IsArray(value)) {
			for j := 0; IsLessThan(j, GetArrayLength(value)); j++ {
				returnString = Add(returnString, this.ParamsToString(GetValue(value, j), Add(level, 1)))
			}
		} else {
			returnString = Add(returnString, ToString(value))
		}
	}
	return returnString
}

/**
 * @method
 * @name cryptocom#closePositions
 * @description closes open positions for a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-close-position
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} [side] not used by cryptocom.closePositions
 * @param {object} [params] extra parameters specific to the okx api endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.type] LIMIT or MARKET
 * @param {number} [params.price] for limit orders only
 * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *CryptocomCore) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes33758 := (<-this.LoadMarkets())
		PanicOnError(retRes33758)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
			"type":            "MARKET",
		}
		var typeVar interface{} = this.SafeStringUpper(params, "type")
		var price interface{} = this.SafeString(params, "price")
		if IsTrue(!IsEqual(typeVar, nil)) {
			AddElementToObject(request, "type", typeVar)
		}
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "price", this.PriceToPrecision(GetValue(market, "symbol"), price))
		}

		response := (<-this.V1PrivatePostPrivateClosePosition(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "id" : 1700830813298,
		//        "method" : "private/close-position",
		//        "code" : 0,
		//        "result" : {
		//            "client_oid" : "179a909d-5614-655b-0d0e-9e85c9a25c85",
		//            "order_id" : "6142909897021751347"
		//        }
		//    }
		//
		var result interface{} = this.SafeDict(response, "result")

		ch <- this.ParseOrder(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-instrument-fee-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *CryptocomCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes34158 := (<-this.LoadMarkets())
		PanicOnError(retRes34158)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instrument_name": GetValue(market, "id"),
		}

		response := (<-this.V1PrivatePostPrivateGetInstrumentFeeRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "id": 1,
		//        "code": 0,
		//        "method": "private/staking/unstake",
		//        "result": {
		//          "staking_id": "1",
		//          "instrument_name": "SOL.staked",
		//          "status": "NEW",
		//          "quantity": "1",
		//          "underlying_inst_name": "SOL",
		//          "reason": "NO_ERROR"
		//        }
		//    }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseTradingFee(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptocom#fetchTradingFees
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-get-fee-rate
 * @description fetch the trading fees for multiple markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure} indexed by market symbols
 */
func (this *CryptocomCore) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes34498 := (<-this.LoadMarkets())
		PanicOnError(retRes34498)

		response := (<-this.V1PrivatePostPrivateGetFeeRate(params))
		PanicOnError(response)
		//
		//   {
		//       "id": 1,
		//       "method": "/private/get-fee-rate",
		//       "code": 0,
		//       "result": {
		//         "spot_tier": "3",
		//         "deriv_tier": "3",
		//         "effective_spot_maker_rate_bps": "6.5",
		//         "effective_spot_taker_rate_bps": "6.9",
		//         "effective_deriv_maker_rate_bps": "1.1",
		//         "effective_deriv_taker_rate_bps": "3"
		//       }
		//   }
		//
		var result interface{} = this.SafeDict(response, "result", map[string]interface{}{})

		ch <- this.ParseTradingFees(result)
		return nil

	}()
	return ch
}
func (this *CryptocomCore) ParseTradingFees(response interface{}) interface{} {
	//
	// {
	//         "spot_tier": "3",
	//         "deriv_tier": "3",
	//         "effective_spot_maker_rate_bps": "6.5",
	//         "effective_spot_taker_rate_bps": "6.9",
	//         "effective_deriv_maker_rate_bps": "1.1",
	//         "effective_deriv_taker_rate_bps": "3"
	//  }
	//
	var result interface{} = map[string]interface{}{}
	AddElementToObject(result, "info", response)
	for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
		var symbol interface{} = GetValue(this.Symbols, i)
		var market interface{} = this.Market(symbol)
		var isSwap interface{} = GetValue(market, "swap")
		var takerFeeKey interface{} = Ternary(IsTrue(isSwap), "effective_deriv_taker_rate_bps", "effective_spot_taker_rate_bps")
		var makerFeeKey interface{} = Ternary(IsTrue(isSwap), "effective_deriv_maker_rate_bps", "effective_spot_maker_rate_bps")
		var tradingFee interface{} = map[string]interface{}{
			"info":       response,
			"symbol":     symbol,
			"maker":      this.ParseNumber(Precise.StringDiv(this.SafeString(response, makerFeeKey), "10000")),
			"taker":      this.ParseNumber(Precise.StringDiv(this.SafeString(response, takerFeeKey), "10000")),
			"percentage": nil,
			"tierBased":  nil,
		}
		AddElementToObject(result, symbol, tradingFee)
	}
	return result
}
func (this *CryptocomCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {
	//      "instrument_name": "BTC_USD",
	//      "effective_maker_rate_bps": "6.5",
	//      "effective_taker_rate_bps": "6.9"
	// }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(fee, "instrument_name")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	return map[string]interface{}{
		"info":       fee,
		"symbol":     symbol,
		"maker":      this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "effective_maker_rate_bps"), "10000")),
		"taker":      this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "effective_taker_rate_bps"), "10000")),
		"percentage": nil,
		"tierBased":  nil,
	}
}
func (this *CryptocomCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var typeVar interface{} = this.SafeString(api, 0)
	var access interface{} = this.SafeString(api, 1)
	var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), typeVar), "/"), path)
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	if IsTrue(IsEqual(access, "public")) {
		if IsTrue(GetArrayLength(ObjectKeys(query))) {
			url = Add(url, Add("?", this.Urlencode(query)))
		}
	} else {
		this.CheckRequiredCredentials()
		var nonce interface{} = ToString(this.Nonce())
		var requestParams interface{} = this.Extend(map[string]interface{}{}, params)
		var paramsKeys interface{} = ObjectKeys(requestParams)
		var strSortKey interface{} = this.ParamsToString(requestParams, 0)
		var payload interface{} = Add(Add(Add(Add(path, nonce), this.ApiKey), strSortKey), nonce)
		var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256)
		var paramsKeysLength interface{} = GetArrayLength(paramsKeys)
		body = this.Json(map[string]interface{}{
			"id":      nonce,
			"method":  path,
			"params":  params,
			"api_key": this.ApiKey,
			"sig":     signature,
			"nonce":   nonce,
		})
		// fix issue https://github.com/ccxt/ccxt/issues/11179
		// php always encodes dictionaries as arrays
		// if an array is empty, php will put it in square brackets
		// python and js will put it in curly brackets
		// the code below checks and replaces those brackets in empty requests
		if IsTrue(IsEqual(paramsKeysLength, 0)) {
			var paramsString interface{} = "{}"
			var arrayString interface{} = "[]"
			body = Replace(body, arrayString, paramsString)
		}
		headers = map[string]interface{}{
			"Content-Type": "application/json",
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *CryptocomCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	var errorCode interface{} = this.SafeString(response, "code")
	if IsTrue(!IsEqual(errorCode, "0")) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
		panic(ExchangeError(Add(Add(this.Id, " "), body)))
	}
	return nil
}

func (this *CryptocomCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
