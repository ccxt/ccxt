package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type backpack struct {
	Exchange
}

func NewBackpackCore() *backpack {
	p := &backpack{}
	setDefaults(p)
	return p
}

func (this *backpack) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "backpack",
		"name":      "Backpack",
		"countries": []interface{}{"JP"},
		"rateLimit": 50,
		"version":   "v1",
		"certified": false,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               true,
			"swap":                                 true,
			"future":                               false,
			"option":                               false,
			"addMargin":                            false,
			"cancelAllOrders":                      true,
			"cancelAllOrdersAfter":                 false,
			"cancelOrder":                          true,
			"cancelOrders":                         false,
			"cancelWithdraw":                       false,
			"closePosition":                        false,
			"createConvertTrade":                   false,
			"createDepositAddress":                 false,
			"createLimitBuyOrder":                  true,
			"createLimitOrder":                     true,
			"createLimitSellOrder":                 true,
			"createMarketBuyOrder":                 true,
			"createMarketBuyOrderWithCost":         true,
			"createMarketOrder":                    true,
			"createMarketOrderWithCost":            true,
			"createMarketSellOrder":                true,
			"createMarketSellOrderWithCost":        true,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createPostOnlyOrder":                  true,
			"createReduceOnlyOrder":                true,
			"createStopLossOrder":                  false,
			"createTakeProfitOrder":                false,
			"createTrailingAmountOrder":            false,
			"createTrailingPercentOrder":           false,
			"createTriggerOrder":                   true,
			"fetchAccounts":                        false,
			"fetchBalance":                         true,
			"fetchCanceledAndClosedOrders":         false,
			"fetchCanceledOrders":                  false,
			"fetchClosedOrder":                     false,
			"fetchClosedOrders":                    false,
			"fetchConvertCurrencies":               false,
			"fetchConvertQuote":                    false,
			"fetchConvertTrade":                    false,
			"fetchConvertTradeHistory":             false,
			"fetchCurrencies":                      true,
			"fetchDepositAddress":                  true,
			"fetchDeposits":                        true,
			"fetchDepositsWithdrawals":             false,
			"fetchDepositWithdrawFees":             false,
			"fetchFundingHistory":                  true,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    false,
			"fetchIndexOHLCV":                      true,
			"fetchLedger":                          false,
			"fetchLeverage":                        false,
			"fetchLeverageTiers":                   false,
			"fetchMarginAdjustmentHistory":         false,
			"fetchMarginMode":                      false,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       true,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    true,
			"fetchOpenInterestHistory":             true,
			"fetchOpenOrder":                       true,
			"fetchOpenOrders":                      true,
			"fetchOrder":                           false,
			"fetchOrderBook":                       true,
			"fetchOrders":                          true,
			"fetchOrderTrades":                     false,
			"fetchPosition":                        false,
			"fetchPositionHistory":                 false,
			"fetchPositionMode":                    false,
			"fetchPositions":                       true,
			"fetchPositionsForSymbol":              false,
			"fetchPositionsHistory":                false,
			"fetchPremiumIndexOHLCV":               false,
			"fetchStatus":                          true,
			"fetchTicker":                          true,
			"fetchTickers":                         true,
			"fetchTime":                            true,
			"fetchTrades":                          true,
			"fetchTradingFee":                      false,
			"fetchTradingFees":                     false,
			"fetchTransactions":                    false,
			"fetchTransfers":                       false,
			"fetchWithdrawals":                     true,
			"reduceMargin":                         false,
			"sandbox":                              false,
			"setLeverage":                          false,
			"setMargin":                            false,
			"setMarginMode":                        false,
			"setPositionMode":                      false,
			"transfer":                             false,
			"withdraw":                             true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15":  "15m",
			"30":  "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"8h":  "8h",
			"12h": "12h",
			"1d":  "1d",
			"3d":  "3d",
			"1w":  "1w",
			"1M":  "1month",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/cc04c278-679f-4554-9f72-930dd632b80f",
			"api": map[string]interface{}{
				"public":  "https://api.backpack.exchange",
				"private": "https://api.backpack.exchange",
			},
			"www":      "https://backpack.exchange/",
			"doc":      "https://docs.backpack.exchange/",
			"referral": "https://backpack.exchange/join/ib8qxwyl",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/assets":                     1,
					"api/v1/collateral":                 1,
					"api/v1/borrowLend/markets":         1,
					"api/v1/borrowLend/markets/history": 1,
					"api/v1/markets":                    1,
					"api/v1/market":                     1,
					"api/v1/ticker":                     1,
					"api/v1/tickers":                    1,
					"api/v1/depth":                      1,
					"api/v1/klines":                     1,
					"api/v1/markPrices":                 1,
					"api/v1/openInterest":               1,
					"api/v1/fundingRates":               1,
					"api/v1/status":                     1,
					"api/v1/ping":                       1,
					"api/v1/time":                       1,
					"api/v1/wallets":                    1,
					"api/v1/trades":                     1,
					"api/v1/trades/history":             1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/account":                       1,
					"api/v1/account/limits/borrow":         1,
					"api/v1/account/limits/order":          1,
					"api/v1/account/limits/withdrawal":     1,
					"api/v1/borrowLend/positions":          1,
					"api/v1/capital":                       1,
					"api/v1/capital/collateral":            1,
					"wapi/v1/capital/deposits":             1,
					"wapi/v1/capital/deposit/address":      1,
					"wapi/v1/capital/withdrawals":          1,
					"api/v1/position":                      1,
					"wapi/v1/history/borrowLend":           1,
					"wapi/v1/history/interest":             1,
					"wapi/v1/history/borrowLend/positions": 1,
					"wapi/v1/history/dust":                 1,
					"wapi/v1/history/fills":                1,
					"wapi/v1/history/funding":              1,
					"wapi/v1/history/orders":               1,
					"wapi/v1/history/rfq":                  1,
					"wapi/v1/history/quote":                1,
					"wapi/v1/history/settlement":           1,
					"wapi/v1/history/strategies":           1,
					"api/v1/order":                         1,
					"api/v1/orders":                        1,
				},
				"post": map[string]interface{}{
					"api/v1/account/convertDust":  1,
					"api/v1/borrowLend":           1,
					"wapi/v1/capital/withdrawals": 1,
					"api/v1/order":                1,
					"api/v1/orders":               1,
					"api/v1/rfq":                  1,
					"api/v1/rfq/accept":           1,
					"api/v1/rfq/refresh":          1,
					"api/v1/rfq/cancel":           1,
					"api/v1/rfq/quote":            1,
				},
				"delete": map[string]interface{}{
					"api/v1/order":  1,
					"api/v1/orders": 1,
				},
				"patch": map[string]interface{}{
					"api/v1/account": 1,
				},
			},
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           false,
					"stopLossPrice":              true,
					"takeProfitPrice":            true,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"GTC": true,
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": true,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": map[string]interface{}{
					"max": 20,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       nil,
					"untilDays":      nil,
					"symbolRequired": false,
				},
				"fetchOrder": nil,
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       nil,
					"untilDays":      nil,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchClosedOrders": nil,
				"fetchOHLCV": map[string]interface{}{
					"paginate": false,
					"limit":    1000,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"swap": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey": true,
			"secret": true,
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"instructions": map[string]interface{}{
				"api/v1/account": map[string]interface{}{
					"GET":   "accountQuery",
					"PATCH": "accountUpdate",
				},
				"api/v1/capital": map[string]interface{}{
					"GET": "balanceQuery",
				},
				"api/v1/account/limits/borrow": map[string]interface{}{
					"GET": "maxBorrowQuantity",
				},
				"api/v1/account/limits/order": map[string]interface{}{
					"GET": "maxOrderQuantity",
				},
				"api/v1/account/limits/withdrawal": map[string]interface{}{
					"GET": "maxWithdrawalQuantity",
				},
				"api/v1/borrowLend/positions": map[string]interface{}{
					"GET": "borrowLendPositionQuery",
				},
				"api/v1/borrowLend": map[string]interface{}{
					"POST": "borrowLendExecute",
				},
				"wapi/v1/history/borrowLend/positions": map[string]interface{}{
					"GET": "borrowPositionHistoryQueryAll",
				},
				"wapi/v1/history/borrowLend": map[string]interface{}{
					"GET": "borrowHistoryQueryAll",
				},
				"wapi/v1/history/dust": map[string]interface{}{
					"GET": "dustHistoryQueryAll",
				},
				"api/v1/capital/collateral": map[string]interface{}{
					"GET": "collateralQuery",
				},
				"wapi/v1/capital/deposit/address": map[string]interface{}{
					"GET": "depositAddressQuery",
				},
				"wapi/v1/capital/deposits": map[string]interface{}{
					"GET": "depositQueryAll",
				},
				"wapi/v1/history/fills": map[string]interface{}{
					"GET": "fillHistoryQueryAll",
				},
				"wapi/v1/history/funding": map[string]interface{}{
					"GET": "fundingHistoryQueryAll",
				},
				"wapi/v1/history/interest": map[string]interface{}{
					"GET": "interestHistoryQueryAll",
				},
				"api/v1/order": map[string]interface{}{
					"GET":    "orderQuery",
					"POST":   "orderExecute",
					"DELETE": "orderCancel",
				},
				"api/v1/orders": map[string]interface{}{
					"GET":    "orderQueryAll",
					"POST":   "orderExecute",
					"DELETE": "orderCancelAll",
				},
				"wapi/v1/history/orders": map[string]interface{}{
					"GET": "orderHistoryQueryAll",
				},
				"wapi/v1/history/pnl": map[string]interface{}{
					"GET": "pnlHistoryQueryAll",
				},
				"wapi/v1/history/rfq": map[string]interface{}{
					"GET": "rfqHistoryQueryAll",
				},
				"wapi/v1/history/quote": map[string]interface{}{
					"GET": "quoteHistoryQueryAll",
				},
				"wapi/v1/history/settlement": map[string]interface{}{
					"GET": "settlementHistoryQueryAll",
				},
				"api/v1/position": map[string]interface{}{
					"GET": "positionQuery",
				},
				"api/v1/rfq/quote": map[string]interface{}{
					"POST": "quoteSubmit",
				},
				"wapi/v1/history/strategies": map[string]interface{}{
					"GET": "strategyHistoryQueryAll",
				},
				"wapi/v1/capital/withdrawals": map[string]interface{}{
					"GET":  "withdrawalQueryAll",
					"POST": "withdraw",
				},
			},
			"recvWindow":                    5000,
			"brokerId":                      "",
			"currencyIdsListForParseMarket": nil,
			"broker":                        "",
			"timeDifference":                0,
			"adjustForTimeDifference":       false,
			"networks": map[string]interface{}{
				"APT":         "Aptos",
				"ARB":         "Arbitrum",
				"AVAX":        "Avalanche",
				"BASE":        "Base",
				"BERA":        "Berachain",
				"BTC":         "Bitcoin",
				"BCH":         "BitcoinCash",
				"BSC":         "Bsc",
				"ADA":         "Cardano",
				"DOGE":        "Dogecoin",
				"ECLIPSE":     "Eclipse",
				"EQUALSMONEY": "EqualsMoney",
				"ERC20":       "Ethereum",
				"HYP":         "Hyperliquid",
				"LTC":         "Litecoin",
				"OPTIMISM":    "Optimism",
				"MATIC":       "Polygon",
				"SEI":         "Sei",
				"SUI":         "Sui",
				"SOL":         "Solana",
				"STORY":       "Story",
				"TRC20":       "Tron",
				"XRP":         "XRP",
			},
			"networksById": map[string]interface{}{
				"aptos":       "APT",
				"arbitrum":    "ARB",
				"avalanche":   "AVAX",
				"base":        "BASE",
				"berachain":   "BERA",
				"bitcoin":     "BTC",
				"bitcoincash": "BCH",
				"bsc":         "BSC",
				"cardano":     "ADA",
				"dogecoin":    "DOGE",
				"eclipse":     "ECLIPSE",
				"equalsmoney": "EQUALSMONEY",
				"ethereum":    "ERC20",
				"hyperliquid": "HYP",
				"litecoin":    "LTC",
				"optimism":    "OPTIMISM",
				"polygon":     "MATIC",
				"sei":         "SEI",
				"sui":         "SUI",
				"solana":      "SOL",
				"story":       "STORY",
				"tron":        "TRC20",
				"xrp":         "XRP",
			},
		},
		"commonCurrencies": map[string]interface{}{},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"INVALID_CLIENT_REQUEST":      BadRequest,
				"INVALID_ORDER":               InvalidOrder,
				"ACCOUNT_LIQUIDATING":         BadRequest,
				"BORROW_LIMIT":                BadRequest,
				"BORROW_REQUIRES_LEND_REDEEM": BadRequest,
				"FORBIDDEN":                   OperationRejected,
				"INSUFFICIENT_FUNDS":          InsufficientFunds,
				"INSUFFICIENT_MARGIN":         InsufficientFunds,
				"INSUFFICIENT_SUPPLY":         InsufficientFunds,
				"INVALID_ASSET":               BadRequest,
				"INVALID_MARKET":              BadSymbol,
				"INVALID_PRICE":               BadRequest,
				"INVALID_POSITION_ID":         BadRequest,
				"INVALID_QUANTITY":            BadRequest,
				"INVALID_RANGE":               BadRequest,
				"INVALID_SIGNATURE":           AuthenticationError,
				"INVALID_SOURCE":              BadRequest,
				"INVALID_SYMBOL":              BadSymbol,
				"INVALID_TWO_FACTOR_CODE":     BadRequest,
				"LEND_LIMIT":                  BadRequest,
				"LEND_REQUIRES_BORROW_REPAY":  BadRequest,
				"MAINTENANCE":                 ExchangeError,
				"MAX_LEVERAGE_REACHED":        InsufficientFunds,
				"NOT_IMPLEMENTED":             OperationFailed,
				"ORDER_LIMIT":                 OperationRejected,
				"POSITION_LIMIT":              OperationRejected,
				"PRECONDITION_FAILED":         OperationFailed,
				"RESOURCE_NOT_FOUND":          ExchangeNotAvailable,
				"SERVER_ERROR":                NetworkError,
				"TIMEOUT":                     RequestTimeout,
				"TOO_MANY_REQUESTS":           RateLimitExceeded,
				"TRADING_PAUSED":              ExchangeNotAvailable,
				"UNAUTHORIZED":                AuthenticationError,
			},
			"broad": map[string]interface{}{},
		},
	})
}

/**
 * @method
 * @name backpack#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.backpack.exchange/#tag/Assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *backpack) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetApiV1Assets(params))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "coingeckoId": "jito-governance-token",
		//             "displayName": "Jito",
		//             "symbol": "JTO",
		//             "tokens": [
		//                 {
		//                     "blockchain": "Solana",
		//                     "contractAddress": "jtojtomepa8beP8AuQc6eXt5FriJwfFMwQx2v2f9mCL",
		//                     "depositEnabled": true,
		//                     "displayName": "Jito",
		//                     "maximumWithdrawal": null,
		//                     "minimumDeposit": "0.29",
		//                     "minimumWithdrawal": "0.58",
		//                     "withdrawEnabled": true,
		//                     "withdrawalFee": "0.29"
		//                 }
		//             ]
		//         }
		//         ...
		//     ]
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var currecy interface{} = GetValue(response, i)
			var currencyId interface{} = this.SafeString(currecy, "symbol")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var networks interface{} = this.SafeList(currecy, "tokens", []interface{}{})
			var parsedNetworks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
				var network interface{} = GetValue(networks, j)
				var networkId interface{} = this.SafeString(network, "blockchain")
				var networkIdLowerCase interface{} = this.SafeStringLower(network, "blockchain")
				var networkCode interface{} = this.NetworkIdToCode(networkIdLowerCase)
				AddElementToObject(parsedNetworks, networkCode, map[string]interface{}{
					"id":      networkId,
					"network": networkCode,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(network, "minimumWithdrawal"),
							"max": this.ParseNumber(this.OmitZero(this.SafeString(network, "maximumWithdrawal"))),
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(network, "minimumDeposit"),
							"max": nil,
						},
					},
					"active":    nil,
					"deposit":   this.SafeBool(network, "depositEnabled"),
					"withdraw":  this.SafeBool(network, "withdrawEnabled"),
					"fee":       this.SafeNumber(network, "withdrawalFee"),
					"precision": nil,
					"info":      network,
				})
			}
			var active interface{} = nil
			var deposit interface{} = nil
			var withdraw interface{} = nil
			if IsTrue(this.IsEmpty(parsedNetworks)) {
				active = false
				deposit = false
				withdraw = false
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        currencyId,
				"code":      code,
				"precision": nil,
				"type":      "crypto",
				"name":      this.SafeString(currecy, "displayName"),
				"active":    active,
				"deposit":   deposit,
				"withdraw":  withdraw,
				"fee":       nil,
				"limits": map[string]interface{}{
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"networks": parsedNetworks,
				"info":     currecy,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchMarkets
 * @description retrieves data on all markets for bitbank
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *backpack) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes60212 := (<-this.LoadTimeDifference())
			PanicOnError(retRes60212)
		}

		response := (<-this.PublicGetApiV1Markets(params))
		PanicOnError(response)

		ch <- this.ParseMarkets(response)
		return nil

	}()
	return ch
}
func (this *backpack) ParseMarket(market interface{}) interface{} {
	//
	//     [
	//         {
	//             "baseSymbol": "SOL",
	//             "createdAt": "2025-01-21T06:34:54.691858",
	//             "filters": {
	//                 "price": {
	//                     "borrowmarketFeeMaxMultiplier": null,
	//                     "borrowmarketFeeMinMultiplier": null,
	//                     "maxImpactMultiplier": "1.03",
	//                     "maxMultiplier": "1.25",
	//                     "maxPrice": null,
	//                     "meanMarkPriceBand": {
	//                         "maxMultiplier": "1.15",
	//                         "minMultiplier": "0.9"
	//                     },
	//                     "meanPremiumBand": null,
	//                     "minImpactMultiplier": "0.97",
	//                     "minMultiplier": "0.75",
	//                     "minPrice": "0.01",
	//                     "tickSize": "0.01"
	//                 },
	//                 "quantity": {
	//                     "maxQuantity": null,
	//                     "minQuantity": "0.01",
	//                     "stepSize": "0.01"
	//                 }
	//             },
	//             "fundingInterval": 28800000,
	//             "fundingRateLowerBound": null,
	//             "fundingRateUpperBound": null,
	//             "imfFunction": null,
	//             "marketType": "SPOT",
	//             "mmfFunction": null,
	//             "openInterestLimit": "0",
	//             "orderBookState": "Open",
	//             "quoteSymbol": "USDC",
	//             "symbol": "SOL_USDC"
	//         },
	//         {
	//             "baseSymbol": "SOL",
	//             "createdAt": "2025-01-21T06:34:54.691858",
	//             "filters": {
	//                 "price": {
	//                     "borrowEntryFeeMaxMultiplier": null,
	//                     "borrowEntryFeeMinMultiplier": null,
	//                     "maxImpactMultiplier": "1.03",
	//                     "maxMultiplier": "1.25",
	//                     "maxPrice": "1000",
	//                     "meanMarkPriceBand": {
	//                         "maxMultiplier": "1.1",
	//                         "minMultiplier": "0.9"
	//                     },
	//                     "meanPremiumBand": {
	//                         "tolerancePct": "0.05"
	//                     },
	//                     "minImpactMultiplier": "0.97",
	//                     "minMultiplier": "0.75",
	//                     "minPrice": "0.01",
	//                     "tickSize": "0.01"
	//                 },
	//                 "quantity": {
	//                     "maxQuantity": null,
	//                     "minQuantity": "0.01",
	//                     "stepSize": "0.01"
	//                 }
	//             },
	//             "fundingInterval": "28800000",
	//             "fundingRateLowerBound": "-100",
	//             "fundingRateUpperBound": "100",
	//             "imfFunction": {
	//                 "base": "0.02",
	//                 "factor": "0.0001275",
	//                 "type": "sqrt"
	//             },
	//             "marketType": "PERP",
	//             "mmfFunction": {
	//                 "base": "0.0125",
	//                 "factor": "0.0000765",
	//                 "type": "sqrt"
	//             },
	//             "openInterestLimit": "4000000",
	//             "orderBookState": "Open",
	//             "quoteSymbol": "USDC",
	//             "symbol": "SOL_USDC_PERP"
	//         }
	//     ]
	//
	var id interface{} = this.SafeString(market, "symbol")
	var baseId interface{} = this.SafeString(market, "baseSymbol")
	var quoteId interface{} = this.SafeString(market, "quoteSymbol")
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	var filters interface{} = this.SafeDict(market, "filters", map[string]interface{}{})
	var priceFilter interface{} = this.SafeDict(filters, "price", map[string]interface{}{})
	var maxPrice interface{} = this.SafeNumber(priceFilter, "maxPrice")
	var minPrice interface{} = this.SafeNumber(priceFilter, "minPrice")
	var pricePrecision interface{} = this.SafeNumber(priceFilter, "tickSize")
	var quantityFilter interface{} = this.SafeDict(filters, "quantity", map[string]interface{}{})
	var maxQuantity interface{} = this.SafeNumber(quantityFilter, "maxQuantity")
	var minQuantity interface{} = this.SafeNumber(quantityFilter, "minQuantity")
	var amountPrecision interface{} = this.SafeNumber(quantityFilter, "stepSize")
	var typeVar interface{} = nil
	var typeOfMarket interface{} = this.ParseMarketType(this.SafeString(market, "marketType"))
	var linear interface{} = nil
	var inverse interface{} = nil
	var settle interface{} = nil
	var settleId interface{} = nil
	var contractSize interface{} = nil
	if IsTrue(IsEqual(typeOfMarket, "spot")) {
		typeVar = "spot"
	} else if IsTrue(IsEqual(typeOfMarket, "swap")) {
		typeVar = "swap"
		linear = true
		inverse = false
		settleId = this.SafeString(market, "quoteSymbol")
		settle = this.SafeCurrencyCode(settleId)
		symbol = Add(symbol, Add(":", settle))
		contractSize = 1
	}
	var orderBookState interface{} = this.SafeString(market, "orderBookState")
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           typeVar,
		"spot":           IsEqual(typeVar, "spot"),
		"margin":         IsEqual(typeVar, "spot"),
		"swap":           IsEqual(typeVar, "swap"),
		"future":         false,
		"option":         false,
		"active":         IsEqual(orderBookState, "Open"),
		"contract":       !IsEqual(typeVar, "spot"),
		"linear":         linear,
		"inverse":        inverse,
		"taker":          nil,
		"maker":          nil,
		"contractSize":   contractSize,
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": amountPrecision,
			"price":  pricePrecision,
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"amount": map[string]interface{}{
				"min": minQuantity,
				"max": maxQuantity,
			},
			"price": map[string]interface{}{
				"min": minPrice,
				"max": maxPrice,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"created": this.Parse8601(this.SafeString(market, "createdAt")),
		"info":    market,
	})
}
func (this *backpack) ParseMarketType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"SPOT": "spot",
		"PERP": "swap",
	}
	return this.SafeString(types, typeVar, typeVar)
}

/**
 * @method
 * @name backpack#fetchTickers
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_tickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *backpack) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8078 := (<-this.LoadMarkets())
		PanicOnError(retRes8078)
		var request interface{} = map[string]interface{}{}

		response := (<-this.PublicGetApiV1Tickers(this.Extend(request, params)))
		PanicOnError(response)
		var tickers interface{} = this.ParseTickers(response)

		ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *backpack) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8248 := (<-this.LoadMarkets())
		PanicOnError(retRes8248)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetApiV1Ticker(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTicker(response, market)
		return nil

	}()
	return ch
}
func (this *backpack) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTicker/fetchTickers
	//
	//     {
	//         "firstPrice": "327.38",
	//         "high": "337.99",
	//         "lastPrice": "317.14",
	//         "low": "300.01",
	//         "priceChange": "-10.24",
	//         "priceChangePercent": "-0.031279",
	//         "quoteVolume": "21584.32278",
	//         "symbol": "AAVE_USDC",
	//         "trades": "245",
	//         "volume": "65.823"
	//     }, ...
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var open interface{} = this.SafeString(ticker, "firstPrice")
	var last interface{} = this.SafeString(ticker, "lastPrice")
	var high interface{} = this.SafeString(ticker, "high")
	var low interface{} = this.SafeString(ticker, "low")
	var baseVolume interface{} = this.SafeString(ticker, "volume")
	var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume")
	var percentage interface{} = this.SafeString(ticker, "priceChangePercent")
	var change interface{} = this.SafeString(ticker, "priceChange")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     nil,
		"datetime":      nil,
		"high":          high,
		"low":           low,
		"bid":           nil,
		"bidVolume":     nil,
		"ask":           nil,
		"askVolume":     nil,
		"vwap":          nil,
		"open":          open,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        change,
		"percentage":    percentage,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"markPrice":     nil,
		"indexPrice":    nil,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name backpack#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func (this *backpack) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8988 := (<-this.LoadMarkets())
		PanicOnError(retRes8988)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetApiV1Depth(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "asks": [
		//             ["118318.3","0.00633"],
		//             ["118567.2","0.08450"]
		//         ],
		//         "bids": [
		//             ["1.0","0.38647"],
		//             ["12.9","1.00000"]
		//         ],
		//         "lastUpdateId":"1504999670",
		//         "timestamp":1753102447307501
		//     }
		//
		var microseconds interface{} = this.SafeInteger(response, "timestamp")
		var timestamp interface{} = this.ParseToInt(Divide(microseconds, 1000))
		var orderbook interface{} = this.ParseOrderBook(response, symbol, timestamp)
		AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))

		ch <- orderbook
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_klines
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in seconds of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (default 100)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *backpack) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes9388 := (<-this.LoadMarkets())
		PanicOnError(retRes9388)
		var market interface{} = this.Market(symbol)
		var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": interval,
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", this.ParseToInt(Divide(until, 1000))) // convert milliseconds to seconds
		}
		var defaultLimit interface{} = 100
		if IsTrue(IsEqual(since, nil)) {
			if IsTrue(IsEqual(limit, nil)) {
				limit = defaultLimit
			}
			var duration interface{} = this.ParseTimeframe(timeframe)
			var endTime interface{} = Ternary(IsTrue(until), this.ParseToInt(Divide(until, 1000)), this.Seconds())
			var startTime interface{} = Subtract(endTime, (Multiply(limit, duration)))
			AddElementToObject(request, "startTime", startTime)
		} else {
			AddElementToObject(request, "startTime", this.ParseToInt(Divide(since, 1000))) // convert milliseconds to seconds
		}
		var price interface{} = this.SafeString(params, "price")
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "priceType", this.Capitalize(price))
			params = this.Omit(params, "price")
		}

		response := (<-this.PublicGetApiV1Klines(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *backpack) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         {
	//             "close": "118294.6",
	//             "end": "2025-07-19 13:12:00",
	//             "high": "118297.6",
	//             "low": "118237.5",
	//             "open": "118238",
	//             "quoteVolume": "4106.558156",
	//             "start": "2025-07-19 13:09:00",
	//             "trades": "12",
	//             "volume": "0.03473"
	//         },
	//         ...
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.Parse8601(this.SafeString(ohlcv, "start")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}

/**
 * @method
 * @name backpack#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_mark_prices
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *backpack) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes10088 := (<-this.LoadMarkets())
		PanicOnError(retRes10088)
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "spot")) {
			panic(BadRequest(Add(Add(this.Id, " fetchFundingRate() symbol does not support market "), symbol)))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetApiV1MarkPrices(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, 0, map[string]interface{}{})

		ch <- this.ParseFundingRate(data, market)
		return nil

	}()
	return ch
}
func (this *backpack) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "fundingRate": "0.0001",
	//         "indexPrice": "118333.18643195",
	//         "markPrice": "118343.51853741",
	//         "nextFundingTimestamp": 1753113600000,
	//         "symbol": "BTC_USDC_PERP"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextFundingTimestamp")
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                this.SafeNumber(contract, "markPrice"),
		"indexPrice":               this.SafeNumber(contract, "indexPrice"),
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              this.SafeNumber(contract, "fundingRate"),
		"fundingTimestamp":         nil,
		"fundingDatetime":          nil,
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nextFundingTimestamp,
		"nextFundingDatetime":      this.Iso8601(nextFundingTimestamp),
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 "1h",
	}
}

/**
 * @method
 * @name backpack#fetchOpenInterest
 * @description Retrieves the open interest of a derivative trading pair
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_open_interest
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
 */
func (this *backpack) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes10678 := (<-this.LoadMarkets())
		PanicOnError(retRes10678)
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "spot")) {
			panic(BadRequest(Add(Add(this.Id, " fetchOpenInterest() symbol does not support market "), symbol)))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetApiV1OpenInterest(this.Extend(request, params)))
		PanicOnError(response)
		var interest interface{} = this.SafeDict(response, 0, map[string]interface{}{})

		ch <- this.ParseOpenInterest(interest, market)
		return nil

	}()
	return ch
}
func (this *backpack) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         {
	//             "openInterest": "1273.85214",
	//             "symbol": "BTC_USDC_PERP",
	//             "timestamp":1753105735301
	//         }
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(interest, "timestamp")
	var openInterest interface{} = this.SafeNumber(interest, "openInterest")
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             GetValue(market, "symbol"),
		"openInterestAmount": nil,
		"openInterestValue":  openInterest,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"info":               interest,
	}, market)
}

/**
 * @method
 * @name backpack#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.backpack.exchange/#tag/Markets/operation/get_funding_interval_rates
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of funding rate structures
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *backpack) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes11178 := (<-this.LoadMarkets())
		PanicOnError(retRes11178)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", mathMin(limit, 1000)) // api maximum 1000
		}

		response := (<-this.PublicGetApiV1FundingRates(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "fundingRate": "0.0001",
		//             "intervalEndTimestamp": "2025-07-22T00:00:00",
		//             "symbol": "BTC_USDC_PERP"
		//         }
		//     ]
		//
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var rate interface{} = GetValue(response, i)
			var datetime interface{} = this.SafeString(rate, "intervalEndTimestamp")
			var timestamp interface{} = this.Parse8601(datetime)
			AppendToArray(&rates, map[string]interface{}{
				"info":        rate,
				"symbol":      GetValue(market, "symbol"),
				"fundingRate": this.SafeNumber(rate, "fundingRate"),
				"timestamp":   timestamp,
				"datetime":    datetime,
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.backpack.exchange/#tag/Trades/operation/get_recent_trades
 * @see https://docs.backpack.exchange/#tag/Trades/operation/get_historical_trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.offset] the number of trades to skip, default is 0
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *backpack) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes11668 := (<-this.LoadMarkets())
		PanicOnError(retRes11668)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", mathMin(limit, 1000)) // api maximum 1000
		}
		var response interface{} = nil
		var offset interface{} = this.SafeInteger(params, "offset")
		if IsTrue(!IsEqual(offset, nil)) {

			response = (<-this.PublicGetApiV1TradesHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicGetApiV1Trades(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.backpack.exchange/#tag/History/operation/get_fills
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 100, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {string} [params.fillType] 'User' (default) 'BookLiquidation' or 'Adl' or 'Backstop' or 'Liquidation' or 'AllLiquidation' or 'CollateralConversion' or 'CollateralConversionAndSpotLiquidation'
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *backpack) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11988 := (<-this.LoadMarkets())
		PanicOnError(retRes11988)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "from", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, []interface{}{"until"})
			AddElementToObject(request, "to", until)
		}
		var fillType interface{} = this.SafeString(params, "fillType")
		if IsTrue(IsEqual(fillType, nil)) {
			AddElementToObject(request, "fillType", "User") // default
		}

		response := (<-this.PrivateGetWapiV1HistoryFills(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *backpack) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//     {
	//         "id": 8721564,
	//         "isBuyerMaker": false,
	//         "price": "117427.6",
	//         "quantity": "0.00016",
	//         "quoteQuantity": "18.788416",
	//         "timestamp": 1753123916818
	//     }
	//
	// fetchMyTrades
	//     {
	//         "clientId": null,
	//         "fee": "0.004974",
	//         "feeSymbol": "USDC",
	//         "isMaker": false,
	//         "orderId": "4238907375",
	//         "price": "3826.15",
	//         "quantity": "0.0026",
	//         "side": "Bid",
	//         "symbol": "ETH_USDC_PERP",
	//         "systemOrderType": null,
	//         "timestamp": "2025-07-27T17:39:00.092",
	//         "tradeId": 9748827
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString2(trade, "id", "tradeId")
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	var price interface{} = this.SafeString(trade, "price")
	var amount interface{} = this.SafeString(trade, "quantity")
	var isMaker interface{} = this.SafeBool(trade, "isMaker")
	var takerOrMaker interface{} = Ternary(IsTrue(isMaker), "maker", "taker")
	var orderId interface{} = this.SafeString(trade, "orderId")
	var side interface{} = this.ParseOrderSide(this.SafeString(trade, "side"))
	var fee interface{} = nil
	var feeAmount interface{} = this.SafeString(trade, "fee")
	var timestamp interface{} = this.SafeInteger(trade, "timestamp")
	if IsTrue(!IsEqual(feeAmount, nil)) {
		// if fetchMyTrades
		var datetime interface{} = this.SafeString(trade, "timestamp")
		timestamp = this.Parse8601(datetime)
	}
	var feeSymbol interface{} = this.SafeCurrencyCode(this.SafeString(trade, "feeSymbol"))
	if IsTrue(!IsEqual(feeAmount, nil)) {
		fee = map[string]interface{}{
			"cost":     feeAmount,
			"currency": feeSymbol,
			"rate":     nil,
		}
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"id":           id,
		"order":        orderId,
		"type":         nil,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        price,
		"amount":       amount,
		"cost":         nil,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name backpack#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.backpack.exchange/#tag/System/operation/get_status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func (this *backpack) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetApiV1Status(params))
		PanicOnError(response)
		//
		//     {
		//         "message":null,
		//         "status":"Ok"
		//     }
		//
		var status interface{} = this.SafeString(response, "status")

		ch <- map[string]interface{}{
			"status":  ToLower(status),
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://developer-pro.bitmart.com/en/spot/#get-system-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *backpack) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetApiV1Time(params))
		PanicOnError(response)

		//
		//     1753131712992
		//
		ch <- this.SafeInteger(response, 0, this.Milliseconds())
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.backpack.exchange/#tag/Capital/operation/get_balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *backpack) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes13458 := (<-this.LoadMarkets())
		PanicOnError(retRes13458)

		response := (<-this.PrivateGetApiV1Capital(params))
		PanicOnError(response)

		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *backpack) ParseBalance(response interface{}) interface{} {
	//
	//     {
	//         "USDC": {
	//             "available": "120",
	//             "locked": "0",
	//             "staked": "0"
	//         }
	//     }
	//
	var balanceKeys interface{} = ObjectKeys(response)
	var result interface{} = map[string]interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(balanceKeys)); i++ {
		var id interface{} = GetValue(balanceKeys, i)
		var code interface{} = this.SafeCurrencyCode(id)
		var balance interface{} = GetValue(response, id)
		var account interface{} = this.Account()
		var locked interface{} = this.SafeString(balance, "locked")
		var staked interface{} = this.SafeString(balance, "staked")
		var used interface{} = Precise.StringAdd(locked, staked)
		AddElementToObject(account, "free", this.SafeString(balance, "available"))
		AddElementToObject(account, "used", used)
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name backpack#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.backpack.exchange/#tag/Capital/operation/get_deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *backpack) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes13908 := (<-this.LoadMarkets())
		PanicOnError(retRes13908)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "from", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 1000
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PrivateGetWapiV1CapitalDeposits(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.backpack.exchange/#tag/Capital/operation/get_withdrawals
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *backpack) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14258 := (<-this.LoadMarkets())
		PanicOnError(retRes14258)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "from", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "to", until)
		}

		response := (<-this.PrivateGetWapiV1CapitalWithdrawals(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#withdraw
 * @description make a withdrawal
 * @see https://docs.backpack.exchange/#tag/Capital/operation/request_withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the network to withdraw on (mandatory)
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *backpack) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14608 := (<-this.LoadMarkets())
		PanicOnError(retRes14608)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"symbol":  GetValue(currency, "id"),
			"amount":  this.NumberToString(amount),
			"address": address,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "clientId", tag) // memo or tag
		}
		networkCodequeryVariable := this.HandleNetworkCodeAndParams(params)
		networkCode := GetValue(networkCodequeryVariable, 0)
		query := GetValue(networkCodequeryVariable, 1)
		var networkId interface{} = this.NetworkCodeToId(networkCode)
		if IsTrue(IsEqual(networkId, nil)) {
			panic(BadRequest(Add(this.Id, " withdraw() requires a network parameter")))
		}
		AddElementToObject(request, "blockchain", networkId)

		response := (<-this.PrivatePostWapiV1CapitalWithdrawals(this.Extend(request, query)))
		PanicOnError(response)

		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}
func (this *backpack) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//     [
	//         {
	//             "createdAt": "2025-07-23T13:55:54.267",
	//             "fiatAmount": null,
	//             "fiatCurrency": null,
	//             "fromAddress": "0x2e3ab3e88a7dbdc763aadf5b28c18fb085af420a",
	//             "id": 6695353,
	//             "institutionBic": null,
	//             "platformMemo": null,
	//             "quantity": "120",
	//             "source": "ethereum",
	//             "status": "confirmed",
	//             "symbol": "USDC",
	//             "toAddress": "0xfBe7CbfCde93c8a4204a4be6B56732Eb32690170",
	//             "transactionHash": "0x58edaac415398d617b34c6673fffcaf0024990d5700565030119db5cbf3765d1"
	//         }
	//     ]
	//
	// withdraw
	//     {
	//         "accountIdentifier": null,
	//         "bankIdentifier": null,
	//         "bankName": null,
	//         "blockchain": "Ethereum",
	//         "clientId": null,
	//         "createdAt": "2025-08-13T19:27:13.817",
	//         "fee": "3",
	//         "fiatFee": null,
	//         "fiatState": null,
	//         "fiatSymbol": null,
	//         "id": 5479929,
	//         "identifier": null,
	//         "isInternal": false,
	//         "providerId": null,
	//         "quantity": "10",
	//         "status": "pending",
	//         "subaccountId": null,
	//         "symbol": "USDC",
	//         "toAddress": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
	//         "transactionHash": null,
	//         "triggerAt": null
	//     }
	//
	// fetchWithdrawals
	//     [
	//         {
	//             "accountIdentifier": null,
	//             "bankIdentifier": null,
	//             "bankName": null,
	//             "blockchain": "Ethereum",
	//             "clientId": null,
	//             "createdAt": "2025-08-13T19:27:13.817",
	//             "fee": "3",
	//             "fiatFee": null,
	//             "fiatState": null,
	//             "fiatSymbol": null,
	//             "id": 5479929,
	//             "identifier": null,
	//             "isInternal": false,
	//             "providerId": null,
	//             "quantity": "10",
	//             "status": "confirmed",
	//             "subaccountId": null,
	//             "symbol": "USDC",
	//             "toAddress": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
	//             "transactionHash": "0x658b6d082af4afa0d3cf85caf344ff7c19d980117726bf193b00d8850f8746a1",
	//             "triggerAt": null
	//         }
	//     ]
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
	var id interface{} = this.SafeString(transaction, "id")
	var txid interface{} = this.SafeString(transaction, "transactionHash")
	var coin interface{} = this.SafeString(transaction, "symbol")
	var code interface{} = this.SafeCurrencyCode(coin, currency)
	var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "createdAt"))
	var amount interface{} = this.SafeNumber(transaction, "quantity")
	var networkId interface{} = this.SafeStringLower2(transaction, "source", "blockchain")
	var network interface{} = this.NetworkIdToCode(networkId)
	var addressTo interface{} = this.SafeString(transaction, "toAddress")
	var addressFrom interface{} = this.SafeString(transaction, "fromAddress")
	var tag interface{} = this.SafeString(transaction, "platformMemo")
	var feeCost interface{} = this.SafeNumber(transaction, "fee")
	var internal interface{} = this.SafeBool(transaction, "isInternal", false)
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": code,
		}
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     network,
		"address":     nil,
		"addressTo":   addressTo,
		"addressFrom": addressFrom,
		"tag":         tag,
		"tagTo":       nil,
		"tagFrom":     nil,
		"type":        nil,
		"amount":      amount,
		"currency":    code,
		"status":      status,
		"updated":     nil,
		"internal":    internal,
		"comment":     nil,
		"fee":         fee,
	}
}
func (this *backpack) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"cancelled":            "cancelled",
		"confirmed":            "ok",
		"declined":             "declined",
		"expired":              "expired",
		"initiated":            "initiated",
		"pending":              "pending",
		"refunded":             "refunded",
		"information required": "pending",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name backpack#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.backpack.exchange/#tag/Capital/operation/get_deposit_address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.networkCode] the network to fetch the deposit address (mandatory)
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *backpack) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes16238 := (<-this.LoadMarkets())
		PanicOnError(retRes16238)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires a network parameter, see https://docs.ccxt.com/#/?id=network-codes")))
		}
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"blockchain": this.NetworkCodeToId(networkCode),
		}

		response := (<-this.PrivateGetWapiV1CapitalDepositAddress(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}
func (this *backpack) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "address": "0xfBe7CbfCde93c8a4204a4be6B56732Eb32690170"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "address")
	var currencyId interface{} = this.SafeString(depositAddress, "currency")
	currency = this.SafeCurrency(currencyId, currency)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": GetValue(currency, "code"),
		"network":  nil,
		"address":  address,
		"tag":      nil,
	}
}

/**
 * @method
 * @name backpack#createOrder
 * @description create a trade order
 * @see https://docs.backpack.exchange/#tag/Order/operation/execute_order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *market orders only* the cost of the order in units of the quote currency (could be used instead of amount)
 * @param {int} [params.clientOrderId] a unique id for the order
 * @param {boolean} [params.postOnly] true to place a post only order
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
 * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
 * @param {string} [params.selfTradePrevention] 'RejectTaker', 'RejectMaker' or 'RejectBoth'
 * @param {bool} [params.autoLend] *spot margin only* if true then the order can lend
 * @param {bool} [params.autoLendRedeem] *spot margin only* if true then the order can redeem a lend if required
 * @param {bool} [params.autoBorrow] *spot margin only* if true then the order can borrow
 * @param {bool} [params.autoBorrowRepay] *spot margin only* if true then the order can repay a borrow
 * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
 * @param {object} [params.takeProfit] *swap markets only - takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {float} [params.takeProfit.price] take profit order price (if not provided the order will be a market order)
 * @param {object} [params.stopLoss] *swap markets only - stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.stopLoss.price] stop loss order price (if not provided the order will be a market order)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes16868 := (<-this.LoadMarkets())
		PanicOnError(retRes16868)
		var market interface{} = this.Market(symbol)
		var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)

		response := (<-this.PrivatePostApiV1Order(orderRequest))
		PanicOnError(response)

		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#createOrders
 * @description create a list of trade orders
 * @see https://docs.backpack.exchange/#tag/Order/operation/execute_order_batch
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17038 := (<-this.LoadMarkets())
		PanicOnError(retRes17038)
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeNumber(rawOrder, "amount")
			var price interface{} = this.SafeNumber(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var extendedParams interface{} = this.Extend(orderParams, params) // the request does not accept extra params since it's a list, so we're extending each order with the common params
			var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, extendedParams)
			AppendToArray(&ordersRequests, orderRequest)
		}

		response := (<-this.PrivatePostApiV1Orders(ordersRequests))
		PanicOnError(response)

		ch <- this.ParseOrders(response)
		return nil

	}()
	return ch
}
func (this *backpack) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"symbol":    GetValue(market, "id"),
		"side":      this.EncodeOrderSide(side),
		"orderType": this.Capitalize(typeVar),
	}
	var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
	var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
	var quantityKey interface{} = Ternary(IsTrue(isTriggerOrder), "triggerQuantity", "quantity")
	// handle basic limit/market order types
	if IsTrue(IsEqual(typeVar, "limit")) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		AddElementToObject(request, quantityKey, this.AmountToPrecision(symbol, amount))
	} else if IsTrue(IsEqual(typeVar, "market")) {
		var cost interface{} = this.SafeString2(params, "cost", "quoteQuantity")
		if IsTrue(!IsEqual(cost, nil)) {
			AddElementToObject(request, "quoteQuantity", this.CostToPrecision(symbol, cost))
			params = this.Omit(params, []interface{}{"cost", "quoteQuantity"})
		} else {
			AddElementToObject(request, quantityKey, this.AmountToPrecision(symbol, amount))
		}
	}
	// trigger orders
	if IsTrue(isTriggerOrder) {
		AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
		params = this.Omit(params, "triggerPrice")
	}
	var clientOrderId interface{} = this.SafeInteger(params, "clientOrderId") // the exchange requires uint
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(request, "clientId", clientOrderId)
		params = this.Omit(params, "clientOrderId")
	}
	var postOnly interface{} = false
	postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), false, params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		AddElementToObject(params, "postOnly", true)
	}
	var takeProfit interface{} = this.SafeDict(params, "takeProfit")
	if IsTrue(!IsEqual(takeProfit, nil)) {
		var takeProfitTriggerPrice interface{} = this.SafeString(takeProfit, "triggerPrice")
		if IsTrue(!IsEqual(takeProfitTriggerPrice, nil)) {
			AddElementToObject(request, "takeProfitTriggerPrice", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
		}
		var takeProfitPrice interface{} = this.SafeString(takeProfit, "price")
		if IsTrue(!IsEqual(takeProfitPrice, nil)) {
			AddElementToObject(request, "takeProfitLimitPrice", this.PriceToPrecision(symbol, takeProfitPrice))
		}
		params = this.Omit(params, "takeProfit")
	}
	var stopLoss interface{} = this.SafeDict(params, "stopLoss")
	if IsTrue(!IsEqual(stopLoss, nil)) {
		var stopLossTriggerPrice interface{} = this.SafeString(stopLoss, "triggerPrice")
		if IsTrue(!IsEqual(stopLossTriggerPrice, nil)) {
			AddElementToObject(request, "stopLossTriggerPrice", this.PriceToPrecision(symbol, stopLossTriggerPrice))
		}
		var stopLossPrice interface{} = this.SafeString(stopLoss, "price")
		if IsTrue(!IsEqual(stopLossPrice, nil)) {
			AddElementToObject(request, "stopLossLimitPrice", this.PriceToPrecision(symbol, stopLossPrice))
		}
		params = this.Omit(params, "stopLoss")
	}
	return this.Extend(request, params)
}
func (this *backpack) EncodeOrderSide(side interface{}) interface{} {
	var sides interface{} = map[string]interface{}{
		"buy":  "Bid",
		"sell": "Ask",
	}
	return this.SafeString(sides, side, side)
}

/**
 * @method
 * @name backpack#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.backpack.exchange/#tag/Order/operation/get_open_orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18068 := (<-this.LoadMarkets())
		PanicOnError(retRes18068)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}

		response := (<-this.PrivateGetApiV1Orders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchOpenOrder
 * @description fetch an open order by it's id
 * @see https://docs.backpack.exchange/#tag/Order/operation/get_order
 * @param {string} id order id
 * @param {string} symbol not used by hollaex fetchOpenOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18288 := (<-this.LoadMarkets())
		PanicOnError(retRes18288)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":  GetValue(market, "id"),
			"orderId": id,
		}

		response := (<-this.PrivateGetApiV1Order(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#cancelOrder
 * @description cancels an open order
 * @see https://docs.backpack.exchange/#tag/Order/operation/cancel_order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18528 := (<-this.LoadMarkets())
		PanicOnError(retRes18528)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"orderId": id,
			"symbol":  GetValue(market, "id"),
		}

		response := (<-this.PrivateDeleteApiV1Order(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.backpack.exchange/#tag/Order/operation/cancel_open_orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *backpack) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18758 := (<-this.LoadMarkets())
		PanicOnError(retRes18758)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateDeleteApiV1Orders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name backpack#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.backpack.exchange/#tag/History/operation/get_order_history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve (default 100, max 1000)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func (this *backpack) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18998 := (<-this.LoadMarkets())
		PanicOnError(retRes18998)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetWapiV1HistoryOrders(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *backpack) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "clientId": null,
	//         "createdAt": 1753624283415,
	//         "executedQuantity": "0.001",
	//         "executedQuoteQuantity": "3.81428",
	//         "id": "4227701917",
	//         "orderType": "Market",
	//         "quantity": "0.001",
	//         "quoteQuantity": "3.82",
	//         "reduceOnly": null,
	//         "relatedOrderId": null,
	//         "selfTradePrevention": "RejectTaker",
	//         "side": "Bid",
	//         "status": "Filled",
	//         "stopLossLimitPrice": null,
	//         "stopLossTriggerBy": null,
	//         "stopLossTriggerPrice": null,
	//         "strategyId": null,
	//         "symbol": "ETH_USDC",
	//         "takeProfitLimitPrice": null,
	//         "takeProfitTriggerBy": null,
	//         "takeProfitTriggerPrice": null,
	//         "timeInForce": "GTC",
	//         "triggerBy": null,
	//         "triggerPrice": null,
	//         "triggerQuantity": null,
	//         "triggeredAt": null
	//     }
	//
	// fetchOpenOrders
	//     {
	//         "clientId": 123456789,
	//         "createdAt": 1753626206762,
	//         "executedQuantity": "0",
	//         "executedQuoteQuantity": "0",
	//         "id": "4228978331",
	//         "orderType": "Limit",
	//         "postOnly": true,
	//         "price": "3000",
	//         "quantity": "0.001",
	//         "reduceOnly": null,
	//         "relatedOrderId": null,
	//         "selfTradePrevention": "RejectTaker",
	//         "side": "Bid",
	//         "status": "New",
	//         "stopLossLimitPrice": null,
	//         "stopLossTriggerBy": null,
	//         "stopLossTriggerPrice": null,
	//         "strategyId": null,
	//         "symbol": "ETH_USDC",
	//         "takeProfitLimitPrice": null,
	//         "takeProfitTriggerBy": null,
	//         "takeProfitTriggerPrice": null,
	//         "timeInForce": "GTC",
	//         "triggerBy": null,
	//         "triggerPrice": null,
	//         "triggerQuantity": null,
	//         "triggeredAt": null
	//     }
	//
	// fetchOrders
	//     {
	//         "clientId": null,
	//         "createdAt": "2025-07-27T18:05:40.897",
	//         "executedQuantity": "0",
	//         "executedQuoteQuantity": "0",
	//         "expiryReason": null,
	//         "id": "4239996998",
	//         "orderType": "Limit",
	//         "postOnly": false,
	//         "price": "4500",
	//         "quantity": null,
	//         "quoteQuantity": null,
	//         "selfTradePrevention": "RejectTaker",
	//         "side": "Ask",
	//         "status": "Cancelled",
	//         "stopLossLimitPrice": null,
	//         "stopLossTriggerBy": null,
	//         "stopLossTriggerPrice": null,
	//         "strategyId": null,
	//         "symbol": "ETH_USDC",
	//         "systemOrderType": null,
	//         "takeProfitLimitPrice": null,
	//         "takeProfitTriggerBy": null,
	//         "takeProfitTriggerPrice": null,
	//         "timeInForce": "GTC",
	//         "triggerBy": null,
	//         "triggerPrice": "4300",
	//         "triggerQuantity": "0.001"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(order, "createdAt")
	var timestamp2 interface{} = this.Parse8601(this.SafeString(order, "createdAt"))
	if IsTrue(!IsEqual(timestamp2, nil)) {
		timestamp = timestamp2
	}
	var id interface{} = this.SafeString(order, "id")
	var clientOrderId interface{} = this.SafeString(order, "clientId")
	var symbol interface{} = this.SafeSymbol(this.SafeString(order, "symbol"), market)
	var typeVar interface{} = this.SafeStringLower(order, "orderType")
	var timeInForce interface{} = this.SafeString(order, "timeInForce")
	var side interface{} = this.ParseOrderSide(this.SafeString(order, "side"))
	var amount interface{} = this.SafeString2(order, "quantity", "triggerQuantity")
	var price interface{} = this.SafeString(order, "price")
	var cost interface{} = this.SafeString(order, "executedQuoteQuantity")
	var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
	var triggerPrice interface{} = this.SafeString(order, "triggerPrice")
	var filled interface{} = this.SafeString(order, "executedQuantity")
	var reduceOnly interface{} = this.SafeBool(order, "reduceOnly")
	var postOnly interface{} = this.SafeBool(order, "postOnly")
	var stopLossPrice interface{} = this.SafeString2(order, "stopLossLimitPrice", "stopLossTriggerPrice")
	var takeProfitPrice interface{} = this.SafeString2(order, "takeProfitLimitPrice", "takeProfitTriggerPrice")
	return this.SafeOrder(map[string]interface{}{
		"info":               order,
		"id":                 id,
		"clientOrderId":      clientOrderId,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"symbol":             symbol,
		"type":               typeVar,
		"timeInForce":        timeInForce,
		"postOnly":           postOnly,
		"reduceOnly":         reduceOnly,
		"side":               side,
		"price":              price,
		"triggerPrice":       triggerPrice,
		"stopLossPrice":      stopLossPrice,
		"takeProfitPrice":    takeProfitPrice,
		"amount":             amount,
		"cost":               cost,
		"average":            nil,
		"filled":             filled,
		"remaining":          nil,
		"status":             status,
		"fee":                nil,
		"trades":             nil,
	}, market)
}
func (this *backpack) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"New":             "open",
		"Filled":          "closed",
		"Cancelled":       "canceled",
		"Expired":         "canceled",
		"PartiallyFilled": "open",
		"TriggerPending":  "open",
		"TriggerFailed":   "rejected",
	}
	return this.SafeString(statuses, status, status)
}
func (this *backpack) ParseOrderSide(side interface{}) interface{} {
	var sides interface{} = map[string]interface{}{
		"Bid": "buy",
		"Ask": "sell",
	}
	return this.SafeString(sides, side, side)
}

/**
 * @method
 * @name backpack#fetchPositions
 * @description fetch all open positions
 * @see https://docs.backpack.exchange/#tag/Futures/operation/get_positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *backpack) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes20868 := (<-this.LoadMarkets())
		PanicOnError(retRes20868)

		response := (<-this.PrivateGetApiV1Position(params))
		PanicOnError(response)
		var positions interface{} = this.ParsePositions(response)
		if IsTrue(this.IsEmpty(symbols)) {

			ch <- positions
			return nil
		}
		symbols = this.MarketSymbols(symbols)

		ch <- this.FilterByArrayPositions(positions, "symbol", symbols, false)
		return nil

	}()
	return ch
}
func (this *backpack) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchPositions
	//     {
	//         "breakEvenPrice": "3831.3630555555555555555555556",
	//         "cumulativeFundingPayment": "-0.009218",
	//         "cumulativeInterest": "0",
	//         "entryPrice": "3826.8888888888888888888888889",
	//         "estLiquidationPrice": "0",
	//         "imf": "0.02",
	//         "imfFunction": {
	//             "base": "0.02",
	//             "factor": "0.0000935",
	//             "type": "sqrt"
	//         },
	//         "markPrice": "3787.46813304",
	//         "mmf": "0.0125",
	//         "mmfFunction": {
	//             "base": "0.0125",
	//             "factor": "0.0000561",
	//             "type": "sqrt"
	//         },
	//         "netCost": "13.7768",
	//         "netExposureNotional": "13.634885278944",
	//         "netExposureQuantity": "0.0036",
	//         "netQuantity": "0.0036",
	//         "pnlRealized": "0",
	//         "pnlUnrealized": "-0.141914",
	//         "positionId": "4238420454",
	//         "subaccountId": null,
	//         "symbol": "ETH_USDC_PERP",
	//         "userId":1813870
	//     }
	//
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(position, "positionId")
	var marketId interface{} = this.SafeString(position, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var entryPrice interface{} = this.SafeString(position, "entryPrice")
	var markPrice interface{} = this.SafeString(position, "markPrice")
	var netCost interface{} = this.SafeString(position, "netCost")
	var hedged interface{} = false
	var side interface{} = "long"
	if IsTrue(Precise.StringLt(netCost, "0")) {
		side = "short"
	}
	if IsTrue(IsEqual(netCost, nil)) {
		hedged = nil
		side = nil
	}
	var unrealizedPnl interface{} = this.SafeString(position, "pnlUnrealized")
	var realizedPnl interface{} = this.SafeString(position, "pnlRealized")
	var liquidationPrice interface{} = this.SafeString(position, "estLiquidationPrice")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          id,
		"symbol":                      symbol,
		"timestamp":                   this.Parse8601(this.SafeString(position, "timestamp")),
		"datetime":                    this.Iso8601(this.Parse8601(this.SafeString(position, "timestamp"))),
		"lastUpdateTimestamp":         nil,
		"hedged":                      hedged,
		"side":                        side,
		"contracts":                   this.SafeString(position, "netExposureQuantity"),
		"contractSize":                nil,
		"entryPrice":                  entryPrice,
		"markPrice":                   markPrice,
		"lastPrice":                   nil,
		"notional":                    Precise.StringAbs(netCost),
		"leverage":                    nil,
		"collateral":                  nil,
		"initialMargin":               nil,
		"initialMarginPercentage":     this.SafeString(position, "imf"),
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": this.SafeString(position, "mmf"),
		"realizedPnl":                 realizedPnl,
		"unrealizedPnl":               unrealizedPnl,
		"liquidationPrice":            liquidationPrice,
		"marginMode":                  nil,
		"marginRatio":                 nil,
		"percentage":                  nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name backpack#fetchFundingHistory
 * @description fetches the history of funding payments
 * @see https://docs.backpack.exchange/#tag/History/operation/get_funding_payments
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch (default 24 hours ago)
 * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *backpack) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21958 := (<-this.LoadMarkets())
		PanicOnError(retRes21958)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetWapiV1HistoryFunding(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseIncomes(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *backpack) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "fundingRate": "0.0001",
	//         "intervalEndTimestamp": "2025-08-01T16:00:00",
	//         "quantity": "-0.001301",
	//         "subaccountId": 0,
	//         "symbol": "ETH_USDC_PERP",
	//         "userId": 1813870
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(income, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var amount interface{} = this.SafeNumber(income, "quantity")
	var id interface{} = this.SafeString(income, "userId")
	var timestamp interface{} = this.Parse8601(this.SafeString(income, "intervalEndTimestamp"))
	var rate interface{} = this.SafeNumber(income, "fundingRate")
	return map[string]interface{}{
		"info":      income,
		"symbol":    symbol,
		"code":      nil,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"id":        id,
		"amount":    amount,
		"rate":      rate,
	}
}
func (this *backpack) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func (this *backpack) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var endpoint interface{} = Add("/", path)
	var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
	var sortedParams interface{} = Ternary(IsTrue(IsArray(params)), params, this.Keysort(params))
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		var ts interface{} = ToString(this.Nonce())
		var recvWindow interface{} = this.SafeString2(this.Options, "recvWindow", "X-Window", "5000")
		var optionInstructions interface{} = this.SafeDict(this.Options, "instructions", map[string]interface{}{})
		var optionPathInstructions interface{} = this.SafeDict(optionInstructions, path, map[string]interface{}{})
		var instruction interface{} = this.SafeString(optionPathInstructions, method, "")
		var payload interface{} = ""
		if IsTrue(IsTrue((IsEqual(path, "api/v1/orders"))) && IsTrue((IsEqual(method, "POST")))) {
			payload = this.GenerateBatchPayload(sortedParams, ts, recvWindow, instruction)
		} else {
			var queryString interface{} = this.Urlencode(sortedParams)
			if IsTrue(IsGreaterThan(GetArrayLength(queryString), 0)) {
				queryString = Add(queryString, "&")
			}
			payload = Add(Add(Add(Add(Add(Add(Add("instruction=", instruction), "&"), queryString), "timestamp="), ts), "&window="), recvWindow)
		}
		var secretBytes interface{} = this.Base64ToBinary(this.Secret)
		var seed interface{} = this.ArraySlice(secretBytes, 0, 32)
		var signature interface{} = Eddsa(this.Encode(payload), seed, ed25519)
		headers = map[string]interface{}{
			"X-Timestamp": ts,
			"X-Window":    recvWindow,
			"X-API-Key":   this.ApiKey,
			"X-Signature": signature,
			"X-Broker-Id": "1400",
		}
		if IsTrue(!IsEqual(method, "GET")) {
			body = this.Json(sortedParams)
			AddElementToObject(headers, "Content-Type", "application/json")
		}
	}
	if IsTrue(IsEqual(method, "GET")) {
		var query interface{} = this.Urlencode(sortedParams)
		if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
			endpoint = Add(endpoint, Add("?", query))
		}
	}
	url = Add(url, endpoint)
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *backpack) GenerateBatchPayload(params interface{}, ts interface{}, recvWindow interface{}, instruction interface{}) interface{} {
	var payload interface{} = ""
	for i := 0; IsLessThan(i, GetArrayLength(params)); i++ {
		var order interface{} = this.SafeDict(params, i, map[string]interface{}{})
		var sortedOrder interface{} = this.Keysort(order)
		var orderQuery interface{} = this.Urlencode(sortedOrder)
		payload = Add(payload, Add(Add(Add(Add("instruction=", instruction), "&"), orderQuery), "&"))
		if IsTrue(IsEqual(i, (Subtract(GetArrayLength(params), 1)))) {
			payload = Add(payload, Add(Add(Add("timestamp=", ts), "&window="), recvWindow))
		}
	}
	return payload
}
func (this *backpack) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	//
	// {"code":"INVALID_ORDER","message":"Invalid order"}
	// {"code":"INVALID_CLIENT_REQUEST","message":"Must specify both `triggerPrice` and `triggerQuantity` or neither"}
	//
	var errorCode interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString(response, "message")
	if IsTrue(!IsEqual(errorCode, nil)) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *backpack) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
