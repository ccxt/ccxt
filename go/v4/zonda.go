package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type zonda struct {
    Exchange

}

func NewZondaCore() zonda {
   p := zonda{}
   setDefaults(&p)
   return p
}

func  (this *zonda) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "zonda",
        "name": "Zonda",
        "countries": []interface{}{"EE"},
        "rateLimit": 1000,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRates": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": nil,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverages": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarginModes": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrices": false,
            "fetchMyLiquidations": false,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOption": false,
            "fetchOptionChain": false,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": nil,
            "fetchTransfer": false,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": nil,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "60",
            "3m": "180",
            "5m": "300",
            "15m": "900",
            "30m": "1800",
            "1h": "3600",
            "2h": "7200",
            "4h": "14400",
            "6h": "21600",
            "12h": "43200",
            "1d": "86400",
            "3d": "259200",
            "1w": "604800",
        },
        "hostname": "zondacrypto.exchange",
        "urls": map[string]interface{} {
            "referral": "https://auth.zondaglobal.com/ref/jHlbB4mIkdS1",
            "logo": "https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg",
            "www": "https://zondaglobal.com",
            "api": map[string]interface{} {
                "public": "https://{hostname}/API/Public",
                "private": "https://{hostname}/API/Trading/tradingApi.php",
                "v1_01Public": "https://api.{hostname}/rest",
                "v1_01Private": "https://api.{hostname}/rest",
            },
            "doc": []interface{}{"https://docs.zondacrypto.exchange/", "https://github.com/BitBayNet/API"},
            "support": "https://zondaglobal.com/en/helpdesk/zonda-exchange",
            "fees": "https://zondaglobal.com/legal/zonda-exchange/fees",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"{id}/all", "{id}/market", "{id}/orderbook", "{id}/ticker", "{id}/trades"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"info", "trade", "cancel", "orderbook", "orders", "transfer", "withdraw", "history", "transactions"},
            },
            "v1_01Public": map[string]interface{} {
                "get": []interface{}{"trading/ticker", "trading/ticker/{symbol}", "trading/stats", "trading/stats/{symbol}", "trading/orderbook/{symbol}", "trading/transactions/{symbol}", "trading/candle/history/{symbol}/{resolution}"},
            },
            "v1_01Private": map[string]interface{} {
                "get": []interface{}{"api_payments/deposits/crypto/addresses", "payments/withdrawal/{detailId}", "payments/deposit/{detailId}", "trading/offer", "trading/stop/offer", "trading/config/{symbol}", "trading/history/transactions", "balances/BITBAY/history", "balances/BITBAY/balance", "fiat_cantor/rate/{baseId}/{quoteId}", "fiat_cantor/history", "client_payments/v2/customer/crypto/{currency}/channels/deposit", "client_payments/v2/customer/crypto/{currency}/channels/withdrawal", "client_payments/v2/customer/crypto/deposit/fee", "client_payments/v2/customer/crypto/withdrawal/fee"},
                "post": []interface{}{"trading/offer/{symbol}", "trading/stop/offer/{symbol}", "trading/config/{symbol}", "balances/BITBAY/balance", "balances/BITBAY/balance/transfer/{source}/{destination}", "fiat_cantor/exchange", "api_payments/withdrawals/crypto", "api_payments/withdrawals/fiat", "client_payments/v2/customer/crypto/deposit", "client_payments/v2/customer/crypto/withdrawal"},
                "delete": []interface{}{"trading/offer/{symbol}/{id}/{side}/{price}", "trading/stop/offer/{symbol}/{id}/{side}/{price}"},
                "put": []interface{}{"balances/BITBAY/balance/{id}"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.0"),
                "taker": this.ParseNumber("0.001"),
                "percentage": true,
                "tierBased": false,
            },
            "fiat": map[string]interface{} {
                "maker": this.ParseNumber("0.0030"),
                "taker": this.ParseNumber("0.0043"),
                "percentage": true,
                "tierBased": true,
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0.0043"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("0.0042"), this.ParseNumber("1250")}, []interface{}{this.ParseNumber("0.0041"), this.ParseNumber("3750")}, []interface{}{this.ParseNumber("0.0040"), this.ParseNumber("7500")}, []interface{}{this.ParseNumber("0.0039"), this.ParseNumber("10000")}, []interface{}{this.ParseNumber("0.0038"), this.ParseNumber("15000")}, []interface{}{this.ParseNumber("0.0037"), this.ParseNumber("20000")}, []interface{}{this.ParseNumber("0.0036"), this.ParseNumber("25000")}, []interface{}{this.ParseNumber("0.0035"), this.ParseNumber("37500")}, []interface{}{this.ParseNumber("0.0034"), this.ParseNumber("50000")}, []interface{}{this.ParseNumber("0.0033"), this.ParseNumber("75000")}, []interface{}{this.ParseNumber("0.0032"), this.ParseNumber("100000")}, []interface{}{this.ParseNumber("0.0031"), this.ParseNumber("150000")}, []interface{}{this.ParseNumber("0.0030"), this.ParseNumber("200000")}, []interface{}{this.ParseNumber("0.0029"), this.ParseNumber("250000")}, []interface{}{this.ParseNumber("0.0028"), this.ParseNumber("375000")}, []interface{}{this.ParseNumber("0.0027"), this.ParseNumber("500000")}, []interface{}{this.ParseNumber("0.0026"), this.ParseNumber("625000")}, []interface{}{this.ParseNumber("0.0025"), this.ParseNumber("875000")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0.0030"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("0.0029"), this.ParseNumber("1250")}, []interface{}{this.ParseNumber("0.0028"), this.ParseNumber("3750")}, []interface{}{this.ParseNumber("0.0028"), this.ParseNumber("7500")}, []interface{}{this.ParseNumber("0.0027"), this.ParseNumber("10000")}, []interface{}{this.ParseNumber("0.0026"), this.ParseNumber("15000")}, []interface{}{this.ParseNumber("0.0025"), this.ParseNumber("20000")}, []interface{}{this.ParseNumber("0.0025"), this.ParseNumber("25000")}, []interface{}{this.ParseNumber("0.0024"), this.ParseNumber("37500")}, []interface{}{this.ParseNumber("0.0023"), this.ParseNumber("50000")}, []interface{}{this.ParseNumber("0.0023"), this.ParseNumber("75000")}, []interface{}{this.ParseNumber("0.0022"), this.ParseNumber("100000")}, []interface{}{this.ParseNumber("0.0021"), this.ParseNumber("150000")}, []interface{}{this.ParseNumber("0.0021"), this.ParseNumber("200000")}, []interface{}{this.ParseNumber("0.0020"), this.ParseNumber("250000")}, []interface{}{this.ParseNumber("0.0019"), this.ParseNumber("375000")}, []interface{}{this.ParseNumber("0.0018"), this.ParseNumber("500000")}, []interface{}{this.ParseNumber("0.0018"), this.ParseNumber("625000")}, []interface{}{this.ParseNumber("0.0017"), this.ParseNumber("875000")}},
                },
            },
            "funding": map[string]interface{} {
                "withdraw": map[string]interface{} {},
            },
        },
        "options": map[string]interface{} {
            "fetchTickerMethod": "v1_01PublicGetTradingTickerSymbol",
            "fetchTickersMethod": "v1_01PublicGetTradingTicker",
            "fiatCurrencies": []interface{}{"EUR", "USD", "GBP", "PLN"},
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "400": ExchangeError,
            "401": InvalidOrder,
            "402": InvalidOrder,
            "403": InvalidOrder,
            "404": InvalidOrder,
            "405": InvalidOrder,
            "406": InsufficientFunds,
            "408": InvalidOrder,
            "501": AuthenticationError,
            "502": AuthenticationError,
            "503": InvalidNonce,
            "504": ExchangeError,
            "505": AuthenticationError,
            "506": AccountSuspended,
            "509": ExchangeError,
            "510": BadSymbol,
            "FUNDS_NOT_SUFFICIENT": InsufficientFunds,
            "OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS": InvalidOrder,
            "OFFER_NOT_FOUND": OrderNotFound,
            "OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED": OrderImmediatelyFillable,
            "ACTION_LIMIT_EXCEEDED": RateLimitExceeded,
            "UNDER_MAINTENANCE": OnMaintenance,
            "REQUEST_TIMESTAMP_TOO_OLD": InvalidNonce,
            "PERMISSIONS_NOT_SUFFICIENT": PermissionDenied,
            "INVALID_STOP_RATE": InvalidOrder,
            "TIMEOUT": ExchangeError,
            "RESPONSE_TIMEOUT": ExchangeError,
            "ACTION_BLOCKED": PermissionDenied,
            "INVALID_HASH_SIGNATURE": AuthenticationError,
        },
        "commonCurrencies": map[string]interface{} {
            "GGC": "Global Game Coin",
        },
    })
}
/**
 * @method
 * @name zonda#fetchMarkets
 * @see https://docs.zondacrypto.exchange/reference/ticker-1
 * @description retrieves data on all markets for zonda
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *zonda) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1_01PublicGetTradingTicker(params))
            PanicOnError(response)
            //
            //     {
            //         "status": "Ok",
            //         "items": {
            //             "BSV-USD": {
            //                 "market": {
            //                     "code": "BSV-USD",
            //                     "first": { currency: "BSV", minOffer: "0.00035", scale: 8 },
            //                     "second": { currency: "USD", minOffer: "5", scale: 2 }
            //                 },
            //                 "time": "1557569762154",
            //                 "highestBid": "52.31",
            //                 "lowestAsk": "62.99",
            //                 "rate": "63",
            //                 "previousRate": "51.21",
            //             },
            //         },
            //     }
            //
            var items interface{} = this.SafeValue(response, "items", map[string]interface{} {})
            var markets interface{} = ObjectValues(items)
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseMarket(item interface{}) interface{}  {
    var market interface{} = this.SafeValue(item, "market", map[string]interface{} {})
    var id interface{} = this.SafeString(market, "code")
    var first interface{} = this.SafeValue(market, "first", map[string]interface{} {})
    var second interface{} = this.SafeValue(market, "second", map[string]interface{} {})
    var baseId interface{} = this.SafeString(first, "currency")
    var quoteId interface{} = this.SafeString(second, "currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var fees interface{} = this.SafeValue(this.Fees, "trading", map[string]interface{} {})
    var fiatCurrencies interface{} = this.SafeValue(this.Options, "fiatCurrencies", []interface{}{})
    if IsTrue(IsTrue(this.InArray(base, fiatCurrencies)) || IsTrue(this.InArray(quote, fiatCurrencies))) {
        fees = this.SafeValue(this.Fees, "fiat", map[string]interface{} {})
    }
    // todo: check that the limits have ben interpreted correctly
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": nil,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.SafeNumber(fees, "taker"),
        "maker": this.SafeNumber(fees, "maker"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "optionType": nil,
        "strike": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(first, "scale"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(second, "scale"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(first, "minOffer"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": item,
    }
}
/**
 * @method
 * @name zonda#fetchOpenOrders
 * @see https://docs.zondacrypto.exchange/reference/active-orders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol not used by zonda fetchOpenOrders
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zonda) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5038 := (<-this.LoadMarkets())
            PanicOnError(retRes5038)
            var request interface{} = map[string]interface{} {}
            // todo pair
        
            response:= (<-this.V1_01PrivateGetTradingOffer(this.Extend(request, params)))
            PanicOnError(response)
            var items interface{} = this.SafeList(response, "items", []interface{}{})
        
            ch <- this.ParseOrders(items, nil, since, limit, map[string]interface{} {
                "status": "open",
            })
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "ETH-EUR",
    //         "offerType": "Sell",
    //         "id": "93d3657b-d616-11e9-9248-0242ac110005",
    //         "currentAmount": "0.04",
    //         "lockedAmount": "0.04",
    //         "rate": "280",
    //         "startAmount": "0.04",
    //         "time": "1568372806924",
    //         "postOnly": false,
    //         "hidden": false,
    //         "mode": "limit",
    //         "receivedAmount": "0.0",
    //         "firstBalanceId": "5b816c3e-437c-4e43-9bef-47814ae7ebfc",
    //         "secondBalanceId": "ab43023b-4079-414c-b340-056e3430a3af"
    //     }
    //
    // cancelOrder
    //
    //    {
    //        status: "Ok",
    //        errors: []
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var timestamp interface{} = this.SafeInteger(order, "time")
    var amount interface{} = this.SafeString(order, "startAmount")
    var remaining interface{} = this.SafeString(order, "currentAmount")
    var postOnly interface{} = this.SafeValue(order, "postOnly")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "id"),
        "clientOrderId": nil,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": nil,
        "symbol": symbol,
        "type": this.SafeString(order, "mode"),
        "timeInForce": nil,
        "postOnly": postOnly,
        "side": this.SafeStringLower(order, "offerType"),
        "price": this.SafeString(order, "rate"),
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "filled": nil,
        "remaining": remaining,
        "average": nil,
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name zonda#fetchMyTrades
 * @see https://docs.zondacrypto.exchange/reference/transactions-history
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *zonda) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5808 := (<-this.LoadMarkets())
            PanicOnError(retRes5808)
            var request interface{} = map[string]interface{} {}
            if IsTrue(symbol) {
                var markets interface{} = []interface{}{this.MarketId(symbol)}
                symbol = this.Symbol(symbol)
                AddElementToObject(request, "markets", markets)
            }
            var query interface{} = map[string]interface{} {
                "query": this.Json(this.Extend(request, params)),
            }
        
            response:= (<-this.V1_01PrivateGetTradingHistoryTransactions(query))
            PanicOnError(response)
            //
            //     {
            //         "status": "Ok",
            //         "totalRows": "67",
            //         "items": [
            //             {
            //                 "id": "b54659a0-51b5-42a0-80eb-2ac5357ccee2",
            //                 "market": "BTC-EUR",
            //                 "time": "1541697096247",
            //                 "amount": "0.00003",
            //                 "rate": "4341.44",
            //                 "initializedBy": "Sell",
            //                 "wasTaker": false,
            //                 "userAction": "Buy",
            //                 "offerId": "bd19804a-6f89-4a69-adb8-eb078900d006",
            //                 "commissionValue": null
            //             },
            //         ]
            //     }
            //
            var items interface{} = this.SafeValue(response, "items")
            var result interface{} = this.ParseTrades(items, nil, since, limit)
            if IsTrue(IsEqual(symbol, nil)) {
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterBySymbol(result, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(response, "balances")
    if IsTrue(IsEqual(balances, nil)) {
        panic(ExchangeError(Add(Add(this.Id, " empty balance response "), this.Json(response))))
    }
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "used", this.SafeString(balance, "lockedFunds"))
        AddElementToObject(account, "free", this.SafeString(balance, "availableFunds"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name zonda#fetchBalance
 * @see https://docs.zondacrypto.exchange/reference/list-of-wallets
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *zonda) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6448 := (<-this.LoadMarkets())
            PanicOnError(retRes6448)
        
            response:= (<-this.V1_01PrivateGetBalancesBITBAYBalance(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#fetchOrderBook
 * @see https://docs.zondacrypto.exchange/reference/orderbook-2
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *zonda) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6608 := (<-this.LoadMarkets())
            PanicOnError(retRes6608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1_01PublicGetTradingOrderbookSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"Ok",
            //         "sell":[
            //             {"ra":"43988.93","ca":"0.00100525","sa":"0.00100525","pa":"0.00100525","co":1},
            //             {"ra":"43988.94","ca":"0.00114136","sa":"0.00114136","pa":"0.00114136","co":1},
            //             {"ra":"43989","ca":"0.010578","sa":"0.010578","pa":"0.010578","co":1},
            //         ],
            //         "buy":[
            //             {"ra":"42157.33","ca":"2.83147881","sa":"2.83147881","pa":"2.83147881","co":2},
            //             {"ra":"42096.0","ca":"0.00011878","sa":"0.00011878","pa":"0.00011878","co":1},
            //             {"ra":"42022.0","ca":"0.00011899","sa":"0.00011899","pa":"0.00011899","co":1},
            //         ],
            //         "timestamp":"1642299886122",
            //         "seqNo":"27641254"
            //     }
            //
            var rawBids interface{} = this.SafeValue(response, "buy", []interface{}{})
            var rawAsks interface{} = this.SafeValue(response, "sell", []interface{}{})
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- map[string]interface{} {
                "symbol": GetValue(market, "symbol"),
                "bids": this.ParseBidsAsks(rawBids, "ra", "ca"),
                "asks": this.ParseBidsAsks(rawAsks, "ra", "ca"),
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "nonce": this.SafeInteger(response, "seqNo"),
            }
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // version 1
    //
    //    {
    //        "m": "ETH-PLN",
    //        "h": "13485.13",
    //        "l": "13100.01",
    //        "v": "126.10710939",
    //        "r24h": "13332.72"
    //    }
    //
    // version 2
    //
    //    {
    //        "market": {
    //            "code": "ADA-USDT",
    //            "first": {
    //                "currency": "ADA",
    //                "minOffer": "0.2",
    //                "scale": "6"
    //            },
    //            "second": {
    //                "currency": "USDT",
    //                "minOffer": "0.099",
    //                "scale": "6"
    //            },
    //            "amountPrecision": "6",
    //            "pricePrecision": "6",
    //            "ratePrecision": "6"
    //        },
    //        "time": "1655812661202",
    //        "highestBid": "0.492",
    //        "lowestAsk": "0.499389",
    //        "rate": "0.50588",
    //        "previousRate": "0.504981"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var tickerMarket interface{} = this.SafeValue(ticker, "market")
    var marketId interface{} = this.SafeString2(tickerMarket, "code", "m")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(ticker, "time")
    var rate interface{} = this.SafeValue(ticker, "rate")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "h"),
        "low": this.SafeString(ticker, "l"),
        "bid": this.SafeNumber(ticker, "highestBid"),
        "bidVolume": nil,
        "ask": this.SafeNumber(ticker, "lowestAsk"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "r24h"),
        "close": rate,
        "last": rate,
        "previousClose": this.SafeValue(ticker, "previousRate"),
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name zonda#fetchTicker
 * @description v1_01PublicGetTradingTickerSymbol retrieves timestamp, datetime, bid, ask, close, last, previousClose, v1_01PublicGetTradingStatsSymbol retrieves high, low, volume and opening price of an asset
 * @see https://docs.zondacrypto.exchange/reference/market-statistics
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] v1_01PublicGetTradingTickerSymbol (default) or v1_01PublicGetTradingStatsSymbol
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *zonda) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7748 := (<-this.LoadMarkets())
            PanicOnError(retRes7748)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var method interface{} = "v1_01PublicGetTradingTickerSymbol"
            var defaultMethod interface{} = this.SafeString(this.Options, "fetchTickerMethod", method)
            var fetchTickerMethod interface{} = this.SafeString2(params, "method", "fetchTickerMethod", defaultMethod)
            var response interface{} = nil
            if IsTrue(IsEqual(fetchTickerMethod, method)) {
                
        response = (<-this.V1_01PublicGetTradingTickerSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(fetchTickerMethod, "v1_01PublicGetTradingStatsSymbol")) {
                
        response = (<-this.V1_01PublicGetTradingStatsSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(BadRequest(Add(this.Id, " fetchTicker params[\"method\"] must be \"v1_01PublicGetTradingTickerSymbol\" or \"v1_01PublicGetTradingStatsSymbol\"")))
            }
            var stats interface{} = this.SafeValue2(response, "ticker", "stats")
        
            ch <- this.ParseTicker(stats, market)
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @name zonda#fetchTickersV2
 * @description v1_01PublicGetTradingTicker retrieves timestamp, datetime, bid, ask, close, last, previousClose for each market, v1_01PublicGetTradingStats retrieves high, low, volume and opening price of each market
 * @see https://docs.zondacrypto.exchange/reference/market-statistics
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] v1_01PublicGetTradingTicker (default) or v1_01PublicGetTradingStats
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *zonda) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8468 := (<-this.LoadMarkets())
            PanicOnError(retRes8468)
            var method interface{} = "v1_01PublicGetTradingTicker"
            var defaultMethod interface{} = this.SafeString(this.Options, "fetchTickersMethod", method)
            var fetchTickersMethod interface{} = this.SafeString2(params, "method", "fetchTickersMethod", defaultMethod)
            var response interface{} = nil
            if IsTrue(IsEqual(fetchTickersMethod, method)) {
                
        response = (<-this.V1_01PublicGetTradingTicker(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(fetchTickersMethod, "v1_01PublicGetTradingStats")) {
                
        response = (<-this.V1_01PublicGetTradingStats(params))
                PanicOnError(response)
            } else {
                panic(BadRequest(Add(this.Id, " fetchTickers params[\"method\"] must be \"v1_01PublicGetTradingTicker\" or \"v1_01PublicGetTradingStats\"")))
            }
            var items interface{} = this.SafeDict(response, "items")
        
            ch <- this.ParseTickers(items, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://docs.zondacrypto.exchange/reference/operations-history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *zonda) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var balanceCurrencies interface{} = []interface{}{}
            if IsTrue(!IsEqual(code, nil)) {
                var currency interface{} = this.Currency(code)
                AppendToArray(&balanceCurrencies,GetValue(currency, "id"))
            }
            var request interface{} = map[string]interface{} {
                "balanceCurrencies": balanceCurrencies,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            request = this.Extend(request, params)
        
            response:= (<-this.V1_01PrivateGetBalancesBITBAYHistory(map[string]interface{} {
            "query": this.Json(request),
        }))
            PanicOnError(response)
            var items interface{} = GetValue(response, "items")
        
            ch <- this.ParseLedger(items, nil, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    FUNDS_MIGRATION
    //    {
    //      "historyId": "84ea7a29-7da5-4de5-b0c0-871e83cad765",
    //      "balance": {
    //        "id": "821ec166-cb88-4521-916c-f4eb44db98df",
    //        "currency": "LTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "LTC"
    //      },
    //      "detailId": null,
    //      "time": 1506128252968,
    //      "type": "FUNDS_MIGRATION",
    //      "value": 0.0009957,
    //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
    //      "fundsAfter": { "total": 0.0009957, "available": 0.0009957, "locked": 0 },
    //      "change": { "total": 0.0009957, "available": 0.0009957, "locked": 0 }
    //    }
    //
    //    CREATE_BALANCE
    //    {
    //      "historyId": "d0fabd8d-9107-4b5e-b9a6-3cab8af70d49",
    //      "balance": {
    //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
    //        "currency": "BTG",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTG"
    //      },
    //      "detailId": null,
    //      "time": 1508895244751,
    //      "type": "CREATE_BALANCE",
    //      "value": 0,
    //      "fundsBefore": { "total": null, "available": null, "locked": null },
    //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
    //      "change": { "total": 0, "available": 0, "locked": 0 }
    //    }
    //
    //    BITCOIN_GOLD_FORK
    //    {
    //      "historyId": "2b4d52d3-611c-473d-b92c-8a8d87a24e41",
    //      "balance": {
    //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
    //        "currency": "BTG",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTG"
    //      },
    //      "detailId": null,
    //      "time": 1508895244778,
    //      "type": "BITCOIN_GOLD_FORK",
    //      "value": 0.00453512,
    //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
    //      "fundsAfter": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
    //      "change": { "total": 0.00453512, "available": 0.00453512, "locked": 0 }
    //    }
    //
    //    ADD_FUNDS
    //    {
    //      "historyId": "3158236d-dae5-4a5d-81af-c1fa4af340fb",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": "8e83a960-e737-4380-b8bb-259d6e236faa",
    //      "time": 1520631178816,
    //      "type": "ADD_FUNDS",
    //      "value": 0.628405,
    //      "fundsBefore": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
    //      "fundsAfter": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
    //      "change": { "total": 0.628405, "available": 0.628405, "locked": 0 }
    //    }
    //
    //    TRANSACTION_PRE_LOCKING
    //    {
    //      "historyId": "e7d19e0f-03b3-46a8-bc72-dde72cc24ead",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": null,
    //      "time": 1520706403868,
    //      "type": "TRANSACTION_PRE_LOCKING",
    //      "value": -0.1,
    //      "fundsBefore": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
    //      "fundsAfter": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
    //      "change": { "total": 0, "available": -0.1, "locked": 0.1 }
    //    }
    //
    //    TRANSACTION_POST_OUTCOME
    //    {
    //      "historyId": "c4010825-231d-4a9c-8e46-37cde1f7b63c",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": "bf2876bc-b545-4503-96c8-ef4de8233876",
    //      "time": 1520706404032,
    //      "type": "TRANSACTION_POST_OUTCOME",
    //      "value": -0.01771415,
    //      "fundsBefore": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
    //      "fundsAfter": { "total": 0.61522597, "available": 0.53294012, "locked": 0.08228585 },
    //      "change": { "total": -0.01771415, "available": 0, "locked": -0.01771415 }
    //    }
    //
    //    TRANSACTION_POST_INCOME
    //    {
    //      "historyId": "7f18b7af-b676-4125-84fd-042e683046f6",
    //      "balance": {
    //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
    //        "currency": "EUR",
    //        "type": "FIAT",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "EUR"
    //      },
    //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
    //      "time": 1520706404035,
    //      "type": "TRANSACTION_POST_INCOME",
    //      "value": 628.78,
    //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
    //      "fundsAfter": { "total": 628.78, "available": 628.78, "locked": 0 },
    //      "change": { "total": 628.78, "available": 628.78, "locked": 0 }
    //    }
    //
    //    TRANSACTION_COMMISSION_OUTCOME
    //    {
    //      "historyId": "843177fa-61bc-4cbf-8be5-b029d856c93b",
    //      "balance": {
    //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
    //        "currency": "EUR",
    //        "type": "FIAT",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "EUR"
    //      },
    //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
    //      "time": 1520706404050,
    //      "type": "TRANSACTION_COMMISSION_OUTCOME",
    //      "value": -2.71,
    //      "fundsBefore": { "total": 766.06, "available": 766.06, "locked": 0 },
    //      "fundsAfter": { "total": 763.35,"available": 763.35, "locked": 0 },
    //      "change": { "total": -2.71, "available": -2.71, "locked": 0 }
    //    }
    //
    //    TRANSACTION_OFFER_COMPLETED_RETURN
    //    {
    //      "historyId": "cac69b04-c518-4dc5-9d86-e76e91f2e1d2",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": null,
    //      "time": 1520714886425,
    //      "type": "TRANSACTION_OFFER_COMPLETED_RETURN",
    //      "value": 0.00000196,
    //      "fundsBefore": { "total": 0.00941208, "available": 0.00941012, "locked": 0.00000196 },
    //      "fundsAfter": { "total": 0.00941208, "available": 0.00941208, "locked": 0 },
    //      "change": { "total": 0, "available": 0.00000196, "locked": -0.00000196 }
    //    }
    //
    //    WITHDRAWAL_LOCK_FUNDS
    //    {
    //      "historyId": "03de2271-66ab-4960-a786-87ab9551fc14",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
    //      "time": 1522245654481,
    //      "type": "WITHDRAWAL_LOCK_FUNDS",
    //      "value": -0.8,
    //      "fundsBefore": { "total": 0.8, "available": 0.8, "locked": 0 },
    //      "fundsAfter": { "total": 0.8, "available": 0, "locked": 0.8 },
    //      "change": { "total": 0, "available": -0.8, "locked": 0.8 }
    //    }
    //
    //    WITHDRAWAL_SUBTRACT_FUNDS
    //    {
    //      "historyId": "b0308c89-5288-438d-a306-c6448b1a266d",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
    //      "time": 1522246526186,
    //      "type": "WITHDRAWAL_SUBTRACT_FUNDS",
    //      "value": -0.8,
    //      "fundsBefore": { "total": 0.8, "available": 0, "locked": 0.8 },
    //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
    //      "change": { "total": -0.8, "available": 0, "locked": -0.8 }
    //    }
    //
    //    TRANSACTION_OFFER_ABORTED_RETURN
    //    {
    //      "historyId": "b1a3c075-d403-4e05-8f32-40512cdd88c0",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": null,
    //      "time": 1522512298662,
    //      "type": "TRANSACTION_OFFER_ABORTED_RETURN",
    //      "value": 0.0564931,
    //      "fundsBefore": { "total": 0.44951311, "available": 0.39302001, "locked": 0.0564931 },
    //      "fundsAfter": { "total": 0.44951311, "available": 0.44951311, "locked": 0 },
    //      "change": { "total": 0, "available": 0.0564931, "locked": -0.0564931 }
    //    }
    //
    //    WITHDRAWAL_UNLOCK_FUNDS
    //    {
    //      "historyId": "0ed569a2-c330-482e-bb89-4cb553fb5b11",
    //      "balance": {
    //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
    //        "currency": "BTC",
    //        "type": "CRYPTO",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "BTC"
    //      },
    //      "detailId": "0c7be256-c336-4111-bee7-4eb22e339700",
    //      "time": 1527866360785,
    //      "type": "WITHDRAWAL_UNLOCK_FUNDS",
    //      "value": 0.05045,
    //      "fundsBefore": { "total": 0.86001578, "available": 0.80956578, "locked": 0.05045 },
    //      "fundsAfter": { "total": 0.86001578, "available": 0.86001578, "locked": 0 },
    //      "change": { "total": 0, "available": 0.05045, "locked": -0.05045 }
    //    }
    //
    //    TRANSACTION_COMMISSION_RETURN
    //    {
    //      "historyId": "07c89c27-46f1-4d7a-8518-b73798bf168a",
    //      "balance": {
    //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
    //        "currency": "EUR",
    //        "type": "FIAT",
    //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
    //        "name": "EUR"
    //      },
    //      "detailId": null,
    //      "time": 1528304043063,
    //      "type": "TRANSACTION_COMMISSION_RETURN",
    //      "value": 0.6,
    //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
    //      "fundsAfter": { "total": 0.6, "available": 0.6, "locked": 0 },
    //      "change": { "total": 0.6, "available": 0.6, "locked": 0 }
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(item, "time")
    var balance interface{} = this.SafeValue(item, "balance", map[string]interface{} {})
    var currencyId interface{} = this.SafeString(balance, "currency")
    currency = this.SafeCurrency(currencyId, currency)
    var change interface{} = this.SafeValue(item, "change", map[string]interface{} {})
    var amount interface{} = this.SafeString(change, "total")
    var direction interface{} = "in"
    if IsTrue(Precise.StringLt(amount, "0")) {
        direction = "out"
        amount = Precise.StringNeg(amount)
    }
    // there are 2 undocumented api calls: (v1_01PrivateGetPaymentsDepositDetailId and v1_01PrivateGetPaymentsWithdrawalDetailId)
    // that can be used to enrich the transfers with txid, address etc (you need to use info.detailId as a parameter)
    var fundsBefore interface{} = this.SafeValue(item, "fundsBefore", map[string]interface{} {})
    var fundsAfter interface{} = this.SafeValue(item, "fundsAfter", map[string]interface{} {})
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "historyId"),
        "direction": direction,
        "account": nil,
        "referenceId": this.SafeString(item, "detailId"),
        "referenceAccount": nil,
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "currency": this.SafeCurrencyCode(currencyId),
        "amount": this.ParseNumber(amount),
        "before": this.SafeNumber(fundsBefore, "total"),
        "after": this.SafeNumber(fundsAfter, "total"),
        "status": "ok",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": nil,
    }, currency)
}
func  (this *zonda) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "ADD_FUNDS": "transaction",
        "BITCOIN_GOLD_FORK": "transaction",
        "CREATE_BALANCE": "transaction",
        "FUNDS_MIGRATION": "transaction",
        "WITHDRAWAL_LOCK_FUNDS": "transaction",
        "WITHDRAWAL_SUBTRACT_FUNDS": "transaction",
        "WITHDRAWAL_UNLOCK_FUNDS": "transaction",
        "TRANSACTION_COMMISSION_OUTCOME": "fee",
        "TRANSACTION_COMMISSION_RETURN": "fee",
        "TRANSACTION_OFFER_ABORTED_RETURN": "trade",
        "TRANSACTION_OFFER_COMPLETED_RETURN": "trade",
        "TRANSACTION_POST_INCOME": "trade",
        "TRANSACTION_POST_OUTCOME": "trade",
        "TRANSACTION_PRE_LOCKING": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *zonda) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1582399800000",
    //         {
    //             "o": "0.0001428",
    //             "c": "0.0001428",
    //             "h": "0.0001428",
    //             "l": "0.0001428",
    //             "v": "4",
    //             "co": "1"
    //         }
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var first interface{} = this.SafeValue(ohlcv, 1, map[string]interface{} {})
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(first, "o"), this.SafeNumber(first, "h"), this.SafeNumber(first, "l"), this.SafeNumber(first, "c"), this.SafeNumber(first, "v")}
}
/**
 * @method
 * @name zonda#fetchOHLCV
 * @see https://docs.zondacrypto.exchange/reference/candles-chart
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *zonda) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13008 := (<-this.LoadMarkets())
            PanicOnError(retRes13008)
            var market interface{} = this.Market(symbol)
            var tradingSymbol interface{} = Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId"))
            var request interface{} = map[string]interface{} {
                "symbol": tradingSymbol,
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            } else {
                limit = mathMin(limit, 11000) // supports up to 11k candles diapason
            }
            var duration interface{} = this.ParseTimeframe(timeframe)
            var timerange interface{} = Multiply(Multiply(limit, duration), 1000)
            if IsTrue(IsEqual(since, nil)) {
                AddElementToObject(request, "to", this.Milliseconds())
                AddElementToObject(request, "from", Subtract(GetValue(request, "to"), timerange))
            } else {
                AddElementToObject(request, "from", since)
                AddElementToObject(request, "to", this.Sum(GetValue(request, "from"), timerange))
            }
        
            response:= (<-this.V1_01PublicGetTradingCandleHistorySymbolResolution(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"Ok",
            //         "items":[
            //             ["1591503060000",{"o":"0.02509572","c":"0.02509438","h":"0.02509664","l":"0.02509438","v":"0.02082165","co":"17"}],
            //             ["1591503120000",{"o":"0.02509606","c":"0.02509515","h":"0.02509606","l":"0.02509487","v":"0.04971703","co":"13"}],
            //             ["1591503180000",{"o":"0.02509532","c":"0.02509589","h":"0.02509589","l":"0.02509454","v":"0.01332236","co":"7"}],
            //         ]
            //     }
            //
            var items interface{} = this.SafeList(response, "items", []interface{}{})
        
            ch <- this.ParseOHLCVs(items, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder trades
    //
    //     {
    //         "rate": "0.02195928",
    //         "amount": "0.00167952"
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "amount": "0.29285199",
    //         "commissionValue": "0.00125927",
    //         "id": "11c8203a-a267-11e9-b698-0242ac110007",
    //         "initializedBy": "Buy",
    //         "market": "ETH-EUR",
    //         "offerId": "11c82038-a267-11e9-b698-0242ac110007",
    //         "rate": "277",
    //         "time": "1562689917517",
    //         "userAction": "Buy",
    //         "wasTaker": true,
    //     }
    //
    // fetchTrades (public)
    //
    //     {
    //          "id": "df00b0da-e5e0-11e9-8c19-0242ac11000a",
    //          "t": "1570108958831",
    //          "a": "0.04776653",
    //          "r": "0.02145854",
    //          "ty": "Sell"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "time", "t")
    var side interface{} = this.SafeStringLower2(trade, "userAction", "ty")
    var wasTaker interface{} = this.SafeValue(trade, "wasTaker")
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(wasTaker, nil)) {
        takerOrMaker = Ternary(IsTrue(wasTaker), "taker", "maker")
    }
    var priceString interface{} = this.SafeString2(trade, "rate", "r")
    var amountString interface{} = this.SafeString2(trade, "amount", "a")
    var feeCostString interface{} = this.SafeString(trade, "commissionValue")
    var marketId interface{} = this.SafeString(trade, "market")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrency interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), GetValue(market, "base"), GetValue(market, "quote"))
        fee = map[string]interface{} {
            "currency": feeCurrency,
            "cost": feeCostString,
        }
    }
    var order interface{} = this.SafeString(trade, "offerId")
    // todo: check this logic
    var typeVar interface{} = nil
    if IsTrue(!IsEqual(order, nil)) {
        typeVar = Ternary(IsTrue(order), "limit", "market")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "order": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name zonda#fetchTrades
 * @see https://docs.zondacrypto.exchange/reference/last-transactions
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *zonda) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14288 := (<-this.LoadMarkets())
            PanicOnError(retRes14288)
            var market interface{} = this.Market(symbol)
            var tradingSymbol interface{} = Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId"))
            var request interface{} = map[string]interface{} {
                "symbol": tradingSymbol,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromTime", Subtract(since, 1)) // result does not include exactly `since` time therefore decrease by 1
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default - 10, max - 300
            }
        
            response:= (<-this.V1_01PublicGetTradingTransactionsSymbol(this.Extend(request, params)))
            PanicOnError(response)
            var items interface{} = this.SafeList(response, "items")
        
            ch <- this.ParseTrades(items, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#createOrder
 * @description create a trade order
 * @see https://docs.zondacrypto.exchange/reference/new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zonda) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14598 := (<-this.LoadMarkets())
            PanicOnError(retRes14598)
            var market interface{} = this.Market(symbol)
            var tradingSymbol interface{} = Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId"))
            amount = ParseFloat(this.AmountToPrecision(symbol, amount))
            var request interface{} = map[string]interface{} {
                "symbol": tradingSymbol,
                "offerType": ToUpper(side),
                "amount": amount,
            }
            var stopLossPrice interface{} = this.SafeValue2(params, "stopPrice", "stopLossPrice")
            var isStopLossPrice interface{} = !IsEqual(stopLossPrice, nil)
            var isLimitOrder interface{} = IsEqual(typeVar, "limit")
            var isMarketOrder interface{} = IsEqual(typeVar, "market")
            var isStopLimit interface{} = IsTrue((IsEqual(typeVar, "stop-limit"))) || IsTrue((IsTrue(isLimitOrder) && IsTrue(isStopLossPrice)))
            var isStopMarket interface{} = IsTrue(IsEqual(typeVar, "stop-market")) || IsTrue((IsTrue(isMarketOrder) && IsTrue(isStopLossPrice)))
            var isStopOrder interface{} = IsTrue(isStopLimit) || IsTrue(isStopMarket)
            if IsTrue(IsTrue(isLimitOrder) || IsTrue(isStopLimit)) {
                AddElementToObject(request, "rate", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "mode", Ternary(IsTrue(isStopLimit), "stop-limit", "limit"))
            } else if IsTrue(IsTrue(isMarketOrder) || IsTrue(isStopMarket)) {
                AddElementToObject(request, "mode", Ternary(IsTrue(isStopMarket), "stop-market", "market"))
            } else {
                panic(ExchangeError(Add(this.Id, " createOrder() invalid type")))
            }
            params = this.Omit(params, []interface{}{"stopPrice", "stopLossPrice"})
            var response interface{} = nil
            if IsTrue(isStopOrder) {
                if !IsTrue(isStopLossPrice) {
                    panic(ExchangeError(Add(this.Id, " createOrder() zonda requires `triggerPrice` parameter for stop-limit or stop-market orders")))
                }
                AddElementToObject(request, "stopRate", this.PriceToPrecision(symbol, stopLossPrice))
                
        response = (<-this.V1_01PrivatePostTradingStopOfferSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1_01PrivatePostTradingOfferSymbol(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // unfilled (open order)
            //
            //     {
            //         "status": "Ok",
            //         "completed": false, // can deduce status from here
            //         "offerId": "ce9cc72e-d61c-11e9-9248-0242ac110005",
            //         "transactions": [], // can deduce order info from here
            //     }
            //
            // filled (closed order)
            //
            //     {
            //         "status": "Ok",
            //         "offerId": "942a4a3e-e922-11e9-8c19-0242ac11000a",
            //         "completed": true,
            //         "transactions": [
            //           {
            //             "rate": "0.02195928",
            //             "amount": "0.00167952"
            //           },
            //           {
            //             "rate": "0.02195928",
            //             "amount": "0.00167952"
            //           },
            //           {
            //             "rate": "0.02196207",
            //             "amount": "0.27704177"
            //           }
            //         ]
            //     }
            //
            // partially-filled (open order)
            //
            //     {
            //         "status": "Ok",
            //         "offerId": "d0ebefab-f4d7-11e9-8c19-0242ac11000a",
            //         "completed": false,
            //         "transactions": [
            //           {
            //             "rate": "0.02106404",
            //             "amount": "0.0019625"
            //           },
            //           {
            //             "rate": "0.02106404",
            //             "amount": "0.0019625"
            //           },
            //           {
            //             "rate": "0.02105901",
            //             "amount": "0.00975256"
            //           }
            //         ]
            //     }
            //
            var id interface{} = this.SafeString2(response, "offerId", "stopOfferId")
            var completed interface{} = this.SafeBool(response, "completed", false)
            var status interface{} = Ternary(IsTrue(completed), "closed", "open")
            var transactions interface{} = this.SafeValue(response, "transactions")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "info": response,
                "timestamp": nil,
                "datetime": nil,
                "lastTradeTimestamp": nil,
                "status": status,
                "symbol": symbol,
                "type": typeVar,
                "side": side,
                "price": price,
                "amount": amount,
                "cost": nil,
                "filled": nil,
                "remaining": nil,
                "average": nil,
                "fee": nil,
                "trades": transactions,
                "clientOrderId": nil,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#cancelOrder
 * @see https://docs.zondacrypto.exchange/reference/cancel-order
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zonda) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var side interface{} = this.SafeString(params, "side")
            if IsTrue(IsEqual(side, nil)) {
                panic(ExchangeError(Add(this.Id, " cancelOrder() requires a `side` parameter (\"buy\" or \"sell\")")))
            }
            var price interface{} = this.SafeValue(params, "price")
            if IsTrue(IsEqual(price, nil)) {
                panic(ExchangeError(Add(this.Id, " cancelOrder() requires a `price` parameter (float or string)")))
            }
        
            retRes15938 := (<-this.LoadMarkets())
            PanicOnError(retRes15938)
            var market interface{} = this.Market(symbol)
            var tradingSymbol interface{} = Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId"))
            var request interface{} = map[string]interface{} {
                "symbol": tradingSymbol,
                "id": id,
                "side": side,
                "price": price,
            }
        
            response:= (<-this.V1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.Extend(request, params)))
            PanicOnError(response)
        
                // { status: "Fail", errors: [ "NOT_RECOGNIZED_OFFER_TYPE" ] }  -- if required params are missing
            // { status: "Ok", errors: [] }
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) IsFiat(currency interface{}) interface{}  {
    var fiatCurrencies interface{} = map[string]interface{} {
        "USD": true,
        "EUR": true,
        "PLN": true,
    }
    return this.SafeBool(fiatCurrencies, currency, false)
}
func  (this *zonda) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
    //         "currency": "BTC",
    //         "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
    //         "balanceEngine": "BITBAY",
    //         "tag": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "network": nil,
        "address": address,
        "tag": this.SafeString(depositAddress, "tag"),
    }
}
/**
 * @method
 * @name zonda#fetchDepositAddress
 * @see https://docs.zondacrypto.exchange/reference/deposit-addresses-for-crypto
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.walletId] Wallet id to filter deposit adresses.
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *zonda) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16508 := (<-this.LoadMarkets())
            PanicOnError(retRes16508)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.V1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "Ok",
            //         "data": [{
            //                 "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
            //                 "currency": "BTC",
            //                 "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
            //                 "balanceEngine": "BITBAY",
            //                 "tag": null
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            var first interface{} = this.SafeDict(data, 0)
        
            ch <- this.ParseDepositAddress(first, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#fetchDepositAddresses
 * @see https://docs.zondacrypto.exchange/reference/deposit-addresses-for-crypto
 * @description fetch deposit addresses for multiple currencies and chain types
 * @param {string[]|undefined} codes zonda does not support filtering filtering by multiple codes and will ignore this parameter.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *zonda) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16848 := (<-this.LoadMarkets())
            PanicOnError(retRes16848)
        
            response:= (<-this.V1_01PrivateGetApiPaymentsDepositsCryptoAddresses(params))
            PanicOnError(response)
            //
            //     {
            //         "status": "Ok",
            //         "data": [{
            //                 "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
            //                 "currency": "BTC",
            //                 "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
            //                 "balanceEngine": "BITBAY",
            //                 "tag": null
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseDepositAddresses(data, codes)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zonda#transfer
 * @see https://docs.zondacrypto.exchange/reference/internal-transfer
 * @description transfer currency internally between wallets on the same account
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *zonda) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17168 := (<-this.LoadMarkets())
            PanicOnError(retRes17168)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "source": fromAccount,
                "destination": toAccount,
                "currency": code,
                "funds": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.V1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "Ok",
            //         "from": {
            //             "id": "ad9397c5-3bd9-4372-82ba-22da6a90cb56",
            //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
            //             "availableFunds": 0.01803472,
            //             "totalFunds": 0.01804161,
            //             "lockedFunds": 0.00000689,
            //             "currency": "BTC",
            //             "type": "CRYPTO",
            //             "name": "BTC",
            //             "balanceEngine": "BITBAY"
            //         },
            //         "to": {
            //             "id": "01931d52-536b-4ca5-a9f4-be28c86d0cc3",
            //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
            //             "availableFunds": 0.0001,
            //             "totalFunds": 0.0001,
            //             "lockedFunds": 0,
            //             "currency": "BTC",
            //             "type": "CRYPTO",
            //             "name": "Prowizja",
            //             "balanceEngine": "BITBAY"
            //         },
            //         "errors": null
            //     }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
            var transferOptions interface{} = this.SafeValue(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "amount", amount)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "status": "Ok",
    //         "from": {
    //             "id": "ad9397c5-3bd9-4372-82ba-22da6a90cb56",
    //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
    //             "availableFunds": 0.01803472,
    //             "totalFunds": 0.01804161,
    //             "lockedFunds": 0.00000689,
    //             "currency": "BTC",
    //             "type": "CRYPTO",
    //             "name": "BTC",
    //             "balanceEngine": "BITBAY"
    //         },
    //         "to": {
    //             "id": "01931d52-536b-4ca5-a9f4-be28c86d0cc3",
    //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
    //             "availableFunds": 0.0001,
    //             "totalFunds": 0.0001,
    //             "lockedFunds": 0,
    //             "currency": "BTC",
    //             "type": "CRYPTO",
    //             "name": "Prowizja",
    //             "balanceEngine": "BITBAY"
    //         },
    //         "errors": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var status interface{} = this.SafeString(transfer, "status")
    var fromAccount interface{} = this.SafeValue(transfer, "from", map[string]interface{} {})
    var fromId interface{} = this.SafeString(fromAccount, "id")
    var to interface{} = this.SafeValue(transfer, "to", map[string]interface{} {})
    var toId interface{} = this.SafeString(to, "id")
    var currencyId interface{} = this.SafeString(fromAccount, "currency")
    return map[string]interface{} {
        "info": transfer,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": nil,
        "fromAccount": fromId,
        "toAccount": toId,
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *zonda) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Ok": "ok",
        "Fail": "failed",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name zonda#withdraw
 * @see https://docs.zondacrypto.exchange/reference/crypto-withdrawal-1
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *zonda) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes18338 := (<-this.LoadMarkets())
            PanicOnError(retRes18338)
            var response interface{} = nil
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
            }
            if IsTrue(this.IsFiat(code)) {
                // request['swift'] = params['swift']; // Bank identifier, if required.
                
        response = (<-this.V1_01PrivatePostApiPaymentsWithdrawalsFiat(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(tag, nil)) {
                    AddElementToObject(request, "tag", tag)
                }
                
        response = (<-this.V1_01PrivatePostApiPaymentsWithdrawalsCrypto(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "status": "Ok",
            //         "data": {
            //           "id": "65e01087-afb0-4ab2-afdb-cc925e360296"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *zonda) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "id": "65e01087-afb0-4ab2-afdb-cc925e360296"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    currency = this.SafeCurrency(nil, currency)
    return map[string]interface{} {
        "id": this.SafeString(transaction, "id"),
        "txid": nil,
        "timestamp": nil,
        "datetime": nil,
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "amount": nil,
        "type": nil,
        "currency": GetValue(currency, "code"),
        "status": nil,
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "info": transaction,
    }
}
func  (this *zonda) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api))
    if IsTrue(IsEqual(api, "public")) {
        var query interface{} = this.Omit(params, this.ExtractParams(path))
        url = Add(url, Add(Add("/", this.ImplodeParams(path, params)), ".json"))
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "v1_01Public")) {
        var query interface{} = this.Omit(params, this.ExtractParams(path))
        url = Add(url, Add("/", this.ImplodeParams(path, params)))
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "v1_01Private")) {
        this.CheckRequiredCredentials()
        var query interface{} = this.Omit(params, this.ExtractParams(path))
        url = Add(url, Add("/", this.ImplodeParams(path, params)))
        var nonce interface{} = ToString(this.Milliseconds())
        var payload interface{} = nil
        if IsTrue(!IsEqual(method, "POST")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
            payload = Add(this.ApiKey, nonce)
        } else if IsTrue(IsEqual(body, nil)) {
            body = this.Json(query)
            payload = Add(Add(this.ApiKey, nonce), body)
        }
        headers = map[string]interface{} {
            "Request-Timestamp": nonce,
            "Operation-Id": this.Uuid(),
            "API-Key": this.ApiKey,
            "API-Hash": this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha512),
            "Content-Type": "application/json",
        }
    } else {
        this.CheckRequiredCredentials()
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "method": path,
            "moment": this.Nonce(),
        }, params))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "API-Key": this.ApiKey,
            "API-Hash": this.Hmac(this.Encode(body), this.Encode(this.Secret), sha512),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *zonda) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "code")) {
        //
        // bitbay returns the integer "success": 1 key from their private API
        // or an integer "code" value from 0 to 510 and an error message
        //
        //      { "success": 1, ... }
        //      { 'code': 502, "message": "Invalid sign" }
        //      { 'code': 0, "message": "offer funds not exceeding minimums" }
        //
        //      400 At least one parameter wasn't set
        //      401 Invalid order type
        //      402 No orders with specified currencies
        //      403 Invalid payment currency name
        //      404 Error. Wrong transaction type
        //      405 Order with this id doesn't exist
        //      406 No enough money or crypto
        //      408 Invalid currency name
        //      501 Invalid public key
        //      502 Invalid sign
        //      503 Invalid moment parameter. Request time doesn't match current server time
        //      504 Invalid method
        //      505 Key has no permission for this action
        //      506 Account locked. Please contact with customer service
        //      509 The BIC/SWIFT is required for this currency
        //      510 Invalid market name
        //
        var code interface{} = this.SafeString(response, "code") // always an integer
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(this.Exceptions, code, feedback)
        panic(ExchangeError(feedback))
    } else if IsTrue(InOp(response, "status")) {
        //
        //      {"status":"Fail","errors":["OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS"]}
        //
        var status interface{} = this.SafeString(response, "status")
        if IsTrue(IsEqual(status, "Fail")) {
            var errors interface{} = this.SafeValue(response, "errors")
            var feedback interface{} = Add(Add(this.Id, " "), body)
            for i := 0; IsLessThan(i, GetArrayLength(errors)); i++ {
                var error interface{} = GetValue(errors, i)
                this.ThrowExactlyMatchedException(this.Exceptions, error, feedback)
            }
            panic(ExchangeError(feedback))
        }
    }
    return nil
}


func (this *zonda) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
