package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type novadax struct {
    Exchange

}

func NewNovadaxCore() novadax {
   p := novadax{}
   setDefaults(&p)
   return p
}

func  (this *novadax) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "novadax",
        "name": "NovaDAX",
        "countries": []interface{}{"BR"},
        "rateLimit": 10,
        "version": "v1",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactions": "emulated",
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "ONE_MIN",
            "5m": "FIVE_MIN",
            "15m": "FIFTEEN_MIN",
            "30m": "HALF_HOU",
            "1h": "ONE_HOU",
            "1d": "ONE_DAY",
            "1w": "ONE_WEE",
            "1M": "ONE_MON",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/92337550-2b085500-f0b3-11ea-98e7-5794fb07dd3b.jpg",
            "api": map[string]interface{} {
                "public": "https://api.novadax.com",
                "private": "https://api.novadax.com",
            },
            "www": "https://www.novadax.com.br",
            "doc": []interface{}{"https://doc.novadax.com/pt-BR/"},
            "fees": "https://www.novadax.com.br/fees-and-limits",
            "referral": "https://www.novadax.com.br/?s=ccxt",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "common/symbol": 1,
                    "common/symbols": 1,
                    "common/timestamp": 1,
                    "market/tickers": 5,
                    "market/ticker": 1,
                    "market/depth": 1,
                    "market/trades": 5,
                    "market/kline/history": 5,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "orders/get": 1,
                    "orders/list": 10,
                    "orders/fill": 3,
                    "orders/fills": 10,
                    "account/getBalance": 1,
                    "account/subs": 1,
                    "account/subs/balance": 1,
                    "account/subs/transfer/record": 10,
                    "wallet/query/deposit-withdraw": 3,
                },
                "post": map[string]interface{} {
                    "orders/create": 5,
                    "orders/batch-create": 50,
                    "orders/cancel": 1,
                    "orders/batch-cancel": 10,
                    "orders/cancel-by-symbol": 10,
                    "account/subs/transfer": 5,
                    "wallet/withdraw/coin": 3,
                    "account/withdraw/coin": 3,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.005"),
                "maker": this.ParseNumber("0.0025"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "A99999": ExchangeError,
                "A10001": BadRequest,
                "A10002": ExchangeError,
                "A10003": AuthenticationError,
                "A10004": RateLimitExceeded,
                "A10005": PermissionDenied,
                "A10006": AccountSuspended,
                "A10007": AccountNotEnabled,
                "A10011": BadSymbol,
                "A10012": BadSymbol,
                "A10013": OnMaintenance,
                "A30001": OrderNotFound,
                "A30002": InvalidOrder,
                "A30003": InvalidOrder,
                "A30004": InvalidOrder,
                "A30005": InvalidOrder,
                "A30006": InvalidOrder,
                "A30007": InsufficientFunds,
                "A30008": InvalidOrder,
                "A30009": InvalidOrder,
                "A30010": CancelPending,
                "A30011": InvalidOrder,
                "A30012": InvalidOrder,
                "A40004": InsufficientFunds,
            },
            "broad": map[string]interface{} {},
        },
        "options": map[string]interface{} {
            "fetchOHLCV": map[string]interface{} {
                "volume": "amount",
            },
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": true,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name novadax#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://doc.novadax.com/en-US/#get-current-system-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *novadax) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCommonTimestamp(params))
            PanicOnError(response)
        
                //
            //     {
            //         "code":"A10000",
            //         "data":1599090512080,
            //         "message":"Success"
            //     }
            //
        ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchMarkets
 * @description retrieves data on all markets for novadax
 * @see https://doc.novadax.com/en-US/#get-all-supported-trading-symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *novadax) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCommonSymbols(params))
            PanicOnError(response)
            //
            //     {
            //         "code":"A10000",
            //         "data":[
            //             {
            //                 "amountPrecision":8,
            //                 "baseCurrency":"BTC",
            //                 "minOrderAmount":"0.001",
            //                 "minOrderValue":"25",
            //                 "pricePrecision":2,
            //                 "quoteCurrency":"BRL",
            //                 "status":"ONLINE",
            //                 "symbol":"BTC_BRL",
            //                 "valuePrecision":2
            //             },
            //         ],
            //         "message":"Success"
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseMarket(market interface{}) interface{}  {
    var baseId interface{} = this.SafeString(market, "baseCurrency")
    var quoteId interface{} = this.SafeString(market, "quoteCurrency")
    var id interface{} = this.SafeString(market, "symbol")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var status interface{} = this.SafeString(market, "status")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsEqual(status, "ONLINE")),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amountPrecision"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minOrderAmount"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "minOrderValue"),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
func  (this *novadax) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker, fetchTickers
    //
    //     {
    //         "ask":"61946.1",
    //         "baseVolume24h":"164.41930186",
    //         "bid":"61815",
    //         "high24h":"64930.72",
    //         "lastPrice":"61928.41",
    //         "low24h":"61156.32",
    //         "open24h":"64512.46",
    //         "quoteVolume24h":"10308157.95",
    //         "symbol":"BTC_BRL",
    //         "timestamp":1599091115090
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var open interface{} = this.SafeString(ticker, "open24h")
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var baseVolume interface{} = this.SafeString(ticker, "baseVolume24h")
    var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high24h"),
        "low": this.SafeString(ticker, "low24h"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name novadax#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.novadax.com/en-US/#get-latest-ticker-for-specific-pair
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *novadax) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4658 := (<-this.LoadMarkets())
            PanicOnError(retRes4658)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":"A10000",
            //         "data":{
            //             "ask":"61946.1",
            //             "baseVolume24h":"164.41930186",
            //             "bid":"61815",
            //             "high24h":"64930.72",
            //             "lastPrice":"61928.41",
            //             "low24h":"61156.32",
            //             "open24h":"64512.46",
            //             "quoteVolume24h":"10308157.95",
            //             "symbol":"BTC_BRL",
            //             "timestamp":1599091115090
            //         },
            //         "message":"Success"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://doc.novadax.com/en-US/#get-latest-tickers-for-all-trading-pairs
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *novadax) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5038 := (<-this.LoadMarkets())
            PanicOnError(retRes5038)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetMarketTickers(params))
            PanicOnError(response)
            //
            //     {
            //         "code":"A10000",
            //         "data":[
            //             {
            //                 "ask":"61879.36",
            //                 "baseVolume24h":"164.40955092",
            //                 "bid":"61815",
            //                 "high24h":"64930.72",
            //                 "lastPrice":"61820.04",
            //                 "low24h":"61156.32",
            //                 "open24h":"64624.19",
            //                 "quoteVolume24h":"10307493.92",
            //                 "symbol":"BTC_BRL",
            //                 "timestamp":1599091291083
            //             },
            //         ],
            //         "message":"Success"
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(data, i))
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://doc.novadax.com/en-US/#get-market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *novadax) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5478 := (<-this.LoadMarkets())
            PanicOnError(retRes5478)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 10, max 20
            }
        
            response:= (<-this.PublicGetMarketDepth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":"A10000",
            //         "data":{
            //             "asks":[
            //                 ["0.037159","0.3741"],
            //                 ["0.037215","0.2706"],
            //                 ["0.037222","1.8459"],
            //             ],
            //             "bids":[
            //                 ["0.037053","0.3857"],
            //                 ["0.036969","0.8101"],
            //                 ["0.036953","1.5226"],
            //             ],
            //             "timestamp":1599280414448
            //         },
            //         "message":"Success"
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "timestamp")
        
            ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks")
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "amount":"0.0632",
    //         "price":"0.037288",
    //         "side":"BUY",
    //         "timestamp":1599279694576
    //     }
    //
    // private fetchOrderTrades
    //
    //      {
    //          "id": "608717046691139584",
    //          "orderId": "608716957545402368",
    //          "symbol": "BTC_BRL",
    //          "side": "BUY",
    //          "amount": "0.0988",
    //          "price": "45514.76",
    //          "fee": "0.0000988 BTC",
    //          "feeAmount": "0.0000988",
    //          "feeCurrency": "BTC",
    //          "role": "MAKER",
    //          "timestamp": 1565171053345
    //       }
    //
    // private fetchMyTrades (same endpoint as fetchOrderTrades)
    //
    //      {
    //          "id": "608717046691139584",
    //          "orderId": "608716957545402368",
    //          "symbol": "BTC_BRL",
    //          "side": "BUY",
    //          "amount": "0.0988",
    //          "price": "45514.76",
    //          "fee": "0.0000988 BTC",
    //          "feeAmount": "0.0000988",
    //          "feeCurrency": "BTC",
    //          "role": "MAKER",
    //          "timestamp": 1565171053345
    //       }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "id")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var side interface{} = this.SafeStringLower(trade, "side")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var takerOrMaker interface{} = this.SafeStringLower(trade, "role")
    var feeString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "feeCurrency")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": this.SafeString(trade, "feeAmount"),
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name novadax#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://doc.novadax.com/en-US/#get-recent-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *novadax) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6718 := (<-this.LoadMarkets())
            PanicOnError(retRes6718)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
        
            response:= (<-this.PublicGetMarketTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":"A10000",
            //         "data":[
            //             {"amount":"0.0632","price":"0.037288","side":"BUY","timestamp":1599279694576},
            //             {"amount":"0.0052","price":"0.03715","side":"SELL","timestamp":1599276606852},
            //             {"amount":"0.0058","price":"0.037188","side":"SELL","timestamp":1599275187812},
            //         ],
            //         "message":"Success"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://doc.novadax.com/en-US/#get-kline-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *novadax) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7088 := (<-this.LoadMarkets())
            PanicOnError(retRes7088)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "unit": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var duration interface{} = this.ParseTimeframe(timeframe)
            var now interface{} = this.Seconds()
            if IsTrue(IsEqual(limit, nil)) {
                limit = 3000 // max
            }
            if IsTrue(IsEqual(since, nil)) {
                AddElementToObject(request, "from", Subtract(now, Multiply(limit, duration)))
                AddElementToObject(request, "to", now)
            } else {
                var startFrom interface{} = this.ParseToInt(Divide(since, 1000))
                AddElementToObject(request, "from", startFrom)
                AddElementToObject(request, "to", this.Sum(startFrom, Multiply(limit, duration)))
            }
        
            response:= (<-this.PublicGetMarketKlineHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": [
            //             {
            //                 "amount": 8.25709100,
            //                 "closePrice": 62553.20,
            //                 "count": 29,
            //                 "highPrice": 62592.87,
            //                 "lowPrice": 62553.20,
            //                 "openPrice": 62554.23,
            //                 "score": 1602501480,
            //                 "symbol": "BTC_BRL",
            //                 "vol": 516784.2504067500
            //             }
            //         ],
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "amount": 8.25709100,
    //         "closePrice": 62553.20,
    //         "count": 29,
    //         "highPrice": 62592.87,
    //         "lowPrice": 62553.20,
    //         "openPrice": 62554.23,
    //         "score": 1602501480,
    //         "symbol": "BTC_BRL",
    //         "vol": 516784.2504067500
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var options interface{} = this.SafeValue(this.Options, "fetchOHLCV", map[string]interface{} {})
    var volumeField interface{} = this.SafeString(options, "volume", "amount") // or vol
    return []interface{}{this.SafeTimestamp(ohlcv, "score"), this.SafeNumber(ohlcv, "openPrice"), this.SafeNumber(ohlcv, "highPrice"), this.SafeNumber(ohlcv, "lowPrice"), this.SafeNumber(ohlcv, "closePrice"), this.SafeNumber(ohlcv, volumeField)}
}
func  (this *novadax) ParseBalance(response interface{}) interface{}  {
    var data interface{} = this.SafeValue(response, "data", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
        var balance interface{} = GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(account, "used", this.SafeString(balance, "hold"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name novadax#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://doc.novadax.com/en-US/#get-account-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *novadax) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8068 := (<-this.LoadMarkets())
            PanicOnError(retRes8068)
        
            response:= (<-this.PrivateGetAccountGetBalance(params))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "A10000",
            //         "data": [
            //             {
            //                 "available": "1.23",
            //                 "balance": "0.23",
            //                 "currency": "BTC",
            //                 "hold": "1"
            //             }
            //         ],
            //         "message": "Success"
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#createOrder
 * @description create a trade order
 * @see https://doc.novadax.com/en-US/#order-introduction
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] for spot market buy orders, the quote quantity that can be used as an alternative for the amount
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8408 := (<-this.LoadMarkets())
            PanicOnError(retRes8408)
            var market interface{} = this.Market(symbol)
            var uppercaseType interface{} = ToUpper(typeVar)
            var uppercaseSide interface{} = ToUpper(side)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": uppercaseSide,
            }
            var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
            if IsTrue(IsEqual(triggerPrice, nil)) {
                if IsTrue(IsTrue((IsEqual(uppercaseType, "STOP_LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_MARKET")))) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a stopPrice parameter for "), uppercaseType), " orders")))
                }
            } else {
                if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
                    uppercaseType = "STOP_LIMIT"
                } else if IsTrue(IsEqual(uppercaseType, "MARKET")) {
                    uppercaseType = "STOP_MARKET"
                }
                var defaultOperator interface{} = Ternary(IsTrue((IsEqual(uppercaseSide, "BUY"))), "LTE", "GTE")
                AddElementToObject(request, "operator", this.SafeString(params, "operator", defaultOperator))
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
                params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice"})
            }
            if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            } else if IsTrue(IsTrue((IsEqual(uppercaseType, "MARKET"))) || IsTrue((IsEqual(uppercaseType, "STOP_MARKET")))) {
                if IsTrue(IsEqual(uppercaseSide, "SELL")) {
                    AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                } else if IsTrue(IsEqual(uppercaseSide, "BUY")) {
                    var quoteAmount interface{} = nil
                    var createMarketBuyOrderRequiresPrice interface{} = true
                    createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                    params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                    var cost interface{} = this.SafeNumber2(params, "cost", "value")
                    params = this.Omit(params, "cost")
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsEqual(price, nil)) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var costRequest interface{} = Precise.StringMul(amountString, priceString)
                            quoteAmount = this.CostToPrecision(symbol, costRequest)
                        }
                    } else {
                        quoteAmount = this.CostToPrecision(symbol, amount)
                    }
                    AddElementToObject(request, "value", quoteAmount)
                }
            }
            AddElementToObject(request, "type", uppercaseType)
        
            response:= (<-this.PrivatePostOrdersCreate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": {
            //             "amount": "0.001",
            //             "averagePrice": null,
            //             "filledAmount": "0",
            //             "filledFee": "0",
            //             "filledValue": "0",
            //             "id": "870613508008464384",
            //             "operator": "GTE",
            //             "price": "210000",
            //             "side": "BUY",
            //             "status": "SUBMITTED",
            //             "stopPrice": "211000",
            //             "symbol": "BTC_BRL",
            //             "timestamp": 1627612035528,
            //             "type": "STOP_LIMIT",
            //             "value": "210"
            //         },
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#cancelOrder
 * @description cancels an open order
 * @see https://doc.novadax.com/en-US/#cancel-an-order
 * @param {string} id order id
 * @param {string} symbol not used by novadax cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9388 := (<-this.LoadMarkets())
            PanicOnError(retRes9388)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivatePostOrdersCancel(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": {
            //             "result": true
            //         },
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://doc.novadax.com/en-US/#get-order-details
 * @param {string} id order id
 * @param {string} symbol not used by novadax fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9678 := (<-this.LoadMarkets())
            PanicOnError(retRes9678)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrdersGet(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": {
            //             "id": "608695623247466496",
            //             "symbol": "BTC_BRL",
            //             "type": "MARKET",
            //             "side": "SELL",
            //             "price": null,
            //             "averagePrice": "0",
            //             "amount": "0.123",
            //             "filledAmount": "0",
            //             "value": null,
            //             "filledValue": "0",
            //             "filledFee": "0",
            //             "status": "REJECTED",
            //             "timestamp": 1565165945588
            //         },
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://doc.novadax.com/en-US/#get-order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10098 := (<-this.LoadMarkets())
            PanicOnError(retRes10098)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100, max 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromTimestamp", since)
            }
        
            response:= (<-this.PrivateGetOrdersList(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": [
            //             {
            //                 "id": "608695678650028032",
            //                 "symbol": "BTC_BRL",
            //                 "type": "MARKET",
            //                 "side": "SELL",
            //                 "price": null,
            //                 "averagePrice": "0",
            //                 "amount": "0.123",
            //                 "filledAmount": "0",
            //                 "value": null,
            //                 "filledValue": "0",
            //                 "filledFee": "0",
            //                 "status": "REJECTED",
            //                 "timestamp": 1565165958796
            //             },
            //         ],
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://doc.novadax.com/en-US/#get-order-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "SUBMITTED,PROCESSING,PARTIAL_FILLED,CANCELING",
            }
        
                retRes107315 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes107315)
                ch <- retRes107315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://doc.novadax.com/en-US/#get-order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *novadax) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "FILLED,CANCELED,REJECTED",
            }
        
                retRes109115 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes109115)
                ch <- retRes109115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://doc.novadax.com/en-US/#get-order-match-details
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *novadax) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11078 := (<-this.LoadMarkets())
            PanicOnError(retRes11078)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrdersFill(this.Extend(request, params)))
            PanicOnError(response)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
                //
            //      {
            //          "code": "A10000",
            //          "data": [
            //              {
            //                  "id": "608717046691139584",
            //                  "orderId": "608716957545402368",
            //                  "symbol": "BTC_BRL",
            //                  "side": "BUY",
            //                  "amount": "0.0988",
            //                  "price": "45514.76",
            //                  "fee": "0.0000988 BTC",
            //                  "feeAmount": "0.0000988",
            //                  "feeCurrency": "BTC",
            //                  "role": "MAKER",
            //                  "timestamp": 1565171053345
            //              },
            //          ],
            //          "message": "Success"
            //      }
            //
        ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUBMITTED": "open",
        "PROCESSING": "open",
        "PARTIAL_FILLED": "open",
        "CANCELING": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "REJECTED": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *novadax) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, fetchOrders, fetchOrder
    //
    //     {
    //         "amount": "0.001",
    //         "averagePrice": null,
    //         "filledAmount": "0",
    //         "filledFee": "0",
    //         "filledValue": "0",
    //         "id": "870613508008464384",
    //         "operator": "GTE",
    //         "price": "210000",
    //         "side": "BUY",
    //         "status": "SUBMITTED",
    //         "stopPrice": "211000",
    //         "symbol": "BTC_BRL",
    //         "timestamp": 1627612035528,
    //         "type": "STOP_LIMIT",
    //         "value": "210"
    //     }
    //
    // cancelOrder
    //
    //     {
    //         "result": true
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var amount interface{} = this.SafeString(order, "amount")
    var price interface{} = this.SafeString(order, "price")
    var cost interface{} = this.SafeString2(order, "filledValue", "value")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var side interface{} = this.SafeStringLower(order, "side")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var average interface{} = this.SafeString(order, "averagePrice")
    var filled interface{} = this.SafeString(order, "filledAmount")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(order, "filledFee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": nil,
        }
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": this.SafeNumber(order, "stopPrice"),
        "amount": amount,
        "cost": cost,
        "average": average,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name novadax#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://doc.novadax.com/en-US/#get-sub-account-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *novadax) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12408 := (<-this.LoadMarkets())
            PanicOnError(retRes12408)
            var currency interface{} = this.Currency(code)
            if IsTrue(IsTrue(!IsEqual(fromAccount, "main")) && IsTrue(!IsEqual(toAccount, "main"))) {
                panic(ExchangeError(Add(this.Id, " transfer() supports transfers between main account and subaccounts only")))
            }
            // master-transfer-in = from master account to subaccount
            // master-transfer-out = from subaccount to master account
            var typeVar interface{} = Ternary(IsTrue((IsEqual(fromAccount, "main"))), "master-transfer-in", "master-transfer-out")
            var request interface{} = map[string]interface{} {
                "transferAmount": this.CurrencyToPrecision(code, amount),
                "currency": GetValue(currency, "id"),
                "subId": Ternary(IsTrue((IsEqual(typeVar, "master-transfer-in"))), toAccount, fromAccount),
                "transferType": typeVar,
            }
        
            response:= (<-this.PrivatePostAccountSubsTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code":"A10000",
            //        "message":"Success",
            //        "data":40
            //    }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
            var transferOptions interface{} = this.SafeValue(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "fromAccount", fromAccount)
                AddElementToObject(transfer, "toAccount", toAccount)
                AddElementToObject(transfer, "amount", amount)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "code":"A10000",
    //        "message":"Success",
    //        "data":40
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transfer, "data")
    var status interface{} = this.SafeString(transfer, "message")
    var currencyCode interface{} = this.SafeCurrencyCode(nil, currency)
    return map[string]interface{} {
        "info": transfer,
        "id": id,
        "amount": nil,
        "currency": currencyCode,
        "fromAccount": nil,
        "toAccount": nil,
        "timestamp": nil,
        "datetime": nil,
        "status": status,
    }
}
func  (this *novadax) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUCCESS": "pending",
    }
    return this.SafeString(statuses, status, "failed")
}
/**
 * @method
 * @name novadax#withdraw
 * @description make a withdrawal
 * @see https://doc.novadax.com/en-US/#send-cryptocurrencies
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *novadax) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes13188 := (<-this.LoadMarkets())
            PanicOnError(retRes13188)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "code": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "wallet": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "tag", tag)
            }
        
            response:= (<-this.PrivatePostAccountWithdrawCoin(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code":"A10000",
            //         "data": "DR123",
            //         "message":"Success"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://doc.novadax.com/en-US/#get-sub-account-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *novadax) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivateGetAccountSubs(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": [
            //             {
            //                 "subId": "CA648856083527372800",
            //                 "state": "Normal",
            //                 "subAccount": "003",
            //                 "subIdentify": "003"
            //             }
            //         ],
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var account interface{} = GetValue(data, i)
                var accountId interface{} = this.SafeString(account, "subId")
                var typeVar interface{} = this.SafeString(account, "subAccount")
                AppendToArray(&result,map[string]interface{} {
                    "id": accountId,
                    "type": typeVar,
                    "currency": nil,
                    "info": account,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://doc.novadax.com/en-US/#wallet-records-of-deposits-and-withdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *novadax) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "coin_in",
            }
        
                retRes139415 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes139415)
                ch <- retRes139415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://doc.novadax.com/en-US/#wallet-records-of-deposits-and-withdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *novadax) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "coin_out",
            }
        
                retRes141215 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes141215)
                ch <- retRes141215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name novadax#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://doc.novadax.com/en-US/#wallet-records-of-deposits-and-withdraws
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *novadax) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14278 := (<-this.LoadMarkets())
            PanicOnError(retRes14278)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.PrivateGetWalletQueryDepositWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "A10000",
            //         "data": [
            //             {
            //                 "id": "DR562339304588709888",
            //                 "type": "COIN_IN",
            //                 "currency": "XLM",
            //                 "chain": "XLM",
            //                 "address": "GCUTK7KHPJC3ZQJ3OMWWFHAK2OXIBRD4LNZQRCCOVE7A2XOPP2K5PU5Q",
            //                 "addressTag": "1000009",
            //                 "amount": 1.0,
            //                 "state": "SUCCESS",
            //                 "txHash": "39210645748822f8d4ce673c7559aa6622e6e9cdd7073bc0fcae14b1edfda5f4",
            //                 "createdAt": 1554113737000,
            //                 "updatedAt": 1601371273000
            //             }
            //         ],
            //         "message": "Success"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *novadax) ParseTransactionStatus(status interface{}) interface{}  {
    // Pending the record is wait broadcast to chain
    // x/M confirming the comfirming state of tx, the M is total confirmings needed
    // SUCCESS the record is success full
    // FAIL the record failed
    var parts interface{} = Split(status, " ")
    status = this.SafeString(parts, 1, status)
    var statuses interface{} = map[string]interface{} {
        "Pending": "pending",
        "confirming": "pending",
        "SUCCESS": "ok",
        "FAIL": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *novadax) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "code":"A10000",
    //         "data": "DR123",
    //         "message":"Success"
    //     }
    //
    // fetchDepositsWithdrawals
    //
    //     {
    //         "id": "DR562339304588709888",
    //         "type": "COIN_IN",
    //         "currency": "XLM",
    //         "chain": "XLM",
    //         "address": "GCUTK7KHPJC3ZQJ3OMWWFHAK2OXIBRD4LNZQRCCOVE7A2XOPP2K5PU5Q",
    //         "addressTag": "1000009",
    //         "amount": 1.0,
    //         "state": "SUCCESS",
    //         "txHash": "39210645748822f8d4ce673c7559aa6622e6e9cdd7073bc0fcae14b1edfda5f4",
    //         "createdAt": 1554113737000,
    //         "updatedAt": 1601371273000
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString2(transaction, "id", "data")
    var typeVar interface{} = this.SafeString(transaction, "type")
    if IsTrue(IsEqual(typeVar, "COIN_IN")) {
        typeVar = "deposit"
    } else if IsTrue(IsEqual(typeVar, "COIN_OUT")) {
        typeVar = "withdraw"
    }
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "addressTag")
    var txid interface{} = this.SafeString(transaction, "txHash")
    var timestamp interface{} = this.SafeInteger(transaction, "createdAt")
    var updated interface{} = this.SafeInteger(transaction, "updatedAt")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
    var network interface{} = this.SafeString(transaction, "chain")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "currency": code,
        "amount": amount,
        "network": network,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "tagFrom": nil,
        "status": status,
        "type": typeVar,
        "updated": updated,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "comment": nil,
        "internal": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
            "rate": nil,
        },
    }
}
/**
 * @method
 * @name novadax#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://doc.novadax.com/en-US/#get-order-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *novadax) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15688 := (<-this.LoadMarkets())
            PanicOnError(retRes15688)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromTimestamp", since)
            }
        
            response:= (<-this.PrivateGetOrdersFills(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "code": "A10000",
            //          "data": [
            //              {
            //                  "id": "608717046691139584",
            //                  "orderId": "608716957545402368",
            //                  "symbol": "BTC_BRL",
            //                  "side": "BUY",
            //                  "amount": "0.0988",
            //                  "price": "45514.76",
            //                  "fee": "0.0000988 BTC",
            //                  "feeAmount": "0.0000988",
            //                  "feeCurrency": "BTC",
            //                  "role": "MAKER",
            //                  "timestamp": 1565171053345
            //              },
            //          ],
            //          "message": "Success"
            //      }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *novadax) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), request)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Milliseconds())
        headers = map[string]interface{} {
            "X-Nova-Access-Key": this.ApiKey,
            "X-Nova-Timestamp": timestamp,
        }
        var queryString interface{} = nil
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(query)
            queryString = this.Hash(this.Encode(body), md5)
            AddElementToObject(headers, "Content-Type", "application/json")
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
            queryString = this.Urlencode(this.Keysort(query))
        }
        var auth interface{} = Add(Add(Add(Add(Add(Add(method, "\n"), request), "\n"), queryString), "\n"), timestamp) // eslint-disable-line quotes
        AddElementToObject(headers, "X-Nova-Signature", this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *novadax) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {"code":"A10003","data":[],"message":"Authentication failed, Invalid accessKey."}
    //
    var errorCode interface{} = this.SafeString(response, "code")
    if IsTrue(!IsEqual(errorCode, "A10000")) {
        var message interface{} = this.SafeString(response, "message")
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *novadax) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
