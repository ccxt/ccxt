package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type vertex struct {
    Exchange

}

func NewVertexCore() vertex {
   p := vertex{}
   setDefaults(&p)
   return p
}

func  (this *vertex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "vertex",
        "name": "Vertex",
        "countries": []interface{}{},
        "version": "v1",
        "rateLimit": 50,
        "certified": false,
        "pro": true,
        "dex": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": true,
            "future": true,
            "option": false,
            "addMargin": false,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelOrdersForSymbols": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createReduceOnlyOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "editOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDeposits": false,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginMode": nil,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyLiquidations": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenInterests": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": false,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": 60,
            "5m": 300,
            "15m": 900,
            "1h": 3600,
            "2h": 7200,
            "4h": 14400,
            "1d": 86400,
            "1w": 604800,
            "1M": 604800,
        },
        "hostname": "vertexprotocol.com",
        "urls": map[string]interface{} {
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/bd04a0fa-3b48-47b6-9d8b-124954d520a8",
            "api": map[string]interface{} {
                "v1": map[string]interface{} {
                    "archive": "https://archive.prod.{hostname}/v1",
                    "gateway": "https://gateway.prod.{hostname}/v1",
                    "trigger": "https://trigger.prod.{hostname}/v1",
                },
                "v2": map[string]interface{} {
                    "archive": "https://archive.prod.{hostname}/v2",
                    "gateway": "https://gateway.prod.{hostname}/v2",
                },
            },
            "test": map[string]interface{} {
                "v1": map[string]interface{} {
                    "archive": "https://archive.sepolia-test.{hostname}/v1",
                    "gateway": "https://gateway.sepolia-test.{hostname}/v1",
                    "trigger": "https://trigger.sepolia-test.{hostname}/v1",
                },
                "v2": map[string]interface{} {
                    "archive": "https://archive.sepolia-test.{hostname}/v2",
                    "gateway": "https://gateway.sepolia-test.{hostname}/v2",
                },
            },
            "www": "https://vertexprotocol.com/",
            "doc": "https://docs.vertexprotocol.com/",
            "fees": "https://docs.vertexprotocol.com/basics/fees",
            "referral": "https://app.vertexprotocol.com?referrer=0xCfC9BaB96a2eA3d3c3F031c005e82E1D9F295aC1",
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "archive": map[string]interface{} {
                    "post": map[string]interface{} {
                        "": 1,
                    },
                },
                "gateway": map[string]interface{} {
                    "get": map[string]interface{} {
                        "query": 1,
                        "symbols": 1,
                        "time": 1,
                    },
                    "post": map[string]interface{} {
                        "query": 1,
                        "execute": 1,
                    },
                },
                "trigger": map[string]interface{} {
                    "post": map[string]interface{} {
                        "execute": 1,
                        "query": 1,
                    },
                },
            },
            "v2": map[string]interface{} {
                "archive": map[string]interface{} {
                    "get": map[string]interface{} {
                        "tickers": 1,
                        "contracts": 1,
                        "trades": 1,
                        "vrtx": 1,
                    },
                },
                "gateway": map[string]interface{} {
                    "get": map[string]interface{} {
                        "assets": 0.6667,
                        "pairs": 1,
                        "orderbook": 1,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "swap": map[string]interface{} {
                "taker": this.ParseNumber("0.0002"),
                "maker": this.ParseNumber("0.0002"),
            },
            "spot": map[string]interface{} {
                "taker": this.ParseNumber("0.0002"),
                "maker": this.ParseNumber("0.0002"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": false,
            "secret": false,
            "walletAddress": true,
            "privateKey": true,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "1000": RateLimitExceeded,
                "1015": RateLimitExceeded,
                "1001": PermissionDenied,
                "1002": PermissionDenied,
                "1003": PermissionDenied,
                "2000": InvalidOrder,
                "2001": InvalidOrder,
                "2002": InvalidOrder,
                "2003": InvalidOrder,
                "2004": InvalidOrder,
                "2005": InvalidOrder,
                "2006": InvalidOrder,
                "2007": InvalidOrder,
                "2008": InvalidOrder,
                "2009": InvalidOrder,
                "2010": InvalidOrder,
                "2011": BadRequest,
                "2012": BadRequest,
                "2013": InvalidOrder,
                "2014": PermissionDenied,
                "2015": InvalidOrder,
                "2016": InvalidOrder,
                "2017": InvalidOrder,
                "2019": InvalidOrder,
                "2020": InvalidOrder,
                "2021": InvalidOrder,
                "2022": InvalidOrder,
                "2023": InvalidOrder,
                "2024": InsufficientFunds,
                "2025": InsufficientFunds,
                "2026": BadRequest,
                "2027": AuthenticationError,
                "2028": AuthenticationError,
                "2029": AuthenticationError,
                "2030": BadRequest,
                "2031": InvalidOrder,
                "2033": InvalidOrder,
                "2034": InvalidOrder,
                "2035": InvalidOrder,
                "2036": InvalidOrder,
                "2037": InvalidOrder,
                "2038": InvalidOrder,
                "2039": InvalidOrder,
                "2040": InvalidOrder,
                "2041": InvalidOrder,
                "2042": InvalidOrder,
                "2043": InvalidOrder,
                "2044": InvalidOrder,
                "2045": InvalidOrder,
                "2046": InvalidOrder,
                "2047": InvalidOrder,
                "2048": InvalidOrder,
                "2049": ExchangeError,
                "2050": PermissionDenied,
                "2051": InvalidOrder,
                "2052": InvalidOrder,
                "2053": InvalidOrder,
                "2054": InvalidOrder,
                "2055": InvalidOrder,
                "2056": InvalidOrder,
                "2057": InvalidOrder,
                "2058": InvalidOrder,
                "2059": InvalidOrder,
                "2060": InvalidOrder,
                "2061": InvalidOrder,
                "2062": InvalidOrder,
                "2063": InvalidOrder,
                "2064": InvalidOrder,
                "2065": InvalidOrder,
                "2066": InvalidOrder,
                "2067": InvalidOrder,
                "2068": InvalidOrder,
                "2069": InvalidOrder,
                "2070": InvalidOrder,
                "2071": InvalidOrder,
                "2072": InvalidOrder,
                "2073": InvalidOrder,
                "2074": InvalidOrder,
                "2075": InvalidOrder,
                "2076": InvalidOrder,
                "3000": BadRequest,
                "3001": BadRequest,
                "3002": BadRequest,
                "3003": BadRequest,
                "4000": BadRequest,
                "4001": ExchangeError,
                "4002": ExchangeError,
                "4003": ExchangeError,
                "4004": InvalidOrder,
                "5000": ExchangeError,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
        "commonCurrencies": map[string]interface{} {},
        "options": map[string]interface{} {
            "defaultType": "swap",
            "sandboxMode": false,
            "timeDifference": 0,
            "brokerId": 5930043274845996,
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": true,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
func  (this *vertex) SetSandboxMode(enabled interface{})  {
    this.Exchange.SetSandboxMode(enabled)
    AddElementToObject(this.Options, "sandboxMode", enabled)
}
func  (this *vertex) ConvertToX18(num interface{}) interface{}  {
    if IsTrue(IsString(num)) {
        return Precise.StringMul(num, "1000000000000000000")
    }
    var numStr interface{} = this.NumberToString(num)
    return Precise.StringMul(numStr, "1000000000000000000")
}
func  (this *vertex) ConvertFromX18(num interface{}) interface{}  {
    if IsTrue(IsString(num)) {
        return Precise.StringDiv(num, "1000000000000000000")
    }
    var numStr interface{} = this.NumberToString(num)
    return Precise.StringDiv(numStr, "1000000000000000000")
}
/**
 * @method
 * @name vertex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *vertex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.V2GatewayGetAssets(this.Extend(request, params)))
            PanicOnError(response)
            //
            // [
            //     {
            //         "product_id": 2,
            //         "ticker_id": "BTC-PERP_USDC",
            //         "market_type": "perp",
            //         "name": "Bitcoin Perp",
            //         "symbol": "BTC-PERP",
            //         "maker_fee": 0.0002,
            //         "taker_fee": 0,
            //         "can_withdraw": false,
            //         "can_deposit": false
            //     },
            //     {
            //         "product_id": 1,
            //         "ticker_id": "BTC_USDC",
            //         "market_type": "spot",
            //         "name": "Bitcoin",
            //         "symbol": "BTC",
            //         "taker_fee": 0.0003,
            //         "maker_fee": 0,
            //         "can_withdraw": true,
            //         "can_deposit": true
            //     }
            // ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var data interface{} = this.SafeDict(response, i, map[string]interface{} {})
                var tickerId interface{} = this.SafeString(data, "ticker_id")
                if IsTrue(IsTrue((!IsEqual(tickerId, nil))) && IsTrue((IsGreaterThan(GetIndexOf(tickerId, "PERP"), 0)))) {
                    continue
                }
                var id interface{} = this.SafeString(data, "product_id")
                var name interface{} = this.SafeString(data, "symbol")
                var code interface{} = this.SafeCurrencyCode(name)
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "name": name,
            "code": code,
            "precision": nil,
            "info": data,
            "active": nil,
            "deposit": this.SafeBool(data, "can_deposit"),
            "withdraw": this.SafeBool(data, "can_withdraw"),
            "networks": nil,
            "fee": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseMarket(market interface{}) interface{}  {
    //
    // {
    //     "type": "spot",
    //     "product_id": 3,
    //     "symbol": "WETH",
    //     "price_increment_x18": "100000000000000000",
    //     "size_increment": "10000000000000000",
    //     "min_size": "100000000000000000",
    //     "min_depth_x18": "5000000000000000000000",
    //     "max_spread_rate_x18": "2000000000000000",
    //     "maker_fee_rate_x18": "0",
    //     "taker_fee_rate_x18": "300000000000000",
    //     "long_weight_initial_x18": "900000000000000000",
    //     "long_weight_maintenance_x18": "950000000000000000"
    // }
    //
    var marketType interface{} = this.SafeString(market, "type")
    var quoteId interface{} = "USDC"
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var baseId interface{} = this.SafeString(market, "symbol")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var settleId interface{} = quoteId
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    var spot interface{} = IsEqual(marketType, "spot")
    var contract interface{} =     !IsTrue(spot)
    var swap interface{} =     !IsTrue(spot)
    if IsTrue(swap) {
        var splitSymbol interface{} = Split(base, "-")
        symbol = Add(Add(Add(Add(GetValue(splitSymbol, 0), "/"), quote), ":"), settle)
    }
    var priceIncrementX18 interface{} = this.SafeString(market, "price_increment_x18")
    var sizeIncrementX18 interface{} = this.SafeString(market, "size_increment")
    var minSizeX18 interface{} = this.SafeString(market, "min_size")
    var takerX18 interface{} = this.SafeNumber(market, "taker_fee_rate_x18")
    var makerX18 interface{} = this.SafeNumber(market, "maker_fee_rate_x18")
    var isInverse interface{} = Ternary(IsTrue((spot)), nil, false)
    var isLinear interface{} = Ternary(IsTrue((spot)), nil, true)
    var contractSize interface{} = Ternary(IsTrue((spot)), nil, this.ParseNumber("1"))
    return map[string]interface{} {
        "id": this.SafeString(market, "product_id"),
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": Ternary(IsTrue((spot)), nil, settle),
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": Ternary(IsTrue((spot)), nil, settleId),
        "type": Ternary(IsTrue((spot)), "spot", "swap"),
        "spot": spot,
        "margin": nil,
        "swap": swap,
        "future": false,
        "option": false,
        "active": true,
        "contract": contract,
        "linear": isLinear,
        "inverse": isInverse,
        "taker": this.ParseNumber(this.ConvertFromX18(takerX18)),
        "maker": this.ParseNumber(this.ConvertFromX18(makerX18)),
        "contractSize": contractSize,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ConvertFromX18(sizeIncrementX18)),
            "price": this.ParseNumber(this.ConvertFromX18(priceIncrementX18)),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.ParseNumber(this.ConvertFromX18(minSizeX18)),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name vertex#fetchMarkets
 * @description retrieves data on all markets for vertex
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *vertex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "symbols",
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": {
            //         "symbols": {
            //             "WETH": {
            //                 "type": "spot",
            //                 "product_id": 3,
            //                 "symbol": "WETH",
            //                 "price_increment_x18": "100000000000000000",
            //                 "size_increment": "10000000000000000",
            //                 "min_size": "100000000000000000",
            //                 "min_depth_x18": "5000000000000000000000",
            //                 "max_spread_rate_x18": "2000000000000000",
            //                 "maker_fee_rate_x18": "0",
            //                 "taker_fee_rate_x18": "300000000000000",
            //                 "long_weight_initial_x18": "900000000000000000",
            //                 "long_weight_maintenance_x18": "950000000000000000"
            //             }
            //         }
            //     },
            //     "request_type": "query_symbols"
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var markets interface{} = this.SafeDict(data, "symbols", map[string]interface{} {})
            var symbols interface{} = ObjectKeys(markets)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                var symbol interface{} = GetValue(symbols, i)
                var rawMarket interface{} = this.SafeDict(markets, symbol, map[string]interface{} {})
                AppendToArray(&result,this.ParseMarket(rawMarket))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *vertex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1GatewayGetTime(params))
            PanicOnError(response)
        
                // 1717481623452
        ch <- this.ParseNumber(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *vertex) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "status",
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": "active",
            //     "request_type": "query_status",
            // }
            //
            var status interface{} = this.SafeString(response, "data")
            if IsTrue(IsEqual(status, "active")) {
                status = "ok"
            } else {
                status = "error"
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //       "ticker_id": "ARB_USDC",
    //       "trade_id": 999994,
    //       "price": 1.1366122408151016,
    //       "base_filled": 175,
    //       "quote_filled": -198.90714214264278,
    //       "timestamp": 1691068943,
    //       "trade_type": "buy"
    // }
    // fetchMytrades
    // {
    //     "digest": "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
    //     "order": {
    //         "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
    //         "priceX18": "27544000000000000000000",
    //         "amount": "2000000000000000000",
    //         "expiration": "4611686020107119633",
    //         "nonce": "1761322608857448448"
    //     },
    //     "base_filled": "736000000000000000",
    //     "quote_filled": "-20276464287857571514302",
    //     "fee": "4055287857571514302",
    //     "sequencer_fee": "0"
    //     "cumulative_fee": "4055287857571514302",
    //     "cumulative_base_filled": "736000000000000000",
    //     "cumulative_quote_filled": "-20276464287857571514302",
    //     "submission_idx": "563012",
    //     "pre_balance": {
    //       "base": {
    //         "perp": {
    //           "product_id": 2,
    //           "lp_balance": {
    //             "amount": "0",
    //             "last_cumulative_funding_x18": "1823351297710837"
    //           },
    //           "balance": {
    //             "amount": "2686684000000000000000",
    //             "v_quote_balance": "-76348662407149297671587247",
    //             "last_cumulative_funding_x18": "134999841911604906604576"
    //           }
    //         }
    //       },
    //       "quote": null
    //     },
    //     "post_balance": {
    //       "base": {
    //         "perp": {
    //           "product_id": 2,
    //           "lp_balance": {
    //             "amount": "0",
    //             "last_cumulative_funding_x18": "1823351297710837"
    //           },
    //           "balance": {
    //             "amount": "2686013000000000000000",
    //             "v_quote_balance": "-76328351274188497671587247",
    //             "last_cumulative_funding_x18": "134999841911604906604576"
    //           }
    //         }
    //       },
    //       "quote": null
    //     }
    //   }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var price interface{} = nil
    var amount interface{} = nil
    var side interface{} = nil
    var fee interface{} = nil
    var feeCost interface{} = this.ConvertFromX18(this.SafeString(trade, "fee"))
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": nil,
        }
    }
    var id interface{} = this.SafeString2(trade, "trade_id", "submission_idx")
    var order interface{} = this.SafeString(trade, "digest")
    var timestamp interface{} = this.SafeTimestamp(trade, "timestamp")
    if IsTrue(IsEqual(timestamp, nil)) {
        // fetchMyTrades
        var baseBalance interface{} = this.SafeDict(this.SafeDict(trade, "pre_balance", map[string]interface{} {}), "base", map[string]interface{} {})
        var marketId interface{} = nil
        if IsTrue(InOp(baseBalance, "perp")) {
            marketId = this.SafeString(this.SafeDict(baseBalance, "perp", map[string]interface{} {}), "product_id")
        } else {
            marketId = this.SafeString(this.SafeDict(baseBalance, "spot", map[string]interface{} {}), "product_id")
        }
        market = this.SafeMarket(marketId)
        var subOrder interface{} = this.SafeDict(trade, "order", map[string]interface{} {})
        price = this.ConvertFromX18(this.SafeString(subOrder, "priceX18"))
        amount = this.ConvertFromX18(this.SafeString(trade, "base_filled"))
        if IsTrue(Precise.StringLt(amount, "0")) {
            side = "sell"
        } else {
            side = "buy"
        }
    } else {
        var tickerId interface{} = this.SafeString(trade, "ticker_id")
        var splitTickerId interface{} = Split(tickerId, "_")
        var splitSymbol interface{} = Split(GetValue(splitTickerId, 0), "-")
        var marketId interface{} = Add(GetValue(splitSymbol, 0), GetValue(splitTickerId, 1))
        market = this.SafeMarket(marketId, market)
        price = this.SafeString(trade, "price")
        amount = this.SafeString(trade, "base_filled")
        side = this.SafeStringLower(trade, "trade_type")
    }
    amount = Precise.StringAbs(amount)
    var symbol interface{} = GetValue(market, "symbol")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "order": order,
        "takerOrMaker": nil,
        "type": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name vertex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *vertex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes369287 := (<-this.LoadMarkets())
            PanicOnError(retRes369287)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = Add(GetValue(market, "baseId"), "_USDC")
            var request interface{} = map[string]interface{} {
                "ticker_id": marketId,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2ArchiveGetTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //       "ticker_id": "ARB_USDC",
            //       "trade_id": 999994,
            //       "price": 1.1366122408151016,
            //       "base_filled": 175,
            //       "quote_filled": -198.90714214264278,
            //       "timestamp": 1691068943,
            //       "trade_type": "buy"
            //     },
            //     {
            //       "ticker_id": "ARB_USDC",
            //       "trade_id": 999978,
            //       "price": 1.136512210806099,
            //       "base_filled": 175,
            //       "quote_filled": -198.8896368910673,
            //       "timestamp": 1691068882,
            //       "trade_type": "buy"
            //     }
            // ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/matches
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *vertex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes121159 := (<-this.LoadMarkets())
            PanicOnError(retRes121159)
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchMyTrades", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var market interface{} = nil
            var matchesRequest interface{} = map[string]interface{} {
                "subaccount": this.ConvertAddressToSender(userAddress),
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(matchesRequest, "product_ids", []interface{}{this.ParseToNumeric(GetValue(market, "id"))})
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(matchesRequest, "max_time", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(matchesRequest, "limit", limit)
            }
            var request interface{} = map[string]interface{} {
                "matches": matchesRequest,
            }
        
            response:= (<-this.V1ArchivePost(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "matches": [
            //       {
            //         "digest": "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
            //         "order": {
            //           "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //           "priceX18": "27544000000000000000000",
            //           "amount": "2000000000000000000",
            //           "expiration": "4611686020107119633",
            //           "nonce": "1761322608857448448"
            //         },
            //         "base_filled": "736000000000000000",
            //         "quote_filled": "-20276464287857571514302",
            //         "fee": "4055287857571514302",
            //         "sequencer_fee": "0"
            //         "cumulative_fee": "4055287857571514302",
            //         "cumulative_base_filled": "736000000000000000",
            //         "cumulative_quote_filled": "-20276464287857571514302",
            //         "submission_idx": "563012",
            //         "pre_balance": {
            //           "base": {
            //             "perp": {
            //               "product_id": 2,
            //               "lp_balance": {
            //                 "amount": "0",
            //                 "last_cumulative_funding_x18": "1823351297710837"
            //               },
            //               "balance": {
            //                 "amount": "2686684000000000000000",
            //                 "v_quote_balance": "-76348662407149297671587247",
            //                 "last_cumulative_funding_x18": "134999841911604906604576"
            //               }
            //             }
            //           },
            //           "quote": null
            //         },
            //         "post_balance": {
            //           "base": {
            //             "perp": {
            //               "product_id": 2,
            //               "lp_balance": {
            //                 "amount": "0",
            //                 "last_cumulative_funding_x18": "1823351297710837"
            //               },
            //               "balance": {
            //                 "amount": "2686013000000000000000",
            //                 "v_quote_balance": "-76328351274188497671587247",
            //                 "last_cumulative_funding_x18": "134999841911604906604576"
            //               }
            //             }
            //           },
            //           "quote": null
            //         }
            //       },
            //       {
            //         "digest": "0x0f6e5a0434e36d8e6d4fed950d3624b0d8c91a8a84efd156bb25c1382561c0c2",
            //         "order": {
            //           "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //           "priceX18": "27540000000000000000000",
            //           "amount": "2000000000000000000",
            //           "expiration": "4611686020107119623",
            //           "nonce": "1761322602510417920"
            //         },
            //         "base_filled": "723999999999999999",
            //         "quote_filled": "-19944943483044913474043",
            //         "fee": "5983483044913474042",
            //         "cumulative_fee": "11958484645393618085",
            //         "cumulative_base_filled": "1446999999999999998",
            //         "cumulative_quote_filled": "-39861640484645393618087",
            //         "submission_idx": "563011",
            //         "pre_balance": {
            //           "base": {
            //             "perp": {
            //               "product_id": 2,
            //               "lp_balance": {
            //                 "amount": "0",
            //                 "last_cumulative_funding_x18": "1823351297710837"
            //               },
            //               "balance": {
            //                 "amount": "2686684000000000000000",
            //                 "v_quote_balance": "-76348662407149297671587247",
            //                 "last_cumulative_funding_x18": "134999841911604906604576"
            //               }
            //             }
            //           },
            //           "quote": null
            //         },
            //         "post_balance": {
            //           "base": {
            //             "perp": {
            //               "product_id": 2,
            //               "lp_balance": {
            //                 "amount": "0",
            //                 "last_cumulative_funding_x18": "1823351297710837"
            //               },
            //               "balance": {
            //                 "amount": "2686013000000000000000",
            //                 "v_quote_balance": "-76328351274188497671587247",
            //                 "last_cumulative_funding_x18": "134999841911604906604576"
            //               }
            //             }
            //           },
            //           "quote": null
            //         }
            //       }
            //     ],
            //     "txs": [
            //       {
            //         "tx": {
            //           "match_orders": {
            //             "product_id": 2,
            //             "amm": true,
            //             "taker": {
            //               "order": {
            //                 "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //                 "price_x18": "27544000000000000000000",
            //                 "amount": "2000000000000000000",
            //                 "expiration": 4611686020107120000,
            //                 "nonce": 1761322608857448400
            //               },
            //               "signature": "0xe8fa7151bde348afa3b46dc52798046b7c8318f1b0a7f689710debbc094658cc1bf5a7e478ccc8278b625da0b9402c86b580d2e31e13831337dfd6153f4b37811b"
            //             },
            //             "maker": {
            //               "order": {
            //                 "sender": "0xebdbbcdbd2646c5f23a1e0806027eee5f71b074664656661756c740000000000",
            //                 "price_x18": "27544000000000000000000",
            //                 "amount": "-736000000000000000",
            //                 "expiration": 1679731669,
            //                 "nonce": 1761322585591644200
            //               },
            //               "signature": "0x47f9d47f0777f3ca0b13f07b7682dbeea098c0e377b87dcb025754fe34c900e336b8c7744e021fb9c46a4f8c6a1478bafa28bf0d023ae496aa3efa4d8e81df181c"
            //             }
            //           }
            //         },
            //         "submission_idx": "563012",
            //         "timestamp": "1679728133"
            //       },
            //       {
            //         "tx": {
            //           "match_orders": {
            //             "product_id": 1,
            //             "amm": true,
            //             "taker": {
            //               "order": {
            //                 "sender": "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //                 "price_x18": "27540000000000000000000",
            //                 "amount": "2000000000000000000",
            //                 "expiration": 4611686020107120000,
            //                 "nonce": 1761322602510418000
            //               },
            //               "signature": "0x826c68f1a3f76d9ffbe8041f8d45e969d31f1ab6f2ae2f6379d1493e479e56436091d6cf4c72e212dd2f1d2fa17c627c4c21bd6d281c77172b8af030488478b71c"
            //             },
            //             "maker": {
            //               "order": {
            //                 "sender": "0xf8d240d9514c9a4715d66268d7af3b53d619642564656661756c740000000000",
            //                 "price_x18": "27540000000000000000000",
            //                 "amount": "-724000000000000000",
            //                 "expiration": 1679731656,
            //                 "nonce": 1761322565506171000
            //               },
            //               "signature": "0xd8b6505b8d9b8c3cbfe793080976388035682c02a27893fb26b48a5b2bfe943f4162dea3a42e24e0dff5e2f74fbf77e33d83619140a2a581117c55e6cc236bdb1c"
            //             }
            //           }
            //         },
            //         "submission_idx": "563011",
            //         "timestamp": "1679728127"
            //       }
            //     ]
            // }
            //
            var trades interface{} = this.SafeList(response, "matches", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *vertex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes500903 := (<-this.LoadMarkets())
            PanicOnError(retRes500903)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = Add(GetValue(market, "baseId"), "_USDC")
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            }
            var request interface{} = map[string]interface{} {
                "ticker_id": marketId,
                "depth": limit,
            }
        
            response:= (<-this.V2GatewayGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "ticker_id": "ETH-PERP_USDC",
            //     "bids": [
            //         [
            //             1612.3,
            //             0.31
            //         ],
            //         [
            //             1612.0,
            //             0.93
            //         ],
            //         [
            //             1611.5,
            //             1.55
            //         ],
            //         [
            //             1610.8,
            //             2.17
            //         ]
            //     ],
            //     "asks": [
            //         [
            //             1612.9,
            //             0.93
            //         ],
            //         [
            //             1613.4,
            //             1.55
            //         ],
            //         [
            //             1614.1,
            //             2.17
            //         ]
            //     ],
            //     "timestamp": 1694375362016
            // }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "bids", "asks")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/fee-rates
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *vertex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes461817 := (<-this.LoadMarkets())
            PanicOnError(retRes461817)
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchTradingFees", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "type": "fee_rates",
                "sender": this.ConvertAddressToSender(userAddress),
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": {
            //       "taker_fee_rates_x18": [
            //         "0",
            //         "300000000000000",
            //         "200000000000000",
            //         "300000000000000",
            //         "200000000000000"
            //       ],
            //       "maker_fee_rates_x18": [
            //         "0",
            //         "0",
            //         "0",
            //         "0",
            //         "0"
            //       ],
            //       "liquidation_sequencer_fee": "250000000000000000",
            //       "health_check_sequencer_fee": "100000000000000000",
            //       "taker_sequencer_fee": "25000000000000000",
            //       "withdraw_sequencer_fees": [
            //         "10000000000000000",
            //         "40000000000000",
            //         "0",
            //         "600000000000000",
            //         "0"
            //       ]
            //     },
            //     "request_type": "query_fee_rates",
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var maker interface{} = this.SafeList(data, "maker_fee_rates_x18", []interface{}{})
            var taker interface{} = this.SafeList(data, "taker_fee_rates_x18", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(taker)); i++ {
                var market interface{} = this.SafeMarket(this.NumberToString(i))
                if IsTrue(IsEqual(GetValue(market, "id"), nil)) {
                    continue
                }
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(this.ConvertFromX18(GetValue(maker, i))),
            "taker": this.ParseNumber(this.ConvertFromX18(GetValue(taker, i))),
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // example response in fetchOHLCV
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "timestamp"), this.ParseNumber(this.ConvertFromX18(this.SafeString(ohlcv, "open_x18"))), this.ParseNumber(this.ConvertFromX18(this.SafeString(ohlcv, "high_x18"))), this.ParseNumber(this.ConvertFromX18(this.SafeString(ohlcv, "low_x18"))), this.ParseNumber(this.ConvertFromX18(this.SafeString(ohlcv, "close_x18"))), this.ParseNumber(this.ConvertFromX18(this.SafeString(ohlcv, "volume")))}
}
/**
 * @method
 * @name vertex#fetchOHLCV
 * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/candlesticks
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *vertex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes807104 := (<-this.LoadMarkets())
            PanicOnError(retRes807104)
            var market interface{} = this.Market(symbol)
            var ohlcvRequest interface{} = map[string]interface{} {
                "product_id": this.ParseToInt(GetValue(market, "id")),
                "granularity": this.SafeInteger(this.Timeframes, timeframe),
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(ohlcvRequest, "max_time", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(ohlcvRequest, "limit", mathMin(limit, 1000))
            }
            var request interface{} = map[string]interface{} {
                "candlesticks": ohlcvRequest,
            }
        
            response:= (<-this.V1ArchivePost(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "candlesticks": [
            //       {
            //         "product_id": 1,
            //         "granularity": 60,
            //         "submission_idx": "627709",
            //         "timestamp": "1680118140",
            //         "open_x18": "27235000000000000000000",
            //         "high_x18": "27298000000000000000000",
            //         "low_x18": "27235000000000000000000",
            //         "close_x18": "27298000000000000000000",
            //         "volume": "1999999999999999998"
            //       },
            //       {
            //         "product_id": 1,
            //         "granularity": 60,
            //         "submission_idx": "627699",
            //         "timestamp": "1680118080",
            //         "open_x18": "27218000000000000000000",
            //         "high_x18": "27245000000000000000000",
            //         "low_x18": "27218000000000000000000",
            //         "close_x18": "27245000000000000000000",
            //         "volume": "11852999999999999995"
            //       }
            //     ]
            // }
            //
            var rows interface{} = this.SafeList(response, "candlesticks", []interface{}{})
        
            ch <- this.ParseOHLCVs(rows, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseFundingRate(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "product_id": 4,
    //     "funding_rate_x18": "2447900598160952",
    //     "update_time": "1680116326"
    // }
    //
    // {
    //     "ETH-PERP_USDC": {
    //         "ticker_id": "ETH-PERP_USDC",
    //         "base_currency": "ETH-PERP",
    //         "quote_currency": "USDC",
    //         "last_price": 1620.3,
    //         "base_volume": 1309.2,
    //         "quote_volume": 2117828.093867611,
    //         "product_type": "perpetual",
    //         "contract_price": 1620.372642114429,
    //         "contract_price_currency": "USD",
    //         "open_interest": 1635.2,
    //         "open_interest_usd": 2649633.3443855145,
    //         "index_price": 1623.293496279935,
    //         "mark_price": 1623.398589416731,
    //         "funding_rate": 0.000068613217104332,
    //         "next_funding_rate_timestamp": 1694379600,
    //         "price_change_percent_24h": -0.6348599635253989
    //     }
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var fundingRate interface{} = this.SafeNumber(ticker, "funding_rate")
    if IsTrue(IsEqual(fundingRate, nil)) {
        var fundingRateX18 interface{} = this.SafeString(ticker, "funding_rate_x18")
        fundingRate = this.ParseNumber(this.ConvertFromX18(fundingRateX18))
    }
    var fundingTimestamp interface{} = this.SafeTimestamp2(ticker, "update_time", "next_funding_rate_timestamp")
    var markPrice interface{} = this.SafeNumber(ticker, "mark_price")
    var indexPrice interface{} = this.SafeNumber(ticker, "index_price")
    return map[string]interface{} {
        "info": ticker,
        "symbol": GetValue(market, "symbol"),
        "markPrice": markPrice,
        "indexPrice": indexPrice,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": fundingRate,
        "fundingTimestamp": fundingTimestamp,
        "fundingDatetime": this.Iso8601(fundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
/**
 * @method
 * @name vertex#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *vertex) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes769705 := (<-this.LoadMarkets())
            PanicOnError(retRes769705)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "funding_rate": map[string]interface{} {
                    "product_id": this.ParseToInt(GetValue(market, "id")),
                },
            }
        
            response:= (<-this.V1ArchivePost(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "product_id": 4,
            //     "funding_rate_x18": "2447900598160952",
            //     "update_time": "1680116326"
            // }
            //
        ch <- this.ParseFundingRate(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchFundingRates
 * @description fetches funding rates for multiple markets
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
 * @param {string[]} symbols unified symbols of the markets to fetch the funding rates for, all market funding rates are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *vertex) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes915802 := (<-this.LoadMarkets())
            PanicOnError(retRes915802)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
            }
        
            response:= (<-this.V2ArchiveGetContracts(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "ETH-PERP_USDC": {
            //         "ticker_id": "ETH-PERP_USDC",
            //         "base_currency": "ETH-PERP",
            //         "quote_currency": "USDC",
            //         "last_price": 1620.3,
            //         "base_volume": 1309.2,
            //         "quote_volume": 2117828.093867611,
            //         "product_type": "perpetual",
            //         "contract_price": 1620.372642114429,
            //         "contract_price_currency": "USD",
            //         "open_interest": 1635.2,
            //         "open_interest_usd": 2649633.3443855145,
            //         "index_price": 1623.293496279935,
            //         "mark_price": 1623.398589416731,
            //         "funding_rate": 0.000068613217104332,
            //         "next_funding_rate_timestamp": 1694379600,
            //         "price_change_percent_24h": -0.6348599635253989
            //     }
            // }
            //
            var keys interface{} = ObjectKeys(response)
            var fundingRates interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var tickerId interface{} = GetValue(keys, i)
                var parsedTickerId interface{} = Split(tickerId, "-")
                var data interface{} = GetValue(response, tickerId)
                var marketId interface{} = Add(GetValue(parsedTickerId, 0), "/USDC:USDC")
                var market interface{} = this.Market(marketId)
                var ticker interface{} = this.ParseFundingRate(data, market)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(fundingRates, symbol, ticker)
            }
        
            ch <- this.FilterByArray(fundingRates, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "ETH-PERP_USDC": {
    //         "ticker_id": "ETH-PERP_USDC",
    //         "base_currency": "ETH-PERP",
    //         "quote_currency": "USDC",
    //         "last_price": 1620.3,
    //         "base_volume": 1309.2,
    //         "quote_volume": 2117828.093867611,
    //         "product_type": "perpetual",
    //         "contract_price": 1620.372642114429,
    //         "contract_price_currency": "USD",
    //         "open_interest": 1635.2,
    //         "open_interest_usd": 2649633.3443855145,
    //         "index_price": 1623.293496279935,
    //         "mark_price": 1623.398589416731,
    //         "funding_rate": 0.000068613217104332,
    //         "next_funding_rate_timestamp": 1694379600,
    //         "price_change_percent_24h": -0.6348599635253989
    //     }
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(interest, "ticker_id")
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "openInterestAmount": this.SafeNumber(interest, "open_interest"),
        "openInterestValue": this.SafeNumber(interest, "open_interest_usd"),
        "timestamp": nil,
        "datetime": nil,
        "info": interest,
    }, market)
}
/**
 * @method
 * @name vertex#fetchOpenInterests
 * @description Retrieves the open interest for a list of symbols
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
 * @param {string[]} [symbols] a list of unified CCXT market symbols
 * @param {object} [params] exchange specific parameters
 * @returns {object[]} a list of [open interest structures]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *vertex) FetchOpenInterests(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes497270 := (<-this.LoadMarkets())
            PanicOnError(retRes497270)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V2ArchiveGetContracts(params))
            PanicOnError(response)
            //
            //     {
            //         "ADA-PERP_USDC": {
            //             "ticker_id": "ADA-PERP_USDC",
            //             "base_currency": "ADA-PERP",
            //             "quote_currency": "USDC",
            //             "last_price": 0.85506,
            //             "base_volume": 1241320.0,
            //             "quote_volume": 1122670.9080057142,
            //             "product_type": "perpetual",
            //             "contract_price": 0.8558601432685385,
            //             "contract_price_currency": "USD",
            //             "open_interest": 104040.0,
            //             "open_interest_usd": 89043.68930565874,
            //             "index_price": 0.8561952606869176,
            //             "mark_price": 0.856293781088936,
            //             "funding_rate": 0.000116153806226841,
            //             "next_funding_rate_timestamp": 1734685200,
            //             "price_change_percent_24h": -12.274325340321374
            //         },
            //     }
            //
            var parsedSymbols interface{} = []interface{}{}
            var results interface{} = []interface{}{}
            var markets interface{} = ObjectKeys(response)
            if IsTrue(IsEqual(symbols, nil)) {
                symbols = []interface{}{}
                for y := 0; IsLessThan(y, GetArrayLength(markets)); y++ {
                    var tickerId interface{} = GetValue(markets, y)
                    var parsedTickerId interface{} = Split(tickerId, "-")
                    var currentSymbol interface{} = Add(GetValue(parsedTickerId, 0), "/USDC:USDC")
                    if !IsTrue(this.InArray(currentSymbol, symbols)) {
                        AppendToArray(&symbols,currentSymbol)
                    }
                }
            }
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var marketId interface{} = GetValue(markets, i)
                var marketInner interface{} = this.SafeMarket(marketId)
                var openInterest interface{} = this.SafeDict(response, marketId, map[string]interface{} {})
                for j := 0; IsLessThan(j, GetArrayLength(symbols)); j++ {
                    var market interface{} = this.Market(GetValue(symbols, j))
                    var tickerId interface{} = Add(GetValue(market, "base"), "_USDC")
                    if IsTrue(IsEqual(GetValue(marketInner, "marketId"), tickerId)) {
                        AppendToArray(&parsedSymbols,GetValue(market, "symbol"))
                        AppendToArray(&results,this.ParseOpenInterest(openInterest, market))
                    }
                }
            }
        
            ch <- this.FilterByArray(results, "symbol", parsedSymbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchOpenInterest
 * @description Retrieves the open interest of a derivative trading pair
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *vertex) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes377463 := (<-this.LoadMarkets())
            PanicOnError(retRes377463)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
            }
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.V2ArchiveGetContracts(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "ETH-PERP_USDC": {
            //         "ticker_id": "ETH-PERP_USDC",
            //         "base_currency": "ETH-PERP",
            //         "quote_currency": "USDC",
            //         "last_price": 1620.3,
            //         "base_volume": 1309.2,
            //         "quote_volume": 2117828.093867611,
            //         "product_type": "perpetual",
            //         "contract_price": 1620.372642114429,
            //         "contract_price_currency": "USD",
            //         "open_interest": 1635.2,
            //         "open_interest_usd": 2649633.3443855145,
            //         "index_price": 1623.293496279935,
            //         "mark_price": 1623.398589416731,
            //         "funding_rate": 0.000068613217104332,
            //         "next_funding_rate_timestamp": 1694379600,
            //         "price_change_percent_24h": -0.6348599635253989
            //     }
            // }
            //
            var tickerId interface{} = Add(GetValue(market, "base"), "_USDC")
            var openInterest interface{} = this.SafeDict(response, tickerId, map[string]interface{} {})
        
            ch <- this.ParseOpenInterest(openInterest, market)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "ticker_id": "BTC_USDC",
    //         "base_currency": "BTC",
    //         "quote_currency": "USDC",
    //         "last_price": 25728.0,
    //         "base_volume": 552.048,
    //         "quote_volume": 14238632.207250029,
    //         "price_change_percent_24h": -0.6348599635253989
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var base interface{} = this.SafeString(ticker, "base_currency")
    var quote interface{} = this.SafeString(ticker, "quote_currency")
    var marketId interface{} = Add(Add(base, "/"), quote)
    if IsTrue(IsGreaterThan(GetIndexOf(base, "PERP"), 0)) {
        marketId = Add(Replace(marketId, "-PERP", ""), ":USDC")
    }
    market = this.Market(marketId)
    var last interface{} = this.SafeString(ticker, "last_price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "price_change_percent_24h"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "base_volume"),
        "quoteVolume": this.SafeString(ticker, "quote_volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name vertex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.vertexprotocol.com/developer-resources/api/v2/tickers
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *vertex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes75532 := (<-this.LoadMarkets())
            PanicOnError(retRes75532)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.V2ArchiveGetTickers(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "ETH_USDC": {
            //         "ticker_id": "ETH_USDC",
            //         "base_currency": "ETH",
            //         "quote_currency": "USDC",
            //         "last_price": 1619.1,
            //         "base_volume": 1428.32,
            //         "quote_volume": 2310648.316391866,
            //         "price_change_percent_24h": -1.0509394462969588
            //     },
            //     "BTC_USDC": {
            //         "ticker_id": "BTC_USDC",
            //         "base_currency": "BTC",
            //         "quote_currency": "USDC",
            //         "last_price": 25728.0,
            //         "base_volume": 552.048,
            //         "quote_volume": 14238632.207250029,
            //         "price_change_percent_24h": -0.6348599635253989
            //     }
            // }
            //
            var tickers interface{} = ObjectValues(response)
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) QueryContracts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // query contract addresses for sending order
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var cachedContracts interface{} = this.SafeDict(this.Options, "v1contracts")
            if IsTrue(!IsEqual(cachedContracts, nil)) {
        
                ch <- cachedContracts
                return nil
            }
            var request interface{} = map[string]interface{} {
                "type": "contracts",
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            AddElementToObject(this.Options, "v1contracts", data)
        
            ch <- data
            return nil
        
            }()
            return ch
        }
func  (this *vertex) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *vertex) HashMessage(message interface{}) interface{}  {
    return Add("0x", this.Hash(message, keccak, "hex"))
}
func  (this *vertex) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    var r interface{} = GetValue(signature, "r")
    var s interface{} = GetValue(signature, "s")
    var v interface{} = this.IntToBase16(this.Sum(27, GetValue(signature, "v")))
    return Add(Add(Add("0x", PadStart(r, 64, "0")), PadStart(s, 64, "0")), v)
}
func  (this *vertex) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func  (this *vertex) BuildSig(chainId interface{}, messageTypes interface{}, message interface{}, optionalArgs ...interface{}) interface{}  {
    verifyingContractAddress := GetArg(optionalArgs, 0, "")
    _ = verifyingContractAddress
    var domain interface{} = map[string]interface{} {
        "chainId": chainId,
        "name": "Vertex",
        "verifyingContract": verifyingContractAddress,
        "version": "0.0.1",
    }
    var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, message)
    var signature interface{} = this.SignMessage(msg, this.PrivateKey)
    return signature
}
func  (this *vertex) BuildCreateOrderSig(message interface{}, chainId interface{}, verifyingContractAddress interface{}) interface{}  {
    var messageTypes interface{} = map[string]interface{} {
        "Order": []interface{}{map[string]interface{} {
    "name": "sender",
    "type": "bytes32",
}, map[string]interface{} {
    "name": "priceX18",
    "type": "int128",
}, map[string]interface{} {
    "name": "amount",
    "type": "int128",
}, map[string]interface{} {
    "name": "expiration",
    "type": "uint64",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint64",
}},
    }
    return this.BuildSig(chainId, messageTypes, message, verifyingContractAddress)
}
func  (this *vertex) BuildListTriggerTxSig(message interface{}, chainId interface{}, verifyingContractAddress interface{}) interface{}  {
    var messageTypes interface{} = map[string]interface{} {
        "ListTriggerOrders": []interface{}{map[string]interface{} {
    "name": "sender",
    "type": "bytes32",
}, map[string]interface{} {
    "name": "recvTime",
    "type": "uint64",
}},
    }
    return this.BuildSig(chainId, messageTypes, message, verifyingContractAddress)
}
func  (this *vertex) BuildCancelAllOrdersSig(message interface{}, chainId interface{}, verifyingContractAddress interface{}) interface{}  {
    var messageTypes interface{} = map[string]interface{} {
        "CancellationProducts": []interface{}{map[string]interface{} {
    "name": "sender",
    "type": "bytes32",
}, map[string]interface{} {
    "name": "productIds",
    "type": "uint32[]",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint64",
}},
    }
    return this.BuildSig(chainId, messageTypes, message, verifyingContractAddress)
}
func  (this *vertex) BuildCancelOrdersSig(message interface{}, chainId interface{}, verifyingContractAddress interface{}) interface{}  {
    var messageTypes interface{} = map[string]interface{} {
        "Cancellation": []interface{}{map[string]interface{} {
    "name": "sender",
    "type": "bytes32",
}, map[string]interface{} {
    "name": "productIds",
    "type": "uint32[]",
}, map[string]interface{} {
    "name": "digests",
    "type": "bytes32[]",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint64",
}},
    }
    return this.BuildSig(chainId, messageTypes, message, verifyingContractAddress)
}
func  (this *vertex) BuildWithdrawSig(message interface{}, chainId interface{}, verifyingContractAddress interface{}) interface{}  {
    var messageTypes interface{} = map[string]interface{} {
        "WithdrawCollateral": []interface{}{map[string]interface{} {
    "name": "sender",
    "type": "bytes32",
}, map[string]interface{} {
    "name": "productId",
    "type": "uint32",
}, map[string]interface{} {
    "name": "amount",
    "type": "uint128",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint64",
}},
    }
    return this.BuildSig(chainId, messageTypes, message, verifyingContractAddress)
}
func  (this *vertex) ConvertAddressToSender(address interface{}) interface{}  {
    var sender interface{} = Add(address, "64656661756c74")
    return PadEnd(sender, 66, "0")
}
func  (this *vertex) GetNonce(now interface{}, expiration interface{}) interface{}  {
    if IsTrue(IsEqual(now, nil)) {
        now = this.Nonce()
    }
    // nonce = ((now + expiration) << 20) + 1000
    // 1 << 20 = 1048576
    return Precise.StringAdd(Precise.StringMul(Precise.StringAdd(this.NumberToString(now), this.NumberToString(expiration)), "1048576"), "1000")
}
func  (this *vertex) GetExpiration(now interface{}, timeInForce interface{}, postOnly interface{}, reduceOnly interface{}) interface{}  {
    var expiration interface{} = Precise.StringAdd(this.NumberToString(now), "86400")
    if IsTrue(IsEqual(timeInForce, "ioc")) {
        // 1 << 62 = 4611686018427387904
        expiration = Precise.StringOr(expiration, "4611686018427387904")
    } else if IsTrue(IsEqual(timeInForce, "fok")) {
        // 2 << 62 = 9223372036854775808
        expiration = Precise.StringOr(expiration, "9223372036854775808")
    } else if IsTrue(postOnly) {
        // 3 << 62 = 13835058055282163712
        expiration = Precise.StringOr(expiration, "13835058055282163712")
    }
    if IsTrue(reduceOnly) {
        // 1 << 61 = 2305843009213693952
        expiration = Precise.StringOr(expiration, "2305843009213693952")
    }
    return expiration
}
func  (this *vertex) GetAmount(amount interface{}, side interface{}) interface{}  {
    var amountString interface{} = this.NumberToString(amount)
    if IsTrue(IsEqual(side, "sell")) {
        if IsTrue(IsGreaterThan(amount, 0)) {
            // amount *= -1;
            amountString = Precise.StringMul(amountString, "-1")
        }
    } else {
        if IsTrue(IsLessThan(amount, 0)) {
            // amount *= -1;
            amountString = Precise.StringMul(amountString, "-1")
        }
    }
    return amountString
}
/**
 * @method
 * @name vertex#createOrder
 * @description create a trade order
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/place-order
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] ioc, fok
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only, only works for ioc and fok order
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var marketType interface{} = ToLower(typeVar)
            var isMarketOrder interface{} = IsEqual(marketType, "market")
            if IsTrue(IsTrue(isMarketOrder) && IsTrue(IsEqual(price, nil))) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument for market order")))
            }
        
            retRes661870 := (<-this.LoadMarkets())
            PanicOnError(retRes661870)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = this.ParseToInt(GetValue(market, "id"))
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var bookAddresses interface{} = this.SafeList(contracts, "book_addrs", []interface{}{})
            var verifyingContractAddress interface{} = this.SafeString(bookAddresses, marketId)
            var defaultTimeInForce interface{} = Ternary(IsTrue((isMarketOrder)), "fok", nil)
            var timeInForce interface{} = this.SafeStringLower(params, "timeInForce", defaultTimeInForce)
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice", triggerPrice)
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            var isTrigger interface{} =     (IsTrue(stopLossPrice) || IsTrue(takeProfitPrice))
            var now interface{} = this.Nonce()
            var nonce interface{} = this.GetNonce(now, 90000)
            if IsTrue(IsTrue(postOnly) && IsTrue(reduceOnly)) {
                panic(NotSupported(Add(this.Id, " reduceOnly not supported when postOnly is enabled")))
            }
            var expiration interface{} = this.GetExpiration(now, timeInForce, postOnly, reduceOnly)
            if IsTrue(isTrigger) {
                // 1 << 63 = 9223372036854775808
                nonce = Precise.StringOr(nonce, "9223372036854775808")
            }
            var amountString interface{} = this.GetAmount(amount, side)
            var order interface{} = map[string]interface{} {
                "sender": this.ConvertAddressToSender(this.WalletAddress),
                "priceX18": this.ConvertToX18(this.PriceToPrecision(symbol, price)),
                "amount": this.ConvertToX18(this.AmountToPrecision(symbol, amountString)),
                "expiration": expiration,
                "nonce": nonce,
            }
            var request interface{} = map[string]interface{} {
                "place_order": map[string]interface{} {
                    "product_id": marketId,
                    "order": map[string]interface{} {
                        "sender": GetValue(order, "sender"),
                        "priceX18": GetValue(order, "priceX18"),
                        "amount": GetValue(order, "amount"),
                        "expiration": this.NumberToString(GetValue(order, "expiration")),
                        "nonce": GetValue(order, "nonce"),
                    },
                    "signature": this.BuildCreateOrderSig(order, chainId, verifyingContractAddress),
                    "id": this.SafeInteger(this.Options, "brokerId", 5930043274845996),
                },
            }
            params = this.Omit(params, []interface{}{"timeInForce", "reduceOnly", "postOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"})
            var response interface{} = nil
            if IsTrue(isTrigger) {
                var trigger interface{} = map[string]interface{} {}
                if IsTrue(!IsEqual(stopLossPrice, nil)) {
                    AddElementToObject(trigger, "last_price_below", this.ConvertToX18(stopLossPrice))
                } else if IsTrue(!IsEqual(takeProfitPrice, nil)) {
                    AddElementToObject(trigger, "last_price_above", this.ConvertToX18(takeProfitPrice))
                }
                AddElementToObject(GetValue(request, "place_order"), "trigger", trigger)
                
        response = (<-this.V1TriggerPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1GatewayPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // {
            //     "status": "success",
            //     "signature": {signature},
            //     "data": {
            //       "digest": {order digest}
            //     },
            //     "request_type": "execute_place_order"
            //     "id": 100
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": this.SafeString(data, "digest"),
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#editOrder
 * @description edit a trade order
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-and-place
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] ioc, fok
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only, only works for ioc and fok order
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var marketType interface{} = ToLower(typeVar)
            var isMarketOrder interface{} = IsEqual(marketType, "market")
            if IsTrue(IsTrue(isMarketOrder) && IsTrue(IsEqual(price, nil))) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a price argument for market order")))
            }
        
            retRes925608 := (<-this.LoadMarkets())
            PanicOnError(retRes925608)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = this.ParseToInt(GetValue(market, "id"))
            var defaultTimeInForce interface{} = Ternary(IsTrue((isMarketOrder)), "fok", nil)
            var timeInForce interface{} = this.SafeStringLower(params, "timeInForce", defaultTimeInForce)
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice", triggerPrice)
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            var isTrigger interface{} =     (IsTrue(stopLossPrice) || IsTrue(takeProfitPrice))
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var bookAddresses interface{} = this.SafeList(contracts, "book_addrs", []interface{}{})
            var verifyingContractAddressOrder interface{} = this.SafeString(bookAddresses, marketId)
            var verifyingContractAddressCancel interface{} = this.SafeString(contracts, "endpoint_addr")
            var now interface{} = this.Nonce()
            var nonce interface{} = this.GetNonce(now, 90000)
            var sender interface{} = this.ConvertAddressToSender(this.WalletAddress)
            if IsTrue(IsTrue(postOnly) && IsTrue(reduceOnly)) {
                panic(NotSupported(Add(this.Id, " reduceOnly not supported when postOnly is enabled")))
            }
            if IsTrue(isTrigger) {
                panic(NotSupported(Add(this.Id, " editOrder() not supported for trigger order")))
            }
            var expiration interface{} = this.GetExpiration(now, timeInForce, postOnly, reduceOnly)
            var amountString interface{} = this.GetAmount(amount, side)
            var order interface{} = map[string]interface{} {
                "sender": sender,
                "priceX18": this.ConvertToX18(this.PriceToPrecision(symbol, price)),
                "amount": this.ConvertToX18(this.AmountToPrecision(symbol, amountString)),
                "expiration": expiration,
                "nonce": nonce,
            }
            var cancels interface{} = map[string]interface{} {
                "sender": sender,
                "productIds": []interface{}{marketId},
                "digests": []interface{}{id},
                "nonce": nonce,
            }
            var request interface{} = map[string]interface{} {
                "cancel_and_place": map[string]interface{} {
                    "cancel_tx": map[string]interface{} {
                        "sender": GetValue(cancels, "sender"),
                        "productIds": GetValue(cancels, "productIds"),
                        "digests": GetValue(cancels, "digests"),
                        "nonce": this.NumberToString(GetValue(cancels, "nonce")),
                    },
                    "cancel_signature": this.BuildCancelOrdersSig(cancels, chainId, verifyingContractAddressCancel),
                    "place_order": map[string]interface{} {
                        "product_id": marketId,
                        "order": map[string]interface{} {
                            "sender": GetValue(order, "sender"),
                            "priceX18": GetValue(order, "priceX18"),
                            "amount": GetValue(order, "amount"),
                            "expiration": this.NumberToString(GetValue(order, "expiration")),
                            "nonce": GetValue(order, "nonce"),
                        },
                        "signature": this.BuildCreateOrderSig(order, chainId, verifyingContractAddressOrder),
                        "id": this.SafeInteger(this.Options, "brokerId", 5930043274845996),
                    },
                },
            }
            params = this.Omit(params, []interface{}{"timeInForce", "reduceOnly", "postOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"})
        
            response:= (<-this.V1GatewayPostExecute(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "signature": {signature},
            //     "data": {
            //       "digest": {order digest}
            //     },
            //     "request_type": "execute_cancel_and_place"
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": this.SafeString(data, "digest"),
            })
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "pending": "open",
        }
        if IsTrue(IsString(status)) {
            return this.SafeString(statuses, status, status)
        }
        var statusCancelled interface{} = this.SafeDict(status, "cancelled")
        if IsTrue(!IsEqual(statusCancelled, nil)) {
            return "canceled"
        }
        var statusTriggered interface{} = this.SafeDict(status, "triggered", map[string]interface{} {})
        var triggeredStatus interface{} = this.SafeString(statusTriggered, "status", "failure")
        if IsTrue(IsEqual(triggeredStatus, "success")) {
            return "closed"
        }
        return "canceled"
    }
    return status
}
func  (this *vertex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "product_id": 1,
    //     "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
    //     "price_x18": "1000000000000000000",
    //     "amount": "1000000000000000000",
    //     "expiration": "2000000000",
    //     "nonce": "1",
    //     "unfilled_amount": "1000000000000000000",
    //     "digest": "0x0000000000000000000000000000000000000000000000000000000000000000",
    //     "placed_at": 1681951347,
    //     "order_type": "ioc"
    // }
    // stop order
    // {
    //     "order": {
    //       "order": {
    //         "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
    //         "priceX18": "1000000000000000000",
    //         "amount": "1000000000000000000",
    //         "expiration": "2000000000",
    //         "nonce": "1",
    //       },
    //       "signature": "0x...",
    //       "product_id": 1,
    //       "spot_leverage": true,
    //       "trigger": {
    //         "price_above": "1000000000000000000"
    //       },
    //       "digest": "0x..."
    //     },
    //     "status": "pending",
    //     "updated_at": 1688768157050
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "product_id")
    var timestamp interface{} = this.SafeTimestamp(order, "placed_at")
    var amount interface{} = this.SafeString(order, "amount")
    var price interface{} = this.SafeString(order, "price_x18")
    var remaining interface{} = this.SafeString(order, "unfilled_amount")
    var triggerPriceNum interface{} = nil
    var status interface{} = this.SafeValue(order, "status")
    if IsTrue(!IsEqual(status, nil)) {
        // trigger order
        var outerOrder interface{} = this.SafeDict(order, "order", map[string]interface{} {})
        var innerOrder interface{} = this.SafeDict(outerOrder, "order", map[string]interface{} {})
        marketId = this.SafeString(outerOrder, "product_id")
        amount = this.SafeString(innerOrder, "amount")
        price = this.SafeString(innerOrder, "priceX18")
        timestamp = this.SafeTimestamp(order, "updated_at")
        var trigger interface{} = this.SafeDict(outerOrder, "trigger", map[string]interface{} {})
        var triggerPrice interface{} = this.SafeStringN(trigger, []interface{}{"price_above", "price_below", "last_price_above", "last_price_below"})
        if IsTrue(!IsEqual(triggerPrice, nil)) {
            triggerPriceNum = this.ParseToNumeric(this.ConvertFromX18(triggerPrice))
        }
    }
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var priceNum interface{} = nil
    if IsTrue(!IsEqual(price, nil)) {
        priceNum = this.ParseToNumeric(this.ConvertFromX18(price))
    }
    var amountNum interface{} = nil
    if IsTrue(!IsEqual(amount, nil)) {
        amountNum = this.ParseToNumeric(this.ConvertFromX18(amount))
    }
    var remainingNum interface{} = nil
    if IsTrue(!IsEqual(remaining, nil)) {
        remainingNum = this.ParseToNumeric(this.ConvertFromX18(remaining))
    }
    var side interface{} = nil
    if IsTrue(IsTrue(!IsEqual(amountNum, nil)) && IsTrue(!IsEqual(remainingNum, nil))) {
        side = Ternary(IsTrue((IsTrue(IsLessThan(amountNum, 0)) || IsTrue(IsLessThan(remainingNum, 0)))), "sell", "buy")
    }
    var tif interface{} = this.ParseTimeInForce(this.SafeString(order, "order_type"))
    var isPostOnly interface{} =     (IsEqual(tif, "PO"))
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "digest"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": nil,
        "symbol": symbol,
        "type": nil,
        "timeInForce": tif,
        "postOnly": isPostOnly,
        "reduceOnly": nil,
        "side": side,
        "price": priceNum,
        "triggerPrice": triggerPriceNum,
        "amount": amountNum,
        "cost": nil,
        "average": nil,
        "filled": nil,
        "remaining": remainingNum,
        "status": this.ParseOrderStatus(status),
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *vertex) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "POST_ONLY": "PO",
    }
    return this.SafeStringUpper(timeInForces, timeInForce, timeInForce)
}
/**
 * @method
 * @name vertex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/order
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5597 := (<-this.LoadMarkets())
            PanicOnError(retRes5597)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "type": "order",
                "product_id": this.ParseToInt(GetValue(market, "id")),
                "digest": id,
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": {
            //       "product_id": 1,
            //       "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //       "price_x18": "1000000000000000000",
            //       "amount": "1000000000000000000",
            //       "expiration": "2000000000",
            //       "nonce": "1",
            //       "unfilled_amount": "1000000000000000000",
            //       "digest": "0x0000000000000000000000000000000000000000000000000000000000000000",
            //       "placed_at": 1681951347,
            //       "order_type": "ioc"
            //     },
            //     "request_type": "query_order",
            // }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes367054 := (<-this.LoadMarkets())
            PanicOnError(retRes367054)
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchOpenOrders", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_id", this.ParseToNumeric(GetValue(market, "id")))
            }
            var response interface{} = nil
            if IsTrue(trigger) {
        
                contracts:= (<-this.QueryContracts())
                PanicOnError(contracts)
                var chainId interface{} = this.SafeString(contracts, "chain_id")
                var verifyingContractAddress interface{} = this.SafeString(contracts, "endpoint_addr")
                var tx interface{} = map[string]interface{} {
                    "sender": this.ConvertAddressToSender(userAddress),
                    "recvTime": Add(this.Nonce(), 90000),
                }
                AddElementToObject(request, "signature", this.BuildListTriggerTxSig(tx, chainId, verifyingContractAddress))
                AddElementToObject(request, "tx", map[string]interface{} {
            "sender": GetValue(tx, "sender"),
            "recvTime": this.NumberToString(GetValue(tx, "recvTime")),
        })
                AddElementToObject(request, "type", "list_trigger_orders")
                AddElementToObject(request, "pending", true)
                var until interface{} = this.SafeInteger(params, "until")
                params = this.Omit(params, "until")
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "max_update_time", until)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.V1TriggerPostQuery(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                this.CheckRequiredArgument("fetchOpenOrders", symbol, "symbol")
                AddElementToObject(request, "type", "subaccount_orders")
                AddElementToObject(request, "sender", this.ConvertAddressToSender(userAddress))
                
        response = (<-this.V1GatewayPostQuery(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders")
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if !IsTrue(trigger) {
                panic(NotSupported(Add(this.Id, " fetchOrders only support trigger orders")))
            }
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchOrders", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
        
            retRes336402 := (<-this.LoadMarkets())
            PanicOnError(retRes336402)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "type": "list_trigger_orders",
                "pending": false,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_id", this.ParseToNumeric(GetValue(market, "id")))
            }
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var verifyingContractAddress interface{} = this.SafeString(contracts, "endpoint_addr")
            var tx interface{} = map[string]interface{} {
                "sender": this.ConvertAddressToSender(userAddress),
                "recvTime": Add(this.Nonce(), 90000),
            }
            AddElementToObject(request, "signature", this.BuildListTriggerTxSig(tx, chainId, verifyingContractAddress))
            AddElementToObject(request, "tx", map[string]interface{} {
            "sender": GetValue(tx, "sender"),
            "recvTime": this.NumberToString(GetValue(tx, "recvTime")),
        })
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "max_update_time", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1TriggerPostQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": {
            //       "orders": [
            //         {
            //           "order": {
            //             "order": {
            //               "sender": "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //               "priceX18": "1000000000000000000",
            //               "amount": "1000000000000000000",
            //               "expiration": "2000000000",
            //               "nonce": "1",
            //             },
            //             "signature": "0x...",
            //             "product_id": 1,
            //             "spot_leverage": true,
            //             "trigger": {
            //               "price_above": "1000000000000000000"
            //             },
            //             "digest": "0x..."
            //           },
            //           "status": "pending",
            //           "updated_at": 1688768157050
            //         }
            //       ]
            //     },
            //     "request_type": "query_list_trigger_orders"
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders")
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#cancelAllOrders
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-product-orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-product-orders
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes306839 := (<-this.LoadMarkets())
            PanicOnError(retRes306839)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var verifyingContractAddress interface{} = this.SafeString(contracts, "endpoint_addr")
            var now interface{} = this.Nonce()
            var nonce interface{} = this.GetNonce(now, 90000)
            var cancels interface{} = map[string]interface{} {
                "sender": this.ConvertAddressToSender(this.WalletAddress),
                "productIds": []interface{}{this.ParseToNumeric(marketId)},
                "nonce": nonce,
            }
            var request interface{} = map[string]interface{} {
                "cancel_product_orders": map[string]interface{} {
                    "tx": map[string]interface{} {
                        "sender": GetValue(cancels, "sender"),
                        "productIds": GetValue(cancels, "productIds"),
                        "nonce": this.NumberToString(GetValue(cancels, "nonce")),
                    },
                    "signature": this.BuildCancelAllOrdersSig(cancels, chainId, verifyingContractAddress),
                },
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.V1TriggerPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1GatewayPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#cancelOrder
 * @description cancels an open order
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes832421 :=  (<-this.CancelOrders([]interface{}{id}, symbol, params))
                PanicOnError(retRes832421)
                ch <- retRes832421
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#cancelOrders
 * @description cancel multiple orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *vertex) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes171582 := (<-this.LoadMarkets())
            PanicOnError(retRes171582)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var verifyingContractAddress interface{} = this.SafeString(contracts, "endpoint_addr")
            var now interface{} = this.Nonce()
            var nonce interface{} = this.GetNonce(now, 90000)
            var cancels interface{} = map[string]interface{} {
                "sender": this.ConvertAddressToSender(this.WalletAddress),
                "productIds": []interface{}{},
                "digests": ids,
                "nonce": nonce,
            }
            var productIds interface{} = GetValue(cancels, "productIds")
            var marketIdNum interface{} = this.ParseToNumeric(marketId)
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                AppendToArray(&productIds,marketIdNum)
            }
            var request interface{} = map[string]interface{} {
                "cancel_orders": map[string]interface{} {
                    "tx": map[string]interface{} {
                        "sender": GetValue(cancels, "sender"),
                        "productIds": productIds,
                        "digests": GetValue(cancels, "digests"),
                        "nonce": this.NumberToString(GetValue(cancels, "nonce")),
                    },
                    "signature": this.BuildCancelOrdersSig(cancels, chainId, verifyingContractAddress),
                },
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.V1TriggerPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1GatewayPostExecute(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *vertex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchBalance", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "type": "subaccount_info",
                "subaccount": this.ConvertAddressToSender(userAddress),
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "status": "success",
            //     "data": {
            //       "subaccount": "0x265167ddfac55365d6ff07fc5943276319aa6b9f64656661756c740000000000",
            //       "exists": true,
            //       "healths": [
            //         {
            //           "assets": "75323297691833342306",
            //           "liabilities": "46329556869051092241",
            //           "health": "28993740822782250065"
            //         },
            //         {
            //           "assets": "75323297691833342306",
            //           "liabilities": "35968911700887320741",
            //           "health": "39354385990946021565"
            //         },
            //         {
            //           "assets": "80796966663601107565",
            //           "liabilities": "0",
            //           "health": "80796966663601107565"
            //         }
            //       ],
            //       "health_contributions": [
            //         [
            //           "75323297691833340000",
            //           "75323297691833340000",
            //           "75323297691833340000"
            //         ],
            //         [
            //           "0",
            //           "0",
            //           "0"
            //         ],
            //         [
            //           "0",
            //           "0",
            //           "0"
            //         ],
            //         [
            //           "0",
            //           "0",
            //           "0"
            //         ],
            //         [
            //           "-46329556869051090000",
            //           "-35968911700887323000",
            //           "5473668971767765000"
            //         ]
            //       ],
            //       "spot_count": 3,
            //       "perp_count": 2,
            //       "spot_balances": [
            //         {
            //           "product_id": 1,
            //           "lp_balance": {
            //             "amount": "0"
            //           },
            //           "balance": {
            //             "amount": "0",
            //             "last_cumulative_multiplier_x18": "1003419811982007193"
            //           }
            //         },
            //         {
            //           "product_id": 3,
            //           "lp_balance": {
            //             "amount": "0"
            //           },
            //           "balance": {
            //             "amount": "0",
            //             "last_cumulative_multiplier_x18": "1007584195035969404"
            //           }
            //         },
            //         {
            //           "product_id": 0,
            //           "lp_balance": {
            //             "amount": "0"
            //           },
            //           "balance": {
            //             "amount": "75323297691833342306",
            //             "last_cumulative_multiplier_x18": "1000000002391497578"
            //           }
            //         }
            //       ],
            //       "perp_balances": [
            //         {
            //           "product_id": 2,
            //           "lp_balance": {
            //             "amount": "0",
            //             "last_cumulative_funding_x18": "-284321955122859921"
            //           },
            //           "balance": {
            //             "amount": "0",
            //             "v_quote_balance": "0",
            //             "last_cumulative_funding_x18": "6363466629611946777168"
            //           }
            //         },
            //         {
            //           "product_id": 4,
            //           "lp_balance": {
            //             "amount": "0",
            //             "last_cumulative_funding_x18": "-90979748449893411"
            //           },
            //           "balance": {
            //             "amount": "-200000000000000000",
            //             "v_quote_balance": "419899475698318625259",
            //             "last_cumulative_funding_x18": "141182516563970577208"
            //           }
            //         }
            //       ],
            //       "spot_products": [
            //         {
            //           "product_id": 1,
            //           "oracle_price_x18": "30217830336443750750000",
            //           "risk": {
            //             "long_weight_initial_x18": "750000000000000000",
            //             "short_weight_initial_x18": "1250000000000000000",
            //             "long_weight_maintenance_x18": "800000000000000000",
            //             "short_weight_maintenance_x18": "1200000000000000000",
            //             "large_position_penalty_x18": "0"
            //           },
            //           "config": {
            //             "token": "0x5cc7c91690b2cbaee19a513473d73403e13fb431",
            //             "interest_inflection_util_x18": "800000000000000000",
            //             "interest_floor_x18": "10000000000000000",
            //             "interest_small_cap_x18": "40000000000000000",
            //             "interest_large_cap_x18": "1000000000000000000"
            //           },
            //           "state": {
            //             "cumulative_deposits_multiplier_x18": "1001304691727847318",
            //             "cumulative_borrows_multiplier_x18": "1003419811982007193",
            //             "total_deposits_normalized": "213107447159798397806318",
            //             "total_borrows_normalized": "4907820740150097483532"
            //           },
            //           "lp_state": {
            //             "supply": "1304981417419495030893348",
            //             "quote": {
            //               "amount": "2048495687410669565222259",
            //               "last_cumulative_multiplier_x18": "1000000002391497578"
            //             },
            //             "base": {
            //               "amount": "67623029247538886515",
            //               "last_cumulative_multiplier_x18": "1001304691727847318"
            //             }
            //           },
            //           "book_info": {
            //             "size_increment": "1000000000000000",
            //             "price_increment_x18": "1000000000000000000",
            //             "min_size": "10000000000000000",
            //             "collected_fees": "8865582805773573662738183",
            //             "lp_spread_x18": "3000000000000000"
            //           }
            //         },
            //         {
            //           "product_id": 3,
            //           "oracle_price_x18": "2075217009708333333333",
            //           "risk": {
            //             "long_weight_initial_x18": "750000000000000000",
            //             "short_weight_initial_x18": "1250000000000000000",
            //             "long_weight_maintenance_x18": "800000000000000000",
            //             "short_weight_maintenance_x18": "1200000000000000000",
            //             "large_position_penalty_x18": "0"
            //           },
            //           "config": {
            //             "token": "0xcc59686e3a32fb104c8ff84dd895676265efb8a6",
            //             "interest_inflection_util_x18": "800000000000000000",
            //             "interest_floor_x18": "10000000000000000",
            //             "interest_small_cap_x18": "40000000000000000",
            //             "interest_large_cap_x18": "1000000000000000000"
            //           },
            //           "state": {
            //             "cumulative_deposits_multiplier_x18": "1003722507760089346",
            //             "cumulative_borrows_multiplier_x18": "1007584195035969404",
            //             "total_deposits_normalized": "232750303205807326418622",
            //             "total_borrows_normalized": "110730726549469855171025"
            //           },
            //           "lp_state": {
            //             "supply": "902924999999999999774268",
            //             "quote": {
            //               "amount": "1165328092090344104989049",
            //               "last_cumulative_multiplier_x18": "1000000002391497578"
            //             },
            //             "base": {
            //               "amount": "563265647183403990588",
            //               "last_cumulative_multiplier_x18": "1003722507760089346"
            //             }
            //           },
            //           "book_info": {
            //             "size_increment": "10000000000000000",
            //             "price_increment_x18": "100000000000000000",
            //             "min_size": "100000000000000000",
            //             "collected_fees": "1801521329724633001446457",
            //             "lp_spread_x18": "3000000000000000"
            //           }
            //         },
            //         {
            //           "product_id": 0,
            //           "oracle_price_x18": "1000000000000000000",
            //           "risk": {
            //             "long_weight_initial_x18": "1000000000000000000",
            //             "short_weight_initial_x18": "1000000000000000000",
            //             "long_weight_maintenance_x18": "1000000000000000000",
            //             "short_weight_maintenance_x18": "1000000000000000000",
            //             "large_position_penalty_x18": "0"
            //           },
            //           "config": {
            //             "token": "0x179522635726710dd7d2035a81d856de4aa7836c",
            //             "interest_inflection_util_x18": "800000000000000000",
            //             "interest_floor_x18": "10000000000000000",
            //             "interest_small_cap_x18": "40000000000000000",
            //             "interest_large_cap_x18": "1000000000000000000"
            //           },
            //           "state": {
            //             "cumulative_deposits_multiplier_x18": "1000000002391497578",
            //             "cumulative_borrows_multiplier_x18": "1001593395547514024",
            //             "total_deposits_normalized": "60000256267437588885818752247843",
            //             "total_borrows_normalized": "391445043137305055810336885"
            //           },
            //           "lp_state": {
            //             "supply": "0",
            //             "quote": {
            //               "amount": "0",
            //               "last_cumulative_multiplier_x18": "0"
            //             },
            //             "base": {
            //               "amount": "0",
            //               "last_cumulative_multiplier_x18": "0"
            //             }
            //           },
            //           "book_info": {
            //             "size_increment": "0",
            //             "price_increment_x18": "0",
            //             "min_size": "0",
            //             "collected_fees": "0",
            //             "lp_spread_x18": "0"
            //           }
            //         }
            //       ],
            //       "perp_products": [
            //         {
            //           "product_id": 2,
            //           "oracle_price_x18": "30219079716463070000000",
            //           "risk": {
            //             "long_weight_initial_x18": "875000000000000000",
            //             "short_weight_initial_x18": "1125000000000000000",
            //             "long_weight_maintenance_x18": "900000000000000000",
            //             "short_weight_maintenance_x18": "1100000000000000000",
            //             "large_position_penalty_x18": "0"
            //           },
            //           "state": {
            //             "cumulative_funding_long_x18": "6363466629611946777168",
            //             "cumulative_funding_short_x18": "6363466629611946777168",
            //             "available_settle": "100612314098927536086702448",
            //             "open_interest": "57975708279961875623240"
            //           },
            //           "lp_state": {
            //             "supply": "783207415944433511804197",
            //             "last_cumulative_funding_x18": "6363466629611946777168",
            //             "cumulative_funding_per_lp_x18": "-284321955122859921",
            //             "base": "37321000000000000000",
            //             "quote": "1150991638943862165224593"
            //           },
            //           "book_info": {
            //             "size_increment": "1000000000000000",
            //             "price_increment_x18": "1000000000000000000",
            //             "min_size": "10000000000000000",
            //             "collected_fees": "7738341933653651206856235",
            //             "lp_spread_x18": "3000000000000000"
            //           }
            //         },
            //         {
            //           "product_id": 4,
            //           "oracle_price_x18": "2072129033632754300000",
            //           "risk": {
            //             "long_weight_initial_x18": "875000000000000000",
            //             "short_weight_initial_x18": "1125000000000000000",
            //             "long_weight_maintenance_x18": "900000000000000000",
            //             "short_weight_maintenance_x18": "1100000000000000000",
            //             "large_position_penalty_x18": "0"
            //           },
            //           "state": {
            //             "cumulative_funding_long_x18": "141182516563970577208",
            //             "cumulative_funding_short_x18": "141182516563970577208",
            //             "available_settle": "33807443862986950288685582",
            //             "open_interest": "316343836992291503987611"
            //           },
            //           "lp_state": {
            //             "supply": "541756546038144467864559",
            //             "last_cumulative_funding_x18": "141182516563970577208",
            //             "cumulative_funding_per_lp_x18": "-90979748449893411",
            //             "base": "362320000000000000000",
            //             "quote": "750080187685127907834038"
            //           },
            //           "book_info": {
            //             "size_increment": "10000000000000000",
            //             "price_increment_x18": "100000000000000000",
            //             "min_size": "100000000000000000",
            //             "collected_fees": "1893278317732551619694831",
            //             "lp_spread_x18": "3000000000000000"
            //           }
            //         }
            //       ]
            //     },
            //     "request_type": "query_subaccount_info"
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var balances interface{} = this.SafeList(data, "spot_balances", []interface{}{})
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var balance interface{} = GetValue(balances, i)
                var marketId interface{} = this.SafeString(balance, "product_id")
                var market interface{} = this.SafeMarket(marketId)
                var isUsdcMarketId interface{} = IsEqual(marketId, "0")
                if IsTrue(IsTrue(IsEqual(GetValue(market, "id"), nil)) && !IsTrue(isUsdcMarketId)) {
                    continue
                }
                var baseId interface{} = Ternary(IsTrue((isUsdcMarketId)), "USDC", this.SafeString(market, "baseId"))
                var code interface{} = this.SafeCurrencyCode(baseId)
                var account interface{} = this.Account()
                var tokenBalance interface{} = this.SafeDict(balance, "balance", map[string]interface{} {})
                var total interface{} = this.ConvertFromX18(this.SafeString(tokenBalance, "amount"))
                AddElementToObject(account, "total", total)
                AddElementToObject(result, code, account)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "product_id": 2,
    //     "lp_balance": {
    //       "amount": "0",
    //       "last_cumulative_funding_x18": "-284321955122859921"
    //     },
    //     "balance": {
    //       "amount": "0",
    //       "v_quote_balance": "0",
    //       "last_cumulative_funding_x18": "6363466629611946777168"
    //     }
    //   },
    //   {
    //     "product_id": 4,
    //     "lp_balance": {
    //       "amount": "0",
    //       "last_cumulative_funding_x18": "-90979748449893411"
    //     },
    //     "balance": {
    //       "amount": "-200000000000000000",
    //       "v_quote_balance": "419899475698318625259",
    //       "last_cumulative_funding_x18": "141182516563970577208"
    //     }
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "product_id")
    market = this.SafeMarket(marketId)
    var balance interface{} = this.SafeDict(position, "balance", map[string]interface{} {})
    var contractSize interface{} = this.ConvertFromX18(this.SafeString(balance, "amount"))
    var side interface{} = "buy"
    if IsTrue(Precise.StringLt(contractSize, "1")) {
        side = "sell"
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "lastUpdateTimestamp": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "entryPrice": nil,
        "notional": nil,
        "leverage": nil,
        "unrealizedPnl": nil,
        "contracts": nil,
        "contractSize": this.ParseToNumeric(contractSize),
        "marginRatio": nil,
        "liquidationPrice": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": "cross",
        "marginType": nil,
        "side": side,
        "percentage": nil,
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name vertex#fetchPositions
 * @description fetch all open positions
 * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *vertex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchPositions", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "type": "subaccount_info",
                "subaccount": this.ConvertAddressToSender(userAddress),
            }
        
            response:= (<-this.V1GatewayGetQuery(this.Extend(request, params)))
            PanicOnError(response)
            // the response is the same as fetchBalance
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(data, "perp_balances", []interface{}{})
            symbols = this.MarketSymbols(symbols)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                var position interface{} = this.Extend(this.ParsePosition(GetValue(positions, i), nil), params)
                if IsTrue(IsEqual(GetValue(position, "contractSize"), 0)) {
                    continue
                }
                AppendToArray(&result,position)
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *vertex) QueryNonces() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var request interface{} = map[string]interface{} {
            "type": "nonces",
            "address": this.WalletAddress,
        }
        
        response:= (<-this.V1GatewayGetQuery(request))
        PanicOnError(response)
        
        //
        // {
        //     "status":"success",
        //     "data":{
        //       "tx_nonce": 0,
        //       "order_nonce": 1753048133299863552
        //     },
        //     "request_type": "query_nonces",
        // }
        //
        ch <- this.SafeDict(response, "data", map[string]interface{} {})
        return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name vertex#withdraw
 * @description make a withdrawal
 * @see https://docs.vertexprotocol.com/developer-resources/api/withdrawing-on-chain
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *vertex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes828997 := (<-this.LoadMarkets())
            PanicOnError(retRes828997)
            var currency interface{} = this.Currency(code)
        
            contracts:= (<-this.QueryContracts())
            PanicOnError(contracts)
            var chainId interface{} = this.SafeString(contracts, "chain_id")
            var verifyingContractAddress interface{} = this.SafeString(contracts, "endpoint_addr")
        
            nonces:= (<-this.QueryNonces())
            PanicOnError(nonces)
            var nonce interface{} = this.SafeNumber(nonces, "tx_nonce")
            var withdraw interface{} = map[string]interface{} {
                "sender": this.ConvertAddressToSender(this.WalletAddress),
                "productId": this.ParseToNumeric(GetValue(currency, "id")),
                "amount": ToString(amount),
                "nonce": nonce,
            }
            var request interface{} = map[string]interface{} {
                "withdraw_collateral": map[string]interface{} {
                    "tx": map[string]interface{} {
                        "sender": GetValue(withdraw, "sender"),
                        "productId": GetValue(withdraw, "productId"),
                        "amount": GetValue(withdraw, "amount"),
                        "nonce": this.NumberToString(GetValue(withdraw, "nonce")),
                    },
                    "signature": this.BuildWithdrawSig(withdraw, chainId, verifyingContractAddress),
                },
            }
        
            response:= (<-this.V1GatewayPostExecute(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "success",
            //         "signature": {signature},
            //         "request_type": "execute_withdraw_collateral"
            //     }
            //
            var transaction interface{} = this.ParseTransaction(response, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "address": address,
            })
            return nil
        
            }()
            return ch
        }
func  (this *vertex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "status": "success",
    //         "signature": {signature},
    //         "request_type": "execute_withdraw_collateral"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var code interface{} = nil
    if IsTrue(!IsEqual(currency, nil)) {
        code = GetValue(currency, "code")
    }
    return map[string]interface{} {
        "info": transaction,
        "id": nil,
        "txid": nil,
        "timestamp": nil,
        "datetime": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "type": "withdrawal",
        "amount": nil,
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": nil,
        "network": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
    }
}
func  (this *vertex) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "success": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *vertex) HandlePublicAddress(methodName interface{}, params interface{}) interface{}  {
    var userAux interface{} = nil
    userAuxparamsVariable := this.HandleOptionAndParams(params, methodName, "user");
    userAux = GetValue(userAuxparamsVariable,0);
    params = GetValue(userAuxparamsVariable,1)
    var user interface{} = userAux
    userparamsVariable := this.HandleOptionAndParams(params, methodName, "address", userAux);
    user = GetValue(userparamsVariable,0);
    params = GetValue(userparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(user, nil))) && IsTrue((!IsEqual(user, "")))) {
        return []interface{}{user, params}
    }
    if IsTrue(IsTrue((!IsEqual(this.WalletAddress, nil))) && IsTrue((!IsEqual(this.WalletAddress, "")))) {
        return []interface{}{this.WalletAddress, params}
    }
    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a user parameter inside \\'params\\' or the wallet address set")))
}
func  (this *vertex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    //
    var status interface{} = this.SafeString(response, "status", "")
    if IsTrue(IsEqual(status, "failure")) {
        var message interface{} = this.SafeString(response, "error")
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var errorCode interface{} = this.SafeString(response, "error_code")
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *vertex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = this.SafeString(api, 0)
    var typeVar interface{} = this.SafeString(api, 1)
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(GetValue(this.Urls, "api"), version), typeVar))
    if IsTrue(IsTrue(!IsEqual(version, "v1")) || IsTrue(!IsEqual(typeVar, "archive"))) {
        url = Add(Add(url, "/"), path)
    }
    if IsTrue(IsEqual(method, "POST")) {
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
        body = this.Json(params)
    } else {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    if IsTrue(!IsEqual(path, "execute")) {
        // required encoding for public methods
        if IsTrue(!IsEqual(headers, nil)) {
            AddElementToObject(headers, "Accept-Encoding", "gzip")
        } else {
            headers = map[string]interface{} {
                "Accept-Encoding": "gzip",
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *vertex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
