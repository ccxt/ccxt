package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type latoken struct {
    Exchange

}

func NewLatokenCore() latoken {
   p := latoken{}
   setDefaults(&p)
   return p
}

func  (this *latoken) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "latoken",
        "name": "Latoken",
        "countries": []interface{}{"KY"},
        "version": "v2",
        "rateLimit": 1000,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createPostOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": false,
            "createStopOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactions": "emulated",
            "fetchTransfer": false,
            "fetchTransfers": true,
            "transfer": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",
            "api": map[string]interface{} {
                "rest": "https://api.latoken.com",
            },
            "www": "https://latoken.com",
            "doc": []interface{}{"https://api.latoken.com"},
            "fees": "https://latoken.com/fees",
            "referral": "https://latoken.com/invite?r=mvgp2djk",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "book/{currency}/{quote}": 1,
                    "chart/week": 1,
                    "chart/week/{currency}/{quote}": 1,
                    "currency": 1,
                    "currency/available": 1,
                    "currency/quotes": 1,
                    "currency/{currency}": 1,
                    "pair": 1,
                    "pair/available": 1,
                    "ticker": 1,
                    "ticker/{base}/{quote}": 1,
                    "time": 1,
                    "trade/history/{currency}/{quote}": 1,
                    "trade/fee/{currency}/{quote}": 1,
                    "trade/feeLevels": 1,
                    "transaction/bindings": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "auth/account": 1,
                    "auth/account/currency/{currency}/{type}": 1,
                    "auth/order": 1,
                    "auth/order/getOrder/{id}": 1,
                    "auth/order/pair/{currency}/{quote}": 1,
                    "auth/order/pair/{currency}/{quote}/active": 1,
                    "auth/stopOrder": 1,
                    "auth/stopOrder/getOrder/{id}": 1,
                    "auth/stopOrder/pair/{currency}/{quote}": 1,
                    "auth/stopOrder/pair/{currency}/{quote}/active": 1,
                    "auth/trade": 1,
                    "auth/trade/pair/{currency}/{quote}": 1,
                    "auth/trade/fee/{currency}/{quote}": 1,
                    "auth/transaction": 1,
                    "auth/transaction/bindings": 1,
                    "auth/transaction/bindings/{currency}": 1,
                    "auth/transaction/{id}": 1,
                    "auth/transfer": 1,
                },
                "post": map[string]interface{} {
                    "auth/order/cancel": 1,
                    "auth/order/cancelAll": 1,
                    "auth/order/cancelAll/{currency}/{quote}": 1,
                    "auth/order/place": 1,
                    "auth/spot/deposit": 1,
                    "auth/spot/withdraw": 1,
                    "auth/stopOrder/cancel": 1,
                    "auth/stopOrder/cancelAll": 1,
                    "auth/stopOrder/cancelAll/{currency}/{quote}": 1,
                    "auth/stopOrder/place": 1,
                    "auth/transaction/depositAddress": 1,
                    "auth/transaction/withdraw": 1,
                    "auth/transaction/withdraw/cancel": 1,
                    "auth/transaction/withdraw/confirm": 1,
                    "auth/transaction/withdraw/resendCode": 1,
                    "auth/transfer/email": 1,
                    "auth/transfer/id": 1,
                    "auth/transfer/phone": 1,
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.0049"),
                "taker": this.ParseNumber("0.0049"),
            },
        },
        "commonCurrencies": map[string]interface{} {
            "BUX": "Buxcoin",
            "CBT": "Community Business Token",
            "CTC": "CyberTronchain",
            "DMD": "Diamond Coin",
            "FREN": "Frenchie",
            "GDX": "GoldenX",
            "GEC": "Geco One",
            "GEM": "NFTmall",
            "GMT": "GMT Token",
            "IMC": "IMCoin",
            "MT": "Monarch",
            "TPAY": "Tetra Pay",
            "TRADE": "Smart Trade Coin",
            "TSL": "Treasure SL",
            "UNO": "Unobtanium",
            "WAR": "Warrior Token",
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "INTERNAL_ERROR": ExchangeError,
                "SERVICE_UNAVAILABLE": ExchangeNotAvailable,
                "NOT_AUTHORIZED": AuthenticationError,
                "FORBIDDEN": PermissionDenied,
                "BAD_REQUEST": BadRequest,
                "NOT_FOUND": ExchangeError,
                "ACCESS_DENIED": PermissionDenied,
                "REQUEST_REJECTED": ExchangeError,
                "HTTP_MEDIA_TYPE_NOT_SUPPORTED": BadRequest,
                "MEDIA_TYPE_NOT_ACCEPTABLE": BadRequest,
                "METHOD_ARGUMENT_NOT_VALID": BadRequest,
                "VALIDATION_ERROR": BadRequest,
                "ACCOUNT_EXPIRED": AccountSuspended,
                "BAD_CREDENTIALS": AuthenticationError,
                "COOKIE_THEFT": AuthenticationError,
                "CREDENTIALS_EXPIRED": AccountSuspended,
                "INSUFFICIENT_AUTHENTICATION": AuthenticationError,
                "UNKNOWN_LOCATION": AuthenticationError,
                "TOO_MANY_REQUESTS": RateLimitExceeded,
                "INSUFFICIENT_FUNDS": InsufficientFunds,
                "ORDER_VALIDATION": InvalidOrder,
                "BAD_TICKS": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "invalid API key, signature or digest": AuthenticationError,
                "The API key was revoked": AuthenticationError,
                "request expired or bad": InvalidNonce,
                "For input string": BadRequest,
                "Unable to resolve currency by tag": BadSymbol,
                "Can\\'t find currency with tag": BadSymbol,
                "Unable to place order because pair is in inactive state": BadSymbol,
                "API keys are not available for": AccountSuspended,
            },
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "types": map[string]interface{} {
                "wallet": "ACCOUNT_TYPE_WALLET",
                "funding": "ACCOUNT_TYPE_WALLET",
                "spot": "ACCOUNT_TYPE_SPOT",
            },
            "accounts": map[string]interface{} {
                "ACCOUNT_TYPE_WALLET": "wallet",
                "ACCOUNT_TYPE_SPOT": "spot",
            },
            "fetchTradingFee": map[string]interface{} {
                "method": "fetchPrivateTradingFee",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": nil,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
func  (this *latoken) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
/**
 * @method
 * @name latoken#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api.latoken.com/doc/v2/#tag/Time/operation/currentTime
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *latoken) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "serverTime": 1570615577321
            //     }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchMarkets
 * @description retrieves data on all markets for latoken
 * @see https://api.latoken.com/doc/v2/#tag/Pair/operation/getActivePairs
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *latoken) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            currencies:= (<-this.FetchCurrenciesFromCache(params))
            PanicOnError(currencies)
            //
            //     [
            //         {
            //             "id":"1a075819-9e0b-48fc-8784-4dab1d186d6d",
            //             "status":"CURRENCY_STATUS_ACTIVE",
            //             "type":"CURRENCY_TYPE_ALTERNATIVE", // CURRENCY_TYPE_CRYPTO, CURRENCY_TYPE_IEO
            //             "name":"MyCryptoBank",
            //             "tag":"MCB",
            //             "description":"",
            //             "logo":"",
            //             "decimals":18,
            //             "created":1572912000000,
            //             "tier":1,
            //             "assetClass":"ASSET_CLASS_UNKNOWN",
            //             "minTransferAmount":0
            //         },
            //         {
            //             "id":"db02758e-2507-46a5-a805-7bc60355b3eb",
            //             "status":"CURRENCY_STATUS_ACTIVE",
            //             "type":"CURRENCY_TYPE_FUTURES_CONTRACT",
            //             "name":"BTC USDT Futures Contract",
            //             "tag":"BTCUSDT",
            //             "description":"",
            //             "logo":"",
            //             "decimals":8,
            //             "created":1589459984395,
            //             "tier":1,
            //             "assetClass":"ASSET_CLASS_UNKNOWN",
            //             "minTransferAmount":0
            //         },
            //     ]
            //
        
            response:= (<-this.PublicGetPair(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id":"dba4289b-6b46-4d94-bf55-49eec9a163ad",
            //             "status":"PAIR_STATUS_ACTIVE", // CURRENCY_STATUS_INACTIVE
            //             "baseCurrency":"fb9b53d6-bbf6-472f-b6ba-73cc0d606c9b",
            //             "quoteCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
            //             "priceTick":"0.000000100000000000",
            //             "priceDecimals":7,
            //             "quantityTick":"0.010000000",
            //             "quantityDecimals":2,
            //             "costDisplayDecimals":7,
            //             "created":1572957210501,
            //             "minOrderQuantity":"0",
            //             "maxOrderCostUsd":"999999999999999999",
            //             "minOrderCostUsd":"0",
            //             "externalSymbol":""
            //         }
            //     ]
            //
            if IsTrue(this.SafeValue(this.Options, "adjustForTimeDifference", true)) {
        
                retRes771773 := (<-this.LoadTimeDifference())
                PanicOnError(retRes771773)
            }
            var currenciesById interface{} = this.IndexBy(currencies, "id")
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var market interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(market, "id")
                // the exchange shows them inverted
                var baseId interface{} = this.SafeString(market, "baseCurrency")
                var quoteId interface{} = this.SafeString(market, "quoteCurrency")
                var baseCurrency interface{} = this.SafeValue(currenciesById, baseId)
                var quoteCurrency interface{} = this.SafeValue(currenciesById, quoteId)
                if IsTrue(IsTrue(!IsEqual(baseCurrency, nil)) && IsTrue(!IsEqual(quoteCurrency, nil))) {
                    var base interface{} = this.SafeCurrencyCode(this.SafeString(baseCurrency, "tag"))
                    var quote interface{} = this.SafeCurrencyCode(this.SafeString(quoteCurrency, "tag"))
                    var lowercaseQuote interface{} = ToLower(quote)
                    var capitalizedQuote interface{} = this.Capitalize(lowercaseQuote)
                    var status interface{} = this.SafeString(market, "status")
                    AppendToArray(&result,map[string]interface{} {
                        "id": id,
                        "symbol": Add(Add(base, "/"), quote),
                        "base": base,
                        "quote": quote,
                        "settle": nil,
                        "baseId": baseId,
                        "quoteId": quoteId,
                        "settleId": nil,
                        "type": "spot",
                        "spot": true,
                        "margin": false,
                        "swap": false,
                        "future": false,
                        "option": false,
                        "active": (IsEqual(status, "PAIR_STATUS_ACTIVE")),
                        "contract": false,
                        "linear": nil,
                        "inverse": nil,
                        "contractSize": nil,
                        "expiry": nil,
                        "expiryDatetime": nil,
                        "strike": nil,
                        "optionType": nil,
                        "precision": map[string]interface{} {
                            "amount": this.SafeNumber(market, "quantityTick"),
                            "price": this.SafeNumber(market, "priceTick"),
                        },
                        "limits": map[string]interface{} {
                            "leverage": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                            "amount": map[string]interface{} {
                                "min": this.SafeNumber(market, "minOrderQuantity"),
                                "max": nil,
                            },
                            "price": map[string]interface{} {
                                "min": nil,
                                "max": nil,
                            },
                            "cost": map[string]interface{} {
                                "min": this.SafeNumber(market, Add("minOrderCost", capitalizedQuote)),
                                "max": this.SafeNumber(market, Add("maxOrderCost", capitalizedQuote)),
                            },
                        },
                        "created": this.SafeInteger(market, "created"),
                        "info": market,
                    })
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *latoken) FetchCurrenciesFromCache(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is now redundant
            // currencies are now fetched before markets
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "fetchCurrencies", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(options, "timestamp")
            var expires interface{} = this.SafeInteger(options, "expires", 1000)
            var now interface{} = this.Milliseconds()
            if IsTrue(IsTrue((IsEqual(timestamp, nil))) || IsTrue((IsGreaterThan((Subtract(now, timestamp)), expires)))) {
        
                response:= (<-this.PublicGetCurrency(params))
                PanicOnError(response)
                AddElementToObject(this.Options, "fetchCurrencies", this.Extend(options, map[string]interface{} {
            "response": response,
            "timestamp": now,
        }))
            }
        
            ch <- this.SafeValue(GetValue(this.Options, "fetchCurrencies"), "response")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *latoken) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FetchCurrenciesFromCache(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id":"1a075819-9e0b-48fc-8784-4dab1d186d6d",
            //             "status":"CURRENCY_STATUS_ACTIVE",
            //             "type":"CURRENCY_TYPE_ALTERNATIVE", // CURRENCY_TYPE_CRYPTO, CURRENCY_TYPE_IEO
            //             "name":"MyCryptoBank",
            //             "tag":"MCB",
            //             "description":"",
            //             "logo":"",
            //             "decimals":18,
            //             "created":1572912000000,
            //             "tier":1,
            //             "assetClass":"ASSET_CLASS_UNKNOWN",
            //             "minTransferAmount":0
            //         },
            //         {
            //             "id":"db02758e-2507-46a5-a805-7bc60355b3eb",
            //             "status":"CURRENCY_STATUS_ACTIVE",
            //             "type":"CURRENCY_TYPE_FUTURES_CONTRACT",
            //             "name":"BTC USDT Futures Contract",
            //             "tag":"BTCUSDT",
            //             "description":"",
            //             "logo":"",
            //             "decimals":8,
            //             "created":1589459984395,
            //             "tier":1,
            //             "assetClass":"ASSET_CLASS_UNKNOWN",
            //             "minTransferAmount":0
            //         },
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "id")
                var tag interface{} = this.SafeString(currency, "tag")
                var code interface{} = this.SafeCurrencyCode(tag)
                var fee interface{} = this.SafeNumber(currency, "fee")
                var currencyType interface{} = this.SafeString(currency, "type")
                var typeVar interface{} = nil
                if IsTrue(IsEqual(currencyType, "CURRENCY_TYPE_ALTERNATIVE")) {
                    typeVar = "other"
                } else {
                    // CURRENCY_TYPE_CRYPTO and CURRENCY_TYPE_IEO are all cryptos
                    typeVar = "crypto"
                }
                var status interface{} = this.SafeString(currency, "status")
                var active interface{} =         (IsEqual(status, "CURRENCY_STATUS_ACTIVE"))
                var name interface{} = this.SafeString(currency, "name")
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "name": name,
            "type": typeVar,
            "active": active,
            "deposit": nil,
            "withdraw": nil,
            "fee": fee,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "decimals"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": this.SafeNumber(currency, "minTransferAmount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api.latoken.com/doc/v2/#tag/Account/operation/getBalancesByUser
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *latoken) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes451261 := (<-this.LoadMarkets())
            PanicOnError(retRes451261)
        
            response:= (<-this.PrivateGetAuthAccount(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "e5852e02-8711-431c-9749-a6f5503c6dbe",
            //             "status": "ACCOUNT_STATUS_ACTIVE",
            //             "type": "ACCOUNT_TYPE_WALLET",
            //             "timestamp": "1635920106506",
            //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "available": "100.000000",
            //             "blocked": "0.000000"
            //         },
            //         {
            //             "id": "369df204-acbc-467e-a25e-b16e3cc09cf6",
            //             "status": "ACCOUNT_STATUS_ACTIVE",
            //             "type": "ACCOUNT_TYPE_SPOT",
            //             "timestamp": "1635920106504",
            //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "available": "100.000000",
            //             "blocked": "0.000000"
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {
                "info": response,
                "timestamp": nil,
                "datetime": nil,
            }
            var maxTimestamp interface{} = nil
            var defaultType interface{} = this.SafeString2(this.Options, "fetchBalance", "defaultType", "spot")
            var typeVar interface{} = this.SafeString(params, "type", defaultType)
            var types interface{} = this.SafeValue(this.Options, "types", map[string]interface{} {})
            var accountType interface{} = this.SafeString(types, typeVar, typeVar)
            var balancesByType interface{} = this.GroupBy(response, "type")
            var balances interface{} = this.SafeValue(balancesByType, accountType, []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
                var balance interface{} = GetValue(balances, i)
                var currencyId interface{} = this.SafeString(balance, "currency")
                var timestamp interface{} = this.SafeInteger(balance, "timestamp")
                if IsTrue(!IsEqual(timestamp, nil)) {
                    if IsTrue(IsEqual(maxTimestamp, nil)) {
                        maxTimestamp = timestamp
                    } else {
                        maxTimestamp = mathMax(maxTimestamp, timestamp)
                    }
                }
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                AddElementToObject(account, "free", this.SafeString(balance, "available"))
                AddElementToObject(account, "used", this.SafeString(balance, "blocked"))
                AddElementToObject(result, code, account)
            }
            AddElementToObject(result, "timestamp", maxTimestamp)
            AddElementToObject(result, "datetime", this.Iso8601(maxTimestamp))
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.latoken.com/doc/v2/#tag/Order-Book/operation/getOrderBook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *latoken) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes178373 := (<-this.LoadMarkets())
            PanicOnError(retRes178373)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // max 1000
            }
        
            response:= (<-this.PublicGetBookCurrencyQuote(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "ask":[
            //             {"price":"4428.76","quantity":"0.08136","cost":"360.3239136","accumulated":"360.3239136"},
            //             {"price":"4429.77","quantity":"1.11786","cost":"4951.8626922","accumulated":"5312.1866058"},
            //             {"price":"4430.94","quantity":"1.78418","cost":"7905.5945292","accumulated":"13217.781135"},
            //         ],
            //         "bid":[
            //             {"price":"4428.43","quantity":"0.13675","cost":"605.5878025","accumulated":"605.5878025"},
            //             {"price":"4428.19","quantity":"0.03619","cost":"160.2561961","accumulated":"765.8439986"},
            //             {"price":"4428.15","quantity":"0.02926","cost":"129.567669","accumulated":"895.4116676"},
            //         ],
            //         "totalAsk":"53.14814",
            //         "totalBid":"112216.9029791"
            //     }
            //
        ch <- this.ParseOrderBook(response, symbol, nil, "bid", "ask", "price", "quantity")
            return nil
        
            }()
            return ch
        }
func  (this *latoken) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //        "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
    //        "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //        "volume24h": "165723597.189022176000000000",
    //        "volume7d": "934505768.625109571000000000",
    //        "change24h": "0.0200",
    //        "change7d": "-6.4200",
    //        "amount24h": "6438.457663100000000000",
    //        "amount7d": "35657.785013800000000000",
    //        "lastPrice": "25779.16",
    //        "lastQuantity": "0.248403300000000000",
    //        "bestBid": "25778.74",
    //        "bestBidQuantity": "0.6520232",
    //        "bestAsk": "25779.17",
    //        "bestAskQuantity": "0.4956043",
    //        "updateTimestamp": "1693965231406"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var timestamp interface{} = this.SafeIntegerOmitZero(ticker, "updateTimestamp") // sometimes latoken provided '0' ts from /ticker endpoint
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "low": nil,
        "high": nil,
        "bid": this.SafeString(ticker, "bestBid"),
        "bidVolume": this.SafeString(ticker, "bestBidQuantity"),
        "ask": this.SafeString(ticker, "bestAsk"),
        "askVolume": this.SafeString(ticker, "bestAskQuantity"),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "change24h"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "amount24h"),
        "quoteVolume": this.SafeString(ticker, "volume24h"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name latoken#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.latoken.com/doc/v2/#tag/Ticker/operation/getTicker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *latoken) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes984108 := (<-this.LoadMarkets())
            PanicOnError(retRes984108)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "base": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.PublicGetTickerBaseQuote(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //        "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
            //        "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //        "volume24h": "165723597.189022176000000000",
            //        "volume7d": "934505768.625109571000000000",
            //        "change24h": "0.0200",
            //        "change7d": "-6.4200",
            //        "amount24h": "6438.457663100000000000",
            //        "amount7d": "35657.785013800000000000",
            //        "lastPrice": "25779.16",
            //        "lastQuantity": "0.248403300000000000",
            //        "bestBid": "25778.74",
            //        "bestBidQuantity": "0.6520232",
            //        "bestAsk": "25779.17",
            //        "bestAskQuantity": "0.4956043",
            //        "updateTimestamp": "1693965231406"
            //    }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api.latoken.com/doc/v2/#tag/Ticker/operation/getAllTickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *latoken) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23617 := (<-this.LoadMarkets())
            PanicOnError(retRes23617)
        
            response:= (<-this.PublicGetTicker(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "symbol": "92151d82-df98-4d88-9a4d-284fa9eca49f/0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //            "baseCurrency": "92151d82-df98-4d88-9a4d-284fa9eca49f",
            //            "quoteCurrency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //            "volume24h": "165723597.189022176000000000",
            //            "volume7d": "934505768.625109571000000000",
            //            "change24h": "0.0200",
            //            "change7d": "-6.4200",
            //            "amount24h": "6438.457663100000000000",
            //            "amount7d": "35657.785013800000000000",
            //            "lastPrice": "25779.16",
            //            "lastQuantity": "0.248403300000000000",
            //            "bestBid": "25778.74",
            //            "bestBidQuantity": "0.6520232",
            //            "bestAsk": "25779.17",
            //            "bestAskQuantity": "0.4956043",
            //            "updateTimestamp": "1693965231406"
            //        }
            //    ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *latoken) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "id":"c152f814-8eeb-44f0-8f3f-e5c568f2ffcf",
    //         "isMakerBuyer":false,
    //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
    //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //         "price":"4435.56",
    //         "quantity":"0.32534",
    //         "cost":"1443.0650904",
    //         "timestamp":1635854642725,
    //         "makerBuyer":false
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "id":"02e02533-b4bf-4ba9-9271-24e2108dfbf7",
    //         "isMakerBuyer":false,
    //         "direction":"TRADE_DIRECTION_BUY",
    //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
    //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //         "price":"4564.32",
    //         "quantity":"0.01000",
    //         "cost":"45.6432",
    //         "fee":"0.223651680000000000",
    //         "order":"c9cac6a0-484c-4892-88e7-ad51b39f2ce1",
    //         "timestamp":1635921580399,
    //         "makerBuyer":false
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var typeVar interface{} = nil
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "quantity")
    var costString interface{} = this.SafeString(trade, "cost")
    var makerBuyer interface{} = this.SafeValue(trade, "makerBuyer")
    var side interface{} = this.SafeString(trade, "direction")
    if IsTrue(IsEqual(side, nil)) {
        side = Ternary(IsTrue(makerBuyer), "sell", "buy")
    } else {
        if IsTrue(IsEqual(side, "TRADE_DIRECTION_BUY")) {
            side = "buy"
        } else if IsTrue(IsEqual(side, "TRADE_DIRECTION_SELL")) {
            side = "sell"
        }
    }
    var isBuy interface{} =     (IsEqual(side, "buy"))
    var takerOrMaker interface{} = Ternary(IsTrue((IsTrue(makerBuyer) && IsTrue(isBuy))), "maker", "taker")
    var baseId interface{} = this.SafeString(trade, "baseCurrency")
    var quoteId interface{} = this.SafeString(trade, "quoteCurrency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    if IsTrue(InOp(this.Markets, symbol)) {
        market = this.Market(symbol)
    }
    var id interface{} = this.SafeString(trade, "id")
    var orderId interface{} = this.SafeString(trade, "order")
    var feeCost interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": quote,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name latoken#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByPair
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *latoken) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes293268 := (<-this.LoadMarkets())
            PanicOnError(retRes293268)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 100)) // default 100, limit 100
            }
        
            response:= (<-this.PublicGetTradeHistoryCurrencyQuote(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {"id":"c152f814-8eeb-44f0-8f3f-e5c568f2ffcf","isMakerBuyer":false,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.56","quantity":"0.32534","cost":"1443.0650904","timestamp":1635854642725,"makerBuyer":false},
            //         {"id":"cfecbefb-3d11-43d7-b9d4-fa16211aad8a","isMakerBuyer":false,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.13","quantity":"0.26540","cost":"1177.083502","timestamp":1635854641114,"makerBuyer":false},
            //         {"id":"f43d3ec8-db94-49f3-b534-91dbc2779296","isMakerBuyer":true,"baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f","quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5","price":"4435.00","quantity":"0.41738","cost":"1851.0803","timestamp":1635854640323,"makerBuyer":true},
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getFeeByPair
 * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getAuthFeeByPair
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *latoken) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "fetchTradingFee", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "fetchPrivateTradingFee")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            params = this.Omit(params, "method")
            if IsTrue(IsEqual(method, "fetchPrivateTradingFee")) {
        
                    retRes354430 :=  (<-this.FetchPrivateTradingFee(symbol, params))
                    PanicOnError(retRes354430)
                    ch <- retRes354430
                    return nil
            } else if IsTrue(IsEqual(method, "fetchPublicTradingFee")) {
        
                    retRes321684 :=  (<-this.FetchPublicTradingFee(symbol, params))
                    PanicOnError(retRes321684)
                    ch <- retRes321684
                    return nil
            } else {
                panic(NotSupported(Add(this.Id, " not support this method")))
            }
                return nil
            }()
            return ch
        }
func  (this *latoken) FetchPublicTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes611081 := (<-this.LoadMarkets())
            PanicOnError(retRes611081)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.PublicGetTradeFeeCurrencyQuote(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "makerFee": "0.004900000000000000",
            //         "takerFee": "0.004900000000000000",
            //         "type": "FEE_SCHEME_TYPE_PERCENT_QUOTE",
            //         "take": "FEE_SCHEME_TAKE_PROPORTION"
            //     }
            //
        ch <- map[string]interface{} {
                "info": response,
                "symbol": GetValue(market, "symbol"),
                "maker": this.SafeNumber(response, "makerFee"),
                "taker": this.SafeNumber(response, "takerFee"),
                "percentage": nil,
                "tierBased": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *latoken) FetchPrivateTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes866198 := (<-this.LoadMarkets())
            PanicOnError(retRes866198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.PrivateGetAuthTradeFeeCurrencyQuote(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "makerFee": "0.004900000000000000",
            //         "takerFee": "0.004900000000000000",
            //         "type": "FEE_SCHEME_TYPE_PERCENT_QUOTE",
            //         "take": "FEE_SCHEME_TAKE_PROPORTION"
            //     }
            //
        ch <- map[string]interface{} {
                "info": response,
                "symbol": GetValue(market, "symbol"),
                "maker": this.SafeNumber(response, "makerFee"),
                "taker": this.SafeNumber(response, "takerFee"),
                "percentage": nil,
                "tierBased": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByTrader
 * @see https://api.latoken.com/doc/v2/#tag/Trade/operation/getTradesByAssetAndTrader
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *latoken) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12973 := (<-this.LoadMarkets())
            PanicOnError(retRes12973)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "currency", GetValue(market, "baseId"))
                AddElementToObject(request, "quote", GetValue(market, "quoteId"))
                
        response = (<-this.PrivateGetAuthTradePairCurrencyQuote(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetAuthTrade(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     [
            //         {
            //             "id":"02e02533-b4bf-4ba9-9271-24e2108dfbf7",
            //             "isMakerBuyer":false,
            //             "direction":"TRADE_DIRECTION_BUY",
            //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
            //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "price":"4564.32",
            //             "quantity":"0.01000",
            //             "cost":"45.6432",
            //             "fee":"0.223651680000000000",
            //             "order":"c9cac6a0-484c-4892-88e7-ad51b39f2ce1",
            //             "timestamp":1635921580399,
            //             "makerBuyer":false
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *latoken) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ORDER_STATUS_PLACED": "open",
        "ORDER_STATUS_CLOSED": "closed",
        "ORDER_STATUS_CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *latoken) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ORDER_TYPE_MARKET": "market",
        "ORDER_TYPE_LIMIT": "limit",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *latoken) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "ORDER_CONDITION_GOOD_TILL_CANCELLED": "GTC",
        "ORDER_CONDITION_IMMEDIATE_OR_CANCEL": "IOC",
        "ORDER_CONDITION_FILL_OR_KILL": "FOK",
    }
    return this.SafeString(timeInForces, timeInForce, timeInForce)
}
func  (this *latoken) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //    {
    //        "baseCurrency": "f7dac554-8139-4ff6-841f-0e586a5984a0",
    //        "quoteCurrency": "a5a7a7a9-e2a3-43f9-8754-29a02f6b709b",
    //        "side": "BID",
    //        "clientOrderId": "my-wonderful-order-number-71566",
    //        "price": "10103.19",
    //        "stopPrice": "10103.19",
    //        "quantity": "3.21",
    //        "timestamp": 1568185507
    //    }
    //
    // fetchOrder, fetchOpenOrders, fetchOrders
    //
    //     {
    //         "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
    //         "status":"ORDER_STATUS_PLACED",
    //         "side":"ORDER_SIDE_BUY",
    //         "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
    //         "type":"ORDER_TYPE_LIMIT",
    //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
    //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //         "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
    //         "price":"4000.00",
    //         "quantity":"0.01",
    //         "cost":"40.000000000000000000",
    //         "filled":"0",
    //         "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
    //         "creator":"ORDER_CREATOR_USER",
    //         "creatorId":"",
    //         "timestamp":1635920767648
    //     }
    //
    // cancelOrder
    //
    //     {
    //         "message":"cancellation request successfully submitted",
    //         "status":"SUCCESS",
    //         "id":"a631426d-3543-45ba-941e-75f7825afb0f"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var baseId interface{} = this.SafeString(order, "baseCurrency")
    var quoteId interface{} = this.SafeString(order, "quoteCurrency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = nil
    if IsTrue(IsTrue((!IsEqual(base, nil))) && IsTrue((!IsEqual(quote, nil)))) {
        symbol = Add(Add(base, "/"), quote)
        if IsTrue(InOp(this.Markets, symbol)) {
            market = this.Market(symbol)
        }
    }
    var orderSide interface{} = this.SafeString(order, "side")
    var side interface{} = nil
    if IsTrue(!IsEqual(orderSide, nil)) {
        var parts interface{} = Split(orderSide, "_")
        var partsLength interface{} =         GetArrayLength(parts)
        side = this.SafeStringLower(parts, Subtract(partsLength, 1))
    }
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "type"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "quantity")
    var filled interface{} = this.SafeString(order, "filled")
    var cost interface{} = this.SafeString(order, "cost")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var message interface{} = this.SafeString(order, "message")
    if IsTrue(!IsEqual(message, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(message, "cancel"), 0)) {
            status = "canceled"
        } else if IsTrue(IsGreaterThanOrEqual(GetIndexOf(message, "accept"), 0)) {
            status = "open"
        }
    }
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var timeInForce interface{} = this.ParseTimeInForce(this.SafeString(order, "condition"))
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString(order, "stopPrice"),
        "cost": cost,
        "amount": amount,
        "filled": filled,
        "average": nil,
        "remaining": nil,
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name latoken#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyActiveOrdersByPair
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyActiveStopOrdersByPair  // stop
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes135292 := (<-this.LoadMarkets())
            PanicOnError(retRes135292)
            var response interface{} = nil
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, "stop")
            // privateGetAuthOrderActive doesn't work even though its listed at https://api.latoken.com/doc/v2/#tag/Order/operation/getMyActiveOrders
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "baseId"),
                "quote": GetValue(market, "quoteId"),
            }
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivateGetAuthStopOrderPairCurrencyQuoteActive(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetAuthOrderPairCurrencyQuoteActive(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     [
            //         {
            //             "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
            //             "status":"ORDER_STATUS_PLACED",
            //             "side":"ORDER_SIDE_BUY",
            //             "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
            //             "type":"ORDER_TYPE_LIMIT",
            //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
            //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
            //             "price":"4000.00",
            //             "quantity":"0.01000",
            //             "cost":"40.00",
            //             "filled":"0.00000",
            //             "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
            //             "creator":"USER",
            //             "creatorId":"",
            //             "timestamp":1635920767648
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyOrders
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getMyOrdersByPair
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyStopOrders       // stop
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getMyStopOrdersByPair // stop
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes535023 := (<-this.LoadMarkets())
            PanicOnError(retRes535023)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "currency", GetValue(market, "baseId"))
                AddElementToObject(request, "quote", GetValue(market, "quoteId"))
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivateGetAuthStopOrderPairCurrencyQuote(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetAuthOrderPairCurrencyQuote(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivateGetAuthStopOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetAuthOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
        
                //
            //     [
            //         {
            //             "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
            //             "status":"ORDER_STATUS_PLACED",
            //             "side":"ORDER_SIDE_BUY",
            //             "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
            //             "type":"ORDER_TYPE_LIMIT",
            //             "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
            //             "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
            //             "price":"4000.00",
            //             "quantity":"0.01000",
            //             "cost":"40.00",
            //             "filled":"0.00000",
            //             "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
            //             "creator":"USER",
            //             "creatorId":"",
            //             "timestamp":1635920767648
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/getOrderById
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/getStopOrderById
 * @param {string} id order id
 * @param {string} [symbol] not used by latoken fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching a trigger order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes608491 := (<-this.LoadMarkets())
            PanicOnError(retRes608491)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivateGetAuthStopOrderGetOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetAuthOrderGetOrderId(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "id":"a76bd262-3560-4bfb-98ac-1cedd394f4fc",
            //         "status":"ORDER_STATUS_PLACED",
            //         "side":"ORDER_SIDE_BUY",
            //         "condition":"ORDER_CONDITION_GOOD_TILL_CANCELLED",
            //         "type":"ORDER_TYPE_LIMIT",
            //         "baseCurrency":"620f2019-33c0-423b-8a9d-cde4d7f8ef7f",
            //         "quoteCurrency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //         "clientOrderId":"web-macos_chrome_1a6a6659-6f7c-4fac-be0b-d1d7ac06d",
            //         "price":"4000.00",
            //         "quantity":"0.01",
            //         "cost":"40.000000000000000000",
            //         "filled":"0",
            //         "trader":"7244bb3a-b6b2-446a-ac78-fa4bce5b59a9",
            //         "creator":"ORDER_CREATOR_USER",
            //         "creatorId":"",
            //         "timestamp":1635920767648
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#createOrder
 * @description create a trade order
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/placeOrder
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/placeStopOrder  // stop
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.condition] "GTC", "IOC", or  "FOK"
 * @param {string} [params.clientOrderId] [ 0 .. 50 ] characters, client's custom order id (free field for your convenience)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes824922 := (<-this.LoadMarkets())
            PanicOnError(retRes824922)
            var market interface{} = this.Market(symbol)
            var uppercaseType interface{} = ToUpper(typeVar)
            var request interface{} = map[string]interface{} {
                "baseCurrency": GetValue(market, "baseId"),
                "quoteCurrency": GetValue(market, "quoteId"),
                "side": ToUpper(side),
                "condition": "GTC",
                "type": uppercaseType,
                "clientOrderId": this.Uuid(),
                "quantity": this.AmountToPrecision(symbol, amount),
                "timestamp": this.Seconds(),
            }
            if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice"})
            var response interface{} = nil
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
                
        response = (<-this.PrivatePostAuthStopOrderPlace(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostAuthOrderPlace(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //    {
            //        "baseCurrency": "f7dac554-8139-4ff6-841f-0e586a5984a0",
            //        "quoteCurrency": "a5a7a7a9-e2a3-43f9-8754-29a02f6b709b",
            //        "side": "BID",
            //        "clientOrderId": "my-wonderful-order-number-71566",
            //        "price": "10103.19",
            //        "stopPrice": "10103.19",
            //        "quantity": "3.21",
            //        "timestamp": 1568185507
            //    }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#cancelOrder
 * @description cancels an open order
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelOrder
 * @see https://api.latoken.com/doc/v2/#tag/StopOrder/operation/cancelStopOrder  // stop
 * @param {string} id order id
 * @param {string} symbol not used by latoken cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if cancelling a trigger order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes994503 := (<-this.LoadMarkets())
            PanicOnError(retRes994503)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivatePostAuthStopOrderCancel(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostAuthOrderCancel(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "id": "12345678-1234-1244-1244-123456789012",
            //         "message": "cancellation request successfully submitted",
            //         "status": "SUCCESS",
            //         "error": "",
            //         "errors": { }
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelAllOrders
 * @see https://api.latoken.com/doc/v2/#tag/Order/operation/cancelAllOrdersByPair
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if cancelling trigger orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *latoken) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes549718 := (<-this.LoadMarkets())
            PanicOnError(retRes549718)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "currency", GetValue(market, "baseId"))
                AddElementToObject(request, "quote", GetValue(market, "quoteId"))
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivatePostAuthStopOrderCancelAllCurrencyQuote(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostAuthOrderCancelAllCurrencyQuote(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivatePostAuthStopOrderCancelAll(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostAuthOrderCancelAll(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
        
                //
            //     {
            //         "message":"cancellation request successfully submitted",
            //         "status":"SUCCESS"
            //     }
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#fetchTransactions
 * @deprecated
 * @description use fetchDepositsWithdrawals instead
 * @see https://api.latoken.com/doc/v2/#tag/Transaction/operation/getUserTransactions
 * @param {string} code unified currency code for the currency of the transactions, default is undefined
 * @param {int} [since] timestamp in ms of the earliest transaction, default is undefined
 * @param {int} [limit] max number of transactions to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *latoken) FetchTransactions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes916211 := (<-this.LoadMarkets())
            PanicOnError(retRes916211)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PrivateGetAuthTransaction(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "hasNext":false,
            //         "content":[
            //             {
            //                 "id":"fbf7d0d1-2629-4ad8-9def-7a1dba423362",
            //                 "status":"TRANSACTION_STATUS_CONFIRMED",
            //                 "type":"TRANSACTION_TYPE_DEPOSIT",
            //                 "senderAddress":"",
            //                 "recipientAddress":"0x3c46fa2e3f9023bc4897828ed173f8ecb3a554bc",
            //                 "amount":"200.000000000000000000",
            //                 "transactionFee":"0.000000000000000000",
            //                 "timestamp":1635893208404,
            //                 "transactionHash":"0x28bad3b74a042df13d64ddfbca855566a51bf7f190b8cd565c236a18d5cd493f#42",
            //                 "blockHeight":13540262,
            //                 "currency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //                 "memo":null,
            //                 "paymentProvider":"a8d6d1cb-f84a-4e9d-aa82-c6a08b356ee1",
            //                 "requiresCode":false
            //             }
            //         ],
            //         "first":true,
            //         "hasContent":true,
            //         "pageSize":10
            //     }
            //
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var content interface{} = this.SafeList(response, "content", []interface{}{})
        
            ch <- this.ParseTransactions(content, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *latoken) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id":"fbf7d0d1-2629-4ad8-9def-7a1dba423362",
    //         "status":"TRANSACTION_STATUS_CONFIRMED",
    //         "type":"TRANSACTION_TYPE_DEPOSIT",
    //         "senderAddress":"",
    //         "recipientAddress":"0x3c46fa2e3f9023bc4897828ed173f8ecb3a554bc",
    //         "amount":"200.000000000000000000",
    //         "transactionFee":"0.000000000000000000",
    //         "timestamp":1635893208404,
    //         "transactionHash":"0x28bad3b74a042df13d64ddfbca855566a51bf7f190b8cd565c236a18d5cd493f#42",
    //         "blockHeight":13540262,
    //         "currency":"0c3a106d-bde3-4c13-a26e-3fd2394529e5",
    //         "memo":null,
    //         "paymentProvider":"a8d6d1cb-f84a-4e9d-aa82-c6a08b356ee1",
    //         "requiresCode":false
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var timestamp interface{} = this.SafeInteger(transaction, "timestamp")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var addressFrom interface{} = this.SafeString(transaction, "senderAddress")
    var addressTo interface{} = this.SafeString(transaction, "recipientAddress")
    var txid interface{} = this.SafeString(transaction, "transactionHash")
    var tagTo interface{} = this.SafeString(transaction, "memo")
    var fee interface{} = map[string]interface{} {
        "currency": nil,
        "cost": nil,
        "rate": nil,
    }
    var feeCost interface{} = this.SafeNumber(transaction, "transactionFee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "cost", feeCost)
        AddElementToObject(fee, "currency", code)
    }
    var typeVar interface{} = this.ParseTransactionType(this.SafeString(transaction, "type"))
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "address": addressTo,
        "tagFrom": nil,
        "tagTo": tagTo,
        "tag": tagTo,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
func  (this *latoken) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "TRANSACTION_STATUS_CONFIRMED": "ok",
        "TRANSACTION_STATUS_EXECUTED": "ok",
        "TRANSACTION_STATUS_CHECKING": "pending",
        "TRANSACTION_STATUS_CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *latoken) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "TRANSACTION_TYPE_DEPOSIT": "deposit",
        "TRANSACTION_TYPE_WITHDRAWAL": "withdrawal",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name latoken#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/getUsersTransfers
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *latoken) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes97490 := (<-this.LoadMarkets())
            PanicOnError(retRes97490)
            var currency interface{} = this.Currency(code)
        
            response:= (<-this.PrivateGetAuthTransfer(params))
            PanicOnError(response)
            //
            //     {
            //         "hasNext": true,
            //         "content": [
            //             {
            //             "id": "ebd6312f-cb4f-45d1-9409-4b0b3027f21e",
            //             "status": "TRANSFER_STATUS_COMPLETED",
            //             "type": "TRANSFER_TYPE_WITHDRAW_SPOT",
            //             "fromAccount": "c429c551-adbb-4078-b74b-276bea308a36",
            //             "toAccount": "631c6203-bd62-4734-a04d-9b2a951f43b9",
            //             "transferringFunds": 1259.0321785,
            //             "usdValue": 1259.032179,
            //             "rejectReason": null,
            //             "timestamp": 1633515579530,
            //             "direction": "INTERNAL",
            //             "method": "TRANSFER_METHOD_UNKNOWN",
            //             "recipient": null,
            //             "sender": null,
            //             "currency": "0c3a106d-bde3-4c13-a26e-3fd2394529e5",
            //             "codeRequired": false,
            //             "fromUser": "ce555f3f-585d-46fb-9ae6-487f66738073",
            //             "toUser": "ce555f3f-585d-46fb-9ae6-487f66738073",
            //             "fee": 0
            //             },
            //             ...
            //         ],
            //         "first": true,
            //         "pageSize": 20,
            //         "hasContent": true
            //     }
            //
            var transfers interface{} = this.SafeList(response, "content", []interface{}{})
        
            ch <- this.ParseTransfers(transfers, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name latoken#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferByEmail
 * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferById
 * @see https://api.latoken.com/doc/v2/#tag/Transfer/operation/transferByPhone
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *latoken) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes376448 := (<-this.LoadMarkets())
            PanicOnError(retRes376448)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "recipient": toAccount,
                "value": this.CurrencyToPrecision(code, amount),
            }
            var response interface{} = nil
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(toAccount, "@"), 0)) {
                
        response = (<-this.PrivatePostAuthTransferEmail(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(GetLength(toAccount), 36)) {
                
        response = (<-this.PrivatePostAuthTransferId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostAuthTransferPhone(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "id": "e6fc4ace-7750-44e4-b7e9-6af038ac7107",
            //         "status": "TRANSFER_STATUS_COMPLETED",
            //         "type": "TRANSFER_TYPE_DEPOSIT_SPOT",
            //         "fromAccount": "3bf61015-bf32-47a6-b237-c9f70df772ad",
            //         "toAccount": "355eb279-7c7e-4515-814a-575a49dc0325",
            //         "transferringFunds": "500000.000000000000000000",
            //         "usdValue": "0.000000000000000000",
            //         "rejectReason": "",
            //         "timestamp": 1576844438402,
            //         "direction": "INTERNAL",
            //         "method": "TRANSFER_METHOD_UNKNOWN",
            //         "recipient": "",
            //         "sender": "",
            //         "currency": "40af7879-a8cc-4576-a42d-7d2749821b58",
            //         "codeRequired": false,
            //         "fromUser": "cd555555-666d-46fb-9ae6-487f66738073",
            //         "toUser": "cd555555-666d-46fb-9ae6-487f66738073",
            //         "fee": 0
            //     }
            //
        ch <- this.ParseTransfer(response)
            return nil
        
            }()
            return ch
        }
func  (this *latoken) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "e6fc4ace-7750-44e4-b7e9-6af038ac7107",
    //         "status": "TRANSFER_STATUS_COMPLETED",
    //         "type": "TRANSFER_TYPE_DEPOSIT_SPOT",
    //         "fromAccount": "3bf61015-bf32-47a6-b237-c9f70df772ad",
    //         "toAccount": "355eb279-7c7e-4515-814a-575a49dc0325",
    //         "transferringFunds": "500000.000000000000000000",
    //         "usdValue": "0.000000000000000000",
    //         "rejectReason": "",
    //         "timestamp": 1576844438402,
    //         "direction": "INTERNAL",
    //         "method": "TRANSFER_METHOD_UNKNOWN",
    //         "recipient": "",
    //         "sender": "",
    //         "currency": "40af7879-a8cc-4576-a42d-7d2749821b58",
    //         "codeRequired": false,
    //         "fromUser": "cd555555-666d-46fb-9ae6-487f66738073",
    //         "toUser": "cd555555-666d-46fb-9ae6-487f66738073",
    //         "fee": 0
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeTimestamp(transfer, "timestamp")
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var status interface{} = this.SafeString(transfer, "status")
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "id"),
        "timestamp": this.SafeInteger(transfer, "timestamp"),
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "transferringFunds"),
        "fromAccount": this.SafeString(transfer, "fromAccount"),
        "toAccount": this.SafeString(transfer, "toAccount"),
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *latoken) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "TRANSFER_STATUS_COMPLETED": "ok",
        "TRANSFER_STATUS_PENDING": "pending",
        "TRANSFER_STATUS_REJECTED": "failed",
        "TRANSFER_STATUS_UNVERIFIED": "pending",
        "TRANSFER_STATUS_CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *latoken) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, nil)
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    var requestString interface{} = request
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var urlencodedQuery interface{} = this.Urlencode(query)
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            requestString = Add(requestString, Add("?", urlencodedQuery))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var auth interface{} = Add(Add(method, request), urlencodedQuery)
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha512)
        headers = map[string]interface{} {
            "X-LA-APIKEY": this.ApiKey,
            "X-LA-SIGNATURE": signature,
            "X-LA-DIGEST": "HMAC-SHA512",
        }
        if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-Type", "application/json")
            body = this.Json(query)
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), requestString)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *latoken) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil
    }
    //
    // {"result":false,"message":"invalid API key, signature or digest","error":"BAD_REQUEST","status":"FAILURE"}
    // {"result":false,"message":"request expired or bad <timeAlive>/<timestamp> format","error":"BAD_REQUEST","status":"FAILURE"}
    // {"message":"Internal Server Error","error":"INTERNAL_ERROR","status":"FAILURE"}
    // {"result":false,"message":"Internal error","error":"For input string: \"NaN\"","status":"FAILURE"}
    //
    var message interface{} = this.SafeString(response, "message")
    var feedback interface{} = Add(Add(this.Id, " "), body)
    if IsTrue(!IsEqual(message, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
    }
    var error interface{} = this.SafeValue(response, "error")
    var errorMessage interface{} = this.SafeString(error, "message")
    if IsTrue(IsTrue((!IsEqual(error, nil))) || IsTrue((!IsEqual(errorMessage, nil)))) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *latoken) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
