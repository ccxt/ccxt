package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type whitebit struct {
    Exchange

}

func NewWhitebitCore() whitebit {
   p := whitebit{}
   setDefaults(&p)
   return p
}

func  (this *whitebit) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "whitebit",
        "name": "WhiteBit",
        "version": "v4",
        "countries": []interface{}{"EE"},
        "rateLimit": 50,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "createConvertTrade": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "editOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchConvertQuote": true,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": true,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrderBook": true,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionHistory": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactionFees": true,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "8h": "8h",
            "12h": "12h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",
            "api": map[string]interface{} {
                "v1": map[string]interface{} {
                    "public": "https://whitebit.com/api/v1/public",
                    "private": "https://whitebit.com/api/v1",
                },
                "v2": map[string]interface{} {
                    "public": "https://whitebit.com/api/v2/public",
                },
                "v4": map[string]interface{} {
                    "public": "https://whitebit.com/api/v4/public",
                    "private": "https://whitebit.com/api/v4",
                },
            },
            "www": "https://www.whitebit.com",
            "doc": "https://github.com/whitebit-exchange/api-docs",
            "fees": "https://whitebit.com/fee-schedule",
            "referral": "https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963",
        },
        "api": map[string]interface{} {
            "web": map[string]interface{} {
                "get": []interface{}{"v1/healthcheck"},
            },
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": []interface{}{"markets", "tickers", "ticker", "symbols", "depth/result", "history", "kline"},
                },
                "private": map[string]interface{} {
                    "post": []interface{}{"account/balance", "order/new", "order/cancel", "orders", "account/order_history", "account/executed_history", "account/executed_history/all", "account/order"},
                },
            },
            "v2": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": []interface{}{"markets", "ticker", "assets", "fee", "depth/{market}", "trades/{market}"},
                },
            },
            "v4": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": []interface{}{"assets", "collateral/markets", "fee", "orderbook/depth/{market}", "orderbook/{market}", "ticker", "trades/{market}", "time", "ping", "markets", "futures", "platform/status", "mining-pool"},
                },
                "private": map[string]interface{} {
                    "post": []interface{}{"collateral-account/balance", "collateral-account/balance-summary", "collateral-account/positions/history", "collateral-account/leverage", "collateral-account/positions/open", "collateral-account/summary", "collateral-account/funding-history", "main-account/address", "main-account/balance", "main-account/create-new-address", "main-account/codes", "main-account/codes/apply", "main-account/codes/my", "main-account/codes/history", "main-account/fiat-deposit-url", "main-account/history", "main-account/withdraw", "main-account/withdraw-pay", "main-account/transfer", "main-account/smart/plans", "main-account/smart/investment", "main-account/smart/investment/close", "main-account/smart/investments", "main-account/fee", "main-account/smart/interest-payment-history", "trade-account/balance", "trade-account/executed-history", "trade-account/order", "trade-account/order/history", "order/collateral/limit", "order/collateral/market", "order/collateral/stop-limit", "order/collateral/trigger-market", "order/collateral/bulk", "order/new", "order/market", "order/stock_market", "order/stop_limit", "order/stop_market", "order/cancel", "order/cancel/all", "order/kill-switch", "order/kill-switch/status", "order/bulk", "order/modify", "order/conditional-cancel", "orders", "oco-orders", "order/collateral/oco", "order/oco-cancel", "order/oto-cancel", "profile/websocket_token", "convert/estimate", "convert/confirm", "convert/history", "sub-account/create", "sub-account/delete", "sub-account/edit", "sub-account/list", "sub-account/transfer", "sub-account/block", "sub-account/unblock", "sub-account/balances", "sub-account/transfer/history", "sub-account/api-key/create", "sub-account/api-key/edit", "sub-account/api-key/delete", "sub-account/api-key/list", "sub-account/api-key/reset", "sub-account/api-key/ip-address/list", "sub-account/api-key/ip-address/create", "sub-account/api-key/ip-address/delete", "mining/rewards", "market/fee", "conditional-orders"},
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.001"),
                "maker": this.ParseNumber("0.001"),
            },
        },
        "options": map[string]interface{} {
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "fiatCurrencies": []interface{}{"EUR", "USD", "RUB", "UAH"},
            "fetchBalance": map[string]interface{} {
                "account": "spot",
            },
            "accountsByType": map[string]interface{} {
                "funding": "main",
                "main": "main",
                "spot": "spot",
                "margin": "collateral",
                "trade": "spot",
            },
            "networksById": map[string]interface{} {
                "BEP20": "BSC",
            },
            "defaultType": "spot",
            "brokerId": "ccxt",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1440,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Unauthorized request.": AuthenticationError,
                "The market format is invalid.": BadSymbol,
                "Market is not available": BadSymbol,
                "Invalid payload.": BadRequest,
                "Amount must be greater than 0": InvalidOrder,
                "Not enough balance.": InsufficientFunds,
                "The order id field is required.": InvalidOrder,
                "Not enough balance": InsufficientFunds,
                "This action is unauthorized.": PermissionDenied,
                "This API Key is not authorized to perform this action.": PermissionDenied,
                "Unexecuted order was not found.": OrderNotFound,
                "The selected from is invalid.": BadRequest,
                "503": ExchangeNotAvailable,
                "422": OrderNotFound,
            },
            "broad": map[string]interface{} {
                "This action is unauthorized": PermissionDenied,
                "Given amount is less than min amount": InvalidOrder,
                "Min amount step": InvalidOrder,
                "Total is less than": InvalidOrder,
                "fee must be no less than": InvalidOrder,
                "Enable your key in API settings": PermissionDenied,
                "You don\\'t have such amount for transfer": InsufficientFunds,
            },
        },
    })
}
/**
 * @method
 * @name whitebit#fetchMarkets
 * @description retrieves data on all markets for whitebit
 * @see https://docs.whitebit.com/public/http-v4/#market-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *whitebit) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes41812 := (<-this.LoadTimeDifference())
                PanicOnError(retRes41812)
            }
        
            markets:= (<-this.V4PublicGetMarkets())
            PanicOnError(markets)
        
                //
            //    [
            //        {
            //          "name": "SON_USD",         // Market pair name
            //          "stock": "SON",            // Ticker of stock currency
            //          "money": "USD",            // Ticker of money currency
            //          "stockPrec": "3",          // Stock currency precision
            //          "moneyPrec": "2",          // Precision of money currency
            //          "feePrec": "4",            // Fee precision
            //          "makerFee": "0.1",         // Default maker fee ratio
            //          "takerFee": "0.1",         // Default taker fee ratio
            //          "minAmount": "0.001",      // Minimal amount of stock to trade
            //          "minTotal": "0.001",       // Minimal amount of money to trade
            //          "tradesEnabled": true,     // Is trading enabled
            //          "isCollateral": true,      // Is margin trading enabled
            //          "type": "spot",            // Market type. Possible values: "spot", "futures"
            //          "maxTotal": "1000000000"   // Maximum total(amount * price) of money to trade
            //        },
            //        {
            //          ...
            //        }
            //    ]
            //
        ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "name")
    var baseId interface{} = this.SafeString(market, "stock")
    var quoteId interface{} = this.SafeString(market, "money")
    quoteId = Ternary(IsTrue((IsEqual(quoteId, "PERP"))), "USDT", quoteId)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var active interface{} = this.SafeValue(market, "tradesEnabled")
    var isCollateral interface{} = this.SafeValue(market, "isCollateral")
    var typeId interface{} = this.SafeString(market, "type")
    var typeVar interface{} = nil
    var settle interface{} = nil
    var settleId interface{} = nil
    var symbol interface{} = Add(Add(base, "/"), quote)
    var swap interface{} = IsEqual(typeId, "futures")
    var margin interface{} = IsTrue(isCollateral) && !IsTrue(swap)
    var contract interface{} = false
    var amountPrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "stockPrec")))
    var contractSize interface{} = amountPrecision
    var linear interface{} = nil
    var inverse interface{} = nil
    if IsTrue(swap) {
        settleId = quoteId
        settle = this.SafeCurrencyCode(settleId)
        symbol = Add(Add(symbol, ":"), settle)
        typeVar = "swap"
        contract = true
        linear = true
        inverse = false
    } else {
        typeVar = "spot"
    }
    var takerFeeRate interface{} = this.SafeString(market, "takerFee")
    var taker interface{} = Precise.StringDiv(takerFeeRate, "100")
    var makerFeeRate interface{} = this.SafeString(market, "makerFee")
    var maker interface{} = Precise.StringDiv(makerFeeRate, "100")
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": typeVar,
        "spot": !IsTrue(swap),
        "margin": margin,
        "swap": swap,
        "future": false,
        "option": false,
        "active": active,
        "contract": contract,
        "linear": linear,
        "inverse": inverse,
        "taker": this.ParseNumber(taker),
        "maker": this.ParseNumber(maker),
        "contractSize": contractSize,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": amountPrecision,
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "moneyPrec"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minAmount"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "minTotal"),
                "max": this.SafeNumber(market, "maxTotal"),
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name whitebit#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.whitebit.com/public/http-v4/#asset-status-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *whitebit) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V4PublicGetAssets(params))
            PanicOnError(response)
            //
            //      "BTC": {
            //          "name": "Bitcoin",
            //          "unified_cryptoasset_id": 1,
            //          "can_withdraw": true,
            //          "can_deposit": true,
            //          "min_withdraw": "0.001",
            //          "max_withdraw": "2",
            //          "maker_fee": "0.1",
            //          "taker_fee": "0.1",
            //          "min_deposit": "0.0001",
            //           "max_deposit": "0",
            //       },
            //
            var ids interface{} = ObjectKeys(response)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                var currency interface{} = GetValue(response, id)
                // breaks down in Python due to utf8 encoding issues on the exchange side
                // const name = this.safeString (currency, 'name');
                var canDeposit interface{} = this.SafeBool(currency, "can_deposit", true)
                var canWithdraw interface{} = this.SafeBool(currency, "can_withdraw", true)
                var active interface{} = IsTrue(canDeposit) && IsTrue(canWithdraw)
                var code interface{} = this.SafeCurrencyCode(id)
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "name": nil,
            "active": active,
            "deposit": canDeposit,
            "withdraw": canWithdraw,
            "fee": nil,
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "min_withdraw"),
                    "max": this.SafeNumber(currency, "max_withdraw"),
                },
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchTransactionFees
 * @deprecated
 * @description please use fetchDepositWithdrawFees instead
 * @see https://docs.whitebit.com/public/http-v4/#fee
 * @param {string[]|undefined} codes not used by fetchTransactionFees ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *whitebit) FetchTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6078 := (<-this.LoadMarkets())
            PanicOnError(retRes6078)
        
            response:= (<-this.V4PublicGetFee(params))
            PanicOnError(response)
            //
            //      {
            //          "1INCH":{
            //              "is_depositable":true,
            //              "is_withdrawal":true,
            //              "ticker":"1INCH",
            //              "name":"1inch",
            //              "providers":[
            //              ],
            //              "withdraw":{
            //                   "max_amount":"0",
            //                  "min_amount":"21.5",
            //                  "fixed":"17.5",
            //                  "flex":null
            //              },
            //              "deposit":{
            //                  "max_amount":"0",
            //                  "min_amount":"19.5",
            //                  "fixed":null,
            //                  "flex":null
            //               }
            //          },
            //           {...}
            //      }
            //
            var currenciesIds interface{} = ObjectKeys(response)
            var withdrawFees interface{} = map[string]interface{} {}
            var depositFees interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currenciesIds)); i++ {
                var currency interface{} = GetValue(currenciesIds, i)
                var data interface{} = GetValue(response, currency)
                var code interface{} = this.SafeCurrencyCode(currency)
                var withdraw interface{} = this.SafeValue(data, "withdraw", map[string]interface{} {})
                AddElementToObject(withdrawFees, code, this.SafeString(withdraw, "fixed"))
                var deposit interface{} = this.SafeValue(data, "deposit", map[string]interface{} {})
                AddElementToObject(depositFees, code, this.SafeString(deposit, "fixed"))
            }
        
            ch <- map[string]interface{} {
                "withdraw": withdrawFees,
                "deposit": depositFees,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://docs.whitebit.com/public/http-v4/#fee
 * @param {string[]|undefined} codes not used by fetchDepositWithdrawFees ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *whitebit) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6638 := (<-this.LoadMarkets())
            PanicOnError(retRes6638)
        
            response:= (<-this.V4PublicGetFee(params))
            PanicOnError(response)
        
                //
            //    {
            //        "1INCH": {
            //            "is_depositable": true,
            //            "is_withdrawal": true,
            //            "ticker": "1INCH",
            //            "name": "1inch",
            //            "providers": [],
            //            "withdraw": {
            //                "max_amount": "0",
            //                "min_amount": "21.5",
            //                "fixed": "17.5",
            //                "flex": null
            //            },
            //            "deposit": {
            //                "max_amount": "0",
            //                "min_amount": "19.5",
            //                "fixed": null,
            //                "flex": null
            //            }
            //        },
            //        "WBT (ERC20)": {
            //            "is_depositable": true,
            //            "is_withdrawal": true,
            //            "ticker": "WBT",
            //            "name": "WhiteBIT Token",
            //            "providers": [],
            //            "withdraw": { max_amount: "0", min_amount: '0.7', fixed: "0.253", flex: null },
            //            "deposit": { max_amount: "0", min_amount: "0.35", fixed: null, flex: null }
            //        },
            //        "WBT (TRC20)": {
            //            "is_depositable": true,
            //            "is_withdrawal": true,
            //            "ticker": "WBT",
            //            "name": "WhiteBIT Token",
            //            "providers": [],
            //            "withdraw": { max_amount: "0", min_amount: "1.5", fixed: "0.075", flex: null },
            //            "deposit": { max_amount: "0", min_amount: "0.75", fixed: null, flex: null }
            //        },
            //        ...
            //    }
            //
        ch <- this.ParseDepositWithdrawFees(response, codes)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "1INCH": {
    //            "is_depositable": true,
    //            "is_withdrawal": true,
    //            "ticker": "1INCH",
    //            "name": "1inch",
    //            "providers": [],
    //            "withdraw": {
    //                "max_amount": "0",
    //                "min_amount": "21.5",
    //                "fixed": "17.5",
    //                "flex": null
    //            },
    //            "deposit": {
    //                "max_amount": "0",
    //                "min_amount": "19.5",
    //                "fixed": null,
    //                "flex": null
    //            }
    //        },
    //        "WBT (ERC20)": {
    //            "is_depositable": true,
    //            "is_withdrawal": true,
    //            "ticker": "WBT",
    //            "name": "WhiteBIT Token",
    //            "providers": [],
    //            "withdraw": { max_amount: "0", min_amount: "0.7", fixed: "0.253", flex: null },
    //            "deposit": { max_amount: "0", min_amount: "0.35", fixed: null, flex: null }
    //        },
    //        "WBT (TRC20)": {
    //            "is_depositable": true,
    //            "is_withdrawal": true,
    //            "ticker": "WBT",
    //            "name": "WhiteBIT Token",
    //            "providers": [],
    //            "withdraw": { max_amount: "0", min_amount: "1.5", fixed: "0.075", flex: null },
    //            "deposit": { max_amount: "0", min_amount: "0.75", fixed: null, flex: null }
    //        },
    //        ...
    //    }
    //
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 1, nil)
    _ = currencyIdKey
    var depositWithdrawFees interface{} = map[string]interface{} {}
    codes = this.MarketCodes(codes)
    var currencyIds interface{} = ObjectKeys(response)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var entry interface{} = GetValue(currencyIds, i)
        var splitEntry interface{} = Split(entry, " ")
        var currencyId interface{} = GetValue(splitEntry, 0)
        var feeInfo interface{} = GetValue(response, entry)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
            var depositWithdrawFee interface{} = this.SafeValue(depositWithdrawFees, code)
            if IsTrue(IsEqual(depositWithdrawFee, nil)) {
                AddElementToObject(depositWithdrawFees, code, this.DepositWithdrawFee(map[string]interface{} {}))
            }
            AddElementToObject(GetValue(GetValue(depositWithdrawFees, code), "info"), entry, feeInfo)
            var networkId interface{} = this.SafeString(splitEntry, 1)
            var withdraw interface{} = this.SafeValue(feeInfo, "withdraw")
            var deposit interface{} = this.SafeValue(feeInfo, "deposit")
            var withdrawFee interface{} = this.SafeNumber(withdraw, "fixed")
            var depositFee interface{} = this.SafeNumber(deposit, "fixed")
            var withdrawResult interface{} = map[string]interface{} {
                "fee": withdrawFee,
                "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
            }
            var depositResult interface{} = map[string]interface{} {
                "fee": depositFee,
                "percentage": Ternary(IsTrue((!IsEqual(depositFee, nil))), false, nil),
            }
            if IsTrue(!IsEqual(networkId, nil)) {
                var networkLength interface{} =                 GetLength(networkId)
                networkId = Slice(networkId, 1, Subtract(networkLength, 1))
                var networkCode interface{} = this.NetworkIdToCode(networkId)
                AddElementToObject(GetValue(GetValue(depositWithdrawFees, code), "networks"), networkCode, map[string]interface{} {
    "withdraw": withdrawResult,
    "deposit": depositResult,
})
            } else {
                AddElementToObject(GetValue(depositWithdrawFees, code), "withdraw", withdrawResult)
                AddElementToObject(GetValue(depositWithdrawFees, code), "deposit", depositResult)
            }
        }
    }
    var depositWithdrawCodes interface{} = ObjectKeys(depositWithdrawFees)
    for i := 0; IsLessThan(i, GetArrayLength(depositWithdrawCodes)); i++ {
        var code interface{} = GetValue(depositWithdrawCodes, i)
        var currency interface{} = this.Currency(code)
        AddElementToObject(depositWithdrawFees, code, this.AssignDefaultDepositWithdrawFees(GetValue(depositWithdrawFees, code), currency))
    }
    return depositWithdrawFees
}
/**
 * @method
 * @name whitebit#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.whitebit.com/public/http-v4/#asset-status-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *whitebit) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8138 := (<-this.LoadMarkets())
            PanicOnError(retRes8138)
        
            response:= (<-this.V4PublicGetAssets(params))
            PanicOnError(response)
            //
            //      {
            //          "1INCH": {
            //              "name": "1inch",
            //              "unified_cryptoasset_id": "8104",
            //              "can_withdraw": true,
            //              "can_deposit": true,
            //              "min_withdraw": "33",
            //              "max_withdraw": "0",
            //              "maker_fee": "0.1",
            //              "taker_fee": "0.1",
            //              "min_deposit": "30",
            //              "max_deposit": "0"
            //            },
            //            ...
            //      }
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                var market interface{} = this.Market(symbol)
                var fee interface{} = this.SafeValue(response, GetValue(market, "baseId"), map[string]interface{} {})
                var makerFee interface{} = this.SafeString(fee, "maker_fee")
                var takerFee interface{} = this.SafeString(fee, "taker_fee")
                makerFee = Precise.StringDiv(makerFee, "100")
                takerFee = Precise.StringDiv(takerFee, "100")
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fee,
            "symbol": GetValue(market, "symbol"),
            "percentage": true,
            "tierBased": false,
            "maker": this.ParseNumber(makerFee),
            "taker": this.ParseNumber(takerFee),
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.whitebit.com/public/http-v4/#market-activity
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *whitebit) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8638 := (<-this.LoadMarkets())
            PanicOnError(retRes8638)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //         "success":true,
            //         "message":"",
            //         "result": {
            //             "bid":"0.021979",
            //             "ask":"0.021996",
            //             "open":"0.02182",
            //             "high":"0.022039",
            //             "low":"0.02161",
            //             "last":"0.021987",
            //             "volume":"2810.267",
            //             "deal":"61.383565474",
            //             "change":"0.76",
            //         },
            //     }
            //
            var ticker interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  FetchTicker (v1)
    //
    //    {
    //        "bid": "0.021979",
    //        "ask": "0.021996",
    //        "open": "0.02182",
    //        "high": "0.022039",
    //        "low": "0.02161",
    //        "last": "0.021987",
    //        "volume": "2810.267",
    //        "deal": "61.383565474",
    //        "change": "0.76",
    //    }
    //
    // FetchTickers (v4)
    //
    //    "BCH_RUB": {
    //        "base_id": 1831,
    //        "quote_id": 0,
    //        "last_price": "32830.21",
    //        "quote_volume": "1494659.8024096",
    //        "base_volume": "46.1083",
    //        "isFrozen": false,
    //        "change": "2.12" // in percent
    //    }
    //
    // WS market_update
    //
    //     {
    //         "open": "52853.04",
    //         "close": "55913.88",
    //         "high": "56272",
    //         "low": "49549.67",
    //         "volume": "57331.067185",
    //         "deal": "3063860382.42985338",
    //         "last": "55913.88",
    //         "period": 86400
    //     }
    // v2
    //   {
    //       lastUpdateTimestamp: '2025-01-02T09:16:36.000Z',
    //       tradingPairs: 'ARB_USDC',
    //       lastPrice: '0.7727',
    //       lowestAsk: '0.7735',
    //       highestBid: '0.7732',
    //       baseVolume24h: '1555793.74',
    //       quoteVolume24h: '1157602.622406',
    //       tradesEnabled: true
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "tradingPairs")
    market = this.SafeMarket(marketId, market)
    // last price is provided as "last" or "last_price"
    var last interface{} = this.SafeStringN(ticker, []interface{}{"last", "last_price", "lastPrice"})
    // if "close" is provided, use it, otherwise use <last>
    var close interface{} = this.SafeString(ticker, "close", last)
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString2(ticker, "bid", "highestBid"),
        "bidVolume": nil,
        "ask": this.SafeString2(ticker, "ask", "lowestAsk"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": close,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "change"),
        "average": nil,
        "baseVolume": this.SafeStringN(ticker, []interface{}{"base_volume", "volume", "baseVolume24h"}),
        "quoteVolume": this.SafeStringN(ticker, []interface{}{"quote_volume", "deal", "quoteVolume24h"}),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name whitebit#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.whitebit.com/public/http-v4/#market-activity
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either v2PublicGetTicker or v4PublicGetTicker default is v4PublicGetTicker
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *whitebit) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9838 := (<-this.LoadMarkets())
            PanicOnError(retRes9838)
            symbols = this.MarketSymbols(symbols)
            var method interface{} = "v4PublicGetTicker"
            methodparamsVariable := this.HandleOptionAndParams(params, "fetchTickers", "method", method);
            method = GetValue(methodparamsVariable,0);
            params = GetValue(methodparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(method, "v4PublicGetTicker")) {
                
        response = (<-this.V4PublicGetTicker(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetTicker(params))
                PanicOnError(response)
            }
            //
            //      "BCH_RUB": {
            //          "base_id":1831,
            //          "quote_id":0,
            //          "last_price":"32830.21",
            //          "quote_volume":"1494659.8024096",
            //          "base_volume":"46.1083",
            //          "isFrozen":false,
            //          "change":"2.12"
            //      },
            //
            var resultList interface{} = this.SafeList(response, "result")
            if IsTrue(!IsEqual(resultList, nil)) {
        
                ch <- this.ParseTickers(resultList, symbols)
                return nil
            }
            var marketIds interface{} = ObjectKeys(response)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var market interface{} = this.SafeMarket(marketId)
                var ticker interface{} = this.ParseTicker(GetValue(response, marketId), market)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.whitebit.com/public/http-v4/#orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *whitebit) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10318 := (<-this.LoadMarkets())
            PanicOnError(retRes10318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default = 100, maximum = 100
            }
        
            response:= (<-this.V4PublicGetOrderbookMarket(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "timestamp": 1594391413,
            //          "asks": [
            //              [
            //                  "9184.41",
            //                  "0.773162"
            //              ],
            //              [ ... ]
            //          ],
            //          "bids": [
            //              [
            //                  "9181.19",
            //                  "0.010873"
            //              ],
            //              [ ... ]
            //          ]
            //      }
            //
            var timestamp interface{} = this.SafeTimestamp(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.whitebit.com/public/http-v4/#recent-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *whitebit) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes10758 := (<-this.LoadMarkets())
            PanicOnError(retRes10758)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.V4PublicGetTradesMarket(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //      [
            //          {
            //              "tradeID": 158056419,
            //              "price": "9186.13",
            //              "quote_volume": "0.0021",
            //              "base_volume": "9186.13",
            //              "trade_timestamp": 1594391747,
            //              "type": "sell"
            //          },
            //      ],
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.whitebit.com/private/http-trade-v4/#query-executed-order-history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *whitebit) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11088 := (<-this.LoadMarkets())
            PanicOnError(retRes11088)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
        
            response:= (<-this.V4PrivatePostTradeAccountExecutedHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // when no symbol is provided
            //
            //   {
            //       "USDC_USDT":[
            //          {
            //             "id":"1343815269",
            //             "clientOrderId":"",
            //             "time":"1641051917.532965",
            //             "side":"sell",
            //             "role":"2",
            //             "amount":"9.986",
            //             "price":"0.9995",
            //             "deal":"9.981007",
            //             "fee":"0.009981007",
            //             "orderId":"58166729555"
            //          },
            //       ]
            //   }
            //
            // when a symbol is provided
            //
            //     [
            //         {
            //             "id": 1343815269,
            //             "clientOrderId": '',
            //             "time": 1641051917.532965,
            //             "side": "sell",
            //             "role": 2,
            //             "amount": "9.986",
            //             "price": "0.9995",
            //             "deal": "9.981007",
            //             "fee": "0.009981007",
            //             "orderId": 58166729555,
            //         },
            //     ]
            //
            if IsTrue(IsArray(response)) {
        
                ch <- this.ParseTrades(response, market, since, limit)
                return nil
            } else {
                var results interface{} = []interface{}{}
                var keys interface{} = ObjectKeys(response)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    var marketId interface{} = GetValue(keys, i)
                    var marketNew interface{} = this.SafeMarket(marketId, nil, "_")
                    var rawTrades interface{} = this.SafeValue(response, marketId, []interface{}{})
                    var parsed interface{} = this.ParseTrades(rawTrades, marketNew, since, limit)
                    results = this.ArrayConcat(results, parsed)
                }
                results = this.SortBy2(results, "timestamp", "id")
        
                ch <- this.FilterBySinceLimit(results, since, limit, "timestamp")
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *whitebit) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTradesV4
    //
    //     {
    //       "tradeID": 158056419,
    //       "price": "9186.13",
    //       "quote_volume": "0.0021",
    //       "base_volume": "9186.13",
    //       "trade_timestamp": 1594391747,
    //       "type": "sell"
    //     }
    //
    // orderTrades (v4Private)
    //
    //     {
    //         "time": 1593342324.613711,
    //         "fee": "0.00000419198",
    //         "price": "0.00000701",
    //         "amount": "598",
    //         "id": 149156519, // trade id
    //         "dealOrderId": 3134995325, // orderId
    //         "clientOrderId": "customId11",
    //         "role": 2, // 1 = maker, 2 = taker
    //         "deal": "0.00419198" // amount in money
    //         "feeAsset": "USDT"
    //     }
    //
    // fetchMyTrades
    //
    //      {
    //          "id": 1343815269,
    //          "clientOrderId": '',
    //          "time": 1641051917.532965,
    //          "side": "sell",
    //          "role": 2,
    //          "amount": "9.986",
    //          "price": "0.9995",
    //          "deal": "9.981007",
    //          "fee": "0.009981007",
    //          "orderId": 58166729555,
    //          "feeAsset": "USDT"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(nil, market)
    var timestamp interface{} = this.SafeTimestamp2(trade, "time", "trade_timestamp")
    var orderId interface{} = this.SafeString2(trade, "dealOrderId", "orderId")
    var cost interface{} = this.SafeString(trade, "deal")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString2(trade, "amount", "quote_volume")
    var id interface{} = this.SafeString2(trade, "id", "tradeID")
    var side interface{} = this.SafeString2(trade, "type", "side")
    var symbol interface{} = GetValue(market, "symbol")
    var role interface{} = this.SafeInteger(trade, "role")
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(role, nil)) {
        takerOrMaker = Ternary(IsTrue((IsEqual(role, 1))), "maker", "taker")
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "feeAsset")),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": nil,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name whitebit#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.whitebit.com/public/http-v1/#kline
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *whitebit) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12668 := (<-this.LoadMarkets())
            PanicOnError(retRes12668)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                var maxLimit interface{} = 1440
                if IsTrue(IsEqual(limit, nil)) {
                    limit = maxLimit
                }
                limit = mathMin(limit, maxLimit)
                var start interface{} = this.ParseToInt(Divide(since, 1000))
                AddElementToObject(request, "start", start)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1440))
            }
        
            response:= (<-this.V1PublicGetKline(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "message":"",
            //         "result":[
            //             [1591488000,"0.025025","0.025025","0.025029","0.025023","6.181","0.154686629"],
            //             [1591488060,"0.025028","0.025033","0.025035","0.025026","8.067","0.201921167"],
            //             [1591488120,"0.025034","0.02505","0.02505","0.025034","20.089","0.503114696"],
            //         ]
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOHLCVs(result, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1591488000,
    //         "0.025025",
    //         "0.025025",
    //         "0.025029",
    //         "0.025023",
    //         "6.181",
    //         "0.154686629"
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name whitebit#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.whitebit.com/public/http-v4/#server-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *whitebit) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V4PublicGetPing(params))
            PanicOnError(response)
            //
            //      [
            //          "pong"
            //      ]
            //
            var status interface{} = this.SafeString(response, 0)
        
            ch <- map[string]interface{} {
                "status": Ternary(IsTrue((IsEqual(status, "pong"))), "ok", status),
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.whitebit.com/public/http-v4/#server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *whitebit) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V4PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "time":1737380046
            //     }
            //
        ch <- this.SafeInteger(response, "time")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            AddElementToObject(params, "cost", cost)
        
                retRes137815 :=  (<-this.CreateOrder(symbol, "market", side, 0, nil, params))
                PanicOnError(retRes137815)
                    // only buy side is supported
        ch <- retRes137815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes139115 :=  (<-this.CreateMarketOrderWithCost(symbol, "buy", cost, params))
                PanicOnError(retRes139115)
                ch <- retRes139115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#createOrder
 * @description create a trade order
 * @see https://docs.whitebit.com/private/http-trade-v4/#create-limit-order
 * @see https://docs.whitebit.com/private/http-trade-v4/#create-market-order
 * @see https://docs.whitebit.com/private/http-trade-v4/#create-buy-stock-market-order
 * @see https://docs.whitebit.com/private/http-trade-v4/#create-stop-limit-order
 * @see https://docs.whitebit.com/private/http-trade-v4/#create-stop-market-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *market orders only* the cost of the order in units of the base currency
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14138 := (<-this.LoadMarkets())
            PanicOnError(retRes14138)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "side": side,
            }
            var cost interface{} = nil
            costparamsVariable := this.HandleParamString(params, "cost");
            cost = GetValue(costparamsVariable,0);
            params = GetValue(costparamsVariable,1)
            if IsTrue(!IsEqual(cost, nil)) {
                if IsTrue(IsTrue((!IsEqual(side, "buy"))) || IsTrue((!IsEqual(typeVar, "market")))) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() cost is only supported for market buy orders")))
                }
                AddElementToObject(request, "amount", this.CostToPrecision(symbol, cost))
            } else {
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                var brokerId interface{} = this.SafeString(this.Options, "brokerId")
                if IsTrue(!IsEqual(brokerId, nil)) {
                    AddElementToObject(request, "clientOrderId", Add(brokerId, this.Uuid16()))
                }
            } else {
                AddElementToObject(request, "clientOrderId", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId"})
            }
            var marketType interface{} = this.SafeString(market, "type")
            var isLimitOrder interface{} = IsEqual(typeVar, "limit")
            var isMarketOrder interface{} = IsEqual(typeVar, "market")
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "activation_price"})
            var isStopOrder interface{} =     (!IsEqual(triggerPrice, nil))
            var postOnly interface{} = this.IsPostOnly(isMarketOrder, false, params)
            marginModequeryVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(postOnly) {
                AddElementToObject(request, "postOnly", true)
            }
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) && IsTrue(!IsEqual(marginMode, "cross"))) {
                panic(NotSupported(Add(this.Id, " createOrder() is only available for cross margin")))
            }
            params = this.Omit(query, []interface{}{"postOnly", "triggerPrice", "stopPrice"})
            var useCollateralEndpoint interface{} = IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "swap"))
            var response interface{} = nil
            if IsTrue(isStopOrder) {
                AddElementToObject(request, "activation_price", this.PriceToPrecision(symbol, triggerPrice))
                if IsTrue(isLimitOrder) {
                    // stop limit order
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                    
        response = (<-this.V4PrivatePostOrderStopLimit(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    // stop market order
                    if IsTrue(useCollateralEndpoint) {
                        
        response = (<-this.V4PrivatePostOrderCollateralTriggerMarket(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V4PrivatePostOrderStopMarket(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                }
            } else {
                if IsTrue(isLimitOrder) {
                    // limit order
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                    if IsTrue(useCollateralEndpoint) {
                        
        response = (<-this.V4PrivatePostOrderCollateralLimit(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.V4PrivatePostOrderNew(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else {
                    // market order
                    if IsTrue(useCollateralEndpoint) {
                        
        response = (<-this.V4PrivatePostOrderCollateralMarket(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        if IsTrue(!IsEqual(cost, nil)) {
                            
        response = (<-this.V4PrivatePostOrderMarket(this.Extend(request, params)))
                            PanicOnError(response)
                        } else {
                            
        response = (<-this.V4PrivatePostOrderStockMarket(this.Extend(request, params)))
                            PanicOnError(response)
                        }
                    }
                }
            }
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#editOrder
 * @description edit a trade order
 * @see https://docs.whitebit.com/private/http-trade-v4/#modify-order
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(id, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a id argument")))
            }
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a symbol argument")))
            }
        
            retRes15158 := (<-this.LoadMarkets())
            PanicOnError(retRes15158)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "orderId": id,
                "market": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                // Update clientOrderId of the order
                AddElementToObject(request, "clientOrderId", clientOrderId)
            }
            var isLimitOrder interface{} = IsEqual(typeVar, "limit")
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "activation_price"})
            var isStopOrder interface{} =     (!IsEqual(triggerPrice, nil))
            params = this.Omit(params, []interface{}{"clOrdId", "clientOrderId", "triggerPrice", "stopPrice"})
            if IsTrue(isStopOrder) {
                AddElementToObject(request, "activation_price", this.PriceToPrecision(symbol, triggerPrice))
                if IsTrue(isLimitOrder) {
                    // stop limit order
                    AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                } else {
                    // stop market order
                    if IsTrue(IsEqual(side, "buy")) {
                        // Use total parameter instead of amount for modify buy stop market order
                        AddElementToObject(request, "total", this.AmountToPrecision(symbol, amount))
                    } else {
                        AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                    }
                }
            } else {
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                if IsTrue(isLimitOrder) {
                    // limit order
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
            }
        
            response:= (<-this.V4PrivatePostOrderModify(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#cancelOrder
 * @description cancels an open order
 * @see https://docs.whitebit.com/private/http-trade-v4/#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes15708 := (<-this.LoadMarkets())
            PanicOnError(retRes15708)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "orderId": ParseInt(id),
            }
        
            response:= (<-this.V4PrivatePostOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "orderId": 4180284841, // order id
            //        "clientOrderId": "customId11", // custom order identifier; "clientOrderId": "" - if not specified.
            //        "market": "BTC_USDT", // deal market
            //        "side": "buy", // order side
            //        "type": "stop market", // order type
            //        "timestamp": 1595792396.165973, // current timestamp
            //        "dealMoney": "0", // if order finished - amount in money currency that is finished
            //        "dealStock": "0", // if order finished - amount in stock currency that is finished
            //        "amount": "0.001", // amount
            //        "takerFee": "0.001", // maker fee ratio. If the number less than 0.0001 - it will be rounded to zero
            //        "makerFee": "0.001", // maker fee ratio. If the number less than 0.0001 - it will be rounded to zero
            //        "left": "0.001", // if order not finished - rest of the amount that must be finished
            //        "dealFee": "0", // fee in money that you pay if order is finished
            //        "price": "40000", // price if price isset
            //        "activation_price": "40000" // activation price if activation price is set
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.whitebit.com/private/http-trade-v4/#cancel-all-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] market type, ['swap', 'spot']
 * @param {boolean} [params.isMargin] cancel all margin orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16118 := (<-this.LoadMarkets())
            PanicOnError(retRes16118)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var requestType interface{} = []interface{}{}
            if IsTrue(IsEqual(typeVar, "spot")) {
                var isMargin interface{} = nil
                isMarginparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrders", "isMargin", false);
                isMargin = GetValue(isMarginparamsVariable,0);
                params = GetValue(isMarginparamsVariable,1)
                if IsTrue(isMargin) {
                    AppendToArray(&requestType,"margin")
                } else {
                    AppendToArray(&requestType,"spot")
                }
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                AppendToArray(&requestType,"futures")
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelAllOrders() does not support "), typeVar), " type")))
            }
            AddElementToObject(request, "type", requestType)
        
            response:= (<-this.V4PrivatePostOrderCancelAll(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // []
            //
        ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://docs.whitebit.com/private/http-trade-v4/#sync-kill-switch-timer
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.types] Order types value. Example: "spot", "margin", "futures" or null
 * @param {string} [params.symbol] symbol unified symbol of the market the order was made in
 * @returns {object} the api result
 */
func  (this *whitebit) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16548 := (<-this.LoadMarkets())
            PanicOnError(retRes16548)
            var symbol interface{} = this.SafeString(params, "symbol")
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrdersAfter() requires a symbol argument in params")))
            }
            var market interface{} = this.Market(symbol)
            params = this.Omit(params, "symbol")
            var isBiggerThanZero interface{} =     (IsGreaterThan(timeout, 0))
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(isBiggerThanZero) {
                AddElementToObject(request, "timeout", this.NumberToString(Divide(timeout, 1000)))
            } else {
                AddElementToObject(request, "timeout", "null")
            }
        
            response:= (<-this.V4PrivatePostOrderKillSwitch(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "market": "BTC_USDT", // currency market,
            //         "startTime": 1662478154, // now timestamp,
            //         "cancellationTime": 1662478154, // now + timer_value,
            //         "types": ["spot", "margin"]
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseBalance(response interface{}) interface{}  {
    var balanceKeys interface{} = ObjectKeys(response)
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(balanceKeys)); i++ {
        var id interface{} = GetValue(balanceKeys, i)
        var code interface{} = this.SafeCurrencyCode(id)
        var balance interface{} = GetValue(response, id)
        if IsTrue(IsTrue(IsObject(balance)) && IsTrue(!IsEqual(balance, nil))) {
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString2(balance, "available", "main_balance"))
            AddElementToObject(account, "used", this.SafeString(balance, "freeze"))
            AddElementToObject(account, "total", this.SafeString(balance, "main_balance"))
            AddElementToObject(result, code, account)
        } else {
            var account interface{} = this.Account()
            AddElementToObject(account, "total", balance)
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name whitebit#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.whitebit.com/private/http-main-v4/#main-balance
 * @see https://docs.whitebit.com/private/http-trade-v4/#trading-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *whitebit) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17158 := (<-this.LoadMarkets())
            PanicOnError(retRes17158)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.V4PrivatePostCollateralAccountBalance(params))
                PanicOnError(response)
            } else {
                var options interface{} = this.SafeValue(this.Options, "fetchBalance", map[string]interface{} {})
                var defaultAccount interface{} = this.SafeString(options, "account")
                var account interface{} = this.SafeString2(params, "account", "type", defaultAccount)
                params = this.Omit(params, []interface{}{"account", "type"})
                if IsTrue(IsTrue(IsEqual(account, "main")) || IsTrue(IsEqual(account, "funding"))) {
                    
        response = (<-this.V4PrivatePostMainAccountBalance(params))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V4PrivatePostTradeAccountBalance(params))
                    PanicOnError(response)
                }
            }
        
                //
            // main account
            //
            //     {
            //         "BTC":{"main_balance":"0.0013929494020316"},
            //         "ETH":{"main_balance":"0.001398289308"},
            //     }
            //
            // spot trade account
            //
            //     {
            //         "BTC": { "available": "0.123", "freeze": "1" },
            //         "XMR": { "available": "3013", "freeze": "100" },
            //     }
            //
            // swap
            //
            //     {
            //          "BTC": 1,
            //          "USDT": 1000
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.whitebit.com/private/http-trade-v4/#query-unexecutedactive-orders
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17698 := (<-this.LoadMarkets())
            PanicOnError(retRes17698)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 100))
            }
        
            response:= (<-this.V4PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "orderId": 3686033640,
            //             "clientOrderId": "customId11",
            //             "market": "BTC_USDT",
            //             "side": "buy",
            //             "type": "limit",
            //             "timestamp": 1594605801.49815,    // current timestamp of unexecuted order
            //             "dealMoney": "0",                 // executed amount in money
            //             "dealStock": "0",                 // executed amount in stock
            //             "amount": "2.241379",             // active order amount
            //             "takerFee": "0.001",
            //             "makerFee": "0.001",
            //             "left": "2.241379",               // unexecuted amount in stock
            //             "dealFee": "0",                   // executed fee by deal
            //             "price": "40000"
            //         },
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit, map[string]interface{} {
                "status": "open",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.whitebit.com/private/http-trade-v4/#query-executed-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *whitebit) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18158 := (<-this.LoadMarkets())
            PanicOnError(retRes18158)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = GetValue(market, "symbol")
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 100)) // default 50 max 100
            }
        
            response:= (<-this.V4PrivatePostTradeAccountOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "BTC_USDT": [
            //             {
            //                 "id": 160305483,
            //                 "clientOrderId": "customId11",
            //                 "time": 1594667731.724403,
            //                 "side": "sell",
            //                 "role": 2, // 1 = maker, 2 = taker
            //                 "amount": "0.000076",
            //                 "price": "9264.21",
            //                 "deal": "0.70407996",
            //                 "fee": "0.00070407996"
            //             },
            //         ],
            //     }
            //
            var marketIds interface{} = ObjectKeys(response)
            var results interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var marketNew interface{} = this.SafeMarket(marketId, nil, "_")
                var orders interface{} = GetValue(response, marketId)
                for j := 0; IsLessThan(j, GetArrayLength(orders)); j++ {
                    var order interface{} = this.ParseOrder(GetValue(orders, j), marketNew)
                    AppendToArray(&results,this.Extend(order, map[string]interface{} {
                        "status": "closed",
                    }))
                }
            }
            results = this.SortBy(results, "timestamp")
            results = this.FilterBySymbolSinceLimit(results, symbol, since, limit)
        
            ch <- results
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "limit": "limit",
        "market": "market",
        "stop market": "market",
        "stop limit": "limit",
        "stock market": "market",
        "margin limit": "limit",
        "margin market": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *whitebit) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, fetchOpenOrders, cancelOrder
    //
    //      {
    //          "orderId":105687928629,
    //          "clientOrderId":"",
    //          "market":"DOGE_USDT",
    //          "side":"sell",
    //          "type":"stop market",
    //          "timestamp":1659091079.729576,
    //          "dealMoney":"0",                // executed amount in quote
    //          "dealStock":"0",                // base filled amount
    //          "amount":"100",
    //          "takerFee":"0.001",
    //          "makerFee":"0",
    //          "left":"100",
    //          "price": "40000", // price if price isset
    //          "dealFee":"0",
    //          "activation_price":"0.065"      // stop price (if stop limit or stop market)
    //      }
    //
    // fetchClosedOrders
    //
    //      {
    //          "id":105531094719,
    //          "clientOrderId":"",
    //          "ctime":1659045334.550127,
    //          "ftime":1659045334.550127,
    //          "side":"buy",
    //          "amount":"5.9940059",           // cost in terms of quote for regular market orders, amount in terms or base for all other order types
    //          "price":"0",
    //          "type":"market",
    //          "takerFee":"0.001",
    //          "makerFee":"0",
    //          "dealFee":"0.0059375815",
    //          "dealStock":"85",               // base filled amount
    //          "dealMoney":"5.9375815",        // executed amount in quote
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "market")
    market = this.SafeMarket(marketId, market, "_")
    var symbol interface{} = GetValue(market, "symbol")
    var side interface{} = this.SafeString(order, "side")
    var filled interface{} = this.SafeString(order, "dealStock")
    var remaining interface{} = this.SafeString(order, "left")
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    if IsTrue(IsEqual(clientOrderId, "")) {
        clientOrderId = nil
    }
    var price interface{} = this.SafeString(order, "price")
    var triggerPrice interface{} = this.SafeNumber(order, "activation_price")
    var orderId interface{} = this.SafeString2(order, "orderId", "id")
    var typeVar interface{} = this.SafeString(order, "type")
    var orderType interface{} = this.ParseOrderType(typeVar)
    if IsTrue(IsEqual(orderType, "market")) {
        remaining = nil
    }
    var amount interface{} = this.SafeString(order, "amount")
    var cost interface{} = this.SafeString(order, "dealMoney")
    if IsTrue(IsTrue((IsEqual(side, "buy"))) && IsTrue((IsTrue((IsEqual(typeVar, "market"))) || IsTrue((IsEqual(typeVar, "stop market")))))) {
        amount = filled
    }
    var dealFee interface{} = this.SafeString(order, "dealFee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(dealFee, nil)) {
        fee = map[string]interface{} {
            "cost": this.ParseNumber(dealFee),
            "currency": GetValue(market, "quote"),
        }
    }
    var timestamp interface{} = this.SafeTimestamp2(order, "ctime", "timestamp")
    var lastTradeTimestamp interface{} = this.SafeTimestamp(order, "ftime")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": orderId,
        "symbol": symbol,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "timeInForce": nil,
        "postOnly": nil,
        "status": nil,
        "side": side,
        "price": price,
        "type": orderType,
        "triggerPrice": triggerPrice,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "average": nil,
        "cost": cost,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name whitebit#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.whitebit.com/private/http-trade-v4/#query-executed-order-deals
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *whitebit) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19848 := (<-this.LoadMarkets())
            PanicOnError(retRes19848)
            var request interface{} = map[string]interface{} {
                "orderId": ParseInt(id),
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 100))
            }
        
            response:= (<-this.V4PrivatePostTradeAccountOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "records": [
            //             {
            //                 "time": 1593342324.613711,
            //                 "fee": "0.00000419198",
            //                 "price": "0.00000701",
            //                 "amount": "598",
            //                 "id": 149156519, // trade id
            //                 "dealOrderId": 3134995325, // orderId
            //                 "clientOrderId": "customId11", // empty string if not specified
            //                 "role": 2, // 1 = maker, 2 = taker
            //                 "deal": "0.00419198"
            //             }
            //         ],
            //         "offset": 0,
            //         "limit": 100
            //     }
            //
            var data interface{} = this.SafeList(response, "records", []interface{}{})
        
            ch <- this.ParseTrades(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.whitebit.com/private/http-main-v4/#get-fiat-deposit-address
 * @see https://docs.whitebit.com/private/http-main-v4/#get-cryptocurrency-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *whitebit) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20318 := (<-this.LoadMarkets())
            PanicOnError(retRes20318)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "ticker": GetValue(currency, "id"),
            }
            var response interface{} = nil
            if IsTrue(this.IsFiat(code)) {
                var provider interface{} = this.SafeString(params, "provider")
                if IsTrue(IsEqual(provider, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires a provider when the ticker is fiat")))
                }
                AddElementToObject(request, "provider", provider)
                var amount interface{} = this.SafeNumber(params, "amount")
                if IsTrue(IsEqual(amount, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires an amount when the ticker is fiat")))
                }
                AddElementToObject(request, "amount", amount)
                var uniqueId interface{} = this.SafeValue(params, "uniqueId")
                if IsTrue(IsEqual(uniqueId, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires an uniqueId when the ticker is fiat")))
                }
                
        response = (<-this.V4PrivatePostMainAccountFiatDepositUrl(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V4PrivatePostMainAccountAddress(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // fiat
            //
            //     {
            //         "url": "https://someaddress.com"
            //     }
            //
            // crypto
            //
            //     {
            //         "account": {
            //             "address": "GDTSOI56XNVAKJNJBLJGRNZIVOCIZJRBIDKTWSCYEYNFAZEMBLN75RMN",
            //             "memo": "48565488244493"
            //         },
            //         "required": {
            //             "fixedFee": "0",
            //             "flexFee": {
            //                 "maxFee": "0",
            //                 "minFee": "0",
            //                 "percent": "0"
            //             },
            //             "maxAmount": "0",
            //             "minAmount": "1"
            //         }
            //     }
            //
            var url interface{} = this.SafeString(response, "url")
            var account interface{} = this.SafeValue(response, "account", map[string]interface{} {})
            var address interface{} = this.SafeString(account, "address", url)
            var tag interface{} = this.SafeString(account, "memo")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": nil,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#setLeverage
 * @description set the level of leverage for a market
 * @see https://docs.whitebit.com/private/http-trade-v4/#change-collateral-account-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *whitebit) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21078 := (<-this.LoadMarkets())
            PanicOnError(retRes21078)
            if IsTrue(!IsEqual(symbol, nil)) {
                panic(NotSupported(Add(this.Id, " setLeverage() does not allow to set per symbol")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 20)))) {
                panic(BadRequest(Add(this.Id, " setLeverage() leverage should be between 1 and 20")))
            }
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
        
                retRes211715 :=  (<-this.V4PrivatePostCollateralAccountLeverage(this.Extend(request, params)))
                PanicOnError(retRes211715)
                ch <- retRes211715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://docs.whitebit.com/private/http-main-v4/#transfer-between-main-and-trade-balances
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from - main, spot, collateral
 * @param {string} toAccount account to transfer to - main, spot, collateral
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *whitebit) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21368 := (<-this.LoadMarkets())
            PanicOnError(retRes21368)
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType")
            var fromAccountId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toAccountId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var amountString interface{} = this.CurrencyToPrecision(code, amount)
            var request interface{} = map[string]interface{} {
                "ticker": GetValue(currency, "id"),
                "amount": amountString,
                "from": fromAccountId,
                "to": toAccountId,
            }
        
            response:= (<-this.V4PrivatePostMainAccountTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    []
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    []
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "info": transfer,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": nil,
    }
}
/**
 * @method
 * @name whitebit#withdraw
 * @description make a withdrawal
 * @see https://docs.whitebit.com/private/http-main-v4/#create-withdraw-request
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *whitebit) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21858 := (<-this.LoadMarkets())
            PanicOnError(retRes21858)
            var currency interface{} = this.Currency(code) // check if it has canDeposit
            var request interface{} = map[string]interface{} {
                "ticker": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "address": address,
            }
            var uniqueId interface{} = this.SafeValue(params, "uniqueId")
            if IsTrue(IsEqual(uniqueId, nil)) {
                uniqueId = this.Uuid22()
            }
            AddElementToObject(request, "uniqueId", uniqueId)
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            if IsTrue(this.IsFiat(code)) {
                var provider interface{} = this.SafeValue(params, "provider")
                if IsTrue(IsEqual(provider, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a provider when the ticker is fiat")))
                }
                AddElementToObject(request, "provider", provider)
            }
        
            response:= (<-this.V4PrivatePostMainAccountWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // empty array with a success status
            // go to deposit/withdraw history and check you request status by uniqueId
            //
            //     []
            //
        ch <- this.Extend(map[string]interface{} {
                "id": uniqueId,
            }, this.ParseTransaction(response, currency))
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "3ApEASLcrQtZpg1TsssFgYF5V5YQJAKvuE",                                              // deposit address
    //         "uniqueId": null,                                                                             // unique Id of deposit
    //         "transactionId": "a6d71d69-2b17-4ad8-8b15-2d686c54a1a5",
    //         "createdAt": 1593437922,                                                                      // timestamp of deposit
    //         "currency": "Bitcoin",                                                                        // deposit currency
    //         "ticker": "BTC",                                                                              // deposit currency ticker
    //         "method": 1,                                                                                  // called method 1 - deposit, 2 - withdraw
    //         "amount": "0.0006",                                                                           // amount of deposit
    //         "description": "",                                                                            // deposit description
    //         "memo": "",                                                                                   // deposit memo
    //         "fee": "0",                                                                                   // deposit fee
    //         "status": 15,                                                                                 // transactions status
    //         "network": null,                                                                              // if currency is multinetwork
    //         "transactionHash": "a275a514013e4e0f927fd0d1bed215e7f6f2c4c6ce762836fe135ec22529d886",        // deposit transaction hash
    //         "details": {
    //             "partial": {                                                                              // details about partially successful withdrawals
    //                 "requestAmount": "50000",                                                             // requested withdrawal amount
    //                 "processedAmount": "39000",                                                           // processed withdrawal amount
    //                 "processedFee": "273",                                                                // fee for processed withdrawal amount
    //                 "normalizeTransaction": ""                                                            // deposit id
    //             }
    //         },
    //         "confirmations": {                                                                            // if transaction status == 15 you can see this object
    //             "actual": 1,                                                                              // current block confirmations
    //             "required": 2                                                                             // required block confirmation for successful deposit
    //         }
    //         "centralized": false,
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    currency = this.SafeCurrency(nil, currency)
    var address interface{} = this.SafeString(transaction, "address")
    var timestamp interface{} = this.SafeTimestamp(transaction, "createdAt")
    var currencyId interface{} = this.SafeString(transaction, "ticker")
    var status interface{} = this.SafeString(transaction, "status")
    var method interface{} = this.SafeString(transaction, "method")
    return map[string]interface{} {
        "id": this.SafeString(transaction, "uniqueId"),
        "txid": this.SafeString(transaction, "transactionId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.SafeString(transaction, "network"),
        "addressFrom": Ternary(IsTrue((IsEqual(method, "1"))), address, nil),
        "address": address,
        "addressTo": Ternary(IsTrue((IsEqual(method, "2"))), address, nil),
        "amount": this.SafeNumber(transaction, "amount"),
        "type": Ternary(IsTrue((IsEqual(method, "1"))), "deposit", "withdrawal"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "status": this.ParseTransactionStatus(status),
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": this.SafeString(transaction, "description"),
        "internal": nil,
        "fee": map[string]interface{} {
            "cost": this.SafeNumber(transaction, "fee"),
            "currency": this.SafeCurrencyCode(currencyId, currency),
        },
        "info": transaction,
    }
}
func  (this *whitebit) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "pending",
        "2": "pending",
        "3": "ok",
        "4": "canceled",
        "5": "pending",
        "6": "pending",
        "7": "ok",
        "9": "canceled",
        "10": "pending",
        "11": "pending",
        "12": "pending",
        "13": "pending",
        "14": "pending",
        "15": "pending",
        "16": "pending",
        "17": "pending",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name whitebit#fetchDeposit
 * @description fetch information on a deposit
 * @see https://docs.whitebit.com/private/http-main-v4/#get-depositwithdraw-history
 * @param {string} id deposit id
 * @param {string} code not used by whitebit fetchDeposit ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *whitebit) FetchDeposit(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23158 := (<-this.LoadMarkets())
            PanicOnError(retRes23158)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {
                "transactionMethod": 1,
                "uniqueId": id,
                "limit": 1,
                "offset": 0,
            }
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "ticker", GetValue(currency, "id"))
            }
        
            response:= (<-this.V4PrivatePostMainAccountHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "limit": 100,
            //         "offset": 0,
            //         "records": [
            //             {
            //                 "address": "3ApEASLcrQtZpg1TsssFgYF5V5YQJAKvuE",                                              // deposit address
            //                 "uniqueId": null,                                                                             // unique Id of deposit
            //                 "createdAt": 1593437922,                                                                      // timestamp of deposit
            //                 "currency": "Bitcoin",                                                                        // deposit currency
            //                 "ticker": "BTC",                                                                              // deposit currency ticker
            //                 "method": 1,                                                                                  // called method 1 - deposit, 2 - withdraw
            //                 "amount": "0.0006",                                                                           // amount of deposit
            //                 "description": "",                                                                            // deposit description
            //                 "memo": "",                                                                                   // deposit memo
            //                 "fee": "0",                                                                                   // deposit fee
            //                 "status": 15,                                                                                 // transactions status
            //                 "network": null,                                                                              // if currency is multinetwork
            //                 "transactionHash": "a275a514013e4e0f927fd0d1bed215e7f6f2c4c6ce762836fe135ec22529d886",        // deposit transaction hash
            //                 "details": {
            //                     "partial": {                                                                              // details about partially successful withdrawals
            //                         "requestAmount": "50000",                                                             // requested withdrawal amount
            //                         "processedAmount": "39000",                                                           // processed withdrawal amount
            //                         "processedFee": "273",                                                                // fee for processed withdrawal amount
            //                         "normalizeTransaction": ""                                                            // deposit id
            //                     }
            //                 },
            //                 "confirmations": {                                                                            // if transaction status == 15 you can see this object
            //                     "actual": 1,                                                                              // current block confirmations
            //                     "required": 2                                                                             // required block confirmation for successful deposit
            //                 }
            //             },
            //             {...},
            //         ],
            //         "total": 300                                                                                             // total number of  transactions, use this for calculating limit and offset'
            //     }
            //
            var records interface{} = this.SafeValue(response, "records", []interface{}{})
            var first interface{} = this.SafeDict(records, 0, map[string]interface{} {})
        
            ch <- this.ParseTransaction(first, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.whitebit.com/private/http-main-v4/#get-depositwithdraw-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *whitebit) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23828 := (<-this.LoadMarkets())
            PanicOnError(retRes23828)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {
                "transactionMethod": 1,
                "limit": 100,
                "offset": 0,
            }
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "ticker", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 100))
            }
        
            response:= (<-this.V4PrivatePostMainAccountHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "limit": 100,
            //         "offset": 0,
            //         "records": [
            //             {
            //                 "address": "3ApEASLcrQtZpg1TsssFgYF5V5YQJAKvuE",                                              // deposit address
            //                 "uniqueId": null,                                                                             // unique Id of deposit
            //                 "createdAt": 1593437922,                                                                      // timestamp of deposit
            //                 "currency": "Bitcoin",                                                                        // deposit currency
            //                 "ticker": "BTC",                                                                              // deposit currency ticker
            //                 "method": 1,                                                                                  // called method 1 - deposit, 2 - withdraw
            //                 "amount": "0.0006",                                                                           // amount of deposit
            //                 "description": "",                                                                            // deposit description
            //                 "memo": "",                                                                                   // deposit memo
            //                 "fee": "0",                                                                                   // deposit fee
            //                 "status": 15,                                                                                 // transactions status
            //                 "network": null,                                                                              // if currency is multinetwork
            //                 "transactionHash": "a275a514013e4e0f927fd0d1bed215e7f6f2c4c6ce762836fe135ec22529d886",        // deposit transaction hash
            //                 "details": {
            //                     "partial": {                                                                              // details about partially successful withdrawals
            //                         "requestAmount": "50000",                                                             // requested withdrawal amount
            //                         "processedAmount": "39000",                                                           // processed withdrawal amount
            //                         "processedFee": "273",                                                                // fee for processed withdrawal amount
            //                         "normalizeTransaction": ""                                                            // deposit id
            //                     }
            //                 },
            //                 "confirmations": {                                                                            // if transaction status == 15 you can see this object
            //                     "actual": 1,                                                                              // current block confirmations
            //                     "required": 2                                                                             // required block confirmation for successful deposit
            //                 }
            //             },
            //             {...},
            //         ],
            //         "total": 300                                                                                             // total number of  transactions, use this for calculating limit and offset'
            //     }
            //
            var records interface{} = this.SafeList(response, "records", []interface{}{})
        
            ch <- this.ParseTransactions(records, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://docs.whitebit.com/private/http-trade-v4/#open-positions
 * @param {string} code unified currency code
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func  (this *whitebit) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes24518 := (<-this.LoadMarkets())
            PanicOnError(retRes24518)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
        
            response:= (<-this.V4PrivatePostCollateralAccountPositionsOpen(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "positionId": 191823,
            //             "market": "BTC_USDT",
            //             "openDate": 1660340344.027163,
            //             "modifyDate": 1660340344.027163,
            //             "amount": "0.003075",
            //             "basePrice": "24149.24512",
            //             "liquidationPrice": "7059.02",
            //             "leverage": "5",
            //             "pnl": "-0.15",
            //             "pnlPercent": "-0.20",
            //             "margin": "14.86",
            //             "freeMargin": "44.99",
            //             "funding": "0",
            //             "unrealizedFunding": "0.0000307828284903",
            //             "liquidationState": null
            //         }
            //     ]
            //
            var interest interface{} = this.ParseBorrowInterests(response, market)
        
            ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "positionId": 191823,
    //         "market": "BTC_USDT",
    //         "openDate": 1660340344.027163,
    //         "modifyDate": 1660340344.027163,
    //         "amount": "0.003075",
    //         "basePrice": "24149.24512",
    //         "liquidationPrice": "7059.02",
    //         "leverage": "5",
    //         "pnl": "-0.15",
    //         "pnlPercent": "-0.20",
    //         "margin": "14.86",
    //         "freeMargin": "44.99",
    //         "funding": "0",
    //         "unrealizedFunding": "0.0000307828284903",
    //         "liquidationState": null
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var timestamp interface{} = this.SafeTimestamp(info, "modifyDate")
    return map[string]interface{} {
        "info": info,
        "symbol": symbol,
        "currency": "USDT",
        "interest": this.SafeNumber(info, "unrealizedFunding"),
        "interestRate": 0.00098,
        "amountBorrowed": this.SafeNumber(info, "amount"),
        "marginMode": "cross",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name whitebit#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.whitebit.com/public/http-v4/#available-futures-markets-list
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *whitebit) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25308 := (<-this.LoadMarkets())
            PanicOnError(retRes25308)
            symbol = this.Symbol(symbol)
        
            response:= (<-this.FetchFundingRates([]interface{}{symbol}, params))
            PanicOnError(response)
        
            ch <- this.SafeValue(response, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://docs.whitebit.com/public/http-v4/#available-futures-markets-list
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *whitebit) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes25468 := (<-this.LoadMarkets())
            PanicOnError(retRes25468)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V4PublicGetFutures(params))
            PanicOnError(response)
            //
            //    [
            //        {
            //            "name": "BTC_USDT",
            //            "type": "direct",
            //            "quanto_multiplier": "0.0001",
            //            "ref_discount_rate": "0",
            //            "order_price_deviate": "0.5",
            //            "maintenance_rate": "0.005",
            //            "mark_type": "index",
            //            "last_price": "38026",
            //            "mark_price": "37985.6",
            //            "index_price": "37954.92",
            //            "funding_rate_indicative": "0.000219",
            //            "mark_price_round": "0.01",
            //            "funding_offset": 0,
            //            "in_delisting": false,
            //            "risk_limit_base": "1000000",
            //            "interest_rate": "0.0003",
            //            "order_price_round": "0.1",
            //            "order_size_min": 1,
            //            "ref_rebate_rate": "0.2",
            //            "funding_interval": 28800,
            //            "risk_limit_step": "1000000",
            //            "leverage_min": "1",
            //            "leverage_max": "100",
            //            "risk_limit_max": "8000000",
            //            "maker_fee_rate": "-0.00025",
            //            "taker_fee_rate": "0.00075",
            //            "funding_rate": "0.002053",
            //            "order_size_max": 1000000,
            //            "funding_next_apply": 1610035200,
            //            "short_users": 977,
            //            "config_change_time": 1609899548,
            //            "trade_size": 28530850594,
            //            "position_size": 5223816,
            //            "long_users": 455,
            //            "funding_impact_value": "60000",
            //            "orders_limit": 50,
            //            "trade_id": 10851092,
            //            "orderbook_id": 2129638396
            //        }
            //    ]
            //
            var data interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseFundingRates(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "ticker_id":"ADA_PERP",
    //     "stock_currency":"ADA",
    //     "money_currency":"USDT",
    //     "last_price":"0.296708",
    //     "stock_volume":"7982130",
    //     "money_volume":"2345758.29189",
    //     "bid":"0.296608",
    //     "ask":"0.296758",
    //     "high":"0.298338",
    //     "low":"0.290171",
    //     "product_type":"Perpetual",
    //     "open_interest":"46533000",
    //     "index_price":"0.29659",
    //     "index_name":"Cardano",
    //     "index_currency":"ADA",
    //     "funding_rate":"0.0001",
    //     "next_funding_rate_timestamp":"1691193600000",
    //     "brackets":{
    //        "1":"0",
    //        "2":"0",
    //        "3":"0",
    //        "5":"0",
    //        "10":"0",
    //        "20":"0",
    //        "50":"-10000",
    //        "100":"-5000"
    //     },
    //     "max_leverage":"100"
    //  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "ticker_id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var markPrice interface{} = this.SafeNumber(contract, "markPrice")
    var indexPrice interface{} = this.SafeNumber(contract, "indexPrice")
    var interestRate interface{} = this.SafeNumber(contract, "interestRate")
    var fundingRate interface{} = this.SafeNumber(contract, "funding_rate")
    var fundingTime interface{} = this.SafeInteger(contract, "next_funding_rate_timestamp")
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": markPrice,
        "indexPrice": indexPrice,
        "interestRate": interestRate,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": fundingRate,
        "fundingTimestamp": fundingTime,
        "fundingDatetime": this.Iso8601(fundingTime),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
/**
 * @method
 * @name whitebit#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://docs.whitebit.com/private/http-trade-v4/#funding-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the starting timestamp in milliseconds
 * @param {int} [limit] the number of entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch funding history for
 * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *whitebit) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes26718 := (<-this.LoadMarkets())
            PanicOnError(retRes26718)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingHistory() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startDate", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", since)
            }
            requestparamsVariable := this.HandleUntilOption("endDate", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V4PrivatePostCollateralAccountFundingHistory(request))
            PanicOnError(response)
            //
            //     {
            //         "records": [
            //             {
            //                 "market": "BTC_PERP",
            //                 "fundingTime": "1708704000000",
            //                 "fundingRate": "0.00017674",
            //                 "fundingAmount": "-0.171053531892",
            //                 "positionAmount": "0.019",
            //                 "settlementPrice": "50938.2",
            //                 "rateCalculatedTime": "1708675200000"
            //             },
            //         ],
            //         "limit": 100,
            //         "offset": 0
            //     }
            //
            var data interface{} = this.SafeList(response, "records", []interface{}{})
        
            ch <- this.ParseFundingHistories(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseFundingHistory(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "BTC_PERP",
    //         "fundingTime": "1708704000000",
    //         "fundingRate": "0.00017674",
    //         "fundingAmount": "-0.171053531892",
    //         "positionAmount": "0.019",
    //         "settlementPrice": "50938.2",
    //         "rateCalculatedTime": "1708675200000"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "market")
    var timestamp interface{} = this.SafeInteger(contract, "fundingTime")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "code": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": nil,
        "amount": this.SafeNumber(contract, "fundingAmount"),
    }
}
func  (this *whitebit) ParseFundingHistories(contracts interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(contracts)); i++ {
        var contract interface{} = GetValue(contracts, i)
        AppendToArray(&result,this.ParseFundingHistory(contract, market))
    }
    var sorted interface{} = this.SortBy(result, "timestamp")
    return this.FilterBySinceLimit(sorted, since, limit)
}
/**
 * @method
 * @name whitebit#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://github.com/whitebit-exchange/api-docs/blob/main/pages/private/http-main-v4.md#get-depositwithdraw-history
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default = 50, Min: 1, Max: 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {number} [params.transactionMethod] Method. Example: 1 to display deposits / 2 to display withdraws. Do not send this parameter in order to receive both deposits and withdraws.
 * @param {string} [params.address] Can be used for filtering transactions by specific address or memo.
 * @param {string[]} [params.addresses] Can be used for filtering transactions by specific addresses or memos (max: 20).
 * @param {string} [params.uniqueId] Can be used for filtering transactions by specific unique id
 * @param {int} [params.offset] If you want the request to return entries starting from a particular line, you can use OFFSET clause to tell it where it should start. Default: 0, Min: 0, Max: 10000
 * @param {string[]} [params.status] Can be used for filtering transactions by status codes. Caution: You must use this parameter with appropriate transactionMethod and use valid status codes for this method. You can find them below. Example: "status": [3,7]
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *whitebit) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27638 := (<-this.LoadMarkets())
            PanicOnError(retRes27638)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "ticker", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 1000
            }
        
            response:= (<-this.V4PrivatePostMainAccountHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "limit": 100,
            //        "offset": 0,
            //        "records": [
            //            {
            //                "address": "3ApEASLcrQtZpg1TsssFgYF5V5YQJAKvuE",                                        // deposit address
            //                "uniqueId": null,                                                                       // unique Id of deposit
            //                "createdAt": 1593437922,                                                                // timestamp of deposit
            //                "currency": "Bitcoin",                                                                  // deposit currency
            //                "ticker": "BTC",                                                                        // deposit currency ticker
            //                "method": 1,                                                                            // called method 1 - deposit, 2 - withdraw
            //                "amount": "0.0006",                                                                     // amount of deposit
            //                "description": "",                                                                      // deposit description
            //                "memo": "",                                                                             // deposit memo
            //                "fee": "0",                                                                             // deposit fee
            //                "status": 15,                                                                           // transactions status
            //                "network": null,                                                                        // if currency is multinetwork
            //                "transactionHash": "a275a514013e4e0f927fd0d1bed215e7f6f2c4c6ce762836fe135ec22529d886",  // deposit transaction hash
            //                "transactionId": "5e112b38-9652-11ed-a1eb-0242ac120002",                                // transaction id
            //                "details": {
            //                    "partial": {                                                                        // details about partially successful withdrawals
            //                        "requestAmount": "50000",                                                       // requested withdrawal amount
            //                        "processedAmount": "39000",                                                     // processed withdrawal amount
            //                        "processedFee": "273",                                                          // fee for processed withdrawal amount
            //                        "normalizeTransaction": ""                                                      // deposit id
            //                    }
            //                },
            //                "confirmations": {                                                                      // if transaction status == 15 (Pending) you can see this object
            //                    "actual": 1,                                                                        // current block confirmations
            //                    "required": 2                                                                       // required block confirmation for successful deposit
            //                }
            //            },
            //            {...},
            //        ],
            //        "total": 300                                                                                    // total number of  transactions, use this for calculating limit and offset'
            //    }
            //
            var records interface{} = this.SafeList(response, "records")
        
            ch <- this.ParseTransactions(records, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://docs.whitebit.com/private/http-trade-v4/#convert-estimate
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} amount how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *whitebit) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes28288 := (<-this.LoadMarkets())
            PanicOnError(retRes28288)
            var fromCurrency interface{} = this.Currency(fromCode)
            var toCurrency interface{} = this.Currency(toCode)
            var request interface{} = map[string]interface{} {
                "from": fromCode,
                "to": toCode,
                "amount": this.NumberToString(amount),
                "direction": "from",
            }
        
            response:= (<-this.V4PrivatePostConvertEstimate(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "give": "4",
            //         "receive": "0.00004762",
            //         "rate": "0.0000119",
            //         "id": "1740889",
            //         "expireAt": 1741090147,
            //         "from": "USDT",
            //         "to": "BTC"
            //     }
            //
        ch <- this.ParseConversion(response, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#createConvertTrade
 * @description convert from one currency to another
 * @see https://docs.whitebit.com/private/http-trade-v4/#convert-confirm
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *whitebit) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes28658 := (<-this.LoadMarkets())
            PanicOnError(retRes28658)
            var fromCurrency interface{} = this.Currency(fromCode)
            var toCurrency interface{} = this.Currency(toCode)
            var request interface{} = map[string]interface{} {
                "quoteId": id,
            }
        
            response:= (<-this.V4PrivatePostConvertConfirm(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "finalGive": "4",
            //         "finalReceive": "0.00004772"
            //     }
            //
        ch <- this.ParseConversion(response, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://docs.whitebit.com/private/http-trade-v4/#convert-history
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve, default 20, max 200
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.until] the end time in ms
 * @param {string} [params.fromTicker] the currency that you sold and converted from
 * @param {string} [params.toTicker] the currency that you bought and converted into
 * @param {string} [params.quoteId] the quote id of the conversion
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *whitebit) FetchConvertTradeHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28978 := (<-this.LoadMarkets())
            PanicOnError(retRes28978)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                AddElementToObject(request, "fromTicker", code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                var start interface{} = this.ParseToInt(Divide(since, 1000))
                AddElementToObject(request, "from", this.NumberToString(start))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("to", request, params, 0.001);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V4PrivatePostConvertHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "records": [
            //             {
            //                 "id": "1741105",
            //                 "path": [
            //                     {
            //                         "from": "USDT",
            //                         "to": "BTC",
            //                         "rate": "0.00001193"
            //                     }
            //                 ],
            //                 "date": 1741090757,
            //                 "give": "4",
            //                 "receive": "0.00004772",
            //                 "rate": "0.00001193"
            //             }
            //         ],
            //         "total": 1,
            //         "limit": 100,
            //         "offset": 0
            //     }
            //
            var rows interface{} = this.SafeList(response, "records", []interface{}{})
        
            ch <- this.ParseConversions(rows, code, "fromCurrency", "toCurrency", since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchConvertQuote
    //
    //     {
    //         "give": "4",
    //         "receive": "0.00004762",
    //         "rate": "0.0000119",
    //         "id": "1740889",
    //         "expireAt": 1741090147,
    //         "from": "USDT",
    //         "to": "BTC"
    //     }
    //
    // createConvertTrade
    //
    //     {
    //         "finalGive": "4",
    //         "finalReceive": "0.00004772"
    //     }
    //
    // fetchConvertTradeHistory
    //
    //     {
    //         "id": "1741105",
    //         "path": [
    //             {
    //                 "from": "USDT",
    //                 "to": "BTC",
    //                 "rate": "0.00001193"
    //             }
    //         ],
    //         "date": 1741090757,
    //         "give": "4",
    //         "receive": "0.00004772",
    //         "rate": "0.00001193"
    //     }
    //
    fromCurrency := GetArg(optionalArgs, 0, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 1, nil)
    _ = toCurrency
    var path interface{} = this.SafeList(conversion, "path", []interface{}{})
    var first interface{} = this.SafeDict(path, 0, map[string]interface{} {})
    var fromPath interface{} = this.SafeString(first, "from")
    var toPath interface{} = this.SafeString(first, "to")
    var timestamp interface{} = this.SafeTimestamp2(conversion, "date", "expireAt")
    var fromCoin interface{} = this.SafeString(conversion, "from", fromPath)
    var fromCode interface{} = this.SafeCurrencyCode(fromCoin, fromCurrency)
    var toCoin interface{} = this.SafeString(conversion, "to", toPath)
    var toCode interface{} = this.SafeCurrencyCode(toCoin, toCurrency)
    return map[string]interface{} {
        "info": conversion,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(conversion, "id"),
        "fromCurrency": fromCode,
        "fromAmount": this.SafeNumber2(conversion, "give", "finalGive"),
        "toCurrency": toCode,
        "toAmount": this.SafeNumber2(conversion, "receive", "finalReceive"),
        "price": this.SafeNumber(conversion, "rate"),
        "fee": nil,
    }
}
/**
 * @method
 * @name whitebit#fetchPositionHistory
 * @description fetches historical positions
 * @see https://docs.whitebit.com/private/http-trade-v4/#positions-history
 * @param {string} symbol unified contract symbol
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum amount of records to fetch
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @param {int} [params.positionId] the id of the requested position
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *whitebit) FetchPositionHistory(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes30128 := (<-this.LoadMarkets())
            PanicOnError(retRes30128)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startDate", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", since)
            }
            requestparamsVariable := this.HandleUntilOption("endDate", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V4PrivatePostCollateralAccountPositionsHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "positionId": 479975679,
            //             "market": "BTC_PERP",
            //             "openDate": 1741941025.309887,
            //             "modifyDate": 1741941025.309887,
            //             "amount": "0.001",
            //             "basePrice": "82498.7",
            //             "realizedFunding": "0",
            //             "liquidationPrice": "0",
            //             "liquidationState": null,
            //             "orderDetail": {
            //                 "id": 1224727949521,
            //                 "tradeAmount": "0.001",
            //                 "price": "82498.7",
            //                 "tradeFee": "0.028874545",
            //                 "fundingFee": "0",
            //                 "realizedPnl": "-0.028874545"
            //             }
            //         }
            //     ]
            //
            var positions interface{} = this.ParsePositions(response)
        
            ch <- this.FilterBySymbolSinceLimit(positions, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchPositions
 * @description fetch all open positions
 * @see https://docs.whitebit.com/private/http-trade-v4/#open-positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *whitebit) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30628 := (<-this.LoadMarkets())
            PanicOnError(retRes30628)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V4PrivatePostCollateralAccountPositionsOpen(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "positionId": 479975679,
            //             "market": "BTC_PERP",
            //             "openDate": 1741941025.3098869,
            //             "modifyDate": 1741941025.3098869,
            //             "amount": "0.001",
            //             "basePrice": "82498.7",
            //             "liquidationPrice": "70177.2",
            //             "pnl": "0",
            //             "pnlPercent": "0.00",
            //             "margin": "4.2",
            //             "freeMargin": "9.9",
            //             "funding": "0",
            //             "unrealizedFunding": "0",
            //             "liquidationState": null,
            //             "tpsl": null
            //         }
            //     ]
            //
        ch <- this.ParsePositions(response, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://docs.whitebit.com/private/http-trade-v4/#open-positions
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *whitebit) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes30998 := (<-this.LoadMarkets())
            PanicOnError(retRes30998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V4PrivatePostCollateralAccountPositionsOpen(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "positionId": 479975679,
            //             "market": "BTC_PERP",
            //             "openDate": 1741941025.3098869,
            //             "modifyDate": 1741941025.3098869,
            //             "amount": "0.001",
            //             "basePrice": "82498.7",
            //             "liquidationPrice": "70177.2",
            //             "pnl": "0",
            //             "pnlPercent": "0.00",
            //             "margin": "4.2",
            //             "freeMargin": "9.9",
            //             "funding": "0",
            //             "unrealizedFunding": "0",
            //             "liquidationState": null,
            //             "tpsl": null
            //         }
            //     ]
            //
            var data interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParsePosition(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *whitebit) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchPosition, fetchPositions
    //
    //     {
    //         "positionId": 479975679,
    //         "market": "BTC_PERP",
    //         "openDate": 1741941025.3098869,
    //         "modifyDate": 1741941025.3098869,
    //         "amount": "0.001",
    //         "basePrice": "82498.7",
    //         "liquidationPrice": "70177.2",
    //         "pnl": "0",
    //         "pnlPercent": "0.00",
    //         "margin": "4.2",
    //         "freeMargin": "9.9",
    //         "funding": "0",
    //         "unrealizedFunding": "0",
    //         "liquidationState": null,
    //         "tpsl": null
    //     }
    //
    // fetchPositionHistory
    //
    //     {
    //         "positionId": 479975679,
    //         "market": "BTC_PERP",
    //         "openDate": 1741941025.309887,
    //         "modifyDate": 1741941025.309887,
    //         "amount": "0.001",
    //         "basePrice": "82498.7",
    //         "realizedFunding": "0",
    //         "liquidationPrice": "0",
    //         "liquidationState": null,
    //         "orderDetail": {
    //             "id": 1224727949521,
    //             "tradeAmount": "0.001",
    //             "price": "82498.7",
    //             "tradeFee": "0.028874545",
    //             "fundingFee": "0",
    //             "realizedPnl": "-0.028874545"
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "market")
    var timestamp interface{} = this.SafeTimestamp(position, "openDate")
    var tpsl interface{} = this.SafeDict(position, "tpsl", map[string]interface{} {})
    var orderDetail interface{} = this.SafeDict(position, "orderDetail", map[string]interface{} {})
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "positionId"),
        "symbol": this.SafeSymbol(marketId, market),
        "notional": nil,
        "marginMode": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidationPrice"),
        "entryPrice": this.SafeNumber(position, "basePrice"),
        "unrealizedPnl": this.SafeNumber(position, "pnl"),
        "realizedPnl": this.SafeNumber(orderDetail, "realizedPnl"),
        "percentage": this.SafeNumber(position, "pnlPercent"),
        "contracts": nil,
        "contractSize": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "side": nil,
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": this.SafeTimestamp(position, "modifyDate"),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": this.SafeNumber(position, "margin"),
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
        "stopLossPrice": this.SafeNumber(tpsl, "stopLoss"),
        "takeProfitPrice": this.SafeNumber(tpsl, "takeProfit"),
    })
}
func  (this *whitebit) IsFiat(currency interface{}) interface{}  {
    var fiatCurrencies interface{} = this.SafeValue(this.Options, "fiatCurrencies", []interface{}{})
    return this.InArray(currency, fiatCurrencies)
}
func  (this *whitebit) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *whitebit) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var version interface{} = this.SafeValue(api, 0)
    var accessibility interface{} = this.SafeValue(api, 1)
    var pathWithParams interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(GetValue(this.Urls, "api"), version), accessibility), pathWithParams)
    if IsTrue(IsEqual(accessibility, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    }
    if IsTrue(IsEqual(accessibility, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var secret interface{} = this.Encode(this.Secret)
        var request interface{} = Add(Add(Add(Add("/", "api"), "/"), version), pathWithParams)
        body = this.Json(this.Extend(map[string]interface{} {
            "request": request,
            "nonce": nonce,
        }, params))
        var payload interface{} = this.StringToBase64(body)
        var signature interface{} = this.Hmac(this.Encode(payload), secret, sha512)
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "X-TXC-APIKEY": this.ApiKey,
            "X-TXC-PAYLOAD": payload,
            "X-TXC-SIGNATURE": signature,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *whitebit) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsTrue((IsEqual(code, 418))) || IsTrue((IsEqual(code, 429)))) {
        panic(DDoSProtection(Add(Add(Add(Add(Add(Add(this.Id, " "), ToString(code)), " "), reason), " "), body)))
    }
    if IsTrue(IsEqual(code, 404)) {
        panic(ExchangeError(Add(Add(Add(this.Id, " "), ToString(code)), " endpoint not found")))
    }
    if IsTrue(!IsEqual(response, nil)) {
        // For cases where we have a meaningful status
        // {"response":null,"status":422,"errors":{"orderId":["Finished order id 435453454535 not found on your account"]},"notification":null,"warning":"Finished order id 435453454535 not found on your account","_token":null}
        var status interface{} = this.SafeString(response, "status")
        var errors interface{} = this.SafeValue(response, "errors")
        // {"code":10,"message":"Unauthorized request."}
        var message interface{} = this.SafeString(response, "message")
        // For these cases where we have a generic code variable error key
        // {"code":0,"message":"Validation failed","errors":{"amount":["Amount must be greater than 0"]}}
        var codeNew interface{} = this.SafeInteger(response, "code")
        var hasErrorStatus interface{} = IsTrue(IsTrue(!IsEqual(status, nil)) && IsTrue(!IsEqual(status, "200"))) && IsTrue(!IsEqual(errors, nil))
        if IsTrue(IsTrue(hasErrorStatus) || IsTrue(!IsEqual(codeNew, nil))) {
            var feedback interface{} = Add(Add(this.Id, " "), body)
            var errorInfo interface{} = message
            if IsTrue(hasErrorStatus) {
                errorInfo = status
            } else {
                var errorObject interface{} = this.SafeDict(response, "errors", map[string]interface{} {})
                var errorKeys interface{} = ObjectKeys(errorObject)
                var errorsLength interface{} =                 GetArrayLength(errorKeys)
                if IsTrue(IsGreaterThan(errorsLength, 0)) {
                    var errorKey interface{} = GetValue(errorKeys, 0)
                    var errorMessageArray interface{} = this.SafeValue(errorObject, errorKey, []interface{}{})
                    var errorMessageLength interface{} =                     GetArrayLength(errorMessageArray)
                    errorInfo = Ternary(IsTrue((IsGreaterThan(errorMessageLength, 0))), GetValue(errorMessageArray, 0), body)
                }
            }
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorInfo, feedback)
            this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}


func (this *whitebit) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
