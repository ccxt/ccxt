package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type indodax struct {
    Exchange

}

func NewIndodaxCore() indodax {
   p := indodax{}
   setDefaults(&p)
   return p
}

func  (this *indodax) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "indodax",
        "name": "INDODAX",
        "countries": []interface{}{"ID"},
        "rateLimit": 50,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": false,
            "fetchDepositAddress": "emulated",
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFee": true,
            "fetchTransactionFees": false,
            "fetchTransactions": "emulated",
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "version": "2.0",
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg",
            "api": map[string]interface{} {
                "public": "https://indodax.com",
                "private": "https://indodax.com/tapi",
            },
            "www": "https://www.indodax.com",
            "doc": "https://github.com/btcid/indodax-official-api-docs",
            "referral": "https://indodax.com/ref/testbitcoincoid/1",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/server_time": 5,
                    "api/pairs": 5,
                    "api/price_increments": 5,
                    "api/summaries": 5,
                    "api/ticker/{pair}": 5,
                    "api/ticker_all": 5,
                    "api/trades/{pair}": 5,
                    "api/depth/{pair}": 5,
                    "tradingview/history_v2": 5,
                },
            },
            "private": map[string]interface{} {
                "post": map[string]interface{} {
                    "getInfo": 4,
                    "transHistory": 4,
                    "trade": 1,
                    "tradeHistory": 4,
                    "openOrders": 4,
                    "orderHistory": 4,
                    "getOrder": 4,
                    "cancelOrder": 4,
                    "withdrawFee": 4,
                    "withdrawCoin": 4,
                    "listDownline": 4,
                    "checkDownline": 4,
                    "createVoucher": 4,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": 0,
                "taker": 0.003,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "invalid_pair": BadSymbol,
                "Insufficient balance.": InsufficientFunds,
                "invalid order.": OrderNotFound,
                "Invalid credentials. API not found or session has expired.": AuthenticationError,
                "Invalid credentials. Bad sign.": AuthenticationError,
            },
            "broad": map[string]interface{} {
                "Minimum price": InvalidOrder,
                "Minimum order": InvalidOrder,
            },
        },
        "options": map[string]interface{} {
            "recvWindow": Multiply(5, 1000),
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "networks": map[string]interface{} {
                "XLM": "Stellar Token",
                "BSC": "bep20",
                "TRC20": "trc20",
                "MATIC": "polygon",
            },
            "timeframes": map[string]interface{} {
                "1m": "1",
                "15m": "15",
                "30m": "30",
                "1h": "60",
                "4h": "240",
                "1d": "1D",
                "3d": "3D",
                "1w": "1W",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "STR": "XLM",
            "BCHABC": "BCH",
            "BCHSV": "BSV",
            "DRK": "DASH",
            "NEM": "XEM",
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *indodax) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
/**
 * @method
 * @name indodax#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *indodax) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiServerTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "timezone": "UTC",
            //         "server_time": 1571205969552
            //     }
            //
        ch <- this.SafeInteger(response, "server_time")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchMarkets
 * @description retrieves data on all markets for indodax
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#pairs
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *indodax) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiPairs(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "btcidr",
            //             "symbol": "BTCIDR",
            //             "base_currency": "idr",
            //             "traded_currency": "btc",
            //             "traded_currency_unit": "BTC",
            //             "description": "BTC/IDR",
            //             "ticker_id": "btc_idr",
            //             "volume_precision": 0,
            //             "price_precision": 1000,
            //             "price_round": 8,
            //             "pricescale": 1000,
            //             "trade_min_base_currency": 10000,
            //             "trade_min_traded_currency": 0.00007457,
            //             "has_memo": false,
            //             "memo_name": false,
            //             "has_payment_id": false,
            //             "trade_fee_percent": 0.3,
            //             "url_logo": "https://indodax.com/v2/logo/svg/color/btc.svg",
            //             "url_logo_png": "https://indodax.com/v2/logo/png/color/btc.png",
            //             "is_maintenance": 0
            //         }
            //     ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var market interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(market, "ticker_id")
                var baseId interface{} = this.SafeString(market, "traded_currency")
                var quoteId interface{} = this.SafeString(market, "base_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var isMaintenance interface{} = this.SafeInteger(market, "is_maintenance")
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": Ternary(IsTrue(isMaintenance), false, true),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": this.SafeNumber(market, "trade_fee_percent"),
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "percentage": true,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber("1e-8"),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_round"))),
                        "cost": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "volume_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "trade_min_traded_currency"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "trade_min_base_currency"),
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(response, "return", map[string]interface{} {})
    var free interface{} = this.SafeValue(balances, "balance", map[string]interface{} {})
    var used interface{} = this.SafeValue(balances, "balance_hold", map[string]interface{} {})
    var timestamp interface{} = this.SafeTimestamp(balances, "server_time")
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var currencyIds interface{} = ObjectKeys(free)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(free, currencyId))
        AddElementToObject(account, "used", this.SafeString(used, currencyId))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name indodax#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#get-info-endpoint
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *indodax) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4298 := (<-this.LoadMarkets())
            PanicOnError(retRes4298)
        
            response:= (<-this.PrivatePostGetInfo(params))
            PanicOnError(response)
        
                //
            //     {
            //         "success":1,
            //         "return":{
            //             "server_time":1619562628,
            //             "balance":{
            //                 "idr":167,
            //                 "btc":"0.00000000",
            //                 "1inch":"0.00000000",
            //             },
            //             "balance_hold":{
            //                 "idr":0,
            //                 "btc":"0.00000000",
            //                 "1inch":"0.00000000",
            //             },
            //             "address":{
            //                 "btc":"1KMntgzvU7iTSgMBWc11nVuJjAyfW3qJyk",
            //                 "1inch":"0x1106c8bb3172625e1f411c221be49161dac19355",
            //                 "xrp":"rwWr7KUZ3ZFwzgaDGjKBysADByzxvohQ3C",
            //                 "zrx":"0x1106c8bb3172625e1f411c221be49161dac19355"
            //             },
            //             "user_id":"276011",
            //             "name":"",
            //             "email":"testbitcoincoid@mailforspam.com",
            //             "profile_picture":null,
            //             "verification_status":"unverified",
            //             "gauth_enable":true
            //         }
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *indodax) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4758 := (<-this.LoadMarkets())
            PanicOnError(retRes4758)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": Add(GetValue(market, "base"), GetValue(market, "quote")),
            }
        
            orderbook:= (<-this.PublicGetApiDepthPair(this.Extend(request, params)))
            PanicOnError(orderbook)
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "buy", "sell")
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "high":"0.01951",
    //         "low":"0.01877",
    //         "vol_eth":"39.38839319",
    //         "vol_btc":"0.75320886",
    //         "last":"0.01896",
    //         "buy":"0.01896",
    //         "sell":"0.019",
    //         "server_time":1565248908
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeTimestamp(ticker, "server_time")
    var baseVolume interface{} = Add("vol_", ToLower(GetValue(market, "baseId")))
    var quoteVolume interface{} = Add("vol_", ToLower(GetValue(market, "quoteId")))
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, baseVolume),
        "quoteVolume": this.SafeString(ticker, quoteVolume),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name indodax#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *indodax) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5368 := (<-this.LoadMarkets())
            PanicOnError(retRes5368)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": Add(GetValue(market, "base"), GetValue(market, "quote")),
            }
        
            response:= (<-this.PublicGetApiTickerPair(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ticker": {
            //             "high":"0.01951",
            //             "low":"0.01877",
            //             "vol_eth":"39.38839319",
            //             "vol_btc":"0.75320886",
            //             "last":"0.01896",
            //             "buy":"0.01896",
            //             "sell":"0.019",
            //             "server_time":1565248908
            //         }
            //     }
            //
            var ticker interface{} = this.SafeDict(response, "ticker", map[string]interface{} {})
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#ticker-all
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *indodax) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5708 := (<-this.LoadMarkets())
            PanicOnError(retRes5708)
            //
            // {
            //     "tickers": {
            //         "btc_idr": {
            //             "high": "120009000",
            //             "low": "116735000",
            //             "vol_btc": "218.13777777",
            //             "vol_idr": "25800033297",
            //             "last": "117088000",
            //             "buy": "117002000",
            //             "sell": "117078000",
            //             "server_time": 1571207881
            //         }
            //     }
            // }
            //
        
            response:= (<-this.PublicGetApiTickerAll(params))
            PanicOnError(response)
            var tickers interface{} = this.SafeDict(response, "tickers", map[string]interface{} {})
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp(trade, "date")
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "tid"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeSymbol(nil, market),
        "type": nil,
        "side": this.SafeString(trade, "type"),
        "order": nil,
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "amount"),
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name indodax#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Public-RestAPI.md#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *indodax) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6238 := (<-this.LoadMarkets())
            PanicOnError(retRes6238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": Add(GetValue(market, "base"), GetValue(market, "quote")),
            }
        
            response:= (<-this.PublicGetApiTradesPair(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "Time": 1708416900,
    //         "Open": 51707.52,
    //         "High": 51707.52,
    //         "Low": 51707.52,
    //         "Close": 51707.52,
    //         "Volume": "0"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "Time"), this.SafeNumber(ohlcv, "Open"), this.SafeNumber(ohlcv, "High"), this.SafeNumber(ohlcv, "Low"), this.SafeNumber(ohlcv, "Close"), this.SafeNumber(ohlcv, "Volume")}
}
/**
 * @method
 * @name indodax#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *indodax) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6668 := (<-this.LoadMarkets())
            PanicOnError(retRes6668)
            var market interface{} = this.Market(symbol)
            var timeframes interface{} = GetValue(this.Options, "timeframes")
            var selectedTimeframe interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var now interface{} = this.Seconds()
            var until interface{} = this.SafeInteger(params, "until", now)
            params = this.Omit(params, []interface{}{"until"})
            var request interface{} = map[string]interface{} {
                "to": until,
                "tf": selectedTimeframe,
                "symbol": Add(GetValue(market, "base"), GetValue(market, "quote")),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 1000
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", MathFloor(Divide(since, 1000)))
            } else {
                var duration interface{} = this.ParseTimeframe(timeframe)
                AddElementToObject(request, "from", Subtract(Subtract(now, Multiply(limit, duration)), 1))
            }
        
            response:= (<-this.PublicGetTradingviewHistoryV2(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "Time": 1708416900,
            //             "Open": 51707.52,
            //             "High": 51707.52,
            //             "Low": 51707.52,
            //             "Close": 51707.52,
            //             "Volume": "0"
            //         }
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "open": "open",
        "filled": "closed",
        "cancelled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *indodax) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "order_id": "12345",
    //         "submit_time": "1392228122",
    //         "price": "8000000",
    //         "type": "sell",
    //         "order_ltc": "100000000",
    //         "remain_ltc": "100000000"
    //     }
    //
    // market closed orders - note that the price is very high
    // and does not reflect actual price the order executed at
    //
    //     {
    //       "order_id": "49326856",
    //       "type": "sell",
    //       "price": "1000000000",
    //       "submit_time": "1618314671",
    //       "finish_time": "1618314671",
    //       "status": "filled",
    //       "order_xrp": "30.45000000",
    //       "remain_xrp": "0.00000000"
    //     }
    //
    // cancelOrder
    //
    //    {
    //        "order_id": 666883,
    //        "client_order_id": "clientx-sj82ks82j",
    //        "type": "sell",
    //        "pair": "btc_idr",
    //        "balance": {
    //            "idr": "33605800",
    //            "btc": "0.00000000",
    //            ...
    //            "frozen_idr": "0",
    //            "frozen_btc": "0.00000000",
    //            ...
    //        }
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = nil
    if IsTrue(InOp(order, "type")) {
        side = GetValue(order, "type")
    }
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status", "open"))
    var symbol interface{} = nil
    var cost interface{} = nil
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = nil
    var remaining interface{} = nil
    var marketId interface{} = this.SafeString(order, "pair")
    market = this.SafeMarket(marketId, market)
    if IsTrue(!IsEqual(market, nil)) {
        symbol = GetValue(market, "symbol")
        var quoteId interface{} = GetValue(market, "quoteId")
        var baseId interface{} = GetValue(market, "baseId")
        if IsTrue(IsTrue((IsEqual(GetValue(market, "quoteId"), "idr"))) && IsTrue((InOp(order, "order_rp")))) {
            quoteId = "rp"
        }
        if IsTrue(IsTrue((IsEqual(GetValue(market, "baseId"), "idr"))) && IsTrue((InOp(order, "remain_rp")))) {
            baseId = "rp"
        }
        cost = this.SafeString(order, Add("order_", quoteId))
        if !IsTrue(cost) {
            amount = this.SafeString(order, Add("order_", baseId))
            remaining = this.SafeString(order, Add("remain_", baseId))
        }
    }
    var timestamp interface{} = this.SafeInteger(order, "submit_time")
    var fee interface{} = nil
    var id interface{} = this.SafeString(order, "order_id")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": "limit",
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": cost,
        "average": nil,
        "amount": amount,
        "filled": nil,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": nil,
    })
}
/**
 * @method
 * @name indodax#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#get-order-endpoints
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *indodax) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes8248 := (<-this.LoadMarkets())
            PanicOnError(retRes8248)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "order_id": id,
            }
        
            response:= (<-this.PrivatePostGetOrder(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = GetValue(response, "return")
            var order interface{} = this.ParseOrder(this.Extend(map[string]interface{} {
                "id": id,
            }, GetValue(orders, "order")), market)
            AddElementToObject(order, "info", response)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#open-orders-endpoints
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *indodax) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8498 := (<-this.LoadMarkets())
            PanicOnError(retRes8498)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            var rawOrders interface{} = GetValue(GetValue(response, "return"), "orders")
            // { success: 1, return: { orders: null }} if no orders
            if !IsTrue(rawOrders) {
        
                ch <- []interface{}{}
                return nil
            }
            // { success: 1, return: { orders: [ ... objects ] }} for orders fetched by symbol
            if IsTrue(!IsEqual(symbol, nil)) {
        
                ch <- this.ParseOrders(rawOrders, market, since, limit)
                return nil
            }
            // { success: 1, return: { orders: { marketid: [ ... objects ] }}} if all orders are fetched
            var marketIds interface{} = ObjectKeys(rawOrders)
            var exchangeOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var marketOrders interface{} = GetValue(rawOrders, marketId)
                market = this.SafeMarket(marketId)
                var parsedOrders interface{} = this.ParseOrders(marketOrders, market, since, limit)
                exchangeOrders = this.ArrayConcat(exchangeOrders, parsedOrders)
            }
        
            ch <- exchangeOrders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *indodax) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrders() requires a symbol argument")))
            }
        
            retRes8948 := (<-this.LoadMarkets())
            PanicOnError(retRes8948)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = this.ParseOrders(GetValue(GetValue(response, "return"), "orders"), market)
            orders = this.FilterBy(orders, "status", "closed")
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#createOrder
 * @description create a trade order
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#trade-endpoints
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *indodax) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9198 := (<-this.LoadMarkets())
            PanicOnError(retRes9198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "type": side,
                "price": price,
            }
            var priceIsRequired interface{} = false
            var quantityIsRequired interface{} = false
            if IsTrue(IsEqual(typeVar, "market")) {
                if IsTrue(IsEqual(side, "buy")) {
                    var quoteAmount interface{} = nil
                    var cost interface{} = this.SafeNumber(params, "cost")
                    params = this.Omit(params, "cost")
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else {
                        if IsTrue(IsEqual(price, nil)) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price).")))
                        }
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var costRequest interface{} = Precise.StringMul(amountString, priceString)
                        quoteAmount = this.CostToPrecision(symbol, costRequest)
                    }
                    AddElementToObject(request, GetValue(market, "quoteId"), quoteAmount)
                } else {
                    quantityIsRequired = true
                }
            } else if IsTrue(IsEqual(typeVar, "limit")) {
                priceIsRequired = true
                quantityIsRequired = true
                if IsTrue(IsEqual(side, "buy")) {
                    AddElementToObject(request, GetValue(market, "quoteId"), this.ParseToNumeric(Precise.StringMul(this.NumberToString(amount), this.NumberToString(price))))
                }
            }
            if IsTrue(priceIsRequired) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
                }
                AddElementToObject(request, "price", price)
            }
            if IsTrue(quantityIsRequired) {
                AddElementToObject(request, GetValue(market, "baseId"), this.AmountToPrecision(symbol, amount))
            }
        
            result:= (<-this.PrivatePostTrade(this.Extend(request, params)))
            PanicOnError(result)
            var data interface{} = this.SafeValue(result, "return", map[string]interface{} {})
            var id interface{} = this.SafeString(data, "order_id")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": result,
                "id": id,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#cancelOrder
 * @description cancels an open order
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#cancel-order-endpoints
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *indodax) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
            var side interface{} = this.SafeValue(params, "side")
            if IsTrue(IsEqual(side, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires an extra \"side\" param")))
            }
        
            retRes9918 := (<-this.LoadMarkets())
            PanicOnError(retRes9918)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "pair": GetValue(market, "id"),
                "type": side,
            }
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": 1,
            //        "return": {
            //            "order_id": 666883,
            //            "client_order_id": "clientx-sj82ks82j",
            //            "type": "sell",
            //            "pair": "btc_idr",
            //            "balance": {
            //                "idr": "33605800",
            //                "btc": "0.00000000",
            //                ...
            //                "frozen_idr": "0",
            //                "frozen_btc": "0.00000000",
            //                ...
            //            }
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "return")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchTransactionFee
 * @description fetch the fee for a transaction
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#withdraw-fee-endpoints
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *indodax) FetchTransactionFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10328 := (<-this.LoadMarkets())
            PanicOnError(retRes10328)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivatePostWithdrawFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": 1,
            //         "return": {
            //             "server_time": 1607923272,
            //             "withdraw_fee": 0.005,
            //             "currency": "eth"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "return", map[string]interface{} {})
            var currencyId interface{} = this.SafeString(data, "currency")
        
            ch <- map[string]interface{} {
                "info": response,
                "rate": this.SafeNumber(data, "withdraw_fee"),
                "currency": this.SafeCurrencyCode(currencyId, currency),
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#transaction-history-endpoints
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *indodax) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10698 := (<-this.LoadMarkets())
            PanicOnError(retRes10698)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                var startTime interface{} = Slice(this.Iso8601(since), 0, 10)
                AddElementToObject(request, "start", startTime)
                AddElementToObject(request, "end", Slice(this.Iso8601(this.Milliseconds()), 0, 10))
            }
        
            response:= (<-this.PrivatePostTransHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": 1,
            //         "return": {
            //             "withdraw": {
            //                 "idr": [
            //                     {
            //                         "status": "success",
            //                         "type": "coupon",
            //                         "rp": "115205",
            //                         "fee": "500",
            //                         "amount": "114705",
            //                         "submit_time": "1539844166",
            //                         "success_time": "1539844189",
            //                         "withdraw_id": "1783717",
            //                         "tx": "BTC-IDR-RDTVVO2P-ETD0EVAW-VTNZGMIR-HTNTUAPI-84ULM9OI",
            //                         "sender": "boris",
            //                         "used_by": "viginia88"
            //                     },
            //                     ...
            //                 ],
            //                 "btc": [],
            //                 "abyss": [],
            //                 ...
            //             },
            //             "deposit": {
            //                 "idr": [
            //                     {
            //                         "status": "success",
            //                         "type": "duitku",
            //                         "rp": "393000",
            //                         "fee": "5895",
            //                         "amount": "387105",
            //                         "submit_time": "1576555012",
            //                         "success_time": "1576555012",
            //                         "deposit_id": "3395438",
            //                         "tx": "Duitku OVO Settlement"
            //                     },
            //                     ...
            //                 ],
            //                 "btc": [
            //                     {
            //                         "status": "success",
            //                         "btc": "0.00118769",
            //                         "amount": "0.00118769",
            //                         "success_time": "1539529208",
            //                         "deposit_id": "3602369",
            //                         "tx": "c816aeb35a5b42f389970325a32aff69bb6b2126784dcda8f23b9dd9570d6573"
            //                     },
            //                     ...
            //                 ],
            //                 "abyss": [],
            //                 ...
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "return", map[string]interface{} {})
            var withdraw interface{} = this.SafeValue(data, "withdraw", map[string]interface{} {})
            var deposit interface{} = this.SafeValue(data, "deposit", map[string]interface{} {})
            var transactions interface{} = []interface{}{}
            var currency interface{} = nil
            if IsTrue(IsEqual(code, nil)) {
                var keys interface{} = ObjectKeys(withdraw)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    var key interface{} = GetValue(keys, i)
                    transactions = this.ArrayConcat(transactions, GetValue(withdraw, key))
                }
                keys = ObjectKeys(deposit)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    var key interface{} = GetValue(keys, i)
                    transactions = this.ArrayConcat(transactions, GetValue(deposit, key))
                }
            } else {
                currency = this.Currency(code)
                var withdraws interface{} = this.SafeValue(withdraw, GetValue(currency, "id"), []interface{}{})
                var deposits interface{} = this.SafeValue(deposit, GetValue(currency, "id"), []interface{}{})
                transactions = this.ArrayConcat(withdraws, deposits)
            }
        
            ch <- this.ParseTransactions(transactions, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name indodax#withdraw
 * @description make a withdrawal
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#withdraw-coin-endpoints
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *indodax) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes11748 := (<-this.LoadMarkets())
            PanicOnError(retRes11748)
            var currency interface{} = this.Currency(code)
            // Custom string you need to provide to identify each withdrawal.
            // Will be passed to callback URL (assigned via website to the API key)
            // so your system can identify the request and confirm it.
            // Alphanumeric, max length 255.
            var requestId interface{} = this.Milliseconds()
            // Alternatively:
            // let requestId = this.uuid ();
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "withdraw_amount": amount,
                "withdraw_address": address,
                "request_id": ToString(requestId),
            }
            if IsTrue(tag) {
                AddElementToObject(request, "withdraw_memo", tag)
            }
        
            response:= (<-this.PrivatePostWithdrawCoin(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": 1,
            //         "status": "approved",
            //         "withdraw_currency": "xrp",
            //         "withdraw_address": "rwWr7KUZ3ZFwzgaDGjKBysADByzxvohQ3C",
            //         "withdraw_amount": "10000.00000000",
            //         "fee": "2.00000000",
            //         "amount_after_fee": "9998.00000000",
            //         "submit_time": "1509469200",
            //         "withdraw_id": "xrp-12345",
            //         "txid": "",
            //         "withdraw_memo": "123123"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *indodax) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "success": 1,
    //         "status": "approved",
    //         "withdraw_currency": "xrp",
    //         "withdraw_address": "rwWr7KUZ3ZFwzgaDGjKBysADByzxvohQ3C",
    //         "withdraw_amount": "10000.00000000",
    //         "fee": "2.00000000",
    //         "amount_after_fee": "9998.00000000",
    //         "submit_time": "1509469200",
    //         "withdraw_id": "xrp-12345",
    //         "txid": "",
    //         "withdraw_memo": "123123"
    //     }
    //
    // transHistory
    //
    //     {
    //         "status": "success",
    //         "type": "coupon",
    //         "rp": "115205",
    //         "fee": "500",
    //         "amount": "114705",
    //         "submit_time": "1539844166",
    //         "success_time": "1539844189",
    //         "withdraw_id": "1783717",
    //         "tx": "BTC-IDR-RDTVVO2P-ETD0EVAW-VTNZGMIR-HTNTUAPI-84ULM9OI",
    //         "sender": "boris",
    //         "used_by": "viginia88"
    //     }
    //
    //     {
    //         "status": "success",
    //         "btc": "0.00118769",
    //         "amount": "0.00118769",
    //         "success_time": "1539529208",
    //         "deposit_id": "3602369",
    //         "tx": "c816aeb35a5b42f389970325a32aff69bb6b2126784dcda8f23b9dd9570d6573"
    //     },
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var status interface{} = this.SafeString(transaction, "status")
    var timestamp interface{} = this.SafeTimestamp2(transaction, "success_time", "submit_time")
    var depositId interface{} = this.SafeString(transaction, "deposit_id")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": this.SafeCurrencyCode(nil, currency),
            "cost": feeCost,
            "rate": nil,
        }
    }
    return map[string]interface{} {
        "id": this.SafeString2(transaction, "withdraw_id", "deposit_id"),
        "txid": this.SafeString2(transaction, "txid", "tx"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": nil,
        "address": this.SafeString(transaction, "withdraw_address"),
        "addressTo": nil,
        "amount": this.SafeNumberN(transaction, []interface{}{"amount", "withdraw_amount", "deposit_amount"}),
        "type": Ternary(IsTrue((IsEqual(depositId, nil))), "withdraw", "deposit"),
        "currency": this.SafeCurrencyCode(nil, currency),
        "status": this.ParseTransactionStatus(status),
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": this.SafeString(transaction, "withdraw_memo"),
        "internal": nil,
        "fee": fee,
        "info": transaction,
    }
}
func  (this *indodax) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "success": "ok",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name indodax#fetchDepositAddresses
 * @description fetch deposit addresses for multiple currencies and chain types
 * @see https://github.com/btcid/indodax-official-api-docs/blob/master/Private-RestAPI.md#general-information-on-endpoints
 * @param {string[]} [codes] list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *indodax) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13068 := (<-this.LoadMarkets())
            PanicOnError(retRes13068)
        
            response:= (<-this.PrivatePostGetInfo(params))
            PanicOnError(response)
            //
            //    {
            //        success: '1',
            //        return: {
            //            server_time: '1708031570',
            //            balance: {
            //                idr: '29952',
            //                ...
            //            },
            //            balance_hold: {
            //                idr: '0',
            //                ...
            //            },
            //            address: {
            //                btc: '1KMntgzvU7iTSgMBWc11nVuJjAyfW3qJyk',
            //                ...
            //            },
            //            memo_is_required: {
            //                btc: { mainnet: false },
            //                ...
            //            },
            //            network: {
            //                btc: 'mainnet',
            //                ...
            //            },
            //            user_id: '276011',
            //            name: '',
            //            email: 'testbitcoincoid@mailforspam.com',
            //            profile_picture: null,
            //            verification_status: 'unverified',
            //            gauth_enable: true,
            //            withdraw_status: '0'
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "return")
            var addresses interface{} = this.SafeDict(data, "address", map[string]interface{} {})
            var networks interface{} = this.SafeDict(data, "network", map[string]interface{} {})
            var addressKeys interface{} = ObjectKeys(addresses)
            var result interface{} = map[string]interface{} {
                "info": data,
            }
            for i := 0; IsLessThan(i, GetArrayLength(addressKeys)); i++ {
                var marketId interface{} = GetValue(addressKeys, i)
                var code interface{} = this.SafeCurrencyCode(marketId)
                var address interface{} = this.SafeString(addresses, marketId)
                if IsTrue(IsTrue((!IsEqual(address, nil))) && IsTrue((IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))))) {
                    this.CheckAddress(address)
                    var network interface{} = nil
                    if IsTrue(InOp(networks, marketId)) {
                        var networkId interface{} = this.SafeString(networks, marketId)
                        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(networkId, ","), 0)) {
                            network = []interface{}{}
                            var networkIds interface{} = Split(networkId, ",")
                            for j := 0; IsLessThan(j, GetArrayLength(networkIds)); j++ {
                                AppendToArray(&network,ToUpper(this.NetworkIdToCode(GetValue(networkIds, j))))
                            }
                        } else {
                            network = ToUpper(this.NetworkIdToCode(networkId))
                        }
                    }
                    AddElementToObject(result, code, map[string]interface{} {
            "info": map[string]interface{} {},
            "currency": code,
            "network": network,
            "address": address,
            "tag": nil,
        })
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *indodax) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
    if IsTrue(IsEqual(api, "public")) {
        var query interface{} = this.Omit(params, this.ExtractParams(path))
        var requestPath interface{} = Add("/", this.ImplodeParams(path, params))
        url = Add(url, requestPath)
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.UrlencodeWithArrayRepeat(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "method": path,
            "timestamp": this.Nonce(),
            "recvWindow": GetValue(this.Options, "recvWindow"),
        }, params))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "Key": this.ApiKey,
            "Sign": this.Hmac(this.Encode(body), this.Encode(this.Secret), sha512),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *indodax) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    // { success: 0, error: "invalid order." }
    // or
    // [{ data, ... }, { ... }, ... ]
    // {"success":"1","status":"approved","withdraw_currency":"strm","withdraw_address":"0x2b9A8cd5535D99b419aEfFBF1ae8D90a7eBdb24E","withdraw_amount":"2165.05767839","fee":"21.11000000","amount_after_fee":"2143.94767839","submit_time":"1730759489","withdraw_id":"strm-3423","txid":""}
    if IsTrue(IsArray(response)) {
        return nil  // public endpoints may return []-arrays
    }
    var error interface{} = this.SafeValue(response, "error", "")
    if IsTrue(!IsTrue((InOp(response, "success"))) && IsTrue(IsEqual(error, ""))) {
        return nil  // no 'success' property on public responses
    }
    var status interface{} = this.SafeString(response, "success")
    if IsTrue(IsEqual(status, "approved")) {
        return nil
    }
    if IsTrue(IsEqual(this.SafeInteger(response, "success", 0), 1)) {
        // { success: 1, return: { orders: [] }}
        if !IsTrue((InOp(response, "return"))) {
            panic(ExchangeError(Add(Add(this.Id, ": malformed response: "), this.Json(response))))
        } else {
            return nil
        }
    }
    var feedback interface{} = Add(Add(this.Id, " "), body)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
    this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), error, feedback)
    panic(ExchangeError(feedback))
}


func (this *indodax) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
