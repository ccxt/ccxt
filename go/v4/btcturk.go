package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type btcturk struct {
    Exchange

}

func NewBtcturkCore() btcturk {
   p := btcturk{}
   setDefaults(&p)
   return p
}

func  (this *btcturk) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "btcturk",
        "name": "BTCTurk",
        "countries": []interface{}{"TR"},
        "rateLimit": 100,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": 1,
            "15m": 15,
            "30m": 30,
            "1h": 60,
            "4h": 240,
            "1d": "1 d",
            "1w": "1 w",
            "1y": "1 y",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/10e0a238-9f60-4b06-9dda-edfc7602f1d6",
            "api": map[string]interface{} {
                "public": "https://api.btcturk.com/api/v2",
                "private": "https://api.btcturk.com/api/v1",
                "graph": "https://graph-api.btcturk.com/v1",
            },
            "www": "https://www.btcturk.com",
            "doc": "https://github.com/BTCTrader/broker-api-docs",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "orderbook": 1,
                    "ticker": 0.1,
                    "trades": 1,
                    "ohlc": 1,
                    "server/exchangeinfo": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "users/balances": 1,
                    "openOrders": 1,
                    "allOrders": 1,
                    "users/transactions/trade": 1,
                },
                "post": map[string]interface{} {
                    "users/transactions/crypto": 1,
                    "users/transactions/fiat": 1,
                    "order": 1,
                    "cancelOrder": 1,
                },
                "delete": map[string]interface{} {
                    "order": 1,
                },
            },
            "graph": map[string]interface{} {
                "get": map[string]interface{} {
                    "ohlcs": 1,
                    "klines/history": 1,
                },
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 30,
                    "symbolRequired": true,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 30,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.0005"),
                "taker": this.ParseNumber("0.0009"),
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "FAILED_ORDER_WITH_OPEN_ORDERS": InsufficientFunds,
                "FAILED_LIMIT_ORDER": InvalidOrder,
                "FAILED_MARKET_ORDER": InvalidOrder,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name btcturk#fetchMarkets
 * @description retrieves data on all markets for btcturk
 * @see https://docs.btcturk.com/public-endpoints/exchange-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *btcturk) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetServerExchangeinfo(params))
            PanicOnError(response)
            //
            //    {
            //        "data": {
            //            "timeZone": "UTC",
            //            "serverTime": "1618826678404",
            //            "symbols": [
            //                {
            //                    "id": "1",
            //                    "name": "BTCTRY",
            //                    "nameNormalized": "BTC_TRY",
            //                    "status": "TRADING",
            //                    "numerator": "BTC",
            //                    "denominator": "TRY",
            //                    "numeratorScale": "8",
            //                    "denominatorScale": "2",
            //                    "hasFraction": false,
            //                    "filters": [
            //                        {
            //                            "filterType": "PRICE_FILTER",
            //                            "minPrice": "0.0000000000001",
            //                            "maxPrice": "10000000",
            //                            "tickSize": "10",
            //                            "minExchangeValue": "99.91",
            //                            "minAmount": null,
            //                            "maxAmount": null
            //                        }
            //                    ],
            //                    "orderMethods": [
            //                        "MARKET",
            //                        "LIMIT",
            //                        "STOP_MARKET",
            //                        "STOP_LIMIT"
            //                    ],
            //                    "displayFormat": "#,###",
            //                    "commissionFromNumerator": false,
            //                    "order": "1000",
            //                    "priceRounding": false
            //                },
            //                ...
            //            },
            //        ],
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var markets interface{} = this.SafeList(data, "symbols", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseMarket(entry interface{}) interface{}  {
    var id interface{} = this.SafeString(entry, "name")
    var baseId interface{} = this.SafeString(entry, "numerator")
    var quoteId interface{} = this.SafeString(entry, "denominator")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var filters interface{} = this.SafeList(entry, "filters", []interface{}{})
    var minPrice interface{} = nil
    var maxPrice interface{} = nil
    var minAmount interface{} = nil
    var maxAmount interface{} = nil
    var minCost interface{} = nil
    for j := 0; IsLessThan(j, GetArrayLength(filters)); j++ {
        var filter interface{} = GetValue(filters, j)
        var filterType interface{} = this.SafeString(filter, "filterType")
        if IsTrue(IsEqual(filterType, "PRICE_FILTER")) {
            minPrice = this.SafeNumber(filter, "minPrice")
            maxPrice = this.SafeNumber(filter, "maxPrice")
            minAmount = this.SafeNumber(filter, "minAmount")
            maxAmount = this.SafeNumber(filter, "maxAmount")
            minCost = this.SafeNumber(filter, "minExchangeValue")
        }
    }
    var status interface{} = this.SafeString(entry, "status")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsEqual(status, "TRADING")),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "numeratorScale"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "denominatorScale"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": minAmount,
                "max": maxAmount,
            },
            "price": map[string]interface{} {
                "min": minPrice,
                "max": maxPrice,
            },
            "cost": map[string]interface{} {
                "min": minCost,
                "max": nil,
            },
        },
        "created": nil,
        "info": entry,
    }
}
func  (this *btcturk) ParseBalance(response interface{}) interface{}  {
    var data interface{} = this.SafeList(response, "data", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
        var entry interface{} = GetValue(data, i)
        var currencyId interface{} = this.SafeString(entry, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(entry, "balance"))
        AddElementToObject(account, "free", this.SafeString(entry, "free"))
        AddElementToObject(account, "used", this.SafeString(entry, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name btcturk#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.btcturk.com/private-endpoints/account-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *btcturk) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3778 := (<-this.LoadMarkets())
            PanicOnError(retRes3778)
        
            response:= (<-this.PrivateGetUsersBalances(params))
            PanicOnError(response)
        
                //
            //     {
            //       "data": [
            //         {
            //           "asset": "TRY",
            //           "assetname": "Türk Lirası",
            //           "balance": "0",
            //           "locked": "0",
            //           "free": "0",
            //           "orderFund": "0",
            //           "requestFund": "0",
            //           "precision": 2
            //         }
            //       ]
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcturk#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.btcturk.com/public-endpoints/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *btcturk) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4098 := (<-this.LoadMarkets())
            PanicOnError(retRes4098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pairSymbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //     {
            //       "data": {
            //         "timestamp": 1618827901241,
            //         "bids": [
            //           [
            //             "460263.00",
            //             "0.04244000"
            //           ]
            //         ]
            //       }
            //     }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "timestamp")
        
            ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", 0, 1)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   {
    //     "pair": "BTCTRY",
    //     "pairNormalized": "BTC_TRY",
    //     "timestamp": 1618826361234,
    //     "last": 462485,
    //     "high": 473976,
    //     "low": 444201,
    //     "bid": 461928,
    //     "ask": 462485,
    //     "open": 456915,
    //     "volume": 917.41368645,
    //     "average": 462868.29574589,
    //     "daily": 5570,
    //     "dailyPercent": 1.22,
    //     "denominatorSymbol": "TRY",
    //     "numeratorSymbol": "BTC",
    //     "order": 1000
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "pair")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "daily"),
        "percentage": this.SafeString(ticker, "dailyPercent"),
        "average": this.SafeString(ticker, "average"),
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name btcturk#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.btcturk.com/public-endpoints/ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcturk) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4918 := (<-this.LoadMarkets())
            PanicOnError(retRes4918)
        
            response:= (<-this.PublicGetTicker(params))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcturk#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.btcturk.com/public-endpoints/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcturk) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5078 := (<-this.LoadMarkets())
            PanicOnError(retRes5078)
        
            tickers:= (<-this.FetchTickers([]interface{}{symbol}, params))
            PanicOnError(tickers)
        
            ch <- this.SafeValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //     {
    //       "pair": "BTCUSDT",
    //       "pairNormalized": "BTC_USDT",
    //       "numerator": "BTC",
    //       "denominator": "USDT",
    //       "date": "1618916879083",
    //       "tid": "637545136790672520",
    //       "price": "55774",
    //       "amount": "0.27917100",
    //       "side": "buy"
    //     }
    //
    // fetchMyTrades
    //     {
    //       "price": "56000",
    //       "numeratorSymbol": "BTC",
    //       "denominatorSymbol": "USDT",
    //       "orderType": "buy",
    //       "orderId": "2606935102",
    //       "id": "320874372",
    //       "timestamp": "1618916479593",
    //       "amount": "0.00020000",
    //       "fee": "0",
    //       "tax": "0"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "date", "timestamp")
    var id interface{} = this.SafeString2(trade, "tid", "id")
    var order interface{} = this.SafeString(trade, "orderId")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = Precise.StringAbs(this.SafeString(trade, "amount"))
    var marketId interface{} = this.SafeString(trade, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var side interface{} = this.SafeString2(trade, "side", "orderType")
    var fee interface{} = nil
    var feeAmountString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeAmountString, nil)) {
        var feeCurrency interface{} = this.SafeString(trade, "denominatorSymbol")
        fee = map[string]interface{} {
            "cost": Precise.StringAbs(feeAmountString),
            "currency": this.SafeCurrencyCode(feeCurrency),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name btcturk#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.btcturk.com/public-endpoints/trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *btcturk) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5878 := (<-this.LoadMarkets())
            PanicOnError(retRes5878)
            var market interface{} = this.Market(symbol)
            // let maxCount = 50;
            var request interface{} = map[string]interface{} {
                "pairSymbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "last", limit)
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //       "data": [
            //         {
            //           "pair": "BTCTRY",
            //           "pairNormalized": "BTC_TRY",
            //           "numerator": "BTC",
            //           "denominator": "TRY",
            //           "date": 1618828421497,
            //           "tid": "637544252214980918",
            //           "price": "462585.00",
            //           "amount": "0.01618411",
            //           "side": "sell"
            //         }
            //       ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "timestamp": 1661990400,
    //        "high": 368388.0,
    //        "open": 368388.0,
    //        "low": 368388.0,
    //        "close": 368388.0,
    //        "volume": 0.00035208,
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "timestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name btcturk#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.btcturk.com/public-endpoints/get-kline-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *btcturk) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1h")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6538 := (<-this.LoadMarkets())
            PanicOnError(retRes6538)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "resolution": this.SafeValue(this.Timeframes, timeframe, timeframe),
            }
            var until interface{} = this.SafeInteger(params, "until", this.Milliseconds())
            AddElementToObject(request, "to", this.ParseToInt((Divide(until, 1000))))
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.ParseToInt(Divide(since, 1000)))
            } else if IsTrue(IsEqual(limit, nil)) {
                limit = 100 // default value
            }
            if IsTrue(!IsEqual(limit, nil)) {
                limit = mathMin(limit, 11000) // max 11000 candles diapason can be covered
                if IsTrue(IsEqual(timeframe, "1y")) {
                    panic(BadRequest(Add(this.Id, " fetchOHLCV () does not accept a limit parameter when timeframe == \"1y\"")))
                }
                var seconds interface{} = this.ParseTimeframe(timeframe)
                var limitSeconds interface{} = Multiply(seconds, (Subtract(limit, 1)))
                if IsTrue(!IsEqual(since, nil)) {
                    var to interface{} = Add(this.ParseToInt(Divide(since, 1000)), limitSeconds)
                    AddElementToObject(request, "to", mathMin(GetValue(request, "to"), to))
                } else {
                    AddElementToObject(request, "from", Subtract(this.ParseToInt(Divide(0, 1000)), limitSeconds))
                }
            }
        
            response:= (<-this.GraphGetKlinesHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "s": "ok",
            //        "t": [
            //          1661990400,
            //          1661990520,
            //          ...
            //        ],
            //        "h": [
            //          368388.0,
            //          369090.0,
            //          ...
            //        ],
            //        "o": [
            //          368388.0,
            //          368467.0,
            //          ...
            //        ],
            //        "l": [
            //          368388.0,
            //          368467.0,
            //          ...
            //        ],
            //        "c": [
            //          368388.0,
            //          369090.0,
            //          ...
            //        ],
            //        "v": [
            //          0.00035208,
            //          0.2972395,
            //          ...
            //        ]
            //    }
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseOHLCVs(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    var results interface{} = []interface{}{}
    var timestamp interface{} = this.SafeList(ohlcvs, "t", []interface{}{})
    var high interface{} = this.SafeList(ohlcvs, "h", []interface{}{})
    var open interface{} = this.SafeList(ohlcvs, "o", []interface{}{})
    var low interface{} = this.SafeList(ohlcvs, "l", []interface{}{})
    var close interface{} = this.SafeList(ohlcvs, "c", []interface{}{})
    var volume interface{} = this.SafeList(ohlcvs, "v", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(timestamp)); i++ {
        var ohlcv interface{} = map[string]interface{} {
            "timestamp": this.SafeInteger(timestamp, i),
            "high": this.SafeNumber(high, i),
            "open": this.SafeNumber(open, i),
            "low": this.SafeNumber(low, i),
            "close": this.SafeNumber(close, i),
            "volume": this.SafeNumber(volume, i),
        }
        AppendToArray(&results,this.ParseOHLCV(ohlcv, market))
    }
    var sorted interface{} = this.SortBy(results, 0)
    return this.FilterBySinceLimit(sorted, since, limit, 0, tail)
}
/**
 * @method
 * @name btcturk#createOrder
 * @description create a trade order
 * @see https://docs.btcturk.com/private-endpoints/submit-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcturk) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7568 := (<-this.LoadMarkets())
            PanicOnError(retRes7568)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "orderType": side,
                "orderMethod": typeVar,
                "pairSymbol": GetValue(market, "id"),
                "quantity": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(!IsEqual(typeVar, "market")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(InOp(params, "clientOrderId")) {
                AddElementToObject(request, "newClientOrderId", GetValue(params, "clientOrderId"))
            } else if !IsTrue((InOp(params, "newClientOrderId"))) {
                AddElementToObject(request, "newClientOrderId", this.Uuid())
            }
        
            response:= (<-this.PrivatePostOrder(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcturk#cancelOrder
 * @description cancels an open order
 * @see https://docs.btcturk.com/private-endpoints/cancel-order
 * @param {string} id order id
 * @param {string} symbol not used by btcturk cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcturk) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateDeleteOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "success": true,
            //        "message": "SUCCESS",
            //        "code": 0
            //    }
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcturk#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.btcturk.com/private-endpoints/open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcturk) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8168 := (<-this.LoadMarkets())
            PanicOnError(retRes8168)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pairSymbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var bids interface{} = this.SafeList(data, "bids", []interface{}{})
            var asks interface{} = this.SafeList(data, "asks", []interface{}{})
        
            ch <- this.ParseOrders(this.ArrayConcat(bids, asks), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcturk#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.btcturk.com/private-endpoints/all-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcturk) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8428 := (<-this.LoadMarkets())
            PanicOnError(retRes8428)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pairSymbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                // default 100 max 1000
                AddElementToObject(request, "last", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", MathFloor(Divide(since, 1000)))
            }
        
            response:= (<-this.PrivateGetAllOrders(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //   "data": [
            //     {
            //       "id": "2606012912",
            //       "price": "55000",
            //       "amount": "0.0003",
            //       "quantity": "0.0003",
            //       "stopPrice": "0",
            //       "pairSymbol": "BTCUSDT",
            //       "pairSymbolNormalized": "BTC_USDT",
            //       "type": "buy",
            //       "method": "limit",
            //       "orderClientId": "2ed187bd-59a8-4875-a212-1b793963b85c",
            //       "time": "1618913189253",
            //       "updateTime": "1618913189253",
            //       "status": "Untouched",
            //       "leftAmount": "0.0003000000000000"
            //     }
            //   ]
            // }
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Untouched": "open",
        "Partial": "open",
        "Canceled": "canceled",
        "Closed": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcturk) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrders / fetchOpenOrders
    //     {
    //       "id": 2605984008,
    //       "price": "55000",
    //       "amount": "0.00050000",
    //       "quantity": "0.00050000",
    //       "stopPrice": "0",
    //       "pairSymbol": "BTCUSDT",
    //       "pairSymbolNormalized": "BTC_USDT",
    //       "type": "buy",
    //       "method": "limit",
    //       "orderClientId": "f479bdb6-0965-4f03-95b5-daeb7aa5a3a5",
    //       "time": 0,
    //       "updateTime": 1618913083543,
    //       "status": "Untouched",
    //       "leftAmount": "0.00050000"
    //     }
    //
    // createOrder
    //     {
    //       "id": "2606935102",
    //       "quantity": "0.0002",
    //       "price": "56000",
    //       "stopPrice": null,
    //       "newOrderClientId": "98e5c491-7ed9-462b-9666-93553180fb28",
    //       "type": "buy",
    //       "method": "limit",
    //       "pairSymbol": "BTCUSDT",
    //       "pairSymbolNormalized": "BTC_USDT",
    //       "datetime": "1618916479523"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var price interface{} = this.SafeString(order, "price")
    var amountString interface{} = this.SafeString2(order, "amount", "quantity")
    var amount interface{} = Precise.StringAbs(amountString)
    var remaining interface{} = this.SafeString(order, "leftAmount")
    var marketId interface{} = this.SafeString(order, "pairSymbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var side interface{} = this.SafeString(order, "type")
    var typeVar interface{} = this.SafeString(order, "method")
    var clientOrderId interface{} = this.SafeString(order, "orderClientId")
    var timestamp interface{} = this.SafeInteger2(order, "updateTime", "datetime")
    var rawStatus interface{} = this.SafeString(order, "status")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "price": price,
        "amount": amount,
        "remaining": remaining,
        "filled": nil,
        "cost": nil,
        "average": nil,
        "status": status,
        "side": side,
        "type": typeVar,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name btcturk#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.btcturk.com/private-endpoints/user-transactions
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *btcturk) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9688 := (<-this.LoadMarkets())
            PanicOnError(retRes9688)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivateGetUsersTransactionsTrade())
            PanicOnError(response)
            //
            //     {
            //       "data": [
            //         {
            //           "price": "56000",
            //           "numeratorSymbol": "BTC",
            //           "denominatorSymbol": "USDT",
            //           "orderType": "buy",
            //           "orderId": "2606935102",
            //           "id": "320874372",
            //           "timestamp": "1618916479593",
            //           "amount": "0.00020000",
            //           "fee": "0",
            //           "tax": "0"
            //         }
            //       ],
            //       "success": true,
            //       "message": "SUCCESS",
            //       "code": "0"
            //     }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcturk) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *btcturk) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    if IsTrue(IsEqual(this.Id, "btctrader")) {
        panic(ExchangeError(Add(this.Id, " is an abstract base API for BTCExchange, BTCTurk")))
    }
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        body = this.Json(params)
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var secret interface{} = this.Base64ToBinary(this.Secret)
        var auth interface{} = Add(this.ApiKey, nonce)
        headers = map[string]interface{} {
            "X-PCK": this.ApiKey,
            "X-Stamp": nonce,
            "X-Signature": this.Hmac(this.Encode(auth), secret, sha256, "base64"),
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *btcturk) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    var errorCode interface{} = this.SafeString(response, "code", "0")
    var message interface{} = this.SafeString(response, "message")
    var output interface{} = Ternary(IsTrue((IsEqual(message, nil))), body, message)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, Add(Add(this.Id, " "), output))
    if IsTrue(IsTrue((!IsEqual(errorCode, "0"))) && IsTrue((!IsEqual(errorCode, "SUCCESS")))) {
        panic(ExchangeError(Add(Add(this.Id, " "), output)))
    }
    return nil
}


func (this *btcturk) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
