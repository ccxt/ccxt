package ccxt

type Gate struct {
   *gate
   Core *gate
}

func NewGate(userConfig map[string]interface{}) Gate {
   p := &gate{}
   p.Init(userConfig)
   return Gate{
       gate: p,
       Core:  p,
   }
}

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


/**
 * @method
 * @name gate#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-server-current-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *Gate) FetchTime(params ...interface{}) ( int64, error) {
    res := <- this.Core.FetchTime(params...)
    if IsError(res) {
        return -1, CreateReturnError(res)
    }
    return (res).(int64), nil
}
/**
 * @method
 * @name gate#fetchMarkets
 * @description retrieves data on all markets for gate
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-currency-pairs-supported                                     // spot
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-supported-currency-pairs-supported-in-margin-trading         // margin
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts                                            // swap
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts-2                                          // future
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-the-contracts-with-specified-underlying-and-expiration-time  // option
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *Gate) FetchMarkets(params ...interface{}) ([]MarketInterface, error) {
    res := <- this.Core.FetchMarkets(params...)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewMarketInterfaceArray(res), nil
}
func (this *Gate) FetchSpotMarkets(params ...interface{}) ([]map[string]interface{}, error) {
    res := <- this.Core.FetchSpotMarkets(params...)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return res.([]map[string]interface{}), nil
}
func (this *Gate) FetchContractMarkets(params ...interface{}) ([]map[string]interface{}, error) {
    res := <- this.Core.FetchContractMarkets(params...)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return res.([]map[string]interface{}), nil
}
func (this *Gate) FetchOptionMarkets(params ...interface{}) ([]map[string]interface{}, error) {
    res := <- this.Core.FetchOptionMarkets(params...)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return res.([]map[string]interface{}), nil
}
func (this *Gate) FetchOptionUnderlyings() ([]map[string]interface{}, error) {
    res := <- this.Core.FetchOptionUnderlyings()
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return res.([]map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-contract
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *Gate) FetchFundingRate(symbol string, options ...FetchFundingRateOptions) (FundingRate, error) {

    opts := FetchFundingRateOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchFundingRate(symbol, params)
    if IsError(res) {
        return FundingRate{}, CreateReturnError(res)
    }
    return NewFundingRate(res), nil
}
/**
 * @method
 * @name gate#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func (this *Gate) FetchFundingRates(options ...FetchFundingRatesOptions) (FundingRates, error) {

    opts := FetchFundingRatesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchFundingRates(symbols, params)
    if IsError(res) {
        return FundingRates{}, CreateReturnError(res)
    }
    return NewFundingRates(res), nil
}
func (this *Gate) FetchNetworkDepositAddress(code string, options ...FetchNetworkDepositAddressOptions) (map[string]interface{}, error) {

    opts := FetchNetworkDepositAddressOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchNetworkDepositAddress(code, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.gate.io/docs/developers/apiv4/en/#generate-currency-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code (not used directly by gate.io but used by ccxt to filter the response)
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *Gate) FetchDepositAddress(code string, options ...FetchDepositAddressOptions) (DepositAddress, error) {

    opts := FetchDepositAddressOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchDepositAddress(code, params)
    if IsError(res) {
        return DepositAddress{}, CreateReturnError(res)
    }
    return NewDepositAddress(res), nil
}
/**
 * @method
 * @name gate#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-personal-trading-fee
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *Gate) FetchTradingFee(symbol string, options ...FetchTradingFeeOptions) (TradingFeeInterface, error) {

    opts := FetchTradingFeeOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchTradingFee(symbol, params)
    if IsError(res) {
        return TradingFeeInterface{}, CreateReturnError(res)
    }
    return NewTradingFeeInterface(res), nil
}
/**
 * @method
 * @name gate#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-personal-trading-fee
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func (this *Gate) FetchTradingFees(params ...interface{}) (TradingFees, error) {
    res := <- this.Core.FetchTradingFees(params...)
    if IsError(res) {
        return TradingFees{}, CreateReturnError(res)
    }
    return NewTradingFees(res), nil
}
/**
 * @method
 * @name gate#fetchTransactionFees
 * @deprecated
 * @description please use fetchDepositWithdrawFees instead
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *Gate) FetchTransactionFees(options ...FetchTransactionFeesOptions) (map[string]interface{}, error) {

    opts := FetchTransactionFeesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var codes interface{} = nil
    if opts.Codes != nil {
        codes = *opts.Codes
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchTransactionFees(codes, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-status
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *Gate) FetchDepositWithdrawFees(options ...FetchDepositWithdrawFeesOptions) (map[string]interface{}, error) {

    opts := FetchDepositWithdrawFeesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var codes interface{} = nil
    if opts.Codes != nil {
        codes = *opts.Codes
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchDepositWithdrawFees(codes, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-3
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func (this *Gate) FetchFundingHistory(options ...FetchFundingHistoryOptions) ([]FundingHistory, error) {

    opts := FetchFundingHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchFundingHistory(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewFundingHistoryArray(res), nil
}
/**
 * @method
 * @name gate#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-order-book
 * @see https://www.gate.io/docs/developers/apiv4/en/#futures-order-book
 * @see https://www.gate.io/docs/developers/apiv4/en/#futures-order-book-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#options-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *Gate) FetchOrderBook(symbol string, options ...FetchOrderBookOptions) (OrderBook, error) {

    opts := FetchOrderBookOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOrderBook(symbol, limit, params)
    if IsError(res) {
        return OrderBook{}, CreateReturnError(res)
    }
    return NewOrderBook(res), nil
}
/**
 * @method
 * @name gate#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-details-of-a-specifc-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *Gate) FetchTicker(symbol string, options ...FetchTickerOptions) (Ticker, error) {

    opts := FetchTickerOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchTicker(symbol, params)
    if IsError(res) {
        return Ticker{}, CreateReturnError(res)
    }
    return NewTicker(res), nil
}
/**
 * @method
 * @name gate#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-details-of-a-specifc-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-tickers-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *Gate) FetchTickers(options ...FetchTickersOptions) (Tickers, error) {

    opts := FetchTickersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchTickers(symbols, params)
    if IsError(res) {
        return Tickers{}, CreateReturnError(res)
    }
    return NewTickers(res), nil
}
/**
 * @method
 * @name gate#fetchBalance
 * @param {object} [params] exchange specific parameters
 * @param {string} [params.type] spot, margin, swap or future, if not provided this.options['defaultType'] is used
 * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.symbol] margin only - unified ccxt symbol
 * @param {boolean} [params.unifiedAccount] default false, set to true for fetching the unified account balance
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *Gate) FetchBalance(params ...interface{}) (Balances, error) {
    res := <- this.Core.FetchBalance(params...)
    if IsError(res) {
        return Balances{}, CreateReturnError(res)
    }
    return NewBalances(res), nil
}
func (this *Gate) FetchOHLCV(symbol string, options ...FetchOHLCVOptions) ([]OHLCV, error) {

    opts := FetchOHLCVOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var timeframe interface{} = nil
    if opts.Timeframe != nil {
        timeframe = *opts.Timeframe
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOHLCV(symbol, timeframe, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOHLCVArray(res), nil
}
func (this *Gate) FetchOptionOHLCV(symbol string, options ...FetchOptionOHLCVOptions) ([]OHLCV, error) {

    opts := FetchOptionOHLCVOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var timeframe interface{} = nil
    if opts.Timeframe != nil {
        timeframe = *opts.Timeframe
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOptionOHLCV(symbol, timeframe, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOHLCVArray(res), nil
}
/**
 * @method
 * @name gate#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://www.gate.io/docs/developers/apiv4/en/#funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *Gate) FetchFundingRateHistory(options ...FetchFundingRateHistoryOptions) ([]FundingRateHistory, error) {

    opts := FetchFundingRateHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchFundingRateHistory(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewFundingRateHistoryArray(res), nil
}
/**
 * @method
 * @name gate#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-market-trades
 * @see https://www.gate.io/docs/developers/apiv4/en/#futures-trading-history
 * @see https://www.gate.io/docs/developers/apiv4/en/#futures-trading-history-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#options-trade-history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *Gate) FetchTrades(symbol string, options ...FetchTradesOptions) ([]Trade, error) {

    opts := FetchTradesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchTrades(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewTradeArray(res), nil
}
/**
 * @method
 * @name gate#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-4
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *Gate) FetchOrderTrades(id string, options ...FetchOrderTradesOptions) ([]Trade, error) {

    opts := FetchOrderTradesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOrderTrades(id, symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewTradeArray(res), nil
}
/**
 * @method
 * @name gate#fetchMyTrades
 * @description Fetch personal trading history
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-personal-trading-history-4
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
 * @param {int} [params.until] The latest timestamp, in ms, that fetched trades were made
 * @param {int} [params.page] *spot only* Page number
 * @param {string} [params.order_id] *spot only* Filter trades with specified order ID. symbol is also required if this field is present
 * @param {string} [params.order] *contract only* Futures order ID, return related data only if specified
 * @param {int} [params.offset] *contract only* list offset, starting from 0
 * @param {string} [params.last_id] *contract only* specify list staring point using the id of last record in previous list-query results
 * @param {int} [params.count_total] *contract only* whether to return total number matched, default to 0(no return)
 * @param {bool} [params.unifiedAccount] set to true for fetching trades in a unified account
 * @param {bool} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *Gate) FetchMyTrades(options ...FetchMyTradesOptions) ([]Trade, error) {

    opts := FetchMyTradesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchMyTrades(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewTradeArray(res), nil
}
/**
 * @method
 * @name gate#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-deposit-records
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *Gate) FetchDeposits(options ...FetchDepositsOptions) ([]Transaction, error) {

    opts := FetchDepositsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var code interface{} = nil
    if opts.Code != nil {
        code = *opts.Code
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchDeposits(code, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewTransactionArray(res), nil
}
/**
 * @method
 * @name gate#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-withdrawal-records
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *Gate) FetchWithdrawals(options ...FetchWithdrawalsOptions) ([]Transaction, error) {

    opts := FetchWithdrawalsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var code interface{} = nil
    if opts.Code != nil {
        code = *opts.Code
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchWithdrawals(code, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewTransactionArray(res), nil
}
/**
 * @method
 * @name gate#withdraw
 * @description make a withdrawal
 * @see https://www.gate.io/docs/developers/apiv4/en/#withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *Gate) Withdraw(code string, amount float64, address string, options ...WithdrawOptions) (Transaction, error) {

    opts := WithdrawOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var tag interface{} = nil
    if opts.Tag != nil {
        tag = *opts.Tag
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.Withdraw(code, amount, address, tag, params)
    if IsError(res) {
        return Transaction{}, CreateReturnError(res)
    }
    return NewTransaction(res), nil
}
/**
 * @method
 * @name gate#createOrder
 * @description Create an order on the exchange
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-futures-order-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-price-triggered-order-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-options-order
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market' *"market" is contract only*
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
 * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {int} [params.iceberg] Amount to display for the iceberg order, Null or 0 for normal orders, Set to -1 to hide the order completely
 * @param {string} [params.text] User defined information
 * @param {string} [params.account] *spot and margin only* "spot", "margin" or "cross_margin"
 * @param {bool} [params.auto_borrow] *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
 * @param {string} [params.settle] *contract only* Unified Currency Code for settle currency
 * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
 * @param {bool} [params.close] *contract only* Set as true to close the position, with size set to 0
 * @param {bool} [params.auto_size] *contract only* Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
 * @param {int} [params.price_type] *contract only* 0 latest deal price, 1 mark price, 2 index price
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {bool} [params.unifiedAccount] set to true for creating an order in the unified account
 * @returns {object|undefined} [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CreateOrder(symbol string, typeVar string, side string, amount float64, options ...CreateOrderOptions) (Order, error) {

    opts := CreateOrderOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var price interface{} = nil
    if opts.Price != nil {
        price = *opts.Price
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CreateOrder(symbol, typeVar, side, amount, price, params)
    if IsError(res) {
        return Order{}, CreateReturnError(res)
    }
    return NewOrder(res), nil
}
/**
 * @method
 * @name gate#createOrders
 * @description create a list of trade orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-batch-of-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-a-batch-of-futures-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CreateOrders(orders []OrderRequest, options ...CreateOrdersOptions) ([]Order, error) {

    opts := CreateOrdersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CreateOrders(orders, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
/**
 * @method
 * @name gate#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.gate.io/docs/developers/apiv4/en/#create-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.unifiedAccount] set to true for creating a unified account order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CreateMarketBuyOrderWithCost(symbol string, cost float64, options ...CreateMarketBuyOrderWithCostOptions) (Order, error) {

    opts := CreateMarketBuyOrderWithCostOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CreateMarketBuyOrderWithCost(symbol, cost, params)
    if IsError(res) {
        return Order{}, CreateReturnError(res)
    }
    return NewOrder(res), nil
}
/**
 * @method
 * @name gate#editOrder
 * @description edit a trade order, gate currently only supports the modification of the price or amount fields
 * @see https://www.gate.io/docs/developers/apiv4/en/#amend-an-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#amend-an-order-2
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.unifiedAccount] set to true for editing an order in a unified account
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) EditOrder(id string, symbol string, typeVar string, side string, options ...EditOrderOptions) (Order, error) {

    opts := EditOrderOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var amount interface{} = nil
    if opts.Amount != nil {
        amount = *opts.Amount
    }

    var price interface{} = nil
    if opts.Price != nil {
        price = *opts.Price
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.EditOrder(id, symbol, typeVar, side, amount, price, params)
    if IsError(res) {
        return Order{}, CreateReturnError(res)
    }
    return NewOrder(res), nil
}
/**
 * @method
 * @name gate#fetchOrder
 * @description Retrieves information on an order
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-a-single-order-4
 * @param {string} id Order id
 * @param {string} symbol Unified market symbol, *required for spot and margin*
 * @param {object} [params] Parameters specified by the exchange api
 * @param {bool} [params.trigger] True if the order being fetched is a trigger order
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
 * @param {bool} [params.unifiedAccount] set to true for fetching a unified account order
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) FetchOrder(id string, options ...FetchOrderOptions) (Order, error) {

    opts := FetchOrderOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOrder(id, symbol, params)
    if IsError(res) {
        return Order{}, CreateReturnError(res)
    }
    return NewOrder(res), nil
}
/**
 * @method
 * @name gate#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-open-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-running-auto-order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true for fetching trigger orders
 * @param {string} [params.type] spot, margin, swap or future, if not provided this.options['defaultType'] is used
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for type='margin', if not provided this.options['defaultMarginMode'] is used
 * @param {bool} [params.unifiedAccount] set to true for fetching unified account orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) FetchOpenOrders(options ...FetchOpenOrdersOptions) ([]Order, error) {

    opts := FetchOpenOrdersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOpenOrders(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
/**
 * @method
 * @name gate#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-running-auto-order-list
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-auto-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-orders-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-auto-orders-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-options-orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-futures-orders-by-time-range
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true for fetching trigger orders
 * @param {string} [params.type] spot, swap or future, if not provided this.options['defaultType'] is used
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {boolean} [params.historical] *swap only* true for using historical endpoint
 * @param {bool} [params.unifiedAccount] set to true for fetching unified account orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) FetchClosedOrders(options ...FetchClosedOrdersOptions) ([]Order, error) {

    opts := FetchClosedOrdersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchClosedOrders(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
func (this *Gate) FetchOrdersByStatus(status interface{}, options ...FetchOrdersByStatusOptions) (map[string]interface{}, error) {

    opts := FetchOrdersByStatusOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOrdersByStatus(status, symbol, since, limit, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#cancelOrder
 * @description Cancels an open order
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-single-order-4
 * @param {string} id Order id
 * @param {string} symbol Unified market symbol
 * @param {object} [params] Parameters specified by the exchange api
 * @param {bool} [params.trigger] True if the order to be cancelled is a trigger order
 * @param {bool} [params.unifiedAccount] set to true for canceling unified account orders
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CancelOrder(id string, options ...CancelOrderOptions) (Order, error) {

    opts := CancelOrderOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CancelOrder(id, symbol, params)
    if IsError(res) {
        return Order{}, CreateReturnError(res)
    }
    return NewOrder(res), nil
}
/**
 * @method
 * @name gate#cancelOrders
 * @description cancel multiple orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-batch-of-orders-with-an-id-list
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-batch-of-orders-with-an-id-list-2
 * @param {string[]} ids order ids
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.unifiedAccount] set to true for canceling unified account orders
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CancelOrders(ids []string, options ...CancelOrdersOptions) ([]Order, error) {

    opts := CancelOrdersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CancelOrders(ids, symbol, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
/**
 * @method
 * @name gate#cancelOrdersForSymbols
 * @description cancel multiple orders for multiple symbols
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-a-batch-of-orders-with-an-id-list
 * @param {CancellationRequest[]} orders list of order ids with symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderIds] client order ids
 * @param {bool} [params.unifiedAccount] set to true for canceling unified account orders
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CancelOrdersForSymbols(orders []CancellationRequest, options ...CancelOrdersForSymbolsOptions) ([]Order, error) {

    opts := CancelOrdersForSymbolsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CancelOrdersForSymbols(orders, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
/**
 * @method
 * @name gate#cancelAllOrders
 * @description cancel all open orders
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-in-specified-currency-pair
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#cancel-all-open-orders-matched-3
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.unifiedAccount] set to true for canceling unified account orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *Gate) CancelAllOrders(options ...CancelAllOrdersOptions) ([]Order, error) {

    opts := CancelAllOrdersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.CancelAllOrders(symbol, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOrderArray(res), nil
}
/**
 * @method
 * @name gate#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.gate.io/docs/developers/apiv4/en/#transfer-between-trading-accounts
 * @param {string} code unified currency code for currency being transferred
 * @param {float} amount the amount of currency to transfer
 * @param {string} fromAccount the account to transfer currency from
 * @param {string} toAccount the account to transfer currency to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] Unified market symbol *required for type == margin*
 * @returns A [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *Gate) Transfer(code string, amount float64, fromAccount string, toAccount string, options ...TransferOptions) (TransferEntry, error) {

    opts := TransferOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.Transfer(code, amount, fromAccount, toAccount, params)
    if IsError(res) {
        return TransferEntry{}, CreateReturnError(res)
    }
    return NewTransferEntry(res), nil
}
/**
 * @method
 * @name gate#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-leverage
 * @see https://www.gate.io/docs/developers/apiv4/en/#update-position-leverage-2
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *Gate) SetLeverage(leverage int64, options ...SetLeverageOptions) (map[string]interface{}, error) {

    opts := SetLeverageOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.SetLeverage(leverage, symbol, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchPosition
 * @description fetch data on an open contract position
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-single-position
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-single-position-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-specified-contract-position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *Gate) FetchPosition(symbol string, options ...FetchPositionOptions) (Position, error) {

    opts := FetchPositionOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchPosition(symbol, params)
    if IsError(res) {
        return Position{}, CreateReturnError(res)
    }
    return NewPosition(res), nil
}
/**
 * @method
 * @name gate#fetchPositions
 * @description fetch all open positions
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-positions-of-a-user
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-positions-of-a-user-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-user-s-positions-of-specified-underlying
 * @param {string[]|undefined} symbols Not used by gate, but parsed internally by CCXT
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
 * @param {string} [params.type] swap, future or option, if not provided this.options['defaultType'] is used
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *Gate) FetchPositions(options ...FetchPositionsOptions) ([]Position, error) {

    opts := FetchPositionsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchPositions(symbols, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewPositionArray(res), nil
}
/**
 * @method
 * @name gate#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-futures-contracts-2
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func (this *Gate) FetchLeverageTiers(options ...FetchLeverageTiersOptions) (LeverageTiers, error) {

    opts := FetchLeverageTiersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchLeverageTiers(symbols, params)
    if IsError(res) {
        return LeverageTiers{}, CreateReturnError(res)
    }
    return NewLeverageTiers(res), nil
}
/**
 * @method
 * @name gate#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-risk-limit-tiers
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func (this *Gate) FetchMarketLeverageTiers(symbol string, options ...FetchMarketLeverageTiersOptions) ([]LeverageTier, error) {

    opts := FetchMarketLeverageTiersOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchMarketLeverageTiers(symbol, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewLeverageTierArray(res), nil
}
/**
 * @method
 * @name gate#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-interest-records
 * @see https://www.gate.io/docs/developers/apiv4/en/#interest-records-for-the-cross-margin-account
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-interest-records-2
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol when fetching interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedAccount] set to true for fetching borrow interest in the unified account
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func (this *Gate) FetchBorrowInterest(options ...FetchBorrowInterestOptions) ([]BorrowInterest, error) {

    opts := FetchBorrowInterestOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var code interface{} = nil
    if opts.Code != nil {
        code = *opts.Code
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchBorrowInterest(code, symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewBorrowInterestArray(res), nil
}
func (this *Gate) FetchOpenInterestHistory(symbol string, options ...FetchOpenInterestHistoryOptions) ([]OpenInterest, error) {

    opts := FetchOpenInterestHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var timeframe interface{} = nil
    if opts.Timeframe != nil {
        timeframe = *opts.Timeframe
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOpenInterestHistory(symbol, timeframe, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewOpenInterestArray(res), nil
}
/**
 * @method
 * @name gate#fetchSettlementHistory
 * @description fetches historical settlement records
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-settlement-history-2
 * @param {string} symbol unified market symbol of the settlement history, required on gate
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
 */
func (this *Gate) FetchSettlementHistory(options ...FetchSettlementHistoryOptions) (map[string]interface{}, error) {

    opts := FetchSettlementHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchSettlementHistory(symbol, since, limit, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchMySettlementHistory
 * @description fetches historical settlement records of the user
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-my-options-settlements
 * @param {string} symbol unified market symbol of the settlement history
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @returns {object[]} a list of [settlement history objects]
 */
func (this *Gate) FetchMySettlementHistory(options ...FetchMySettlementHistoryOptions) (map[string]interface{}, error) {

    opts := FetchMySettlementHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchMySettlementHistory(symbol, since, limit, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-margin-account-balance-change-history
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-account-book-3
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-account-changing-history
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func (this *Gate) FetchLedger(options ...FetchLedgerOptions) ([]LedgerEntry, error) {

    opts := FetchLedgerOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var code interface{} = nil
    if opts.Code != nil {
        code = *opts.Code
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchLedger(code, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewLedgerEntryArray(res), nil
}
/**
 * @method
 * @name gate#setPositionMode
 * @description set dual/hedged mode to true or false for a swap market, make sure all positions are closed and no orders are open before setting dual mode
 * @see https://www.gate.io/docs/developers/apiv4/en/#enable-or-disable-dual-mode
 * @param {bool} hedged set to true to enable dual mode
 * @param {string|undefined} symbol if passed, dual mode is set for all markets with the same settle currency
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {string} params.settle settle currency
 * @returns {object} response from the exchange
 */
func (this *Gate) SetPositionMode(hedged bool, options ...SetPositionModeOptions) (map[string]interface{}, error) {

    opts := SetPositionModeOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.SetPositionMode(hedged, symbol, params)
    if IsError(res) {
        return map[string]interface{}{}, CreateReturnError(res)
    }
    return res.(map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchUnderlyingAssets
 * @description fetches the market ids of underlying assets for a specific contract market type
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-underlyings
 * @param {object} [params] exchange specific params
 * @param {string} [params.type] the contract market type, 'option', 'swap' or 'future', the default is 'option'
 * @returns {object[]} a list of [underlying assets]{@link https://docs.ccxt.com/#/?id=underlying-assets-structure}
 */
func (this *Gate) FetchUnderlyingAssets(params ...interface{}) ([]map[string]interface{}, error) {
    res := <- this.Core.FetchUnderlyingAssets(params...)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return res.([]map[string]interface{}), nil
}
/**
 * @method
 * @name gate#fetchLiquidations
 * @description retrieves the public liquidations of a trading pair
 * @see https://www.gate.io/docs/developers/apiv4/en/#retrieve-liquidation-history
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func (this *Gate) FetchLiquidations(symbol string, options ...FetchLiquidationsOptions) ([]Liquidation, error) {

    opts := FetchLiquidationsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchLiquidations(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewLiquidationArray(res), nil
}
/**
 * @method
 * @name gate#fetchMyLiquidations
 * @description retrieves the users liquidated positions
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-liquidation-history
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-liquidation-history-2
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-user-s-liquidation-history-of-specified-underlying
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the exchange API endpoint
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func (this *Gate) FetchMyLiquidations(options ...FetchMyLiquidationsOptions) ([]Liquidation, error) {

    opts := FetchMyLiquidationsOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbol interface{} = nil
    if opts.Symbol != nil {
        symbol = *opts.Symbol
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchMyLiquidations(symbol, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewLiquidationArray(res), nil
}
/**
 * @method
 * @name gate#fetchGreeks
 * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-tickers-of-options-contracts
 * @param {string} symbol unified symbol of the market to fetch greeks for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
 */
func (this *Gate) FetchGreeks(symbol string, options ...FetchGreeksOptions) (Greeks, error) {

    opts := FetchGreeksOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchGreeks(symbol, params)
    if IsError(res) {
        return Greeks{}, CreateReturnError(res)
    }
    return NewGreeks(res), nil
}
/**
 * @method
 * @name gate#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-unified-account-information
 * @see https://www.gate.io/docs/developers/apiv4/en/#get-detail-of-lending-market
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-one-single-margin-currency-pair-deprecated
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unified] default false, set to true for fetching the unified accounts leverage
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *Gate) FetchLeverage(symbol string, options ...FetchLeverageOptions) (Leverage, error) {

    opts := FetchLeverageOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchLeverage(symbol, params)
    if IsError(res) {
        return Leverage{}, CreateReturnError(res)
    }
    return NewLeverage(res), nil
}
/**
 * @method
 * @name gate#fetchLeverages
 * @description fetch the set leverage for all leverage markets, only spot margin is supported on gate
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-lending-markets
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-supported-currency-pairs-supported-in-margin-trading-deprecated
 * @param {string[]} symbols a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unified] default false, set to true for fetching unified account leverages
 * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *Gate) FetchLeverages(options ...FetchLeveragesOptions) (Leverages, error) {

    opts := FetchLeveragesOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchLeverages(symbols, params)
    if IsError(res) {
        return Leverages{}, CreateReturnError(res)
    }
    return NewLeverages(res), nil
}
/**
 * @method
 * @name gate#fetchOption
 * @description fetches option data that is commonly found in an option chain
 * @see https://www.gate.io/docs/developers/apiv4/en/#query-specified-contract-detail
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
 */
func (this *Gate) FetchOption(symbol string, options ...FetchOptionOptions) (Option, error) {

    opts := FetchOptionOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOption(symbol, params)
    if IsError(res) {
        return Option{}, CreateReturnError(res)
    }
    return NewOption(res), nil
}
/**
 * @method
 * @name gate#fetchOptionChain
 * @description fetches data for an underlying asset that is commonly found in an option chain
 * @see https://www.gate.io/docs/developers/apiv4/en/#list-all-the-contracts-with-specified-underlying-and-expiration-time
 * @param {string} code base currency to fetch an option chain for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.underlying] the underlying asset, can be obtained from fetchUnderlyingAssets ()
 * @param {int} [params.expiration] unix timestamp of the expiration time
 * @returns {object} a list of [option chain structures]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
 */
func (this *Gate) FetchOptionChain(code string, options ...FetchOptionChainOptions) (OptionChain, error) {

    opts := FetchOptionChainOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchOptionChain(code, params)
    if IsError(res) {
        return OptionChain{}, CreateReturnError(res)
    }
    return NewOptionChain(res), nil
}
/**
 * @method
 * @name gate#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://www.gate.io/docs/developers/apiv4/#list-position-close-history
 * @see https://www.gate.io/docs/developers/apiv4/#list-position-close-history-2
 * @param {string[]} symbols unified conract symbols, must all have the same settle currency and the same market type
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum amount of records to fetch, default=1000
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] the latest time in ms to fetch positions for
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.offset] list offset, starting from 0
 * @param {string} [params.side] long or short
 * @param {string} [params.pnl] query profit or loss
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *Gate) FetchPositionsHistory(options ...FetchPositionsHistoryOptions) ([]Position, error) {

    opts := FetchPositionsHistoryOptionsStruct{}

    for _, opt := range options {
        opt(&opts)
    }

    var symbols interface{} = nil
    if opts.Symbols != nil {
        symbols = *opts.Symbols
    }

    var since interface{} = nil
    if opts.Since != nil {
        since = *opts.Since
    }

    var limit interface{} = nil
    if opts.Limit != nil {
        limit = *opts.Limit
    }

    var params interface{} = nil
    if opts.Params != nil {
        params = *opts.Params
    }
    res := <- this.Core.FetchPositionsHistory(symbols, since, limit, params)
    if IsError(res) {
        return nil, CreateReturnError(res)
    }
    return NewPositionArray(res), nil
}