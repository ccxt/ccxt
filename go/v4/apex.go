package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type apex struct {
    Exchange

}

func NewApexCore() apex {
   p := apex{}
   setDefaults(&p)
   return p
}

func  (this *apex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "apex",
        "name": "Apex",
        "countries": []interface{}{},
        "version": "v3",
        "rateLimit": 20,
        "certified": false,
        "pro": true,
        "dex": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": false,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "cancelOrdersForSymbols": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": false,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "editOrder": false,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledAndClosedOrders": false,
            "fetchCanceledOrders": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDeposits": false,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyLiquidations": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenInterests": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransfer": true,
            "fetchTransfers": true,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": true,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "2h": "120",
            "4h": "240",
            "6h": "360",
            "12h": "720",
            "1d": "D",
            "1w": "W",
            "1M": "M",
        },
        "hostname": "omni.apex.exchange",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/fef8f2f7-4265-46aa-965e-33a91881cb00",
            "api": map[string]interface{} {
                "public": "https://{hostname}/api",
                "private": "https://{hostname}/api",
            },
            "test": map[string]interface{} {
                "public": "https://testnet.omni.apex.exchange/api",
                "private": "https://testnet.omni.apex.exchange/api",
            },
            "www": "https://apex.exchange/",
            "doc": "https://api-docs.pro.apex.exchange",
            "fees": "https://apex-pro.gitbook.io/apex-pro/apex-omni-live-now/trading-perpetual-contracts/trading-fees",
            "referral": "https://omni.apex.exchange/trade",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "v3/symbols": 1,
                    "v3/history-funding": 1,
                    "v3/ticker": 1,
                    "v3/klines": 1,
                    "v3/trades": 1,
                    "v3/depth": 1,
                    "v3/time": 1,
                    "v3/data/all-ticker-info": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "v3/account": 1,
                    "v3/account-balance": 1,
                    "v3/fills": 1,
                    "v3/order-fills": 1,
                    "v3/order": 1,
                    "v3/history-orders": 1,
                    "v3/order-by-client-order-id": 1,
                    "v3/funding": 1,
                    "v3/historical-pnl": 1,
                    "v3/open-orders": 1,
                    "v3/transfers": 1,
                    "v3/transfer": 1,
                },
                "post": map[string]interface{} {
                    "v3/delete-open-orders": 1,
                    "v3/delete-client-order-id": 1,
                    "v3/delete-order": 1,
                    "v3/order": 1,
                    "v3/set-initial-margin-rate": 1,
                    "v3/transfer-out": 1,
                    "v3/contract-transfer-out": 1,
                },
            },
        },
        "httpExceptions": map[string]interface{} {
            "403": RateLimitExceeded,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "20006": "apikey sign error",
                "20016": "request para error",
                "10001": BadRequest,
            },
            "broad": map[string]interface{} {
                "ORDER_PRICE_MUST_GREETER_ZERO": InvalidOrder,
                "ORDER_POSSIBLE_LEAD_TO_ACCOUNT_LIQUIDATED": InvalidOrder,
                "ORDER_WITH_THIS_PRICE_CANNOT_REDUCE_POSITION_ONLY": InvalidOrder,
            },
        },
        "fees": map[string]interface{} {
            "swap": map[string]interface{} {
                "taker": this.ParseNumber("0.0005"),
                "maker": this.ParseNumber("0.0002"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "walletAddress": false,
            "privateKey": false,
            "password": true,
        },
        "precisionMode": TICK_SIZE,
        "commonCurrencies": map[string]interface{} {},
        "options": map[string]interface{} {
            "defaultType": "swap",
            "defaultSlippage": 0.05,
            "brokerId": "6956",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 200,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name apex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-system-time-v3
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *apex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV3Time(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
                //
            // {
            //    "data": {
            //    "time": 1738837534454
            //     }
            // }
        ch <- this.SafeInteger(data, "time")
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseBalance(response interface{}) interface{}  {
    //
    // {
    //     "totalEquityValue": "100.000000",
    //     "availableBalance": "100.000000",
    //     "initialMargin": "100.000000",
    //     "maintenanceMargin": "100.000000",
    //     "symbolToOraclePrice": {
    //     "BTC-USDC": {
    //         "oraclePrice": "20000",
    //             "createdTime": 124566
    //     }
    // }
    // }
    //
    var timestamp interface{} = this.Milliseconds()
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var code interface{} = "USDT"
    var account interface{} = this.Account()
    AddElementToObject(account, "free", this.SafeString(response, "availableBalance"))
    AddElementToObject(account, "total", this.SafeString(response, "totalEquityValue"))
    AddElementToObject(result, code, account)
    return this.SafeBalance(result)
}
/**
 * @method
 * @name apex#fetchBalance
 * @description query for account info
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *apex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3568 := (<-this.LoadMarkets())
            PanicOnError(retRes3568)
        
            response:= (<-this.PrivateGetV3AccountBalance(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseAccount(account interface{}) interface{}  {
    var accountId interface{} = this.SafeString(account, "id", "0")
    return map[string]interface{} {
        "id": accountId,
        "type": nil,
        "code": nil,
        "info": account,
    }
}
/**
 * @method
 * @name apex#fetchAccount
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *apex) FetchAccount(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3818 := (<-this.LoadMarkets())
            PanicOnError(retRes3818)
        
            response:= (<-this.PrivateGetV3Account(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseAccount(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-all-config-data-v3
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *apex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV3Symbols(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var spotConfig interface{} = this.SafeDict(data, "spotConfig", map[string]interface{} {})
            var multiChain interface{} = this.SafeDict(spotConfig, "multiChain", map[string]interface{} {})
            // "spotConfig": {
            //     "assets": [
            //         {
            //             "tokenId": "141",
            //             "token": "USDT",
            //             "displayName": "Tether USD Coin",
            //             "decimals": 18,
            //             "showStep": "0.01",
            //             "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Ethereum/Ethereum_USDT.svg",
            //             "l2WithdrawFee": "0",
            //             "enableCollateral": true,
            //             "enableCrossCollateral": false,
            //             "crossCollateralDiscountRate": null,
            //             "isGray": false
            //         }
            //     ],
            // "multiChain": {
            //  "chains": [
            //      {
            //          "chain": "Arbitrum One",
            //          "chainId": "9",
            //          "chainType": "0",
            //          "l1ChainId": "42161",
            //          "chainIconUrl": "https://static-pro.apex.exchange/chains/chain_logos/Arbitrum.svg",
            //          "contractAddress": "0x3169844a120c0f517b4eb4a750c08d8518c8466a",
            //          "swapContractAddress": "0x9e07b6Aef1bbD9E513fc2Eb8873e311E80B4f855",
            //          "stopDeposit": false,
            //          "feeLess": false,
            //          "gasLess": false,
            //          "gasToken": "ETH",
            //          "dynamicFee": true,
            //          "gasTokenDecimals": 18,
            //          "feeGasLimit": 300000,
            //          "blockTimeSeconds": 2,
            //          "rpcUrl": "https://arb.pro.apex.exchange",
            //          "minSwapUsdtAmount": "",
            //          "maxSwapUsdtAmount": "",
            //          "webRpcUrl": "https://arb.pro.apex.exchange",
            //          "webTxUrl": "https://arbiscan.io/tx/",
            //          "backupRpcUrl": "https://arb-mainnet.g.alchemy.com/v2/rGlYUbRHtUav5mfeThCPtsV9GLPt2Xq5",
            //          "txConfirm": 20,
            //          "withdrawGasFeeLess": false,
            //          "tokens": [
            //              {
            //                  "decimals": 6,
            //                  "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Arbitrum/Arbitrum_USDT.svg",
            //                  "token": "USDT",
            //                  "tokenAddress": "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
            //                  "pullOff": false,
            //                  "withdrawEnable": true,
            //                  "slippage": "",
            //                  "isDefaultToken": false,
            //                  "displayToken": "USDT",
            //                  "needResetApproval": true,
            //                  "minFee": "2",
            //                  "maxFee": "40",
            //                  "feeRate": "0.0001",
            //                  "maxWithdraw": "",
            //                  "minDeposit": "",
            //                  "minWithdraw": "",
            //                  "maxFastWithdrawAmount": "40000",
            //                  "minFastWithdrawAmount": "1",
            //                  "isGray": false
            //              },
            //              {
            //                  "decimals": 6,
            //                  "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Arbitrum/Arbitrum_USDC.svg",
            //                  "token": "USDC",
            //                  "tokenAddress": "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
            //                  "pullOff": false,
            //                  "withdrawEnable": true,
            //                  "slippage": "",
            //                  "isDefaultToken": false,
            //                  "displayToken": "USDC",
            //                  "needResetApproval": true,
            //                  "minFee": "2",
            //                  "maxFee": "20",
            //                  "feeRate": "0.0001",
            //                  "maxWithdraw": "",
            //                  "minDeposit": "",
            //                  "minWithdraw": "",
            //                  "maxFastWithdrawAmount": "1",
            //                  "minFastWithdrawAmount": "1",
            //                  "isGray": false
            //              }
            //          ]
            //        }
            //     ]
            // }
            var rows interface{} = this.SafeList(spotConfig, "assets", []interface{}{})
            var chains interface{} = this.SafeList(multiChain, "chains", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var currency interface{} = GetValue(rows, i)
                var currencyId interface{} = this.SafeString(currency, "token")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var name interface{} = this.SafeString(currency, "displayName")
                var networks interface{} = map[string]interface{} {}
                var minPrecision interface{} = nil
                var minWithdrawFeeString interface{} = nil
                var minWithdrawString interface{} = nil
                var deposit interface{} = false
                var withdraw interface{} = false
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var tokens interface{} = this.SafeList(chain, "tokens", []interface{}{})
                    for f := 0; IsLessThan(f, GetArrayLength(tokens)); f++ {
                        var token interface{} = GetValue(tokens, f)
                        var tokenName interface{} = this.SafeString(token, "token")
                        if IsTrue(IsEqual(tokenName, currencyId)) {
                            var networkId interface{} = this.SafeString(chain, "chainId")
                            var networkCode interface{} = this.NetworkIdToCode(networkId)
                            var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "decimals")))
                            minPrecision = Ternary(IsTrue((IsEqual(minPrecision, nil))), precision, mathMin(minPrecision, precision))
                            var depositAllowed interface{} =                     !IsTrue(this.SafeBool(chain, "stopDeposit"))
                            deposit = Ternary(IsTrue((depositAllowed)), depositAllowed, deposit)
                            var withdrawAllowed interface{} = this.SafeBool(token, "withdrawEnable")
                            withdraw = Ternary(IsTrue((withdrawAllowed)), withdrawAllowed, withdraw)
                            minWithdrawFeeString = this.SafeString(token, "minFee")
                            minWithdrawString = this.SafeString(token, "minWithdraw")
                            var minNetworkDepositString interface{} = this.SafeString(chain, "depositMin")
                            AddElementToObject(networks, networkCode, map[string]interface{} {
            "info": chain,
            "id": networkId,
            "network": networkCode,
            "active": IsTrue(depositAllowed) && IsTrue(withdrawAllowed),
            "deposit": depositAllowed,
            "withdraw": withdrawAllowed,
            "fee": this.ParseNumber(minWithdrawFeeString),
            "precision": precision,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minNetworkDepositString),
                    "max": nil,
                },
            },
        })
                        }
                    }
                }
                AddElementToObject(result, code, map[string]interface{} {
            "info": currency,
            "code": code,
            "id": currencyId,
            "type": "crypto",
            "name": name,
            "active": IsTrue(deposit) && IsTrue(withdraw),
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": this.ParseNumber(minWithdrawFeeString),
            "precision": minPrecision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchMarkets
 * @description retrieves data on all markets for apex
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-all-config-data-v3
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *apex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV3Symbols(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var contractConfig interface{} = this.SafeDict(data, "contractConfig", map[string]interface{} {})
            var perpetualContract interface{} = this.SafeList(contractConfig, "perpetualContract", []interface{}{})
        
                // {
            //     "perpetualContract":[
            //         {
            //             "baselinePositionValue": "50000.0000",
            //             "crossId": 30002,
            //             "crossSymbolId": 10,
            //             "crossSymbolName": "BTCUSDT",
            //             "digitMerge": "0.1,0.2,0.4,1,2",
            //             "displayMaxLeverage": "100",
            //             "displayMinLeverage": "1",
            //             "enableDisplay": true,
            //             "enableOpenPosition": true,
            //             "enableTrade": true,
            //             "fundingImpactMarginNotional": "6",
            //             "fundingInterestRate": "0.0003",
            //             "incrementalInitialMarginRate": "0.00250",
            //             "incrementalMaintenanceMarginRate": "0.00100",
            //             "incrementalPositionValue": "50000.0000",
            //             "initialMarginRate": "0.01",
            //             "maintenanceMarginRate": "0.005",
            //             "maxOrderSize": "50",
            //             "maxPositionSize": "100",
            //             "minOrderSize": "0.0010",
            //             "maxMarketPriceRange": "0.025",
            //             "settleAssetId": "USDT",
            //             "baseTokenId": "BTC",
            //             "stepSize": "0.001",
            //             "symbol": "BTC-USDT",
            //             "symbolDisplayName": "BTCUSDT",
            //             "tickSize": "0.1",
            //             "maxMaintenanceMarginRate": "0.5000",
            //             "maxPositionValue": "5000000.0000",
            //             "tagIconUrl": "https://static-pro.apex.exchange/icon/LABLE_HOT.svg",
            //             "tag": "HOT",
            //             "riskTip": false,
            //             "defaultInitialMarginRate": "0.05",
            //             "klineStartTime": 0,
            //             "maxMarketSizeBuffer": "0.98",
            //             "enableFundingSettlement": true,
            //             "indexPriceDecimals": 2,
            //             "indexPriceVarRate": "0.001",
            //             "openPositionOiLimitRate": "0.05",
            //             "fundingMaxRate": "0.000234",
            //             "fundingMinRate": "-0.000234",
            //             "fundingMaxValue": "",
            //             "enableFundingMxValue": true,
            //             "l2PairId": "50001",
            //             "settleTimeStamp": 0,
            //             "isPrelaunch": false,
            //             "riskLimitConfig": {},
            //             "category": "L1"
            //         }
            //     ]
            // }
        ch <- this.ParseMarkets(perpetualContract)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var id2 interface{} = this.SafeString(market, "crossSymbolName")
    var quoteId interface{} = this.SafeString(market, "l2PairId")
    var baseId interface{} = this.SafeString(market, "baseTokenId")
    var quote interface{} = this.SafeString(market, "settleAssetId")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var settleId interface{} = this.SafeString(market, "settleAssetId")
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(baseId, "/"), quote), ":"), settle)
    var expiry interface{} = 0
    var takerFee interface{} = this.ParseNumber("0.0002")
    var makerFee interface{} = this.ParseNumber("0.0005")
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "id2": id2,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": "swap",
        "spot": false,
        "margin": nil,
        "swap": true,
        "future": false,
        "option": false,
        "active": this.SafeBool(market, "enableTrade"),
        "contract": true,
        "linear": true,
        "inverse": false,
        "taker": takerFee,
        "maker": makerFee,
        "contractSize": this.SafeNumber(market, "minOrderSize"),
        "expiry": Ternary(IsTrue((IsEqual(expiry, 0))), nil, expiry),
        "expiryDatetime": Ternary(IsTrue((IsEqual(expiry, 0))), nil, this.Iso8601(expiry)),
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "stepSize"),
            "price": this.SafeNumber(market, "tickSize"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": this.SafeNumber(market, "displayMinLeverage"),
                "max": this.SafeNumber(market, "displayMaxLeverage"),
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minOrderSize"),
                "max": this.SafeNumber(market, "maxOrderSize"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
func  (this *apex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "symbol": "BTCUSDT",
    //     "price24hPcnt": "0.450141",
    //     "lastPrice": "43511.50",
    //     "highPrice24h": "43513.50",
    //     "lowPrice24h": "29996.00",
    //     "markPrice": "43513.50",
    //     "indexPrice": "40828.94",
    //     "openInterest": "2036854775808",
    //     "turnover24h": "5626085.23749999",
    //     "volume24h": "169.317",
    //     "fundingRate": "0",
    //     "predictedFundingRate": "0",
    //     "nextFundingTime": "10:00:00",
    //     "tradeCount": 100
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Milliseconds()
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var percentage interface{} = this.SafeString(ticker, "price24hPcnt")
    var quoteVolume interface{} = this.SafeString(ticker, "turnover24h")
    var baseVolume interface{} = this.SafeString(ticker, "volume24h")
    var high interface{} = this.SafeString(ticker, "highPrice24h")
    var low interface{} = this.SafeString(ticker, "lowPrice24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "markPrice": this.SafeString(ticker, "markPrice"),
        "indexPrice": this.SafeString(ticker, "indexPrice"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name apex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *apex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7778 := (<-this.LoadMarkets())
            PanicOnError(retRes7778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id2"),
            }
        
            response:= (<-this.PublicGetV3Ticker(this.Extend(request, params)))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data", []interface{}{})
            var rawTicker interface{} = this.SafeDict(tickers, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(rawTicker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchTickers
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
 * @param {string} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *apex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7988 := (<-this.LoadMarkets())
            PanicOnError(retRes7988)
        
            response:= (<-this.PublicGetV3DataAllTickerInfo(params))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-candlestick-chart-data-v3
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *apex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8188 := (<-this.LoadMarkets())
            PanicOnError(retRes8188)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
                "symbol": GetValue(market, "id2"),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 200 // default is 200 when requested with `since`
            }
            AddElementToObject(request, "limit", limit) // max 200, default 200
            requestparamsVariable := this.HandleUntilOption("end", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
        
            response:= (<-this.PublicGetV3Klines(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var OHLCVs interface{} = this.SafeList(data, GetValue(market, "id2"), []interface{}{})
        
            ch <- this.ParseOHLCVs(OHLCVs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  {
    //     "start": 1647511440000,
    //     "symbol": "BTC-USD",
    //     "interval": "1",
    //     "low": "40000",
    //     "high": "45000",
    //     "open": "45000",
    //     "close": "40000",
    //     "volume": "1.002",
    //     "turnover": "3"
    //  } {"s":"BTCUSDT","i":"1","t":1741265880000,"c":"90235","h":"90235","l":"90156","o":"90156","v":"0.052","tr":"4690.4466"}
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeIntegerN(ohlcv, []interface{}{"start", "t"}), this.SafeNumberN(ohlcv, []interface{}{"open", "o"}), this.SafeNumberN(ohlcv, []interface{}{"high", "h"}), this.SafeNumberN(ohlcv, []interface{}{"low", "l"}), this.SafeNumberN(ohlcv, []interface{}{"close", "c"}), this.SafeNumberN(ohlcv, []interface{}{"volume", "v"})}
}
/**
 * @method
 * @name apex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-market-depth-v3
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *apex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8738 := (<-this.LoadMarkets())
            PanicOnError(retRes8738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id2"),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100 // default is 200 when requested with `since`
            }
            AddElementToObject(request, "limit", limit) // max 100, default 100
        
            response:= (<-this.PublicGetV3Depth(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "a": [
            //     [
            //         "96576.3",
            //         "0.399"
            //     ],
            //     [
            //         "96577.6",
            //         "0.106"
            //     ]
            // ],
            //     "b": [
            //     [
            //         "96565.2",
            //         "0.131"
            //     ],
            //     [
            //         "96565.1",
            //         "0.038"
            //     ]
            // ],
            //     "s": "BTCUSDT",
            //     "u": 18665465
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.Milliseconds()
            var orderbook interface{} = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "b", "a")
            AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "u"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-newest-trading-data-v3
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *apex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9308 := (<-this.LoadMarkets())
            PanicOnError(retRes9308)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id2"),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 500 // default is 50
            }
            AddElementToObject(request, "limit", limit)
        
            response:= (<-this.PublicGetV3Trades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // [
            //  {
            //      "i": "993f7f85-9215-5723-9078-2186ae140847",
            //      "p": "96534.3",
            //      "S": "Sell",
            //      "v": "0.261",
            //      "s": "BTCUSDT",
            //      "T": 1739118072710
            //  },
            //  {
            //      "i": "c947c9cf-8c18-5784-89c3-91bdf86ddde8",
            //      "p": "96513.5",
            //      "S": "Sell",
            //      "v": "0.042",
            //      "s": "BTCUSDT",
            //      "T": 1739118075944
            //  }
            //  ]
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // [
    //  {
    //      "i": "993f7f85-9215-5723-9078-2186ae140847",
    //      "p": "96534.3",
    //      "S": "Sell",
    //      "v": "0.261",
    //      "s": "BTCUSDT",
    //      "T": 1739118072710
    //  }
    //  ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeStringN(trade, []interface{}{"s", "symbol"})
    market = this.SafeMarket(marketId, market)
    var id interface{} = this.SafeStringN(trade, []interface{}{"i", "id"})
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"t", "T", "createdAt"})
    var priceString interface{} = this.SafeStringN(trade, []interface{}{"p", "price"})
    var amountString interface{} = this.SafeStringN(trade, []interface{}{"v", "size"})
    var side interface{} = this.SafeStringLowerN(trade, []interface{}{"S", "side"})
    var typeVar interface{} = this.SafeStringN(trade, []interface{}{"type"})
    var fee interface{} = this.SafeStringN(trade, []interface{}{"fee"})
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "takerOrMaker": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name apex#fetchOpenInterest
 * @description retrieves the open interest of a contract trading pair
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *apex) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10138 := (<-this.LoadMarkets())
            PanicOnError(retRes10138)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id2"),
            }
        
            response:= (<-this.PublicGetV3Ticker(this.Extend(request, params)))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data", []interface{}{})
            var rawTicker interface{} = this.SafeDict(tickers, 0, map[string]interface{} {})
        
            ch <- this.ParseOpenInterest(rawTicker, market)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "symbol": "BTCUSDT",
    //     "price24hPcnt": "0.450141",
    //     "lastPrice": "43511.50",
    //     "highPrice24h": "43513.50",
    //     "lowPrice24h": "29996.00",
    //     "markPrice": "43513.50",
    //     "indexPrice": "40828.94",
    //     "openInterest": "2036854775808",
    //     "turnover24h": "5626085.23749999",
    //     "volume24h": "169.317",
    //     "fundingRate": "0",
    //     "predictedFundingRate": "0",
    //     "nextFundingTime": "10:00:00",
    //     "tradeCount": 100
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Milliseconds()
    var marketId interface{} = this.SafeString(interest, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": symbol,
        "openInterestAmount": this.SafeString(interest, "openInterest"),
        "openInterestValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": interest,
    }, market)
}
/**
 * @method
 * @name apex#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-funding-rate-history-v3
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *apex) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes10748 := (<-this.LoadMarkets())
            PanicOnError(retRes10748)
            var request interface{} = map[string]interface{} {}
            var market interface{} = this.Market(symbol)
            AddElementToObject(request, "symbol", GetValue(market, "id"))
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "beginTimeInclusive", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var page interface{} = this.SafeInteger(params, "page")
            if IsTrue(!IsEqual(page, nil)) {
                AddElementToObject(request, "page", page)
            }
            var endTimeExclusive interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            if IsTrue(!IsEqual(endTimeExclusive, nil)) {
                AddElementToObject(request, "endTimeExclusive", endTimeExclusive)
            }
        
            response:= (<-this.PublicGetV3HistoryFunding(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "historyFunds": [
            //     {
            //         "symbol": "BTC-USD",
            //         "rate": "0.0000125000",
            //         "price": "31297.5000008009374142",
            //         "fundingTime": 12315555,
            //         "fundingTimestamp": 12315555
            //     }
            // ],
            //     "totalSize": 11
            // }
            //
            var rates interface{} = []interface{}{}
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var resultList interface{} = this.SafeList(data, "historyFunds", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(resultList)); i++ {
                var entry interface{} = GetValue(resultList, i)
                var timestamp interface{} = this.SafeInteger(entry, "fundingTimestamp")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeString(entry, "symbol"),
                    "fundingRate": this.SafeNumber(entry, "rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "1234",
    //     "clientId": "1234",
    //     "accountId": "12345",
    //     "symbol": "BTC-USD",
    //     "side": "SELL",
    //     "price": "18000",
    //     "limitFee": "100",
    //     "fee": "100",
    //     "triggerPrice": "1.2",
    //     "trailingPercent": "0.12",
    //     "size": "100",
    //     "remainingSize": "100",
    //     "type": "LIMIT",
    //     "createdAt": 1647502440973,
    //     "updatedTime": 1647502440973,
    //     "expiresAt": 1647502440973,
    //     "status": "PENDING",
    //     "timeInForce": "GOOD_TIL_CANCEL",
    //     "postOnly": false,
    //     "reduceOnly": false,
    //     "stopPnl": false,
    //     "latestMatchFillPrice": "reason",
    //     "cumMatchFillSize": "0.1",
    //     "cumMatchFillValue": "1000",
    //     "cumMatchFillFee": "1",
    //     "cumSuccessFillSize": "0.1",
    //     "cumSuccessFillValue": "1000",
    //     "cumSuccessFillFee": "1",
    //     "triggerPriceType": "INDEX",
    //     "isOpenTpslOrder": true,
    //     "isSetOpenTp": true,
    //     "isSetOpenSl": false,
    //     "openTpParam": {
    //     "side": "SELL",
    //         "price": "18000",
    //         "limitFee": "100",
    //         "clientOrderId": "111100",
    //         "triggerPrice": "1.2",
    //         "trailingPercent": "0.12",
    //         "size": "100"
    // },
    //     "openSlParam": {
    //     "side": "SELL",
    //         "price": "18000",
    //         "limitFee": "100",
    //         "clientOrderId": "111100",
    //         "triggerPrice": "1.2",
    //         "trailingPercent": "0.12",
    //         "size": "100"
    // }
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "createdAt")
    var orderId interface{} = this.SafeString(order, "id")
    var clientOrderId interface{} = this.SafeString(order, "clientId")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "size")
    var orderType interface{} = this.SafeString(order, "type")
    var status interface{} = this.SafeString(order, "status")
    var side interface{} = this.SafeStringLower(order, "side")
    // const average = this.omitZero (this.safeString (order, 'avg_fill_price'));
    var remaining interface{} = this.OmitZero(this.SafeString(order, "remainingSize"))
    var lastUpdateTimestamp interface{} = this.SafeInteger(order, "updatedTime")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": this.ParseOrderType(orderType),
        "timeInForce": this.ParseTimeInForce(this.SafeString(order, "timeInForce")),
        "postOnly": this.SafeBool(order, "postOnly"),
        "reduceOnly": this.SafeBool(order, "reduceOnly"),
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString(order, "triggerPrice"),
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "average": nil,
        "amount": amount,
        "filled": nil,
        "remaining": remaining,
        "cost": nil,
        "trades": nil,
        "fee": map[string]interface{} {
            "cost": this.SafeString(order, "fee"),
            "currency": GetValue(market, "settleId"),
        },
        "info": order,
    }, market)
}
func  (this *apex) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "GOOD_TIL_CANCEL": "GOOD_TIL_CANCEL",
        "FILL_OR_KILL": "FILL_OR_KILL",
        "IMMEDIATE_OR_CANCEL": "IMMEDIATE_OR_CANCEL",
        "POST_ONLY": "POST_ONLY",
    }
    return this.SafeString(timeInForces, timeInForce, nil)
}
func  (this *apex) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "PENDING": "open",
            "OPEN": "open",
            "FILLED": "filled",
            "CANCELING": "canceled",
            "CANCELED": "canceled",
            "UNTRIGGERED": "open",
        }
        return this.SafeString(statuses, status, status)
    }
    return status
}
func  (this *apex) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "LIMIT": "LIMIT",
        "MARKET": "MARKET",
        "STOP_LIMIT": "STOP_LIMIT",
        "STOP_MARKET": "STOP_MARKET",
        "TAKE_PROFIT_LIMIT": "TAKE_PROFIT_LIMIT",
        "TAKE_PROFIT_MARKET": "TAKE_PROFIT_MARKET",
    }
    return this.SafeStringUpper(types, typeVar, typeVar)
}
func  (this *apex) SafeMarket(optionalArgs ...interface{}) interface{}  {
    marketId := GetArg(optionalArgs, 0, nil)
    _ = marketId
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    if IsTrue(IsTrue(IsEqual(market, nil)) && IsTrue(!IsEqual(marketId, nil))) {
        if IsTrue(InOp(this.Markets, marketId)) {
            market = GetValue(this.Markets, marketId)
        } else if IsTrue(InOp(this.Markets_by_id, marketId)) {
            market = GetValue(this.Markets_by_id, marketId)
        } else {
            var newMarketId interface{} = this.AddHyphenBeforeUsdt(marketId)
            if IsTrue(InOp(this.Markets_by_id, newMarketId)) {
                var markets interface{} = GetValue(this.Markets_by_id, newMarketId)
                var numMarkets interface{} =                 GetArrayLength(markets)
                if IsTrue(IsGreaterThan(numMarkets, 0)) {
                    if IsTrue(IsEqual(GetValue(GetValue(GetValue(this.Markets_by_id, newMarketId), 0), "id2"), marketId)) {
                        market = GetValue(GetValue(this.Markets_by_id, newMarketId), 0)
                    }
                }
            }
        }
    }
    return this.Exchange.SafeMarket(marketId, market, delimiter, marketType)
}
func  (this *apex) GenerateRandomClientIdOmni(_accountId interface{}) interface{}  {
    var accountId interface{} = IsTrue(_accountId) || IsTrue(ToString(this.RandNumber(12)))
    return Add(Add(Add(Add(Add("apexomni-", accountId), "-"), ToString(this.Milliseconds())), "-"), ToString(this.RandNumber(6)))
}
func  (this *apex) AddHyphenBeforeUsdt(symbol interface{}) interface{}  {
    var uppercaseSymbol interface{} = ToUpper(symbol)
    var index interface{} = GetIndexOf(uppercaseSymbol, "USDT")
    var symbolChar interface{} = this.SafeString(symbol, Subtract(index, 1))
    if IsTrue(IsTrue(IsGreaterThan(index, 0)) && IsTrue(!IsEqual(symbolChar, "-"))) {
        return Add(Add(Slice(symbol, 0, index), "-"), Slice(symbol, index, nil))
    }
    return symbol
}
func  (this *apex) GetSeeds() interface{}  {
    var seeds interface{} = this.SafeString(this.Options, "seeds")
    if IsTrue(IsEqual(seeds, nil)) {
        panic(ArgumentsRequired(Add(this.Id, " the \"seeds\" key is required in the options to access private endpoints. You can find it in API Management > Omni Key, and then set it as exchange.options[\"seeds\"] = XXXX")))
    }
    return seeds
}
func  (this *apex) GetAccountId() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var accountId interface{} = this.SafeString(this.Options, "accountId", "0")
        if IsTrue(IsEqual(accountId, "0")) {
        
            accountData:= (<-this.FetchAccount())
            PanicOnError(accountData)
            AddElementToObject(this.Options, "accountId", this.SafeString(accountData, "id", "0"))
        }
        
        ch <- GetValue(this.Options, "accountId")
        return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#createOrder
 * @description create a trade order
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-creating-orders
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {string} [params.timeInForce] "GTC", "IOC", or "POST_ONLY"
 * @param {bool} [params.postOnly] true or false
 * @param {bool} [params.reduceOnly] Ensures that the executed order does not flip the opened position.
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13368 := (<-this.LoadMarkets())
            PanicOnError(retRes13368)
            var market interface{} = this.Market(symbol)
            var orderType interface{} = ToUpper(typeVar)
            var orderSide interface{} = ToUpper(side)
            var orderSize interface{} = this.AmountToPrecision(symbol, amount)
            var orderPrice interface{} = "0"
            if IsTrue(!IsEqual(price, nil)) {
                orderPrice = this.PriceToPrecision(symbol, price)
            }
            var fees interface{} = this.SafeDict(this.Fees, "swap", map[string]interface{} {})
            var taker interface{} = this.SafeNumber(fees, "taker", 0.0005)
            var maker interface{} = this.SafeNumber(fees, "maker", 0.0002)
            var limitFee interface{} = this.DecimalToPrecision(Precise.StringAdd(Precise.StringMul(Precise.StringMul(orderPrice, orderSize), ToString(taker)), ToString(GetValue(GetValue(market, "precision"), "price"))), TRUNCATE, GetValue(GetValue(market, "precision"), "price"), this.PrecisionMode, this.PaddingMode)
            var timeNow interface{} = this.Milliseconds()
            // const triggerPrice = this.safeString2 (params, 'triggerPrice', 'stopPrice');
            var isMarket interface{} = IsEqual(orderType, "MARKET")
            if IsTrue(IsTrue(isMarket) && IsTrue((IsEqual(price, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument for market orders")))
            }
            var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
            var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
            if IsTrue(IsEqual(timeInForce, nil)) {
                timeInForce = "GOOD_TIL_CANCEL"
            }
            if !IsTrue(isMarket) {
                if IsTrue(postOnly) {
                    timeInForce = "POST_ONLY"
                } else if IsTrue(IsEqual(timeInForce, "ioc")) {
                    timeInForce = "IMMEDIATE_OR_CANCEL"
                }
            }
            params = this.Omit(params, "timeInForce")
            params = this.Omit(params, "postOnly")
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
        
            accountId:= (<-this.GetAccountId())
            PanicOnError(accountId)
            if IsTrue(IsEqual(clientOrderId, nil)) {
                clientOrderId = this.GenerateRandomClientIdOmni(accountId)
            }
            params = this.Omit(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
            var orderToSign interface{} = map[string]interface{} {
                "accountId": accountId,
                "slotId": clientOrderId,
                "nonce": clientOrderId,
                "pairId": GetValue(market, "quoteId"),
                "size": orderSize,
                "price": orderPrice,
                "direction": orderSide,
                "makerFeeRate": ToString(maker),
                "takerFeeRate": ToString(taker),
            }
        
            signature:= (<-this.GetZKContractSignatureObj(this.Remove0xPrefix(this.GetSeeds()), orderToSign))
            PanicOnError(signature)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": orderSide,
                "type": orderType,
                "size": orderSize,
                "price": orderPrice,
                "limitFee": limitFee,
                "expiration": MathFloor(Add(Divide(timeNow, 1000), Multiply(Multiply(Multiply(30, 24), 60), 60))),
                "timeInForce": timeInForce,
                "clientId": clientOrderId,
                "brokerId": this.SafeString(this.Options, "brokerId", "6956"),
            }
            AddElementToObject(request, "signature", signature)
        
            response:= (<-this.PrivatePostV3Order(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#transfer
 * @description transfer currency internally between wallets on the same account
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.transferId] UUID, which is unique across the platform
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *apex) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14188 := (<-this.LoadMarkets())
            PanicOnError(retRes14188)
        
            configResponse:= (<-this.PublicGetV3Symbols(params))
            PanicOnError(configResponse)
            var configData interface{} = this.SafeDict(configResponse, "data", map[string]interface{} {})
            var contractConfig interface{} = this.SafeDict(configData, "contractConfig", map[string]interface{} {})
            var contractAssets interface{} = this.SafeList(contractConfig, "assets", []interface{}{})
            var spotConfig interface{} = this.SafeDict(configData, "spotConfig", map[string]interface{} {})
            var spotAssets interface{} = this.SafeList(spotConfig, "assets", []interface{}{})
            var globalConfig interface{} = this.SafeDict(spotConfig, "global", map[string]interface{} {})
            var receiverAddress interface{} = this.SafeString(globalConfig, "contractAssetPoolEthAddress", "")
            var receiverZkAccountId interface{} = this.SafeString(globalConfig, "contractAssetPoolZkAccountId", "")
            var receiverSubAccountId interface{} = this.SafeString(globalConfig, "contractAssetPoolSubAccount", "")
            var receiverAccountId interface{} = this.SafeString(globalConfig, "contractAssetPoolAccountId", "")
        
            accountResponse:= (<-this.PrivateGetV3Account(params))
            PanicOnError(accountResponse)
            var accountData interface{} = this.SafeDict(accountResponse, "data", map[string]interface{} {})
            var spotAccount interface{} = this.SafeDict(accountData, "spotAccount", map[string]interface{} {})
            var zkAccountId interface{} = this.SafeString(spotAccount, "zkAccountId", "")
            var subAccountId interface{} = this.SafeString(spotAccount, "defaultSubAccountId", "0")
            var subAccounts interface{} = this.SafeList(spotAccount, "subAccounts", []interface{}{})
            var nonce interface{} = "0"
            if IsTrue(IsGreaterThan(GetArrayLength(subAccounts), 0)) {
                nonce = this.SafeString(GetValue(subAccounts, 0), "nonce", "0")
            }
            var ethAddress interface{} = this.SafeString(accountData, "ethereumAddress", "")
            var accountId interface{} = this.SafeString(accountData, "id", "")
            var currency interface{} = map[string]interface{} {}
            var assets interface{} = []interface{}{}
            if IsTrue(IsTrue(!IsEqual(fromAccount, nil)) && IsTrue(IsEqual(ToLower(fromAccount), "contract"))) {
                assets = contractAssets
            } else {
                assets = spotAssets
            }
            for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
                if IsTrue(IsEqual(this.SafeString(GetValue(assets, i), "token", ""), code)) {
                    currency = GetValue(assets, i)
                }
            }
            var tokenId interface{} = this.SafeString(currency, "tokenId", "")
            var amountNumber interface{} = this.ParseToInt(Multiply(amount, (MathPow(10, this.SafeNumber(currency, "decimals", 0)))))
            var timestampSeconds interface{} = this.ParseToInt(Divide(this.Milliseconds(), 1000))
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
            if IsTrue(IsEqual(clientOrderId, nil)) {
                clientOrderId = this.GenerateRandomClientIdOmni(this.SafeString(this.Options, "accountId"))
            }
            params = this.Omit(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
            if IsTrue(IsTrue(!IsEqual(fromAccount, nil)) && IsTrue(IsEqual(ToLower(fromAccount), "contract"))) {
                var formattedUint32 interface{} = "4294967295"
                var zkSignAccountId interface{} = Precise.StringMod(accountId, formattedUint32)
                var expireTime interface{} = Add(timestampSeconds, Multiply(Multiply(3600, 24), 28))
                var orderToSign interface{} = map[string]interface{} {
                    "zkAccountId": zkSignAccountId,
                    "receiverAddress": ethAddress,
                    "subAccountId": subAccountId,
                    "receiverSubAccountId": subAccountId,
                    "tokenId": tokenId,
                    "amount": ToString(amountNumber),
                    "fee": "0",
                    "nonce": clientOrderId,
                    "timestampSeconds": expireTime,
                    "isContract": true,
                }
        
                signature:= (<-this.GetZKTransferSignatureObj(this.Remove0xPrefix(this.GetSeeds()), orderToSign))
                PanicOnError(signature)
                var request interface{} = map[string]interface{} {
                    "amount": amount,
                    "expireTime": expireTime,
                    "clientWithdrawId": clientOrderId,
                    "signature": signature,
                    "token": code,
                    "ethAddress": ethAddress,
                }
        
                response:= (<-this.PrivatePostV3ContractTransferOut(this.Extend(request, params)))
                PanicOnError(response)
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                var currentTime interface{} = this.Milliseconds()
        
                ch <- this.Extend(this.ParseTransfer(data, this.Currency(code)), map[string]interface{} {
                    "timestamp": currentTime,
                    "datetime": this.Iso8601(currentTime),
                    "amount": this.ParseNumber(amount),
                    "fromAccount": "contract",
                    "toAccount": "spot",
                })
                return nil
            } else {
                var orderToSign interface{} = map[string]interface{} {
                    "zkAccountId": zkAccountId,
                    "receiverAddress": receiverAddress,
                    "subAccountId": subAccountId,
                    "receiverSubAccountId": receiverSubAccountId,
                    "tokenId": tokenId,
                    "amount": ToString(amountNumber),
                    "fee": "0",
                    "nonce": nonce,
                    "timestampSeconds": timestampSeconds,
                }
        
                signature:= (<-this.GetZKTransferSignatureObj(this.Remove0xPrefix(this.GetSeeds()), orderToSign))
                PanicOnError(signature)
                var request interface{} = map[string]interface{} {
                    "amount": ToString(amount),
                    "timestamp": timestampSeconds,
                    "clientTransferId": clientOrderId,
                    "signature": signature,
                    "zkAccountId": zkAccountId,
                    "subAccountId": subAccountId,
                    "fee": "0",
                    "token": code,
                    "tokenId": tokenId,
                    "receiverAccountId": receiverAccountId,
                    "receiverZkAccountId": receiverZkAccountId,
                    "receiverSubAccountId": receiverSubAccountId,
                    "receiverAddress": receiverAddress,
                    "nonce": nonce,
                }
        
                response:= (<-this.PrivatePostV3TransferOut(this.Extend(request, params)))
                PanicOnError(response)
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                var currentTime interface{} = this.Milliseconds()
        
                ch <- this.Extend(this.ParseTransfer(data, this.Currency(code)), map[string]interface{} {
                    "timestamp": currentTime,
                    "datetime": this.Iso8601(currentTime),
                    "amount": this.ParseNumber(amount),
                    "fromAccount": "spot",
                    "toAccount": "contract",
                })
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *apex) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "coin")
    var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
    var fromAccount interface{} = this.SafeString(transfer, "fromAccount")
    var toAccount interface{} = this.SafeString(transfer, "toAccount")
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeStringN(transfer, []interface{}{"transferId", "id"}),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": fromAccount,
        "toAccount": toAccount,
        "status": this.SafeString(transfer, "status"),
    }
}
/**
 * @method
 * @name apex#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-cancel-all-open-orders
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15678 := (<-this.LoadMarkets())
            PanicOnError(retRes15678)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostV3DeleteOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- data
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#cancelOrder
 * @description cancels an open order
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-cancel-order
 * @param {string} id order id
 * @param symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
            var response interface{} = nil
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "id", clientOrderId)
                params = this.Omit(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
                
        response = (<-this.PrivatePostV3DeleteClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "id", id)
                
        response = (<-this.PrivatePostV3DeleteOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- data
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-order-id
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-order-by-clientorderid
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16188 := (<-this.LoadMarkets())
            PanicOnError(retRes16188)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
            var response interface{} = nil
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "id", clientOrderId)
                params = this.Omit(params, []interface{}{"clientId", "clientOrderId", "client_order_id"})
                
        response = (<-this.PrivateGetV3OrderByClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "id", id)
                
        response = (<-this.PrivateGetV3Order(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-open-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16468 := (<-this.LoadMarkets())
            PanicOnError(retRes16468)
        
            response:= (<-this.PrivateGetV3OpenOrders(params))
            PanicOnError(response)
            var orders interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(orders, nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchOrders
 * @description fetches information on multiple orders made by the user *classic accounts only*
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-all-order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve, default 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.until] end time, ms
 * @param {boolean} [params.status] "PENDING", "OPEN", "FILLED", "CANCELED", "EXPIRED", "UNTRIGGERED"
 * @param {boolean} [params.side] BUY or SELL
 * @param {string} [params.type] "LIMIT", "MARKET","STOP_LIMIT", "STOP_MARKET", "TAKE_PROFIT_LIMIT","TAKE_PROFIT_MARKET"
 * @param {string} [params.orderType] "ACTIVE","CONDITION","HISTORY"
 * @param {boolean} [params.page] Page numbers start from 0
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *apex) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16708 := (<-this.LoadMarkets())
            PanicOnError(retRes16708)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "beginTimeInclusive", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var endTimeExclusive interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            if IsTrue(!IsEqual(endTimeExclusive, nil)) {
                AddElementToObject(request, "endTimeExclusive", endTimeExclusive)
                params = this.Omit(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            }
        
            response:= (<-this.PrivateGetV3HistoryOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-trade-history
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *apex) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17078 := (<-this.LoadMarkets())
            PanicOnError(retRes17078)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "clientId"})
        
            response:= (<-this.PrivateGetV3OrderFills(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders", []interface{}{})
        
            ch <- this.ParseTrades(orders, nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchMyTrades
 * @description fetches information on multiple orders made by the user *classic accounts only*
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-trade-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve, default 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.until] end time
 * @param {boolean} [params.side] BUY or SELL
 * @param {string} [params.orderType] "LIMIT", "MARKET","STOP_LIMIT", "STOP_MARKET", "TAKE_PROFIT_LIMIT","TAKE_PROFIT_MARKET"
 * @param {boolean} [params.page] Page numbers start from 0
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *apex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17388 := (<-this.LoadMarkets())
            PanicOnError(retRes17388)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "beginTimeInclusive", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var endTimeExclusive interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            if IsTrue(!IsEqual(endTimeExclusive, nil)) {
                AddElementToObject(request, "endTimeExclusive", endTimeExclusive)
                params = this.Omit(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            }
        
            response:= (<-this.PrivateGetV3Fills(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders", []interface{}{})
        
            ch <- this.ParseTrades(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchFundingHistory
 * @description fetches information on multiple orders made by the user *classic accounts only*
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-funding-rate
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve, default 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.until] end time, ms
 * @param {boolean} [params.side] BUY or SELL
 * @param {boolean} [params.page] Page numbers start from 0
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *apex) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17778 := (<-this.LoadMarkets())
            PanicOnError(retRes17778)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "beginTimeInclusive", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var endTimeExclusive interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "endTimeExclusive", "until"})
            if IsTrue(!IsEqual(endTimeExclusive, nil)) {
                params = this.Omit(params, []interface{}{"endTime", "endTimeExclusive", "until"})
                AddElementToObject(request, "endTimeExclusive", endTimeExclusive)
            }
        
            response:= (<-this.PrivateGetV3Funding(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fundingValues interface{} = this.SafeList(data, "fundingValues", []interface{}{})
        
            ch <- this.ParseIncomes(fundingValues, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "1234",
    //     "symbol": "BTC-USDT",
    //     "fundingValue": "10000",
    //     "rate": "0.0000125000",
    //     "positionSize": "500",
    //     "price": "90",
    //     "side": "LONG",
    //     "status": "SUCCESS",
    //     "fundingTime": 1647502440973,
    //     "transactionId": "1234556"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var code interface{} = "USDT"
    var timestamp interface{} = this.SafeInteger(income, "fundingTime")
    return map[string]interface{} {
        "info": income,
        "symbol": this.SafeSymbol(marketId, market),
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(income, "id"),
        "amount": this.SafeNumber(income, "fundingValue"),
        "rate": this.SafeNumber(income, "rate"),
    }
}
/**
 * @method
 * @name apex#setLeverage
 * @description set the level of leverage for a market
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-sets-the-initial-margin-rate-of-a-contract
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *apex) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes18468 := (<-this.LoadMarkets())
            PanicOnError(retRes18468)
            var market interface{} = this.Market(symbol)
            var leverageString interface{} = this.NumberToString(leverage)
            var initialMarginRate interface{} = Precise.StringDiv("1", leverageString, 4)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "initialMarginRate": initialMarginRate,
            }
        
            response:= (<-this.PrivatePostV3SetInitialMarginRate(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- data
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#fetchPositions
 * @description fetch all open positions
 * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-data
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *apex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18698 := (<-this.LoadMarkets())
            PanicOnError(retRes18698)
        
            response:= (<-this.PrivateGetV3Account(params))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(data, "positions", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *apex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "symbol": "BTC-USDT",
    //     "status": "",
    //     "side": "LONG",
    //     "size": "0.000",
    //     "entryPrice": "0.00",
    //     "exitPrice": "",
    //     "createdAt": 1690366452416,
    //     "updatedTime": 1690366452416,
    //     "fee": "0.000000",
    //     "fundingFee": "0.000000",
    //     "lightNumbers": "",
    //     "customInitialMarginRate": "0"
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var side interface{} = this.SafeStringLower(position, "side")
    var quantity interface{} = this.SafeString(position, "size")
    var timestamp interface{} = this.SafeInteger(position, "updatedTime")
    var leverage interface{} = 20
    var customInitialMarginRate interface{} = this.SafeStringN(position, []interface{}{"customInitialMarginRate", "customImr"}, "0")
    if IsTrue(!IsEqual(this.PrecisionFromString(customInitialMarginRate), 0)) {
        leverage = this.ParseToInt(Precise.StringDiv("1", customInitialMarginRate, 4))
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "id"),
        "symbol": symbol,
        "entryPrice": this.SafeString(position, "entryPrice"),
        "markPrice": nil,
        "notional": nil,
        "collateral": nil,
        "unrealizedPnl": nil,
        "side": side,
        "contracts": this.ParseNumber(quantity),
        "contractSize": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "hedged": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": leverage,
        "liquidationPrice": nil,
        "marginRatio": nil,
        "marginMode": nil,
        "percentage": nil,
    })
}
func  (this *apex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api)), "/"), path)
    headers = map[string]interface{} {
        "User-Agent": "apex-CCXT",
        "Accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
    }
    var signPath interface{} = Add("/api/", path)
    var signBody interface{} = body
    if IsTrue(!IsEqual(ToUpper(method), "POST")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            signPath = Add(signPath, Add("?", this.Rawencode(params)))
            url = Add(url, Add("?", this.Rawencode(params)))
        }
    } else {
        var sortedQuery interface{} = this.Keysort(params)
        signBody = this.Rawencode(sortedQuery)
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Milliseconds())
        var messageString interface{} = Add(Add(timestamp, ToUpper(method)), signPath)
        if IsTrue(!IsEqual(signBody, nil)) {
            messageString = Add(messageString, signBody)
        }
        var signature interface{} = this.Hmac(this.Encode(messageString), this.Encode(this.StringToBase64(this.Secret)), sha256, "base64")
        AddElementToObject(headers, "APEX-SIGNATURE", signature)
        AddElementToObject(headers, "APEX-API-KEY", this.ApiKey)
        AddElementToObject(headers, "APEX-TIMESTAMP", timestamp)
        AddElementToObject(headers, "APEX-PASSPHRASE", this.Password)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": signBody,
        "headers": headers,
    }
}
func  (this *apex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    // {"code":3,"msg":"Order price must be greater than 0. Order price is 0.","key":"ORDER_PRICE_MUST_GREETER_ZERO","detail":{"price":"0"}}
    // {"code":400,"msg":"strconv.ParseInt: parsing \"dsfdfsd\": invalid syntax","timeCost":5320995}
    //
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorCode interface{} = this.SafeInteger(response, "code")
    if IsTrue(IsTrue(!IsEqual(errorCode, nil)) && IsTrue(!IsEqual(errorCode, 0))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString2(response, "key", "msg")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        var status interface{} = ToString(code)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), status, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *apex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
