package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type tradeogre struct {
    Exchange

}

func NewTradeogreCore() tradeogre {
   p := tradeogre{}
   setDefaults(&p)
   return p
}

func  (this *tradeogre) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "tradeogre",
        "name": "tradeogre",
        "countries": []interface{}{},
        "rateLimit": 100,
        "version": "v2",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createMarketOrder": false,
            "createOrder": true,
            "createOrders": false,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": false,
            "fetchLedgerEntry": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawAddresses": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": false,
            "withdraw": false,
        },
        "urls": map[string]interface{} {
            "referral": "",
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/3aa748b7-ea44-45e9-a9e7-b1d207a2578a",
            "api": map[string]interface{} {
                "rest": "https://tradeogre.com/api/v1",
            },
            "www": "https://tradeogre.com",
            "doc": "https://tradeogre.com/help/api",
            "fees": "https://tradeogre.com/help/fees",
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "markets": 1,
                    "orders/{market}": 1,
                    "ticker/{market}": 1,
                    "history/{market}": 1,
                    "chart/{interval}/{market}/{timestamp}": 1,
                    "chart/{interval}/{market}": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account/balances": 1,
                    "account/order/{uuid}": 1,
                },
                "post": map[string]interface{} {
                    "order/buy": 1,
                    "order/sell": 1,
                    "order/cancel": 1,
                    "orders": 1,
                    "account/orders": 1,
                    "account/balance": 1,
                },
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Must be authorized": AuthenticationError,
                "Market not found": BadRequest,
                "Insufficient funds": InsufficientFunds,
                "Order not found": BadRequest,
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "15m": "15m",
            "1h": "1h",
            "4h": "4h",
            "1d": "1d",
            "1w": "1w",
        },
        "options": map[string]interface{} {},
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name tradeogre#fetchMarkets
 * @description retrieves data on all markets for bigone
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *tradeogre) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
            //
            //   [
            //       {
            //          "AEON-BTC": {
            //             "initialprice": "0.00022004",
            //             "price": "0.00025992",
            //             "high": "0.00025992",
            //             "low": "0.00022003",
            //             "volume": "0.00359066",
            //             "bid": "0.00022456",
            //             "ask": "0.00025993"
            //          }
            //       }
            //   ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var rawMarket interface{} = GetValue(response, i)
                var keys interface{} = ObjectKeys(rawMarket)
                var id interface{} = this.SafeString(keys, 0)
                var keyParts interface{} = Split(id, "-")
                var baseId interface{} = this.SafeString(keyParts, 0)
                var quoteId interface{} = this.SafeString(keyParts, 1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var market interface{} = this.SafeMarketStructure(map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "taker": GetValue(GetValue(this.Fees, "trading"), "taker"),
                    "maker": GetValue(GetValue(this.Fees, "trading"), "maker"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision("8")),
                        "price": this.ParseNumber(this.ParsePrecision("8")),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": rawMarket,
                })
                AppendToArray(&result,market)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *tradeogre) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3298 := (<-this.LoadMarkets())
            PanicOnError(retRes3298)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickerMarket(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //   {
            //       "success":true,
            //       "initialprice":"0.02502002",
            //       "price":"0.02500000",
            //       "high":"0.03102001",
            //       "low":"0.02500000",
            //       "volume":"0.15549958",
            //       "bid":"0.02420000",
            //       "ask":"0.02625000"
            //   }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *tradeogre) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3598 := (<-this.LoadMarkets())
            PanicOnError(retRes3598)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PublicGetMarkets(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "AAVE-USDT": {
            //                 "initialprice": "177.20325711",
            //                 "price": "177.20325711",
            //                 "high": "177.20325711",
            //                 "low": "177.20325711",
            //                 "volume": "0.00000000",
            //                 "bid": "160.72768581",
            //                 "ask": "348.99999999",
            //                 "basename": "Aave"
            //             }
            //         },
            //         ...
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var marketIdArray interface{} = ObjectKeys(entry)
                var marketId interface{} = this.SafeString(marketIdArray, 0)
                var market interface{} = this.SafeMarket(marketId)
                var data interface{} = GetValue(entry, marketId)
                var ticker interface{} = this.ParseTicker(data, market)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  fetchTicker:
    //     {
    //         "success":true,
    //         "initialprice":"0.02502002",
    //         "price":"0.02500000",
    //         "high":"0.03102001",
    //         "low":"0.02500000",
    //         "volume":"0.15549958",
    //         "bid":"0.02420000",
    //         "ask":"0.02625000"
    //     }
    //
    //  fetchTickers:
    //     {
    //         "initialprice": "177.20325711",
    //         "price": "177.20325711",
    //         "high": "177.20325711",
    //         "low": "177.20325711",
    //         "volume": "0.00000000",
    //         "bid": "160.72768581",
    //         "ask": "348.99999999",
    //         "basename": "Aave"
    //     },
    //     ...
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "initialprice"),
        "close": this.SafeString(ticker, "price"),
        "last": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeString(ticker, "volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name tradeogre#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp of the latest candle in ms
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *tradeogre) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4588 := (<-this.LoadMarkets())
            PanicOnError(retRes4588)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var response interface{} = nil
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "timestamp", this.ParseToInt(Divide(until, 1000)))
                
        response = (<-this.PublicGetChartIntervalMarketTimestamp(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetChartIntervalMarket(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     [
            //         [
            //             1729130040,
            //             67581.47235999,
            //             67581.47235999,
            //             67338.01,
            //             67338.01,
            //             6.72168016
            //         ],
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1729130040,
    //         67581.47235999,
    //         67581.47235999,
    //         67338.01,
    //         67338.01,
    //         6.72168016
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name tradeogre#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *tradeogre) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5198 := (<-this.LoadMarkets())
            PanicOnError(retRes5198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrdersMarket(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "buy": {
            //        "0.02425501": "36.46986607",
            //        "0.02425502": "93.64201137",
            //        "0.02425503": "19.02000000",
            //        "0.02425515": "115.49000000"
            // }
            //
            var rawBids interface{} = this.SafeDict(response, "buy", map[string]interface{} {})
            var rawAsks interface{} = this.SafeDict(response, "sell", map[string]interface{} {})
            var rawOrderbook interface{} = map[string]interface{} {
                "bids": rawBids,
                "asks": rawAsks,
            }
            var orderbook interface{} = this.ParseOrderBook(rawOrderbook, symbol)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "s"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var prices interface{} = ObjectKeys(bidasks)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(prices)); i++ {
        var priceString interface{} = this.SafeString(prices, i)
        var price interface{} = this.SafeNumber(prices, i)
        var volume interface{} = this.SafeNumber(bidasks, priceString)
        AppendToArray(&result,[]interface{}{price, volume})
    }
    return result
}
/**
 * @method
 * @name tradeogre#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} params.lastId order id
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *tradeogre) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5708 := (<-this.LoadMarkets())
            PanicOnError(retRes5708)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetHistoryMarket(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  {
    //      "date":1515128233,
    //      "type":"sell",
    //      "price":"0.02454320",
    //      "quantity":"0.17614230"
    //  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(trade, "date", 1000)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "order": nil,
        "type": nil,
        "side": this.SafeString(trade, "type"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "quantity"),
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
        },
    }, market)
}
/**
 * @method
 * @name tradeogre#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.currency] currency to fetch the balance for
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *tradeogre) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6188 := (<-this.LoadMarkets())
            PanicOnError(retRes6188)
            var response interface{} = nil
            var currency interface{} = this.SafeString(params, "currency")
            if IsTrue(!IsEqual(currency, nil)) {
                
        response = (<-this.PrivatePostAccountBalance(params))
                PanicOnError(response)
                var singleCurrencyresult interface{} = map[string]interface{} {
                    "info": response,
                }
                var code interface{} = this.SafeCurrencyCode(currency)
                var account interface{} = map[string]interface{} {
                    "total": this.SafeNumber(response, "balance"),
                    "free": this.SafeNumber(response, "available"),
                }
                AddElementToObject(singleCurrencyresult, code, account)
        
                ch <- this.SafeBalance(singleCurrencyresult)
                return nil
            } else {
                
        response = (<-this.PrivateGetAccountBalances(params))
                PanicOnError(response)
            }
            var result interface{} = this.SafeDict(response, "balances", map[string]interface{} {})
        
            ch <- this.ParseBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseBalance(response interface{}) interface{}  {
    //
    //    {
    //        "USDT": "12"
    //    }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var keys interface{} = ObjectKeys(response)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var currencyId interface{} = GetValue(keys, i)
        var balance interface{} = GetValue(response, currencyId)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = map[string]interface{} {
            "total": balance,
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name tradeogre#createOrder
 * @description create a trade order
 * @see https://tradeogre.com/help/api#:~:text=u%20%27%7Bpublic%7D%3A%7Bprivate%7D%27-,Submit%20Buy%20Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *tradeogre) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6768 := (<-this.LoadMarkets())
            PanicOnError(retRes6768)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(typeVar, "market")) {
                panic(BadRequest(Add(this.Id, " createOrder does not support market orders")))
            }
            if IsTrue(IsEqual(price, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder requires a price parameter")))
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "quantity": this.AmountToPrecision(symbol, amount),
                "price": this.PriceToPrecision(symbol, price),
            }
            var response interface{} = nil
            if IsTrue(IsEqual(side, "buy")) {
                
        response = (<-this.PrivatePostOrderBuy(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrderSell(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#cancelOrder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *tradeogre) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7088 := (<-this.LoadMarkets())
            PanicOnError(retRes7088)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.PrivatePostOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#cancelAllOrders
 * @description cancel all open orders
 * @param {string} symbol alpaca cancelAllOrders cannot setting symbol, it will cancel all open orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *tradeogre) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7258 := (<-this.LoadMarkets())
            PanicOnError(retRes7258)
        
            response:= (<-this.CancelOrder("all", symbol, params))
            PanicOnError(response)
        
            ch <- []interface{}{response}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://tradeogre.com/help/api#:~:text=%7B%22success%22%3Atrue%7D-,Get%20Orders,-Method%20(POST)
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *tradeogre) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7448 := (<-this.LoadMarkets())
            PanicOnError(retRes7448)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostAccountOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name tradeogre#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://tradeogre.com/help/api#:~:text=market%22%3A%22XMR%2DBTC%22%7D%5D-,Get%20Order,-Method%20(GET)
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *tradeogre) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7688 := (<-this.LoadMarkets())
            PanicOnError(retRes7688)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.PrivateGetAccountOrderUuid(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, nil)
            return nil
        
            }()
            return ch
        }
func  (this *tradeogre) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //
    // {
    //     "uuid": "a40ac710-8dc5-b5a8-aa69-389715197b14",
    //     "date": 1514876938,
    //     "type": "sell",
    //     "price": "0.02621960",
    //     "quantity": "1.55772526",
    //     "market": "XMR-BTC"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(order, "date", 1000)
    var marketId interface{} = this.SafeString(order, "market")
    market = this.SafeMarket(marketId, market)
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "uuid"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString(order, "type"),
        "price": this.SafeString(order, "price"),
        "triggerPrice": nil,
        "amount": nil,
        "cost": nil,
        "average": nil,
        "filled": this.SafeString(order, "fulfilled"),
        "remaining": this.SafeString(order, "quantity"),
        "status": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
        },
        "trades": nil,
    }, market)
}
func  (this *tradeogre) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.ImplodeParams(path, params))
    params = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "Referer": "CCXT",
            "authorization": Add("Basic ", this.StringToBase64(Add(Add(this.ApiKey, ":"), this.Secret))),
        }
        if IsTrue(!IsEqual(method, "GET")) {
            body = this.Urlencode(params)
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *tradeogre) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if !IsTrue((InOp(response, "success"))) {
        return nil
    }
    //
    //  {"success":false,"error":"Must be authorized"}
    //
    var success interface{} = this.SafeBool(response, "success")
    if IsTrue(success) {
        return nil
    }
    var successString interface{} = this.SafeString(response, "success")
    if IsTrue(IsEqual(successString, "true")) {
        return nil
    }
    var error interface{} = this.SafeValue(response, "error")
    var errorCode interface{} = this.SafeString(error, "code")
    var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    panic(ExchangeError(feedback))
}


func (this *tradeogre) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
