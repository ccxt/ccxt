package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type hashkey struct {
    Exchange

}

func NewHashkeyCore() hashkey {
   p := hashkey{}
   setDefaults(&p)
   return p
}

func  (this *hashkey) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "hashkey",
        "name": "HashKey Global",
        "countries": []interface{}{"BM"},
        "rateLimit": 100,
        "version": "v1",
        "certified": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelWithdraw": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopLossOrder": false,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "createTakeProfitOrder": false,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchCanceledAndClosedOrders": true,
            "fetchCanceledOrders": true,
            "fetchClosedOrder": true,
            "fetchClosedOrders": false,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchLeverageTiers": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": "emulated",
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsForSymbol": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": false,
            "setLeverage": true,
            "setMargin": false,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "8h": "8h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/6dd6127b-cc19-4a13-9b29-a98d81f80e98",
            "api": map[string]interface{} {
                "public": "https://api-glb.hashkey.com",
                "private": "https://api-glb.hashkey.com",
            },
            "test": map[string]interface{} {
                "public": "https://api-glb.sim.hashkeydev.com",
                "private": "https://api-glb.sim.hashkeydev.com",
            },
            "www": "https://global.hashkey.com/",
            "doc": "https://hashkeyglobal-apidoc.readme.io/",
            "fees": "https://support.global.hashkey.com/hc/en-us/articles/13199900083612-HashKey-Global-Fee-Structure",
            "referral": "https://global.hashkey.com/en-US/register/invite?invite_code=82FQUN",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/v1/exchangeInfo": 5,
                    "quote/v1/depth": 1,
                    "quote/v1/trades": 1,
                    "quote/v1/klines": 1,
                    "quote/v1/ticker/24hr": 1,
                    "quote/v1/ticker/price": 1,
                    "quote/v1/ticker/bookTicker": 1,
                    "quote/v1/depth/merged": 1,
                    "quote/v1/markPrice": 1,
                    "quote/v1/index": 1,
                    "api/v1/futures/fundingRate": 1,
                    "api/v1/futures/historyFundingRate": 1,
                    "api/v1/ping": 1,
                    "api/v1/time": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/v1/spot/order": 1,
                    "api/v1/spot/openOrders": 1,
                    "api/v1/spot/tradeOrders": 5,
                    "api/v1/futures/leverage": 1,
                    "api/v1/futures/order": 1,
                    "api/v1/futures/openOrders": 1,
                    "api/v1/futures/userTrades": 1,
                    "api/v1/futures/positions": 1,
                    "api/v1/futures/historyOrders": 1,
                    "api/v1/futures/balance": 1,
                    "api/v1/futures/liquidationAssignStatus": 1,
                    "api/v1/futures/riskLimit": 1,
                    "api/v1/futures/commissionRate": 1,
                    "api/v1/futures/getBestOrder": 1,
                    "api/v1/account/vipInfo": 1,
                    "api/v1/account": 1,
                    "api/v1/account/trades": 5,
                    "api/v1/account/type": 5,
                    "api/v1/account/checkApiKey": 1,
                    "api/v1/account/balanceFlow": 5,
                    "api/v1/spot/subAccount/openOrders": 1,
                    "api/v1/spot/subAccount/tradeOrders": 1,
                    "api/v1/subAccount/trades": 1,
                    "api/v1/futures/subAccount/openOrders": 1,
                    "api/v1/futures/subAccount/historyOrders": 1,
                    "api/v1/futures/subAccount/userTrades": 1,
                    "api/v1/account/deposit/address": 1,
                    "api/v1/account/depositOrders": 1,
                    "api/v1/account/withdrawOrders": 1,
                },
                "post": map[string]interface{} {
                    "api/v1/userDataStream": 1,
                    "api/v1/spot/orderTest": 1,
                    "api/v1/spot/order": 1,
                    "api/v1.1/spot/order": 1,
                    "api/v1/spot/batchOrders": 5,
                    "api/v1/futures/leverage": 1,
                    "api/v1/futures/order": 1,
                    "api/v1/futures/position/trading-stop": 3,
                    "api/v1/futures/batchOrders": 5,
                    "api/v1/account/assetTransfer": 1,
                    "api/v1/account/authAddress": 1,
                    "api/v1/account/withdraw": 1,
                },
                "put": map[string]interface{} {
                    "api/v1/userDataStream": 1,
                },
                "delete": map[string]interface{} {
                    "api/v1/spot/order": 1,
                    "api/v1/spot/openOrders": 5,
                    "api/v1/spot/cancelOrderByIds": 5,
                    "api/v1/futures/order": 1,
                    "api/v1/futures/batchOrders": 1,
                    "api/v1/futures/cancelOrderByIds": 1,
                    "api/v1/userDataStream": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "spot": map[string]interface{} {
                    "tierBased": true,
                    "percentage": true,
                    "feeSide": "get",
                    "maker": this.ParseNumber("0.0012"),
                    "taker": this.ParseNumber("0.0012"),
                    "tiers": map[string]interface{} {
                        "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00080")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00070")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00060")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.00040")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.00030")}, []interface{}{this.ParseNumber("400000000"), this.ParseNumber("0.00010")}, []interface{}{this.ParseNumber("800000000"), this.ParseNumber("0.00")}},
                        "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00090")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00085")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00075")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.00065")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("400000000"), this.ParseNumber("0.00040")}, []interface{}{this.ParseNumber("800000000"), this.ParseNumber("0.00035")}},
                    },
                },
                "swap": map[string]interface{} {
                    "tierBased": true,
                    "percentage": true,
                    "feeSide": "get",
                    "maker": this.ParseNumber("0.00025"),
                    "taker": this.ParseNumber("0.00060"),
                    "tiers": map[string]interface{} {
                        "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.00025")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00016")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00014")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00012")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.000080")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.000060")}, []interface{}{this.ParseNumber("400000000"), this.ParseNumber("0.000020")}, []interface{}{this.ParseNumber("800000000"), this.ParseNumber("0.00")}},
                        "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.00060")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00050")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00040")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.00035")}, []interface{}{this.ParseNumber("200000000"), this.ParseNumber("0.00030")}, []interface{}{this.ParseNumber("400000000"), this.ParseNumber("0.00025")}, []interface{}{this.ParseNumber("800000000"), this.ParseNumber("0.00020")}},
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "broker": "10000700011",
            "recvWindow": nil,
            "sandboxMode": false,
            "networks": map[string]interface{} {
                "BTC": "BTC",
                "ERC20": "ETH",
                "AVAX": "AvalancheC",
                "SOL": "Solana",
                "MATIC": "Polygon",
                "ATOM": "Cosmos",
                "DOT": "Polkadot",
                "LTC": "LTC",
                "OPTIMISM": "Optimism",
                "ARB": "Arbitrum",
                "DOGE": "Dogecoin",
                "TRC20": "Tron",
                "ZKSYNC": "zkSync",
                "TON": "TON",
                "KLAYTN": "Klaytn",
                "MERLINCHAIN": "Merlin Chain",
            },
            "networksById": map[string]interface{} {
                "BTC": "BTC",
                "Bitcoin": "BTC",
                "ETH": "ERC20",
                "ERC20": "ERC20",
                "AvalancheC": "AVAX",
                "AVAX C-Chain": "AVAX",
                "Solana": "SOL",
                "Cosmos": "ATOM",
                "Arbitrum": "ARB",
                "Polygon": "MATIC",
                "Optimism": "OPTIMISM",
                "Polkadot": "DOT",
                "LTC": "LTC",
                "Litecoin": "LTC",
                "Dogecoin": "DOGE",
                "Merlin Chain": "MERLINCHAIN",
                "zkSync": "ZKSYNC",
                "TRC20": "TRC20",
                "Tron": "TRC20",
                "TON": "TON",
                "BSC(BEP20)": "BSC",
                "Klaytn": "KLAYTN",
            },
            "defaultNetwork": "ERC20",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": true,
                    "selfTradePrevention": true,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 20,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 30,
                    "untilDays": 30,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "triggerPrice": true,
                    "selfTradePrevention": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "trigger": true,
                    "limit": 500,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "0001": BadRequest,
                "0002": AuthenticationError,
                "0003": RateLimitExceeded,
                "0102": AuthenticationError,
                "0103": AuthenticationError,
                "0104": PermissionDenied,
                "0201": ExchangeError,
                "0202": PermissionDenied,
                "0206": BadRequest,
                "0207": BadRequest,
                "0209": BadRequest,
                "0210": BadRequest,
                "0211": OrderNotFound,
                "0401": InsufficientFunds,
                "0402": BadRequest,
                "-1000": ExchangeError,
                "-1001": ExchangeError,
                "-100010": BadSymbol,
                "-100012": BadSymbol,
                "-1002": AuthenticationError,
                "-1004": BadRequest,
                "-1005": PermissionDenied,
                "-1006": ExchangeError,
                "-1007": RequestTimeout,
                "-1014": InvalidOrder,
                "-1015": InvalidOrder,
                "-1020": OperationRejected,
                "-1021": InvalidNonce,
                "-1024": BadRequest,
                "-1101": ExchangeNotAvailable,
                "-1115": InvalidOrder,
                "-1117": InvalidOrder,
                "-1123": InvalidOrder,
                "-1124": InvalidOrder,
                "-1126": InvalidOrder,
                "-1129": BadRequest,
                "-1130": BadRequest,
                "-1132": BadRequest,
                "-1133": BadRequest,
                "-1135": BadRequest,
                "-1136": BadRequest,
                "-1138": InvalidOrder,
                "-1137": InvalidOrder,
                "-1139": OrderImmediatelyFillable,
                "-1140": InvalidOrder,
                "-1141": DuplicateOrderId,
                "-1142": OrderNotFillable,
                "-1143": OrderNotFound,
                "-1144": OperationRejected,
                "-1145": NotSupported,
                "-1146": RequestTimeout,
                "-1147": RequestTimeout,
                "-1148": InvalidOrder,
                "-1149": OperationRejected,
                "-1150": OperationFailed,
                "-1151": OperationRejected,
                "-1152": AccountNotEnabled,
                "-1153": InvalidOrder,
                "-1154": InvalidOrder,
                "-1155": OperationRejected,
                "-1156": OperationFailed,
                "-1157": OperationFailed,
                "-1158": OperationFailed,
                "-1159": AccountNotEnabled,
                "-1160": AccountNotEnabled,
                "-1161": OperationFailed,
                "-1162": ContractUnavailable,
                "-1163": InvalidAddress,
                "-1164": OperationFailed,
                "-1165": ArgumentsRequired,
                "-1166": OperationRejected,
                "-1167": BadRequest,
                "-1168": BadRequest,
                "-1169": PermissionDenied,
                "-1170": PermissionDenied,
                "-1171": PermissionDenied,
                "-1172": BadRequest,
                "-1173": BadRequest,
                "-1174": PermissionDenied,
                "-1175": BadRequest,
                "-1176": BadRequest,
                "-1177": InvalidOrder,
                "-1178": AccountNotEnabled,
                "-1179": AccountSuspended,
                "-1181": ExchangeError,
                "-1193": OperationRejected,
                "-1194": OperationRejected,
                "-1195": BadRequest,
                "-1196": BadRequest,
                "-1200": BadRequest,
                "-1201": BadRequest,
                "-1202": BadRequest,
                "-1203": BadRequest,
                "-1204": BadRequest,
                "-1205": AccountNotEnabled,
                "-1206": BadRequest,
                "-1207": BadRequest,
                "-1208": BadRequest,
                "-1209": BadRequest,
                "-2001": ExchangeNotAvailable,
                "-2002": OperationFailed,
                "-2003": OperationFailed,
                "-2004": OperationFailed,
                "-2005": RequestTimeout,
                "-2010": OperationRejected,
                "-2011": OperationRejected,
                "-2016": OperationRejected,
                "-2017": OperationRejected,
                "-2018": OperationRejected,
                "-2019": PermissionDenied,
                "-2020": PermissionDenied,
                "-2021": PermissionDenied,
                "-2022": OperationRejected,
                "-2023": AuthenticationError,
                "-2024": AccountNotEnabled,
                "-2025": AccountNotEnabled,
                "-2026": BadRequest,
                "-2027": OperationRejected,
                "-2028": OperationRejected,
                "-2029": OperationRejected,
                "-2030": InsufficientFunds,
                "-2031": NotSupported,
                "-2032": OperationRejected,
                "-2033": OperationFailed,
                "-2034": InsufficientFunds,
                "-2035": OperationRejected,
                "-2036": NotSupported,
                "-2037": ExchangeError,
                "-2038": InsufficientFunds,
                "-2039": NotSupported,
                "-2040": ExchangeNotAvailable,
                "-2041": BadRequest,
                "-2042": OperationRejected,
                "-2043": OperationRejected,
                "-2044": BadRequest,
                "-2045": BadRequest,
                "-2046": BadRequest,
                "-2048": BadRequest,
                "-2049": BadRequest,
                "-2050": BadRequest,
                "-2051": OperationRejected,
                "-2052": OperationRejected,
                "-2053": OperationRejected,
                "-2054": BadRequest,
                "-2055": BadRequest,
                "-2056": BadRequest,
                "-2057": BadRequest,
                "-3117": PermissionDenied,
                "-3143": PermissionDenied,
                "-3144": PermissionDenied,
                "-3145": DDoSProtection,
                "-4001": BadRequest,
                "-4002": BadRequest,
                "-4003": InsufficientFunds,
                "-4004": BadRequest,
                "-4005": BadRequest,
                "-4006": AccountNotEnabled,
                "-4007": NotSupported,
                "-4008": AccountNotEnabled,
                "-4009": PermissionDenied,
                "-4010": PermissionDenied,
                "-4011": ExchangeError,
                "-4012": ExchangeError,
                "-4013": OperationFailed,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name hashkey#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://hashkeyglobal-apidoc.readme.io/reference/check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *hashkey) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiV1Time(params))
            PanicOnError(response)
        
                //
            //     {
            //         "serverTime": 1721661553214
            //     }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://hashkeyglobal-apidoc.readme.io/reference/test-connectivity
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *hashkey) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiV1Ping(params))
            PanicOnError(response)
        
                //
            // {}
            //
        ch <- map[string]interface{} {
                "status": "ok",
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchMarkets
 * @description retrieves data on all markets for the exchange
 * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] the id of the market to fetch
 * @returns {object[]} an array of objects representing market data
 */
func  (this *hashkey) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PublicGetApiV1ExchangeInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": "1721661653952",
            //         "brokerFilters": [],
            //         "symbols": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "symbolName": "BTCUSDT",
            //                 "status": "TRADING",
            //                 "baseAsset": "BTC",
            //                 "baseAssetName": "BTC",
            //                 "baseAssetPrecision": "0.00001",
            //                 "quoteAsset": "USDT",
            //                 "quoteAssetName": "USDT",
            //                 "quotePrecision": "0.0000001",
            //                 "retailAllowed": true,
            //                 "piAllowed": true,
            //                 "corporateAllowed": true,
            //                 "omnibusAllowed": true,
            //                 "icebergAllowed": false,
            //                 "isAggregate": false,
            //                 "allowMargin": false,
            //                 "filters": [
            //                     {
            //                         "minPrice": "0.01",
            //                         "maxPrice": "100000.00000000",
            //                         "tickSize": "0.01",
            //                         "filterType": "PRICE_FILTER"
            //                     },
            //                     {
            //                         "minQty": "0.00001",
            //                         "maxQty": "8",
            //                         "stepSize": "0.00001",
            //                         "marketOrderMinQty": "0.00001",
            //                         "marketOrderMaxQty": "4",
            //                         "filterType": "LOT_SIZE"
            //                     },
            //                     {
            //                         "minNotional": "1",
            //                         "filterType": "MIN_NOTIONAL"
            //                     },
            //                     {
            //                         "minAmount": "1",
            //                         "maxAmount": "400000",
            //                         "minBuyPrice": "0",
            //                         "marketOrderMinAmount": "1",
            //                         "marketOrderMaxAmount": "200000",
            //                         "filterType": "TRADE_AMOUNT"
            //                     },
            //                     {
            //                         "maxSellPrice": "0",
            //                         "buyPriceUpRate": "0.1",
            //                         "sellPriceDownRate": "0.1",
            //                         "filterType": "LIMIT_TRADING"
            //                     },
            //                     {
            //                         "buyPriceUpRate": "0.1",
            //                         "sellPriceDownRate": "0.1",
            //                         "filterType": "MARKET_TRADING"
            //                     },
            //                     {
            //                         "noAllowMarketStartTime": "1710485700000",
            //                         "noAllowMarketEndTime": "1710486000000",
            //                         "limitOrderStartTime": "0",
            //                         "limitOrderEndTime": "0",
            //                         "limitMinPrice": "0",
            //                         "limitMaxPrice": "0",
            //                         "filterType": "OPEN_QUOTE"
            //                     }
            //                 ]
            //             }
            //         ],
            //         "options": [ ],
            //         "contracts": [
            //             {
            //                 "filters": [
            //                     {
            //                         "minPrice": "0.1",
            //                         "maxPrice": "100000.00000000",
            //                         "tickSize": "0.1",
            //                         "filterType": "PRICE_FILTER"
            //                     },
            //                     {
            //                         "minQty": "0.001",
            //                         "maxQty": "10",
            //                         "stepSize": "0.001",
            //                         "marketOrderMinQty": "0",
            //                         "marketOrderMaxQty": "0",
            //                         "filterType": "LOT_SIZE"
            //                     },
            //                     {
            //                         "minNotional": "0",
            //                         "filterType": "MIN_NOTIONAL"
            //                     },
            //                     {
            //                         "maxSellPrice": "999999",
            //                         "buyPriceUpRate": "0.05",
            //                         "sellPriceDownRate": "0.05",
            //                         "maxEntrustNum": 200,
            //                         "maxConditionNum": 200,
            //                         "filterType": "LIMIT_TRADING"
            //                     },
            //                     {
            //                         "buyPriceUpRate": "0.05",
            //                         "sellPriceDownRate": "0.05",
            //                         "filterType": "MARKET_TRADING"
            //                     },
            //                     {
            //                         "noAllowMarketStartTime": "0",
            //                         "noAllowMarketEndTime": "0",
            //                         "limitOrderStartTime": "0",
            //                         "limitOrderEndTime": "0",
            //                         "limitMinPrice": "0",
            //                         "limitMaxPrice": "0",
            //                         "filterType": "OPEN_QUOTE"
            //                     }
            //                 ],
            //                 "exchangeId": "301",
            //                 "symbol": "BTCUSDT-PERPETUAL",
            //                 "symbolName": "BTCUSDT-PERPETUAL",
            //                 "status": "TRADING",
            //                 "baseAsset": "BTCUSDT-PERPETUAL",
            //                 "baseAssetPrecision": "0.001",
            //                 "quoteAsset": "USDT",
            //                 "quoteAssetPrecision": "0.1",
            //                 "icebergAllowed": false,
            //                 "inverse": false,
            //                 "index": "USDT",
            //                 "marginToken": "USDT",
            //                 "marginPrecision": "0.0001",
            //                 "contractMultiplier": "0.001",
            //                 "underlying": "BTC",
            //                 "riskLimits": [
            //                     {
            //                         "riskLimitId": "200000722",
            //                         "quantity": "1000.00",
            //                         "initialMargin": "0.10",
            //                         "maintMargin": "0.005",
            //                         "isWhite": false
            //                     },
            //                     {
            //                         "riskLimitId": "200000723",
            //                         "quantity": "2000.00",
            //                         "initialMargin": "0.10",
            //                         "maintMargin": "0.01",
            //                         "isWhite": false
            //                     }
            //                 ]
            //             }
            //         ],
            //         "coins": [
            //            {
            //                 "orgId": "9001",
            //                 "coinId": "BTC",
            //                 "coinName": "BTC",
            //                 "coinFullName": "Bitcoin",
            //                 "allowWithdraw": true,
            //                 "allowDeposit": true,
            //                 "tokenType": "CHAIN_TOKEN",
            //                 "chainTypes": [
            //                     {
            //                         "chainType": "Bitcoin",
            //                         "withdrawFee": "0",
            //                         "minWithdrawQuantity": "0.002",
            //                         "maxWithdrawQuantity": "0",
            //                         "minDepositQuantity": "0.0005",
            //                         "allowDeposit": true,
            //                         "allowWithdraw": true
            //                     }
            //                 ]
            //             }
            //         ]
            //     }
            //
            var spotMarkets interface{} = this.SafeList(response, "symbols", []interface{}{})
            var swapMarkets interface{} = this.SafeList(response, "contracts", []interface{}{})
            var markets interface{} = this.ArrayConcat(spotMarkets, swapMarkets)
            if IsTrue(this.IsEmpty(markets)) {
                markets = []interface{}{response} // if user provides params.symbol the exchange returns a single object insted of list of objects
            }
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseMarket(market interface{}) interface{}  {
    // spot
    //     {
    //         "symbol": "BTCUSDT",
    //         "symbolName": "BTCUSDT",
    //         "status": "TRADING",
    //         "baseAsset": "BTC",
    //         "baseAssetName": "BTC",
    //         "baseAssetPrecision": "0.00001",
    //         "quoteAsset": "USDT",
    //         "quoteAssetName": "USDT",
    //         "quotePrecision": "0.0000001",
    //         "retailAllowed": true,
    //         "piAllowed": true,
    //         "corporateAllowed": true,
    //         "omnibusAllowed": true,
    //         "icebergAllowed": false,
    //         "isAggregate": false,
    //         "allowMargin": false,
    //         "filters": [
    //             {
    //                 "minPrice": "0.01",
    //                 "maxPrice": "100000.00000000",
    //                 "tickSize": "0.01",
    //                 "filterType": "PRICE_FILTER"
    //             },
    //             {
    //                 "minQty": "0.00001",
    //                 "maxQty": "8",
    //                 "stepSize": "0.00001",
    //                 "marketOrderMinQty": "0.00001",
    //                 "marketOrderMaxQty": "4",
    //                 "filterType": "LOT_SIZE"
    //             },
    //             {
    //                 "minNotional": "1",
    //                 "filterType": "MIN_NOTIONAL"
    //             },
    //             {
    //                 "minAmount": "1",
    //                 "maxAmount": "400000",
    //                 "minBuyPrice": "0",
    //                 "marketOrderMinAmount": "1",
    //                 "marketOrderMaxAmount": "200000",
    //                 "filterType": "TRADE_AMOUNT"
    //             },
    //             {
    //                 "maxSellPrice": "0",
    //                 "buyPriceUpRate": "0.1",
    //                 "sellPriceDownRate": "0.1",
    //                 "filterType": "LIMIT_TRADING"
    //             },
    //             {
    //                 "buyPriceUpRate": "0.1",
    //                 "sellPriceDownRate": "0.1",
    //                 "filterType": "MARKET_TRADING"
    //             },
    //             {
    //                 "noAllowMarketStartTime": "1710485700000",
    //                 "noAllowMarketEndTime": "1710486000000",
    //                 "limitOrderStartTime": "0",
    //                 "limitOrderEndTime": "0",
    //                 "limitMinPrice": "0",
    //                 "limitMaxPrice": "0",
    //                 "filterType": "OPEN_QUOTE"
    //             }
    //         ]
    //     }
    //
    // swap
    //     {
    //         "filters": [
    //             {
    //                 "minPrice": "0.1",
    //                 "maxPrice": "100000.00000000",
    //                 "tickSize": "0.1",
    //                 "filterType": "PRICE_FILTER"
    //             },
    //             {
    //                 "minQty": "0.001",
    //                 "maxQty": "10",
    //                 "stepSize": "0.001",
    //                 "marketOrderMinQty": "0",
    //                 "marketOrderMaxQty": "0",
    //                 "filterType": "LOT_SIZE"
    //             },
    //             {
    //                 "minNotional": "0",
    //                 "filterType": "MIN_NOTIONAL"
    //             },
    //             {
    //                 "maxSellPrice": "999999",
    //                 "buyPriceUpRate": "0.05",
    //                 "sellPriceDownRate": "0.05",
    //                 "maxEntrustNum": 200,
    //                 "maxConditionNum": 200,
    //                 "filterType": "LIMIT_TRADING"
    //             },
    //             {
    //                 "buyPriceUpRate": "0.05",
    //                 "sellPriceDownRate": "0.05",
    //                 "filterType": "MARKET_TRADING"
    //             },
    //             {
    //                 "noAllowMarketStartTime": "0",
    //                 "noAllowMarketEndTime": "0",
    //                 "limitOrderStartTime": "0",
    //                 "limitOrderEndTime": "0",
    //                 "limitMinPrice": "0",
    //                 "limitMaxPrice": "0",
    //                 "filterType": "OPEN_QUOTE"
    //             }
    //         ],
    //         "exchangeId": "301",
    //         "symbol": "BTCUSDT-PERPETUAL",
    //         "symbolName": "BTCUSDT-PERPETUAL",
    //         "status": "TRADING",
    //         "baseAsset": "BTCUSDT-PERPETUAL",
    //         "baseAssetPrecision": "0.001",
    //         "quoteAsset": "USDT",
    //         "quoteAssetPrecision": "0.1",
    //         "icebergAllowed": false,
    //         "inverse": false,
    //         "index": "USDT",
    //         "marginToken": "USDT",
    //         "marginPrecision": "0.0001",
    //         "contractMultiplier": "0.001",
    //         "underlying": "BTC",
    //         "riskLimits": [
    //             {
    //                 "riskLimitId": "200000722",
    //                 "quantity": "1000.00",
    //                 "initialMargin": "0.10",
    //                 "maintMargin": "0.005",
    //                 "isWhite": false
    //             },
    //             {
    //                 "riskLimitId": "200000723",
    //                 "quantity": "2000.00",
    //                 "initialMargin": "0.10",
    //                 "maintMargin": "0.01",
    //                 "isWhite": false
    //             }
    //         ]
    //     }
    //
    var marketId interface{} = this.SafeString(market, "symbol")
    var quoteId interface{} = this.SafeString(market, "quoteAsset")
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = this.SafeString(market, "marginToken")
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var baseId interface{} = this.SafeString(market, "baseAsset")
    var marketType interface{} = "spot"
    var isSpot interface{} = true
    var isSwap interface{} = false
    var suffix interface{} = ""
    var parts interface{} = Split(marketId, "-")
    var secondPart interface{} = this.SafeString(parts, 1)
    if IsTrue(IsEqual(secondPart, "PERPETUAL")) {
        marketType = "swap"
        isSpot = false
        isSwap = true
        baseId = this.SafeString(market, "underlying")
        suffix = Add(suffix, Add(":", settleId))
    }
    var base interface{} = this.SafeCurrencyCode(baseId)
    var symbol interface{} = Add(Add(Add(base, "/"), quote), suffix)
    var status interface{} = this.SafeString(market, "status")
    var active interface{} = IsEqual(status, "TRADING")
    var isLinear interface{} = nil
    var subType interface{} = nil
    var isInverse interface{} = this.SafeBool(market, "inverse")
    if IsTrue(!IsEqual(isInverse, nil)) {
        if IsTrue(isInverse) {
            isLinear = false
            subType = "inverse"
        } else {
            isLinear = true
            subType = "linear"
        }
    }
    var filtersList interface{} = this.SafeList(market, "filters", []interface{}{})
    var filters interface{} = this.IndexBy(filtersList, "filterType")
    var priceFilter interface{} = this.SafeDict(filters, "PRICE_FILTER", map[string]interface{} {})
    var amountFilter interface{} = this.SafeDict(filters, "LOT_SIZE", map[string]interface{} {})
    var costFilter interface{} = this.SafeDict(filters, "MIN_NOTIONAL", map[string]interface{} {})
    var minCostString interface{} = this.OmitZero(this.SafeString(costFilter, "min_notional"))
    var contractSizeString interface{} = this.SafeString(market, "contractMultiplier")
    var amountPrecisionString interface{} = this.SafeString(amountFilter, "stepSize")
    var amountMinLimitString interface{} = this.SafeString(amountFilter, "minQty")
    var amountMaxLimitString interface{} = this.SafeString(amountFilter, "maxQty")
    var minLeverage interface{} = nil
    var maxLeverage interface{} = nil
    if IsTrue(isSwap) {
        amountPrecisionString = Precise.StringDiv(amountPrecisionString, contractSizeString)
        amountMinLimitString = Precise.StringDiv(amountMinLimitString, contractSizeString)
        amountMaxLimitString = Precise.StringDiv(amountMaxLimitString, contractSizeString)
        var riskLimits interface{} = this.SafeList(market, "riskLimits")
        if IsTrue(!IsEqual(riskLimits, nil)) {
            var first interface{} = this.SafeDict(riskLimits, 0)
            var arrayLength interface{} =             GetArrayLength(riskLimits)
            var last interface{} = this.SafeDict(riskLimits, Subtract(arrayLength, 1))
            var minInitialMargin interface{} = this.SafeString(first, "initialMargin")
            var maxInitialMargin interface{} = this.SafeString(last, "initialMargin")
            if IsTrue(Precise.StringGt(minInitialMargin, maxInitialMargin)) {
                minInitialMarginmaxInitialMarginVariable := []interface{}{maxInitialMargin, minInitialMargin};
                minInitialMargin = GetValue(minInitialMarginmaxInitialMarginVariable,0);
                maxInitialMargin = GetValue(minInitialMarginmaxInitialMarginVariable,1)
            }
            minLeverage = this.ParseToInt(Precise.StringDiv("1", maxInitialMargin))
            maxLeverage = this.ParseToInt(Precise.StringDiv("1", minInitialMargin))
        }
    }
    var tradingFees interface{} = this.SafeDict(this.Fees, "trading")
    var fees interface{} = Ternary(IsTrue(isSpot), this.SafeDict(tradingFees, "spot"), this.SafeDict(tradingFees, "swap"))
    return this.SafeMarketStructure(map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "baseId": baseId,
        "quoteId": quoteId,
        "active": active,
        "type": marketType,
        "subType": subType,
        "spot": isSpot,
        "margin": this.SafeBool(market, "allowMargin"),
        "swap": isSwap,
        "future": false,
        "option": false,
        "contract": isSwap,
        "settle": settle,
        "settleId": settleId,
        "contractSize": this.ParseNumber(contractSizeString),
        "linear": isLinear,
        "inverse": isInverse,
        "taker": this.SafeNumber(fees, "taker"),
        "maker": this.SafeNumber(fees, "maker"),
        "percentage": this.SafeBool(fees, "percentage"),
        "tierBased": this.SafeBool(fees, "tierBased"),
        "feeSide": this.SafeString(fees, "feeSide"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(amountPrecisionString),
            "price": this.SafeNumber(priceFilter, "tickSize"),
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.ParseNumber(amountMinLimitString),
                "max": this.ParseNumber(amountMaxLimitString),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(priceFilter, "minPrice"),
                "max": this.SafeNumber(priceFilter, "maxPrice"),
            },
            "leverage": map[string]interface{} {
                "min": minLeverage,
                "max": maxLeverage,
            },
            "cost": map[string]interface{} {
                "min": this.ParseNumber(minCostString),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
/**
 * @method
 * @name hashkey#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *hashkey) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiV1ExchangeInfo(params))
            PanicOnError(response)
            var coins interface{} = this.SafeList(response, "coins")
            //
            //     {
            //         ...
            //         "coins": [
            //             {
            //                 "orgId": "9001",
            //                 "coinId": "BTC",
            //                 "coinName": "BTC",
            //                 "coinFullName": "Bitcoin",
            //                 "allowWithdraw": true,
            //                 "allowDeposit": true,
            //                 "tokenType": "CHAIN_TOKEN",
            //                 "chainTypes": [
            //                     {
            //                         "chainType": "Bitcoin",
            //                         "withdrawFee": "0",
            //                         "minWithdrawQuantity": "0.002",
            //                         "maxWithdrawQuantity": "0",
            //                         "minDepositQuantity": "0.0005",
            //                         "allowDeposit": true,
            //                         "allowWithdraw": true
            //                     }
            //                 ]
            //             }
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(coins)); i++ {
                var currecy interface{} = GetValue(coins, i)
                var currencyId interface{} = this.SafeString(currecy, "coinId")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var allowWithdraw interface{} = this.SafeBool(currecy, "allowWithdraw")
                var allowDeposit interface{} = this.SafeBool(currecy, "allowDeposit")
                var networks interface{} = this.SafeList(currecy, "chainTypes")
                var networksById interface{} = this.SafeDict(this.Options, "networksById")
                var parsedNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
                    var network interface{} = GetValue(networks, j)
                    var networkId interface{} = this.SafeString(network, "chainType")
                    var networkName interface{} = this.SafeString(networksById, networkId, networkId)
                    var maxWithdrawQuantity interface{} = this.OmitZero(this.SafeString(network, "maxWithdrawQuantity"))
                    var networkDeposit interface{} = this.SafeBool(network, "allowDeposit")
                    var networkWithdraw interface{} = this.SafeBool(network, "allowWithdraw")
                    AddElementToObject(parsedNetworks, networkName, map[string]interface{} {
            "id": networkId,
            "network": networkName,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(network, "minWithdrawQuantity"),
                    "max": this.ParseNumber(maxWithdrawQuantity),
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(network, "minDepositQuantity"),
                    "max": nil,
                },
            },
            "active": IsTrue(networkDeposit) && IsTrue(networkWithdraw),
            "deposit": networkDeposit,
            "withdraw": networkWithdraw,
            "fee": this.SafeNumber(network, "withdrawFee"),
            "precision": nil,
            "info": network,
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "code": code,
            "precision": nil,
            "type": this.ParseCurrencyType(this.SafeString(currecy, "tokenType")),
            "name": this.SafeString(currecy, "coinFullName"),
            "active": IsTrue(allowWithdraw) && IsTrue(allowDeposit),
            "deposit": allowDeposit,
            "withdraw": allowWithdraw,
            "fee": nil,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": parsedNetworks,
            "info": currecy,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseCurrencyType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "CHAIN_TOKEN": "crypto",
        "ERC20_TOKEN": "crypto",
        "BSC_TOKEN": "crypto",
        "REAL_MONEY": "fiat",
    }
    return this.SafeString(types, typeVar)
}
/**
 * @method
 * @name hashkey#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (maximum value is 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *hashkey) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12238 := (<-this.LoadMarkets())
            PanicOnError(retRes12238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetQuoteV1Depth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "t": 1721681436393,
            //         "b": [
            //             ["67902.49", "0.00112"],
            //             ["67901.08", "0.01014"]
            //             ...
            //         ],
            //         "a": [
            //             ["67905.99", "0.87134"],
            //             ["67906", "0.57361"]
            //             ...
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "t")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "b", "a")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-recent-trade-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (maximum value is 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *hashkey) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12638 := (<-this.LoadMarkets())
            PanicOnError(retRes12638)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetQuoteV1Trades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "t": 1721682745779,
            //             "p": "67835.99",
            //             "q": "0.00017",
            //             "ibm": true
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-trade-list
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-trades
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-user
 * @param {string} symbol *is mandatory for swap markets* unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch trades for (default 'spot')
 * @param {int} [params.until] the latest time in ms to fetch trades for, only supports the last 30 days timeframe
 * @param {string} [params.fromId] srarting trade id
 * @param {string} [params.toId] ending trade id
 * @param {string} [params.clientOrderId] *spot markets only* filter trades by orderId
 * @param {string} [params.accountId] account id to fetch the orders from
 * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
 */
func  (this *hashkey) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchMyTrades"
        
            retRes13078 := (<-this.LoadMarkets())
            PanicOnError(retRes13078)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            var accountId interface{} = nil
            accountIdparamsVariable := this.HandleOptionAndParams(params, methodName, "accountId");
            accountId = GetValue(accountIdparamsVariable,0);
            params = GetValue(accountIdparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(market, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                if IsTrue(!IsEqual(accountId, nil)) {
                    AddElementToObject(request, "accountId", accountId)
                }
                
        response = (<-this.PrivateGetApiV1AccountTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for swap markets")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                if IsTrue(!IsEqual(accountId, nil)) {
                    AddElementToObject(request, "subAccountId", accountId)
                    
        response = (<-this.PrivateGetApiV1FuturesSubAccountUserTrades(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetApiV1FuturesUserTrades(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //     {
    //         "t": 1721682745779,
    //         "p": "67835.99",
    //         "q": "0.00017",
    //         "ibm": true
    //     }
    //
    // fetchMyTrades spot
    //
    //     {
    //         "id": "1739352552862964736",
    //         "clientOrderId": "1722082982086472",
    //         "ticketId": "1739352552795029504",
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "orderId": "1739352552762301440",
    //         "matchOrderId": "0",
    //         "price": "3289.96",
    //         "qty": "0.001",
    //         "commission": "0.0000012",
    //         "commissionAsset": "ETH",
    //         "time": "1722082982097",
    //         "isBuyer": true,
    //         "isMaker": false,
    //         "fee": {
    //             "feeCoinId": "ETH",
    //             "feeCoinName": "ETH",
    //             "fee": "0.0000012"
    //         },
    //         "feeCoinId": "ETH",
    //         "feeAmount": "0.0000012",
    //         "makerRebate": "0"
    //     }
    //
    // fetchMyTrades swap
    //     {
    //         "time": "1722429951648",
    //         "tradeId": "1742263144691139328",
    //         "orderId": "1742263144028363776",
    //         "symbol": "ETHUSDT-PERPETUAL",
    //         "price": "3327.54",
    //         "quantity": "4",
    //         "commissionAsset": "USDT",
    //         "commission": "0.00798609",
    //         "makerRebate": "0",
    //         "type": "LIMIT",
    //         "side": "BUY_OPEN",
    //         "realizedPnl": "0",
    //         "isMarker": false
    //     }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "t", "time")
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var side interface{} = this.SafeStringLower(trade, "side") // swap trades have side param
    if IsTrue(!IsEqual(side, nil)) {
        side = this.SafeString(Split(side, "_"), 0)
    }
    var isBuyer interface{} = this.SafeBool(trade, "isBuyer")
    if IsTrue(!IsEqual(isBuyer, nil)) {
        side = Ternary(IsTrue(isBuyer), "buy", "sell")
    }
    var takerOrMaker interface{} = nil
    var isMaker interface{} = this.SafeBoolN(trade, []interface{}{"isMaker", "isMarker"})
    if IsTrue(!IsEqual(isMaker, nil)) {
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    var isBuyerMaker interface{} = this.SafeBool(trade, "ibm")
    // if public trade
    if IsTrue(!IsEqual(isBuyerMaker, nil)) {
        takerOrMaker = "taker"
        side = Ternary(IsTrue(isBuyerMaker), "sell", "buy")
    }
    var feeCost interface{} = this.SafeString(trade, "commission")
    var feeCurrncyId interface{} = this.SafeString(trade, "commissionAsset")
    var feeInfo interface{} = this.SafeDict(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeInfo, nil)) {
        feeCost = this.SafeString(feeInfo, "fee")
        feeCurrncyId = this.SafeString(feeInfo, "feeCoinId")
    }
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeCost),
            "currency": this.SafeCurrencyCode(feeCurrncyId),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString2(trade, "id", "tradeId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "side": side,
        "price": this.SafeString2(trade, "p", "price"),
        "amount": this.SafeStringN(trade, []interface{}{"q", "qty", "quantity"}),
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "type": nil,
        "order": this.SafeString(trade, "orderId"),
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name hashkey#fetchOHLCV
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-kline
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *hashkey) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOHLCV"
        
            retRes15258 := (<-this.LoadMarkets())
            PanicOnError(retRes15258)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, methodName, "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes152919 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1000))
                    PanicOnError(retRes152919)
                    ch <- retRes152919
                    return nil
            }
            var market interface{} = this.Market(symbol)
            timeframe = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": timeframe,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PublicGetQuoteV1Klines(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [
            //             1721684280000,
            //             "67832.49",
            //             "67862.5",
            //             "67832.49",
            //             "67861.44",
            //             "0.01122",0,
            //             "761.2763533",68,
            //             "0.00561",
            //             "380.640643"
            //         ],
            //         ...
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1721684280000,
    //         "67832.49",
    //         "67862.5",
    //         "67832.49",
    //         "67861.44",
    //         "0.01122",0,
    //         "761.2763533",68,
    //         "0.00561",
    //         "380.640643"
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name hashkey#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-24hr-ticker-price-change
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hashkey) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16028 := (<-this.LoadMarkets())
            PanicOnError(retRes16028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetQuoteV1Ticker24hr(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "t": 1721685896846,
            //             "s": "BTCUSDT-PERPETUAL",
            //             "c": "67756.7",
            //             "h": "68479.9",
            //             "l": "66594.3",
            //             "o": "68279.7",
            //             "b": "67756.6",
            //             "a": "67756.7",
            //             "v": "1604722",
            //             "qv": "108827258.7761"
            //         }
            //     ]
            //
            var ticker interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-24hr-ticker-price-change
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hashkey) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16388 := (<-this.LoadMarkets())
            PanicOnError(retRes16388)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetQuoteV1Ticker24hr(params))
            PanicOnError(response)
        
            ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "t": 1721685896846,
    //         "s": "BTCUSDT-PERPETUAL",
    //         "c": "67756.7",
    //         "h": "68479.9",
    //         "l": "66594.3",
    //         "o": "68279.7",
    //         "b": "67756.6",
    //         "a": "67756.7",
    //         "v": "1604722",
    //         "qv": "108827258.7761"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var marketId interface{} = this.SafeString(ticker, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var last interface{} = this.SafeString(ticker, "c")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "h"),
        "low": this.SafeString(ticker, "l"),
        "bid": this.SafeString(ticker, "b"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "a"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "o"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": this.SafeString(ticker, "qv"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name hashkey#fetchLastPrices
 * @description fetches the last price for multiple markets
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-symbol-price-ticker
 * @param {string[]} [symbols] unified symbols of the markets to fetch the last prices
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] the id of the market to fetch last price for
 * @returns {object} a dictionary of lastprices structures
 */
func  (this *hashkey) FetchLastPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16998 := (<-this.LoadMarkets())
            PanicOnError(retRes16998)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PublicGetQuoteV1TickerPrice(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "s": "BTCUSDT-PERPETUAL",
            //             "p": "64871"
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseLastPrices(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseLastPrice(entry interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(entry, "s")
    market = this.SafeMarket(marketId, market)
    return map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "price": this.SafeNumber(entry, "p"),
        "side": nil,
        "info": entry,
    }
}
/**
 * @method
 * @name hashkey#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.accountId] account ID, for Master Key only
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch balance for (default 'spot')
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *hashkey) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17398 := (<-this.LoadMarkets())
            PanicOnError(retRes17398)
            var request interface{} = map[string]interface{} {}
            var methodName interface{} = "fetchBalance"
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, nil, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "swap")) {
        
                response:= (<-this.PrivateGetApiV1FuturesBalance(params))
                PanicOnError(response)
                //
                //     [
                //         {
                //             "balance": "30.63364672",
                //             "availableBalance": "28.85635534",
                //             "positionMargin": "4.3421",
                //             "orderMargin": "0",
                //             "asset": "USDT",
                //             "crossUnRealizedPnl": "2.5649"
                //         }
                //     ]
                //
                var balance interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
                ch <- this.ParseSwapBalance(balance)
                return nil
            } else if IsTrue(IsEqual(marketType, "spot")) {
        
                response:= (<-this.PrivateGetApiV1Account(this.Extend(request, params)))
                PanicOnError(response)
        
                        //
                //     {
                //         "balances": [
                //             {
                //                 "asset":"USDT",
                //                 "assetId":"USDT",
                //                 "assetName":"USDT",
                //                 "total":"40",
                //                 "free":"40",
                //                 "locked":"0"
                //             },
                //             ...
                //         ],
                //         "userId": "1732885739572845312"
                //     }
                //
        ch <- this.ParseBalance(response)
                return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
                return nil
            }()
            return ch
        }
func  (this *hashkey) ParseBalance(balance interface{}) interface{}  {
    //
    //     {
    //         "balances": [
    //             {
    //                 "asset":"USDT",
    //                 "assetId":"USDT",
    //                 "assetName":"USDT",
    //                 "total":"40",
    //                 "free":"40",
    //                 "locked":"0"
    //             },
    //             ...
    //         ],
    //         "userId": "1732885739572845312"
    //     }
    //
    var result interface{} = map[string]interface{} {
        "info": balance,
    }
    var balances interface{} = this.SafeList(balance, "balances", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balanceEntry interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balanceEntry, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balanceEntry, "total"))
        AddElementToObject(account, "free", this.SafeString(balanceEntry, "free"))
        AddElementToObject(account, "used", this.SafeString(balanceEntry, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
func  (this *hashkey) ParseSwapBalance(balance interface{}) interface{}  {
    //
    //     {
    //         "balance": "30.63364672",
    //         "availableBalance": "28.85635534",
    //         "positionMargin": "4.3421",
    //         "orderMargin": "0",
    //         "asset": "USDT",
    //         "crossUnRealizedPnl": "2.5649"
    //     }
    //
    var currencyId interface{} = this.SafeString(balance, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    AddElementToObject(account, "total", this.SafeString(balance, "balance"))
    var positionMargin interface{} = this.SafeString(balance, "positionMargin")
    var orderMargin interface{} = this.SafeString(balance, "orderMargin")
    AddElementToObject(account, "used", Precise.StringAdd(positionMargin, orderMargin))
    var result interface{} = map[string]interface{} {
        "info": balance,
    }
    AddElementToObject(result, code, account)
    return this.SafeBalance(result)
}
/**
 * @method
 * @name hashkey#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-deposit-address
 * @param {string} code unified currency code (default is 'USDT')
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for fetch deposit address (default is 'ETH')
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *hashkey) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18548 := (<-this.LoadMarkets())
            PanicOnError(retRes18548)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(IsEqual(networkCode, nil)) {
                networkCode = this.DefaultNetworkCode(code)
            }
            AddElementToObject(request, "chainType", this.NetworkCodeToId(networkCode, code))
        
            response:= (<-this.PrivateGetApiV1AccountDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "canDeposit": true,
            //         "address": "0x61AAd7F763e2C7fF1CC996918740F67f9dC8BF4e",
            //         "addressExt": "",
            //         "minQuantity": "1",
            //         "needAddressTag": false,
            //         "requiredConfirmTimes": 64,
            //         "canWithdrawConfirmTimes": 64,
            //         "coinType": "ERC20_TOKEN"
            //     }
            //
            var depositAddress interface{} = this.ParseDepositAddress(response, currency)
            AddElementToObject(depositAddress, "network", networkCode)
        
            ch <- depositAddress
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "canDeposit": true,
    //         "address": "0x61AAd7F763e2C7fF1CC996918740F67f9dC8BF4e",
    //         "addressExt": "",
    //         "minQuantity": "1",
    //         "needAddressTag": false,
    //         "requiredConfirmTimes": 64,
    //         "canWithdrawConfirmTimes": 64,
    //         "coinType": "ERC20_TOKEN"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    var tag interface{} = this.SafeString(depositAddress, "addressExt")
    if IsTrue(IsEqual(tag, "")) {
        tag = nil
    }
    return map[string]interface{} {
        "info": depositAddress,
        "currency": GetValue(currency, "code"),
        "network": nil,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name hashkey#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-deposit-history
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @param {int} [params.fromId] starting ID (To be released)
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *hashkey) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchDeposits"
        
            retRes19268 := (<-this.LoadMarkets())
            PanicOnError(retRes19268)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateGetApiV1AccountDepositOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "time": "1721641082163",
            //             "coin": "TRXUSDT",
            //             "coinName": "TRXUSDT",
            //             "address": "TBA6CypYJizwA9XdC7Ubgc5F1bxrQ7SqPt",
            //             "quantity": "86.00000000000000000000",
            //             "status": 4,
            //             "statusCode": "4",
            //             "txId": "0970c14da4d7412295fa7b21c03a08da319e746a0d59ef14462a74183d118da4"
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, map[string]interface{} {
                "type": "deposit",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://hashkeyglobal-apidoc.readme.io/reference/withdrawal-records
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hashkey) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchWithdrawals"
        
            retRes19768 := (<-this.LoadMarkets())
            PanicOnError(retRes19768)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateGetApiV1AccountWithdrawOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "time": "1723545505366",
            //             "id": "W611267400947572736",
            //             "coin": "USDT",
            //             "coinId": "USDT",
            //             "coinName": "USDT",
            //             "address": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
            //             "quantity": "2.00000000",
            //             "arriveQuantity": "2.00000000",
            //             "txId": "f83f94e7d2e81fbec98c66c25d6615872cc2d426145629b6cf22e5e0a0753715",
            //             "addressUrl": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
            //             "feeCoinId": "USDT",
            //             "feeCoinName": "USDT",
            //             "fee": "1.00000000",
            //             "remark": "",
            //             "platform": ""
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, map[string]interface{} {
                "type": "withdrawal",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#withdraw
 * @description make a withdrawal
 * @see https://hashkeyglobal-apidoc.readme.io/reference/withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for withdraw
 * @param {string} [params.clientOrderId] client order id
 * @param {string} [params.platform] the platform to withdraw to (hashkey, HashKey HK)
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hashkey) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes20368 := (<-this.LoadMarkets())
            PanicOnError(retRes20368)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "address": address,
                "quantity": amount,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "addressExt", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chainType", this.NetworkCodeToId(networkCode))
            }
        
            response:= (<-this.PrivatePostApiV1AccountWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "id": "0",
            //         "orderId": "W611267400947572736",
            //         "accountId": "1732885739589466115"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  fetchDeposits
    //     {
    //         "time": "1721641082163",
    //         "coin": "TRXUSDT", // todo how to parse it?
    //         "coinName": "TRXUSDT",
    //         "address": "TBA6CypYJizwA9XdC7Ubgc5F1bxrQ7SqPt",
    //         "quantity": "86.00000000000000000000",
    //         "status": 4,
    //         "statusCode": "4",
    //         "txId": "0970c14da4d7412295fa7b21c03a08da319e746a0d59ef14462a74183d118da4"
    //     }
    //
    // fetchWithdrawals
    //     {
    //         "time": "1723545505366",
    //         "id": "W611267400947572736",
    //         "coin": "USDT",
    //         "coinId": "USDT",
    //         "coinName": "USDT",
    //         "address": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
    //         "quantity": "2.00000000",
    //         "arriveQuantity": "2.00000000",
    //         "txId": "f83f94e7d2e81fbec98c66c25d6615872cc2d426145629b6cf22e5e0a0753715",
    //         "addressUrl": "TQbkBMnWnJNGTAUpFS4kvv4NRLzUAnGAes",
    //         "feeCoinId": "USDT",
    //         "feeCoinName": "USDT",
    //         "fee": "1.00000000",
    //         "remark": "",
    //         "platform": ""
    //     }
    //
    // withdraw
    //     {
    //         "success": true,
    //         "id": "0",
    //         "orderId": "W611267400947572736",
    //         "accountId": "1732885739589466115"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString2(transaction, "id", "orderId")
    var address interface{} = this.SafeString(transaction, "address")
    var status interface{} = this.SafeString(transaction, "status") // for fetchDeposits
    if IsTrue(IsEqual(status, nil)) {
        var success interface{} = this.SafeBool(transaction, "success", false) // for withdraw
        if IsTrue(success) {
            status = "ok"
        } else {
            var addressUrl interface{} = this.SafeString(transaction, "addressUrl") // for fetchWithdrawals
            if IsTrue(!IsEqual(addressUrl, nil)) {
                status = "ok"
            }
        }
    }
    var txid interface{} = this.SafeString(transaction, "txId")
    var coin interface{} = this.SafeString(transaction, "coin")
    var code interface{} = this.SafeCurrencyCode(coin, currency)
    var timestamp interface{} = this.SafeInteger(transaction, "time")
    var amount interface{} = this.SafeNumber(transaction, "quantity")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": address,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": nil,
        "amount": amount,
        "currency": code,
        "status": this.ParseTransactionStatus(status),
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": fee,
    }
}
func  (this *hashkey) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "pending",
        "2": "pending",
        "3": "failed",
        "4": "ok",
        "5": "pending",
        "6": "ok",
        "7": "failed",
        "8": "cancelled",
        "9": "failed",
        "10": "failed",
        "successful": "ok",
        "success": "ok",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name hashkey#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://hashkeyglobal-apidoc.readme.io/reference/new-account-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account id to transfer from
 * @param {string} toAccount account id to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the transfer
 * @param {string} [params.remark] a note for the transfer
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *hashkey) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21888 := (<-this.LoadMarkets())
            PanicOnError(retRes21888)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "quantity": this.CurrencyToPrecision(code, amount),
                "fromAccountId": fromAccount,
                "toAccountId": toAccount,
            }
        
            response:= (<-this.PrivatePostApiV1AccountAssetTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "timestamp": 1722260230773,
            //         "clientOrderId": "",
            //         "orderId": "1740839420695806720"
            //     }
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
    var currencyId interface{} = this.SafeString(currency, "id")
    var status interface{} = nil
    var success interface{} = this.SafeBool(transfer, "success", false)
    if IsTrue(success) {
        status = "ok"
    }
    return map[string]interface{} {
        "id": this.SafeString(transfer, "orderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": status,
        "info": transfer,
    }
}
/**
 * @method
 * @name hashkey#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-sub-account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *hashkey) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22388 := (<-this.LoadMarkets())
            PanicOnError(retRes22388)
        
            response:= (<-this.PrivateGetApiV1AccountType(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "accountId": "1732885739589466112",
            //             "accountLabel": "Main Trading Account",
            //             "accountType": 1,
            //             "accountIndex": 0
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseAccounts(response, params)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseAccount(account interface{}) interface{}  {
    var accountLabel interface{} = this.SafeString(account, "accountLabel")
    var label interface{} = ""
    if IsTrue(IsTrue(IsEqual(accountLabel, "Main Trading Account")) || IsTrue(IsEqual(accountLabel, "Main Future Account"))) {
        label = "main"
    } else if IsTrue(IsTrue(IsEqual(accountLabel, "Sub Main Trading Account")) || IsTrue(IsEqual(accountLabel, "Sub Main Future Account"))) {
        label = "sub"
    }
    var accountType interface{} = this.ParseAccountType(this.SafeString(account, "accountType"))
    var typeVar interface{} = Add(Add(label, " "), accountType)
    return map[string]interface{} {
        "id": this.SafeString(account, "accountId"),
        "type": typeVar,
        "code": nil,
        "info": account,
    }
}
func  (this *hashkey) ParseAccountType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "1": "spot account",
        "3": "swap account",
        "5": "custody account",
        "6": "fiat account",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *hashkey) EncodeAccountType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "spot": "1",
        "swap": "3",
        "custody": "5",
    }
    return this.SafeInteger(types, typeVar, typeVar)
}
func  (this *hashkey) EncodeFlowType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "trade": "1",
        "fee": "3",
        "transfer": "51",
        "deposit": "900",
        "withdraw": "904",
    }
    return this.SafeInteger(types, typeVar, typeVar)
}
/**
 * @method
 * @name hashkey#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-account-transaction-list
 * @param {string} [code] unified currency code, default is undefined (not used)
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {int} [params.flowType] trade, fee, transfer, deposit, withdrawal
 * @param {int} [params.accountType] spot, swap, custody
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *hashkey) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchLedger"
            if IsTrue(IsEqual(since, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a since argument")))
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(IsEqual(until, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires an until argument")))
            }
        
            retRes23268 := (<-this.LoadMarkets())
            PanicOnError(retRes23268)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {}
            AddElementToObject(request, "startTime", since)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            AddElementToObject(request, "endTime", until)
            var flowType interface{} = nil
            flowTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "flowType");
            flowType = GetValue(flowTypeparamsVariable,0);
            params = GetValue(flowTypeparamsVariable,1)
            if IsTrue(!IsEqual(flowType, nil)) {
                AddElementToObject(request, "flowType", this.EncodeFlowType(flowType))
            }
            var accountType interface{} = nil
            accountTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "accountType");
            accountType = GetValue(accountTypeparamsVariable,0);
            params = GetValue(accountTypeparamsVariable,1)
            if IsTrue(!IsEqual(accountType, nil)) {
                AddElementToObject(request, "accountType", this.EncodeAccountType(accountType))
            }
        
            response:= (<-this.PrivateGetApiV1AccountBalanceFlow(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": "1740844413612065537",
            //             "accountId": "1732885739589466112",
            //             "coin": "USDT",
            //             "coinId": "USDT",
            //             "coinName": "USDT",
            //             "flowTypeValue": 51,
            //             "flowType": "USER_ACCOUNT_TRANSFER",
            //             "flowName": "",
            //             "change": "-1",
            //             "total": "8.015680088",
            //             "created": "1722260825765"
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "1": "trade",
        "2": "fee",
        "51": "transfer",
        "900": "deposit",
        "904": "withdraw",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *hashkey) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "1740844413612065537",
    //         "accountId": "1732885739589466112",
    //         "coin": "USDT",
    //         "coinId": "USDT",
    //         "coinName": "USDT",
    //         "flowTypeValue": 51,
    //         "flowType": "USER_ACCOUNT_TRANSFER",
    //         "flowName": "",
    //         "change": "-1",
    //         "total": "8.015680088",
    //         "created": "1722260825765"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "id")
    var account interface{} = this.SafeString(item, "accountId")
    var timestamp interface{} = this.SafeInteger(item, "created")
    var typeVar interface{} = this.ParseLedgerEntryType(this.SafeString(item, "flowTypeValue"))
    var currencyId interface{} = this.SafeString(item, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var amountString interface{} = this.SafeString(item, "change")
    var amount interface{} = this.ParseNumber(amountString)
    var direction interface{} = "in"
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(amountString, "-"), 0)) {
        direction = "out"
    }
    var afterString interface{} = this.SafeString(item, "total")
    var after interface{} = this.ParseNumber(afterString)
    var status interface{} = "ok"
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "account": account,
        "direction": direction,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": code,
        "symbol": nil,
        "amount": amount,
        "before": nil,
        "after": after,
        "status": status,
        "fee": nil,
    }, currency)
}
/**
 * @method
 * @name hashkey#createOrder
 * @description create a trade order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/test-new-order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/create-order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/create-new-futures-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER' for spot, 'market' or 'limit' or 'STOP' for swap
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {boolean} [params.test] *spot markets only* whether to use the test endpoint or not, default is false
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] "GTC" or "IOC" or "PO" for spot, 'GTC' or 'FOK' or 'IOC' or 'LIMIT_MAKER' or 'PO' for swap
 * @param {string} [params.clientOrderId] a unique id for the order - is mandatory for swap
 * @param {float} [params.triggerPrice] *swap markets only* The price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24518 := (<-this.LoadMarkets())
            PanicOnError(retRes24518)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
        
                    retRes245419 :=  (<-this.CreateSpotOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes245419)
                    ch <- retRes245419
                    return nil
            } else if IsTrue(GetValue(market, "swap")) {
        
                    retRes245619 :=  (<-this.CreateSwapOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes245619)
                    ch <- retRes245619
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " createOrder() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24728 := (<-this.LoadMarkets())
            PanicOnError(retRes24728)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() is supported for spot markets only")))
            }
            AddElementToObject(params, "cost", cost)
        
                retRes247815 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes247815)
                ch <- retRes247815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#createSpotOrder
 * @description create a trade order on spot market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/test-new-order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {bool} [params.test] whether to use the test endpoint or not, default is false
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] 'GTC', 'IOC', or 'PO'
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CreateSpotOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var triggerPrice interface{} = this.SafeString2(params, "stopPrice", "triggerPrice")
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                panic(NotSupported(Add(this.Id, " trigger orders are not supported for spot markets")))
            }
        
            retRes25058 := (<-this.LoadMarkets())
            PanicOnError(retRes25058)
            var market interface{} = this.Market(symbol)
            var isMarketBuy interface{} = IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))
            var cost interface{} = this.SafeString(params, "cost")
            if IsTrue(IsTrue((!IsTrue(isMarketBuy))) && IsTrue((!IsEqual(cost, nil)))) {
                panic(NotSupported(Add(this.Id, " createOrder() supports cost parameter for spot market buy orders only")))
            }
            var request interface{} = this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = map[string]interface{} {}
            var test interface{} = this.SafeBool(params, "test")
            if IsTrue(test) {
                params = this.Omit(params, "test")
                
        response = (<-this.PrivatePostApiV1SpotOrderTest(request))
                PanicOnError(response)
            } else if IsTrue(IsTrue(isMarketBuy) && IsTrue((IsEqual(cost, nil)))) {
                
        response = (<-this.PrivatePostApiV11SpotOrder(request))
                PanicOnError(response) // the endpoint for market buy orders by amount
            } else {
                
        response = (<-this.PrivatePostApiV1SpotOrder(request))
                PanicOnError(response) // the endpoint for market buy orders by cost and other orders
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    if IsTrue(GetValue(market, "spot")) {
        return this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params)
    } else if IsTrue(GetValue(market, "swap")) {
        return this.CreateSwapOrderRequest(symbol, typeVar, side, amount, price, params)
    } else {
        panic(NotSupported(Add(Add(Add(Add(this.Id, " "), "createOrderRequest() is not supported for "), GetValue(market, "type")), " type of markets")))
    }
}
func  (this *hashkey) CreateSpotOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name hashkey#createSpotOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
    * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
    * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
    * @param {string} [params.clientOrderId] a unique id for the order
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    typeVar = ToUpper(typeVar)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": ToUpper(side),
        "type": typeVar,
    }
    if IsTrue(!IsEqual(amount, nil)) {
        AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
    }
    var cost interface{} = nil
    costparamsVariable := this.HandleParamString(params, "cost");
    cost = GetValue(costparamsVariable,0);
    params = GetValue(costparamsVariable,1)
    if IsTrue(!IsEqual(cost, nil)) {
        AddElementToObject(request, "quantity", this.CostToPrecision(symbol, cost))
    }
    if IsTrue(!IsEqual(price, nil)) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var isMarketOrder interface{} = IsEqual(typeVar, "MARKET")
    var postOnly interface{} = false
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(typeVar, "LIMIT_MAKER"), params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    if IsTrue(IsTrue(postOnly) && IsTrue((IsEqual(typeVar, "LIMIT")))) {
        AddElementToObject(request, "type", "LIMIT_MAKER")
    }
    var clientOrderId interface{} = nil
    clientOrderIdparamsVariable := this.HandleParamString(params, "clientOrderId");
    clientOrderId = GetValue(clientOrderIdparamsVariable,0);
    params = GetValue(clientOrderIdparamsVariable,1)
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(params, "newClientOrderId", clientOrderId)
    }
    return this.Extend(request, params)
}
func  (this *hashkey) CreateSwapOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name hashkey#createSwapOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit' or 'STOP'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
    * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
    * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
    * @param {string} [params.timeInForce] 'GTC', 'FOK', 'IOC', 'LIMIT_MAKER' or 'PO'
    * @param {string} [params.clientOrderId] a unique id for the order
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "type": "LIMIT",
        "quantity": this.AmountToPrecision(symbol, amount),
    }
    var isMarketOrder interface{} = IsEqual(typeVar, "market")
    if IsTrue(isMarketOrder) {
        AddElementToObject(request, "priceType", "MARKET")
    }
    if IsTrue(!IsEqual(price, nil)) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        AddElementToObject(request, "priceType", "INPUT")
    }
    var reduceOnly interface{} = false
    reduceOnlyparamsVariable := this.HandleParamBool(params, "reduceOnly", reduceOnly);
    reduceOnly = GetValue(reduceOnlyparamsVariable,0);
    params = GetValue(reduceOnlyparamsVariable,1)
    var suffix interface{} = "_OPEN"
    if IsTrue(reduceOnly) {
        suffix = "_CLOSE"
    }
    AddElementToObject(request, "side", Add(ToUpper(side), suffix))
    var timeInForce interface{} = nil
    timeInForceparamsVariable := this.HandleParamString(params, "timeInForce");
    timeInForce = GetValue(timeInForceparamsVariable,0);
    params = GetValue(timeInForceparamsVariable,1)
    var postOnly interface{} = false
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(timeInForce, "LIMIT_MAKER"), params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    if IsTrue(postOnly) {
        timeInForce = "LIMIT_MAKER"
    }
    if IsTrue(!IsEqual(timeInForce, nil)) {
        AddElementToObject(request, "timeInForce", timeInForce)
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if IsTrue(IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "clientOrderId", this.Uuid())
    }
    var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
        AddElementToObject(request, "type", "STOP")
        params = this.Omit(params, "triggerPrice")
    }
    return this.Extend(request, params)
}
/**
 * @method
 * @name hashkey#createSwapOrder
 * @description create a trade order on swap market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/create-new-futures-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'STOP'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.timeInForce] 'GTC', 'FOK', 'IOC', 'LIMIT_MAKER' or 'PO'
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CreateSwapOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27468 := (<-this.LoadMarkets())
            PanicOnError(retRes27468)
            var market interface{} = this.Market(symbol)
            var request interface{} = this.CreateSwapOrderRequest(symbol, typeVar, side, amount, price, params)
        
            response:= (<-this.PrivatePostApiV1FuturesOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "time": "1722429951611",
            //         "updateTime": "1722429951648",
            //         "orderId": "1742263144028363776",
            //         "clientOrderId": "1722429950315",
            //         "symbol": "ETHUSDT-PERPETUAL",
            //         "price": "3460.62",
            //         "leverage": "5",
            //         "origQty": "10",
            //         "executedQty": "10",
            //         "avgPrice": "0",
            //         "marginLocked": "6.9212",
            //         "type": "LIMIT",
            //         "side": "BUY_OPEN",
            //         "timeInForce": "IOC",
            //         "status": "FILLED",
            //         "priceType": "MARKET",
            //         "contractMultiplier": "0.00100000"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://hashkeyglobal-apidoc.readme.io/reference/create-multiple-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-create-new-futures-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27858 := (<-this.LoadMarkets())
            PanicOnError(retRes27858)
            var ordersRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var symbol interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeNumber(rawOrder, "amount")
                var price interface{} = this.SafeNumber(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, orderParams)
                var clientOrderId interface{} = this.SafeString(orderRequest, "clientOrderId")
                if IsTrue(IsEqual(clientOrderId, nil)) {
                    AddElementToObject(orderRequest, "clientOrderId", this.Uuid()) // both spot and swap endpoints require clientOrderId
                }
                AppendToArray(&ordersRequests,orderRequest)
            }
            var firstOrder interface{} = GetValue(ordersRequests, 0)
            var firstSymbol interface{} = this.SafeString(firstOrder, "symbol")
            var market interface{} = this.Market(firstSymbol)
            var request interface{} = map[string]interface{} {
                "orders": ordersRequests,
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PrivatePostApiV1SpotBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PrivatePostApiV1FuturesBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(this.Id, " "), "createOrderRequest() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var result interface{} = this.SafeList(response, "result", []interface{}{})
            var responseOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var responseEntry interface{} = this.SafeDict(result, i, map[string]interface{} {})
                var responseOrder interface{} = this.SafeDict(responseEntry, "order", map[string]interface{} {})
                AppendToArray(&responseOrders,responseOrder)
            }
        
            ch <- this.ParseOrders(responseOrders)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#cancelOrder
 * @description cancels an open order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-futures-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
 * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
 * @param {bool} [params.trigger] *swap markets only* true for canceling a trigger order (default false)
 * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelOrder"
            this.CheckTypeParam(methodName, params)
        
            retRes29068 := (<-this.LoadMarkets())
            PanicOnError(retRes29068)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "orderId", id)
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateDeleteApiV1SpotOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var isTrigger interface{} = false
                isTriggerparamsVariable := this.HandleTriggerOptionAndParams(params, methodName, isTrigger);
                isTrigger = GetValue(isTriggerparamsVariable,0);
                params = GetValue(isTriggerparamsVariable,1)
                if IsTrue(isTrigger) {
                    AddElementToObject(request, "type", "STOP")
                } else {
                    AddElementToObject(request, "type", "LIMIT")
                }
                if IsTrue(!IsEqual(market, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                
        response = (<-this.PrivateDeleteApiV1FuturesOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#cancelAllOrders
 * @description cancel all open orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-all-open-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-cancel-futures-order
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] 'buy' or 'sell'
 * @returns {object} response from exchange
 */
func  (this *hashkey) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // Does not cancel trigger orders. For canceling trigger order use cancelOrder() or cancelOrders()
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelAllOrders"
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument")))
            }
        
            retRes29958 := (<-this.LoadMarkets())
            PanicOnError(retRes29958)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var side interface{} = this.SafeString(params, "side")
            if IsTrue(!IsEqual(side, nil)) {
                AddElementToObject(request, "side", side)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PrivateDeleteApiV1SpotOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PrivateDeleteApiV1FuturesBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var order interface{} = this.SafeOrder(response)
            AddElementToObject(order, "info", response)
        
            ch <- []interface{}{order}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#cancelOrders
 * @description cancel multiple orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/cancel-multiple-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/batch-cancel-futures-order-by-order-id
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol (not used by hashkey)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelOrders"
        
            retRes30378 := (<-this.LoadMarkets())
            PanicOnError(retRes30378)
            var request interface{} = map[string]interface{} {}
            var orderIds interface{} = Join(ids, ",")
            AddElementToObject(request, "ids", orderIds)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateDeleteApiV1SpotCancelOrderByIds(this.Extend(request)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                response = this.PrivateDeleteApiV1FuturesCancelOrderByIds(this.Extend(request))
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var order interface{} = this.SafeOrder(response)
            AddElementToObject(order, "info", response)
        
            ch <- []interface{}{order}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-order
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-order
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
 * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
 * @param {string} [params.accountId] *spot markets only* account id to fetch the order from
 * @param {bool} [params.trigger] *swap markets only* true for fetching a trigger order (default false)
 * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOrder"
            this.CheckTypeParam(methodName, params)
        
            retRes30858 := (<-this.LoadMarkets())
            PanicOnError(retRes30858)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = nil
            clientOrderIdparamsVariable := this.HandleParamString(params, "clientOrderId");
            clientOrderId = GetValue(clientOrderIdparamsVariable,0);
            params = GetValue(clientOrderIdparamsVariable,1)
            if IsTrue(IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "orderId", id)
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "origClientOrderId", clientOrderId)
                }
                
        response = (<-this.PrivateGetApiV1SpotOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var isTrigger interface{} = false
                isTriggerparamsVariable := this.HandleTriggerOptionAndParams(params, methodName, isTrigger);
                isTrigger = GetValue(isTriggerparamsVariable,0);
                params = GetValue(isTriggerparamsVariable,1)
                if IsTrue(isTrigger) {
                    AddElementToObject(request, "type", "STOP")
                }
                
        response = (<-this.PrivateGetApiV1FuturesOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-current-open-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-open-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/sub
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-open-futures-orders
 * @param {string} [symbol] unified market symbol of the market orders were made in - is mandatory for swap markets
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
 * @param {string} [params.orderId] *spot markets only* the id of the order to fetch
 * @param {string} [params.side] *spot markets only* 'buy' or 'sell' - the side of the orders to fetch
 * @param {string} [params.fromOrderId] *swap markets only* the id of the order to start from
 * @param {bool} [params.trigger] *swap markets only* true for fetching trigger orders (default false)
 * @param {bool} [params.stop] *swap markets only* an alternative for trigger param
 * @param {string} [params.accountId] account id to fetch the orders from
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOpenOrders"
            this.CheckTypeParam(methodName, params)
        
            retRes31938 := (<-this.LoadMarkets())
            PanicOnError(retRes31938)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            params = this.Extend(map[string]interface{} {
                "methodName": methodName,
            }, params)
            if IsTrue(IsEqual(marketType, "spot")) {
        
                    retRes320219 :=  (<-this.FetchOpenSpotOrders(symbol, since, limit, params))
                    PanicOnError(retRes320219)
                    ch <- retRes320219
                    return nil
            } else if IsTrue(IsEqual(marketType, "swap")) {
        
                    retRes320419 :=  (<-this.FetchOpenSwapOrders(symbol, since, limit, params))
                    PanicOnError(retRes320419)
                    ch <- retRes320419
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name hashkey#fetchOpenSpotOrders
 * @description fetch all unfilled currently open orders for spot markets
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-current-open-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/sub
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.orderId] the id of the order to fetch
 * @param {string} [params.side] 'buy' or 'sell' - the side of the orders to fetch
 * @param {string} [params.accountId] account id to fetch the orders from
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) FetchOpenSpotOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes32278 := (<-this.LoadMarkets())
            PanicOnError(retRes32278)
            var methodName interface{} = "fetchOpenSpotOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            var accountId interface{} = nil
            accountIdparamsVariable := this.HandleOptionAndParams(params, methodName, "accountId");
            accountId = GetValue(accountIdparamsVariable,0);
            params = GetValue(accountIdparamsVariable,1)
            if IsTrue(!IsEqual(accountId, nil)) {
                AddElementToObject(request, "subAccountId", accountId)
                
        response = (<-this.PrivateGetApiV1SpotSubAccountOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(symbol, nil)) {
                    market = this.Market(symbol)
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.PrivateGetApiV1SpotOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name hashkey#fetchOpenSwapOrders
 * @description fetch all unfilled currently open orders for swap markets
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-open-futures-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-open-orders
 * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve - maximum 500
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.fromOrderId] the id of the order to start from
 * @param {bool} [params.trigger] true for fetching trigger orders (default false)
 * @param {bool} [params.stop] an alternative for trigger param
 * @param {string} [params.accountId] account id to fetch the orders from
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) FetchOpenSwapOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOpenSwapOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for swap market orders")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var isTrigger interface{} = false
            isTriggerparamsVariable := this.HandleTriggerOptionAndParams(params, methodName, isTrigger);
            isTrigger = GetValue(isTriggerparamsVariable,0);
            params = GetValue(isTriggerparamsVariable,1)
            if IsTrue(isTrigger) {
                AddElementToObject(request, "type", "STOP")
            } else {
                AddElementToObject(request, "type", "LIMIT")
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            var accountId interface{} = nil
            accountIdparamsVariable := this.HandleOptionAndParams(params, methodName, "accountId");
            accountId = GetValue(accountIdparamsVariable,0);
            params = GetValue(accountIdparamsVariable,1)
            if IsTrue(!IsEqual(accountId, nil)) {
                AddElementToObject(request, "subAccountId", accountId)
                
        response = (<-this.PrivateGetApiV1FuturesSubAccountOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetApiV1FuturesOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchCanceledAndClosedOrders
 * @description fetches information on multiple canceled and closed orders made by the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-all-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-history-orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-sub-account-history-orders
 * @param {string} symbol *is mandatory for swap markets* unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve - default 500, maximum 1000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for - only supports the last 90 days timeframe
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
 * @param {string} [params.orderId] *spot markets only* the id of the order to fetch
 * @param {string} [params.side] *spot markets only* 'buy' or 'sell' - the side of the orders to fetch
 * @param {string} [params.fromOrderId] *swap markets only* the id of the order to start from
 * @param {bool} [params.trigger] *swap markets only* the id of the order to start from true for fetching trigger orders (default false)
 * @param {bool} [params.stop] *swap markets only* the id of the order to start from an alternative for trigger param
 * @param {string} [params.accountId] account id to fetch the orders from
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hashkey) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchCanceledAndClosedOrders"
            this.CheckTypeParam(methodName, params)
        
            retRes33958 := (<-this.LoadMarkets())
            PanicOnError(retRes33958)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            var accountId interface{} = nil
            accountIdparamsVariable := this.HandleOptionAndParams(params, methodName, "accountId");
            accountId = GetValue(accountIdparamsVariable,0);
            params = GetValue(accountIdparamsVariable,1)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(market, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                if IsTrue(!IsEqual(accountId, nil)) {
                    AddElementToObject(request, "accountId", accountId)
                }
                
        response = (<-this.PrivateGetApiV1SpotTradeOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for swap markets")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var isTrigger interface{} = false
                isTriggerparamsVariable := this.HandleTriggerOptionAndParams(params, methodName, isTrigger);
                isTrigger = GetValue(isTriggerparamsVariable,0);
                params = GetValue(isTriggerparamsVariable,1)
                if IsTrue(isTrigger) {
                    AddElementToObject(request, "type", "STOP")
                } else {
                    AddElementToObject(request, "type", "LIMIT")
                }
                if IsTrue(!IsEqual(accountId, nil)) {
                    AddElementToObject(request, "subAccountId", accountId)
                    
        response = (<-this.PrivateGetApiV1FuturesSubAccountHistoryOrders(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetApiV1FuturesHistoryOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) CheckTypeParam(methodName interface{}, params interface{})  {
    // some hashkey endpoints have a type param for swap markets that defines the type of an order
    // type param is reserved in ccxt for defining the type of the market
    // current method warns user if he provides the exchange specific value in type parameter
    var paramsType interface{} = this.SafeString(params, "type")
    if IsTrue(IsTrue(IsTrue((!IsEqual(paramsType, nil))) && IsTrue((!IsEqual(paramsType, "spot")))) && IsTrue((!IsEqual(paramsType, "swap")))) {
        panic(BadRequest(Add(Add(Add(Add(Add(this.Id, " "), methodName), " () type parameter can not be \""), paramsType), "\". It should define the type of the market (\"spot\" or \"swap\"). To define the type of an order use the trigger parameter (true for trigger orders)")))
    }
}
func  (this *hashkey) HandleTriggerOptionAndParams(params interface{}, methodName interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 0, nil)
    _ = defaultValue
    var isTrigger interface{} = defaultValue
    isTriggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "stop", "trigger", isTrigger);
    isTrigger = GetValue(isTriggerparamsVariable,0);
    params = GetValue(isTriggerparamsVariable,1)
    return []interface{}{isTrigger, params}
}
func  (this *hashkey) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder spot
    //     {
    //         "accountId": "1732885739589466112",
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "clientOrderId": "1722004623170558",
    //         "orderId": "1738695230608169984",
    //         "transactTime": "1722004623186",
    //         "price": "0",
    //         "origQty": "0",
    //         "executedQty": "0.0061",
    //         "status": "FILLED",
    //         "timeInForce": "IOC",
    //         "type": "MARKET",
    //         "side": "BUY",
    //         "reqAmount": "20",
    //         "concentration": ""
    //     }
    //
    // fetchOrder spot
    //     {
    //         "accountId": "1732885739589466112",
    //         "exchangeId": "301",
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "clientOrderId": "1722004623170558",
    //         "orderId": "1738695230608169984",
    //         "price": "0",
    //         "origQty": "0",
    //         "executedQty": "0.0061",
    //         "cummulativeQuoteQty": "19.736489",
    //         "cumulativeQuoteQty": "19.736489",
    //         "avgPrice": "3235.49",
    //         "status": "FILLED",
    //         "timeInForce": "IOC",
    //         "type": "MARKET",
    //         "side": "BUY",
    //         "stopPrice": "0.0",
    //         "icebergQty": "0.0",
    //         "time": "1722004623186",
    //         "updateTime": "1722004623406",
    //         "isWorking": true,
    //         "reqAmount": "20",
    //         "feeCoin": "",
    //         "feeAmount": "0",
    //         "sumFeeAmount": "0"
    //     }
    //
    // cancelOrder
    //     {
    //         "accountId": "1732885739589466112",
    //         "symbol": "ETHUSDT",
    //         "clientOrderId": "1722006209978370",
    //         "orderId": "1738708541676585728",
    //         "transactTime": "1722006209989",
    //         "price": "5000",
    //         "origQty": "0.005",
    //         "executedQty": "0",
    //         "status": "NEW",
    //         "timeInForce": "GTC",
    //         "type": "LIMIT_MAKER",
    //         "side": "SELL"
    //     }
    //
    // createOrder swap
    //     {
    //         "time": "1722429951611",
    //         "updateTime": "1722429951648",
    //         "orderId": "1742263144028363776",
    //         "clientOrderId": "1722429950315",
    //         "symbol": "ETHUSDT-PERPETUAL",
    //         "price": "3460.62",
    //         "leverage": "5",
    //         "origQty": "10",
    //         "executedQty": "10",
    //         "avgPrice": "0",
    //         "marginLocked": "6.9212",
    //         "type": "LIMIT",
    //         "side": "BUY_OPEN",
    //         "timeInForce": "IOC",
    //         "status": "FILLED",
    //         "priceType": "MARKET",
    //         "contractMultiplier": "0.00100000"
    //     }
    //
    // fetchOrder swap
    //     {
    //         "time": "1722429951611",
    //         "updateTime": "1722429951700",
    //         "orderId": "1742263144028363776",
    //         "clientOrderId": "1722429950315",
    //         "symbol": "ETHUSDT-PERPETUAL",
    //         "price": "3460.62",
    //         "leverage": "5",
    //         "origQty": "10",
    //         "executedQty": "10",
    //         "avgPrice": "3327.52",
    //         "marginLocked": "0",
    //         "type": "LIMIT",
    //         "side": "BUY_OPEN",
    //         "timeInForce": "IOC",
    //         "status": "FILLED",
    //         "priceType": "MARKET",
    //         "isLiquidationOrder": false,
    //         "indexPrice": "0",
    //         "liquidationType": ""
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger2(order, "transactTime", "time")
    var status interface{} = this.SafeString(order, "status")
    var typeVar interface{} = this.SafeString(order, "type")
    var priceType interface{} = this.SafeString(order, "priceType")
    if IsTrue(IsEqual(priceType, "MARKET")) {
        typeVar = "market"
    }
    var price interface{} = this.OmitZero(this.SafeString(order, "price"))
    if IsTrue(IsEqual(typeVar, "STOP")) {
        if IsTrue(IsEqual(price, nil)) {
            typeVar = "market"
        } else {
            typeVar = "limit"
        }
    }
    var timeInForce interface{} = this.SafeString(order, "timeInForce")
    var postOnly interface{} = nil
    typeVartimeInForcepostOnlyVariable := this.ParseOrderTypeTimeInForceAndPostOnly(typeVar, timeInForce);
    typeVar = GetValue(typeVartimeInForcepostOnlyVariable,0);
    timeInForce = GetValue(typeVartimeInForcepostOnlyVariable,1);
    postOnly = GetValue(typeVartimeInForcepostOnlyVariable,2)
    var average interface{} = this.OmitZero(this.SafeString(order, "avgPrice"))
    if IsTrue(IsEqual(price, nil)) {
        price = average
    }
    var side interface{} = this.SafeStringLower(order, "side")
    var reduceOnly interface{} = nil
    sidereduceOnlyVariable := this.ParseOrderSideAndReduceOnly(side);
    side = GetValue(sidereduceOnlyVariable,0);
    reduceOnly = GetValue(sidereduceOnlyVariable,1)
    var feeCurrncyId interface{} = this.SafeString(order, "feeCoin")
    if IsTrue(IsEqual(feeCurrncyId, "")) {
        feeCurrncyId = nil
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": this.SafeInteger(order, "updateTime"),
        "status": this.ParseOrderStatus(status),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": price,
        "average": average,
        "amount": this.OmitZero(this.SafeString(order, "origQty")),
        "filled": this.SafeString(order, "executedQty"),
        "remaining": nil,
        "triggerPrice": this.OmitZero(this.SafeString(order, "stopPrice")),
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "cost": this.OmitZero(this.SafeString2(order, "cumulativeQuoteQty", "cummulativeQuoteQty")),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrncyId),
            "amount": this.OmitZero(this.SafeString(order, "feeAmount")),
        },
        "reduceOnly": reduceOnly,
        "postOnly": postOnly,
        "info": order,
    }, market)
}
func  (this *hashkey) ParseOrderSideAndReduceOnly(unparsed interface{}) interface{}  {
    var parts interface{} = Split(unparsed, "_")
    var side interface{} = GetValue(parts, 0)
    var reduceOnly interface{} = nil
    var secondPart interface{} = this.SafeString(parts, 1)
    if IsTrue(!IsEqual(secondPart, nil)) {
        if IsTrue(IsEqual(secondPart, "open")) {
            reduceOnly = false
        } else if IsTrue((IsEqual(secondPart, "close"))) {
            reduceOnly = true
        }
    }
    return []interface{}{side, reduceOnly}
}
func  (this *hashkey) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIALLY_FILLED": "open",
        "PARTIALLY_CANCELED": "canceled",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "ORDER_CANCELED": "canceled",
        "PENDING_CANCEL": "canceled",
        "REJECTED": "rejected",
        "ORDER_NEW": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hashkey) ParseOrderTypeTimeInForceAndPostOnly(typeVar interface{}, timeInForce interface{}) interface{}  {
    var postOnly interface{} = nil
    if IsTrue(IsEqual(typeVar, "LIMIT_MAKER")) {
        postOnly = true
    } else if IsTrue(IsTrue((IsEqual(timeInForce, "LIMIT_MAKER"))) || IsTrue((IsEqual(timeInForce, "MAKER")))) {
        postOnly = true
        timeInForce = "PO"
    }
    typeVar = this.ParseOrderType(typeVar)
    return []interface{}{typeVar, timeInForce, postOnly}
}
func  (this *hashkey) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "LIMIT_MAKER": "limit",
        "MARKET_OF_BASE": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name hashkey#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *hashkey) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37548 := (<-this.LoadMarkets())
            PanicOnError(retRes37548)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "timestamp": this.Milliseconds(),
            }
        
            response:= (<-this.PublicGetApiV1FuturesFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         { "symbol": "ETHUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" }
            //     ]
            //
            var rate interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParseFundingRate(rate, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-funding-rate
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *hashkey) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes37808 := (<-this.LoadMarkets())
            PanicOnError(retRes37808)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "timestamp": this.Milliseconds(),
            }
        
            response:= (<-this.PublicGetApiV1FuturesFundingRate(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         { "symbol": "BTCUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" },
            //         { "symbol": "ETHUSDT-PERPETUAL", "rate": "0.0001", "nextSettleTime": "1722297600000" }
            //     ]
            //
        ch <- this.ParseFundingRates(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ETHUSDT-PERPETUAL",
    //         "rate": "0.0001",
    //         "nextSettleTime": "1722297600000"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    market = this.SafeMarket(marketId, market, nil, "swap")
    var fundingRate interface{} = this.SafeNumber(contract, "rate")
    var fundingTimestamp interface{} = this.SafeInteger(contract, "nextSettleTime")
    return map[string]interface{} {
        "info": contract,
        "symbol": GetValue(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": fundingRate,
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": fundingTimestamp,
        "nextFundingDatetime": this.Iso8601(fundingTimestamp),
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
/**
 * @method
 * @name hashkey#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-history-funding-rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.fromId] the id of the entry to start from
 * @param {int} [params.endId] the id of the entry to end with
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *hashkey) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes38438 := (<-this.LoadMarkets())
            PanicOnError(retRes38438)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetApiV1FuturesHistoryFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "10698",
            //             "symbol": "ETHUSDT-PERPETUAL",
            //             "settleTime": "1722268800000",
            //             "settleRate": "0.0001"
            //         },
            //         ...
            //     ]
            //
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var timestamp interface{} = this.SafeInteger(entry, "settleTime")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(this.SafeString(entry, "symbol"), market, nil, "swap"),
                    "fundingRate": this.SafeNumber(entry, "settleRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySinceLimit(sorted, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @description fetch open positions for a market
 * @name hashkey#fetchPositions
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-positions
 * @description fetch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] 'LONG' or 'SHORT' - the direction of the position (if not provided, positions for both sides will be returned)
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *hashkey) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchPositions"
            if IsTrue((IsEqual(symbols, nil))) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument with one single market symbol")))
            } else {
                var symbolsLength interface{} =         GetArrayLength(symbols)
                if IsTrue(!IsEqual(symbolsLength, 1)) {
                    panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() is supported for a symbol argument with one single market symbol only")))
                }
            }
        
            retRes39038 := (<-this.LoadMarkets())
            PanicOnError(retRes39038)
        
                retRes390415 :=  (<-this.FetchPositionsForSymbol(GetValue(symbols, 0), this.Extend(map[string]interface{} {
                "methodName": "fetchPositions",
            }, params)))
                PanicOnError(retRes390415)
                ch <- retRes390415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @description fetch open positions for a single market
 * @name hashkey#fetchPositionsForSymbol
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-positions
 * @description fetch all open positions for specific symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] 'LONG' or 'SHORT' - the direction of the position (if not provided, positions for both sides will be returned)
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *hashkey) FetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes39198 := (<-this.LoadMarkets())
            PanicOnError(retRes39198)
            var market interface{} = this.Market(symbol)
            var methodName interface{} = "fetchPosition"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            if !IsTrue(GetValue(market, "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() supports swap markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetApiV1FuturesPositions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "ETHUSDT-PERPETUAL",
            //             "side": "LONG",
            //             "avgPrice": "3327.52",
            //             "position": "10",
            //             "available": "0",
            //             "leverage": "5",
            //             "lastPrice": "3324.44",
            //             "positionValue": "33.2752",
            //             "liquidationPrice": "-953.83",
            //             "margin": "6.9012",
            //             "marginRate": "",
            //             "unrealizedPnL": "-0.0288",
            //             "profitRate": "-0.0041",
            //             "realizedPnL": "-0.0199",
            //             "minMargin": "0.2173"
            //         }
            //     ]
            //
        ch <- this.ParsePositions(response, []interface{}{symbol})
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    return this.SafePosition(map[string]interface{} {
        "symbol": symbol,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "contracts": this.SafeNumber(position, "position"),
        "contractSize": nil,
        "side": this.SafeStringLower(position, "side"),
        "notional": this.SafeNumber(position, "positionValue"),
        "leverage": this.SafeInteger(position, "leverage"),
        "unrealizedPnl": this.SafeNumber(position, "unrealizedPnL"),
        "realizedPnl": this.SafeNumber(position, "realizedPnL"),
        "collateral": nil,
        "entryPrice": this.SafeNumber(position, "avgPrice"),
        "markPrice": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidationPrice"),
        "marginMode": "cross",
        "hedged": true,
        "maintenanceMargin": this.SafeNumber(position, "minMargin"),
        "maintenanceMarginPercentage": nil,
        "initialMargin": this.SafeNumber(position, "margin"),
        "initialMarginPercentage": nil,
        "marginRatio": nil,
        "lastUpdateTimestamp": nil,
        "lastPrice": this.SafeNumber(position, "lastPrice"),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "percentage": nil,
        "info": position,
    })
}
/**
 * @method
 * @name hashkey#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/query-futures-leverage-trade
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *hashkey) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes40008 := (<-this.LoadMarkets())
            PanicOnError(retRes40008)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetApiV1FuturesLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "symbolId": "ETHUSDT-PERPETUAL",
            //             "leverage": "5",
            //             "marginType": "CROSS"
            //         }
            //     ]
            //
            var leverage interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParseLeverage(leverage, market)
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginMode interface{} = this.SafeStringLower(leverage, "marginType")
    var leverageValue interface{} = this.SafeNumber(leverage, "leverage")
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginMode,
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name hashkey#setLeverage
 * @description set the level of leverage for a market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/change-futures-leverage-trade
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *hashkey) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes40458 := (<-this.LoadMarkets())
            PanicOnError(retRes40458)
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
            var market interface{} = this.Market(symbol)
            AddElementToObject(request, "symbol", GetValue(market, "id"))
        
            response:= (<-this.PrivatePostApiV1FuturesLeverage(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "0000",
            //         "symbolId": "ETHUSDT-PERPETUAL",
            //         "leverage": "3"
            //     }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @see https://hashkeyglobal-apidoc.readme.io/reference/exchangeinfo
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func  (this *hashkey) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes40728 := (<-this.LoadMarkets())
            PanicOnError(retRes40728)
        
            response:= (<-this.PublicGetApiV1ExchangeInfo(params))
            PanicOnError(response)
            // response is the same as in fetchMarkets()
            var data interface{} = this.SafeList(response, "contracts", []interface{}{})
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.ParseLeverageTiers(data, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "filters": [
    //             {
    //                 "minPrice": "0.1",
    //                 "maxPrice": "100000.00000000",
    //                 "tickSize": "0.1",
    //                 "filterType": "PRICE_FILTER"
    //             },
    //             {
    //                 "minQty": "0.001",
    //                 "maxQty": "10",
    //                 "stepSize": "0.001",
    //                 "marketOrderMinQty": "0",
    //                 "marketOrderMaxQty": "0",
    //                 "filterType": "LOT_SIZE"
    //             },
    //             {
    //                 "minNotional": "0",
    //                 "filterType": "MIN_NOTIONAL"
    //             },
    //             {
    //                 "maxSellPrice": "999999",
    //                 "buyPriceUpRate": "0.05",
    //                 "sellPriceDownRate": "0.05",
    //                 "maxEntrustNum": 200,
    //                 "maxConditionNum": 200,
    //                 "filterType": "LIMIT_TRADING"
    //             },
    //             {
    //                 "buyPriceUpRate": "0.05",
    //                 "sellPriceDownRate": "0.05",
    //                 "filterType": "MARKET_TRADING"
    //             },
    //             {
    //                 "noAllowMarketStartTime": "0",
    //                 "noAllowMarketEndTime": "0",
    //                 "limitOrderStartTime": "0",
    //                 "limitOrderEndTime": "0",
    //                 "limitMinPrice": "0",
    //                 "limitMaxPrice": "0",
    //                 "filterType": "OPEN_QUOTE"
    //             }
    //         ],
    //         "exchangeId": "301",
    //         "symbol": "BTCUSDT-PERPETUAL",
    //         "symbolName": "BTCUSDT-PERPETUAL",
    //         "status": "TRADING",
    //         "baseAsset": "BTCUSDT-PERPETUAL",
    //         "baseAssetPrecision": "0.001",
    //         "quoteAsset": "USDT",
    //         "quoteAssetPrecision": "0.1",
    //         "icebergAllowed": false,
    //         "inverse": false,
    //         "index": "USDT",
    //         "marginToken": "USDT",
    //         "marginPrecision": "0.0001",
    //         "contractMultiplier": "0.001",
    //         "underlying": "BTC",
    //         "riskLimits": [
    //             {
    //                 "riskLimitId": "200000722",
    //                 "quantity": "1000.00",
    //                 "initialMargin": "0.10",
    //                 "maintMargin": "0.005",
    //                 "isWhite": false
    //             },
    //             {
    //                 "riskLimitId": "200000723",
    //                 "quantity": "2000.00",
    //                 "initialMargin": "0.10",
    //                 "maintMargin": "0.01",
    //                 "isWhite": false
    //             }
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var riskLimits interface{} = this.SafeList(info, "riskLimits", []interface{}{})
    var marketId interface{} = this.SafeString(info, "symbol")
    market = this.SafeMarket(marketId, market)
    var tiers interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(riskLimits)); i++ {
        var tier interface{} = GetValue(riskLimits, i)
        var initialMarginRate interface{} = this.SafeString(tier, "initialMargin")
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.Sum(i, 1),
            "symbol": this.SafeSymbol(marketId, market),
            "currency": GetValue(market, "settle"),
            "minNotional": nil,
            "maxNotional": this.SafeNumber(tier, "quantity"),
            "maintenanceMarginRate": this.SafeNumber(tier, "maintMargin"),
            "maxLeverage": this.ParseNumber(Precise.StringDiv("1", initialMarginRate)),
            "info": tier,
        })
    }
    return tiers
}
/**
 * @method
 * @name hashkey#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://developers.binance.com/docs/wallet/asset/trade-fee // spot
 * @see https://hashkeyglobal-apidoc.readme.io/reference/get-futures-commission-rate-request-weight // swap
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *hashkey) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes41908 := (<-this.LoadMarkets())
            PanicOnError(retRes41908)
            var market interface{} = this.Market(symbol)
            var methodName interface{} = "fetchTradingFee"
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.FetchTradingFees(params))
                PanicOnError(response)
        
                ch <- this.SafeDict(response, symbol)
                return nil
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PrivateGetApiV1FuturesCommissionRate(this.Extend(map[string]interface{} {
            "symbol": GetValue(market, "id"),
        }, params)))
                PanicOnError(response)
        
                ch <- this.ParseTradingFee(response, market)
                return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name hashkey#fetchTradingFees
 * @description *for spot markets only* fetch the trading fees for multiple markets
 * @see https://developers.binance.com/docs/wallet/asset/trade-fee
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *hashkey) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42228 := (<-this.LoadMarkets())
            PanicOnError(retRes42228)
        
            response:= (<-this.PrivateGetApiV1AccountVipInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "vipLevel": "0",
            //         "tradeVol30Day": "67",
            //         "totalAssetBal": "0",
            //         "data": [
            //             {
            //                 "symbol": "UXLINKUSDT",
            //                 "productType": "Token-Token",
            //                 "buyMakerFeeCurrency": "UXLINK",
            //                 "buyTakerFeeCurrency": "UXLINK",
            //                 "sellMakerFeeCurrency": "USDT",
            //                 "sellTakerFeeCurrency": "USDT",
            //                 "actualMakerRate": "0.0012",
            //                 "actualTakerRate": "0.0012"
            //             },
            //             ...
            //         ],
            //         "updateTimestamp": "1722320137809"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var fee interface{} = this.SafeDict(data, i, map[string]interface{} {})
                var parsedFee interface{} = this.ParseTradingFee(fee)
                AddElementToObject(result, GetValue(parsedFee, "symbol"), parsedFee)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *hashkey) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         "symbol": "UXLINKUSDT",
    //         "productType": "Token-Token",
    //         "buyMakerFeeCurrency": "UXLINK",
    //         "buyTakerFeeCurrency": "UXLINK",
    //         "sellMakerFeeCurrency": "USDT",
    //         "sellTakerFeeCurrency": "USDT",
    //         "actualMakerRate": "0.0012",
    //         "actualTakerRate": "0.0012"
    //     }
    //
    // swap
    //     {
    //         "openMakerFee": "0.00025",
    //         "openTakerFee": "0.0006",
    //         "closeMakerFee": "0.00025",
    //         "closeTakerFee": "0.0006"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    market = this.SafeMarket(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": GetValue(market, "symbol"),
        "maker": this.SafeNumber2(fee, "openMakerFee", "actualMakerRate"),
        "taker": this.SafeNumber2(fee, "openTakerFee", "actualTakerRate"),
        "percentage": true,
        "tierBased": true,
    }
}
func  (this *hashkey) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    var query interface{} = nil
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = this.Milliseconds()
        var additionalParams interface{} = map[string]interface{} {
            "timestamp": timestamp,
        }
        var recvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
        if IsTrue(!IsEqual(recvWindow, nil)) {
            AddElementToObject(additionalParams, "recvWindow", recvWindow)
        }
        headers = map[string]interface{} {
            "X-HK-APIKEY": this.ApiKey,
            "Content-Type": "application/x-www-form-urlencoded",
        }
        var signature interface{} = nil
        if IsTrue(IsTrue((IsEqual(method, "POST"))) && IsTrue((IsTrue((IsEqual(path, "api/v1/spot/batchOrders"))) || IsTrue((IsEqual(path, "api/v1/futures/batchOrders")))))) {
            AddElementToObject(headers, "Content-Type", "application/json")
            body = this.Json(this.SafeList(params, "orders"))
            signature = this.Hmac(this.Encode(this.CustomUrlencode(additionalParams)), this.Encode(this.Secret), sha256)
            query = this.CustomUrlencode(this.Extend(additionalParams, map[string]interface{} {
                "signature": signature,
            }))
            url = Add(url, Add("?", query))
        } else {
            var totalParams interface{} = this.Extend(additionalParams, params)
            signature = this.Hmac(this.Encode(this.CustomUrlencode(totalParams)), this.Encode(this.Secret), sha256)
            AddElementToObject(totalParams, "signature", signature)
            query = this.CustomUrlencode(totalParams)
            if IsTrue(IsEqual(method, "GET")) {
                url = Add(url, Add("?", query))
            } else {
                body = query
            }
        }
        AddElementToObject(headers, "INPUT-SOURCE", this.SafeString(this.Options, "broker", "10000700011"))
        AddElementToObject(headers, "broker_sign", signature)
    } else {
        query = this.Urlencode(params)
        if IsTrue(!IsEqual(GetLength(query), 0)) {
            url = Add(url, Add("?", query))
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *hashkey) CustomUrlencode(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var result interface{} = this.Urlencode(params)
    result = Replace(result, "%2C", ",")
    return result
}
func  (this *hashkey) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorInArray interface{} = false
    var responseCodeString interface{} = this.SafeString(response, "code", nil)
    var responseCodeInteger interface{} = this.SafeInteger(response, "code", nil) // some codes in response are returned as '0000' others as 0
    if IsTrue(IsEqual(responseCodeInteger, 0)) {
        var result interface{} = this.SafeList(response, "result", []interface{}{}) // for batch methods
        for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
            var entry interface{} = this.SafeDict(result, i)
            var entryCodeInteger interface{} = this.SafeInteger(entry, "code")
            if IsTrue(!IsEqual(entryCodeInteger, 0)) {
                errorInArray = true
                responseCodeString = this.SafeString(entry, "code")
            }
        }
    }
    if IsTrue(IsTrue((!IsEqual(code, 200))) || IsTrue(errorInArray)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), responseCodeString, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCodeString, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *hashkey) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
