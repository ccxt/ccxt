package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bigone struct {
    Exchange

}

func NewBigoneCore() bigone {
   p := bigone{}
   setDefaults(&p)
   return p
}

func  (this *bigone) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bigone",
        "name": "BigONE",
        "countries": []interface{}{"CN"},
        "version": "v3",
        "rateLimit": 20,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": nil,
            "future": nil,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createPostOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFees": false,
            "fetchWithdrawals": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "min1",
            "5m": "min5",
            "15m": "min15",
            "30m": "min30",
            "1h": "hour1",
            "3h": "hour3",
            "4h": "hour4",
            "6h": "hour6",
            "12h": "hour12",
            "1d": "day1",
            "1w": "week1",
            "1M": "month1",
        },
        "hostname": "big.one",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/4e5cfd53-98cc-4b90-92cd-0d7b512653d1",
            "api": map[string]interface{} {
                "public": "https://{hostname}/api/v3",
                "private": "https://{hostname}/api/v3/viewer",
                "contractPublic": "https://{hostname}/api/contract/v2",
                "contractPrivate": "https://{hostname}/api/contract/v2",
                "webExchange": "https://{hostname}/api/",
            },
            "www": "https://big.one",
            "doc": "https://open.big.one/docs/api.html",
            "fees": "https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",
            "referral": "https://b1.run/users/new?code=D3LLBVFT",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"ping", "asset_pairs", "asset_pairs/{asset_pair_name}/depth", "asset_pairs/{asset_pair_name}/trades", "asset_pairs/{asset_pair_name}/ticker", "asset_pairs/{asset_pair_name}/candles", "asset_pairs/tickers"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"accounts", "fund/accounts", "assets/{asset_symbol}/address", "orders", "orders/{id}", "orders/multi", "trades", "withdrawals", "deposits"},
                "post": []interface{}{"orders", "orders/{id}/cancel", "orders/cancel", "withdrawals", "transfer"},
            },
            "contractPublic": map[string]interface{} {
                "get": []interface{}{"symbols", "instruments", "depth@{symbol}/snapshot", "instruments/difference", "instruments/prices"},
            },
            "contractPrivate": map[string]interface{} {
                "get": []interface{}{"accounts", "orders/{id}", "orders", "orders/opening", "orders/count", "orders/opening/count", "trades", "trades/count"},
                "post": []interface{}{"orders", "orders/batch"},
                "put": []interface{}{"positions/{symbol}/margin", "positions/{symbol}/risk-limit"},
                "delete": []interface{}{"orders/{id}", "orders/batch"},
            },
            "webExchange": map[string]interface{} {
                "get": []interface{}{"v3/assets"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.001"),
                "taker": this.ParseNumber("0.001"),
            },
            "funding": map[string]interface{} {
                "withdraw": map[string]interface{} {},
            },
        },
        "options": map[string]interface{} {
            "createMarketBuyOrderRequiresPrice": true,
            "accountsByType": map[string]interface{} {
                "spot": "SPOT",
                "fund": "FUND",
                "funding": "FUND",
                "future": "CONTRACT",
                "swap": "CONTRACT",
            },
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "exchangeMillisecondsCorrection": OpNeg(100),
            "fetchCurrencies": map[string]interface{} {
                "webApiEnable": true,
                "webApiRetries": 5,
                "webApiMuteFailure": true,
            },
            "defaultNetwork": "ERC20",
            "defaultNetworks": map[string]interface{} {
                "USDT": "TRC20",
            },
            "networks": map[string]interface{} {
                "ABBC": "ABBC",
                "ACA": "Acala",
                "AE": "Aeternity",
                "ALGO": "Algorand",
                "APT": "Aptos",
                "AR": "Arweave",
                "ASTR": "Astar",
                "AVAXC": "Avax",
                "AVAXX": "AvaxChain",
                "BEAM": "Beam",
                "BEP20": "BinanceSmartChain",
                "BITCI": "BitciChain",
                "BTC": "Bitcoin",
                "BCH": "BitcoinCash",
                "BSV": "BitcoinSV",
                "CELO": "Celo",
                "CKKB": "CKB",
                "ATOM": "Cosmos",
                "CRC20": "CRO",
                "DASH": "Dash",
                "DOGE": "Dogecoin",
                "XEC": "ECash",
                "EOS": "EOS",
                "ETH": "Ethereum",
                "ETC": "EthereumClassic",
                "ETHW": "EthereumPow",
                "FTM": "Fantom",
                "FIL": "Filecoin",
                "FSN": "Fusion",
                "GRIN": "Grin",
                "ONE": "Harmony",
                "HRC20": "Hecochain",
                "HBAR": "Hedera",
                "HNT": "Helium",
                "ZEN": "Horizen",
                "IOST": "IOST",
                "IRIS": "IRIS",
                "KLAY": "Klaytn",
                "KSM": "Kusama",
                "LTC": "Litecoin",
                "XMR": "Monero",
                "GLMR": "Moonbeam",
                "NEAR": "Near",
                "NEO": "Neo",
                "NEON3": "NeoN3",
                "OASIS": "Oasis",
                "OKC": "Okexchain",
                "ONT": "Ontology",
                "OPTIMISM": "Optimism",
                "DOT": "Polkadot",
                "MATIC": "Polygon",
                "QTUM": "Qtum",
                "REI": "REI",
                "XRP": "Ripple",
                "SGB": "SGB",
                "SDN": "Shiden",
                "SOL": "Solana",
                "XLM": "Stellar",
                "TERA": "Tera",
                "XTZ": "Tezos",
                "TRC20": "Tron",
                "VET": "Vechain",
                "VSYS": "VSystems",
                "WAX": "WAX",
                "ZEC": "Zcash",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": true,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": true,
                    "marketBuyByCost": true,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "triggerPriceType": map[string]interface{} {
                        "mark": true,
                        "index": true,
                        "last": true,
                    },
                },
                "fetchOrders": map[string]interface{} {
                    "daysBack": 100000,
                    "untilDays": 100000,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "daysBack": 100000,
                    "untilDays": 100000,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "10001": BadRequest,
                "10005": ExchangeError,
                "Amount\\'s scale must greater than AssetPair\\'s base scale": InvalidOrder,
                "Price mulit with amount should larger than AssetPair\\'s min_quote_value": InvalidOrder,
                "10007": BadRequest,
                "10011": ExchangeError,
                "10013": BadSymbol,
                "10014": InsufficientFunds,
                "10403": PermissionDenied,
                "10429": RateLimitExceeded,
                "40004": AuthenticationError,
                "40103": AuthenticationError,
                "40104": AuthenticationError,
                "40301": PermissionDenied,
                "40302": ExchangeError,
                "40601": ExchangeError,
                "40602": ExchangeError,
                "40603": InsufficientFunds,
                "40604": InvalidOrder,
                "40605": InvalidOrder,
                "40120": InvalidOrder,
                "40121": InvalidOrder,
                "60100": BadSymbol,
            },
            "broad": map[string]interface{} {},
        },
        "commonCurrencies": map[string]interface{} {
            "CRE": "Cybereits",
            "FXT": "FXTTOKEN",
            "FREE": "FreeRossDAO",
            "MBN": "Mobilian Coin",
            "ONE": "BigONE Token",
        },
    })
}
/**
 * @method
 * @name bigone#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {dict} [params] extra parameters specific to the exchange API endpoint
 * @returns {dict} an associative dictionary of currencies
 */
func  (this *bigone) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // we use undocumented link (possible, less informative alternative is : https://big.one/api/uc/v3/assets/accounts)
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            data:= (<-this.FetchWebEndpoint("fetchCurrencies", "webExchangeGetV3Assets", true))
            PanicOnError(data)
            if IsTrue(IsEqual(data, nil)) {
        
                return nil
            }
            //
            // {
            //     "code": "0",
            //     "message": "",
            //     "data": [
            //       {
            //             "uuid": "17082d1c-0195-4fb6-8779-2cdbcb9eeb3c",
            //             "symbol": "USDT",
            //             "name": "TetherUS",
            //             "scale": 12,
            //             "is_fiat": false,
            //             "is_transfer_enabled": true,
            //             "transfer_scale": 12,
            //             "binding_gateways": [
            //                 {
            //                     "guid": "07efc37f-d1ec-4bc9-8339-a745256ea2ba",
            //                     "is_deposit_enabled": true,
            //                     "gateway_name": "Ethereum",
            //                     "min_withdrawal_amount": "0.000001",
            //                     "withdrawal_fee": "5.71",
            //                     "is_withdrawal_enabled": true,
            //                     "min_deposit_amount": "0.000001",
            //                     "is_memo_required": false,
            //                     "withdrawal_scale": 6,
            //                     "scale": 12
            //                 },
            //                 {
            //                     "guid": "4e387a9a-a480-40a3-b4ae-ed1773c2db5a",
            //                     "is_deposit_enabled": true,
            //                     "gateway_name": "BinanceSmartChain",
            //                     "min_withdrawal_amount": "10",
            //                     "withdrawal_fee": "5",
            //                     "is_withdrawal_enabled": false,
            //                     "min_deposit_amount": "1",
            //                     "is_memo_required": false,
            //                     "withdrawal_scale": 8,
            //                     "scale": 12
            //                 }
            //             ]
            //         },
            //       ...
            //     ],
            // }
            //
            var currenciesData interface{} = this.SafeList(data, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
                var currency interface{} = GetValue(currenciesData, i)
                var id interface{} = this.SafeString(currency, "symbol")
                var code interface{} = this.SafeCurrencyCode(id)
                var name interface{} = this.SafeString(currency, "name")
                var typeVar interface{} = Ternary(IsTrue(this.SafeBool(currency, "is_fiat")), "fiat", "crypto")
                var networks interface{} = map[string]interface{} {}
                var chains interface{} = this.SafeList(currency, "binding_gateways", []interface{}{})
                var currencyMaxPrecision interface{} = this.ParsePrecision(this.SafeString2(currency, "withdrawal_scale", "scale"))
                var currencyDepositEnabled interface{} = nil
                var currencyWithdrawEnabled interface{} = nil
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString(chain, "gateway_name")
                    var networkCode interface{} = this.NetworkIdToCode(networkId)
                    var deposit interface{} = this.SafeBool(chain, "is_deposit_enabled")
                    var withdraw interface{} = this.SafeBool(chain, "is_withdrawal_enabled")
                    var isActive interface{} =             (IsTrue(deposit) && IsTrue(withdraw))
                    var minDepositAmount interface{} = this.SafeString(chain, "min_deposit_amount")
                    var minWithdrawalAmount interface{} = this.SafeString(chain, "min_withdrawal_amount")
                    var withdrawalFee interface{} = this.SafeString(chain, "withdrawal_fee")
                    var precision interface{} = this.ParsePrecision(this.SafeString2(chain, "withdrawal_scale", "scale"))
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "id": networkId,
            "network": networkCode,
            "margin": nil,
            "deposit": deposit,
            "withdraw": withdraw,
            "active": isActive,
            "fee": this.ParseNumber(withdrawalFee),
            "precision": this.ParseNumber(precision),
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": minDepositAmount,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": minWithdrawalAmount,
                    "max": nil,
                },
            },
            "info": chain,
        })
                    // fill global values
                    currencyDepositEnabled = Ternary(IsTrue(IsTrue((IsEqual(currencyDepositEnabled, nil))) || IsTrue(deposit)), deposit, currencyDepositEnabled)
                    currencyWithdrawEnabled = Ternary(IsTrue(IsTrue((IsEqual(currencyWithdrawEnabled, nil))) || IsTrue(withdraw)), withdraw, currencyWithdrawEnabled)
                    currencyMaxPrecision = Ternary(IsTrue(IsTrue((IsEqual(currencyMaxPrecision, nil))) || IsTrue(Precise.StringGt(currencyMaxPrecision, precision))), precision, currencyMaxPrecision)
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "name": name,
            "type": typeVar,
            "active": nil,
            "deposit": currencyDepositEnabled,
            "withdraw": currencyWithdrawEnabled,
            "fee": nil,
            "precision": this.ParseNumber(currencyMaxPrecision),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchMarkets
 * @description retrieves data on all markets for bigone
 * @see https://open.big.one/docs/spot_asset_pair.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bigone) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promises interface{} = []interface{}{this.PublicGetAssetPairs(params), this.ContractPublicGetSymbols(params)}
        
            promisesResult:= (<-promiseAll(promises))
            PanicOnError(promisesResult)
            var response interface{} = GetValue(promisesResult, 0)
            var contractResponse interface{} = GetValue(promisesResult, 1)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
            //                 "name":"PCX-BTC",
            //                 "quote_scale":7,
            //                 "quote_asset":{
            //                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
            //                     "symbol":"BTC",
            //                     "name":"Bitcoin",
            //                 },
            //                 "base_asset":{
            //                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
            //                     "symbol":"PCX",
            //                     "name":"ChainX",
            //                 },
            //                 "base_scale":3,
            //                 "min_quote_value":"0.0001",
            //                 "max_quote_value":"35"
            //             },
            //         ]
            //     }
            //
            //
            //    [
            //        {
            //            "baseCurrency": "BTC",
            //            "multiplier": 1,
            //            "enable": true,
            //            "priceStep": 0.5,
            //            "maxRiskLimit": 1000,
            //            "pricePrecision": 1,
            //            "maintenanceMargin": 0.00500,
            //            "symbol": "BTCUSD",
            //            "valuePrecision": 4,
            //            "minRiskLimit": 100,
            //            "riskLimit": 100,
            //            "isInverse": true,
            //            "riskStep": 1,
            //            "settleCurrency": "BTC",
            //            "baseName": "Bitcoin",
            //            "feePrecision": 8,
            //            "priceMin": 0.5,
            //            "priceMax": 1E+6,
            //            "initialMargin": 0.01000,
            //            "quoteCurrency": "USD"
            //        },
            //        ...
            //    ]
            //
            var markets interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var baseAsset interface{} = this.SafeDict(market, "base_asset", map[string]interface{} {})
                var quoteAsset interface{} = this.SafeDict(market, "quote_asset", map[string]interface{} {})
                var baseId interface{} = this.SafeString(baseAsset, "symbol")
                var quoteId interface{} = this.SafeString(quoteAsset, "symbol")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                AppendToArray(&result,this.SafeMarketStructure(map[string]interface{} {
                    "id": this.SafeString(market, "name"),
                    "uuid": this.SafeString(market, "id"),
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "base_scale"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quote_scale"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_quote_value"),
                            "max": this.SafeNumber(market, "max_quote_value"),
                        },
                    },
                    "created": nil,
                    "info": market,
                }))
            }
            for i := 0; IsLessThan(i, GetArrayLength(contractResponse)); i++ {
                var market interface{} = GetValue(contractResponse, i)
                var baseId interface{} = this.SafeString(market, "baseCurrency")
                var quoteId interface{} = this.SafeString(market, "quoteCurrency")
                var settleId interface{} = this.SafeString(market, "settleCurrency")
                var marketId interface{} = this.SafeString(market, "symbol")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var inverse interface{} = this.SafeBool(market, "isInverse")
                AppendToArray(&result,this.SafeMarketStructure(map[string]interface{} {
                    "id": marketId,
                    "symbol": Add(Add(Add(Add(base, "/"), quote), ":"), settle),
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": "swap",
                    "spot": false,
                    "margin": false,
                    "swap": true,
                    "future": false,
                    "option": false,
                    "active": this.SafeBool(market, "enable"),
                    "contract": true,
                    "linear": !IsTrue(inverse),
                    "inverse": inverse,
                    "contractSize": this.SafeNumber(market, "multiplier"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "valuePrecision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "priceMin"),
                            "max": this.SafeNumber(market, "priceMax"),
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "initialMargin"),
                            "max": nil,
                        },
                    },
                    "info": market,
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        "asset_pair_name": "ETH-BTC",
    //        "bid": {
    //            "price": "0.021593",
    //            "order_count": 1,
    //            "quantity": "0.20936"
    //        },
    //        "ask": {
    //            "price": "0.021613",
    //            "order_count": 1,
    //            "quantity": "2.87064"
    //        },
    //        "open": "0.021795",
    //        "high": "0.021795",
    //        "low": "0.021471",
    //        "close": "0.021613",
    //        "volume": "117078.90431",
    //        "daily_change": "-0.000182"
    //    }
    //
    // contract
    //
    //    {
    //        "usdtPrice": 1.00031998,
    //        "symbol": "BTCUSD",
    //        "btcPrice": 34700.4,
    //        "ethPrice": 1787.83,
    //        "nextFundingRate": 0.00010,
    //        "fundingRate": 0.00010,
    //        "latestPrice": 34708.5,
    //        "last24hPriceChange": 0.0321,
    //        "indexPrice": 34700.4,
    //        "volume24h": 261319063,
    //        "turnover24h": 8204.129380685496,
    //        "nextFundingTime": 1698285600000,
    //        "markPrice": 34702.4646738,
    //        "last24hMaxPrice": 35127.5,
    //        "volume24hInUsd": 0.0,
    //        "openValue": 32.88054722085945,
    //        "last24hMinPrice": 33552.0,
    //        "openInterest": 1141372.0
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketType interface{} = Ternary(IsTrue((InOp(ticker, "asset_pair_name"))), "spot", "swap")
    var marketId interface{} = this.SafeString2(ticker, "asset_pair_name", "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-", marketType)
    var close interface{} = this.SafeString2(ticker, "close", "latestPrice")
    var bid interface{} = this.SafeDict(ticker, "bid", map[string]interface{} {})
    var ask interface{} = this.SafeDict(ticker, "ask", map[string]interface{} {})
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString2(ticker, "high", "last24hMaxPrice"),
        "low": this.SafeString2(ticker, "low", "last24hMinPrice"),
        "bid": this.SafeString(bid, "price"),
        "bidVolume": this.SafeString(bid, "quantity"),
        "ask": this.SafeString(ask, "price"),
        "askVolume": this.SafeString(ask, "quantity"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": this.SafeString2(ticker, "daily_change", "last24hPriceChange"),
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "volume", "volume24h"),
        "quoteVolume": this.SafeString(ticker, "volume24hInUsd"),
        "markPrice": this.SafeString(ticker, "markPrice"),
        "indexPrice": this.SafeString(ticker, "indexPrice"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bigone#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://open.big.one/docs/spot_tickers.html
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bigone) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8558 := (<-this.LoadMarkets())
            PanicOnError(retRes8558)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTicker", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(IsEqual(typeVar, "spot")) {
                var request interface{} = map[string]interface{} {
                    "asset_pair_name": GetValue(market, "id"),
                }
        
                response:= (<-this.PublicGetAssetPairsAssetPairNameTicker(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code":0,
                //         "data":{
                //             "asset_pair_name":"ETH-BTC",
                //             "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
                //             "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
                //             "open":"0.021795",
                //             "high":"0.021795",
                //             "low":"0.021471",
                //             "close":"0.021613",
                //             "volume":"117078.90431",
                //             "daily_change":"-0.000182"
                //         }
                //     }
                //
                var ticker interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
                ch <- this.ParseTicker(ticker, market)
                return nil
            } else {
        
                tickers:= (<-this.FetchTickers([]interface{}{symbol}, params))
                PanicOnError(tickers)
        
                ch <- this.SafeValue(tickers, symbol)
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://open.big.one/docs/spot_tickers.html
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bigone) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8988 := (<-this.LoadMarkets())
            PanicOnError(retRes8988)
            var market interface{} = nil
            var symbol interface{} = this.SafeString(symbols, 0)
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var isSpot interface{} = IsEqual(typeVar, "spot")
            var request interface{} = map[string]interface{} {}
            symbols = this.MarketSymbols(symbols)
            var data interface{} = nil
            if IsTrue(isSpot) {
                if IsTrue(!IsEqual(symbols, nil)) {
                    var ids interface{} = this.MarketIds(symbols)
                    AddElementToObject(request, "pair_names", Join(ids, ","))
                }
        
                response:= (<-this.PublicGetAssetPairsTickers(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    {
                //        "code": 0,
                //        "data": [
                //            {
                //                "asset_pair_name": "PCX-BTC",
                //                "bid": {
                //                    "price": "0.000234",
                //                    "order_count": 1,
                //                    "quantity": "0.518"
                //                },
                //                "ask": {
                //                    "price": "0.0002348",
                //                    "order_count": 1,
                //                    "quantity": "2.348"
                //                },
                //                "open": "0.0002343",
                //                "high": "0.0002348",
                //                "low": "0.0002162",
                //                "close": "0.0002348",
                //                "volume": "12887.016",
                //                "daily_change": "0.0000005"
                //            },
                //            ...
                //        ]
                //    }
                //
                data = this.SafeList(response, "data", []interface{}{})
            } else {
                
        data = (<-this.ContractPublicGetInstruments(params))
                PanicOnError(data)
            }
            var tickers interface{} = this.ParseTickers(data, symbols)
        
            ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://open.big.one/docs/spot_ping.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *bigone) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetPing(params))
            PanicOnError(response)
            //
            //     {
            //         "data": {
            //             "timestamp": 1527665262168391000
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "Timestamp")
        
            ch <- this.ParseToInt(Divide(timestamp, 1000000))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://open.big.one/docs/contract_misc.html#get-orderbook-snapshot
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bigone) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10098 := (<-this.LoadMarkets())
            PanicOnError(retRes10098)
            var market interface{} = this.Market(symbol)
            var response interface{} = nil
            if IsTrue(GetValue(market, "contract")) {
                var request interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                }
                
        response = (<-this.ContractPublicGetDepthSymbolSnapshot(this.Extend(request, params)))
                PanicOnError(response)
        
                        //
                //    {
                //        bids: {
                //            '20000': '20',
                //            ...
                //            '34552': '64851',
                //            '34526.5': '59594',
                //            ...
                //            '34551.5': '29711'
                //        },
                //        asks: {
                //            '34557': '34395',
                //            ...
                //            '40000': '20',
                //            '34611.5': '56024',
                //            ...
                //            '34578.5': '66367'
                //        },
                //        to: '59737174',
                //        lastPrice: '34554.5',
                //        bestPrices: {
                //            ask: '34557.0',
                //            bid: '34552.0'
                //        },
                //        from: '0'
                //    }
                //
        ch <- this.ParseContractOrderBook(response, GetValue(market, "symbol"), limit)
                return nil
            } else {
                var request interface{} = map[string]interface{} {
                    "asset_pair_name": GetValue(market, "id"),
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit) // default 50, max 200
                }
                
        response = (<-this.PublicGetAssetPairsAssetPairNameDepth(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code":0,
                //         "data": {
                //             "asset_pair_name": "EOS-BTC",
                //             "bids": [
                //                 { "price": "42", "order_count": 4, "quantity": "23.33363711" }
                //             ],
                //             "asks": [
                //                 { "price": "45", "order_count": 2, "quantity": "4193.3283464" }
                //             ]
                //         }
                //     }
                //
                var orderbook interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
                ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "bids", "asks", "price", "quantity")
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *bigone) ParseContractBidsAsks(bidsAsks interface{}) interface{}  {
    var bidsAsksKeys interface{} = ObjectKeys(bidsAsks)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bidsAsksKeys)); i++ {
        var price interface{} = GetValue(bidsAsksKeys, i)
        var amount interface{} = GetValue(bidsAsks, price)
        AppendToArray(&result,[]interface{}{this.ParseNumber(price), this.ParseNumber(amount)})
    }
    return result
}
func  (this *bigone) ParseContractOrderBook(orderbook interface{}, symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 0, nil)
    _ = limit
    var responseBids interface{} = this.SafeValue(orderbook, "bids")
    var responseAsks interface{} = this.SafeValue(orderbook, "asks")
    var bids interface{} = this.ParseContractBidsAsks(responseBids)
    var asks interface{} = this.ParseContractBidsAsks(responseAsks)
    return map[string]interface{} {
        "symbol": symbol,
        "bids": this.FilterByLimit(this.SortBy(bids, 0, true), limit),
        "asks": this.FilterByLimit(this.SortBy(asks, 0), limit),
        "timestamp": nil,
        "datetime": nil,
        "nonce": nil,
    }
}
func  (this *bigone) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "id": 38199941,
    //         "price": "3378.67",
    //         "amount": "0.019812",
    //         "taker_side": "ASK",
    //         "created_at": "2019-01-29T06:05:56Z"
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "id": 10854280,
    //         "asset_pair_name": "XIN-USDT",
    //         "price": "70",
    //         "amount": "1",
    //         "taker_side": "ASK",
    //         "maker_order_id": 58284908,
    //         "taker_order_id": 58284909,
    //         "maker_fee": "0.0008",
    //         "taker_fee": "0.07",
    //         "side": "SELF_TRADING",
    //         "inserted_at": "2019-04-16T12:00:01Z"
    //     },
    //
    //     {
    //         "id": 10854263,
    //         "asset_pair_name": "XIN-USDT",
    //         "price": "75.7",
    //         "amount": "12.743149",
    //         "taker_side": "BID",
    //         "maker_order_id": null,
    //         "taker_order_id": 58284888,
    //         "maker_fee": null,
    //         "taker_fee": "0.0025486298",
    //         "side": "BID",
    //         "inserted_at": "2019-04-15T06:20:57Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString2(trade, "created_at", "inserted_at"))
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var marketId interface{} = this.SafeString(trade, "asset_pair_name")
    market = this.SafeMarket(marketId, market, "-")
    var side interface{} = this.SafeString(trade, "side")
    var takerSide interface{} = this.SafeString(trade, "taker_side")
    var takerOrMaker interface{} = nil
    if IsTrue(IsTrue(IsTrue((!IsEqual(takerSide, nil))) && IsTrue((!IsEqual(side, nil)))) && IsTrue((!IsEqual(side, "SELF_TRADING")))) {
        takerOrMaker = Ternary(IsTrue((IsEqual(takerSide, side))), "taker", "maker")
    }
    if IsTrue(IsEqual(side, nil)) {
        // taker side is not related to buy/sell side
        // the following code is probably a mistake
        side = Ternary(IsTrue((IsEqual(takerSide, "ASK"))), "sell", "buy")
    } else {
        if IsTrue(IsEqual(side, "BID")) {
            side = "buy"
        } else if IsTrue(IsEqual(side, "ASK")) {
            side = "sell"
        }
    }
    var makerOrderId interface{} = this.SafeString(trade, "maker_order_id")
    var takerOrderId interface{} = this.SafeString(trade, "taker_order_id")
    var orderId interface{} = nil
    if IsTrue(!IsEqual(makerOrderId, nil)) {
        orderId = makerOrderId
    } else if IsTrue(!IsEqual(takerOrderId, nil)) {
        orderId = takerOrderId
    }
    var id interface{} = this.SafeString(trade, "id")
    var result interface{} = map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": orderId,
        "type": "limit",
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "info": trade,
    }
    var makerCurrencyCode interface{} = nil
    var takerCurrencyCode interface{} = nil
    if IsTrue(!IsEqual(takerOrMaker, nil)) {
        if IsTrue(IsEqual(side, "buy")) {
            if IsTrue(IsEqual(takerOrMaker, "maker")) {
                makerCurrencyCode = GetValue(market, "base")
                takerCurrencyCode = GetValue(market, "quote")
            } else {
                makerCurrencyCode = GetValue(market, "quote")
                takerCurrencyCode = GetValue(market, "base")
            }
        } else {
            if IsTrue(IsEqual(takerOrMaker, "maker")) {
                makerCurrencyCode = GetValue(market, "quote")
                takerCurrencyCode = GetValue(market, "base")
            } else {
                makerCurrencyCode = GetValue(market, "base")
                takerCurrencyCode = GetValue(market, "quote")
            }
        }
    } else if IsTrue(IsEqual(side, "SELF_TRADING")) {
        if IsTrue(IsEqual(takerSide, "BID")) {
            makerCurrencyCode = GetValue(market, "quote")
            takerCurrencyCode = GetValue(market, "base")
        } else if IsTrue(IsEqual(takerSide, "ASK")) {
            makerCurrencyCode = GetValue(market, "base")
            takerCurrencyCode = GetValue(market, "quote")
        }
    }
    var makerFeeCost interface{} = this.SafeString(trade, "maker_fee")
    var takerFeeCost interface{} = this.SafeString(trade, "taker_fee")
    if IsTrue(!IsEqual(makerFeeCost, nil)) {
        if IsTrue(!IsEqual(takerFeeCost, nil)) {
            AddElementToObject(result, "fees", []interface{}{map[string]interface{} {
    "cost": makerFeeCost,
    "currency": makerCurrencyCode,
}, map[string]interface{} {
    "cost": takerFeeCost,
    "currency": takerCurrencyCode,
}})
        } else {
            AddElementToObject(result, "fee", map[string]interface{} {
    "cost": makerFeeCost,
    "currency": makerCurrencyCode,
})
        }
    } else if IsTrue(!IsEqual(takerFeeCost, nil)) {
        AddElementToObject(result, "fee", map[string]interface{} {
    "cost": takerFeeCost,
    "currency": takerCurrencyCode,
})
    } else {
        AddElementToObject(result, "fee", nil)
    }
    return this.SafeTrade(result, market)
}
/**
 * @method
 * @name bigone#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://open.big.one/docs/spot_asset_pair_trade.html
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bigone) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12458 := (<-this.LoadMarkets())
            PanicOnError(retRes12458)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchTrades () can only fetch trades for spot markets")))
            }
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetAssetPairsAssetPairNameTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 38199941,
            //                 "price": "3378.67",
            //                 "amount": "0.019812",
            //                 "taker_side": "ASK",
            //                 "created_at": "2019-01-29T06:05:56Z"
            //             },
            //             {
            //                 "id": 38199934,
            //                 "price": "3376.14",
            //                 "amount": "0.019384",
            //                 "taker_side": "ASK",
            //                 "created_at": "2019-01-29T06:05:40Z"
            //             }
            //         ]
            //     }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": "0.021562",
    //         "high": "0.021563",
    //         "low": "0.02156",
    //         "open": "0.021563",
    //         "time": "2019-11-21T07:54:00Z",
    //         "volume": "59.84376"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "time")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name bigone#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://open.big.one/docs/spot_asset_pair_candle.html
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the earliest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bigone) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13148 := (<-this.LoadMarkets())
            PanicOnError(retRes13148)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchOHLCV () can only fetch ohlcvs for spot markets")))
            }
            var until interface{} = this.SafeInteger(params, "until")
            var untilIsDefined interface{} =     (!IsEqual(until, nil))
            var sinceIsDefined interface{} =     (!IsEqual(since, nil))
            if IsTrue(IsEqual(limit, nil)) {
                limit = Ternary(IsTrue((IsTrue(sinceIsDefined) && IsTrue(untilIsDefined))), 500, 100) // default 100, max 500, if since and limit defined then fetch all the candles between them unless it exceeds the max of 500
            }
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
                "limit": limit,
            }
            if IsTrue(sinceIsDefined) {
                // const start = this.parseToInt (since / 1000);
                var duration interface{} = this.ParseTimeframe(timeframe)
                var endByLimit interface{} = this.Sum(since, Multiply(Multiply(limit, duration), 1000))
                if IsTrue(untilIsDefined) {
                    AddElementToObject(request, "time", this.Iso8601(mathMin(endByLimit, Add(until, 1))))
                } else {
                    AddElementToObject(request, "time", this.Iso8601(endByLimit))
                }
            } else if IsTrue(untilIsDefined) {
                AddElementToObject(request, "time", this.Iso8601(Add(until, 1)))
            }
            params = this.Omit(params, "until")
        
            response:= (<-this.PublicGetAssetPairsAssetPairNameCandles(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "close": "0.021656",
            //                 "high": "0.021658",
            //                 "low": "0.021652",
            //                 "open": "0.021652",
            //                 "time": "2019-11-21T09:30:00Z",
            //                 "volume": "53.08664"
            //             },
            //             {
            //                 "close": "0.021652",
            //                 "high": "0.021656",
            //                 "low": "0.021652",
            //                 "open": "0.021656",
            //                 "time": "2019-11-21T09:29:00Z",
            //                 "volume": "88.39861"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var balances interface{} = this.SafeList(response, "data", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var symbol interface{} = this.SafeString(balance, "asset_symbol")
        var code interface{} = this.SafeCurrencyCode(symbol)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked_balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bigone#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://open.big.one/docs/fund_accounts.html
 * @see https://open.big.one/docs/spot_accounts.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bigone) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14008 := (<-this.LoadMarkets())
            PanicOnError(retRes14008)
            var typeVar interface{} = this.SafeString(params, "type", "")
            params = this.Omit(params, "type")
            var response interface{} = nil
            if IsTrue(IsTrue(IsEqual(typeVar, "funding")) || IsTrue(IsEqual(typeVar, "fund"))) {
                
        response = (<-this.PrivateGetFundAccounts(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetAccounts(params))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "code":0,
            //         "data":[
            //             {"asset_symbol":"NKC","balance":"0","locked_balance":"0"},
            //             {"asset_symbol":"UBTC","balance":"0","locked_balance":"0"},
            //             {"asset_symbol":"READ","balance":"0","locked_balance":"0"},
            //         ],
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "STOP_LIMIT": "limit",
        "STOP_MARKET": "market",
        "LIMIT": "limit",
        "MARKET": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *bigone) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": "42154072251",
    //        "asset_pair_name": "SOL-USDT",
    //        "price": "20",
    //        "amount": "0.5",
    //        "filled_amount": "0",
    //        "avg_deal_price": "0",
    //        "side": "ASK",
    //        "state": "PENDING",
    //        "created_at": "2023-09-13T03:42:00Z",
    //        "updated_at": "2023-09-13T03:42:00Z",
    //        "type": "LIMIT",
    //        "stop_price": "0",
    //        "immediate_or_cancel": false,
    //        "post_only": false,
    //        "client_order_id": ''
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var marketId interface{} = this.SafeString(order, "asset_pair_name")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var side interface{} = this.SafeString(order, "side")
    if IsTrue(IsEqual(side, "BID")) {
        side = "buy"
    } else {
        side = "sell"
    }
    var triggerPrice interface{} = this.SafeString(order, "stop_price")
    if IsTrue(Precise.StringEq(triggerPrice, "0")) {
        triggerPrice = nil
    }
    var immediateOrCancel interface{} = this.SafeBool(order, "immediate_or_cancel")
    var timeInForce interface{} = nil
    if IsTrue(immediateOrCancel) {
        timeInForce = "IOC"
    }
    var typeVar interface{} = this.ParseType(this.SafeString(order, "type"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = nil
    var filled interface{} = nil
    var cost interface{} = nil
    if IsTrue(IsTrue(IsEqual(typeVar, "market")) && IsTrue(IsEqual(side, "buy"))) {
        cost = this.SafeString(order, "filled_amount")
    } else {
        amount = this.SafeString(order, "amount")
        filled = this.SafeString(order, "filled_amount")
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.Parse8601(this.SafeString(order, "updated_at")),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": this.SafeBool(order, "post_only"),
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "amount": amount,
        "cost": cost,
        "average": this.SafeString(order, "avg_deal_price"),
        "filled": filled,
        "remaining": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "state")),
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name bigone#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://open.big.one/docs/spot_orders.html#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15188 := (<-this.LoadMarkets())
            PanicOnError(retRes15188)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes152415 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes152415)
                ch <- retRes152415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#createOrder
 * @description create a trade order
 * @see https://open.big.one/docs/spot_orders.html#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.operator] *stop order only* GTE or LTE (default)
 * @param {string} [params.client_order_id] must match ^[a-zA-Z0-9-_]{1,36}$ this regex. client_order_id is unique in 24 hours, If created 24 hours later and the order closed, it will be released and can be reused
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15498 := (<-this.LoadMarkets())
            PanicOnError(retRes15498)
            var market interface{} = this.Market(symbol)
            var isBuy interface{} =     (IsEqual(side, "buy"))
            var requestSide interface{} = Ternary(IsTrue(isBuy), "BID", "ASK")
            var uppercaseType interface{} = ToUpper(typeVar)
            var isLimit interface{} = IsEqual(uppercaseType, "LIMIT")
            var exchangeSpecificParam interface{} = this.SafeBool(params, "post_only", false)
            var postOnly interface{} = nil
            postOnlyparamsVariable := this.HandlePostOnly((IsEqual(uppercaseType, "MARKET")), exchangeSpecificParam, params);
            postOnly = GetValue(postOnlyparamsVariable,0);
            params = GetValue(postOnlyparamsVariable,1)
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "stop_price"})
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
                "side": requestSide,
                "amount": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsTrue(isLimit) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                if IsTrue(isLimit) {
                    var timeInForce interface{} = this.SafeString(params, "timeInForce")
                    if IsTrue(IsEqual(timeInForce, "IOC")) {
                        AddElementToObject(request, "immediate_or_cancel", true)
                    }
                    if IsTrue(postOnly) {
                        AddElementToObject(request, "post_only", true)
                    }
                }
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            } else {
                if IsTrue(isBuy) {
                    var createMarketBuyOrderRequiresPrice interface{} = true
                    createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                    params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                    var cost interface{} = this.SafeNumber(params, "cost")
                    params = this.Omit(params, "cost")
                    if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var quoteAmount interface{} = this.ParseToNumeric(Precise.StringMul(amountString, priceString))
                            var costRequest interface{} = Ternary(IsTrue((!IsEqual(cost, nil))), cost, quoteAmount)
                            AddElementToObject(request, "amount", this.CostToPrecision(symbol, costRequest))
                        }
                    } else {
                        AddElementToObject(request, "amount", this.CostToPrecision(symbol, amount))
                    }
                } else {
                    AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                }
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "operator", Ternary(IsTrue(isBuy), "GTE", "LTE"))
                if IsTrue(isLimit) {
                    uppercaseType = "STOP_LIMIT"
                } else if IsTrue(IsEqual(uppercaseType, "MARKET")) {
                    uppercaseType = "STOP_MARKET"
                }
            }
            AddElementToObject(request, "type", uppercaseType)
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            }
            params = this.Omit(params, []interface{}{"stop_price", "stopPrice", "triggerPrice", "timeInForce", "clientOrderId"})
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "id": 10,
            //        "asset_pair_name": "EOS-BTC",
            //        "price": "10.00",
            //        "amount": "10.00",
            //        "filled_amount": "9.0",
            //        "avg_deal_price": "12.0",
            //        "side": "ASK",
            //        "state": "FILLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            //
            var order interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#cancelOrder
 * @description cancels an open order
 * @see https://open.big.one/docs/spot_orders.html#cancel-order
 * @param {string} id order id
 * @param {string} symbol Not used by bigone cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16488 := (<-this.LoadMarkets())
            PanicOnError(retRes16488)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivatePostOrdersIdCancel(this.Extend(request, params)))
            PanicOnError(response)
            //    {
            //        "id": 10,
            //        "asset_pair_name": "EOS-BTC",
            //        "price": "10.00",
            //        "amount": "10.00",
            //        "filled_amount": "9.0",
            //        "avg_deal_price": "12.0",
            //        "side": "ASK",
            //        "state": "CANCELLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            var order interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#cancelAllOrders
 * @description cancel all open orders
 * @see https://open.big.one/docs/spot_orders.html#cancel-all-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16778 := (<-this.LoadMarkets())
            PanicOnError(retRes16778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostOrdersCancel(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data": {
            //             "cancelled":[
            //                 58272370,
            //                 58272377
            //             ],
            //             "failed": []
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var cancelled interface{} = this.SafeList(data, "cancelled", []interface{}{})
            var failed interface{} = this.SafeList(data, "failed", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(cancelled)); i++ {
                var orderId interface{} = GetValue(cancelled, i)
                AppendToArray(&result,this.SafeOrder(map[string]interface{} {
                    "info": orderId,
                    "id": orderId,
                    "status": "canceled",
                }))
            }
            for i := 0; IsLessThan(i, GetArrayLength(failed)); i++ {
                var orderId interface{} = GetValue(failed, i)
                AppendToArray(&result,this.SafeOrder(map[string]interface{} {
                    "info": orderId,
                    "id": orderId,
                    "status": "failed",
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-one-order
 * @param {string} id the order id
 * @param {string} symbol not used by bigone fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17298 := (<-this.LoadMarkets())
            PanicOnError(retRes17298)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrdersId(this.Extend(request, params)))
            PanicOnError(response)
            var order interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes17518 := (<-this.LoadMarkets())
            PanicOnError(retRes17518)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 20, max 200
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code":0,
            //        "data": [
            //             {
            //                 "id": 10,
            //                 "asset_pair_name": "ETH-BTC",
            //                 "price": "10.00",
            //                 "amount": "10.00",
            //                 "filled_amount": "9.0",
            //                 "avg_deal_price": "12.0",
            //                 "side": "ASK",
            //                 "state": "FILLED",
            //                 "created_at":"2019-01-29T06:05:56Z",
            //                 "updated_at":"2019-01-29T06:05:56Z",
            //             },
            //         ],
            //        "page_token":"dxzef",
            //    }
            //
            var orders interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://open.big.one/docs/spot_trade.html#trades-of-user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bigone) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes18038 := (<-this.LoadMarkets())
            PanicOnError(retRes18038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "asset_pair_name": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 20, max 200
            }
        
            response:= (<-this.PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 10854280,
            //                 "asset_pair_name": "XIN-USDT",
            //                 "price": "70",
            //                 "amount": "1",
            //                 "taker_side": "ASK",
            //                 "maker_order_id": 58284908,
            //                 "taker_order_id": 58284909,
            //                 "maker_fee": "0.0008",
            //                 "taker_fee": "0.07",
            //                 "side": "SELF_TRADING",
            //                 "inserted_at": "2019-04-16T12:00:01Z"
            //             },
            //             {
            //                 "id": 10854263,
            //                 "asset_pair_name": "XIN-USDT",
            //                 "price": "75.7",
            //                 "amount": "12.743149",
            //                 "taker_side": "BID",
            //                 "maker_order_id": null,
            //                 "taker_order_id": 58284888,
            //                 "maker_fee": null,
            //                 "taker_fee": "0.0025486298",
            //                 "side": "BID",
            //                 "inserted_at": "2019-04-15T06:20:57Z"
            //             }
            //         ],
            //         "page_token":"dxfv"
            //     }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PENDING": "open",
        "FILLED": "closed",
        "CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status)
}
/**
 * @method
 * @name bigone#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "state": "PENDING",
            }
        
                retRes187515 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes187515)
                ch <- retRes187515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bigone) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "state": "FILLED",
            }
        
                retRes189315 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes189315)
                ch <- retRes189315
                return nil
        
            }()
            return ch
        }
func  (this *bigone) Nonce() interface{}  {
    var exchangeTimeCorrection interface{} = Multiply(this.SafeInteger(this.Options, "exchangeMillisecondsCorrection", 0), 1000000)
    return this.Sum(Multiply(this.Microseconds(), 1000), exchangeTimeCorrection)
}
func  (this *bigone) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var baseUrl interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api))
    var url interface{} = Add(Add(baseUrl, "/"), this.ImplodeParams(path, params))
    headers = map[string]interface{} {}
    if IsTrue(IsTrue(IsTrue(IsEqual(api, "public")) || IsTrue(IsEqual(api, "webExchange"))) || IsTrue(IsEqual(api, "contractPublic"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var request interface{} = map[string]interface{} {
            "type": "OpenAPIV2",
            "sub": this.ApiKey,
            "nonce": nonce,
        }
        var token interface{} = Jwt(request, this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "Authorization", Add("Bearer ", token))
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        } else if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-Type", "application/json")
            body = this.Json(query)
        }
    }
    AddElementToObject(headers, "User-Agent", Add(Add(Add("ccxt/", this.Id), "-"), this.Version))
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
/**
 * @method
 * @name bigone#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://open.big.one/docs/spot_deposit.html#get-deposite-address-of-one-asset-of-user
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bigone) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19448 := (<-this.LoadMarkets())
            PanicOnError(retRes19448)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset_symbol": GetValue(currency, "id"),
            }
            networkCodeparamsOmittedVariable := this.HandleNetworkCodeAndParams(params);
            networkCode := GetValue(networkCodeparamsOmittedVariable,0);
            paramsOmitted := GetValue(networkCodeparamsOmittedVariable,1)
        
            response:= (<-this.PrivateGetAssetsAssetSymbolAddress(this.Extend(request, paramsOmitted)))
            PanicOnError(response)
            //
            // the actual response format is not the same as the documented one
            // the data key contains an array in the actual response
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":[
            //             {
            //                 "id":5521878,
            //                 "chain":"Bitcoin",
            //                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
            //                 "memo":""
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var dataLength interface{} =     GetArrayLength(data)
            if IsTrue(IsLessThan(dataLength, 1)) {
                panic(ExchangeError(Add(this.Id, " fetchDepositAddress() returned empty address response")))
            }
            var chainsIndexedById interface{} = this.IndexBy(data, "chain")
            var selectedNetworkId interface{} = this.SelectNetworkIdFromRawNetworks(code, networkCode, chainsIndexedById)
            var addressObject interface{} = this.SafeDict(chainsIndexedById, selectedNetworkId, map[string]interface{} {})
            var address interface{} = this.SafeString(addressObject, "value")
            var tag interface{} = this.SafeString(addressObject, "memo")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": this.NetworkIdToCode(selectedNetworkId),
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "WITHHOLD": "ok",
        "UNCONFIRMED": "pending",
        "CONFIRMED": "ok",
        "COMPLETED": "ok",
        "PENDING": "pending",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bigone) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "amount": "25.0",
    //         "asset_symbol": "BTS"
    //         "confirms": 100,
    //         "id": 5,
    //         "inserted_at": "2018-02-16T11:39:58.000Z",
    //         "is_internal": false,
    //         "kind": "default",
    //         "memo": "",
    //         "state": "WITHHOLD",
    //         "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
    //         "updated_at": "2018-11-09T10:20:09.000Z",
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "amount": "5",
    //         "asset_symbol": "ETH",
    //         "completed_at": "2018-03-15T16:13:45.610463Z",
    //         "customer_id": "10",
    //         "id": 10,
    //         "inserted_at": "2018-03-15T16:13:45.610463Z",
    //         "is_internal": true,
    //         "note": "2018-03-15T16:13:45.610463Z",
    //         "state": "CONFIRMED",
    //         "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
    //         "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
    //     }
    //
    // withdraw
    //
    //     {
    //         "id":1077391,
    //         "customer_id":1082679,
    //         "amount":"21.9000000000000000",
    //         "txid":"",
    //         "is_internal":false,
    //         "kind":"on_chain",
    //         "state":"PENDING",
    //         "inserted_at":"2020-06-03T00:50:57+00:00",
    //         "updated_at":"2020-06-03T00:50:57+00:00",
    //         "memo":"",
    //         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
    //         "fee":"0.1000000000000000",
    //         "asset_symbol":"XRP"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "asset_symbol")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var id interface{} = this.SafeString(transaction, "id")
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "inserted_at"))
    var updated interface{} = this.Parse8601(this.SafeString2(transaction, "updated_at", "completed_at"))
    var txid interface{} = this.SafeString(transaction, "txid")
    var address interface{} = this.SafeString(transaction, "target_address")
    var tag interface{} = this.SafeString(transaction, "memo")
    var typeVar interface{} = Ternary(IsTrue((InOp(transaction, "customer_id"))), "withdrawal", "deposit")
    var internal interface{} = this.SafeBool(transaction, "is_internal")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": address,
        "tagFrom": nil,
        "tag": tag,
        "tagTo": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": updated,
        "fee": nil,
        "comment": nil,
        "internal": internal,
    }
}
/**
 * @method
 * @name bigone#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://open.big.one/docs/spot_deposit.html#deposit-of-user
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bigone) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21008 := (<-this.LoadMarkets())
            PanicOnError(retRes21008)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "asset_symbol", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50
            }
        
            response:= (<-this.PrivateGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "page_token": "NQ==",
            //         "data": [
            //             {
            //                 "id": 5,
            //                 "amount": "25.0",
            //                 "confirms": 100,
            //                 "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
            //                 "is_internal": false,
            //                 "inserted_at": "2018-02-16T11:39:58.000Z",
            //                 "updated_at": "2018-11-09T10:20:09.000Z",
            //                 "kind": "default",
            //                 "memo": "",
            //                 "state": "WITHHOLD",
            //                 "asset_symbol": "BTS"
            //             }
            //         ]
            //     }
            //
            var deposits interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(deposits, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://open.big.one/docs/spot_withdrawal.html#get-withdrawals-of-user
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bigone) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21538 := (<-this.LoadMarkets())
            PanicOnError(retRes21538)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "asset_symbol", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50
            }
        
            response:= (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 10,
            //                 "customer_id": "10",
            //                 "asset_symbol": "ETH",
            //                 "amount": "5",
            //                 "state": "CONFIRMED",
            //                 "note": "2018-03-15T16:13:45.610463Z",
            //                 "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
            //                 "completed_at": "2018-03-15T16:13:45.610463Z",
            //                 "inserted_at": "2018-03-15T16:13:45.610463Z",
            //                 "is_internal": true,
            //                 "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
            //             }
            //         ],
            //         "page_token":"dxvf"
            //     }
            //
            var withdrawals interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(withdrawals, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bigone#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://open.big.one/docs/spot_transfer.html#transfer-of-user
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'SPOT', 'FUND', or 'CONTRACT'
 * @param {string} toAccount 'SPOT', 'FUND', or 'CONTRACT'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *bigone) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22078 := (<-this.LoadMarkets())
            PanicOnError(retRes22078)
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var guid interface{} = this.SafeString(params, "guid", this.Uuid())
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "from": fromId,
                "to": toId,
                "guid": guid,
            }
        
            response:= (<-this.PrivatePostTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": null
            //     }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
            var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "fromAccount", fromAccount)
                AddElementToObject(transfer, "toAccount", toAccount)
                AddElementToObject(transfer, "amount", amount)
                AddElementToObject(transfer, "id", guid)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
func  (this *bigone) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "code": 0,
    //         "data": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var code interface{} = this.SafeString(transfer, "code")
    return map[string]interface{} {
        "info": transfer,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "currency": nil,
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": this.ParseTransferStatus(code),
    }
}
func  (this *bigone) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "ok",
    }
    return this.SafeString(statuses, status, "failed")
}
/**
 * @method
 * @name bigone#withdraw
 * @description make a withdrawal
 * @see https://open.big.one/docs/spot_withdrawal.html#create-withdrawal-of-user
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bigone) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes22838 := (<-this.LoadMarkets())
            PanicOnError(retRes22838)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "id"),
                "target_address": address,
                "amount": this.CurrencyToPrecision(code, amount),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "gateway_name", this.NetworkCodeToId(networkCode))
            }
            // requires write permission on the wallet
        
            response:= (<-this.PrivatePostWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":{
            //             "id":1077391,
            //             "customer_id":1082679,
            //             "amount":"21.9000000000000000",
            //             "txid":"",
            //             "is_internal":false,
            //             "kind":"on_chain",
            //             "state":"PENDING",
            //             "inserted_at":"2020-06-03T00:50:57+00:00",
            //             "updated_at":"2020-06-03T00:50:57+00:00",
            //             "memo":"",
            //             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
            //             "fee":"0.1000000000000000",
            //             "asset_symbol":"XRP"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bigone) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //      {"code":10013,"message":"Resource not found"}
    //      {"code":40004,"message":"invalid jwt"}
    //
    var code interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(IsTrue((!IsEqual(code, "0"))) && IsTrue((!IsEqual(code, nil)))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bigone) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
