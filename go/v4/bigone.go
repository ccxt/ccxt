package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BigoneCore struct {
	Exchange
}

func NewBigoneCore() *BigoneCore {
	p := &BigoneCore{}
	setDefaults(p)
	return p
}

func (this *BigoneCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bigone",
		"name":      "BigONE",
		"countries": []interface{}{"CN"},
		"version":   "v3",
		"rateLimit": 20,
		"has": map[string]interface{}{
			"CORS":                           nil,
			"spot":                           true,
			"margin":                         false,
			"swap":                           true,
			"future":                         nil,
			"option":                         false,
			"borrowCrossMargin":              false,
			"borrowIsolatedMargin":           false,
			"borrowMargin":                   false,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"createMarketBuyOrderWithCost":   true,
			"createMarketOrderWithCost":      false,
			"createMarketSellOrderWithCost":  false,
			"createOrder":                    true,
			"createPostOnlyOrder":            true,
			"createStopLimitOrder":           true,
			"createStopMarketOrder":          true,
			"createStopOrder":                true,
			"fetchAllGreeks":                 false,
			"fetchBalance":                   true,
			"fetchBorrowInterest":            false,
			"fetchBorrowRate":                false,
			"fetchBorrowRateHistories":       false,
			"fetchBorrowRateHistory":         false,
			"fetchBorrowRates":               false,
			"fetchBorrowRatesPerSymbol":      false,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          false,
			"fetchDepositAddressesByNetwork": false,
			"fetchDeposits":                  true,
			"fetchFundingHistory":            false,
			"fetchFundingRate":               false,
			"fetchFundingRateHistory":        false,
			"fetchFundingRates":              false,
			"fetchGreeks":                    false,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchMarkets":                   true,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenOrders":                true,
			"fetchOption":                    false,
			"fetchOptionChain":               false,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrders":                    true,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFee":                false,
			"fetchTradingFees":               false,
			"fetchTransactionFees":           false,
			"fetchVolatilityHistory":         false,
			"fetchWithdrawals":               true,
			"repayCrossMargin":               false,
			"repayIsolatedMargin":            false,
			"transfer":                       true,
			"withdraw":                       true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "min1",
			"5m":  "min5",
			"15m": "min15",
			"30m": "min30",
			"1h":  "hour1",
			"3h":  "hour3",
			"4h":  "hour4",
			"6h":  "hour6",
			"12h": "hour12",
			"1d":  "day1",
			"1w":  "week1",
			"1M":  "month1",
		},
		"hostname": "big.one",
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/4e5cfd53-98cc-4b90-92cd-0d7b512653d1",
			"api": map[string]interface{}{
				"public":          "https://{hostname}/api/v3",
				"private":         "https://{hostname}/api/v3/viewer",
				"contractPublic":  "https://{hostname}/api/contract/v2",
				"contractPrivate": "https://{hostname}/api/contract/v2",
				"webExchange":     "https://{hostname}/api/",
			},
			"www":      "https://big.one",
			"doc":      "https://open.big.one/docs/api.html",
			"fees":     "https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",
			"referral": "https://b1.run/users/new?code=D3LLBVFT",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": []interface{}{"ping", "asset_pairs", "asset_pairs/{asset_pair_name}/depth", "asset_pairs/{asset_pair_name}/trades", "asset_pairs/{asset_pair_name}/ticker", "asset_pairs/{asset_pair_name}/candles", "asset_pairs/tickers"},
			},
			"private": map[string]interface{}{
				"get":  []interface{}{"accounts", "fund/accounts", "assets/{asset_symbol}/address", "orders", "orders/{id}", "orders/multi", "trades", "withdrawals", "deposits"},
				"post": []interface{}{"orders", "orders/{id}/cancel", "orders/cancel", "withdrawals", "transfer"},
			},
			"contractPublic": map[string]interface{}{
				"get": []interface{}{"symbols", "instruments", "depth@{symbol}/snapshot", "instruments/difference", "instruments/prices"},
			},
			"contractPrivate": map[string]interface{}{
				"get":    []interface{}{"accounts", "orders/{id}", "orders", "orders/opening", "orders/count", "orders/opening/count", "trades", "trades/count"},
				"post":   []interface{}{"orders", "orders/batch"},
				"put":    []interface{}{"positions/{symbol}/margin", "positions/{symbol}/risk-limit"},
				"delete": []interface{}{"orders/{id}", "orders/batch"},
			},
			"webExchange": map[string]interface{}{
				"get": []interface{}{"v3/assets"},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"maker": this.ParseNumber("0.001"),
				"taker": this.ParseNumber("0.001"),
			},
			"funding": map[string]interface{}{
				"withdraw": map[string]interface{}{},
			},
		},
		"options": map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": true,
			"accountsByType": map[string]interface{}{
				"spot":    "SPOT",
				"fund":    "FUND",
				"funding": "FUND",
				"future":  "CONTRACT",
				"swap":    "CONTRACT",
			},
			"transfer": map[string]interface{}{
				"fillResponseFromRequest": true,
			},
			"exchangeMillisecondsCorrection": OpNeg(100),
			"fetchCurrencies": map[string]interface{}{
				"webApiEnable":      true,
				"webApiRetries":     5,
				"webApiMuteFailure": true,
			},
			"defaultNetwork": "ERC20",
			"defaultNetworks": map[string]interface{}{
				"USDT": "TRC20",
			},
			"networks": map[string]interface{}{
				"ABBC":     "ABBC",
				"ACA":      "Acala",
				"AE":       "Aeternity",
				"ALGO":     "Algorand",
				"APT":      "Aptos",
				"AR":       "Arweave",
				"ASTR":     "Astar",
				"AVAXC":    "Avax",
				"AVAXX":    "AvaxChain",
				"BEAM":     "Beam",
				"BEP20":    "BinanceSmartChain",
				"BITCI":    "BitciChain",
				"BTC":      "Bitcoin",
				"BCH":      "BitcoinCash",
				"BSV":      "BitcoinSV",
				"CELO":     "Celo",
				"CKKB":     "CKB",
				"ATOM":     "Cosmos",
				"CRC20":    "CRO",
				"DASH":     "Dash",
				"DOGE":     "Dogecoin",
				"XEC":      "ECash",
				"EOS":      "EOS",
				"ETH":      "Ethereum",
				"ETC":      "EthereumClassic",
				"ETHW":     "EthereumPow",
				"FTM":      "Fantom",
				"FIL":      "Filecoin",
				"FSN":      "Fusion",
				"GRIN":     "Grin",
				"ONE":      "Harmony",
				"HRC20":    "Hecochain",
				"HBAR":     "Hedera",
				"HNT":      "Helium",
				"ZEN":      "Horizen",
				"IOST":     "IOST",
				"IRIS":     "IRIS",
				"KLAY":     "Klaytn",
				"KSM":      "Kusama",
				"LTC":      "Litecoin",
				"XMR":      "Monero",
				"GLMR":     "Moonbeam",
				"NEAR":     "Near",
				"NEO":      "Neo",
				"NEON3":    "NeoN3",
				"OASIS":    "Oasis",
				"OKC":      "Okexchain",
				"ONT":      "Ontology",
				"OPTIMISM": "Optimism",
				"DOT":      "Polkadot",
				"MATIC":    "Polygon",
				"QTUM":     "Qtum",
				"REI":      "REI",
				"XRP":      "Ripple",
				"SGB":      "SGB",
				"SDN":      "Shiden",
				"SOL":      "Solana",
				"XLM":      "Stellar",
				"TERA":     "Tera",
				"XTZ":      "Tezos",
				"TRC20":    "Tron",
				"VET":      "Vechain",
				"VSYS":     "VSystems",
				"WAX":      "WAX",
				"ZEC":      "Zcash",
			},
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           true,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": false,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyRequiresPrice": true,
					"marketBuyByCost":        true,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          200,
					"daysBack":       nil,
					"untilDays":      nil,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          200,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          200,
					"daysBack":       nil,
					"untilDays":      nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            200,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        nil,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 500,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"forDerivatives": map[string]interface{}{
				"extends": "default",
				"createOrder": map[string]interface{}{
					"triggerPriceType": map[string]interface{}{
						"mark":  true,
						"index": true,
						"last":  true,
					},
				},
				"fetchOrders": map[string]interface{}{
					"daysBack":  100000,
					"untilDays": 100000,
				},
				"fetchClosedOrders": map[string]interface{}{
					"daysBack":  100000,
					"untilDays": 100000,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forDerivatives",
				},
				"inverse": map[string]interface{}{
					"extends": "forDerivatives",
				},
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"10001": BadRequest,
				"10005": ExchangeError,
				"Amount\\'s scale must greater than AssetPair\\'s base scale":              InvalidOrder,
				"Price mulit with amount should larger than AssetPair\\'s min_quote_value": InvalidOrder,
				"10007": BadRequest,
				"10011": ExchangeError,
				"10013": BadSymbol,
				"10014": InsufficientFunds,
				"10403": PermissionDenied,
				"10429": RateLimitExceeded,
				"40004": AuthenticationError,
				"40103": AuthenticationError,
				"40104": AuthenticationError,
				"40301": PermissionDenied,
				"40302": ExchangeError,
				"40601": ExchangeError,
				"40602": ExchangeError,
				"40603": InsufficientFunds,
				"40604": InvalidOrder,
				"40605": InvalidOrder,
				"40120": InvalidOrder,
				"40121": InvalidOrder,
				"60100": BadSymbol,
			},
			"broad": map[string]interface{}{},
		},
		"commonCurrencies": map[string]interface{}{
			"CRE":  "Cybereits",
			"FXT":  "FXTTOKEN",
			"FREE": "FreeRossDAO",
			"MBN":  "Mobilian Coin",
			"ONE":  "BigONE Token",
		},
	})
}

/**
 * @method
 * @name bigone#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {dict} [params] extra parameters specific to the exchange API endpoint
 * @returns {dict} an associative dictionary of currencies
 */
func (this *BigoneCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// we use undocumented link (possible, less informative alternative is : https://big.one/api/uc/v3/assets/accounts)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		data := (<-this.FetchWebEndpoint("fetchCurrencies", "webExchangeGetV3Assets", true))
		PanicOnError(data)
		if IsTrue(IsEqual(data, nil)) {

			ch <- map[string]interface{}{}
			return nil
		}
		//
		// {
		//     "code": "0",
		//     "message": "",
		//     "data": [
		//       {
		//             "uuid": "17082d1c-0195-4fb6-8779-2cdbcb9eeb3c",
		//             "symbol": "USDT",
		//             "name": "TetherUS",
		//             "scale": 12,
		//             "is_fiat": false,
		//             "is_transfer_enabled": true,
		//             "transfer_scale": 12,
		//             "binding_gateways": [
		//                 {
		//                     "guid": "07efc37f-d1ec-4bc9-8339-a745256ea2ba",
		//                     "is_deposit_enabled": true,
		//                     "gateway_name": "Ethereum",
		//                     "min_withdrawal_amount": "0.000001",
		//                     "withdrawal_fee": "5.71",
		//                     "is_withdrawal_enabled": true,
		//                     "min_deposit_amount": "0.000001",
		//                     "is_memo_required": false,
		//                     "withdrawal_scale": 6,
		//                     "scale": 12
		//                 },
		//                 {
		//                     "guid": "4e387a9a-a480-40a3-b4ae-ed1773c2db5a",
		//                     "is_deposit_enabled": true,
		//                     "gateway_name": "BinanceSmartChain",
		//                     "min_withdrawal_amount": "10",
		//                     "withdrawal_fee": "5",
		//                     "is_withdrawal_enabled": false,
		//                     "min_deposit_amount": "1",
		//                     "is_memo_required": false,
		//                     "withdrawal_scale": 8,
		//                     "scale": 12
		//                 }
		//             ]
		//         },
		//       ...
		//     ],
		// }
		//
		var currenciesData interface{} = this.SafeList(data, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
			var currency interface{} = GetValue(currenciesData, i)
			var id interface{} = this.SafeString(currency, "symbol")
			var code interface{} = this.SafeCurrencyCode(id)
			var name interface{} = this.SafeString(currency, "name")
			var networks interface{} = map[string]interface{}{}
			var chains interface{} = this.SafeList(currency, "binding_gateways", []interface{}{})
			var currencyMaxPrecision interface{} = this.ParsePrecision(this.SafeString2(currency, "withdrawal_scale", "scale"))
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString(chain, "gateway_name")
				var networkCode interface{} = this.NetworkIdToCode(networkId)
				var deposit interface{} = this.SafeBool(chain, "is_deposit_enabled")
				var withdraw interface{} = this.SafeBool(chain, "is_withdrawal_enabled")
				var minDepositAmount interface{} = this.SafeString(chain, "min_deposit_amount")
				var minWithdrawalAmount interface{} = this.SafeString(chain, "min_withdrawal_amount")
				var withdrawalFee interface{} = this.SafeString(chain, "withdrawal_fee")
				var precision interface{} = this.ParsePrecision(this.SafeString2(chain, "withdrawal_scale", "scale"))
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"id":        networkId,
					"network":   networkCode,
					"margin":    nil,
					"deposit":   deposit,
					"withdraw":  withdraw,
					"active":    nil,
					"fee":       this.ParseNumber(withdrawalFee),
					"precision": this.ParseNumber(precision),
					"limits": map[string]interface{}{
						"deposit": map[string]interface{}{
							"min": minDepositAmount,
							"max": nil,
						},
						"withdraw": map[string]interface{}{
							"min": minWithdrawalAmount,
							"max": nil,
						},
					},
					"info": chain,
				})
			}
			var chainLength interface{} = GetArrayLength(chains)
			var typeVar interface{} = nil
			if IsTrue(this.SafeBool(currency, "is_fiat")) {
				typeVar = "fiat"
			} else if IsTrue(IsEqual(chainLength, 0)) {
				if IsTrue(this.IsLeveragedCurrency(id)) {
					typeVar = "leveraged"
				} else {
					typeVar = "other"
				}
			} else {
				typeVar = "crypto"
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        id,
				"code":      code,
				"info":      currency,
				"name":      name,
				"type":      typeVar,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": this.ParseNumber(currencyMaxPrecision),
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchMarkets
 * @description retrieves data on all markets for bigone
 * @see https://open.big.one/docs/spot_asset_pair.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *BigoneCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var promises interface{} = []interface{}{this.PublicGetAssetPairs(params), this.ContractPublicGetSymbols(params)}

		promisesResult := (<-promiseAll(promises))
		PanicOnError(promisesResult)
		var response interface{} = GetValue(promisesResult, 0)
		var contractResponse interface{} = GetValue(promisesResult, 1)
		//
		//     {
		//         "code":0,
		//         "data":[
		//             {
		//                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
		//                 "name":"PCX-BTC",
		//                 "quote_scale":7,
		//                 "quote_asset":{
		//                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
		//                     "symbol":"BTC",
		//                     "name":"Bitcoin",
		//                 },
		//                 "base_asset":{
		//                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
		//                     "symbol":"PCX",
		//                     "name":"ChainX",
		//                 },
		//                 "base_scale":3,
		//                 "min_quote_value":"0.0001",
		//                 "max_quote_value":"35"
		//             },
		//         ]
		//     }
		//
		//
		//    [
		//        {
		//            "baseCurrency": "BTC",
		//            "multiplier": 1,
		//            "enable": true,
		//            "priceStep": 0.5,
		//            "maxRiskLimit": 1000,
		//            "pricePrecision": 1,
		//            "maintenanceMargin": 0.00500,
		//            "symbol": "BTCUSD",
		//            "valuePrecision": 4,
		//            "minRiskLimit": 100,
		//            "riskLimit": 100,
		//            "isInverse": true,
		//            "riskStep": 1,
		//            "settleCurrency": "BTC",
		//            "baseName": "Bitcoin",
		//            "feePrecision": 8,
		//            "priceMin": 0.5,
		//            "priceMax": 1E+6,
		//            "initialMargin": 0.01000,
		//            "quoteCurrency": "USD"
		//        },
		//        ...
		//    ]
		//
		var markets interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var baseAsset interface{} = this.SafeDict(market, "base_asset", map[string]interface{}{})
			var quoteAsset interface{} = this.SafeDict(market, "quote_asset", map[string]interface{}{})
			var baseId interface{} = this.SafeString(baseAsset, "symbol")
			var quoteId interface{} = this.SafeString(quoteAsset, "symbol")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			AppendToArray(&result, this.SafeMarketStructure(map[string]interface{}{
				"id":             this.SafeString(market, "name"),
				"uuid":           this.SafeString(market, "id"),
				"symbol":         Add(Add(base, "/"), quote),
				"base":           base,
				"quote":          quote,
				"settle":         nil,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"margin":         false,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         true,
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "base_scale"))),
					"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quote_scale"))),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "min_quote_value"),
						"max": this.SafeNumber(market, "max_quote_value"),
					},
				},
				"created": nil,
				"info":    market,
			}))
		}
		for i := 0; IsLessThan(i, GetArrayLength(contractResponse)); i++ {
			var market interface{} = GetValue(contractResponse, i)
			var baseId interface{} = this.SafeString(market, "baseCurrency")
			var quoteId interface{} = this.SafeString(market, "quoteCurrency")
			var settleId interface{} = this.SafeString(market, "settleCurrency")
			var marketId interface{} = this.SafeString(market, "symbol")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var settle interface{} = this.SafeCurrencyCode(settleId)
			var inverse interface{} = this.SafeBool(market, "isInverse")
			AppendToArray(&result, this.SafeMarketStructure(map[string]interface{}{
				"id":             marketId,
				"symbol":         Add(Add(Add(Add(base, "/"), quote), ":"), settle),
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           "swap",
				"spot":           false,
				"margin":         false,
				"swap":           true,
				"future":         false,
				"option":         false,
				"active":         this.SafeBool(market, "enable"),
				"contract":       true,
				"linear":         !IsTrue(inverse),
				"inverse":        inverse,
				"contractSize":   this.SafeNumber(market, "multiplier"),
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "valuePrecision"))),
					"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision"))),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": this.SafeNumber(market, "priceMin"),
						"max": this.SafeNumber(market, "priceMax"),
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "initialMargin"),
						"max": nil,
					},
				},
				"info": market,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	//
	//    {
	//        "asset_pair_name": "ETH-BTC",
	//        "bid": {
	//            "price": "0.021593",
	//            "order_count": 1,
	//            "quantity": "0.20936"
	//        },
	//        "ask": {
	//            "price": "0.021613",
	//            "order_count": 1,
	//            "quantity": "2.87064"
	//        },
	//        "open": "0.021795",
	//        "high": "0.021795",
	//        "low": "0.021471",
	//        "close": "0.021613",
	//        "volume": "117078.90431",
	//        "daily_change": "-0.000182"
	//    }
	//
	// contract
	//
	//    {
	//        "usdtPrice": 1.00031998,
	//        "symbol": "BTCUSD",
	//        "btcPrice": 34700.4,
	//        "ethPrice": 1787.83,
	//        "nextFundingRate": 0.00010,
	//        "fundingRate": 0.00010,
	//        "latestPrice": 34708.5,
	//        "last24hPriceChange": 0.0321,
	//        "indexPrice": 34700.4,
	//        "volume24h": 261319063,
	//        "turnover24h": 8204.129380685496,
	//        "nextFundingTime": 1698285600000,
	//        "markPrice": 34702.4646738,
	//        "last24hMaxPrice": 35127.5,
	//        "volume24hInUsd": 0.0,
	//        "openValue": 32.88054722085945,
	//        "last24hMinPrice": 33552.0,
	//        "openInterest": 1141372.0
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketType interface{} = Ternary(IsTrue((InOp(ticker, "asset_pair_name"))), "spot", "swap")
	var marketId interface{} = this.SafeString2(ticker, "asset_pair_name", "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market, "-", marketType)
	var close interface{} = this.SafeString2(ticker, "close", "latestPrice")
	var bid interface{} = this.SafeDict(ticker, "bid", map[string]interface{}{})
	var ask interface{} = this.SafeDict(ticker, "ask", map[string]interface{}{})
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     nil,
		"datetime":      nil,
		"high":          this.SafeString2(ticker, "high", "last24hMaxPrice"),
		"low":           this.SafeString2(ticker, "low", "last24hMinPrice"),
		"bid":           this.SafeString(bid, "price"),
		"bidVolume":     this.SafeString(bid, "quantity"),
		"ask":           this.SafeString(ask, "price"),
		"askVolume":     this.SafeString(ask, "quantity"),
		"vwap":          nil,
		"open":          this.SafeString(ticker, "open"),
		"close":         close,
		"last":          close,
		"previousClose": nil,
		"change":        this.SafeString(ticker, "daily_change"),
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    this.SafeString2(ticker, "volume", "volume24h"),
		"quoteVolume":   this.SafeString(ticker, "volume24hInUsd"),
		"markPrice":     this.SafeString(ticker, "markPrice"),
		"indexPrice":    this.SafeString(ticker, "indexPrice"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name bigone#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://open.big.one/docs/spot_tickers.html
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BigoneCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8808 := (<-this.LoadMarkets())
		PanicOnError(retRes8808)
		var market interface{} = this.Market(symbol)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTicker", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(IsEqual(typeVar, "spot")) {
			var request interface{} = map[string]interface{}{
				"asset_pair_name": GetValue(market, "id"),
			}

			response := (<-this.PublicGetAssetPairsAssetPairNameTicker(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code":0,
			//         "data":{
			//             "asset_pair_name":"ETH-BTC",
			//             "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
			//             "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
			//             "open":"0.021795",
			//             "high":"0.021795",
			//             "low":"0.021471",
			//             "close":"0.021613",
			//             "volume":"117078.90431",
			//             "daily_change":"-0.000182"
			//         }
			//     }
			//
			var ticker interface{} = this.SafeDict(response, "data", map[string]interface{}{})

			ch <- this.ParseTicker(ticker, market)
			return nil
		} else {

			tickers := (<-this.FetchTickers([]interface{}{symbol}, params))
			PanicOnError(tickers)

			ch <- this.SafeValue(tickers, symbol)
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://open.big.one/docs/spot_tickers.html
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BigoneCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes9238 := (<-this.LoadMarkets())
		PanicOnError(retRes9238)
		var market interface{} = nil
		var symbol interface{} = this.SafeString(symbols, 0)
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var isSpot interface{} = IsEqual(typeVar, "spot")
		var request interface{} = map[string]interface{}{}
		symbols = this.MarketSymbols(symbols)
		var data interface{} = nil
		if IsTrue(isSpot) {
			if IsTrue(!IsEqual(symbols, nil)) {
				var ids interface{} = this.MarketIds(symbols)
				AddElementToObject(request, "pair_names", Join(ids, ","))
			}

			response := (<-this.PublicGetAssetPairsTickers(this.Extend(request, params)))
			PanicOnError(response)
			//
			//    {
			//        "code": 0,
			//        "data": [
			//            {
			//                "asset_pair_name": "PCX-BTC",
			//                "bid": {
			//                    "price": "0.000234",
			//                    "order_count": 1,
			//                    "quantity": "0.518"
			//                },
			//                "ask": {
			//                    "price": "0.0002348",
			//                    "order_count": 1,
			//                    "quantity": "2.348"
			//                },
			//                "open": "0.0002343",
			//                "high": "0.0002348",
			//                "low": "0.0002162",
			//                "close": "0.0002348",
			//                "volume": "12887.016",
			//                "daily_change": "0.0000005"
			//            },
			//            ...
			//        ]
			//    }
			//
			data = this.SafeList(response, "data", []interface{}{})
		} else {

			data = (<-this.ContractPublicGetInstruments(params))
			PanicOnError(data)
		}
		var tickers interface{} = this.ParseTickers(data, symbols)

		ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://open.big.one/docs/spot_ping.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *BigoneCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetPing(params))
		PanicOnError(response)
		//
		//     {
		//         "data": {
		//             "timestamp": 1527665262168391000
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var timestamp interface{} = this.SafeInteger(data, "Timestamp")

		ch <- this.ParseToInt(Divide(timestamp, 1000000))
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://open.big.one/docs/contract_misc.html#get-orderbook-snapshot
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *BigoneCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes10348 := (<-this.LoadMarkets())
		PanicOnError(retRes10348)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		if IsTrue(GetValue(market, "contract")) {
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}

			response = (<-this.ContractPublicGetDepthSymbolSnapshot(this.Extend(request, params)))
			PanicOnError(response)

			//
			//    {
			//        bids: {
			//            '20000': '20',
			//            ...
			//            '34552': '64851',
			//            '34526.5': '59594',
			//            ...
			//            '34551.5': '29711'
			//        },
			//        asks: {
			//            '34557': '34395',
			//            ...
			//            '40000': '20',
			//            '34611.5': '56024',
			//            ...
			//            '34578.5': '66367'
			//        },
			//        to: '59737174',
			//        lastPrice: '34554.5',
			//        bestPrices: {
			//            ask: '34557.0',
			//            bid: '34552.0'
			//        },
			//        from: '0'
			//    }
			//
			ch <- this.ParseContractOrderBook(response, GetValue(market, "symbol"), limit)
			return nil
		} else {
			var request interface{} = map[string]interface{}{
				"asset_pair_name": GetValue(market, "id"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit) // default 50, max 200
			}

			response = (<-this.PublicGetAssetPairsAssetPairNameDepth(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code":0,
			//         "data": {
			//             "asset_pair_name": "EOS-BTC",
			//             "bids": [
			//                 { "price": "42", "order_count": 4, "quantity": "23.33363711" }
			//             ],
			//             "asks": [
			//                 { "price": "45", "order_count": 2, "quantity": "4193.3283464" }
			//             ]
			//         }
			//     }
			//
			var orderbook interface{} = this.SafeDict(response, "data", map[string]interface{}{})

			ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "bids", "asks", "price", "quantity")
			return nil
		}

	}()
	return ch
}
func (this *BigoneCore) ParseContractBidsAsks(bidsAsks interface{}) interface{} {
	var bidsAsksKeys interface{} = ObjectKeys(bidsAsks)
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(bidsAsksKeys)); i++ {
		var price interface{} = GetValue(bidsAsksKeys, i)
		var amount interface{} = GetValue(bidsAsks, price)
		AppendToArray(&result, []interface{}{this.ParseNumber(price), this.ParseNumber(amount)})
	}
	return result
}
func (this *BigoneCore) ParseContractOrderBook(orderbook interface{}, symbol interface{}, optionalArgs ...interface{}) interface{} {
	limit := GetArg(optionalArgs, 0, nil)
	_ = limit
	var responseBids interface{} = this.SafeValue(orderbook, "bids")
	var responseAsks interface{} = this.SafeValue(orderbook, "asks")
	var bids interface{} = this.ParseContractBidsAsks(responseBids)
	var asks interface{} = this.ParseContractBidsAsks(responseAsks)
	return map[string]interface{}{
		"symbol":    symbol,
		"bids":      this.FilterByLimit(this.SortBy(bids, 0, true), limit),
		"asks":      this.FilterByLimit(this.SortBy(asks, 0), limit),
		"timestamp": nil,
		"datetime":  nil,
		"nonce":     nil,
	}
}
func (this *BigoneCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades (public)
	//
	//     {
	//         "id": 38199941,
	//         "price": "3378.67",
	//         "amount": "0.019812",
	//         "taker_side": "ASK",
	//         "created_at": "2019-01-29T06:05:56Z"
	//     }
	//
	// fetchMyTrades (private)
	//
	//     {
	//         "id": 10854280,
	//         "asset_pair_name": "XIN-USDT",
	//         "price": "70",
	//         "amount": "1",
	//         "taker_side": "ASK",
	//         "maker_order_id": 58284908,
	//         "taker_order_id": 58284909,
	//         "maker_fee": "0.0008",
	//         "taker_fee": "0.07",
	//         "side": "SELF_TRADING",
	//         "inserted_at": "2019-04-16T12:00:01Z"
	//     },
	//
	//     {
	//         "id": 10854263,
	//         "asset_pair_name": "XIN-USDT",
	//         "price": "75.7",
	//         "amount": "12.743149",
	//         "taker_side": "BID",
	//         "maker_order_id": null,
	//         "taker_order_id": 58284888,
	//         "maker_fee": null,
	//         "taker_fee": "0.0025486298",
	//         "side": "BID",
	//         "inserted_at": "2019-04-15T06:20:57Z"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.Parse8601(this.SafeString2(trade, "created_at", "inserted_at"))
	var priceString interface{} = this.SafeString(trade, "price")
	var amountString interface{} = this.SafeString(trade, "amount")
	var marketId interface{} = this.SafeString(trade, "asset_pair_name")
	market = this.SafeMarket(marketId, market, "-")
	var side interface{} = this.SafeString(trade, "side")
	var takerSide interface{} = this.SafeString(trade, "taker_side")
	var takerOrMaker interface{} = nil
	if IsTrue(IsTrue(IsTrue((!IsEqual(takerSide, nil))) && IsTrue((!IsEqual(side, nil)))) && IsTrue((!IsEqual(side, "SELF_TRADING")))) {
		takerOrMaker = Ternary(IsTrue((IsEqual(takerSide, side))), "taker", "maker")
	}
	if IsTrue(IsEqual(side, nil)) {
		// taker side is not related to buy/sell side
		// the following code is probably a mistake
		side = Ternary(IsTrue((IsEqual(takerSide, "ASK"))), "sell", "buy")
	} else {
		if IsTrue(IsEqual(side, "BID")) {
			side = "buy"
		} else if IsTrue(IsEqual(side, "ASK")) {
			side = "sell"
		}
	}
	var makerOrderId interface{} = this.SafeString(trade, "maker_order_id")
	var takerOrderId interface{} = this.SafeString(trade, "taker_order_id")
	var orderId interface{} = nil
	if IsTrue(!IsEqual(makerOrderId, nil)) {
		orderId = makerOrderId
	} else if IsTrue(!IsEqual(takerOrderId, nil)) {
		orderId = takerOrderId
	}
	var id interface{} = this.SafeString(trade, "id")
	var result interface{} = map[string]interface{}{
		"id":           id,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"order":        orderId,
		"type":         "limit",
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        priceString,
		"amount":       amountString,
		"cost":         nil,
		"info":         trade,
	}
	var makerCurrencyCode interface{} = nil
	var takerCurrencyCode interface{} = nil
	if IsTrue(!IsEqual(takerOrMaker, nil)) {
		if IsTrue(IsEqual(side, "buy")) {
			if IsTrue(IsEqual(takerOrMaker, "maker")) {
				makerCurrencyCode = GetValue(market, "base")
				takerCurrencyCode = GetValue(market, "quote")
			} else {
				makerCurrencyCode = GetValue(market, "quote")
				takerCurrencyCode = GetValue(market, "base")
			}
		} else {
			if IsTrue(IsEqual(takerOrMaker, "maker")) {
				makerCurrencyCode = GetValue(market, "quote")
				takerCurrencyCode = GetValue(market, "base")
			} else {
				makerCurrencyCode = GetValue(market, "base")
				takerCurrencyCode = GetValue(market, "quote")
			}
		}
	} else if IsTrue(IsEqual(side, "SELF_TRADING")) {
		if IsTrue(IsEqual(takerSide, "BID")) {
			makerCurrencyCode = GetValue(market, "quote")
			takerCurrencyCode = GetValue(market, "base")
		} else if IsTrue(IsEqual(takerSide, "ASK")) {
			makerCurrencyCode = GetValue(market, "base")
			takerCurrencyCode = GetValue(market, "quote")
		}
	}
	var makerFeeCost interface{} = this.SafeString(trade, "maker_fee")
	var takerFeeCost interface{} = this.SafeString(trade, "taker_fee")
	if IsTrue(!IsEqual(makerFeeCost, nil)) {
		if IsTrue(!IsEqual(takerFeeCost, nil)) {
			AddElementToObject(result, "fees", []interface{}{map[string]interface{}{
				"cost":     makerFeeCost,
				"currency": makerCurrencyCode,
			}, map[string]interface{}{
				"cost":     takerFeeCost,
				"currency": takerCurrencyCode,
			}})
		} else {
			AddElementToObject(result, "fee", map[string]interface{}{
				"cost":     makerFeeCost,
				"currency": makerCurrencyCode,
			})
		}
	} else if IsTrue(!IsEqual(takerFeeCost, nil)) {
		AddElementToObject(result, "fee", map[string]interface{}{
			"cost":     takerFeeCost,
			"currency": takerCurrencyCode,
		})
	} else {
		AddElementToObject(result, "fee", nil)
	}
	return this.SafeTrade(result, market)
}

/**
 * @method
 * @name bigone#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://open.big.one/docs/spot_asset_pair_trade.html
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *BigoneCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes12708 := (<-this.LoadMarkets())
		PanicOnError(retRes12708)
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "contract")) {
			panic(NotSupported(Add(this.Id, " fetchTrades () can only fetch trades for spot markets")))
		}
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
		}

		response := (<-this.PublicGetAssetPairsAssetPairNameTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "data": [
		//             {
		//                 "id": 38199941,
		//                 "price": "3378.67",
		//                 "amount": "0.019812",
		//                 "taker_side": "ASK",
		//                 "created_at": "2019-01-29T06:05:56Z"
		//             },
		//             {
		//                 "id": 38199934,
		//                 "price": "3376.14",
		//                 "amount": "0.019384",
		//                 "taker_side": "ASK",
		//                 "created_at": "2019-01-29T06:05:40Z"
		//             }
		//         ]
		//     }
		//
		var trades interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "close": "0.021562",
	//         "high": "0.021563",
	//         "low": "0.02156",
	//         "open": "0.021563",
	//         "time": "2019-11-21T07:54:00Z",
	//         "volume": "59.84376"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.Parse8601(this.SafeString(ohlcv, "time")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}

/**
 * @method
 * @name bigone#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://open.big.one/docs/spot_asset_pair_candle.html
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the earliest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *BigoneCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes13398 := (<-this.LoadMarkets())
		PanicOnError(retRes13398)
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "contract")) {
			panic(NotSupported(Add(this.Id, " fetchOHLCV () can only fetch ohlcvs for spot markets")))
		}
		var until interface{} = this.SafeInteger(params, "until")
		var untilIsDefined interface{} = (!IsEqual(until, nil))
		var sinceIsDefined interface{} = (!IsEqual(since, nil))
		if IsTrue(IsEqual(limit, nil)) {
			limit = Ternary(IsTrue((IsTrue(sinceIsDefined) && IsTrue(untilIsDefined))), 500, 100) // default 100, max 500, if since and limit defined then fetch all the candles between them unless it exceeds the max of 500
		}
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
			"period":          this.SafeString(this.Timeframes, timeframe, timeframe),
			"limit":           limit,
		}
		if IsTrue(sinceIsDefined) {
			// const start = this.parseToInt (since / 1000);
			var duration interface{} = this.ParseTimeframe(timeframe)
			var endByLimit interface{} = this.Sum(since, Multiply(Multiply(limit, duration), 1000))
			if IsTrue(untilIsDefined) {
				AddElementToObject(request, "time", this.Iso8601(mathMin(endByLimit, Add(until, 1))))
			} else {
				AddElementToObject(request, "time", this.Iso8601(endByLimit))
			}
		} else if IsTrue(untilIsDefined) {
			AddElementToObject(request, "time", this.Iso8601(Add(until, 1)))
		}
		params = this.Omit(params, "until")

		response := (<-this.PublicGetAssetPairsAssetPairNameCandles(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "data": [
		//             {
		//                 "close": "0.021656",
		//                 "high": "0.021658",
		//                 "low": "0.021652",
		//                 "open": "0.021652",
		//                 "time": "2019-11-21T09:30:00Z",
		//                 "volume": "53.08664"
		//             },
		//             {
		//                 "close": "0.021652",
		//                 "high": "0.021656",
		//                 "low": "0.021652",
		//                 "open": "0.021656",
		//                 "time": "2019-11-21T09:29:00Z",
		//                 "volume": "88.39861"
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	var balances interface{} = this.SafeList(response, "data", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var symbol interface{} = this.SafeString(balance, "asset_symbol")
		var code interface{} = this.SafeCurrencyCode(symbol)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(balance, "balance"))
		AddElementToObject(account, "used", this.SafeString(balance, "locked_balance"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name bigone#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://open.big.one/docs/fund_accounts.html
 * @see https://open.big.one/docs/spot_accounts.html
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *BigoneCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14258 := (<-this.LoadMarkets())
		PanicOnError(retRes14258)
		var typeVar interface{} = this.SafeString(params, "type", "")
		params = this.Omit(params, "type")
		var response interface{} = nil
		if IsTrue(IsTrue(IsEqual(typeVar, "funding")) || IsTrue(IsEqual(typeVar, "fund"))) {

			response = (<-this.PrivateGetFundAccounts(params))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetAccounts(params))
			PanicOnError(response)
		}

		//
		//     {
		//         "code":0,
		//         "data":[
		//             {"asset_symbol":"NKC","balance":"0","locked_balance":"0"},
		//             {"asset_symbol":"UBTC","balance":"0","locked_balance":"0"},
		//             {"asset_symbol":"READ","balance":"0","locked_balance":"0"},
		//         ],
		//     }
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"STOP_LIMIT":  "limit",
		"STOP_MARKET": "market",
		"LIMIT":       "limit",
		"MARKET":      "market",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *BigoneCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "id": "42154072252",
	//        "asset_pair_name": "SOL-USDT",
	//        "price": "20",
	//        "amount": "0.5",
	//        "filled_amount": "0",
	//        "avg_deal_price": "0",
	//        "side": "ASK",
	//        "state": "PENDING",
	//        "created_at": "2023-09-13T03:42:00Z",
	//        "updated_at": "2023-09-13T03:42:00Z",
	//        "type": "LIMIT",
	//        "stop_price": "0",
	//        "immediate_or_cancel": false,
	//        "post_only": false,
	//        "client_order_id": ''
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(order, "id")
	var marketId interface{} = this.SafeString(order, "asset_pair_name")
	var symbol interface{} = this.SafeSymbol(marketId, market, "-")
	var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
	var side interface{} = this.SafeString(order, "side")
	if IsTrue(IsEqual(side, "BID")) {
		side = "buy"
	} else {
		side = "sell"
	}
	var triggerPrice interface{} = this.SafeString(order, "stop_price")
	if IsTrue(Precise.StringEq(triggerPrice, "0")) {
		triggerPrice = nil
	}
	var immediateOrCancel interface{} = this.SafeBool(order, "immediate_or_cancel")
	var timeInForce interface{} = nil
	if IsTrue(immediateOrCancel) {
		timeInForce = "IOC"
	}
	var typeVar interface{} = this.ParseType(this.SafeString(order, "type"))
	var price interface{} = this.SafeString(order, "price")
	var amount interface{} = nil
	var filled interface{} = nil
	var cost interface{} = nil
	if IsTrue(IsTrue(IsEqual(typeVar, "market")) && IsTrue(IsEqual(side, "buy"))) {
		cost = this.SafeString(order, "filled_amount")
	} else {
		amount = this.SafeString(order, "amount")
		filled = this.SafeString(order, "filled_amount")
	}
	return this.SafeOrder(map[string]interface{}{
		"info":               order,
		"id":                 id,
		"clientOrderId":      this.SafeString(order, "client_order_id"),
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": this.Parse8601(this.SafeString(order, "updated_at")),
		"symbol":             symbol,
		"type":               typeVar,
		"timeInForce":        timeInForce,
		"postOnly":           this.SafeBool(order, "post_only"),
		"side":               side,
		"price":              price,
		"triggerPrice":       triggerPrice,
		"amount":             amount,
		"cost":               cost,
		"average":            this.SafeString(order, "avg_deal_price"),
		"filled":             filled,
		"remaining":          nil,
		"status":             this.ParseOrderStatus(this.SafeString(order, "state")),
		"fee":                nil,
		"trades":             nil,
	}, market)
}

/**
 * @method
 * @name bigone#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://open.big.one/docs/spot_orders.html#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes15438 := (<-this.LoadMarkets())
		PanicOnError(retRes15438)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
		}
		AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)

		retRes154915 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
		PanicOnError(retRes154915)
		ch <- retRes154915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#createOrder
 * @description create a trade order
 * @see https://open.big.one/docs/spot_orders.html#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.operator] *stop order only* GTE or LTE (default)
 * @param {string} [params.client_order_id] must match ^[a-zA-Z0-9-_]{1,36}$ this regex. client_order_id is unique in 24 hours, If created 24 hours later and the order closed, it will be released and can be reused
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes15748 := (<-this.LoadMarkets())
		PanicOnError(retRes15748)
		var market interface{} = this.Market(symbol)
		var isBuy interface{} = (IsEqual(side, "buy"))
		var requestSide interface{} = Ternary(IsTrue(isBuy), "BID", "ASK")
		var uppercaseType interface{} = ToUpper(typeVar)
		var isLimit interface{} = IsEqual(uppercaseType, "LIMIT")
		var exchangeSpecificParam interface{} = this.SafeBool(params, "post_only", false)
		var postOnly interface{} = nil
		postOnlyparamsVariable := this.HandlePostOnly((IsEqual(uppercaseType, "MARKET")), exchangeSpecificParam, params)
		postOnly = GetValue(postOnlyparamsVariable, 0)
		params = GetValue(postOnlyparamsVariable, 1)
		var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "stop_price"})
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
			"side":            requestSide,
			"amount":          this.AmountToPrecision(symbol, amount),
		}
		if IsTrue(IsTrue(isLimit) || IsTrue((IsEqual(uppercaseType, "STOP_LIMIT")))) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
			if IsTrue(isLimit) {
				var timeInForce interface{} = this.SafeString(params, "timeInForce")
				if IsTrue(IsEqual(timeInForce, "IOC")) {
					AddElementToObject(request, "immediate_or_cancel", true)
				}
				if IsTrue(postOnly) {
					AddElementToObject(request, "post_only", true)
				}
			}
			AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
		} else {
			if IsTrue(isBuy) {
				var createMarketBuyOrderRequiresPrice interface{} = true
				createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
				createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
				params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
				var cost interface{} = this.SafeNumber(params, "cost")
				params = this.Omit(params, "cost")
				if IsTrue(createMarketBuyOrderRequiresPrice) {
					if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
					} else {
						var amountString interface{} = this.NumberToString(amount)
						var priceString interface{} = this.NumberToString(price)
						var quoteAmount interface{} = this.ParseToNumeric(Precise.StringMul(amountString, priceString))
						var costRequest interface{} = Ternary(IsTrue((!IsEqual(cost, nil))), cost, quoteAmount)
						AddElementToObject(request, "amount", this.CostToPrecision(symbol, costRequest))
					}
				} else {
					AddElementToObject(request, "amount", this.CostToPrecision(symbol, amount))
				}
			} else {
				AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
			}
		}
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
			AddElementToObject(request, "operator", Ternary(IsTrue(isBuy), "GTE", "LTE"))
			if IsTrue(isLimit) {
				uppercaseType = "STOP_LIMIT"
			} else if IsTrue(IsEqual(uppercaseType, "MARKET")) {
				uppercaseType = "STOP_MARKET"
			}
		}
		AddElementToObject(request, "type", uppercaseType)
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "client_order_id", clientOrderId)
		}
		params = this.Omit(params, []interface{}{"stop_price", "stopPrice", "triggerPrice", "timeInForce", "clientOrderId"})

		response := (<-this.PrivatePostOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "id": 10,
		//        "asset_pair_name": "EOS-BTC",
		//        "price": "10.00",
		//        "amount": "10.00",
		//        "filled_amount": "9.0",
		//        "avg_deal_price": "12.0",
		//        "side": "ASK",
		//        "state": "FILLED",
		//        "created_at":"2019-01-29T06:05:56Z",
		//        "updated_at":"2019-01-29T06:05:56Z"
		//    }
		//
		var order interface{} = this.SafeDict(response, "data")

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#cancelOrder
 * @description cancels an open order
 * @see https://open.big.one/docs/spot_orders.html#cancel-order
 * @param {string} id order id
 * @param {string} symbol Not used by bigone cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes16738 := (<-this.LoadMarkets())
		PanicOnError(retRes16738)
		var request interface{} = map[string]interface{}{
			"id": id,
		}

		response := (<-this.PrivatePostOrdersIdCancel(this.Extend(request, params)))
		PanicOnError(response)
		//    {
		//        "id": 10,
		//        "asset_pair_name": "EOS-BTC",
		//        "price": "10.00",
		//        "amount": "10.00",
		//        "filled_amount": "9.0",
		//        "avg_deal_price": "12.0",
		//        "side": "ASK",
		//        "state": "CANCELLED",
		//        "created_at":"2019-01-29T06:05:56Z",
		//        "updated_at":"2019-01-29T06:05:56Z"
		//    }
		var order interface{} = this.SafeDict(response, "data")

		ch <- this.ParseOrder(order)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#cancelAllOrders
 * @description cancel all open orders
 * @see https://open.big.one/docs/spot_orders.html#cancel-all-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17028 := (<-this.LoadMarkets())
		PanicOnError(retRes17028)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
		}

		response := (<-this.PrivatePostOrdersCancel(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":0,
		//         "data": {
		//             "cancelled":[
		//                 58272370,
		//                 58272377
		//             ],
		//             "failed": []
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var cancelled interface{} = this.SafeList(data, "cancelled", []interface{}{})
		var failed interface{} = this.SafeList(data, "failed", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(cancelled)); i++ {
			var orderId interface{} = GetValue(cancelled, i)
			AppendToArray(&result, this.SafeOrder(map[string]interface{}{
				"info":   orderId,
				"id":     orderId,
				"status": "canceled",
			}))
		}
		for i := 0; IsLessThan(i, GetArrayLength(failed)); i++ {
			var orderId interface{} = GetValue(failed, i)
			AppendToArray(&result, this.SafeOrder(map[string]interface{}{
				"info":   orderId,
				"id":     orderId,
				"status": "failed",
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-one-order
 * @param {string} id the order id
 * @param {string} symbol not used by bigone fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17548 := (<-this.LoadMarkets())
		PanicOnError(retRes17548)
		var request interface{} = map[string]interface{}{
			"id": id,
		}

		response := (<-this.PrivateGetOrdersId(this.Extend(request, params)))
		PanicOnError(response)
		var order interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(order)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
		}

		retRes17768 := (<-this.LoadMarkets())
		PanicOnError(retRes17768)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 20, max 200
		}

		response := (<-this.PrivateGetOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code":0,
		//        "data": [
		//             {
		//                 "id": 10,
		//                 "asset_pair_name": "ETH-BTC",
		//                 "price": "10.00",
		//                 "amount": "10.00",
		//                 "filled_amount": "9.0",
		//                 "avg_deal_price": "12.0",
		//                 "side": "ASK",
		//                 "state": "FILLED",
		//                 "created_at":"2019-01-29T06:05:56Z",
		//                 "updated_at":"2019-01-29T06:05:56Z",
		//             },
		//         ],
		//        "page_token":"dxzef",
		//    }
		//
		var orders interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://open.big.one/docs/spot_trade.html#trades-of-user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *BigoneCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes18288 := (<-this.LoadMarkets())
		PanicOnError(retRes18288)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"asset_pair_name": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 20, max 200
		}

		response := (<-this.PrivateGetTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "data": [
		//             {
		//                 "id": 10854280,
		//                 "asset_pair_name": "XIN-USDT",
		//                 "price": "70",
		//                 "amount": "1",
		//                 "taker_side": "ASK",
		//                 "maker_order_id": 58284908,
		//                 "taker_order_id": 58284909,
		//                 "maker_fee": "0.0008",
		//                 "taker_fee": "0.07",
		//                 "side": "SELF_TRADING",
		//                 "inserted_at": "2019-04-16T12:00:01Z"
		//             },
		//             {
		//                 "id": 10854263,
		//                 "asset_pair_name": "XIN-USDT",
		//                 "price": "75.7",
		//                 "amount": "12.743149",
		//                 "taker_side": "BID",
		//                 "maker_order_id": null,
		//                 "taker_order_id": 58284888,
		//                 "maker_fee": null,
		//                 "taker_fee": "0.0025486298",
		//                 "side": "BID",
		//                 "inserted_at": "2019-04-15T06:20:57Z"
		//             }
		//         ],
		//         "page_token":"dxfv"
		//     }
		//
		var trades interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"PENDING":   "open",
		"FILLED":    "closed",
		"CANCELLED": "canceled",
	}
	return this.SafeString(statuses, status)
}

/**
 * @method
 * @name bigone#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"state": "PENDING",
		}

		retRes190015 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes190015)
		ch <- retRes190015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://open.big.one/docs/spot_orders.html#get-user-orders-in-one-asset-pair
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BigoneCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"state": "FILLED",
		}

		retRes191815 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes191815)
		ch <- retRes191815
		return nil

	}()
	return ch
}
func (this *BigoneCore) Nonce() interface{} {
	var exchangeTimeCorrection interface{} = Multiply(this.SafeInteger(this.Options, "exchangeMillisecondsCorrection", 0), 1000000)
	return this.Sum(Multiply(this.Microseconds(), 1000), exchangeTimeCorrection)
}
func (this *BigoneCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	var baseUrl interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api))
	var url interface{} = Add(Add(baseUrl, "/"), this.ImplodeParams(path, params))
	headers = map[string]interface{}{}
	if IsTrue(IsTrue(IsTrue(IsEqual(api, "public")) || IsTrue(IsEqual(api, "webExchange"))) || IsTrue(IsEqual(api, "contractPublic"))) {
		if IsTrue(GetArrayLength(ObjectKeys(query))) {
			url = Add(url, Add("?", this.Urlencode(query)))
		}
	} else {
		this.CheckRequiredCredentials()
		var nonce interface{} = ToString(this.Nonce())
		var request interface{} = map[string]interface{}{
			"type":  "OpenAPIV2",
			"sub":   this.ApiKey,
			"nonce": nonce,
		}
		var token interface{} = Jwt(request, this.Encode(this.Secret), sha256)
		AddElementToObject(headers, "Authorization", Add("Bearer ", token))
		if IsTrue(IsEqual(method, "GET")) {
			if IsTrue(GetArrayLength(ObjectKeys(query))) {
				url = Add(url, Add("?", this.Urlencode(query)))
			}
		} else if IsTrue(IsEqual(method, "POST")) {
			AddElementToObject(headers, "Content-Type", "application/json")
			body = this.Json(query)
		}
	}
	AddElementToObject(headers, "User-Agent", Add(Add(Add("ccxt/", this.Id), "-"), this.Version))
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}

/**
 * @method
 * @name bigone#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://open.big.one/docs/spot_deposit.html#get-deposite-address-of-one-asset-of-user
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *BigoneCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19698 := (<-this.LoadMarkets())
		PanicOnError(retRes19698)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"asset_symbol": GetValue(currency, "id"),
		}
		networkCodeparamsOmittedVariable := this.HandleNetworkCodeAndParams(params)
		networkCode := GetValue(networkCodeparamsOmittedVariable, 0)
		paramsOmitted := GetValue(networkCodeparamsOmittedVariable, 1)

		response := (<-this.PrivateGetAssetsAssetSymbolAddress(this.Extend(request, paramsOmitted)))
		PanicOnError(response)
		//
		// the actual response format is not the same as the documented one
		// the data key contains an array in the actual response
		//
		//     {
		//         "code":0,
		//         "message":"",
		//         "data":[
		//             {
		//                 "id":5521878,
		//                 "chain":"Bitcoin",
		//                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
		//                 "memo":""
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var dataLength interface{} = GetArrayLength(data)
		if IsTrue(IsLessThan(dataLength, 1)) {
			panic(ExchangeError(Add(this.Id, " fetchDepositAddress() returned empty address response")))
		}
		var chainsIndexedById interface{} = this.IndexBy(data, "chain")
		var selectedNetworkId interface{} = this.SelectNetworkIdFromRawNetworks(code, networkCode, chainsIndexedById)
		var addressObject interface{} = this.SafeDict(chainsIndexedById, selectedNetworkId, map[string]interface{}{})
		var address interface{} = this.SafeString(addressObject, "value")
		var tag interface{} = this.SafeString(addressObject, "memo")
		this.CheckAddress(address)

		ch <- map[string]interface{}{
			"info":     response,
			"currency": code,
			"network":  this.NetworkIdToCode(selectedNetworkId),
			"address":  address,
			"tag":      tag,
		}
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"WITHHOLD":    "ok",
		"UNCONFIRMED": "pending",
		"CONFIRMED":   "ok",
		"COMPLETED":   "ok",
		"PENDING":     "pending",
	}
	return this.SafeString(statuses, status, status)
}
func (this *BigoneCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "amount": "25.0",
	//         "asset_symbol": "BTS"
	//         "confirms": 100,
	//         "id": 5,
	//         "inserted_at": "2018-02-16T11:39:58.000Z",
	//         "is_internal": false,
	//         "kind": "default",
	//         "memo": "",
	//         "state": "WITHHOLD",
	//         "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
	//         "updated_at": "2018-11-09T10:20:09.000Z",
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "amount": "5",
	//         "asset_symbol": "ETH",
	//         "completed_at": "2018-03-15T16:13:45.610463Z",
	//         "customer_id": "10",
	//         "id": 10,
	//         "inserted_at": "2018-03-15T16:13:45.610463Z",
	//         "is_internal": true,
	//         "note": "2018-03-15T16:13:45.610463Z",
	//         "state": "CONFIRMED",
	//         "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
	//         "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
	//     }
	//
	// withdraw
	//
	//     {
	//         "id":1077391,
	//         "customer_id":1082679,
	//         "amount":"21.9000000000000000",
	//         "txid":"",
	//         "is_internal":false,
	//         "kind":"on_chain",
	//         "state":"PENDING",
	//         "inserted_at":"2020-06-03T00:50:57+00:00",
	//         "updated_at":"2020-06-03T00:50:57+00:00",
	//         "memo":"",
	//         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
	//         "fee":"0.1000000000000000",
	//         "asset_symbol":"XRP"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(transaction, "asset_symbol")
	var code interface{} = this.SafeCurrencyCode(currencyId)
	var id interface{} = this.SafeString(transaction, "id")
	var amount interface{} = this.SafeNumber(transaction, "amount")
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
	var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "inserted_at"))
	var updated interface{} = this.Parse8601(this.SafeString2(transaction, "updated_at", "completed_at"))
	var txid interface{} = this.SafeString(transaction, "txid")
	var address interface{} = this.SafeString(transaction, "target_address")
	var tag interface{} = this.SafeString(transaction, "memo")
	var typeVar interface{} = Ternary(IsTrue((InOp(transaction, "customer_id"))), "withdrawal", "deposit")
	var internal interface{} = this.SafeBool(transaction, "is_internal")
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     nil,
		"addressFrom": nil,
		"address":     nil,
		"addressTo":   address,
		"tagFrom":     nil,
		"tag":         tag,
		"tagTo":       nil,
		"type":        typeVar,
		"amount":      amount,
		"currency":    code,
		"status":      status,
		"updated":     updated,
		"fee":         nil,
		"comment":     nil,
		"internal":    internal,
	}
}

/**
 * @method
 * @name bigone#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://open.big.one/docs/spot_deposit.html#deposit-of-user
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BigoneCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21258 := (<-this.LoadMarkets())
		PanicOnError(retRes21258)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "asset_symbol", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 50
		}

		response := (<-this.PrivateGetDeposits(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "page_token": "NQ==",
		//         "data": [
		//             {
		//                 "id": 5,
		//                 "amount": "25.0",
		//                 "confirms": 100,
		//                 "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
		//                 "is_internal": false,
		//                 "inserted_at": "2018-02-16T11:39:58.000Z",
		//                 "updated_at": "2018-11-09T10:20:09.000Z",
		//                 "kind": "default",
		//                 "memo": "",
		//                 "state": "WITHHOLD",
		//                 "asset_symbol": "BTS"
		//             }
		//         ]
		//     }
		//
		var deposits interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(deposits, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://open.big.one/docs/spot_withdrawal.html#get-withdrawals-of-user
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BigoneCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21788 := (<-this.LoadMarkets())
		PanicOnError(retRes21788)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "asset_symbol", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 50
		}

		response := (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "data": [
		//             {
		//                 "id": 10,
		//                 "customer_id": "10",
		//                 "asset_symbol": "ETH",
		//                 "amount": "5",
		//                 "state": "CONFIRMED",
		//                 "note": "2018-03-15T16:13:45.610463Z",
		//                 "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
		//                 "completed_at": "2018-03-15T16:13:45.610463Z",
		//                 "inserted_at": "2018-03-15T16:13:45.610463Z",
		//                 "is_internal": true,
		//                 "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
		//             }
		//         ],
		//         "page_token":"dxvf"
		//     }
		//
		var withdrawals interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(withdrawals, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bigone#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://open.big.one/docs/spot_transfer.html#transfer-of-user
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'SPOT', 'FUND', or 'CONTRACT'
 * @param {string} toAccount 'SPOT', 'FUND', or 'CONTRACT'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *BigoneCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22328 := (<-this.LoadMarkets())
		PanicOnError(retRes22328)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		var guid interface{} = this.SafeString(params, "guid", this.Uuid())
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(currency, "id"),
			"amount": this.CurrencyToPrecision(code, amount),
			"from":   fromId,
			"to":     toId,
			"guid":   guid,
		}

		response := (<-this.PrivatePostTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "data": null
		//     }
		//
		var transfer interface{} = this.ParseTransfer(response, currency)
		var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{}{})
		var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
		if IsTrue(fillResponseFromRequest) {
			AddElementToObject(transfer, "fromAccount", fromAccount)
			AddElementToObject(transfer, "toAccount", toAccount)
			AddElementToObject(transfer, "amount", amount)
			AddElementToObject(transfer, "id", guid)
		}

		ch <- transfer
		return nil

	}()
	return ch
}
func (this *BigoneCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "code": 0,
	//         "data": null
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var code interface{} = this.SafeString(transfer, "code")
	return map[string]interface{}{
		"info":        transfer,
		"id":          nil,
		"timestamp":   nil,
		"datetime":    nil,
		"currency":    nil,
		"amount":      nil,
		"fromAccount": nil,
		"toAccount":   nil,
		"status":      this.ParseTransferStatus(code),
	}
}
func (this *BigoneCore) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"0": "ok",
	}
	return this.SafeString(statuses, status, "failed")
}

/**
 * @method
 * @name bigone#withdraw
 * @description make a withdrawal
 * @see https://open.big.one/docs/spot_withdrawal.html#create-withdrawal-of-user
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BigoneCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes23088 := (<-this.LoadMarkets())
		PanicOnError(retRes23088)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"symbol":         GetValue(currency, "id"),
			"target_address": address,
			"amount":         this.CurrencyToPrecision(code, amount),
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "memo", tag)
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "gateway_name", this.NetworkCodeToId(networkCode))
		}
		// requires write permission on the wallet

		response := (<-this.PrivatePostWithdrawals(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":0,
		//         "message":"",
		//         "data":{
		//             "id":1077391,
		//             "customer_id":1082679,
		//             "amount":"21.9000000000000000",
		//             "txid":"",
		//             "is_internal":false,
		//             "kind":"on_chain",
		//             "state":"PENDING",
		//             "inserted_at":"2020-06-03T00:50:57+00:00",
		//             "updated_at":"2020-06-03T00:50:57+00:00",
		//             "memo":"",
		//             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
		//             "fee":"0.1000000000000000",
		//             "asset_symbol":"XRP"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTransaction(data, currency)
		return nil

	}()
	return ch
}
func (this *BigoneCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	//
	//      {"code":10013,"message":"Resource not found"}
	//      {"code":40004,"message":"invalid jwt"}
	//
	var code interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString(response, "message")
	if IsTrue(IsTrue((!IsEqual(code, "0"))) && IsTrue((!IsEqual(code, nil)))) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *BigoneCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
