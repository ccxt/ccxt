package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type xt struct {
    Exchange

}

func NewXtCore() xt {
   p := xt{}
   setDefaults(&p)
   return p
}

func  (this *xt) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "xt",
        "name": "XT",
        "countries": []interface{}{"SC"},
        "rateLimit": 100,
        "version": "v4",
        "certified": false,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": true,
            "option": false,
            "addMargin": true,
            "borrowMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": true,
            "editOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBidsAsks": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawals": false,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchL3OrderBook": false,
            "fetchLedger": true,
            "fetchLedgerEntry": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": true,
            "fetchMarketLeverageTiers": true,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": true,
            "fetchOrdersByStatus": true,
            "fetchOrderTrades": false,
            "fetchPosition": true,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": true,
            "repayMargin": false,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": true,
            "setPositionMode": false,
            "signIn": false,
            "transfer": true,
            "withdraw": true,
        },
        "precisionMode": TICK_SIZE,
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/14319357/232636712-466df2fc-560a-4ca4-aab2-b1d954a58e24.jpg",
            "api": map[string]interface{} {
                "spot": "https://sapi.xt.com",
                "linear": "https://fapi.xt.com",
                "inverse": "https://dapi.xt.com",
                "user": "https://api.xt.com",
            },
            "www": "https://xt.com",
            "referral": "https://www.xt.com/en/accounts/register?ref=9PTM9VW",
            "doc": []interface{}{"https://doc.xt.com/", "https://github.com/xtpub/api-doc"},
            "fees": "https://www.xt.com/en/rate",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "spot": map[string]interface{} {
                    "get": map[string]interface{} {
                        "currencies": 1,
                        "depth": 10,
                        "kline": 1,
                        "symbol": 1,
                        "ticker": 1,
                        "ticker/book": 1,
                        "ticker/price": 1,
                        "ticker/24h": 1,
                        "time": 1,
                        "trade/history": 1,
                        "trade/recent": 1,
                        "wallet/support/currency": 1,
                    },
                },
                "linear": map[string]interface{} {
                    "get": map[string]interface{} {
                        "future/market/v1/public/contract/risk-balance": 1,
                        "future/market/v1/public/contract/open-interest": 1,
                        "future/market/v1/public/leverage/bracket/detail": 1,
                        "future/market/v1/public/leverage/bracket/list": 1,
                        "future/market/v1/public/q/agg-ticker": 1,
                        "future/market/v1/public/q/agg-tickers": 1,
                        "future/market/v1/public/q/deal": 1,
                        "future/market/v1/public/q/depth": 1,
                        "future/market/v1/public/q/funding-rate": 1,
                        "future/market/v1/public/q/funding-rate-record": 1,
                        "future/market/v1/public/q/index-price": 1,
                        "future/market/v1/public/q/kline": 1,
                        "future/market/v1/public/q/mark-price": 1,
                        "future/market/v1/public/q/symbol-index-price": 1,
                        "future/market/v1/public/q/symbol-mark-price": 1,
                        "future/market/v1/public/q/ticker": 1,
                        "future/market/v1/public/q/tickers": 1,
                        "future/market/v1/public/symbol/coins": 3.33,
                        "future/market/v1/public/symbol/detail": 3.33,
                        "future/market/v1/public/symbol/list": 1,
                    },
                },
                "inverse": map[string]interface{} {
                    "get": map[string]interface{} {
                        "future/market/v1/public/contract/risk-balance": 1,
                        "future/market/v1/public/contract/open-interest": 1,
                        "future/market/v1/public/leverage/bracket/detail": 1,
                        "future/market/v1/public/leverage/bracket/list": 1,
                        "future/market/v1/public/q/agg-ticker": 1,
                        "future/market/v1/public/q/agg-tickers": 1,
                        "future/market/v1/public/q/deal": 1,
                        "future/market/v1/public/q/depth": 1,
                        "future/market/v1/public/q/funding-rate": 1,
                        "future/market/v1/public/q/funding-rate-record": 1,
                        "future/market/v1/public/q/index-price": 1,
                        "future/market/v1/public/q/kline": 1,
                        "future/market/v1/public/q/mark-price": 1,
                        "future/market/v1/public/q/symbol-index-price": 1,
                        "future/market/v1/public/q/symbol-mark-price": 1,
                        "future/market/v1/public/q/ticker": 1,
                        "future/market/v1/public/q/tickers": 1,
                        "future/market/v1/public/symbol/coins": 3.33,
                        "future/market/v1/public/symbol/detail": 3.33,
                        "future/market/v1/public/symbol/list": 1,
                    },
                },
            },
            "private": map[string]interface{} {
                "spot": map[string]interface{} {
                    "get": map[string]interface{} {
                        "balance": 1,
                        "balances": 1,
                        "batch-order": 1,
                        "deposit/address": 1,
                        "deposit/history": 1,
                        "history-order": 1,
                        "open-order": 1,
                        "order": 1,
                        "order/{orderId}": 1,
                        "trade": 1,
                        "withdraw/history": 1,
                    },
                    "post": map[string]interface{} {
                        "order": 0.2,
                        "withdraw": 10,
                        "balance/transfer": 1,
                        "balance/account/transfer": 1,
                        "ws-token": 1,
                    },
                    "delete": map[string]interface{} {
                        "batch-order": 1,
                        "open-order": 1,
                        "order/{orderId}": 1,
                    },
                },
                "linear": map[string]interface{} {
                    "get": map[string]interface{} {
                        "future/trade/v1/entrust/plan-detail": 1,
                        "future/trade/v1/entrust/plan-list": 1,
                        "future/trade/v1/entrust/plan-list-history": 1,
                        "future/trade/v1/entrust/profit-detail": 1,
                        "future/trade/v1/entrust/profit-list": 1,
                        "future/trade/v1/order/detail": 1,
                        "future/trade/v1/order/list": 1,
                        "future/trade/v1/order/list-history": 1,
                        "future/trade/v1/order/trade-list": 1,
                        "future/user/v1/account/info": 1,
                        "future/user/v1/balance/bills": 1,
                        "future/user/v1/balance/detail": 1,
                        "future/user/v1/balance/funding-rate-list": 1,
                        "future/user/v1/balance/list": 1,
                        "future/user/v1/position/adl": 1,
                        "future/user/v1/position/list": 1,
                        "future/user/v1/user/collection/list": 1,
                        "future/user/v1/user/listen-key": 1,
                    },
                    "post": map[string]interface{} {
                        "future/trade/v1/entrust/cancel-all-plan": 1,
                        "future/trade/v1/entrust/cancel-all-profit-stop": 1,
                        "future/trade/v1/entrust/cancel-plan": 1,
                        "future/trade/v1/entrust/cancel-profit-stop": 1,
                        "future/trade/v1/entrust/create-plan": 1,
                        "future/trade/v1/entrust/create-profit": 1,
                        "future/trade/v1/entrust/update-profit-stop": 1,
                        "future/trade/v1/order/cancel": 1,
                        "future/trade/v1/order/cancel-all": 1,
                        "future/trade/v1/order/create": 1,
                        "future/trade/v1/order/create-batch": 1,
                        "future/user/v1/account/open": 1,
                        "future/user/v1/position/adjust-leverage": 1,
                        "future/user/v1/position/auto-margin": 1,
                        "future/user/v1/position/close-all": 1,
                        "future/user/v1/position/margin": 1,
                        "future/user/v1/user/collection/add": 1,
                        "future/user/v1/user/collection/cancel": 1,
                        "future/user/v1/position/change-type": 1,
                    },
                },
                "inverse": map[string]interface{} {
                    "get": map[string]interface{} {
                        "future/trade/v1/entrust/plan-detail": 1,
                        "future/trade/v1/entrust/plan-list": 1,
                        "future/trade/v1/entrust/plan-list-history": 1,
                        "future/trade/v1/entrust/profit-detail": 1,
                        "future/trade/v1/entrust/profit-list": 1,
                        "future/trade/v1/order/detail": 1,
                        "future/trade/v1/order/list": 1,
                        "future/trade/v1/order/list-history": 1,
                        "future/trade/v1/order/trade-list": 1,
                        "future/user/v1/account/info": 1,
                        "future/user/v1/balance/bills": 1,
                        "future/user/v1/balance/detail": 1,
                        "future/user/v1/balance/funding-rate-list": 1,
                        "future/user/v1/balance/list": 1,
                        "future/user/v1/position/adl": 1,
                        "future/user/v1/position/list": 1,
                        "future/user/v1/user/collection/list": 1,
                        "future/user/v1/user/listen-key": 1,
                    },
                    "post": map[string]interface{} {
                        "future/trade/v1/entrust/cancel-all-plan": 1,
                        "future/trade/v1/entrust/cancel-all-profit-stop": 1,
                        "future/trade/v1/entrust/cancel-plan": 1,
                        "future/trade/v1/entrust/cancel-profit-stop": 1,
                        "future/trade/v1/entrust/create-plan": 1,
                        "future/trade/v1/entrust/create-profit": 1,
                        "future/trade/v1/entrust/update-profit-stop": 1,
                        "future/trade/v1/order/cancel": 1,
                        "future/trade/v1/order/cancel-all": 1,
                        "future/trade/v1/order/create": 1,
                        "future/trade/v1/order/create-batch": 1,
                        "future/user/v1/account/open": 1,
                        "future/user/v1/position/adjust-leverage": 1,
                        "future/user/v1/position/auto-margin": 1,
                        "future/user/v1/position/close-all": 1,
                        "future/user/v1/position/margin": 1,
                        "future/user/v1/user/collection/add": 1,
                        "future/user/v1/user/collection/cancel": 1,
                    },
                },
                "user": map[string]interface{} {
                    "get": map[string]interface{} {
                        "user/account": 1,
                        "user/account/api-key": 1,
                    },
                    "post": map[string]interface{} {
                        "user/account": 1,
                        "user/account/api-key": 1,
                    },
                    "put": map[string]interface{} {
                        "user/account/api-key": 1,
                    },
                    "delete": map[string]interface{} {
                        "user/account/{apikeyId}": 1,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "spot": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
                "tiers": map[string]interface{} {
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0014")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("150000"), this.ParseNumber("0.0010")}, []interface{}{this.ParseNumber("300000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("600000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1200000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("6000000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("30000000"), this.ParseNumber("0.0002")}},
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0014")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("150000"), this.ParseNumber("0.0010")}, []interface{}{this.ParseNumber("300000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("600000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1200000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("6000000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("30000000"), this.ParseNumber("0.0002")}},
                },
            },
            "contract": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0004"),
                "taker": this.ParseNumber("0.0006"),
                "tiers": map[string]interface{} {
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("0.00038")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00036")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00034")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00032")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.00028")}, []interface{}{this.ParseNumber("30000000"), this.ParseNumber("0.00024")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0002")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00016")}, []interface{}{this.ParseNumber("300000000"), this.ParseNumber("0.00012")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.00008")}},
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("0.000588")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.00057")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.00054")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.00051")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.00048")}, []interface{}{this.ParseNumber("30000000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00036")}, []interface{}{this.ParseNumber("300000000"), this.ParseNumber("0.00033")}, []interface{}{this.ParseNumber("500000000"), this.ParseNumber("0.0003")}},
                },
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400": NetworkError,
                "404": ExchangeError,
                "429": RateLimitExceeded,
                "500": ExchangeError,
                "502": ExchangeError,
                "503": OnMaintenance,
                "AUTH_001": AuthenticationError,
                "AUTH_002": AuthenticationError,
                "AUTH_003": AuthenticationError,
                "AUTH_004": AuthenticationError,
                "AUTH_005": AuthenticationError,
                "AUTH_006": AuthenticationError,
                "AUTH_007": AuthenticationError,
                "AUTH_101": AuthenticationError,
                "AUTH_102": AuthenticationError,
                "AUTH_103": AuthenticationError,
                "AUTH_104": AuthenticationError,
                "AUTH_105": AuthenticationError,
                "AUTH_106": PermissionDenied,
                "SYMBOL_001": BadSymbol,
                "SYMBOL_002": BadSymbol,
                "SYMBOL_003": BadSymbol,
                "SYMBOL_004": BadSymbol,
                "SYMBOL_005": BadSymbol,
                "ORDER_001": InvalidOrder,
                "ORDER_002": InsufficientFunds,
                "ORDER_003": InvalidOrder,
                "ORDER_004": InvalidOrder,
                "ORDER_005": InvalidOrder,
                "ORDER_006": InvalidOrder,
                "ORDER_007": PermissionDenied,
                "ORDER_F0101": InvalidOrder,
                "ORDER_F0102": InvalidOrder,
                "ORDER_F0103": InvalidOrder,
                "ORDER_F0201": InvalidOrder,
                "ORDER_F0202": InvalidOrder,
                "ORDER_F0203": InvalidOrder,
                "ORDER_F0301": InvalidOrder,
                "ORDER_F0401": InvalidOrder,
                "ORDER_F0501": InvalidOrder,
                "ORDER_F0502": InvalidOrder,
                "ORDER_F0601": InvalidOrder,
                "COMMON_001": ExchangeError,
                "COMMON_002": ExchangeError,
                "COMMON_003": BadRequest,
                "CURRENCY_001": BadRequest,
                "DEPOSIT_001": BadRequest,
                "DEPOSIT_002": PermissionDenied,
                "DEPOSIT_003": BadRequest,
                "DEPOSIT_004": BadRequest,
                "DEPOSIT_005": BadRequest,
                "DEPOSIT_006": BadRequest,
                "DEPOSIT_007": BadRequest,
                "DEPOSIT_008": BadRequest,
                "WITHDRAW_001": BadRequest,
                "WITHDRAW_002": BadRequest,
                "WITHDRAW_003": PermissionDenied,
                "WITHDRAW_004": BadRequest,
                "WITHDRAW_005": BadRequest,
                "WITHDRAW_006": BadRequest,
                "WITHDRAW_008": PermissionDenied,
                "WITHDRAW_009": PermissionDenied,
                "WITHDRAW_010": BadRequest,
                "WITHDRAW_011": InsufficientFunds,
                "WITHDRAW_012": PermissionDenied,
                "WITHDRAW_013": PermissionDenied,
                "WITHDRAW_014": BadRequest,
                "WITHDRAW_015": BadRequest,
                "WITHDRAW_016": BadRequest,
                "WITHDRAW_017": BadRequest,
                "WITHDRAW_018": BadRequest,
                "WITHDRAW_019": BadRequest,
                "WITHDRAW_020": PermissionDenied,
                "WITHDRAW_021": PermissionDenied,
                "WITHDRAW_022": BadRequest,
                "WITHDRAW_023": BadRequest,
                "WITHDRAW_024": BadRequest,
                "WITHDRAW_025": BadRequest,
                "FUND_001": BadRequest,
                "FUND_002": InsufficientFunds,
                "FUND_003": BadRequest,
                "FUND_004": ExchangeError,
                "FUND_005": PermissionDenied,
                "FUND_014": BadRequest,
                "FUND_015": BadRequest,
                "FUND_016": BadRequest,
                "FUND_017": BadRequest,
                "FUND_018": BadRequest,
                "FUND_019": BadRequest,
                "FUND_020": BadRequest,
                "FUND_021": BadRequest,
                "FUND_022": BadRequest,
                "FUND_044": BadRequest,
                "TRANSFER_001": BadRequest,
                "TRANSFER_002": InsufficientFunds,
                "TRANSFER_003": BadRequest,
                "TRANSFER_004": PermissionDenied,
                "TRANSFER_005": PermissionDenied,
                "TRANSFER_006": PermissionDenied,
                "TRANSFER_007": RequestTimeout,
                "TRANSFER_008": BadRequest,
                "TRANSFER_009": BadRequest,
                "TRANSFER_010": PermissionDenied,
                "TRANSFER_011": PermissionDenied,
                "TRANSFER_012": PermissionDenied,
                "symbol_not_support_trading_via_api": BadSymbol,
                "open_order_min_nominal_value_limit": InvalidOrder,
                "insufficient_balance": InsufficientFunds,
            },
            "broad": map[string]interface{} {
                "The symbol does not support trading via API": BadSymbol,
                "Exceeds the minimum notional value of a single order": InvalidOrder,
                "insufficient balance": InsufficientFunds,
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "8h": "8h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1M",
        },
        "commonCurrencies": map[string]interface{} {},
        "options": map[string]interface{} {
            "adjustForTimeDifference": false,
            "timeDifference": 0,
            "accountsById": map[string]interface{} {
                "spot": "SPOT",
                "leverage": "LEVER",
                "finance": "FINANCE",
                "swap": "FUTURES_U",
                "future": "FUTURES_U",
                "linear": "FUTURES_U",
                "inverse": "FUTURES_C",
            },
            "networks": map[string]interface{} {
                "ERC20": "Ethereum",
                "TRC20": "Tron",
                "BEP20": "BNB Smart Chain",
                "BEP2": "BNB-BEP2",
                "ETH": "Ethereum",
                "TRON": "Tron",
                "BNB": "BNB Smart Chain",
                "AVAX": "AVAX C-Chain",
                "GAL": "GAL(FT)",
                "ALEO": "ALEO(IOU)",
                "BTC": "Bitcoin",
                "XT": "XT Smart Chain",
                "ETC": "Ethereum Classic",
                "MATIC": "Polygon",
                "LTC": "Litecoin",
                "BTS": "BitShares",
                "XRP": "Ripple",
                "XLM": "Stellar Network",
                "ADA": "Cardano",
                "XWC": "XWC-XWC",
                "DOGE": "dogecoin",
                "DCR": "Decred",
                "SC": "Siacoin",
                "XTZ": "Tezos",
                "ZEC": "Zcash",
                "XMR": "Monero",
                "LSK": "Lisk",
                "ATOM": "Cosmos",
                "ONT": "Ontology",
                "ALGO": "Algorand",
                "SOL": "SOL-SOL",
                "DOT": "Polkadot",
                "ZEN": "Horizen",
                "FIL": "Filecoin",
                "CHZ": "chz",
                "ICP": "Internet Computer",
                "KSM": "Kusama",
                "LUNA": "Terra",
                "THETA": "Theta Token",
                "FTM": "Fantom",
                "VET": "VeChain",
                "NEAR": "NEAR Protocol",
                "ONE": "Harmony",
                "KLAY": "Klaytn",
                "AR": "Arweave",
                "CELT": "OKT",
                "EGLD": "Elrond eGold",
                "CRO": "CRO-CRONOS",
                "BCH": "Bitcoin Cash",
                "GLMR": "Moonbeam",
                "LOOP": "LOOP-LRC",
                "REI": "REI Network",
                "ASTR": "Astar Network",
                "OP": "OPT",
                "MMT": "MMT-MMT",
                "TBC": "TBC-TBC",
                "OMAX": "OMAX-OMAX CHAIN",
                "GMMT": "GMMT chain",
                "ZIL": "Zilliqa",
            },
            "networksById": map[string]interface{} {
                "Ethereum": "ERC20",
                "Tron": "TRC20",
                "BNB Smart Chain": "BEP20",
                "BNB-BEP2": "BEP2",
                "Bitcoin": "BTC",
                "XT Smart Chain": "XT",
                "Ethereum Classic": "ETC",
                "Polygon": "MATIC",
                "Litecoin": "LTC",
                "BitShares": "BTS",
                "Ripple": "XRP",
                "Stellar Network": "XLM",
                "Cardano": "ADA",
                "XWC-XWC": "XWC",
                "dogecoin": "DOGE",
                "Decred": "DCR",
                "Siacoin": "SC",
                "Tezos": "XTZ",
                "Zcash": "ZEC",
                "Monero": "XMR",
                "Lisk": "LSK",
                "Cosmos": "ATOM",
                "Ontology": "ONT",
                "Algorand": "ALGO",
                "SOL-SOL": "SOL",
                "Polkadot": "DOT",
                "Horizen": "ZEN",
                "Filecoin": "FIL",
                "chz": "CHZ",
                "Internet Computer": "ICP",
                "Kusama": "KSM",
                "Terra": "LUNA",
                "Theta Token": "THETA",
                "Fantom": "FTM",
                "VeChain": "VET",
                "AVAX C-Chain": "AVAX",
                "NEAR Protocol": "NEAR",
                "Harmony": "ONE",
                "Klaytn": "KLAY",
                "Arweave": "AR",
                "OKT": "CELT",
                "Elrond eGold": "EGLD",
                "CRO-CRONOS": "CRO",
                "Bitcoin Cash": "BCH",
                "Moonbeam": "GLMR",
                "LOOP-LRC": "LOOP",
                "REI Network": "REI",
                "Astar Network": "ASTR",
                "GAL(FT)": "GAL",
                "ALEO(IOU)": "ALEO",
                "OPT": "OP",
                "MMT-MMT": "MMT",
                "TBC-TBC": "TBC",
                "OMAX-OMAX CHAIN": "OMAX",
                "GMMT chain": "GMMT",
                "Zilliqa": "ZIL",
            },
            "createMarketBuyOrderRequiresPrice": true,
            "recvWindow": "5000",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "marketType": true,
                    "subType": true,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "marketType": true,
                    "subType": true,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "trigger": true,
                    "trailing": false,
                    "marketType": true,
                    "subType": true,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": false,
                    "marketType": true,
                    "subType": true,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": false,
                    "marketType": true,
                    "subType": true,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                },
                "fetchMyTrades": map[string]interface{} {
                    "daysBack": nil,
                    "untilDays": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
        },
    })
}
func  (this *xt) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
/**
 * @method
 * @name xt#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the xt server
 * @see https://doc.xt.com/#market1serverInfo
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {int} the current integer timestamp in milliseconds from the xt server
 */
func  (this *xt) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetTime(params))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "serverTime": 1677823301643
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result")
        
            ch <- this.SafeInteger(data, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://doc.xt.com/#deposit_withdrawalsupportedCurrenciesGet
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *xt) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promisesRaw interface{} = []interface{}{this.PublicSpotGetWalletSupportCurrency(params), this.PublicSpotGetCurrencies(params)}
            chainsResponsecurrenciesResponseVariable := (<-promiseAll(promisesRaw));
            chainsResponse := GetValue(chainsResponsecurrenciesResponseVariable,0);
            currenciesResponse := GetValue(chainsResponsecurrenciesResponseVariable,1)
            //
            // currencies
            //
            //    {
            //        "time": "1686626116145",
            //        "version": "5dbbb2f2527c22b2b2e3b47187ef13d1",
            //        "currencies": [
            //            {
            //                "id": "2",
            //                "currency": "btc",
            //                "fullName": "Bitcoin",
            //                "logo": "https://a.static-global.com/1/currency/btc.png",
            //                "cmcLink": "https://coinmarketcap.com/currencies/bitcoin/",
            //                "weight": "99999",
            //                "maxPrecision": "10",
            //                "depositStatus": "1",
            //                "withdrawStatus": "1",
            //                "convertEnabled": "1",
            //                "transferEnabled": "1",
            //                "isChainExist": "1",
            //                "plates": [152]
            //            },
            //        ],
            //    }
            //
            //
            // chains
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "currency": "btc",
            //                 "supportChains": [
            //                     {
            //                         "chain": "Bitcoin",
            //                         "depositEnabled": true,
            //                         "withdrawEnabled": true,
            //                         "withdrawFeeAmount": 0.0009,
            //                         "withdrawMinAmount": 0.0005,
            //                         "depositFeeRate": 0
            //                     },
            //                 ]
            //             },
            //         ]
            //     }
            //
            // note: individual network's full data is available on per-currency endpoint: https://www.xt.com/sapi/v4/balance/public/currency/11
            //
            var chainsData interface{} = this.SafeValue(chainsResponse, "result", []interface{}{})
            var currenciesResult interface{} = this.SafeValue(currenciesResponse, "result", []interface{}{})
            var currenciesData interface{} = this.SafeValue(currenciesResult, "currencies", []interface{}{})
            var chainsDataIndexed interface{} = this.IndexBy(chainsData, "currency")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
                var entry interface{} = GetValue(currenciesData, i)
                var currencyId interface{} = this.SafeString(entry, "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var minPrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "maxPrecision")))
                var networkEntry interface{} = this.SafeValue(chainsDataIndexed, currencyId, map[string]interface{} {})
                var rawNetworks interface{} = this.SafeValue(networkEntry, "supportChains", []interface{}{})
                var networks interface{} = map[string]interface{} {}
                var minWithdrawString interface{} = nil
                var minWithdrawFeeString interface{} = nil
                var active interface{} = false
                var deposit interface{} = false
                var withdraw interface{} = false
                for j := 0; IsLessThan(j, GetArrayLength(rawNetworks)); j++ {
                    var rawNetwork interface{} = GetValue(rawNetworks, j)
                    var networkId interface{} = this.SafeString(rawNetwork, "chain")
                    var network interface{} = this.NetworkIdToCode(networkId)
                    var depositEnabled interface{} = this.SafeValue(rawNetwork, "depositEnabled")
                    deposit = Ternary(IsTrue((depositEnabled)), depositEnabled, deposit)
                    var withdrawEnabled interface{} = this.SafeValue(rawNetwork, "withdrawEnabled")
                    withdraw = Ternary(IsTrue((withdrawEnabled)), withdrawEnabled, withdraw)
                    var networkActive interface{} = IsTrue(depositEnabled) && IsTrue(withdrawEnabled)
                    active = Ternary(IsTrue((networkActive)), networkActive, active)
                    var withdrawFeeString interface{} = this.SafeString(rawNetwork, "withdrawFeeAmount")
                    if IsTrue(!IsEqual(withdrawFeeString, nil)) {
                        minWithdrawFeeString = Ternary(IsTrue((IsEqual(minWithdrawFeeString, nil))), withdrawFeeString, Precise.StringMin(withdrawFeeString, minWithdrawFeeString))
                    }
                    var minNetworkWithdrawString interface{} = this.SafeString(rawNetwork, "withdrawMinAmount")
                    if IsTrue(!IsEqual(minNetworkWithdrawString, nil)) {
                        minWithdrawString = Ternary(IsTrue((IsEqual(minWithdrawString, nil))), minNetworkWithdrawString, Precise.StringMin(minNetworkWithdrawString, minWithdrawString))
                    }
                    AddElementToObject(networks, network, map[string]interface{} {
            "info": rawNetwork,
            "id": networkId,
            "network": network,
            "name": nil,
            "active": networkActive,
            "fee": this.ParseNumber(withdrawFeeString),
            "precision": minPrecision,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minNetworkWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "id": currencyId,
            "code": code,
            "name": this.SafeString(entry, "fullName"),
            "active": active,
            "fee": this.ParseNumber(minWithdrawFeeString),
            "precision": minPrecision,
            "deposit": deposit,
            "withdraw": withdraw,
            "networks": networks,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdrawString),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchMarkets
 * @description retrieves data on all markets for xt
 * @see https://doc.xt.com/#market2symbol
 * @see https://doc.xt.com/#futures_quotesgetSymbols
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *xt) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes99312 := (<-this.LoadTimeDifference())
                PanicOnError(retRes99312)
            }
            var promisesUnresolved interface{} = []interface{}{this.FetchSpotMarkets(params), this.FetchSwapAndFutureMarkets(params)}
        
            promises:= (<-promiseAll(promisesUnresolved))
            PanicOnError(promises)
            var spotMarkets interface{} = GetValue(promises, 0)
            var swapAndFutureMarkets interface{} = GetValue(promises, 1)
        
            ch <- this.ArrayConcat(spotMarkets, swapAndFutureMarkets)
            return nil
        
            }()
            return ch
        }
func  (this *xt) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetSymbol(params))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "time": 1677881368812,
            //             "version": "abb101d1543e54bee40687b135411ba0",
            //             "symbols": [
            //                 {
            //                     "id": 640,
            //                     "symbol": "xt_usdt",
            //                     "state": "ONLINE",
            //                     "stateTime": 1554048000000,
            //                     "tradingEnabled": true,
            //                     "openapiEnabled": true,
            //                     "nextStateTime": null,
            //                     "nextState": null,
            //                     "depthMergePrecision": 5,
            //                     "baseCurrency": "xt",
            //                     "baseCurrencyPrecision": 8,
            //                     "baseCurrencyId": 128,
            //                     "quoteCurrency": "usdt",
            //                     "quoteCurrencyPrecision": 8,
            //                     "quoteCurrencyId": 11,
            //                     "pricePrecision": 4,
            //                     "quantityPrecision": 2,
            //                     "orderTypes": ["LIMIT","MARKET"],
            //                     "timeInForces": ["GTC","IOC"],
            //                     "displayWeight": 10002,
            //                     "displayLevel": "FULL",
            //                     "plates": [],
            //                     "filters":[
            //                         {
            //                             "filter": "QUOTE_QTY",
            //                             "min": "1"
            //                         },
            //                         {
            //                             "filter": "PROTECTION_LIMIT",
            //                             "buyMaxDeviation": "0.8",
            //                             "sellMaxDeviation": "4"
            //                         },
            //                         {
            //                             "filter": "PROTECTION_MARKET",
            //                             "maxDeviation": "0.02"
            //                         }
            //                     ]
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var symbols interface{} = this.SafeValue(data, "symbols", []interface{}{})
        
            ch <- this.ParseMarkets(symbols)
            return nil
        
            }()
            return ch
        }
func  (this *xt) FetchSwapAndFutureMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            markets:= (<-promiseAll([]interface{}{this.PublicLinearGetFutureMarketV1PublicSymbolList(params), this.PublicInverseGetFutureMarketV1PublicSymbolList(params)}))
            PanicOnError(markets)
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "id": 52,
            //                 "symbolGroupId": 71,
            //                 "symbol": "xt_usdt",
            //                 "pair": "xt_usdt",
            //                 "contractType": "PERPETUAL",
            //                 "productType": "perpetual",
            //                 "predictEventType": null,
            //                 "underlyingType": "U_BASED",
            //                 "contractSize": "1",
            //                 "tradeSwitch": true,
            //                 "isDisplay": true,
            //                 "isOpenApi": false,
            //                 "state": 0,
            //                 "initLeverage": 20,
            //                 "initPositionType": "CROSSED",
            //                 "baseCoin": "xt",
            //                 "quoteCoin": "usdt",
            //                 "baseCoinPrecision": 8,
            //                 "baseCoinDisplayPrecision": 4,
            //                 "quoteCoinPrecision": 8,
            //                 "quoteCoinDisplayPrecision": 4,
            //                 "quantityPrecision": 0,
            //                 "pricePrecision": 4,
            //                 "supportOrderType": "LIMIT,MARKET",
            //                 "supportTimeInForce": "GTC,FOK,IOC,GTX",
            //                 "supportEntrustType": "TAKE_PROFIT,STOP,TAKE_PROFIT_MARKET,STOP_MARKET,TRAILING_STOP_MARKET",
            //                 "supportPositionType": "CROSSED,ISOLATED",
            //                 "minQty": "1",
            //                 "minNotional": "5",
            //                 "maxNotional": "20000000",
            //                 "multiplierDown": "0.1",
            //                 "multiplierUp": "0.1",
            //                 "maxOpenOrders": 200,
            //                 "maxEntrusts": 200,
            //                 "makerFee": "0.0004",
            //                 "takerFee": "0.0006",
            //                 "liquidationFee": "0.01",
            //                 "marketTakeBound": "0.1",
            //                 "depthPrecisionMerge": 5,
            //                 "labels": ["HOT"],
            //                 "onboardDate": 1657101601000,
            //                 "enName": "XTUSDT ",
            //                 "cnName": "XTUSDT",
            //                 "minStepPrice": "0.0001",
            //                 "minPrice": null,
            //                 "maxPrice": null,
            //                 "deliveryDate": 1669879634000,
            //                 "deliveryPrice": null,
            //                 "deliveryCompletion": false,
            //                 "cnDesc": null,
            //                 "enDesc": null
            //             },
            //         ]
            //     }
            //
            var swapAndFutureMarkets interface{} = this.ArrayConcat(this.SafeValue(GetValue(markets, 0), "result", []interface{}{}), this.SafeValue(GetValue(markets, 1), "result", []interface{}{}))
        
            ch <- this.ParseMarkets(swapAndFutureMarkets)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseMarkets(markets interface{}) interface{}  {
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
        AppendToArray(&result,this.ParseMarket(GetValue(markets, i)))
    }
    return result
}
func  (this *xt) ParseMarket(market interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "id": 640,
    //         "symbol": "xt_usdt",
    //         "state": "ONLINE",
    //         "stateTime": 1554048000000,
    //         "tradingEnabled": true,
    //         "openapiEnabled": true,
    //         "nextStateTime": null,
    //         "nextState": null,
    //         "depthMergePrecision": 5,
    //         "baseCurrency": "xt",
    //         "baseCurrencyPrecision": 8,
    //         "baseCurrencyId": 128,
    //         "quoteCurrency": "usdt",
    //         "quoteCurrencyPrecision": 8,
    //         "quoteCurrencyId": 11,
    //         "pricePrecision": 4,
    //         "quantityPrecision": 2,
    //         "orderTypes": ["LIMIT","MARKET"],
    //         "timeInForces": ["GTC","IOC"],
    //         "displayWeight": 10002,
    //         "displayLevel": "FULL",
    //         "plates": [],
    //         "filters":[
    //             {
    //                 "filter": "QUOTE_QTY",
    //                 "min": "1"
    //             },
    //             {
    //                 "filter": "PRICE",
    //                 "min": null,
    //                 "max": null,
    //                 "tickSize": null
    //             },
    //             {
    //                 "filter": "QUANTITY",
    //                 "min": null,
    //                 "max": null,
    //                 "tickSize": null
    //             },
    //             {
    //                 "filter": "PROTECTION_LIMIT",
    //                 "buyMaxDeviation": "0.8",
    //                 "sellMaxDeviation": "4"
    //             },
    //             {
    //                 "filter": "PROTECTION_MARKET",
    //                 "maxDeviation": "0.02"
    //             },
    //             {
    //                  "filter": "PROTECTION_ONLINE",
    //                  "durationSeconds": "300",
    //                  "maxPriceMultiple": "5"
    //             },
    //         ]
    //     }
    //
    // swap and future
    //
    //     {
    //         "id": 52,
    //         "symbolGroupId": 71,
    //         "symbol": "xt_usdt",
    //         "pair": "xt_usdt",
    //         "contractType": "PERPETUAL",
    //         "productType": "perpetual",
    //         "predictEventType": null,
    //         "underlyingType": "U_BASED",
    //         "contractSize": "1",
    //         "tradeSwitch": true,
    //         "isDisplay": true,
    //         "isOpenApi": false,
    //         "state": 0,
    //         "initLeverage": 20,
    //         "initPositionType": "CROSSED",
    //         "baseCoin": "xt",
    //         "quoteCoin": "usdt",
    //         "baseCoinPrecision": 8,
    //         "baseCoinDisplayPrecision": 4,
    //         "quoteCoinPrecision": 8,
    //         "quoteCoinDisplayPrecision": 4,
    //         "quantityPrecision": 0,
    //         "pricePrecision": 4,
    //         "supportOrderType": "LIMIT,MARKET",
    //         "supportTimeInForce": "GTC,FOK,IOC,GTX",
    //         "supportEntrustType": "TAKE_PROFIT,STOP,TAKE_PROFIT_MARKET,STOP_MARKET,TRAILING_STOP_MARKET",
    //         "supportPositionType": "CROSSED,ISOLATED",
    //         "minQty": "1",
    //         "minNotional": "5",
    //         "maxNotional": "20000000",
    //         "multiplierDown": "0.1",
    //         "multiplierUp": "0.1",
    //         "maxOpenOrders": 200,
    //         "maxEntrusts": 200,
    //         "makerFee": "0.0004",
    //         "takerFee": "0.0006",
    //         "liquidationFee": "0.01",
    //         "marketTakeBound": "0.1",
    //         "depthPrecisionMerge": 5,
    //         "labels": ["HOT"],
    //         "onboardDate": 1657101601000,
    //         "enName": "XTUSDT ",
    //         "cnName": "XTUSDT",
    //         "minStepPrice": "0.0001",
    //         "minPrice": null,
    //         "maxPrice": null,
    //         "deliveryDate": 1669879634000,
    //         "deliveryPrice": null,
    //         "deliveryCompletion": false,
    //         "cnDesc": null,
    //         "enDesc": null
    //     }
    //
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString2(market, "baseCurrency", "baseCoin")
    var quoteId interface{} = this.SafeString2(market, "quoteCurrency", "quoteCoin")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var state interface{} = this.SafeString(market, "state")
    var symbol interface{} = Add(Add(base, "/"), quote)
    var filters interface{} = this.SafeValue(market, "filters", []interface{}{})
    var minAmount interface{} = nil
    var maxAmount interface{} = nil
    var minCost interface{} = nil
    var maxCost interface{} = nil
    var minPrice interface{} = nil
    var maxPrice interface{} = nil
    var amountPrecision interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(filters)); i++ {
        var entry interface{} = GetValue(filters, i)
        var filter interface{} = this.SafeString(entry, "filter")
        if IsTrue(IsEqual(filter, "QUANTITY")) {
            minAmount = this.SafeNumber(entry, "min")
            maxAmount = this.SafeNumber(entry, "max")
            amountPrecision = this.SafeNumber(entry, "tickSize")
        }
        if IsTrue(IsEqual(filter, "QUOTE_QTY")) {
            minCost = this.SafeNumber(entry, "min")
        }
        if IsTrue(IsEqual(filter, "PRICE")) {
            minPrice = this.SafeNumber(entry, "min")
            maxPrice = this.SafeNumber(entry, "max")
        }
    }
    if IsTrue(IsEqual(amountPrecision, nil)) {
        amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision")))
    }
    var underlyingType interface{} = this.SafeString(market, "underlyingType")
    var linear interface{} = nil
    var inverse interface{} = nil
    var settleId interface{} = nil
    var settle interface{} = nil
    var expiry interface{} = nil
    var future interface{} = false
    var swap interface{} = false
    var contract interface{} = false
    var spot interface{} = true
    var typeVar interface{} = "spot"
    if IsTrue(IsEqual(underlyingType, "U_BASED")) {
        symbol = Add(Add(symbol, ":"), quote)
        settleId = baseId
        settle = quote
        linear = true
        inverse = false
    } else if IsTrue(IsEqual(underlyingType, "COIN_BASED")) {
        symbol = Add(Add(symbol, ":"), base)
        settleId = baseId
        settle = base
        linear = false
        inverse = true
    }
    if IsTrue(!IsEqual(underlyingType, nil)) {
        expiry = this.SafeInteger(market, "deliveryDate")
        var productType interface{} = this.SafeString(market, "productType")
        if IsTrue(!IsEqual(productType, "perpetual")) {
            symbol = Add(Add(symbol, "-"), this.Yymmdd(expiry))
            typeVar = "future"
            future = true
        } else {
            typeVar = "swap"
            swap = true
        }
        minAmount = this.SafeNumber(market, "minQty")
        minCost = this.SafeNumber(market, "minNotional")
        maxCost = this.SafeNumber(market, "maxNotional")
        minPrice = this.SafeNumber(market, "minPrice")
        maxPrice = this.SafeNumber(market, "maxPrice")
        contract = true
        spot = false
    }
    var isActive interface{} = false
    if IsTrue(contract) {
        isActive = this.SafeValue(market, "isOpenApi", false)
    } else {
        if IsTrue(IsTrue(IsTrue((IsEqual(state, "ONLINE"))) && IsTrue((this.SafeValue(market, "tradingEnabled")))) && IsTrue((this.SafeValue(market, "openapiEnabled")))) {
            isActive = true
        }
    }
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": typeVar,
        "spot": spot,
        "margin": nil,
        "swap": swap,
        "future": future,
        "option": false,
        "active": isActive,
        "contract": contract,
        "linear": linear,
        "inverse": inverse,
        "taker": this.SafeNumber(market, "takerFee"),
        "maker": this.SafeNumber(market, "makerFee"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "expiry": expiry,
        "expiryDatetime": this.Iso8601(expiry),
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision"))),
            "amount": amountPrecision,
            "base": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseCoinPrecision"))),
            "quote": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quoteCoinPrecision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": this.ParseNumber("1"),
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": minAmount,
                "max": maxAmount,
            },
            "price": map[string]interface{} {
                "min": minPrice,
                "max": maxPrice,
            },
            "cost": map[string]interface{} {
                "min": minCost,
                "max": maxCost,
            },
        },
        "info": market,
    })
}
/**
 * @method
 * @name xt#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://doc.xt.com/#market4kline
 * @see https://doc.xt.com/#futures_quotesgetKLine
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *xt) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14128 := (<-this.LoadMarkets())
            PanicOnError(retRes14128)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes141619 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1000))
                    PanicOnError(retRes141619)
                    ch <- retRes141619
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            } else {
                AddElementToObject(request, "limit", 1000)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "linear")) {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicQKline(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicQKline(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicSpotGetKline(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "t": 1678167720000,
            //                 "o": "22467.85",
            //                 "c": "22465.87",
            //                 "h": "22468.86",
            //                 "l": "22465.21",
            //                 "q": "1.316656",
            //                 "v": "29582.73018498"
            //             },
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "s": "btc_usdt",
            //                 "p": "btc_usdt",
            //                 "t": 1678168020000,
            //                 "o": "22450.0",
            //                 "c": "22441.5",
            //                 "h": "22450.0",
            //                 "l": "22441.5",
            //                 "a": "312931",
            //                 "v": "702461.58895"
            //             },
            //         ]
            //     }
            //
            var ohlcvs interface{} = this.SafeValue(response, "result", []interface{}{})
        
            ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "t": 1678167720000,
    //         "o": "22467.85",
    //         "c": "22465.87",
    //         "h": "22468.86",
    //         "l": "22465.21",
    //         "q": "1.316656",
    //         "v": "29582.73018498"
    //     }
    //
    // swap and future
    //
    //     {
    //         "s": "btc_usdt",
    //         "p": "btc_usdt",
    //         "t": 1678168020000,
    //         "o": "22450.0",
    //         "c": "22441.5",
    //         "h": "22450.0",
    //         "l": "22441.5",
    //         "a": "312931",
    //         "v": "702461.58895"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var volumeIndex interface{} = Ternary(IsTrue((GetValue(market, "inverse"))), "v", "a")
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber2(ohlcv, "q", volumeIndex)}
}
/**
 * @method
 * @name xt#fetchOrderBook
 * @see https://doc.xt.com/#market3depth
 * @see https://doc.xt.com/#futures_quotesgetDepth
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified market symbol to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
 */
func  (this *xt) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15408 := (<-this.LoadMarkets())
            PanicOnError(retRes15408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", mathMin(limit, 500))
                }
                
        response = (<-this.PublicSpotGetDepth(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "level", mathMin(limit, 50))
                } else {
                    AddElementToObject(request, "level", 50)
                }
                if IsTrue(GetValue(market, "linear")) {
                    
        response = (<-this.PublicLinearGetFutureMarketV1PublicQDepth(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(GetValue(market, "inverse")) {
                    
        response = (<-this.PublicInverseGetFutureMarketV1PublicQDepth(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "timestamp": 1678169975184,
            //             "lastUpdateId": 1675333221812,
            //             "bids": [
            //                 ["22444.51", "0.129887"],
            //                 ["22444.49", "0.114245"],
            //                 ["22444.30", "0.225956"]
            //             ],
            //             "asks": [
            //                 ["22446.19", "0.095330"],
            //                 ["22446.24", "0.224413"],
            //                 ["22446.28", "0.329095"]
            //             ]
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "t": 1678170311005,
            //             "s": "btc_usdt",
            //             "u": 471694545627,
            //             "b": [
            //                 ["22426", "198623"],
            //                 ["22423.5", "80295"],
            //                 ["22423", "163580"]
            //             ],
            //             "a": [
            //                 ["22427", "3417"],
            //                 ["22428.5", "43532"],
            //                 ["22429", "119"]
            //             ]
            //         }
            //     }
            //
            var orderBook interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger2(orderBook, "timestamp", "t")
            if IsTrue(GetValue(market, "spot")) {
                var ob interface{} = this.ParseOrderBook(orderBook, symbol, timestamp)
                AddElementToObject(ob, "nonce", this.SafeInteger(orderBook, "lastUpdateId"))
        
                ch <- ob
                return nil
            }
            var swapOb interface{} = this.ParseOrderBook(orderBook, symbol, timestamp, "b", "a")
            AddElementToObject(swapOb, "nonce", this.SafeInteger2(orderBook, "u", "lastUpdateId"))
        
            ch <- swapOb
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.xt.com/#market10ticker24h
 * @see https://doc.xt.com/#futures_quotesgetAggTicker
 * @param {string} symbol unified market symbol to fetch the ticker for
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *xt) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16328 := (<-this.LoadMarkets())
            PanicOnError(retRes16328)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "linear")) {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicQAggTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicQAggTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicSpotGetTicker24h(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "s": "btc_usdt",
            //                 "t": 1678172693931,
            //                 "cv": "34.00",
            //                 "cr": "0.0015",
            //                 "o": "22398.05",
            //                 "l": "22323.72",
            //                 "h": "22600.50",
            //                 "c": "22432.05",
            //                 "q": "7962.256931",
            //                 "v": "178675209.47416856"
            //             }
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "t": 1678172848572,
            //             "s": "btc_usdt",
            //             "c": "22415.5",
            //             "h": "22590.0",
            //             "l": "22310.0",
            //             "a": "623654031",
            //             "v": "1399166074.31675",
            //             "o": "22381.5",
            //             "r": "0.0015",
            //             "i": "22424.5",
            //             "m": "22416.5",
            //             "bp": "22415",
            //             "ap": "22415.5"
            //         }
            //     }
            //
            var ticker interface{} = this.SafeValue(response, "result")
            if IsTrue(GetValue(market, "spot")) {
        
                ch <- this.ParseTicker(GetValue(ticker, 0), market)
                return nil
            }
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchTickers
 * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
 * @see https://doc.xt.com/#market10ticker24h
 * @see https://doc.xt.com/#futures_quotesgetAggTickers
 * @param {string} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *xt) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17098 := (<-this.LoadMarkets())
            PanicOnError(retRes17098)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
                market = this.Market(GetValue(symbols, 0))
            }
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchTickers", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicQAggTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicQAggTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicSpotGetTicker24h(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "s": "btc_usdt",
            //                 "t": 1678172693931,
            //                 "cv": "34.00",
            //                 "cr": "0.0015",
            //                 "o": "22398.05",
            //                 "l": "22323.72",
            //                 "h": "22600.50",
            //                 "c": "22432.05",
            //                 "q": "7962.256931",
            //                 "v": "178675209.47416856"
            //             }
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "t": 1680738775108,
            //                 "s": "badger_usdt",
            //                 "c": "2.7176",
            //                 "h": "2.7917",
            //                 "l": "2.6818",
            //                 "a": "88332",
            //                 "v": "242286.3520",
            //                 "o": "2.7422",
            //                 "r": "-0.0089",
            //                 "i": "2.7155",
            //                 "m": "2.7161",
            //                 "bp": "2.7152",
            //                 "ap": "2.7176"
            //             },
            //         ]
            //     }
            //
            var tickers interface{} = this.SafeValue(response, "result", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i), market)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArray(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://doc.xt.com/#market9tickerBook
 * @param {string} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *xt) FetchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17968 := (<-this.LoadMarkets())
            PanicOnError(retRes17968)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                market = this.Market(GetValue(symbols, 0))
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchBidsAsks", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(!IsEqual(subType, nil)) {
                panic(NotSupported(Add(this.Id, " fetchBidsAsks() is not available for swap and future markets, only spot markets are supported")))
            }
        
            response:= (<-this.PublicSpotGetTickerBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "s": "kas_usdt",
            //                 "t": 1679539891853,
            //                 "ap": "0.016298",
            //                 "aq": "5119.09",
            //                 "bp": "0.016290",
            //                 "bq": "135.37"
            //             },
            //         ]
            //     }
            //
            var tickers interface{} = this.SafeValue(response, "result", []interface{}{})
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTicker, fetchTickers
    //
    //     {
    //         "s": "btc_usdt",
    //         "t": 1678172693931,
    //         "cv": "34.00",
    //         "cr": "0.0015",
    //         "o": "22398.05",
    //         "l": "22323.72",
    //         "h": "22600.50",
    //         "c": "22432.05",
    //         "q": "7962.256931",
    //         "v": "178675209.47416856"
    //     }
    //
    // swap and future: fetchTicker, fetchTickers
    //
    //     {
    //         "t": 1678172848572,
    //         "s": "btc_usdt",
    //         "c": "22415.5",
    //         "h": "22590.0",
    //         "l": "22310.0",
    //         "a": "623654031",
    //         "v": "1399166074.31675",
    //         "o": "22381.5",
    //         "r": "0.0015",
    //         "i": "22424.5",
    //         "m": "22416.5",
    //         "bp": "22415",
    //         "ap": "22415.5"
    //     }
    //
    // fetchBidsAsks
    //
    //     {
    //         "s": "kas_usdt",
    //         "t": 1679539891853,
    //         "ap": "0.016298",
    //         "aq": "5119.09",
    //         "bp": "0.016290",
    //         "bq": "135.37"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "s")
    var marketType interface{} = Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "type"), nil)
    var hasSpotKeys interface{} = IsTrue((InOp(ticker, "cv"))) || IsTrue((InOp(ticker, "aq")))
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = Ternary(IsTrue(hasSpotKeys), "spot", "contract")
    }
    market = this.SafeMarket(marketId, market, "_", marketType)
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var percentage interface{} = this.SafeString2(ticker, "cr", "r")
    if IsTrue(!IsEqual(percentage, nil)) {
        percentage = Precise.StringMul(percentage, "100")
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "h"),
        "low": this.SafeNumber(ticker, "l"),
        "bid": this.SafeNumber(ticker, "bp"),
        "bidVolume": this.SafeNumber(ticker, "bq"),
        "ask": this.SafeNumber(ticker, "ap"),
        "askVolume": this.SafeNumber(ticker, "aq"),
        "vwap": nil,
        "open": this.SafeString(ticker, "o"),
        "close": this.SafeString(ticker, "c"),
        "last": this.SafeString(ticker, "c"),
        "previousClose": nil,
        "change": this.SafeNumber(ticker, "cv"),
        "percentage": this.ParseNumber(percentage),
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeNumber2(ticker, "a", "v"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name xt#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://doc.xt.com/#market5tradeRecent
 * @see https://doc.xt.com/#futures_quotesgetDeal
 * @param {string} symbol unified market symbol to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
 */
func  (this *xt) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes19268 := (<-this.LoadMarkets())
            PanicOnError(retRes19268)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.PublicSpotGetTradeRecent(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "num", limit)
                }
                if IsTrue(GetValue(market, "linear")) {
                    
        response = (<-this.PublicLinearGetFutureMarketV1PublicQDeal(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(GetValue(market, "inverse")) {
                    
        response = (<-this.PublicInverseGetFutureMarketV1PublicQDeal(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "i": 203530723141917063,
            //                 "t": 1678227505815,
            //                 "p": "22038.81",
            //                 "q": "0.000978",
            //                 "v": "21.55395618",
            //                 "b": true
            //             },
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "t": 1678227683897,
            //                 "s": "btc_usdt",
            //                 "p": "22031",
            //                 "a": "1067",
            //                 "m": "BID"
            //             },
            //         ]
            //     }
            //
            var trades interface{} = this.SafeValue(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(trades, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://doc.xt.com/#tradetradeGet
 * @see https://doc.xt.com/#futures_ordergetTrades
 * @param {string} [symbol] unified market symbol to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
 */
func  (this *xt) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20008 := (<-this.LoadMarkets())
            PanicOnError(retRes20008)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMyTrades", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(IsTrue(IsTrue((!IsEqual(subType, nil))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "size", limit)
                }
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1OrderTradeList(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1OrderTradeList(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                var marginOrSpotRequest interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), "LEVER", "SPOT")
                AddElementToObject(request, "bizType", marginOrSpotRequest)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.PrivateSpotGetTrade(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot and margin
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "symbol": "btc_usdt",
            //                     "tradeId": "206906233569974658",
            //                     "orderId": "206906233178463488",
            //                     "orderSide": "SELL",
            //                     "orderType": "MARKET",
            //                     "bizType": "SPOT",
            //                     "time": 1679032290215,
            //                     "price": "25703.46",
            //                     "quantity": "0.000099",
            //                     "quoteQty": "2.54464254",
            //                     "baseCurrency": "btc",
            //                     "quoteCurrency": "usdt",
            //                     "fee": "0.00508929",
            //                     "feeCurrency": "usdt",
            //                     "takerMaker": "TAKER"
            //                 },
            //             ]
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "page": 1,
            //             "ps": 10,
            //             "total": 2,
            //             "items": [
            //                 {
            //                     "orderId": "207260566170987200",
            //                     "execId": "207260566790603265",
            //                     "symbol": "btc_usdt",
            //                     "quantity": "13",
            //                     "price": "27368",
            //                     "fee": "0.02134704",
            //                     "feeCoin": "usdt",
            //                     "timestamp": 1679116769838,
            //                     "takerMaker": "TAKER"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var trades interface{} = this.SafeValue(data, "items", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTrades
    //
    //     {
    //         "i": 203530723141917063,
    //         "t": 1678227505815,
    //         "p": "22038.81",
    //         "q": "0.000978",
    //         "v": "21.55395618",
    //         "b": true
    //     }
    //
    // spot: watchTrades
    //
    //    {
    //        s: 'btc_usdt',
    //        i: '228825383103928709',
    //        t: 1684258222702,
    //        p: '27003.65',
    //        q: '0.000796',
    //        b: true
    //    }
    //
    // spot: watchMyTrades
    //
    //    {
    //        "s": "btc_usdt",                // symbol
    //        "t": 1656043204763,             // time
    //        "i": "6316559590087251233",     // tradeId
    //        "oi": "6216559590087220004",    // orderId
    //        "p": "30000",                   // trade price
    //        "q": "3",                       // qty quantity
    //        "v": "90000"                    // volume trade amount
    //    }
    //
    // swap and future: fetchTrades
    //
    //     {
    //         "t": 1678227683897,
    //         "s": "btc_usdt",
    //         "p": "22031",
    //         "a": "1067",
    //         "m": "BID"
    //     }
    //
    // spot: fetchMyTrades
    //
    //     {
    //         "symbol": "btc_usdt",
    //         "tradeId": "206906233569974658",
    //         "orderId": "206906233178463488",
    //         "orderSide": "SELL",
    //         "orderType": "MARKET",
    //         "bizType": "SPOT",
    //         "time": 1679032290215,
    //         "price": "25703.46",
    //         "quantity": "0.000099",
    //         "quoteQty": "2.54464254",
    //         "baseCurrency": "btc",
    //         "quoteCurrency": "usdt",
    //         "fee": "0.00508929",
    //         "feeCurrency": "usdt",
    //         "takerMaker": "TAKER"
    //     }
    //
    // swap and future: fetchMyTrades
    //
    //     {
    //         "orderId": "207260566170987200",
    //         "execId": "207260566790603265",
    //         "symbol": "btc_usdt",
    //         "quantity": "13",
    //         "price": "27368",
    //         "fee": "0.02134704",
    //         "feeCoin": "usdt",
    //         "timestamp": 1679116769838,
    //         "takerMaker": "TAKER"
    //     }
    //
    // contract watchMyTrades
    //
    //    {
    //        "symbol": 'btc_usdt',
    //        "orderSide": 'SELL',
    //        "positionSide": 'LONG',
    //        "orderId": '231485367663419328',
    //        "price": '27152.7',
    //        "quantity": '33',
    //        "marginUnfrozen": '2.85318000',
    //        "timestamp": 1684892412565
    //    }
    //
    // watchMyTrades (ws, swap)
    //
    //    {
    //        'fee': '0.04080840',
    //        'isMaker': False,
    //        'marginUnfrozen': '0.75711984',
    //        'orderId': '376172779053188416',
    //        'orderSide': 'BUY',
    //        'positionSide': 'LONG',
    //        'price': '3400.70',
    //        'quantity': '2',
    //        'symbol': 'eth_usdt',
    //        'timestamp': 1719388579622
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(trade, "s", "symbol")
    var marketType interface{} = Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "type"), nil)
    var hasSpotKeys interface{} = IsTrue(IsTrue((InOp(trade, "b"))) || IsTrue((InOp(trade, "bizType")))) || IsTrue((InOp(trade, "oi")))
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = Ternary(IsTrue(hasSpotKeys), "spot", "contract")
    }
    market = this.SafeMarket(marketId, market, "_", marketType)
    var side interface{} = nil
    var takerOrMaker interface{} = nil
    var isBuyerMaker interface{} = this.SafeBool(trade, "b")
    if IsTrue(!IsEqual(isBuyerMaker, nil)) {
        side = Ternary(IsTrue(isBuyerMaker), "sell", "buy")
        takerOrMaker = "taker" // public trades always taker
    } else {
        var takerMaker interface{} = this.SafeStringLower(trade, "takerMaker")
        if IsTrue(!IsEqual(takerMaker, nil)) {
            takerOrMaker = takerMaker
        } else {
            var isMaker interface{} = this.SafeBool(trade, "isMaker")
            if IsTrue(!IsEqual(isMaker, nil)) {
                takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
            }
        }
        var orderSide interface{} = this.SafeStringLower(trade, "orderSide")
        if IsTrue(!IsEqual(orderSide, nil)) {
            side = orderSide
        } else {
            var bidOrAsk interface{} = this.SafeString(trade, "m")
            if IsTrue(!IsEqual(bidOrAsk, nil)) {
                side = Ternary(IsTrue((IsEqual(bidOrAsk, "BID"))), "buy", "sell")
            }
        }
    }
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"t", "time", "timestamp"})
    var quantity interface{} = this.SafeString2(trade, "q", "quantity")
    var amount interface{} = nil
    if IsTrue(IsEqual(marketType, "spot")) {
        amount = quantity
    } else {
        if IsTrue(IsEqual(quantity, nil)) {
            amount = Precise.StringMul(this.SafeString(trade, "a"), this.NumberToString(GetValue(market, "contractSize")))
        } else {
            amount = Precise.StringMul(quantity, this.NumberToString(GetValue(market, "contractSize")))
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeStringN(trade, []interface{}{"i", "tradeId", "execId"}),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": this.SafeString2(trade, "orderId", "oi"),
        "type": this.SafeStringLower(trade, "orderType"),
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": this.SafeString2(trade, "p", "price"),
        "amount": amount,
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(this.SafeString2(trade, "feeCurrency", "feeCoin")),
            "cost": this.SafeString(trade, "fee"),
        },
    }, market)
}
/**
 * @method
 * @name xt#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://doc.xt.com/#balancebalancesGet
 * @see https://doc.xt.com/#futures_usergetBalances
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
 */
func  (this *xt) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22808 := (<-this.LoadMarkets())
            PanicOnError(retRes22808)
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchBalance", nil, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var isContractWallet interface{} =     (IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future"))))
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureUserV1BalanceList(params))
                PanicOnError(response)
            } else if IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue(isContractWallet)) {
                
        response = (<-this.PrivateLinearGetFutureUserV1BalanceList(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateSpotGetBalances(params))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "totalUsdtAmount": "31.75931133",
            //             "totalBtcAmount": "0.00115951",
            //             "assets": [
            //                 {
            //                     "currency": "usdt",
            //                     "currencyId": 11,
            //                     "frozenAmount": "0.03834082",
            //                     "availableAmount": "31.70995965",
            //                     "totalAmount": "31.74830047",
            //                     "convertBtcAmount": "0.00115911",
            //                     "convertUsdtAmount": "31.74830047"
            //                 },
            //             ]
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "coin": "usdt",
            //                 "walletBalance": "19.29849875",
            //                 "openOrderMarginFrozen": "0",
            //                 "isolatedMargin": "0.709475",
            //                 "crossedMargin": "0",
            //                 "availableBalance": "18.58902375",
            //                 "bonus": "0",
            //                 "coupon":"0"
            //             }
            //         ]
            //     }
            //
            var balances interface{} = nil
            if IsTrue(IsTrue((!IsEqual(subType, nil))) || IsTrue(isContractWallet)) {
                balances = this.SafeValue(response, "result", []interface{}{})
            } else {
                var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
                balances = this.SafeValue(data, "assets", []interface{}{})
            }
        
            ch <- this.ParseBalance(balances)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseBalance(response interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "currency": "usdt",
    //         "currencyId": 11,
    //         "frozenAmount": "0.03834082",
    //         "availableAmount": "31.70995965",
    //         "totalAmount": "31.74830047",
    //         "convertBtcAmount": "0.00115911",
    //         "convertUsdtAmount": "31.74830047"
    //     }
    //
    // swap and future
    //
    //     {
    //         "coin": "usdt",
    //         "walletBalance": "19.29849875",
    //         "openOrderMarginFrozen": "0",
    //         "isolatedMargin": "0.709475",
    //         "crossedMargin": "0",
    //         "availableBalance": "18.58902375",
    //         "bonus": "0",
    //         "coupon":"0"
    //     }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString2(balance, "currency", "coin")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var free interface{} = this.SafeString2(balance, "availableAmount", "availableBalance")
        var used interface{} = this.SafeString(balance, "frozenAmount")
        var total interface{} = this.SafeString2(balance, "totalAmount", "walletBalance")
        if IsTrue(IsEqual(used, nil)) {
            var crossedAndIsolatedMargin interface{} = Precise.StringAdd(this.SafeString(balance, "crossedMargin"), this.SafeString(balance, "isolatedMargin"))
            used = Precise.StringAdd(this.SafeString(balance, "openOrderMarginFrozen"), crossedAndIsolatedMargin)
        }
        AddElementToObject(account, "free", free)
        AddElementToObject(account, "used", used)
        AddElementToObject(account, "total", total)
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name xt#createMarketBuyOrderWithCost
 * @see https://doc.xt.com/#orderorderPost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *xt) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24078 := (<-this.LoadMarkets())
            PanicOnError(retRes24078)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
        
                retRes241215 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, 1, params))
                PanicOnError(retRes241215)
                ch <- retRes241215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#createOrder
 * @description create a trade order
 * @see https://doc.xt.com/#orderorderPost
 * @see https://doc.xt.com/#futures_ordercreate
 * @see https://doc.xt.com/#futures_entrustcreatePlan
 * @see https://doc.xt.com/#futures_entrustcreateProfit
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price to fulfill the order, in units of the quote currency, can be ignored in market orders
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'GTX'
 * @param {string} [params.entrustType] 'TAKE_PROFIT', 'STOP', 'TAKE_PROFIT_MARKET', 'STOP_MARKET', 'TRAILING_STOP_MARKET', required if stopPrice is defined, currently isn't functioning on xt's side
 * @param {string} [params.triggerPriceType] 'INDEX_PRICE', 'MARK_PRICE', 'LATEST_PRICE', required if stopPrice is defined
 * @param {float} [params.triggerPrice] price to trigger a stop order
 * @param {float} [params.stopPrice] alias for triggerPrice
 * @param {float} [params.stopLoss] price to set a stop-loss on an open position
 * @param {float} [params.takeProfit] price to set a take-profit on an open position
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24398 := (<-this.LoadMarkets())
            PanicOnError(retRes24398)
            var market interface{} = this.Market(symbol)
            symbol = GetValue(market, "symbol")
            if IsTrue(GetValue(market, "spot")) {
        
                    retRes244319 :=  (<-this.CreateSpotOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes244319)
                    ch <- retRes244319
                    return nil
            } else {
        
                    retRes244519 :=  (<-this.CreateContractOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes244519)
                    ch <- retRes244519
                    return nil
            }
                return nil
            }()
            return ch
        }
func  (this *xt) CreateSpotOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24508 := (<-this.LoadMarkets())
            PanicOnError(retRes24508)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": ToUpper(side),
                "type": ToUpper(typeVar),
            }
            var timeInForce interface{} = nil
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var marginOrSpotRequest interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), "LEVER", "SPOT")
            AddElementToObject(request, "bizType", marginOrSpotRequest)
            if IsTrue(IsEqual(typeVar, "market")) {
                timeInForce = this.SafeStringUpper(params, "timeInForce", "FOK")
                if IsTrue(IsEqual(side, "buy")) {
                    var cost interface{} = this.SafeString(params, "cost")
                    params = this.Omit(params, "cost")
                    var createMarketBuyOrderRequiresPrice interface{} = this.SafeBool(this.Options, "createMarketBuyOrderRequiresPrice", true)
                    if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsTrue(IsEqual(price, nil)) && IsTrue((IsEqual(cost, nil)))) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires a price argument or cost in params for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var costCalculated interface{} = nil
                            if IsTrue(!IsEqual(price, nil)) {
                                costCalculated = Precise.StringMul(amountString, priceString)
                            } else {
                                costCalculated = cost
                            }
                            AddElementToObject(request, "quoteQty", this.CostToPrecision(symbol, costCalculated))
                        }
                    } else {
                        var amountCost interface{} = Ternary(IsTrue((!IsEqual(cost, nil))), cost, amount)
                        AddElementToObject(request, "quoteQty", this.CostToPrecision(symbol, amountCost))
                    }
                }
            } else {
                timeInForce = this.SafeStringUpper(params, "timeInForce", "GTC")
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(IsTrue((IsEqual(side, "sell"))) || IsTrue((IsEqual(typeVar, "limit")))) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            AddElementToObject(request, "timeInForce", timeInForce)
        
            response:= (<-this.PrivateSpotPostOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "orderId": "204371980095156544"
            //         }
            //     }
            //
            var order interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *xt) CreateContractOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes25118 := (<-this.LoadMarkets())
            PanicOnError(retRes25118)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "origQty": this.AmountToPrecision(symbol, amount),
            }
            var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
            if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "timeInForce", timeInForce)
            }
            var reduceOnly interface{} = this.SafeValue(params, "reduceOnly", false)
            if IsTrue(IsEqual(side, "buy")) {
                var requestType interface{} = Ternary(IsTrue((reduceOnly)), "SHORT", "LONG")
                AddElementToObject(request, "positionSide", requestType)
            } else {
                var requestType interface{} = Ternary(IsTrue((reduceOnly)), "LONG", "SHORT")
                AddElementToObject(request, "positionSide", requestType)
            }
            var response interface{} = nil
            var triggerPrice interface{} = this.SafeNumber2(params, "triggerPrice", "stopPrice")
            var stopLoss interface{} = this.SafeNumber2(params, "stopLoss", "triggerStopPrice")
            var takeProfit interface{} = this.SafeNumber2(params, "takeProfit", "triggerProfitPrice")
            var isTrigger interface{} =     (!IsEqual(triggerPrice, nil))
            var isStopLoss interface{} =     (!IsEqual(stopLoss, nil))
            var isTakeProfit interface{} =     (!IsEqual(takeProfit, nil))
            if IsTrue(!IsEqual(price, nil)) {
                if IsTrue(!IsTrue((isStopLoss)) && !IsTrue((isTakeProfit))) {
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
            }
            if IsTrue(isTrigger) {
                AddElementToObject(request, "timeInForce", this.SafeStringUpper(params, "timeInForce", "GTC"))
                AddElementToObject(request, "triggerPriceType", this.SafeString(params, "triggerPriceType", "LATEST_PRICE"))
                AddElementToObject(request, "orderSide", ToUpper(side))
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
                var entrustType interface{} = Ternary(IsTrue((IsEqual(typeVar, "market"))), "STOP_MARKET", "STOP")
                AddElementToObject(request, "entrustType", entrustType)
                params = this.Omit(params, "triggerPrice")
                if IsTrue(GetValue(market, "linear")) {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCreatePlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(GetValue(market, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCreatePlan(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsTrue(isStopLoss) || IsTrue(isTakeProfit)) {
                if IsTrue(isStopLoss) {
                    AddElementToObject(request, "triggerStopPrice", this.PriceToPrecision(symbol, stopLoss))
                } else {
                    AddElementToObject(request, "triggerProfitPrice", this.PriceToPrecision(symbol, takeProfit))
                }
                params = this.Omit(params, []interface{}{"stopLoss", "takeProfit"})
                if IsTrue(GetValue(market, "linear")) {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCreateProfit(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(GetValue(market, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCreateProfit(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                AddElementToObject(request, "orderSide", ToUpper(side))
                AddElementToObject(request, "orderType", ToUpper(typeVar))
                if IsTrue(GetValue(market, "linear")) {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1OrderCreate(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(GetValue(market, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1OrderCreate(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
        
                //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": "206410760006650176"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://doc.xt.com/#orderorderGet
 * @see https://doc.xt.com/#futures_ordergetById
 * @see https://doc.xt.com/#futures_entrustgetPlanById
 * @see https://doc.xt.com/#futures_entrustgetProfitById
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26028 := (<-this.LoadMarkets())
            PanicOnError(retRes26028)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOrder", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var trigger interface{} = this.SafeValue(params, "stop")
            var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
            if IsTrue(trigger) {
                AddElementToObject(request, "entrustId", id)
            } else if IsTrue(stopLossTakeProfit) {
                AddElementToObject(request, "profitId", id)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            if IsTrue(trigger) {
                params = this.Omit(params, "stop")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1EntrustPlanDetail(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1EntrustPlanDetail(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(stopLossTakeProfit) {
                params = this.Omit(params, "stopLossTakeProfit")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1EntrustProfitDetail(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1EntrustProfitDetail(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureTradeV1OrderDetail(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PrivateLinearGetFutureTradeV1OrderDetail(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateSpotGetOrderOrderId(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "symbol": "btc_usdt",
            //             "orderId": "207505997850909952",
            //             "clientOrderId": null,
            //             "baseCurrency": "btc",
            //             "quoteCurrency": "usdt",
            //             "side": "BUY",
            //             "type": "LIMIT",
            //             "timeInForce": "GTC",
            //             "price": "20000.00",
            //             "origQty": "0.001000",
            //             "origQuoteQty": "20.00",
            //             "executedQty": "0.000000",
            //             "leavingQty": "0.001000",
            //             "tradeBase": "0.000000",
            //             "tradeQuote": "0.00",
            //             "avgPrice": null,
            //             "fee": null,
            //             "feeCurrency": null,
            //             "closed": false,
            //             "state": "NEW",
            //             "time": 1679175285162,
            //             "updatedTime": 1679175285255
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "orderId": "211451874783183936",
            //             "clientOrderId": null,
            //             "symbol": "btc_usdt",
            //             "orderType": "LIMIT",
            //             "orderSide": "BUY",
            //             "positionSide": "LONG",
            //             "timeInForce": "GTC",
            //             "closePosition": false,
            //             "price": "20000",
            //             "origQty": "10",
            //             "avgPrice": "0",
            //             "executedQty": "0",
            //             "marginFrozen": "1.34533334",
            //             "remark": null,
            //             "triggerProfitPrice": null,
            //             "triggerStopPrice": null,
            //             "sourceId": null,
            //             "sourceType": "DEFAULT",
            //             "forceClose": false,
            //             "closeProfit": null,
            //             "state": "NEW",
            //             "createdTime": 1680116055693,
            //             "updatedTime": 1680116055693
            //         }
            //     }
            //
            // trigger
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "entrustId": "216300248132756992",
            //             "symbol": "btc_usdt",
            //             "entrustType": "STOP",
            //             "orderSide": "SELL",
            //             "positionSide": "SHORT",
            //             "timeInForce": "GTC",
            //             "closePosition": null,
            //             "price": "20000",
            //             "origQty": "1",
            //             "stopPrice": "19000",
            //             "triggerPriceType": "LATEST_PRICE",
            //             "state": "NOT_TRIGGERED",
            //             "marketOrderLevel": null,
            //             "createdTime": 1681271998064,
            //             "updatedTime": 1681271998064,
            //             "ordinary": false
            //         }
            //     }
            //
            // stop-loss and take-profit
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "profitId": "216306213226230400",
            //             "symbol": "btc_usdt",
            //             "positionSide": "LONG",
            //             "origQty": "1",
            //             "triggerPriceType": "LATEST_PRICE",
            //             "triggerProfitPrice": null,
            //             "triggerStopPrice": "20000",
            //             "entryPrice": null,
            //             "positionSize": null,
            //             "isolatedMargin": null,
            //             "executedQty": null,
            //             "avgPrice": null,
            //             "positionType": "ISOLATED",
            //             "state": "NOT_TRIGGERED",
            //             "createdTime": 1681273420039
            //         }
            //     }
            //
            var order interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://doc.xt.com/#orderhistoryOrderGet
 * @see https://doc.xt.com/#futures_ordergetHistory
 * @see https://doc.xt.com/#futures_entrustgetPlanHistory
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27798 := (<-this.LoadMarkets())
            PanicOnError(retRes27798)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOrders", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var trigger interface{} = this.SafeValue2(params, "trigger", "stop")
            if IsTrue(trigger) {
                params = this.Omit(params, []interface{}{"trigger", "stop"})
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1EntrustPlanListHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1EntrustPlanListHistory(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureTradeV1OrderListHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PrivateLinearGetFutureTradeV1OrderListHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrders", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                var marginOrSpotRequest interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), "LEVER", "SPOT")
                AddElementToObject(request, "bizType", marginOrSpotRequest)
                
        response = (<-this.PrivateSpotGetHistoryOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //  spot and margin
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": true,
            //             "items": [
            //                 {
            //                     "symbol": "btc_usdt",
            //                     "orderId": "207505997850909952",
            //                     "clientOrderId": null,
            //                     "baseCurrency": "btc",
            //                     "quoteCurrency": "usdt",
            //                     "side": "BUY",
            //                     "type": "LIMIT",
            //                     "timeInForce": "GTC",
            //                     "price": "20000.00",
            //                     "origQty": "0.001000",
            //                     "origQuoteQty": "20.00",
            //                     "executedQty": "0.000000",
            //                     "leavingQty": "0.000000",
            //                     "tradeBase": "0.000000",
            //                     "tradeQuote": "0.00",
            //                     "avgPrice": null,
            //                     "fee": null,
            //                     "feeCurrency": null,
            //                     "closed": true,
            //                     "state": "CANCELED",
            //                     "time": 1679175285162,
            //                     "updatedTime": 1679175488492
            //                 },
            //             ]
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": true,
            //             "items": [
            //                 {
            //                     "orderId": "207519546930995456",
            //                     "clientOrderId": null,
            //                     "symbol": "btc_usdt",
            //                     "orderType": "LIMIT",
            //                     "orderSide": "BUY",
            //                     "positionSide": "LONG",
            //                     "timeInForce": "GTC",
            //                     "closePosition": false,
            //                     "price": "20000",
            //                     "origQty": "100",
            //                     "avgPrice": "0",
            //                     "executedQty": "0",
            //                     "marginFrozen": "4.12",
            //                     "remark": null,
            //                     "triggerProfitPrice": null,
            //                     "triggerStopPrice": null,
            //                     "sourceId": null,
            //                     "sourceType": "DEFAULT",
            //                     "forceClose": false,
            //                     "closeProfit": null,
            //                     "state": "CANCELED",
            //                     "createdTime": 1679178515689,
            //                     "updatedTime": 1679180096172
            //                 },
            //             ]
            //         }
            //     }
            //
            // stop
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "entrustId": "216300248132756992",
            //                     "symbol": "btc_usdt",
            //                     "entrustType": "STOP",
            //                     "orderSide": "SELL",
            //                     "positionSide": "SHORT",
            //                     "timeInForce": "GTC",
            //                     "closePosition": null,
            //                     "price": "20000",
            //                     "origQty": "1",
            //                     "stopPrice": "19000",
            //                     "triggerPriceType": "LATEST_PRICE",
            //                     "state": "USER_REVOCATION",
            //                     "marketOrderLevel": null,
            //                     "createdTime": 1681271998064,
            //                     "updatedTime": 1681273188674,
            //                     "ordinary": false
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var orders interface{} = this.SafeValue(data, "items", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *xt) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes29328 := (<-this.LoadMarkets())
            PanicOnError(retRes29328)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrdersByStatus", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOrdersByStatus", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var trigger interface{} = this.SafeValue(params, "stop")
            var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
            if IsTrue(IsEqual(status, "open")) {
                if IsTrue(IsTrue(trigger) || IsTrue(stopLossTakeProfit)) {
                    AddElementToObject(request, "state", "NOT_TRIGGERED")
                } else if IsTrue(!IsEqual(subType, nil)) {
                    AddElementToObject(request, "state", "NEW")
                }
            } else if IsTrue(IsEqual(status, "closed")) {
                if IsTrue(IsTrue(trigger) || IsTrue(stopLossTakeProfit)) {
                    AddElementToObject(request, "state", "TRIGGERED")
                } else {
                    AddElementToObject(request, "state", "FILLED")
                }
            } else if IsTrue(IsEqual(status, "canceled")) {
                if IsTrue(IsTrue(trigger) || IsTrue(stopLossTakeProfit)) {
                    AddElementToObject(request, "state", "USER_REVOCATION")
                } else {
                    AddElementToObject(request, "state", "CANCELED")
                }
            } else {
                AddElementToObject(request, "state", status)
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(trigger) || IsTrue(stopLossTakeProfit)) || IsTrue((!IsEqual(subType, nil)))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "size", limit)
                }
            }
            if IsTrue(trigger) {
                params = this.Omit(params, "stop")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1EntrustPlanList(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1EntrustPlanList(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(stopLossTakeProfit) {
                params = this.Omit(params, "stopLossTakeProfit")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1EntrustProfitList(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1EntrustProfitList(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsTrue(IsTrue((!IsEqual(subType, nil))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInverseGetFutureTradeV1OrderList(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearGetFutureTradeV1OrderList(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrdersByStatus", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                var marginOrSpotRequest interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), "LEVER", "SPOT")
                AddElementToObject(request, "bizType", marginOrSpotRequest)
                if IsTrue(!IsEqual(status, "open")) {
                    if IsTrue(!IsEqual(since, nil)) {
                        AddElementToObject(request, "startTime", since)
                    }
                    if IsTrue(!IsEqual(limit, nil)) {
                        AddElementToObject(request, "limit", limit)
                    }
                    
        response = (<-this.PrivateSpotGetHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateSpotGetOpenOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // spot and margin
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": true,
            //             "items": [
            //                 {
            //                     "symbol": "btc_usdt",
            //                     "orderId": "207505997850909952",
            //                     "clientOrderId": null,
            //                     "baseCurrency": "btc",
            //                     "quoteCurrency": "usdt",
            //                     "side": "BUY",
            //                     "type": "LIMIT",
            //                     "timeInForce": "GTC",
            //                     "price": "20000.00",
            //                     "origQty": "0.001000",
            //                     "origQuoteQty": "20.00",
            //                     "executedQty": "0.000000",
            //                     "leavingQty": "0.000000",
            //                     "tradeBase": "0.000000",
            //                     "tradeQuote": "0.00",
            //                     "avgPrice": null,
            //                     "fee": null,
            //                     "feeCurrency": null,
            //                     "closed": true,
            //                     "state": "CANCELED",
            //                     "time": 1679175285162,
            //                     "updatedTime": 1679175488492
            //                 },
            //             ]
            //         }
            //     }
            //
            // spot and margin: fetchOpenOrders
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": [
            //             {
            //                 "symbol": "eth_usdt",
            //                 "orderId": "208249323222264320",
            //                 "clientOrderId": null,
            //                 "baseCurrency": "eth",
            //                 "quoteCurrency": "usdt",
            //                 "side": "BUY",
            //                 "type": "LIMIT",
            //                 "timeInForce": "GTC",
            //                 "price": "1300.00",
            //                 "origQty": "0.0032",
            //                 "origQuoteQty": "4.16",
            //                 "executedQty": "0.0000",
            //                 "leavingQty": "0.0032",
            //                 "tradeBase": "0.0000",
            //                 "tradeQuote": "0.00",
            //                 "avgPrice": null,
            //                 "fee": null,
            //                 "feeCurrency": null,
            //                 "closed": false,
            //                 "state": "NEW",
            //                 "time": 1679352507741,
            //                 "updatedTime": 1679352507869
            //             },
            //         ]
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "page": 1,
            //             "ps": 10,
            //             "total": 25,
            //             "items": [
            //                 {
            //                     "orderId": "207519546930995456",
            //                     "clientOrderId": null,
            //                     "symbol": "btc_usdt",
            //                     "orderType": "LIMIT",
            //                     "orderSide": "BUY",
            //                     "positionSide": "LONG",
            //                     "timeInForce": "GTC",
            //                     "closePosition": false,
            //                     "price": "20000",
            //                     "origQty": "100",
            //                     "avgPrice": "0",
            //                     "executedQty": "0",
            //                     "marginFrozen": "4.12",
            //                     "remark": null,
            //                     "triggerProfitPrice": null,
            //                     "triggerStopPrice": null,
            //                     "sourceId": null,
            //                     "sourceType": "DEFAULT",
            //                     "forceClose": false,
            //                     "closeProfit": null,
            //                     "state": "CANCELED",
            //                     "createdTime": 1679178515689,
            //                     "updatedTime": 1679180096172
            //                 },
            //             ]
            //         }
            //     }
            //
            // stop
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "page": 1,
            //             "ps": 3,
            //             "total": 8,
            //             "items": [
            //                 {
            //                     "entrustId": "216300248132756992",
            //                     "symbol": "btc_usdt",
            //                     "entrustType": "STOP",
            //                     "orderSide": "SELL",
            //                     "positionSide": "SHORT",
            //                     "timeInForce": "GTC",
            //                     "closePosition": null,
            //                     "price": "20000",
            //                     "origQty": "1",
            //                     "stopPrice": "19000",
            //                     "triggerPriceType": "LATEST_PRICE",
            //                     "state": "USER_REVOCATION",
            //                     "marketOrderLevel": null,
            //                     "createdTime": 1681271998064,
            //                     "updatedTime": 1681273188674,
            //                     "ordinary": false
            //                 },
            //             ]
            //         }
            //     }
            //
            // stop-loss and take-profit
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "page": 1,
            //             "ps": 3,
            //             "total": 2,
            //             "items": [
            //                 {
            //                     "profitId": "216306213226230400",
            //                     "symbol": "btc_usdt",
            //                     "positionSide": "LONG",
            //                     "origQty": "1",
            //                     "triggerPriceType": "LATEST_PRICE",
            //                     "triggerProfitPrice": null,
            //                     "triggerStopPrice": "20000",
            //                     "entryPrice": "0",
            //                     "positionSize": "0",
            //                     "isolatedMargin": "0",
            //                     "executedQty": "0",
            //                     "avgPrice": null,
            //                     "positionType": "ISOLATED",
            //                     "state": "USER_REVOCATION",
            //                     "createdTime": 1681273420039
            //                 },
            //             ]
            //         }
            //     }
            //
            var isSpotOpenOrders interface{} =     (IsTrue((IsEqual(status, "open"))) && IsTrue((IsEqual(subType, nil))))
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var orders interface{} = Ternary(IsTrue(isSpotOpenOrders), this.SafeValue(response, "result", []interface{}{}), this.SafeValue(data, "items", []interface{}{}))
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://doc.xt.com/#orderopenOrderGet
 * @see https://doc.xt.com/#futures_ordergetOrders
 * @see https://doc.xt.com/#futures_entrustgetPlan
 * @see https://doc.xt.com/#futures_entrustgetProfit
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes321315 :=  (<-this.FetchOrdersByStatus("open", symbol, since, limit, params))
                PanicOnError(retRes321315)
                ch <- retRes321315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://doc.xt.com/#orderhistoryOrderGet
 * @see https://doc.xt.com/#futures_ordergetOrders
 * @see https://doc.xt.com/#futures_entrustgetPlan
 * @see https://doc.xt.com/#futures_entrustgetProfit
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes323315 :=  (<-this.FetchOrdersByStatus("closed", symbol, since, limit, params))
                PanicOnError(retRes323315)
                ch <- retRes323315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://doc.xt.com/#orderhistoryOrderGet
 * @see https://doc.xt.com/#futures_ordergetOrders
 * @see https://doc.xt.com/#futures_entrustgetPlan
 * @see https://doc.xt.com/#futures_entrustgetProfit
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes325315 :=  (<-this.FetchOrdersByStatus("canceled", symbol, since, limit, params))
                PanicOnError(retRes325315)
                ch <- retRes325315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#cancelOrder
 * @description cancels an open order
 * @see https://doc.xt.com/#orderorderDel
 * @see https://doc.xt.com/#futures_ordercancel
 * @see https://doc.xt.com/#futures_entrustcancelPlan
 * @see https://doc.xt.com/#futures_entrustcancelProfit
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32728 := (<-this.LoadMarkets())
            PanicOnError(retRes32728)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("cancelOrder", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var trigger interface{} = this.SafeValue2(params, "trigger", "stop")
            var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
            if IsTrue(trigger) {
                AddElementToObject(request, "entrustId", id)
            } else if IsTrue(stopLossTakeProfit) {
                AddElementToObject(request, "profitId", id)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            if IsTrue(trigger) {
                params = this.Omit(params, []interface{}{"trigger", "stop"})
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCancelPlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCancelPlan(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(stopLossTakeProfit) {
                params = this.Omit(params, "stopLossTakeProfit")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCancelProfitStop(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCancelProfitStop(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInversePostFutureTradeV1OrderCancel(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PrivateLinearPostFutureTradeV1OrderCancel(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateSpotDeleteOrderOrderId(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "cancelId": "208322474307982720"
            //         }
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": "208319789679471616"
            //     }
            //
            var isContractResponse interface{} =     (IsTrue(IsTrue((!IsEqual(subType, nil))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future"))))
            var order interface{} = Ternary(IsTrue(isContractResponse), response, this.SafeValue(response, "result", map[string]interface{} {}))
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://doc.xt.com/#orderopenOrderDel
 * @see https://doc.xt.com/#futures_ordercancelBatch
 * @see https://doc.xt.com/#futures_entrustcancelPlanBatch
 * @see https://doc.xt.com/#futures_entrustcancelProfitBatch
 * @param {string} [symbol] unified market symbol of the market to cancel orders in
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {bool} [params.trigger] if the order is a trigger order or not
 * @param {bool} [params.stopLossTakeProfit] if the order is a stop-loss or take-profit order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33548 := (<-this.LoadMarkets())
            PanicOnError(retRes33548)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("cancelAllOrders", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var trigger interface{} = this.SafeValue2(params, "trigger", "stop")
            var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
            if IsTrue(trigger) {
                params = this.Omit(params, []interface{}{"trigger", "stop"})
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCancelAllPlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCancelAllPlan(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(stopLossTakeProfit) {
                params = this.Omit(params, "stopLossTakeProfit")
                if IsTrue(IsEqual(subType, "inverse")) {
                    
        response = (<-this.PrivateInversePostFutureTradeV1EntrustCancelAllProfitStop(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateLinearPostFutureTradeV1EntrustCancelAllProfitStop(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInversePostFutureTradeV1OrderCancelAll(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PrivateLinearPostFutureTradeV1OrderCancelAll(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                var marginOrSpotRequest interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), "LEVER", "SPOT")
                AddElementToObject(request, "bizType", marginOrSpotRequest)
                
        response = (<-this.PrivateSpotDeleteOpenOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // spot and margin
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": null
            //     }
            //
            // swap and future
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": true
            //     }
            //
        ch <- []interface{}{this.SafeOrder(response)}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#cancelOrders
 * @description cancel multiple orders
 * @see https://doc.xt.com/#orderbatchOrderDel
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol of the market to cancel orders in
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *xt) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34288 := (<-this.LoadMarkets())
            PanicOnError(retRes34288)
            var request interface{} = map[string]interface{} {
                "orderIds": ids,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("cancelOrders", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(!IsEqual(subType, nil)) {
                panic(NotSupported(Add(this.Id, " cancelOrders() does not support swap and future orders, only spot orders are accepted")))
            }
        
            response:= (<-this.PrivateSpotDeleteBatchOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // spot
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": null
            //     }
            //
        ch <- []interface{}{this.SafeOrder(response)}
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: createOrder
    //
    //     {
    //         "orderId": "204371980095156544"
    //     }
    //
    // spot: cancelOrder
    //
    //     {
    //         "cancelId": "208322474307982720"
    //     }
    //
    // swap and future: createOrder, cancelOrder
    //
    //     {
    //         "returnCode": 0,
    //         "msgInfo": "success",
    //         "error": null,
    //         "result": "206410760006650176"
    //     }
    //
    // spot: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
    //
    //     {
    //         "symbol": "btc_usdt",
    //         "orderId": "207505997850909952",
    //         "clientOrderId": null,
    //         "baseCurrency": "btc",
    //         "quoteCurrency": "usdt",
    //         "side": "BUY",
    //         "type": "LIMIT",
    //         "timeInForce": "GTC",
    //         "price": "20000.00",
    //         "origQty": "0.001000",
    //         "origQuoteQty": "20.00",
    //         "executedQty": "0.000000",
    //         "leavingQty": "0.001000",
    //         "tradeBase": "0.000000",
    //         "tradeQuote": "0.00",
    //         "avgPrice": null,
    //         "fee": null,
    //         "feeCurrency": null,
    //         "closed": false,
    //         "state": "NEW",
    //         "time": 1679175285162,
    //         "updatedTime": 1679175285255
    //     }
    //
    // swap and future: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
    //
    //     {
    //         "orderId": "207519546930995456",
    //         "clientOrderId": null,
    //         "symbol": "btc_usdt",
    //         "orderType": "LIMIT",
    //         "orderSide": "BUY",
    //         "positionSide": "LONG",
    //         "timeInForce": "GTC",
    //         "closePosition": false,
    //         "price": "20000",
    //         "origQty": "100",
    //         "avgPrice": "0",
    //         "executedQty": "0",
    //         "marginFrozen": "4.12",
    //         "remark": null,
    //         "triggerProfitPrice": null,
    //         "triggerStopPrice": null,
    //         "sourceId": null,
    //         "sourceType": "DEFAULT",
    //         "forceClose": false,
    //         "closeProfit": null,
    //         "state": "CANCELED",
    //         "createdTime": 1679178515689,
    //         "updatedTime": 1679180096172
    //     }
    //
    // trigger: fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
    //
    //     {
    //         "entrustId": "216300248132756992",
    //         "symbol": "btc_usdt",
    //         "entrustType": "STOP",
    //         "orderSide": "SELL",
    //         "positionSide": "SHORT",
    //         "timeInForce": "GTC",
    //         "closePosition": null,
    //         "price": "20000",
    //         "origQty": "1",
    //         "stopPrice": "19000",
    //         "triggerPriceType": "LATEST_PRICE",
    //         "state": "NOT_TRIGGERED",
    //         "marketOrderLevel": null,
    //         "createdTime": 1681271998064,
    //         "updatedTime": 1681271998064,
    //         "ordinary": false
    //     }
    //
    // stop-loss and take-profit: fetchOrder, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrdersByStatus
    //
    //     {
    //         "profitId": "216306213226230400",
    //         "symbol": "btc_usdt",
    //         "positionSide": "LONG",
    //         "origQty": "1",
    //         "triggerPriceType": "LATEST_PRICE",
    //         "triggerProfitPrice": null,
    //         "triggerStopPrice": "20000",
    //         "entryPrice": null,
    //         "positionSize": null,
    //         "isolatedMargin": null,
    //         "executedQty": null,
    //         "avgPrice": null,
    //         "positionType": "ISOLATED",
    //         "state": "NOT_TRIGGERED",
    //         "createdTime": 1681273420039
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var marketType interface{} = Ternary(IsTrue(IsTrue((InOp(order, "result"))) || IsTrue((InOp(order, "positionSide")))), "contract", "spot")
    market = this.SafeMarket(marketId, market, nil, marketType)
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, marketType)
    var timestamp interface{} = this.SafeInteger2(order, "time", "createdTime")
    var quantity interface{} = this.SafeNumber(order, "origQty")
    var amount interface{} = Ternary(IsTrue((IsEqual(marketType, "spot"))), quantity, Precise.StringMul(this.NumberToString(quantity), this.NumberToString(GetValue(market, "contractSize"))))
    var filledQuantity interface{} = this.SafeNumber(order, "executedQty")
    var filled interface{} = Ternary(IsTrue((IsEqual(marketType, "spot"))), filledQuantity, Precise.StringMul(this.NumberToString(filledQuantity), this.NumberToString(GetValue(market, "contractSize"))))
    var lastUpdatedTimestamp interface{} = this.SafeInteger(order, "updatedTime")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeStringN(order, []interface{}{"orderId", "result", "cancelId", "entrustId", "profitId"}),
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastUpdatedTimestamp,
        "lastUpdateTimestamp": lastUpdatedTimestamp,
        "symbol": symbol,
        "type": this.SafeStringLower2(order, "type", "orderType"),
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": nil,
        "side": this.SafeStringLower2(order, "side", "orderSide"),
        "price": this.SafeNumber(order, "price"),
        "triggerPrice": this.SafeNumber(order, "stopPrice"),
        "stopLoss": this.SafeNumber(order, "triggerStopPrice"),
        "takeProfit": this.SafeNumber(order, "triggerProfitPrice"),
        "amount": amount,
        "filled": filled,
        "remaining": this.SafeNumber(order, "leavingQty"),
        "cost": nil,
        "average": this.SafeNumber(order, "avgPrice"),
        "status": this.ParseOrderStatus(this.SafeString(order, "state")),
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(this.SafeString(order, "feeCurrency")),
            "cost": this.SafeNumber(order, "fee"),
        },
        "trades": nil,
    }, market)
}
func  (this *xt) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "REJECTED": "rejected",
        "EXPIRED": "expired",
        "UNFINISHED": "open",
        "NOT_TRIGGERED": "open",
        "TRIGGERING": "open",
        "TRIGGERED": "closed",
        "USER_REVOCATION": "canceled",
        "PLATFORM_REVOCATION": "rejected",
        "HISTORY": "expired",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name xt#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://doc.xt.com/#futures_usergetBalanceBill
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/en/latest/manual.html#ledger-structure}
 */
func  (this *xt) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes36488 := (<-this.LoadMarkets())
            PanicOnError(retRes36488)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchLedger", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchLedger", nil, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureUserV1BalanceBills(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(subType, "linear"))) || IsTrue((IsEqual(typeVar, "swap")))) || IsTrue((IsEqual(typeVar, "future")))) {
                
        response = (<-this.PrivateLinearGetFutureUserV1BalanceBills(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchLedger() does not support spot transactions, only swap and future wallet transactions are supported")))
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "id": "207260567109387524",
            //                     "coin": "usdt",
            //                     "symbol": "btc_usdt",
            //                     "type": "FEE",
            //                     "amount": "-0.0213",
            //                     "side": "SUB",
            //                     "afterAmount": null,
            //                     "createdTime": 1679116769914
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var ledger interface{} = this.SafeValue(data, "items", []interface{}{})
        
            ch <- this.ParseLedger(ledger, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "207260567109387524",
    //         "coin": "usdt",
    //         "symbol": "btc_usdt",
    //         "type": "FEE",
    //         "amount": "-0.0213",
    //         "side": "SUB",
    //         "afterAmount": null,
    //         "createdTime": 1679116769914
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var side interface{} = this.SafeString(item, "side")
    var direction interface{} = Ternary(IsTrue((IsEqual(side, "ADD"))), "in", "out")
    var currencyId interface{} = this.SafeString(item, "coin")
    currency = this.SafeCurrency(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(item, "createdTime")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "id"),
        "direction": direction,
        "account": nil,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(item, "amount"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": this.SafeNumber(item, "afterAmount"),
        "status": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
        },
    }, currency)
}
func  (this *xt) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var ledgerType interface{} = map[string]interface{} {
        "EXCHANGE": "transfer",
        "CLOSE_POSITION": "trade",
        "TAKE_OVER": "trade",
        "MERGE": "trade",
        "QIANG_PING_MANAGER": "fee",
        "FUND": "fee",
        "FEE": "fee",
        "ADL": "auto-deleveraging",
    }
    return this.SafeString(ledgerType, typeVar, typeVar)
}
/**
 * @method
 * @name xt#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://doc.xt.com/#deposit_withdrawaldepositAddressGet
 * @param {string} code unified currency code
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} params.network required network id
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/en/latest/manual.html#address-structure}
 */
func  (this *xt) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37658 := (<-this.LoadMarkets())
            PanicOnError(retRes37658)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            var currency interface{} = this.Currency(code)
            var networkId interface{} = this.NetworkCodeToId(networkCode, code)
            this.CheckRequiredArgument("fetchDepositAddress", networkId, "network")
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "chain": networkId,
            }
        
            response:= (<-this.PrivateSpotGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "address": "0x7f7173cf29d3846d20ca5a3aec1120b93dbd157a",
            //             "memo": ""
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(result, currency)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "0x7f7173cf29d3846d20ca5a3aec1120b93dbd157a",
    //         "memo": ""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(nil, currency),
        "network": nil,
        "address": address,
        "tag": this.SafeString(depositAddress, "memo"),
    }
}
/**
 * @method
 * @name xt#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://doc.xt.com/#deposit_withdrawalhistoryDepositGet
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
 */
func  (this *xt) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes38218 := (<-this.LoadMarkets())
            PanicOnError(retRes38218)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 10, max 200
            }
        
            response:= (<-this.PrivateSpotGetDepositHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "id": 170368702,
            //                     "currency": "usdt",
            //                     "chain": "Ethereum",
            //                     "memo": "",
            //                     "status": "SUCCESS",
            //                     "amount": "31.792528",
            //                     "confirmations": 12,
            //                     "transactionId": "0x90b8487c258b81b85e15e461b1839c49d4d8e6e9de4c1adb658cd47d4f5c5321",
            //                     "address": "0x7f7172cf29d3846d30ca5a3aec1120b92dbd150b",
            //                     "fromAddr": "0x7830c87c02e56aff27fa9ab1241711331fa86f58",
            //                     "createdTime": 1678491442000
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var deposits interface{} = this.SafeValue(data, "items", []interface{}{})
        
            ch <- this.ParseTransactions(deposits, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://doc.xt.com/#deposit_withdrawalwithdrawHistory
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
 */
func  (this *xt) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes38788 := (<-this.LoadMarkets())
            PanicOnError(retRes38788)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 10, max 200
            }
        
            response:= (<-this.PrivateSpotGetWithdrawHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "id": 950898,
            //                     "currency": "usdt",
            //                     "chain": "Tron",
            //                     "address": "TGB2vxTjiqraVZBy7YHXF8V3CSMVhQKcaf",
            //                     "memo": "",
            //                     "status": "SUCCESS",
            //                     "amount": "5",
            //                     "fee": "2",
            //                     "confirmations": 6,
            //                     "transactionId": "c36e230b879842b1d7afd19d15ee1a866e26eaa0626e367d6f545d2932a15156",
            //                     "createdTime": 1680049062000
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var withdrawals interface{} = this.SafeValue(data, "items", []interface{}{})
        
            ch <- this.ParseTransactions(withdrawals, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#withdraw
 * @description make a withdrawal
 * @see https://doc.xt.com/#deposit_withdrawalwithdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} [tag]
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure}
 */
func  (this *xt) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckAddress(address)
        
            retRes39378 := (<-this.LoadMarkets())
            PanicOnError(retRes39378)
            var currency interface{} = this.Currency(code)
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            var networkIdsByCodes interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var networkId interface{} = this.SafeString2(networkIdsByCodes, networkCode, code, code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "chain": networkId,
                "amount": this.CurrencyToPrecision(code, amount),
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
        
            response:= (<-this.PrivateSpotPostWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rc": 0,
            //         "mc": "SUCCESS",
            //         "ma": [],
            //         "result": {
            //             "id": 950898
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTransaction(result, currency)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "id": 170368702,
    //         "currency": "usdt",
    //         "chain": "Ethereum",
    //         "memo": "",
    //         "status": "SUCCESS",
    //         "amount": "31.792528",
    //         "confirmations": 12,
    //         "transactionId": "0x90b8487c258b81b85e15e461b1839c49d4d8e6e9de4c1adb658cd47d4f5c5321",
    //         "address": "0x7f7172cf29d3846d30ca5a3aec1120b92dbd150b",
    //         "fromAddr": "0x7830c87c02e56aff27fa9ab1241711331fa86f58",
    //         "createdTime": 1678491442000
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "id": 950898,
    //         "currency": "usdt",
    //         "chain": "Tron",
    //         "address": "TGB2vxTjiqraVZBy7YHXF8V3CSMVhQKcaf",
    //         "memo": "",
    //         "status": "SUCCESS",
    //         "amount": "5",
    //         "fee": "2",
    //         "confirmations": 6,
    //         "transactionId": "c36e230b879842b1d7afd19d15ee1a866e26eaa0626e367d6f545d2932a15156",
    //         "createdTime": 1680049062000
    //     }
    //
    // withdraw
    //
    //     {
    //         "id": 950898
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var typeVar interface{} = Ternary(IsTrue((InOp(transaction, "fromAddr"))), "deposit", "withdraw")
    var timestamp interface{} = this.SafeInteger(transaction, "createdTime")
    var address interface{} = this.SafeString(transaction, "address")
    var memo interface{} = this.SafeString(transaction, "memo")
    var currencyCode interface{} = this.SafeCurrencyCode(this.SafeString(transaction, "currency"), currency)
    var fee interface{} = this.SafeNumber(transaction, "fee")
    var feeCurrency interface{} = Ternary(IsTrue((!IsEqual(fee, nil))), currencyCode, nil)
    var networkId interface{} = this.SafeString(transaction, "chain")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "transactionId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "updated": nil,
        "addressFrom": this.SafeString(transaction, "fromAddr"),
        "addressTo": address,
        "address": address,
        "tagFrom": nil,
        "tagTo": nil,
        "tag": memo,
        "type": typeVar,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": currencyCode,
        "network": this.NetworkIdToCode(networkId, currencyCode),
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "comment": memo,
        "fee": map[string]interface{} {
            "currency": feeCurrency,
            "cost": fee,
            "rate": nil,
        },
        "internal": nil,
    }
}
func  (this *xt) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUBMIT": "pending",
        "REVIEW": "pending",
        "AUDITED": "pending",
        "PENDING": "pending",
        "CANCEL": "canceled",
        "FAIL": "failed",
        "SUCCESS": "ok",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name xt#setLeverage
 * @description set the level of leverage for a market
 * @see https://doc.xt.com/#futures_useradjustLeverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} params.positionSide 'LONG' or 'SHORT'
 * @returns {object} response from the exchange
 */
func  (this *xt) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
            var positionSide interface{} = this.SafeString(params, "positionSide")
            this.CheckRequiredArgument("setLeverage", positionSide, "positionSide", []interface{}{"LONG", "SHORT"})
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 125)))) {
                panic(BadRequest(Add(this.Id, " setLeverage() leverage should be between 1 and 125")))
            }
        
            retRes40778 := (<-this.LoadMarkets())
            PanicOnError(retRes40778)
            var market interface{} = this.Market(symbol)
            if !IsTrue((GetValue(market, "contract"))) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports contract markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "positionSide": positionSide,
                "leverage": leverage,
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("setLeverage", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInversePostFutureUserV1PositionAdjustLeverage(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateLinearPostFutureUserV1PositionAdjustLeverage(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": null
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#addMargin
 * @description add margin to a position
 * @see https://doc.xt.com/#futures_useradjustMargin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} params.positionSide 'LONG' or 'SHORT'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *xt) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes411815 :=  (<-this.ModifyMarginHelper(symbol, amount, "ADD", params))
                PanicOnError(retRes411815)
                ch <- retRes411815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#reduceMargin
 * @description remove margin from a position
 * @see https://doc.xt.com/#futures_useradjustMargin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} params.positionSide 'LONG' or 'SHORT'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *xt) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes413315 :=  (<-this.ModifyMarginHelper(symbol, amount, "SUB", params))
                PanicOnError(retRes413315)
                ch <- retRes413315
                return nil
        
            }()
            return ch
        }
func  (this *xt) ModifyMarginHelper(symbol interface{}, amount interface{}, addOrReduce interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var positionSide interface{} = this.SafeString(params, "positionSide")
            this.CheckRequiredArgument("setLeverage", positionSide, "positionSide", []interface{}{"LONG", "SHORT"})
        
            retRes41398 := (<-this.LoadMarkets())
            PanicOnError(retRes41398)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "margin": amount,
                "type": addOrReduce,
                "positionSide": positionSide,
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("modifyMarginHelper", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInversePostFutureUserV1PositionMargin(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateLinearPostFutureUserV1PositionMargin(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": null
            //     }
            //
        ch <- this.ParseMarginModification(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return map[string]interface{} {
        "info": data,
        "type": nil,
        "amount": nil,
        "code": nil,
        "symbol": this.SafeSymbol(nil, market),
        "status": nil,
        "marginMode": nil,
        "total": nil,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name xt#fetchLeverageTiers
 * @description retrieve information on the maximum leverage for different trade sizes
 * @see https://doc.xt.com/#futures_quotesgetLeverageBrackets
 * @param {string} [symbols] a list of unified market symbols
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func  (this *xt) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes41918 := (<-this.LoadMarkets())
            PanicOnError(retRes41918)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchLeverageTiers", nil, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicLeverageBracketList(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicLeverageBracketList(params))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "symbol": "rad_usdt",
            //                 "leverageBrackets": [
            //                     {
            //                         "symbol": "rad_usdt",
            //                         "bracket": 1,
            //                         "maxNominalValue": "5000",
            //                         "maintMarginRate": "0.025",
            //                         "startMarginRate": "0.05",
            //                         "maxStartMarginRate": null,
            //                         "maxLeverage": "20",
            //                         "minLeverage": "1"
            //                     },
            //                 ]
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", []interface{}{})
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.ParseLeverageTiers(data, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseLeverageTiers(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "rad_usdt",
    //         "leverageBrackets": [
    //             {
    //                 "symbol": "rad_usdt",
    //                 "bracket": 1,
    //                 "maxNominalValue": "5000",
    //                 "maintMarginRate": "0.025",
    //                 "startMarginRate": "0.05",
    //                 "maxStartMarginRate": null,
    //                 "maxLeverage": "20",
    //                 "minLeverage": "1"
    //             },
    //         ]
    //     }
    //
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    marketIdKey := GetArg(optionalArgs, 1, nil)
    _ = marketIdKey
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var marketId interface{} = this.SafeString(entry, "symbol")
        var market interface{} = this.SafeMarket(marketId, nil, "_", "contract")
        var symbol interface{} = this.SafeSymbol(marketId, market)
        if IsTrue(!IsEqual(symbols, nil)) {
            if IsTrue(this.InArray(symbol, symbols)) {
                AddElementToObject(result, symbol, this.ParseMarketLeverageTiers(entry, market))
            }
        } else {
            AddElementToObject(result, symbol, this.ParseMarketLeverageTiers(GetValue(response, i), market))
        }
    }
    return result
}
/**
 * @method
 * @name xt#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage for different trade sizes of a single market
 * @see https://doc.xt.com/#futures_quotesgetLeverageBracket
 * @param {string} symbol unified market symbol
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func  (this *xt) FetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42748 := (<-this.LoadMarkets())
            PanicOnError(retRes42748)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMarketLeverageTiers", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicLeverageBracketDetail(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicLeverageBracketDetail(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "symbol": "btc_usdt",
            //             "leverageBrackets": [
            //                 {
            //                     "symbol": "btc_usdt",
            //                     "bracket": 1,
            //                     "maxNominalValue": "500000",
            //                     "maintMarginRate": "0.004",
            //                     "startMarginRate": "0.008",
            //                     "maxStartMarginRate": null,
            //                     "maxLeverage": "125",
            //                     "minLeverage": "1"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseMarketLeverageTiers(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "rad_usdt",
    //         "leverageBrackets": [
    //             {
    //                 "symbol": "rad_usdt",
    //                 "bracket": 1,
    //                 "maxNominalValue": "5000",
    //                 "maintMarginRate": "0.025",
    //                 "startMarginRate": "0.05",
    //                 "maxStartMarginRate": null,
    //                 "maxLeverage": "20",
    //                 "minLeverage": "1"
    //             },
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var tiers interface{} = []interface{}{}
    var brackets interface{} = this.SafeValue(info, "leverageBrackets", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(brackets)); i++ {
        var tier interface{} = GetValue(brackets, i)
        var marketId interface{} = this.SafeString(info, "symbol")
        market = this.SafeMarket(marketId, market, "_", "contract")
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.SafeInteger(tier, "bracket"),
            "symbol": this.SafeSymbol(marketId, market, "_", "contract"),
            "currency": GetValue(market, "settle"),
            "minNotional": this.SafeNumber(GetValue(brackets, Subtract(i, 1)), "maxNominalValue", 0),
            "maxNotional": this.SafeNumber(tier, "maxNominalValue"),
            "maintenanceMarginRate": this.SafeNumber(tier, "maintMarginRate"),
            "maxLeverage": this.SafeNumber(tier, "maxLeverage"),
            "info": tier,
        })
    }
    return tiers
}
/**
 * @method
 * @name xt#fetchFundingRateHistory
 * @description fetches historical funding rates
 * @see https://doc.xt.com/#futures_quotesgetFundingRateRecord
 * @param {string} [symbol] unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures] to fetch
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
 */
func  (this *xt) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes43668 := (<-this.LoadMarkets())
            PanicOnError(retRes43668)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRateHistory() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchFundingRateHistory", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicQFundingRateRecord(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicQFundingRateRecord(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": true,
            //             "items": [
            //                 {
            //                     "id": "210441653482221888",
            //                     "symbol": "btc_usdt",
            //                     "fundingRate": "0.000057",
            //                     "createdTime": 1679875200000,
            //                     "collectionInternal": 28800
            //                 },
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var items interface{} = this.SafeValue(result, "items", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(items)); i++ {
                var entry interface{} = GetValue(items, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var symbolInner interface{} = this.SafeSymbol(marketId, market)
                var timestamp interface{} = this.SafeInteger(entry, "createdTime")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://doc.xt.com/#futures_quotesgetFundingRate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *xt) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes443515 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes443515)
                ch <- retRes443515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://doc.xt.com/#futures_quotesgetFundingRate
 * @param {string} symbol unified market symbol
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *xt) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes44488 := (<-this.LoadMarkets())
            PanicOnError(retRes44488)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchFundingRate", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PublicInverseGetFutureMarketV1PublicQFundingRate(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicLinearGetFutureMarketV1PublicQFundingRate(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "symbol": "btc_usdt",
            //             "fundingRate": "0.000086",
            //             "nextCollectionTime": 1680307200000,
            //             "collectionInternal": 8
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "btc_usdt",
    //         "fundingRate": "0.000086",
    //         "nextCollectionTime": 1680307200000,
    //         "collectionInternal": 8
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_", "swap")
    var timestamp interface{} = this.SafeInteger(contract, "nextCollectionTime")
    var interval interface{} = this.SafeString(contract, "collectionInternal")
    if IsTrue(!IsEqual(interval, nil)) {
        interval = Add(interval, "h")
    }
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": this.SafeNumber(contract, "fundingRate"),
        "fundingTimestamp": timestamp,
        "fundingDatetime": this.Iso8601(timestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": interval,
    }
}
/**
 * @method
 * @name xt#fetchFundingHistory
 * @description fetch the funding history
 * @see https://doc.xt.com/#futures_usergetFunding
 * @param {string} symbol unified market symbol
 * @param {int} [since] the starting timestamp in milliseconds
 * @param {int} [limit] the number of entries to return
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *xt) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes45318 := (<-this.LoadMarkets())
            PanicOnError(retRes45318)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingHistory() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchFundingHistory", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureUserV1BalanceFundingRateList(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateLinearGetFutureUserV1BalanceFundingRateList(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": {
            //             "hasPrev": false,
            //             "hasNext": false,
            //             "items": [
            //                 {
            //                     "id": "210804044057280512",
            //                     "symbol": "btc_usdt",
            //                     "cast": "-0.0013",
            //                     "coin": "usdt",
            //                     "positionSide": "SHORT",
            //                     "createdTime": 1679961600653
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var items interface{} = this.SafeValue(data, "items", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(items)); i++ {
                var entry interface{} = GetValue(items, i)
                AppendToArray(&result,this.ParseFundingHistory(entry, market))
            }
            var sorted interface{} = this.SortBy(result, "timestamp")
        
            ch <- this.FilterBySinceLimit(sorted, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseFundingHistory(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "210804044057280512",
    //         "symbol": "btc_usdt",
    //         "cast": "-0.0013",
    //         "coin": "usdt",
    //         "positionSide": "SHORT",
    //         "createdTime": 1679961600653
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_", "swap")
    var currencyId interface{} = this.SafeString(contract, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var timestamp interface{} = this.SafeInteger(contract, "createdTime")
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(contract, "id"),
        "amount": this.SafeNumber(contract, "cast"),
    }
}
/**
 * @method
 * @name xt#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://doc.xt.com/#futures_usergetPosition
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *xt) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes46228 := (<-this.LoadMarkets())
            PanicOnError(retRes46228)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchPosition", market, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureUserV1PositionList(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateLinearGetFutureUserV1PositionList(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "symbol": "btc_usdt",
            //                 "positionType": "ISOLATED",
            //                 "positionSide": "SHORT",
            //                 "contractType": "PERPETUAL",
            //                 "positionSize": "10",
            //                 "closeOrderSize": "0",
            //                 "availableCloseSize": "10",
            //                 "entryPrice": "27060",
            //                 "openOrderSize": "0",
            //                 "isolatedMargin": "1.0824",
            //                 "openOrderMarginFrozen": "0",
            //                 "realizedProfit": "-0.00130138",
            //                 "autoMargin": false,
            //                 "leverage": 25
            //             },
            //         ]
            //     }
            //
            var positions interface{} = this.SafeValue(response, "result", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                var entry interface{} = GetValue(positions, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var marketInner interface{} = this.SafeMarket(marketId, nil, nil, "contract")
                var positionSize interface{} = this.SafeString(entry, "positionSize")
                if IsTrue(!IsEqual(positionSize, "0")) {
        
                    ch <- this.ParsePosition(entry, marketInner)
                    return nil
                }
            }
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#fetchPositions
 * @description fetch all open positions
 * @see https://doc.xt.com/#futures_usergetPosition
 * @param {string} [symbols] list of unified market symbols, not supported with xt
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *xt) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes46838 := (<-this.LoadMarkets())
            PanicOnError(retRes46838)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("fetchPositions", nil, params);
            subType = GetValue(subTypeparamsVariable,0);
            params = GetValue(subTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(subType, "inverse")) {
                
        response = (<-this.PrivateInverseGetFutureUserV1PositionList(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateLinearGetFutureUserV1PositionList(params))
                PanicOnError(response)
            }
            //
            //     {
            //         "returnCode": 0,
            //         "msgInfo": "success",
            //         "error": null,
            //         "result": [
            //             {
            //                 "symbol": "btc_usdt",
            //                 "positionType": "ISOLATED",
            //                 "positionSide": "SHORT",
            //                 "contractType": "PERPETUAL",
            //                 "positionSize": "10",
            //                 "closeOrderSize": "0",
            //                 "availableCloseSize": "10",
            //                 "entryPrice": "27060",
            //                 "openOrderSize": "0",
            //                 "isolatedMargin": "1.0824",
            //                 "openOrderMarginFrozen": "0",
            //                 "realizedProfit": "-0.00130138",
            //                 "autoMargin": false,
            //                 "leverage": 25
            //             },
            //         ]
            //     }
            //
            var positions interface{} = this.SafeValue(response, "result", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                var entry interface{} = GetValue(positions, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var marketInner interface{} = this.SafeMarket(marketId, nil, nil, "contract")
                AppendToArray(&result,this.ParsePosition(entry, marketInner))
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "btc_usdt",
    //         "positionType": "ISOLATED",
    //         "positionSide": "SHORT",
    //         "contractType": "PERPETUAL",
    //         "positionSize": "10",
    //         "closeOrderSize": "0",
    //         "availableCloseSize": "10",
    //         "entryPrice": "27060",
    //         "openOrderSize": "0",
    //         "isolatedMargin": "1.0824",
    //         "openOrderMarginFrozen": "0",
    //         "realizedProfit": "-0.00130138",
    //         "autoMargin": false,
    //         "leverage": 25
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "contract")
    var positionType interface{} = this.SafeString(position, "positionType")
    var marginMode interface{} = Ternary(IsTrue((IsEqual(positionType, "CROSSED"))), "cross", "isolated")
    var collateral interface{} = this.SafeNumber(position, "isolatedMargin")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "hedged": nil,
        "side": this.SafeStringLower(position, "positionSide"),
        "contracts": this.SafeNumber(position, "positionSize"),
        "contractSize": GetValue(market, "contractSize"),
        "entryPrice": this.SafeNumber(position, "entryPrice"),
        "markPrice": nil,
        "notional": nil,
        "leverage": this.SafeInteger(position, "leverage"),
        "collateral": collateral,
        "initialMargin": collateral,
        "maintenanceMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMarginPercentage": nil,
        "unrealizedPnl": nil,
        "liquidationPrice": nil,
        "marginMode": marginMode,
        "percentage": nil,
        "marginRatio": nil,
    })
}
/**
 * @method
 * @name xt#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://doc.xt.com/#transfersubTransferPost
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from -  spot, swap, leverage, finance
 * @param {string} toAccount account to transfer to - spot, swap, leverage, finance
 * @param {object} params extra parameters specific to the whitebit api endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *xt) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes47938 := (<-this.LoadMarkets())
            PanicOnError(retRes47938)
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsById")
            var fromAccountId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toAccountId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var amountString interface{} = this.CurrencyToPrecision(code, amount)
            var request interface{} = map[string]interface{} {
                "bizId": this.Uuid(),
                "currency": GetValue(currency, "id"),
                "amount": amountString,
                "from": fromAccountId,
                "to": toAccountId,
            }
        
            response:= (<-this.PrivateSpotPostBalanceTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //   {
            //       info: { rc: '0', mc: 'SUCCESS', ma: [], result: '226971333791398656' },
            //       id: '226971333791398656',
            //       timestamp: undefined,
            //       datetime: undefined,
            //       currency: undefined,
            //       amount: undefined,
            //       fromAccount: undefined,
            //       toAccount: undefined,
            //       status: undefined
            //   }
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *xt) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "result"),
        "timestamp": nil,
        "datetime": nil,
        "currency": nil,
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": nil,
    }
}
/**
 * @method
 * @name xt#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://doc.xt.com/#futures_userchangePositionType
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} [symbol] required
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.positionSide] *required* "long" or "short"
 * @returns {object} response from the exchange
 */
func  (this *xt) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
        
            retRes48528 := (<-this.LoadMarkets())
            PanicOnError(retRes48528)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
                panic(BadSymbol(Add(this.Id, " setMarginMode() supports contract markets only")))
            }
            marginMode = ToLower(marginMode)
            if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "cross"))) {
                panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
            }
            if IsTrue(IsEqual(marginMode, "cross")) {
                marginMode = "CROSSED"
            } else {
                marginMode = "ISOLATED"
            }
            var posSide interface{} = this.SafeStringUpper(params, "positionSide")
            if IsTrue(IsEqual(posSide, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a positionSide parameter, either \"LONG\" or \"SHORT\"")))
            }
            var request interface{} = map[string]interface{} {
                "positionType": marginMode,
                "positionSide": posSide,
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateLinearPostFutureUserV1PositionChangeType(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "error": {
            //       "code": "",
            //       "msg": ""
            //     },
            //     "msgInfo": "",
            //     "result": {},
            //     "returnCode": 0
            // }
            //
        ch <- response  // unify return type
            return nil
        
            }()
            return ch
        }
func  (this *xt) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    // spot: error
    //
    //     {
    //         "rc": 1,
    //         "mc": "AUTH_103",
    //         "ma": [],
    //         "result": null
    //     }
    //
    // spot: success
    //
    //     {
    //         "returnCode": 0,
    //         "msgInfo": "success",
    //         "error": null,
    //         "result": []
    //     }
    //
    // swap and future: error
    //
    //     {
    //         "returnCode": 1,
    //         "msgInfo": "failure",
    //         "error": {
    //             "code": "403",
    //             "msg": "invalid signature"
    //         },
    //         "result": null
    //     }
    //
    // swap and future: success
    //
    //     {
    //         "returnCode": 0,
    //         "msgInfo": "success",
    //         "error": null,
    //         "result": null
    //     }
    //
    // other:
    //
    //     {
    //         "rc": 0,
    //         "mc": "SUCCESS",
    //         "ma": [],
    //         "result": {}
    //     }
    //
    // {"returnCode":1,"msgInfo":"failure","error":{"code":"insufficient_balance","msg":"insufficient balance","args":[]},"result":null}
    //
    //
    var status interface{} = this.SafeStringUpper2(response, "msgInfo", "mc")
    if IsTrue(IsTrue(!IsEqual(status, nil)) && IsTrue(!IsEqual(status, "SUCCESS"))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var error interface{} = this.SafeValue(response, "error", map[string]interface{} {})
        var spotErrorCode interface{} = this.SafeString(response, "mc")
        var errorCode interface{} = this.SafeString(error, "code", spotErrorCode)
        var spotMessage interface{} = this.SafeString(response, "msgInfo")
        var message interface{} = this.SafeString(error, "msg", spotMessage)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *xt) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var signed interface{} = IsEqual(GetValue(api, 0), "private")
    var endpoint interface{} = GetValue(api, 1)
    var request interface{} = Add("/", this.ImplodeParams(path, params))
    var payload interface{} = nil
    if IsTrue(IsTrue((IsEqual(endpoint, "spot"))) || IsTrue((IsEqual(endpoint, "user")))) {
        if IsTrue(signed) {
            payload = Add(Add("/", this.Version), request)
        } else {
            payload = Add(Add(Add("/", this.Version), "/public"), request)
        }
    } else {
        payload = request
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), endpoint), payload)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var urlencoded interface{} = this.Urlencode(this.Keysort(query))
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    if IsTrue(signed) {
        this.CheckRequiredCredentials()
        var defaultRecvWindow interface{} = this.SafeString(this.Options, "recvWindow")
        var recvWindow interface{} = this.SafeString(query, "recvWindow", defaultRecvWindow)
        var timestamp interface{} = this.NumberToString(this.Nonce())
        body = query
        if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(payload, "/v4/order"))) || IsTrue((IsEqual(payload, "/future/trade/v1/order/create")))) || IsTrue((IsEqual(payload, "/future/trade/v1/entrust/create-plan")))) || IsTrue((IsEqual(payload, "/future/trade/v1/entrust/create-profit")))) || IsTrue((IsEqual(payload, "/future/trade/v1/order/create-batch")))) {
            var id interface{} = "CCXT"
            if IsTrue(IsGreaterThan(GetIndexOf(payload, "future"), OpNeg(1))) {
                AddElementToObject(body, "clientMedia", id)
            } else {
                AddElementToObject(body, "media", id)
            }
        }
        var isUndefinedBody interface{} =         (IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(path, "order/{orderId}")))) || IsTrue((IsEqual(path, "ws-token"))))
        body = Ternary(IsTrue(isUndefinedBody), nil, this.Json(body))
        var payloadString interface{} = nil
        if IsTrue(IsTrue((IsEqual(endpoint, "spot"))) || IsTrue((IsEqual(endpoint, "user")))) {
            payloadString = Add(Add(Add(Add(Add(Add("xt-validate-algorithms=HmacSHA256&xt-validate-appkey=", this.ApiKey), "&xt-validate-recvwindow="), recvWindow), "&xt-validate-t"), "imestamp="), timestamp)
            if IsTrue(isUndefinedBody) {
                if IsTrue(urlencoded) {
                    url = Add(url, Add("?", urlencoded))
                    payloadString = Add(payloadString, Add(Add(Add(Add(Add("#", method), "#"), payload), "#"), this.Rawencode(this.Keysort(query))))
                } else {
                    payloadString = Add(payloadString, Add(Add(Add("#", method), "#"), payload))
                }
            } else {
                payloadString = Add(payloadString, Add(Add(Add(Add(Add("#", method), "#"), payload), "#"), body))
            }
            AddElementToObject(headers, "xt-validate-algorithms", "HmacSHA256")
            AddElementToObject(headers, "xt-validate-recvwindow", recvWindow)
        } else {
            payloadString = Add(Add(Add(Add("xt-validate-appkey=", this.ApiKey), "&xt-validate-t"), "imestamp="), timestamp) // we can't glue timestamp, breaks in php
            if IsTrue(IsEqual(method, "GET")) {
                if IsTrue(urlencoded) {
                    url = Add(url, Add("?", urlencoded))
                    payloadString = Add(payloadString, Add(Add(Add("#", payload), "#"), urlencoded))
                } else {
                    payloadString = Add(payloadString, Add("#", payload))
                }
            } else {
                payloadString = Add(payloadString, Add(Add(Add("#", payload), "#"), body))
            }
        }
        var signature interface{} = this.Hmac(this.Encode(payloadString), this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "xt-validate-appkey", this.ApiKey)
        AddElementToObject(headers, "xt-validate-timestamp", timestamp)
        AddElementToObject(headers, "xt-validate-signature", signature)
    } else {
        if IsTrue(urlencoded) {
            url = Add(url, Add("?", urlencoded))
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *xt) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
