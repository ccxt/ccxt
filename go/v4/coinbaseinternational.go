package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinbaseinternational struct {
    Exchange

}

func NewCoinbaseinternationalCore() coinbaseinternational {
   p := coinbaseinternational{}
   setDefaults(&p)
   return p
}

func  (this *coinbaseinternational) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinbaseinternational",
        "name": "Coinbase International",
        "countries": []interface{}{"US"},
        "certified": true,
        "pro": true,
        "rateLimit": 100,
        "version": "v1",
        "userAgent": GetValue(this.UserAgents, "chrome"),
        "headers": map[string]interface{} {
            "CB-VERSION": "2018-05-30",
        },
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": true,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": true,
            "createLimitBuyOrder": true,
            "createLimitSellOrder": true,
            "createMarketBuyOrder": true,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrder": true,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "editOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposits": true,
            "fetchFundingHistory": true,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL2OrderBook": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyBuys": true,
            "fetchMySells": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": false,
            "fetchOrders": false,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": false,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMargin": true,
            "setMarginMode": false,
            "setPositionMode": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/866ae638-6ab5-4ebf-ab2c-cdcce9545625",
            "api": map[string]interface{} {
                "rest": "https://api.international.coinbase.com/api",
            },
            "test": map[string]interface{} {
                "rest": "https://api-n5e1.coinbase.com/api",
            },
            "www": "https://international.coinbase.com",
            "doc": []interface{}{"https://docs.cloud.coinbase.com/intx/docs"},
            "fees": []interface{}{"https://help.coinbase.com/en/international-exchange/trading-deposits-withdrawals/international-exchange-fees"},
            "referral": "",
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": []interface{}{"assets", "assets/{assets}", "assets/{asset}/networks", "instruments", "instruments/{instrument}", "instruments/{instrument}/quote", "instruments/{instrument}/funding", "instruments/{instrument}/candles"},
                },
                "private": map[string]interface{} {
                    "get": []interface{}{"orders", "orders/{id}", "portfolios", "portfolios/{portfolio}", "portfolios/{portfolio}/detail", "portfolios/{portfolio}/summary", "portfolios/{portfolio}/balances", "portfolios/{portfolio}/balances/{asset}", "portfolios/{portfolio}/positions", "portfolios/{portfolio}/positions/{instrument}", "portfolios/fills", "portfolios/{portfolio}/fills", "transfers", "transfers/{transfer_uuid}"},
                    "post": []interface{}{"orders", "portfolios", "portfolios/margin", "portfolios/transfer", "transfers/withdraw", "transfers/address", "transfers/create-counterparty-id", "transfers/validate-counterparty-id", "transfers/withdraw/counterparty"},
                    "put": []interface{}{"orders/{id}", "portfolios/{portfolio}"},
                    "delete": []interface{}{"orders", "orders/{id}"},
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "taker": this.ParseNumber("0.004"),
                "maker": this.ParseNumber("0.002"),
                "tierBased": true,
                "percentage": true,
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0035")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0035")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("250000000"), this.ParseNumber("0.0025")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("250000000"), this.ParseNumber("0")}},
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {},
            "broad": map[string]interface{} {
                "DUPLICATE_CLIENT_ORDER_ID": DuplicateOrderId,
                "Order rejected": InvalidOrder,
                "market orders must be IoC": InvalidOrder,
                "tif is required": InvalidOrder,
                "Invalid replace order request": InvalidOrder,
                "Unauthorized": PermissionDenied,
                "invalid result_limit": BadRequest,
                "is a required field": BadRequest,
                "Not Found": BadRequest,
                "ip not allowed": AuthenticationError,
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "ONE_MINUTE",
            "5m": "FIVE_MINUTE",
            "15m": "FIFTEEN_MINUTE",
            "30m": "THIRTY_MINUTE",
            "1h": "ONE_HOUR",
            "2h": "TWO_HOUR",
            "6h": "SIX_HOUR",
            "1d": "ONE_DAY",
        },
        "options": map[string]interface{} {
            "brokerId": "nfqkvdjp",
            "portfolio": "",
            "withdraw": map[string]interface{} {
                "method": "v1PrivatePostTransfersWithdraw",
            },
            "networksById": map[string]interface{} {
                "ethereum": "ETH",
                "arbitrum": "ARBITRUM",
                "avacchain": "AVAX",
                "optimism": "OPTIMISM",
                "polygon": "MATIC",
                "solana": "SOL",
                "bitcoin": "BTC",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": true,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                        "GTC": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": true,
                    "selfTradePrevention": true,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": 10000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 300,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
func  (this *coinbaseinternational) HandlePortfolioAndParams(methodName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var portfolio interface{} = nil
            portfolioparamsVariable := this.HandleOptionAndParams(params, methodName, "portfolio");
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            if IsTrue(IsTrue((!IsEqual(portfolio, nil))) && IsTrue((!IsEqual(portfolio, "")))) {
        
                ch <- []interface{}{portfolio, params}
                return nil
            }
            var defaultPortfolio interface{} = this.SafeString(this.Options, "portfolio")
            if IsTrue(IsTrue((!IsEqual(defaultPortfolio, nil))) && IsTrue((!IsEqual(defaultPortfolio, "")))) {
        
                ch <- []interface{}{defaultPortfolio, params}
                return nil
            }
        
            accounts:= (<-this.FetchAccounts())
            PanicOnError(accounts)
            for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
                var account interface{} = GetValue(accounts, i)
                var info interface{} = this.SafeDict(account, "info", map[string]interface{} {})
                if IsTrue(this.SafeBool(info, "is_default")) {
                    var portfolioId interface{} = this.SafeString(info, "portfolio_id")
                    AddElementToObject(this.Options, "portfolio", portfolioId)
        
                    ch <- []interface{}{portfolioId, params}
                    return nil
                }
            }
            panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a portfolio parameter or set the default portfolio with this.options[\"portfolio\"]")))
        
            }()
            return ch
        }
func  (this *coinbaseinternational) HandleNetworkIdAndParams(currencyCode interface{}, methodName interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var networkId interface{} = nil
            networkIdparamsVariable := this.HandleOptionAndParams(params, methodName, "network_arn_id");
            networkId = GetValue(networkIdparamsVariable,0);
            params = GetValue(networkIdparamsVariable,1)
            if IsTrue(IsEqual(networkId, nil)) {
        
                retRes35812 := (<-this.LoadCurrencyNetworks(currencyCode))
                PanicOnError(retRes35812)
                var networks interface{} = GetValue(GetValue(this.Currencies, currencyCode), "networks")
                var network interface{} = this.SafeString2(params, "networkCode", "network")
                if IsTrue(IsEqual(network, nil)) {
                    // find default network
                    if IsTrue(this.IsEmpty(networks)) {
                        panic(BadRequest(Add(Add(Add(this.Id, " createDepositAddress network not found for currency "), currencyCode), " please specify networkId in params")))
                    }
                    var defaultNetwork interface{} = this.FindDefaultNetwork(networks)
                    networkId = GetValue(defaultNetwork, "id")
                } else {
                    networkId = this.NetworkCodeToId(network, currencyCode)
                }
            }
        
            ch <- []interface{}{networkId, params}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.cloud.coinbase.com/intx/reference/getportfolios
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *coinbaseinternational) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3848 := (<-this.LoadMarkets())
            PanicOnError(retRes3848)
        
            response:= (<-this.V1PrivateGetPortfolios(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //           "portfolio_id":"1ap32qsc-1-0",
            //           "portfolio_uuid":"028d7f6c-b92c-7361-8b7e-2932711e5a22",
            //           "name":"CCXT Portfolio 030624-17:16",
            //           "user_uuid":"e6cf46b6-a32f-5fa7-addb-3324d4526fbd",
            //           "maker_fee_rate":"0",
            //           "taker_fee_rate":"0.0002",
            //           "trading_lock":false,
            //           "borrow_disabled":false,
            //           "is_lsp":false,
            //           "is_default":true,
            //           "cross_collateral_enabled":false
            //        }
            //    ]
            //
        ch <- this.ParseAccounts(response, params)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseAccount(account interface{}) interface{}  {
    //
    //    {
    //       "portfolio_id":"1ap32qsc-1-0",
    //       "portfolio_uuid":"028d7f6c-b92c-7361-8b7e-2932711e5a22",
    //       "name":"CCXT Portfolio 030624-17:16",
    //       "user_uuid":"e6cf46b6-a32f-5fa7-addb-3324d4526fbd",
    //       "maker_fee_rate":"0",
    //       "taker_fee_rate":"0.0002",
    //       "trading_lock":false,
    //       "borrow_disabled":false,
    //       "is_lsp":false,
    //       "is_default":true,
    //       "cross_collateral_enabled":false
    //    }
    //
    return map[string]interface{} {
        "id": this.SafeString2(account, "portfolio_id", "portfolio_uuid"),
        "type": nil,
        "code": nil,
        "info": account,
    }
}
/**
 * @method
 * @name coinbaseinternational#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.cdp.coinbase.com/intx/reference/getinstrumentcandles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch, default 100 max 10000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 */
func  (this *coinbaseinternational) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 100)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4458 := (<-this.LoadMarkets())
            PanicOnError(retRes4458)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes44919 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 10000))
                    PanicOnError(retRes44919)
                    ch <- retRes44919
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
                "granularity": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", this.Iso8601(since))
            } else {
                panic(ArgumentsRequired(Add(this.Id, " fetchOHLCV() requires a since argument")))
            }
            var unitl interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(unitl, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "end", this.Iso8601(unitl))
            }
        
            response:= (<-this.V1PublicGetInstrumentsInstrumentCandles(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   {
            //       "aggregations": [
            //         {
            //           "start": "2024-04-23T00:00:00Z",
            //           "open": "62884.4",
            //           "high": "64710.6",
            //           "low": "62884.4",
            //           "close": "63508.4",
            //           "volume": "3253.9983"
            //         }
            //       ]
            //   }
            //
            var candles interface{} = this.SafeList(response, "aggregations", []interface{}{})
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   {
    //     "start": "2024-04-23T00:00:00Z",
    //     "open": "62884.4",
    //     "high": "64710.6",
    //     "low": "62884.4",
    //     "close": "63508.4",
    //     "volume": "3253.9983"
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString2(ohlcv, "start", "time")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name coinbaseinternational#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.cloud.coinbase.com/intx/reference/getinstrumentfunding
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *coinbaseinternational) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes5228 := (<-this.LoadMarkets())
            PanicOnError(retRes5228)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            var maxEntriesPerRequest interface{} = nil
            maxEntriesPerRequestparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "maxEntriesPerRequest", 100);
            maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
            params = GetValue(maxEntriesPerRequestparamsVariable,1)
            var pageKey interface{} = "ccxtPageKey"
            if IsTrue(paginate) {
        
                    retRes52919 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, pageKey, maxEntriesPerRequest))
                    PanicOnError(retRes52919)
                    ch <- retRes52919
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var page interface{} = Subtract(this.SafeInteger(params, pageKey, 1), 1)
            var request interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
                "result_offset": this.SafeInteger2(params, "offset", "result_offset", Multiply(page, maxEntriesPerRequest)),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "result_limit", limit)
            }
        
            response:= (<-this.V1PublicGetInstrumentsInstrumentFunding(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "pagination":{
            //           "result_limit":"25",
            //           "result_offset":"0"
            //        },
            //        "results":[
            //           {
            //              "instrument_id":"149264167780483072",
            //              "funding_rate":"0.000011",
            //              "mark_price":"47388.1",
            //              "event_time":"2024-02-10T16:00:00Z"
            //           },
            //           ...
            //        ]
            //    }
            //
            var rawRates interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseFundingRateHistories(rawRates, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseFundingRateHistory(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseFundingRate(info, market)
}
func  (this *coinbaseinternational) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "instrument_id":"149264167780483072",
    //       "funding_rate":"0.000011",
    //       "mark_price":"47388.1",
    //       "event_time":"2024-02-10T16:00:00Z"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var fundingDatetime interface{} = this.SafeString2(contract, "event_time", "time")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(nil, market),
        "markPrice": this.SafeNumber(contract, "mark_price"),
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": this.Parse8601(fundingDatetime),
        "datetime": fundingDatetime,
        "fundingRate": this.SafeNumber(contract, "funding_rate"),
        "fundingTimestamp": this.Parse8601(fundingDatetime),
        "fundingDatetime": fundingDatetime,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
    }
}
/**
 * @method
 * @name coinbaseinternational#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://docs.cdp.coinbase.com/intx/reference/gettransfers
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *coinbaseinternational) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6098 := (<-this.LoadMarkets())
            PanicOnError(retRes6098)
            var request interface{} = map[string]interface{} {
                "type": "FUNDING",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var portfolios interface{} = nil
            portfoliosparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "portfolios");
            portfolios = GetValue(portfoliosparamsVariable,0);
            params = GetValue(portfoliosparamsVariable,1)
            if IsTrue(!IsEqual(portfolios, nil)) {
                AddElementToObject(request, "portfolios", portfolios)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time_from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "result_limit", limit)
            } else {
                AddElementToObject(request, "result_limit", 100)
            }
        
            response:= (<-this.V1PrivateGetTransfers(this.Extend(request, params)))
            PanicOnError(response)
            var fundings interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseIncomes(fundings, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "amount":"0.0008",
    //     "asset":"USDC",
    //     "created_at":"2024-02-22T16:00:00Z",
    //     "from_portfolio":{
    //        "id":"13yuk1fs-1-0",
    //        "name":"Eng Test Portfolio - 2",
    //        "uuid":"018712f2-5ff9-7de3-9010-xxxxxxxxx"
    //     },
    //     "instrument_id":"149264164756389888",
    //     "instrument_symbol":"ETH-PERP",
    //     "position_id":"1xy4v51m-1-2",
    //     "status":"PROCESSED",
    //     "to_portfolio":{
    //        "name":"CB_FUND"
    //     },
    //     "transfer_type":"FUNDING",
    //     "transfer_uuid":"a6b708df-2c44-32c5-bb98-xxxxxxxxxx",
    //     "updated_at":"2024-02-22T16:00:00Z"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    market = this.SafeMarket(marketId, market, nil, "contract")
    var datetime interface{} = this.SafeInteger(income, "created_at")
    var timestamp interface{} = this.Parse8601(datetime)
    var currencyId interface{} = this.SafeString(income, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    return map[string]interface{} {
        "info": income,
        "symbol": GetValue(market, "symbol"),
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(income, "transfer_uuid"),
        "amount": this.SafeNumber(income, "amount"),
        "rate": nil,
    }
}
/**
 * @method
 * @name coinbaseinternational#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://docs.cdp.coinbase.com/intx/reference/gettransfers
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coinbaseinternational) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6888 := (<-this.LoadMarkets())
            PanicOnError(retRes6888)
            var request interface{} = map[string]interface{} {
                "type": "INTERNAL",
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var portfolios interface{} = nil
            portfoliosparamsVariable := this.HandleOptionAndParams(params, "fetchTransfers", "portfolios");
            portfolios = GetValue(portfoliosparamsVariable,0);
            params = GetValue(portfoliosparamsVariable,1)
            if IsTrue(!IsEqual(portfolios, nil)) {
                AddElementToObject(request, "portfolios", portfolios)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time_from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "result_limit", limit)
            } else {
                AddElementToObject(request, "result_limit", 100)
            }
        
            response:= (<-this.V1PrivateGetTransfers(this.Extend(request, params)))
            PanicOnError(response)
            var transfers interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseTransfers(transfers, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "amount":"0.0008",
    //     "asset":"USDC",
    //     "created_at":"2024-02-22T16:00:00Z",
    //     "from_portfolio":{
    //        "id":"13yuk1fs-1-0",
    //        "name":"Eng Test Portfolio - 2",
    //        "uuid":"018712f2-5ff9-7de3-9010-xxxxxxxxx"
    //     },
    //     "instrument_id":"149264164756389888",
    //     "instrument_symbol":"ETH-PERP",
    //     "position_id":"1xy4v51m-1-2",
    //     "status":"PROCESSED",
    //     "to_portfolio":{
    //        "name":"CB_FUND"
    //     },
    //     "transfer_type":"FUNDING",
    //     "transfer_uuid":"a6b708df-2c44-32c5-bb98-xxxxxxxxxx",
    //     "updated_at":"2024-02-22T16:00:00Z"
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var datetime interface{} = this.SafeInteger(transfer, "created_at")
    var timestamp interface{} = this.Parse8601(datetime)
    var currencyId interface{} = this.SafeString(transfer, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var fromPorfolio interface{} = this.SafeDict(transfer, "from_portfolio", map[string]interface{} {})
    var fromId interface{} = this.SafeString(fromPorfolio, "id")
    var toPorfolio interface{} = this.SafeDict(transfer, "to_portfolio", map[string]interface{} {})
    var toId interface{} = this.SafeString(toPorfolio, "id")
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transfer_uuid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": code,
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": fromId,
        "toAccount": toId,
        "status": this.ParseTransferStatus(this.SafeString(transfer, "status")),
    }
}
func  (this *coinbaseinternational) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "FAILED": "failed",
        "PROCESSED": "ok",
        "NEW": "pending",
        "STARTED": "pending",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinbaseinternational#createDepositAddress
 * @description create a currency deposit address
 * @see https://docs.cloud.coinbase.com/intx/reference/createaddress
 * @see https://docs.cloud.coinbase.com/intx/reference/createcounterpartyid
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network_arn_id] Identifies the blockchain network (e.g., networks/ethereum-mainnet/assets/313ef8a9-ae5a-5f2f-8a56-572c0e2a4d5a) if not provided will pick default
 * @param {string} [params.network] unified network code to identify the blockchain network
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinbaseinternational) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7818 := (<-this.LoadMarkets())
            PanicOnError(retRes7818)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "createDepositAddress", "method", "v1PrivatePostTransfersAddress");
            method = GetValue(methodparamsVariable,0);
            params = GetValue(methodparamsVariable,1)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("createDepositAddress", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
            }
            if IsTrue(IsEqual(method, "v1PrivatePostTransfersAddress")) {
                var currency interface{} = this.Currency(code)
                AddElementToObject(request, "asset", GetValue(currency, "id"))
                var networkId interface{} = nil
                networkIdparamsVariable := (<-this.HandleNetworkIdAndParams(code, "createDepositAddress", params));
                networkId = GetValue(networkIdparamsVariable,0);
                params = GetValue(networkIdparamsVariable,1)
                AddElementToObject(request, "network_arn_id", networkId)
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
            //
            // v1PrivatePostTransfersAddress
            //    {
            //        address: "3LkwYscRyh6tUR1XTqXSJQoJnK7ucC1F4n",
            //        network_arn_id: "networks/bitcoin-mainnet/assets/6ecc0dcc-10a2-500e-b315-a3b9abae19ce",
            //        destination_tag: "",
            //    }
            // v1PrivatePostTransfersCreateCounterpartyId
            //    {
            //        "portfolio_uuid":"018e0a8b-6b6b-70e0-9689-1e7926c2c8bc",
            //        "counterparty_id":"CB2ZPUCZBE"
            //    }
            //
            var tag interface{} = this.SafeString(response, "destination_tag")
            var address interface{} = this.SafeString2(response, "address", "counterparty_id")
        
            ch <- map[string]interface{} {
                "currency": code,
                "tag": tag,
                "address": address,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) FindDefaultNetwork(networks interface{}) interface{}  {
    var networksArray interface{} = this.ToArray(networks)
    for i := 0; IsLessThan(i, GetArrayLength(networksArray)); i++ {
        var info interface{} = GetValue(GetValue(networksArray, i), "info")
        var is_default interface{} = this.SafeBool(info, "is_default", false)
        if IsTrue(IsEqual(is_default, true)) {
            return GetValue(networksArray, i)
        }
    }
    return GetValue(networksArray, 0)
}
func  (this *coinbaseinternational) LoadCurrencyNetworks(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var currency interface{} = this.Currency(code)
            var networks interface{} = this.SafeDict(currency, "networks")
            if IsTrue(!IsEqual(networks, nil)) {
        
                ch <- false
                return nil
            }
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
            }
        
            rawNetworks:= (<-this.V1PublicGetAssetsAssetNetworks(request))
            PanicOnError(rawNetworks)
            //
            //    [
            //        {
            //            "asset_id":"1",
            //            "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
            //            "asset_name":"USDC",
            //            "network_arn_id":"networks/ethereum-mainnet/assets/9bc140b4-69c3-5fc9-bd0d-b041bcf40039",
            //            "min_withdrawal_amt":"1",
            //            "max_withdrawal_amt":"100000000",
            //            "network_confirms":35,
            //            "processing_time":485,
            //            "is_default":true,
            //            "network_name":"ethereum",
            //            "display_name":"Ethereum"
            //        },
            //        ....
            //    ]
            //
            AddElementToObject(currency, "networks", this.ParseNetworks(rawNetworks))
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseNetworks(networks interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(networks)); i++ {
        var network interface{} = this.Extend(this.ParseNetwork(GetValue(networks, i)), params)
        AddElementToObject(result, GetValue(network, "network"), network)
    }
    return result
}
func  (this *coinbaseinternational) ParseNetwork(network interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "asset_id":"1",
    //        "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
    //        "asset_name":"USDC",
    //        "network_arn_id":"networks/ethereum-mainnet/assets/9bc140b4-69c3-5fc9-bd0d-b041bcf40039",
    //        "min_withdrawal_amt":"1",
    //        "max_withdrawal_amt":"100000000",
    //        "network_confirms":35,
    //        "processing_time":485,
    //        "is_default":true,
    //        "network_name":"ethereum",
    //        "display_name":"Ethereum"
    //    }
    //
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var currencyId interface{} = this.SafeString(network, "asset_name")
    var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
    var networkId interface{} = this.SafeString(network, "network_arn_id")
    var networkIdForCode interface{} = this.SafeStringN(network, []interface{}{"network_name", "display_name", "network_arn_id"}, "")
    return this.SafeNetwork(map[string]interface{} {
        "info": network,
        "id": networkId,
        "name": this.SafeString(network, "display_name"),
        "network": this.NetworkIdToCode(networkIdForCode, currencyCode),
        "active": nil,
        "deposit": nil,
        "withdraw": nil,
        "precision": nil,
        "fee": nil,
        "limits": map[string]interface{} {
            "withdraw": map[string]interface{} {
                "min": this.SafeNumber(network, "min_withdrawal_amt"),
                "max": this.SafeNumber(network, "max_withdrawal_amt"),
            },
            "deposit": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
    })
}
/**
 * @method
 * @name coinbaseinternational#setMargin
 * @description Either adds or reduces margin in order to set the margin to a specific value
 * @see https://docs.cloud.coinbase.com/intx/reference/setportfoliomarginoverride
 * @param {string} symbol unified market symbol of the market to set margin in
 * @param {float} amount the amount to set the margin to
 * @param {object} [params] parameters specific to the exchange API endpoint
 * @returns {object} A [margin structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#add-margin-structure}
 */
func  (this *coinbaseinternational) SetMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("setMargin", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            if IsTrue(!IsEqual(symbol, nil)) {
                panic(BadRequest(Add(this.Id, " setMargin() only allows setting margin to full portfolio")))
            }
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
                "margin_override": amount,
            }
        
                retRes93615 :=  (<-this.V1PrivatePostPortfoliosMargin(this.Extend(request, params)))
                PanicOnError(retRes93615)
                ch <- retRes93615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name exchange#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.cloud.coinbase.com/intx/reference/gettransfers
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
 * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
 * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
 * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseinternational) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9568 := (<-this.LoadMarkets())
            PanicOnError(retRes9568)
            var paginate interface{} = nil
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            var maxEntriesPerRequest interface{} = nil
            maxEntriesPerRequestparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "maxEntriesPerRequest", 100);
            maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
            params = GetValue(maxEntriesPerRequestparamsVariable,1)
            var pageKey interface{} = "ccxtPageKey"
            if IsTrue(paginate) {
        
                    retRes96319 :=  (<-this.FetchPaginatedCallIncremental("fetchDepositsWithdrawals", code, since, limit, params, pageKey, maxEntriesPerRequest))
                    PanicOnError(retRes96319)
                    ch <- retRes96319
                    return nil
            }
            var page interface{} = Subtract(this.SafeInteger(params, pageKey, 1), 1)
            var request interface{} = map[string]interface{} {
                "result_offset": this.SafeInteger2(params, "offset", "result_offset", Multiply(page, maxEntriesPerRequest)),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time_from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                var newLimit interface{} = mathMin(limit, 100)
                AddElementToObject(request, "result_limit", newLimit)
            }
            var portfolios interface{} = nil
            portfoliosparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "portfolios");
            portfolios = GetValue(portfoliosparamsVariable,0);
            params = GetValue(portfoliosparamsVariable,1)
            if IsTrue(!IsEqual(portfolios, nil)) {
                AddElementToObject(request, "portfolios", portfolios)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "time_to", this.Iso8601(until))
            }
        
            response:= (<-this.V1PrivateGetTransfers(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "pagination":{
            //           "result_limit":25,
            //           "result_offset":0
            //        },
            //        "results":[
            //           {
            //              "transfer_uuid":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3",
            //              "transfer_type":"WITHDRAW",
            //              "amount":"1.000000",
            //              "asset":"USDC",
            //              "status":"PROCESSED",
            //              "network_name":"ethereum",
            //              "created_at":"2024-03-14T02:32:18.497795Z",
            //              "updated_at":"2024-03-14T02:35:38.514588Z",
            //              "from_portfolio":{
            //                 "id":"1yun54bb-1-6",
            //                 "uuid":"018e0a8b-6b6b-70e0-9689-1e7926c2c8bc",
            //                 "name":"fungus technology o?Portfolio"
            //              },
            //              "to_address":"0xcdcE79F820BE9d6C5033db5c31d1AE3A8c2399bB"
            //           }
            //        ]
            //    }
            //
            var rawTransactions interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseTransactions(rawTransactions)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchPosition
 * @see https://docs.cloud.coinbase.com/intx/reference/getportfolioposition
 * @description fetch data on an open position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coinbaseinternational) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10278 := (<-this.LoadMarkets())
            PanicOnError(retRes10278)
            symbol = this.Symbol(symbol)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("fetchPosition", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
                "instrument": this.MarketId(symbol),
            }
        
            position:= (<-this.V1PrivateGetPortfoliosPortfolioPositionsInstrument(this.Extend(request, params)))
            PanicOnError(position)
        
                //
            //    {
            //        "symbol":"BTC-PERP",
            //        "instrument_id":"114jqr89-0-0",
            //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //        "vwap":"52482.3",
            //        "net_size":"0",
            //        "buy_order_size":"0.001",
            //        "sell_order_size":"0",
            //        "im_contribution":"0.2",
            //        "unrealized_pnl":"0",
            //        "mark_price":"52406.8",
            //        "entry_vwap":"52472.9"
            //    }
            //
        ch <- this.ParsePosition(position)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "symbol":"BTC-PERP",
    //       "instrument_id":"114jqr89-0-0",
    //       "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
    //       "vwap":"52482.3",
    //       "net_size":"0",
    //       "buy_order_size":"0.001",
    //       "sell_order_size":"0",
    //       "im_contribution":"0.2",
    //       "unrealized_pnl":"0",
    //       "mark_price":"52406.8",
    //       "entry_vwap":"52472.9"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    var quantity interface{} = this.SafeString(position, "net_size")
    market = this.SafeMarket(marketId, market, "-")
    var side interface{} = "long"
    if IsTrue(Precise.StringLe(quantity, "0")) {
        side = "short"
        quantity = Precise.StringMul("-1", quantity)
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "id"),
        "symbol": GetValue(market, "symbol"),
        "entryPrice": nil,
        "markPrice": this.SafeNumber(position, "mark_price"),
        "notional": nil,
        "collateral": nil,
        "unrealizedPnl": this.SafeNumber(position, "unrealized_pnl"),
        "side": side,
        "contracts": this.ParseNumber(quantity),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "timestamp": nil,
        "datetime": nil,
        "hedged": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "initialMargin": this.SafeNumber(position, "im_contribution"),
        "initialMarginPercentage": nil,
        "leverage": nil,
        "liquidationPrice": nil,
        "marginRatio": nil,
        "marginMode": nil,
        "percentage": nil,
    })
}
/**
 * @method
 * @name coinbaseinternational#fetchPositions
 * @see https://docs.cloud.coinbase.com/intx/reference/getportfoliopositions
 * @description fetch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coinbaseinternational) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11158 := (<-this.LoadMarkets())
            PanicOnError(retRes11158)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("fetchPositions", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
            }
        
            response:= (<-this.V1PrivateGetPortfoliosPortfolioPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    [
            //        {
            //           "symbol":"BTC-PERP",
            //           "instrument_id":"114jqr89-0-0",
            //           "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //           "vwap":"52482.3",
            //           "net_size":"0",
            //           "buy_order_size":"0.001",
            //           "sell_order_size":"0",
            //           "im_contribution":"0.2",
            //           "unrealized_pnl":"0",
            //           "mark_price":"52406.8",
            //           "entry_vwap":"52472.9"
            //        }
            //    ]
            //
            var positions interface{} = this.ParsePositions(response)
            if IsTrue(this.IsEmpty(symbols)) {
        
                ch <- positions
                return nil
            }
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(positions, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.cloud.coinbase.com/intx/reference/gettransfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
 * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
 * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
 * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseinternational) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11648 := (<-this.LoadMarkets())
            PanicOnError(retRes11648)
            AddElementToObject(params, "type", "WITHDRAW")
        
                retRes116615 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, params))
                PanicOnError(retRes116615)
                ch <- retRes116615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
 * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
 * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
 * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseinternational) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11858 := (<-this.LoadMarkets())
            PanicOnError(retRes11858)
            AddElementToObject(params, "type", "DEPOSIT")
        
                retRes118715 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, params))
                PanicOnError(retRes118715)
                ch <- retRes118715
                return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PROCESSED": "ok",
        "NEW": "pending",
        "STARTED": "pending",
        "FAILED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinbaseinternational) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "idem":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3"
    //    }
    // const transactionType = this.safeString (transaction, 'type');
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var datetime interface{} = this.SafeString(transaction, "updated_at")
    var fromPorfolio interface{} = this.SafeDict(transaction, "from_portfolio", map[string]interface{} {})
    var addressFrom interface{} = this.SafeStringN(transaction, []interface{}{"from_address", "from_cb_account", this.SafeStringN(fromPorfolio, []interface{}{"id", "uuid", "name"}), "from_counterparty_id"})
    var toPorfolio interface{} = this.SafeDict(transaction, "from_portfolio", map[string]interface{} {})
    var addressTo interface{} = this.SafeStringN(transaction, []interface{}{"to_address", "to_cb_account", this.SafeStringN(toPorfolio, []interface{}{"id", "uuid", "name"}), "to_counterparty_id"})
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "transfer_uuid"),
        "txid": this.SafeString(transaction, "transaction_uuid"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "network": this.NetworkIdToCode(this.SafeString(transaction, "network_name")),
        "address": nil,
        "addressTo": addressTo,
        "addressFrom": addressFrom,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": this.SafeString(transaction, "resource"),
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": this.SafeCurrencyCode(this.SafeString(transaction, "asset"), currency),
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": this.Parse8601(datetime),
        "fee": map[string]interface{} {
            "cost": nil,
            "currency": nil,
        },
    }
}
func  (this *coinbaseinternational) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "portfolio_id":"1wp37qsc-1-0",
    //       "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
    //       "portfolio_name":"CCXT Portfolio 020624-17:16",
    //       "fill_id":"1xbfy19y-1-184",
    //       "exec_id":"280841526207070392",
    //       "order_id":"1xbfv8yw-1-0",
    //       "instrument_id":"114jqr89-0-0",
    //       "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
    //       "symbol":"BTC-PERP",
    //       "match_id":"280841526207053840",
    //       "fill_price":"52500",
    //       "fill_qty":"0.01",
    //       "client_id":"1x59ctku-1-1",
    //       "client_order_id":"ccxt3e4e2a5f-4a89-",
    //       "order_qty":"0.01",
    //       "limit_price":"52500",
    //       "total_filled":"0.01",
    //       "filled_vwap":"52500",
    //       "expire_time":"",
    //       "stop_price":"",
    //       "side":"BUY",
    //       "tif":"GTC",
    //       "stp_mode":"BOTH",
    //       "flags":"",
    //       "fee":"0.105",
    //       "fee_asset":"USDC",
    //       "order_status":"DONE",
    //       "event_time":"2024-02-15T00:43:57.631Z"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var datetime interface{} = this.SafeString(trade, "event_time")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString2(trade, "fill_id", "exec_id"),
        "order": this.SafeString(trade, "order_id"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": this.SafeSymbol(marketId, market),
        "type": nil,
        "side": this.SafeStringLower(trade, "side"),
        "takerOrMaker": nil,
        "price": this.SafeNumber(trade, "fill_price"),
        "amount": this.SafeNumber(trade, "fill_qty"),
        "cost": nil,
        "fee": map[string]interface{} {
            "cost": this.SafeNumber(trade, "fee"),
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "fee_asset")),
        },
    })
}
/**
 * @method
 * @name coinbaseinternational#fetchMarkets
 * @see https://docs.cloud.coinbase.com/intx/reference/getinstruments
 * @description retrieves data on all markets for coinbaseinternational
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinbaseinternational) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetInstruments(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //           "instrument_id":"149264164756389888",
            //           "instrument_uuid":"e9360798-6a10-45d6-af05-67c30eb91e2d",
            //           "symbol":"ETH-PERP",
            //           "type":"PERP",
            //           "base_asset_id":"118059611793145856",
            //           "base_asset_uuid":"d85dce9b-5b73-5c3c-8978-522ce1d1c1b4",
            //           "base_asset_name":"ETH",
            //           "quote_asset_id":"1",
            //           "quote_asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
            //           "quote_asset_name":"USDC",
            //           "base_increment":"0.0001",
            //           "quote_increment":"0.01",
            //           "price_band_percent":"0.02",
            //           "market_order_percent":"0.0075",
            //           "qty_24hr":"44434.8131",
            //           "notional_24hr":"110943454.279785",
            //           "avg_daily_qty":"1099171.6025",
            //           "avg_daily_notional":"2637240145.456987",
            //           "previous_day_qty":"78909.3939",
            //           "open_interest":"1270.749",
            //           "position_limit_qty":"1831.9527",
            //           "position_limit_adq_pct":"0.05",
            //           "replacement_cost":"0.23",
            //           "base_imf":"0.1",
            //           "min_notional_value":"10",
            //           "funding_interval":"3600000000000",
            //           "trading_state":"TRADING",
            //           "quote":{
            //              "best_bid_price":"2490.8",
            //              "best_bid_size":"9.0515",
            //              "best_ask_price":"2490.81",
            //              "best_ask_size":"4.8486",
            //              "trade_price":"2490.39",
            //              "trade_qty":"0.9508",
            //              "index_price":"2490.5",
            //              "mark_price":"2490.8",
            //              "settlement_price":"2490.81",
            //              "limit_up":"2615.42",
            //              "limit_down":"2366.34",
            //              "predicted_funding":"0.000009",
            //              "timestamp":"2024-02-10T16:07:39.454Z"
            //           }
            //        },
            //        ...
            //    ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseMarket(market interface{}) interface{}  {
    //
    //   {
    //       "instrument_id":"149264164756389888",
    //       "instrument_uuid":"e9360798-6a10-45d6-af05-67c30eb91e2d",
    //       "symbol":"ETH-PERP",
    //       "type":"PERP",
    //       "base_asset_id":"118059611793145856",
    //       "base_asset_uuid":"d85dce9b-5b73-5c3c-8978-522ce1d1c1b4",
    //       "base_asset_name":"ETH",
    //       "quote_asset_id":"1",
    //       "quote_asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
    //       "quote_asset_name":"USDC",
    //       "base_increment":"0.0001",
    //       "quote_increment":"0.01",
    //       "price_band_percent":"0.02",
    //       "market_order_percent":"0.0075",
    //       "qty_24hr":"44434.8131",
    //       "notional_24hr":"110943454.279785",
    //       "avg_daily_qty":"1099171.6025",
    //       "avg_daily_notional":"2637240145.456987",
    //       "previous_day_qty":"78909.3939",
    //       "open_interest":"1270.749",
    //       "position_limit_qty":"1831.9527",
    //       "position_limit_adq_pct":"0.05",
    //       "replacement_cost":"0.23",
    //       "base_imf":"0.1",
    //       "min_notional_value":"10",
    //       "funding_interval":"3600000000000",
    //       "trading_state":"TRADING",
    //       "quote":{
    //          "best_bid_price":"2490.8",
    //          "best_bid_size":"9.0515",
    //          "best_ask_price":"2490.81",
    //          "best_ask_size":"4.8486",
    //          "trade_price":"2490.39",
    //          "trade_qty":"0.9508",
    //          "index_price":"2490.5",
    //          "mark_price":"2490.8",
    //          "settlement_price":"2490.81",
    //          "limit_up":"2615.42",
    //          "limit_down":"2366.34",
    //          "predicted_funding":"0.000009",
    //          "timestamp":"2024-02-10T16:07:39.454Z"
    //       }
    //    }
    //
    var marketId interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "base_asset_name")
    var quoteId interface{} = this.SafeString(market, "quote_asset_name")
    var typeId interface{} = this.SafeString(market, "type") // 'SPOT', 'PERP'
    var isSpot interface{} =     (IsEqual(typeId, "SPOT"))
    var fees interface{} = this.Fees
    var symbol interface{} = Add(Add(baseId, "/"), quoteId)
    var settleId interface{} = nil
    if !IsTrue(isSpot) {
        settleId = quoteId
        symbol = Add(symbol, Add(":", quoteId))
    }
    return map[string]interface{} {
        "id": marketId,
        "lowercaseId": ToLower(marketId),
        "symbol": symbol,
        "base": baseId,
        "quote": quoteId,
        "settle": Ternary(IsTrue(settleId), settleId, nil),
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": Ternary(IsTrue(settleId), settleId, nil),
        "type": Ternary(IsTrue(isSpot), "spot", "swap"),
        "spot": isSpot,
        "margin": false,
        "swap": !IsTrue(isSpot),
        "future": false,
        "option": false,
        "active": IsEqual(this.SafeString(market, "trading_state"), "TRADING"),
        "contract": !IsTrue(isSpot),
        "linear": Ternary(IsTrue(isSpot), nil, (IsEqual(settleId, quoteId))),
        "inverse": Ternary(IsTrue(isSpot), nil, (!IsEqual(settleId, quoteId))),
        "taker": GetValue(GetValue(fees, "trading"), "taker"),
        "maker": GetValue(GetValue(fees, "trading"), "maker"),
        "contractSize": Ternary(IsTrue(isSpot), nil, 1),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "base_increment"),
            "price": this.SafeNumber(market, "quote_increment"),
            "cost": this.SafeNumber(market, "quote_increment"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": this.SafeNumber(market, "base_imf"),
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": Ternary(IsTrue(isSpot), nil, this.SafeNumber(market, "position_limit_qty")),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_notional_value"),
                "max": nil,
            },
        },
        "info": market,
        "created": nil,
    }
}
/**
 * @method
 * @name coinbaseinternational#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.cloud.coinbase.com/intx/reference/getassets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinbaseinternational) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            currencies:= (<-this.V1PublicGetAssets(params))
            PanicOnError(currencies)
        
                //
            //    [
            //        {
            //           "asset_id":"1",
            //           "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
            //           "asset_name":"USDC",
            //           "status":"ACTIVE",
            //           "collateral_weight":1.0,
            //           "supported_networks_enabled":true
            //        },
            //        ...
            //    ]
            //
        ch <- this.ParseCurrencies(currencies)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseCurrency(currency interface{}) interface{}  {
    //
    //    {
    //       "asset_id":"1",
    //       "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
    //       "asset_name":"USDC",
    //       "status":"ACTIVE",
    //       "collateral_weight":1.0,
    //       "supported_networks_enabled":true
    //    }
    //
    var id interface{} = this.SafeString(currency, "asset_name")
    var code interface{} = this.SafeCurrencyCode(id)
    var statusId interface{} = this.SafeString(currency, "status")
    return this.SafeCurrencyStructure(map[string]interface{} {
        "id": id,
        "name": code,
        "code": code,
        "precision": nil,
        "info": currency,
        "active": (IsEqual(statusId, "ACTIVE")),
        "deposit": nil,
        "withdraw": nil,
        "networks": nil,
        "fee": nil,
        "fees": nil,
        "limits": this.Limits,
    })
}
/**
 * @method
 * @name coinbaseinternational#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.cloud.coinbase.com/intx/reference/getinstruments
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinbaseinternational) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15338 := (<-this.LoadMarkets())
            PanicOnError(retRes15338)
            symbols = this.MarketSymbols(symbols)
        
            instruments:= (<-this.V1PublicGetInstruments(params))
            PanicOnError(instruments)
            var tickers interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(instruments)); i++ {
                var instrument interface{} = GetValue(instruments, i)
                var marketId interface{} = this.SafeString(instrument, "symbol")
                var symbol interface{} = this.SafeSymbol(marketId)
                var quote interface{} = this.SafeDict(instrument, "quote", map[string]interface{} {})
                AddElementToObject(tickers, symbol, this.ParseTicker(quote, this.SafeMarket(marketId)))
            }
        
            ch <- this.FilterByArray(tickers, "symbol", symbols, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.cloud.coinbase.com/intx/reference/getinstrumentquote
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinbaseinternational) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15578 := (<-this.LoadMarkets())
            PanicOnError(retRes15578)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": this.MarketId(symbol),
            }
        
            ticker:= (<-this.V1PublicGetInstrumentsInstrumentQuote(this.Extend(request, params)))
            PanicOnError(ticker)
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "best_bid_price":"2490.8",
    //        "best_bid_size":"9.0515",
    //        "best_ask_price":"2490.81",
    //        "best_ask_size":"4.8486",
    //        "trade_price":"2490.39",
    //        "trade_qty":"0.9508",
    //        "index_price":"2490.5",
    //        "mark_price":"2490.8",
    //        "settlement_price":"2490.81",
    //        "limit_up":"2615.42",
    //        "limit_down":"2366.34",
    //        "predicted_funding":"0.000009",
    //        "timestamp":"2024-02-10T16:07:39.454Z"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(ticker, "timestamp")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(nil, market),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "bid": this.SafeNumber(ticker, "best_bid_price"),
        "bidVolume": this.SafeNumber(ticker, "best_bid_size"),
        "ask": this.SafeNumber(ticker, "best_ask_price"),
        "askVolume": this.SafeNumber(ticker, "best_ask_size"),
        "high": nil,
        "low": nil,
        "open": nil,
        "close": nil,
        "last": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "vwap": nil,
        "baseVolume": nil,
        "quoteVolume": nil,
        "previousClose": nil,
        "markPrice": this.SafeNumber(ticker, "mark_price"),
        "indexPrice": this.SafeNumber(ticker, "index_price"),
    })
}
/**
 * @method
 * @name coinbaseinternational#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.cloud.coinbase.com/intx/reference/getportfoliobalances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.v3] default false, set true to use v3 api endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinbaseinternational) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16218 := (<-this.LoadMarkets())
            PanicOnError(retRes16218)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("fetchBalance", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
            }
        
            balances:= (<-this.V1PrivateGetPortfoliosPortfolioBalances(this.Extend(request, params)))
            PanicOnError(balances)
        
                //
            //    [
            //        {
            //           "asset_id":"0-0-1",
            //           "asset_name":"USDC",
            //           "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
            //           "quantity":"500000.0000000000",
            //           "hold":"0",
            //           "hold_available_for_collateral":"0",
            //           "transfer_hold":"0",
            //           "collateral_value":"500000.0",
            //           "max_withdraw_amount":"500000.0000000000",
            //           "loan":"0",
            //           "loan_collateral_requirement":"0.0"
            //        }
            //    ]
            //
        ch <- this.ParseBalance(balances)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseBalance(response interface{}) interface{}  {
    //
    //    {
    //       "asset_id":"0-0-1",
    //       "asset_name":"USDC",
    //       "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
    //       "quantity":"500000.0000000000",
    //       "hold":"0",
    //       "hold_available_for_collateral":"0",
    //       "transfer_hold":"0",
    //       "collateral_value":"500000.0",
    //       "max_withdraw_amount":"500000.0000000000",
    //       "loan":"0",
    //       "loan_collateral_requirement":"0.0"
    //    }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var rawBalance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(rawBalance, "asset_name")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(rawBalance, "quantity"))
        AddElementToObject(account, "used", this.SafeString(rawBalance, "hold"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinbaseinternational#transfer
 * @description Transfer an amount of asset from one portfolio to another.
 * @see https://docs.cloud.coinbase.com/intx/reference/createportfolioassettransfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transfer-structure}
 */
func  (this *coinbaseinternational) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16928 := (<-this.LoadMarkets())
            PanicOnError(retRes16928)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "ammount": amount,
                "from": fromAccount,
                "to": toAccount,
            }
        
            response:= (<-this.V1PrivatePostPortfoliosTransfer(this.Extend(request, params)))
            PanicOnError(response)
            var success interface{} = this.SafeBool(response, "success")
        
            ch <- map[string]interface{} {
                "info": response,
                "id": nil,
                "timestamp": nil,
                "datetime": nil,
                "currency": code,
                "amount": amount,
                "fromAccount": fromAccount,
                "toAccount": toAccount,
                "status": Ternary(IsTrue(success), "ok", "failed"),
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#createOrder
 * @description create a trade order
 * @see https://docs.cloud.coinbase.com/intx/reference/createorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
 * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.stopPrice] alias for triggerPrice
 * @param {float} [params.triggerPrice] price to trigger stop orders
 * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
 * @param {bool} [params.postOnly] true or false
 * @param {string} [params.tif] 'GTC', 'IOC', 'GTD' default is 'GTC' for limit orders and 'IOC' for market orders
 * @param {string} [params.expire_time] The expiration time required for orders with the time in force set to GTT. Must not go beyond 30 days of the current time. Uses ISO-8601 format (e.g., 2023-03-16T23:59:53Z)
 * @param {string} [params.stp_mode] Possible values: [NONE, AGGRESSING, BOTH] Specifies the behavior for self match handling. None disables the functionality, new cancels the newest order, and both cancels both orders.
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17368 := (<-this.LoadMarkets())
            PanicOnError(retRes17368)
            var market interface{} = this.Market(symbol)
            var typeId interface{} = ToUpper(typeVar)
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "stop_price"})
            var clientOrderIdprefix interface{} = this.SafeString(this.Options, "brokerId", "nfqkvdjp")
            var clientOrderId interface{} = Add(Add(clientOrderIdprefix, "-"), this.Uuid())
            clientOrderId = Slice(clientOrderId, 0, 17)
            var request interface{} = map[string]interface{} {
                "client_order_id": clientOrderId,
                "side": ToUpper(side),
                "instrument": GetValue(market, "id"),
                "size": this.AmountToPrecision(GetValue(market, "symbol"), amount),
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                if IsTrue(IsEqual(typeVar, "limit")) {
                    typeId = "STOP_LIMIT"
                } else {
                    typeId = "STOP"
                }
                AddElementToObject(request, "stop_price", triggerPrice)
            }
            AddElementToObject(request, "type", typeId)
            if IsTrue(IsEqual(typeVar, "limit")) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires a price parameter for a limit order types")))
                }
                AddElementToObject(request, "price", price)
            }
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("createOrder", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            if IsTrue(!IsEqual(portfolio, nil)) {
                AddElementToObject(request, "portfolio", portfolio)
            }
            var postOnly interface{} = this.SafeBool2(params, "postOnly", "post_only")
            var tif interface{} = this.SafeString2(params, "tif", "timeInForce")
            // market orders must be IOC
            if IsTrue(IsEqual(typeId, "MARKET")) {
                if IsTrue(IsTrue(!IsEqual(tif, nil)) && IsTrue(!IsEqual(tif, "IOC"))) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() market orders must have tif set to \"IOC\"")))
                }
                tif = "IOC"
            } else {
                tif = Ternary(IsTrue((IsEqual(tif, nil))), "GTC", tif)
            }
            if IsTrue(!IsEqual(postOnly, nil)) {
                AddElementToObject(request, "post_only", postOnly)
            }
            AddElementToObject(request, "tif", tif)
            params = this.Omit(params, []interface{}{"client_order_id", "user", "postOnly", "timeInForce"})
        
            response:= (<-this.V1PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "order_id":"1x96skvg-1-0",
            //        "client_order_id":"ccxt",
            //        "side":"BUY",
            //        "instrument_id":"114jqr89-0-0",
            //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //        "symbol":"BTC-PERP",
            //        "portfolio_id":"1wp37qsc-1-0",
            //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
            //        "type":"LIMIT",
            //        "price":"10000",
            //        "size":"0.001",
            //        "tif":"GTC",
            //        "stp_mode":"BOTH",
            //        "event_type":"NEW",
            //        "order_status":"WORKING",
            //        "leaves_qty":"0.001",
            //        "exec_qty":"0",
            //        "avg_price":"0",
            //        "fee":"0"
            //    }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "order_id":"1x96skvg-1-0",
    //        "client_order_id":"ccxt",
    //        "side":"BUY",
    //        "instrument_id":"114jqr89-0-0",
    //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
    //        "symbol":"BTC-PERP",
    //        "portfolio_id":"1wp37qsc-1-0",
    //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
    //        "type":"LIMIT",
    //        "price":"10000",
    //        "size":"0.001",
    //        "tif":"GTC",
    //        "stp_mode":"BOTH",
    //        "event_type":"NEW",
    //        "order_status":"WORKING",
    //        "leaves_qty":"0.001",
    //        "exec_qty":"0",
    //        "avg_price":"0",
    //        "fee":"0"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var feeCost interface{} = this.SafeNumber(order, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
        }
    }
    var datetime interface{} = this.SafeString2(order, "submit_time", "event_time")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastTradeTimestamp": nil,
        "symbol": this.SafeSymbol(marketId, market),
        "type": this.ParseOrderType(this.SafeString(order, "type")),
        "timeInForce": this.SafeString(order, "tif"),
        "postOnly": nil,
        "side": this.SafeStringLower(order, "side"),
        "price": this.SafeString(order, "price"),
        "triggerPrice": this.SafeString(order, "stop_price"),
        "amount": this.SafeString(order, "size"),
        "filled": this.SafeString(order, "exec_qty"),
        "remaining": this.SafeString(order, "leaves_qty"),
        "cost": nil,
        "average": this.SafeString(order, "avg_price"),
        "status": this.ParseOrderStatus(this.SafeString(order, "order_status")),
        "fee": fee,
        "trades": nil,
    }, market)
}
func  (this *coinbaseinternational) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIAL_FILLED": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "REPLACED": "canceled",
        "PENDING_CANCEL": "open",
        "REJECTED": "rejected",
        "PENDING_NEW": "open",
        "EXPIRED": "expired",
        "PENDING_REPLACE": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinbaseinternational) ParseOrderType(typeVar interface{}) interface{}  {
    if IsTrue(IsEqual(typeVar, "UNKNOWN_ORDER_TYPE")) {
        return nil
    }
    var types interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "STOP": "limit",
        "STOP_LIMIT": "limit",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name coinbaseinternational#cancelOrder
 * @description cancels an open order
 * @see https://docs.cloud.coinbase.com/intx/reference/cancelorder
 * @param {string} id order id
 * @param {string} symbol not used by coinbaseinternational cancelOrder()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19108 := (<-this.LoadMarkets())
            PanicOnError(retRes19108)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("cancelOrder", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
                "id": id,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            orders:= (<-this.V1PrivateDeleteOrdersId(this.Extend(request, params)))
            PanicOnError(orders)
        
                //
            //    {
            //        "order_id":"1x96skvg-1-0",
            //        "client_order_id":"ccxt",
            //        "side":"BUY",
            //        "instrument_id":"114jqr89-0-0",
            //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //        "symbol":"BTC-PERP",
            //        "portfolio_id":"1wp37qsc-1-0",
            //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
            //        "type":"LIMIT",
            //        "price":"10000",
            //        "size":"0.001",
            //        "tif":"GTC",
            //        "stp_mode":"BOTH",
            //        "event_type":"CANCELED",
            //        "order_status":"DONE",
            //        "leaves_qty":"0.001",
            //        "exec_qty":"0",
            //        "avg_price":"0",
            //        "fee":"0"
            //    }
            //
        ch <- this.ParseOrder(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#cancelAllOrders
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19578 := (<-this.LoadMarkets())
            PanicOnError(retRes19578)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("cancelAllOrders", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
            }
            var market interface{} = nil
            if IsTrue(symbol) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument", GetValue(market, "id"))
            }
        
            orders:= (<-this.V1PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(orders)
        
            ch <- this.ParseOrders(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#editOrder
 * @description edit a trade order
 * @see https://docs.cloud.coinbase.com/intx/reference/modifyorder
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.clientOrderId client order id
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes19888 := (<-this.LoadMarkets())
            PanicOnError(retRes19888)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("editOrder", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            if IsTrue(!IsEqual(portfolio, nil)) {
                AddElementToObject(request, "portfolio", portfolio)
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"stopPrice", "stop_price", "triggerPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop_price", triggerPrice)
            }
            var clientOrderId interface{} = this.SafeString2(params, "client_order_id", "clientOrderId")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                panic(BadRequest(Add(this.Id, " editOrder() requires a clientOrderId parameter")))
            }
            AddElementToObject(request, "client_order_id", clientOrderId)
        
            order:= (<-this.V1PrivatePutOrdersId(this.Extend(request, params)))
            PanicOnError(order)
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.cloud.coinbase.com/intx/reference/modifyorder
 * @param {string} id the order id
 * @param {string} symbol unified market symbol that the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20288 := (<-this.LoadMarkets())
            PanicOnError(retRes20288)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("fetchOrder", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "id": id,
                "portfolio": portfolio,
            }
        
            order:= (<-this.V1PrivateGetOrdersId(this.Extend(request, params)))
            PanicOnError(order)
        
                //
            //    {
            //        "order_id":"1x96skvg-1-0",
            //        "client_order_id":"ccxt",
            //        "side":"BUY",
            //        "instrument_id":"114jqr89-0-0",
            //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //        "symbol":"BTC-PERP",
            //        "portfolio_id":"1wp37qsc-1-0",
            //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
            //        "type":"LIMIT",
            //        "price":"10000",
            //        "size":"0.001",
            //        "tif":"GTC",
            //        "stp_mode":"BOTH",
            //        "event_type":"NEW",
            //        "event_time":"2024-02-14T03:25:14Z",
            //        "submit_time":"2024-02-14T03:25:13.999Z",
            //        "order_status":"WORKING",
            //        "leaves_qty":"0.001",
            //        "exec_qty":"0",
            //        "avg_price":"0",
            //        "fee":"0"
            //    }
            //
        ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchOpenOrders
 * @description fetches information on all currently open orders
 * @see https://docs.cloud.coinbase.com/intx/reference/getorders
 * @param {string} symbol unified market symbol of the orders
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {int} [params.offset] offset
 * @param {string} [params.event_type] The most recent type of event that happened to the order. Allowed values: NEW, TRADE, REPLACED
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseinternational) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20838 := (<-this.LoadMarkets())
            PanicOnError(retRes20838)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("fetchOpenOrders", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            var maxEntriesPerRequest interface{} = nil
            maxEntriesPerRequestparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "maxEntriesPerRequest", 100);
            maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
            params = GetValue(maxEntriesPerRequestparamsVariable,1)
            var pageKey interface{} = "ccxtPageKey"
            if IsTrue(paginate) {
        
                    retRes209219 :=  (<-this.FetchPaginatedCallIncremental("fetchOpenOrders", symbol, since, limit, params, pageKey, maxEntriesPerRequest))
                    PanicOnError(retRes209219)
                    ch <- retRes209219
                    return nil
            }
            var page interface{} = Subtract(this.SafeInteger(params, pageKey, 1), 1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
                "result_offset": this.SafeInteger2(params, "offset", "result_offset", Multiply(page, maxEntriesPerRequest)),
            }
            var market interface{} = nil
            if IsTrue(symbol) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument", symbol)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 100)) {
                    panic(BadRequest(Add(this.Id, " fetchOpenOrders() maximum limit is 100")))
                }
                AddElementToObject(request, "result_limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "ref_datetime", this.Iso8601(since))
            }
        
            response:= (<-this.V1PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "pagination":{
            //           "result_limit":25,
            //           "result_offset":0
            //        },
            //        "results":[
            //           {
            //              "order_id":"1y4cm6b4-1-0",
            //              "client_order_id":"ccxtd0dd4b5d-8e5f-",
            //              "side":"SELL",
            //              "instrument_id":"114jqr89-0-0",
            //              "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //              "symbol":"BTC-PERP",
            //              "portfolio_id":"1wp37qsc-1-0",
            //              "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
            //              "type":"LIMIT",
            //              "price":"54000",
            //              "size":"0.01",
            //              "tif":"GTC",
            //              "stp_mode":"BOTH",
            //              "event_type":"NEW",
            //              "event_time":"2024-02-24T16:46:37.413Z",
            //              "submit_time":"2024-02-24T16:46:37.412Z",
            //              "order_status":"WORKING",
            //              "leaves_qty":"0.01",
            //              "exec_qty":"0",
            //              "avg_price":"0",
            //              "fee":"0"
            //           },
            //           ...
            //        ]
            //    }
            //
            var rawOrders interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseOrders(rawOrders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.cloud.coinbase.com/intx/reference/getmultiportfoliofills
 * @param {string} symbol unified market symbol of the trades
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] the maximum number of trade structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinbaseinternational) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21668 := (<-this.LoadMarkets())
            PanicOnError(retRes21668)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            var pageKey interface{} = "ccxtPageKey"
            var maxEntriesPerRequest interface{} = nil
            maxEntriesPerRequestparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "maxEntriesPerRequest", 100);
            maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
            params = GetValue(maxEntriesPerRequestparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes217319 :=  (<-this.FetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, params, pageKey, maxEntriesPerRequest))
                    PanicOnError(retRes217319)
                    ch <- retRes217319
                    return nil
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var page interface{} = Subtract(this.SafeInteger(params, pageKey, 1), 1)
            var request interface{} = map[string]interface{} {
                "result_offset": this.SafeInteger2(params, "offset", "result_offset", Multiply(page, maxEntriesPerRequest)),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 100)) {
                    panic(BadRequest(Add(this.Id, " fetchMyTrades() maximum limit is 100. Consider setting paginate to true to fetch more trades.")))
                }
                AddElementToObject(request, "result_limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time_from", this.Iso8601(since))
            }
            var until interface{} = this.SafeStringN(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "ref_datetime", this.Iso8601(until))
            }
        
            response:= (<-this.V1PrivateGetPortfoliosFills(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "pagination":{
            //           "result_limit":25,
            //           "result_offset":0
            //        },
            //        "results":[
            //           {
            //              "portfolio_id":"1wp37qsc-1-0",
            //              "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
            //              "portfolio_name":"CCXT Portfolio 020624-17:16",
            //              "fill_id":"1xbfy19y-1-184",
            //              "exec_id":"280841526207070392",
            //              "order_id":"1xbfv8yw-1-0",
            //              "instrument_id":"114jqr89-0-0",
            //              "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
            //              "symbol":"BTC-PERP",
            //              "match_id":"280841526207053840",
            //              "fill_price":"52500",
            //              "fill_qty":"0.01",
            //              "client_id":"1x59ctku-1-1",
            //              "client_order_id":"ccxt3e4e2a5f-4a89-",
            //              "order_qty":"0.01",
            //              "limit_price":"52500",
            //              "total_filled":"0.01",
            //              "filled_vwap":"52500",
            //              "expire_time":"",
            //              "stop_price":"",
            //              "side":"BUY",
            //              "tif":"GTC",
            //              "stp_mode":"BOTH",
            //              "flags":"",
            //              "fee":"0.105",
            //              "fee_asset":"USDC",
            //              "order_status":"DONE",
            //              "event_time":"2024-02-15T00:43:57.631Z"
            //           },
            //        ]
            //    }
            //
            var trades interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#withdraw
 * @description make a withdrawal
 * @see https://docs.cloud.coinbase.com/intx/reference/withdraw
 * @see https://docs.cloud.coinbase.com/intx/reference/counterpartywithdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} [tag] an optional tag for the withdrawal
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.add_network_fee_to_total] if true, deducts network fee from the portfolio, otherwise deduct fee from the withdrawal
 * @param {string} [params.network_arn_id] Identifies the blockchain network (e.g., networks/ethereum-mainnet/assets/313ef8a9-ae5a-5f2f-8a56-572c0e2a4d5a)
 * @param {string} [params.nonce] a unique integer representing the withdrawal request
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseinternational) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes22618 := (<-this.LoadMarkets())
            PanicOnError(retRes22618)
            var currency interface{} = this.Currency(code)
            var portfolio interface{} = nil
            portfolioparamsVariable := (<-this.HandlePortfolioAndParams("withdraw", params));
            portfolio = GetValue(portfolioparamsVariable,0);
            params = GetValue(portfolioparamsVariable,1)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "withdraw", "method", "v1PrivatePostTransfersWithdraw");
            method = GetValue(methodparamsVariable,0);
            params = GetValue(methodparamsVariable,1)
            var networkId interface{} = nil
            networkIdparamsVariable := (<-this.HandleNetworkIdAndParams(code, "withdraw", params));
            networkId = GetValue(networkIdparamsVariable,0);
            params = GetValue(networkIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "portfolio": portfolio,
                "type": "send",
                "asset": GetValue(currency, "id"),
                "address": address,
                "amount": amount,
                "currency": GetValue(currency, "id"),
                "network_arn_id": networkId,
                "nonce": this.Nonce(),
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "idem":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3"
            //    }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseinternational) SafeNetwork(network interface{}) interface{}  {
    var withdrawEnabled interface{} = this.SafeBool(network, "withdraw")
    var depositEnabled interface{} = this.SafeBool(network, "deposit")
    var limits interface{} = this.SafeDict(network, "limits")
    var withdraw interface{} = this.SafeDict(limits, "withdraw")
    var withdrawMax interface{} = this.SafeNumber(withdraw, "max")
    var deposit interface{} = this.SafeDict(limits, "deposit")
    var depositMax interface{} = this.SafeNumber(deposit, "max")
    if IsTrue(IsTrue(IsEqual(withdrawEnabled, nil)) && IsTrue(!IsEqual(withdrawMax, nil))) {
        withdrawEnabled = (IsGreaterThan(withdrawMax, 0))
    }
    if IsTrue(IsTrue(IsEqual(depositEnabled, nil)) && IsTrue(!IsEqual(depositMax, nil))) {
        depositEnabled = (IsGreaterThan(depositMax, 0))
    }
    var networkId interface{} = this.SafeString(network, "id")
    var isEnabled interface{} =     (IsTrue(withdrawEnabled) && IsTrue(depositEnabled))
    return map[string]interface{} {
        "info": GetValue(network, "info"),
        "id": networkId,
        "name": this.SafeString(network, "name"),
        "network": this.SafeString(network, "network"),
        "active": this.SafeBool(network, "active", isEnabled),
        "deposit": depositEnabled,
        "withdraw": withdrawEnabled,
        "fee": this.SafeNumber(network, "fee"),
        "precision": this.SafeNumber(network, "precision"),
        "limits": map[string]interface{} {
            "withdraw": map[string]interface{} {
                "min": this.SafeNumber(withdraw, "min"),
                "max": withdrawMax,
            },
            "deposit": map[string]interface{} {
                "min": this.SafeNumber(deposit, "min"),
                "max": depositMax,
            },
        },
    }
}
func  (this *coinbaseinternational) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(api, 0)
    var signed interface{} = IsEqual(GetValue(api, 1), "private")
    var fullPath interface{} = Add(Add(Add("/", version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var savedPath interface{} = Add("/api", fullPath)
    if IsTrue(IsTrue(IsEqual(method, "GET")) || IsTrue(IsEqual(method, "DELETE"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            fullPath = Add(fullPath, Add("?", this.UrlencodeWithArrayRepeat(query)))
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), fullPath)
    if IsTrue(signed) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var payload interface{} = ""
        if IsTrue(!IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                payload = body
            }
        }
        var auth interface{} = Add(Add(Add(nonce, method), savedPath), payload)
        var signature interface{} = this.Hmac(this.Encode(auth), this.Base64ToBinary(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "CB-ACCESS-TIMESTAMP": nonce,
            "CB-ACCESS-SIGN": signature,
            "CB-ACCESS-PASSPHRASE": this.Password,
            "CB-ACCESS-KEY": this.ApiKey,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinbaseinternational) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    //    {
    //        "title":"io.javalin.http.BadRequestResponse: Order rejected (DUPLICATE_CLIENT_ORDER_ID - duplicate client order id detected)",
    //        "status":400
    //    }
    //
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var errMsg interface{} = this.SafeString(response, "title")
    if IsTrue(!IsEqual(errMsg, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errMsg, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errMsg, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinbaseinternational) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
