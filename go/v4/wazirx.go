package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type wazirx struct {
    Exchange

}

func NewWazirxCore() wazirx {
   p := wazirx{}
   setDefaults(&p)
   return p
}

func  (this *wazirx) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "wazirx",
        "name": "WazirX",
        "countries": []interface{}{"IN"},
        "version": "v2",
        "rateLimit": 1000,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRates": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchLeverage": false,
            "fetchLeverages": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarginModes": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrices": false,
            "fetchMyLiquidations": false,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOption": false,
            "fetchOptionChain": false,
            "fetchOrder": false,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/148647666-c109c20b-f8ac-472f-91c3-5f658cb90f49.jpeg",
            "api": map[string]interface{} {
                "rest": "https://api.wazirx.com/sapi/v1",
            },
            "www": "https://wazirx.com",
            "doc": "https://docs.wazirx.com/#public-rest-api-for-wazirx",
            "fees": "https://wazirx.com/fees",
            "referral": "https://wazirx.com/invite/k7rrnks5",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "exchangeInfo": 1,
                    "depth": 0.5,
                    "ping": 1,
                    "systemStatus": 1,
                    "tickers/24hr": 1,
                    "ticker/24hr": 1,
                    "time": 1,
                    "trades": 1,
                    "klines": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account": 1,
                    "allOrders": 1,
                    "funds": 1,
                    "historicalTrades": 1,
                    "openOrders": 1,
                    "order": 0.5,
                    "myTrades": 0.5,
                    "coins": 12,
                    "crypto/withdraws": 12,
                    "crypto/deposits/address": 60,
                    "sub_account/fund_transfer/history": 1,
                    "sub_account/accounts": 1,
                },
                "post": map[string]interface{} {
                    "order": 0.1,
                    "order/test": 0.5,
                },
                "delete": map[string]interface{} {
                    "order": 0.1,
                    "openOrders": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "WRX": map[string]interface{} {
                "maker": this.ParseNumber("0.0"),
                "taker": this.ParseNumber("0.0"),
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1121": BadSymbol,
                "1999": BadRequest,
                "2002": InsufficientFunds,
                "2005": BadRequest,
                "2078": PermissionDenied,
                "2098": BadRequest,
                "2031": InvalidOrder,
                "2113": BadRequest,
                "2115": BadRequest,
                "2136": RateLimitExceeded,
                "94001": InvalidOrder,
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
        },
        "options": map[string]interface{} {
            "recvWindow": 10000,
            "networks": map[string]interface{} {},
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name wazirx#fetchMarkets
 * @see https://docs.wazirx.com/#exchange-info
 * @description retrieves data on all markets for wazirx
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *wazirx) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetExchangeInfo(params))
            PanicOnError(response)
            //
            // {
            //     "timezone":"UTC",
            //     "serverTime":1641336850932,
            //     "symbols":[
            //     {
            //         "symbol":"btcinr",
            //         "status":"trading",
            //         "baseAsset":"btc",
            //         "quoteAsset":"inr",
            //         "baseAssetPrecision":5,
            //         "quoteAssetPrecision":0,
            //         "orderTypes":[
            //             "limit",
            //             "stop_limit"
            //         ],
            //         "isSpotTradingAllowed":true,
            //         "filters":[
            //             {
            //                 "filterType":"PRICE_FILTER",
            //                 "minPrice":"1",
            //                 "tickSize":"1"
            //             }
            //         ]
            //     },
            //
            var markets interface{} = this.SafeValue(response, "symbols", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "baseAsset")
    var quoteId interface{} = this.SafeString(market, "quoteAsset")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var isSpot interface{} = this.SafeValue(market, "isSpotTradingAllowed")
    var filters interface{} = this.SafeValue(market, "filters")
    var minPrice interface{} = nil
    for j := 0; IsLessThan(j, GetArrayLength(filters)); j++ {
        var filter interface{} = GetValue(filters, j)
        var filterType interface{} = this.SafeString(filter, "filterType")
        if IsTrue(IsEqual(filterType, "PRICE_FILTER")) {
            minPrice = this.SafeNumber(filter, "minPrice")
        }
    }
    var fee interface{} = this.SafeValue(this.Fees, quote, map[string]interface{} {})
    var takerString interface{} = this.SafeString(fee, "taker", "0.2")
    takerString = Precise.StringDiv(takerString, "100")
    var makerString interface{} = this.SafeString(fee, "maker", "0.2")
    makerString = Precise.StringDiv(makerString, "100")
    var status interface{} = this.SafeString(market, "status")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": isSpot,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsEqual(status, "trading")),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.ParseNumber(takerString),
        "maker": this.ParseNumber(makerString),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetPrecision"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quoteAssetPrecision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": minPrice,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name wazirx#fetchOHLCV
 * @see https://docs.wazirx.com/#kline-candlestick-data
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents. Available values [1m,5m,15m,30m,1h,2h,4h,6h,12h,1d,1w]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in s of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *wazirx) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3978 := (<-this.LoadMarkets())
            PanicOnError(retRes3978)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 2000))
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", this.ParseToInt(Divide(since, 1000)))
            }
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PublicGetKlines(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //        [1669014360,1402001,1402001,1402001,1402001,0],
            //        ...
            //    ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [1669014300,1402001,1402001,1402001,1402001,0],
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name wazirx#fetchOrderBook
 * @see https://docs.wazirx.com/#order-book
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *wazirx) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4498 := (<-this.LoadMarkets())
            PanicOnError(retRes4498)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // [1, 5, 10, 20, 50, 100, 500, 1000]
            }
        
            response:= (<-this.PublicGetDepth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //          "timestamp":1559561187,
            //          "asks":[
            //                     ["8540.0","1.5"],
            //                     ["8541.0","0.0042"]
            //                 ],
            //          "bids":[
            //                     ["8530.0","0.8814"],
            //                     ["8524.0","1.4"]
            //                 ]
            //      }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchTicker
 * @see https://docs.wazirx.com/#24hr-ticker-price-change-statistics
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *wazirx) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4858 := (<-this.LoadMarkets())
            PanicOnError(retRes4858)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetTicker24hr(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            // {
            //     "symbol":"wrxinr",
            //     "baseAsset":"wrx",
            //     "quoteAsset":"inr",
            //     "openPrice":"94.77",
            //     "lowPrice":"92.7",
            //     "highPrice":"95.17",
            //     "lastPrice":"94.03",
            //     "volume":"1118700.0",
            //     "bidPrice":"94.02",
            //     "askPrice":"94.03",
            //     "at":1641382455000
            // }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchTickers
 * @see https://docs.wazirx.com/#24hr-tickers-price-change-statistics
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *wazirx) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5198 := (<-this.LoadMarkets())
            PanicOnError(retRes5198)
        
            tickers:= (<-this.PublicGetTickers24hr())
            PanicOnError(tickers)
            //
            // [
            //     {
            //        "symbol":"btcinr",
            //        "baseAsset":"btc",
            //        "quoteAsset":"inr",
            //        "openPrice":"3698486",
            //        "lowPrice":"3641155.0",
            //        "highPrice":"3767999.0",
            //        "lastPrice":"3713212.0",
            //        "volume":"254.11582",
            //        "bidPrice":"3715021.0",
            //        "askPrice":"3715022.0",
            //     }
            //     ...
            // ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = GetValue(tickers, i)
                var parsedTicker interface{} = this.ParseTicker(ticker)
                var symbol interface{} = GetValue(parsedTicker, "symbol")
                AddElementToObject(result, symbol, parsedTicker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchTrades
 * @see https://docs.wazirx.com/#recent-trades-list
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *wazirx) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5608 := (<-this.LoadMarkets())
            PanicOnError(retRes5608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000)) // Default 500; max 1000.
            }
            var method interface{} = this.SafeString(this.Options, "fetchTradesMethod", "publicGetTrades")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "privateGetHistoricalTrades")) {
                
        response = (<-this.PrivateGetHistoricalTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetTrades(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                // [
            //     {
            //         "id":322307791,
            //         "price":"93.7",
            //         "qty":"0.7",
            //         "quoteQty":"65.59",
            //         "time":1641386701000,
            //         "isBuyerMaker":false
            //     },
            // ]
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id":322307791,
    //         "price":"93.7",
    //         "qty":"0.7",
    //         "quoteQty":"65.59",
    //         "time":1641386701000,
    //         "isBuyerMaker":false
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "id")
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var datetime interface{} = this.Iso8601(timestamp)
    market = this.SafeMarket(nil, market)
    var isBuyerMaker interface{} = this.SafeValue(trade, "isBuyerMaker")
    var side interface{} = Ternary(IsTrue(isBuyerMaker), "sell", "buy")
    var price interface{} = this.SafeNumber(trade, "price")
    var amount interface{} = this.SafeNumber(trade, "qty")
    var cost interface{} = this.SafeNumber(trade, "quoteQty")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": GetValue(market, "symbol"),
        "order": id,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name wazirx#fetchStatus
 * @see https://docs.wazirx.com/#system-status
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *wazirx) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetSystemStatus(params))
            PanicOnError(response)
            //
            //     {
            //         "status":"normal", // normal, system maintenance
            //         "message":"System is running normally."
            //     }
            //
            var status interface{} = this.SafeString(response, "status")
        
            ch <- map[string]interface{} {
                "status": Ternary(IsTrue((IsEqual(status, "normal"))), "ok", "maintenance"),
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchTime
 * @see https://docs.wazirx.com/#check-server-time
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *wazirx) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "serverTime":1635467280514
            //     }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //        "symbol":"btcinr",
    //        "baseAsset":"btc",
    //        "quoteAsset":"inr",
    //        "openPrice":"3698486",
    //        "lowPrice":"3641155.0",
    //        "highPrice":"3767999.0",
    //        "lastPrice":"3713212.0",
    //        "volume":"254.11582", // base volume
    //        "bidPrice":"3715021.0",
    //        "askPrice":"3715022.0",
    //        "at":1641382455000 // only on fetchTicker
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var open interface{} = this.SafeString(ticker, "openPrice")
    var high interface{} = this.SafeString(ticker, "highPrice")
    var low interface{} = this.SafeString(ticker, "lowPrice")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var bid interface{} = this.SafeString(ticker, "bidPrice")
    var ask interface{} = this.SafeString(ticker, "askPrice")
    var timestamp interface{} = this.SafeInteger(ticker, "at")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
func  (this *wazirx) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var id interface{} = this.SafeString(balance, "asset")
        var code interface{} = this.SafeCurrencyCode(id)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "free"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name wazirx#fetchBalance
 * @see https://docs.wazirx.com/#fund-details-user_data
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *wazirx) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7438 := (<-this.LoadMarkets())
            PanicOnError(retRes7438)
        
            response:= (<-this.PrivateGetFunds(params))
            PanicOnError(response)
        
                //
            // [
            //       {
            //          "asset":"inr",
            //          "free":"0.0",
            //          "locked":"0.0"
            //       },
            // ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchOrders
 * @see https://docs.wazirx.com/#all-orders-user_data
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *wazirx) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes7728 := (<-this.LoadMarkets())
            PanicOnError(retRes7728)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetAllOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   [
            //       {
            //           "id": 28,
            //           "symbol": "wrxinr",
            //           "price": "9293.0",
            //           "origQty": "10.0",
            //           "executedQty": "8.2",
            //           "status": "cancel",
            //           "type": "limit",
            //           "side": "sell",
            //           "createdTime": 1499827319559,
            //           "updatedTime": 1499827319559
            //       },
            //       {
            //           "id": 30,
            //           "symbol": "wrxinr",
            //           "price": "9293.0",
            //           "stopPrice": "9200.0",
            //           "origQty": "10.0",
            //           "executedQty": "0.0",
            //           "status": "cancel",
            //           "type": "stop_limit",
            //           "side": "sell",
            //           "createdTime": 1499827319559,
            //           "updatedTime": 1507725176595
            //       }
            //   ]
            //
            var orders interface{} = this.ParseOrders(response, market, since, limit)
            orders = this.FilterBy(orders, "symbol", symbol)
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchOpenOrders
 * @see https://docs.wazirx.com/#current-open-orders-user_data
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *wazirx) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8308 := (<-this.LoadMarkets())
            PanicOnError(retRes8308)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            // [
            //     {
            //         "id": 28,
            //         "symbol": "wrxinr",
            //         "price": "9293.0",
            //         "origQty": "10.0",
            //         "executedQty": "8.2",
            //         "status": "cancel",
            //         "type": "limit",
            //         "side": "sell",
            //         "createdTime": 1499827319559,
            //         "updatedTime": 1499827319559
            //     },
            //     {
            //         "id": 30,
            //         "symbol": "wrxinr",
            //         "price": "9293.0",
            //         "stopPrice": "9200.0",
            //         "origQty": "10.0",
            //         "executedQty": "0.0",
            //         "status": "cancel",
            //         "type": "stop_limit",
            //         "side": "sell",
            //         "createdTime": 1499827319559,
            //         "updatedTime": 1507725176595
            //     }
            // ]
            var orders interface{} = this.ParseOrders(response, market, since, limit)
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#cancelAllOrders
 * @see https://docs.wazirx.com/#cancel-all-open-orders-on-a-symbol-trade
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *wazirx) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes8828 := (<-this.LoadMarkets())
            PanicOnError(retRes8828)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateDeleteOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            id: "4565421197",
            //            symbol: "adausdt",
            //            type: "limit",
            //            side: "buy",
            //            status: "wait",
            //            price: "0.41",
            //            origQty: "11.00",
            //            executedQty: "0.00",
            //            avgPrice: "0.00",
            //            createdTime: "1718089507000",
            //            updatedTime: "1718089507000",
            //            clientOrderId: "93d2a838-e272-405d-91e7-3a7bc6d3a003"
            //        }
            //    ]
            //
        ch <- this.ParseOrders(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#cancelOrder
 * @see https://docs.wazirx.com/#cancel-order-trade
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *wazirx) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes9238 := (<-this.LoadMarkets())
            PanicOnError(retRes9238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderId": id,
            }
        
            response:= (<-this.PrivateDeleteOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#createOrder
 * @see https://docs.wazirx.com/#new-order-trade
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *wazirx) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            typeVar = ToLower(typeVar)
            if IsTrue(IsTrue((!IsEqual(typeVar, "limit"))) && IsTrue((!IsEqual(typeVar, "stop_limit")))) {
                panic(ExchangeError(Add(this.Id, " createOrder() supports limit and stop_limit orders only")))
            }
            if IsTrue(IsEqual(price, nil)) {
                panic(ExchangeError(Add(this.Id, " createOrder() requires a price argument")))
            }
        
            retRes9548 := (<-this.LoadMarkets())
            PanicOnError(retRes9548)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": side,
                "quantity": amount,
                "type": "limit",
            }
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "type", "stop_limit")
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
        
            response:= (<-this.PrivatePostOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "id": 28,
            //     "symbol": "wrxinr",
            //     "price": "9293.0",
            //     "origQty": "10.0",
            //     "executedQty": "8.2",
            //     "status": "wait",
            //     "type": "limit",
            //     "side": "sell",
            //     "createdTime": 1499827319559,
            //     "updatedTime": 1499827319559
            // }
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": 1949417813,
    //        "symbol": "ltcusdt",
    //        "type": "limit",
    //        "side": "sell",
    //        "status": "done",
    //        "price": "146.2",
    //        "origQty": "0.05",
    //        "executedQty": "0.05",
    //        "avgPrice":  "0.00",
    //        "createdTime": 1641252564000,
    //        "updatedTime": 1641252564000
    //        "clientOrderId": "93d2a838-e272-405d-91e7-3a7bc6d3a003"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var created interface{} = this.SafeInteger(order, "createdTime")
    var updated interface{} = this.SafeInteger(order, "updatedTime")
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var amount interface{} = this.SafeString(order, "quantity")
    var filled interface{} = this.SafeString(order, "executedQty")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var id interface{} = this.SafeString(order, "id")
    var price interface{} = this.SafeString(order, "price")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var side interface{} = this.SafeStringLower(order, "side")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "timestamp": created,
        "datetime": this.Iso8601(created),
        "lastTradeTimestamp": updated,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": nil,
        "fee": nil,
        "average": this.SafeString(order, "avgPrice"),
        "trades": []interface{}{},
    }, market)
}
func  (this *wazirx) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "wait": "open",
        "done": "closed",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name wazirx#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.wazirx.com/#all-coins-39-information-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *wazirx) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if !IsTrue(this.CheckRequiredCredentials(false)) {
        
                return nil
            }
        
            response:= (<-this.PrivateGetCoins(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "currency": "btc",
            //             "name": "Bitcoin",
            //             "networkList": [
            //                 {
            //                     "addressRegex": "^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^(bc1)[0-9A-Za-z]{39,59}$",
            //                     "confirmations": 4,
            //                     "depositDesc": {
            //                         "description": ""
            //                     },
            //                     "depositDust": "0.00000001",
            //                     "depositEnable": true,
            //                     "disclaimer": "• \u003cb\u003eSend only using the Bitcoin network.\u003c/b\u003e Using any other network will result in loss of funds.\u003cbr/\u003e• \u003cb\u003eDeposit only BTC to this deposit address.\u003c/b\u003e Depositing any other asset will result in a loss of funds.\u003cbr/\u003e",
            //                     "fullName": null,
            //                     "hidden": {
            //                         "deposit": false,
            //                         "withdraw": false
            //                     },
            //                     "isDefault": true,
            //                     "maxWithdrawAmount": "3",
            //                     "minConfirm": 4,
            //                     "minWithdrawAmount": "0.003",
            //                     "name": "Bitcoin",
            //                     "network": "btc",
            //                     "order": 3,
            //                     "precision": 8,
            //                     "requestId": "6d67a13d-26f7-4941-9856-94eba4adfe78",
            //                     "shortName": "BTC",
            //                     "specialTip": "Please ensure to select \u003cb\u003eBitcoin\u003c/b\u003e network at sender's wallet.",
            //                     "withdrawConsent": {
            //                         "helpUrl": null,
            //                         "message": "I confirm that this withdrawal of crypto assets is being done to my own wallet, as specified above. I authorize you to share travel rule information with the destination wallet service provider wherever applicable."
            //                     },
            //                     "withdrawDesc": {
            //                         "description": ""
            //                     },
            //                     "withdrawEnable": true,
            //                     "withdrawFee": "0.0015"
            //                 }
            //             ],
            //             "rapidListed": false
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var currencyId interface{} = this.SafeString(currency, "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var name interface{} = this.SafeString(currency, "name")
                var chains interface{} = this.SafeList(currency, "networkList", []interface{}{})
                var networks interface{} = map[string]interface{} {}
                var minPrecision interface{} = nil
                var minWithdrawFeeString interface{} = nil
                var minWithdrawString interface{} = nil
                var maxWithdrawString interface{} = nil
                var minDepositString interface{} = nil
                var deposit interface{} = false
                var withdraw interface{} = false
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString(chain, "network")
                    var networkCode interface{} = this.NetworkIdToCode(networkId)
                    var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(chain, "precision")))
                    minPrecision = Ternary(IsTrue((IsEqual(minPrecision, nil))), precision, mathMin(minPrecision, precision))
                    var depositAllowed interface{} = this.SafeBool(chain, "depositEnable")
                    deposit = Ternary(IsTrue((depositAllowed)), depositAllowed, deposit)
                    var withdrawAllowed interface{} = this.SafeBool(chain, "withdrawEnable")
                    withdraw = Ternary(IsTrue((withdrawAllowed)), withdrawAllowed, withdraw)
                    var withdrawFeeString interface{} = this.SafeString(chain, "withdrawFee")
                    if IsTrue(!IsEqual(withdrawFeeString, nil)) {
                        minWithdrawFeeString = Ternary(IsTrue((IsEqual(minWithdrawFeeString, nil))), withdrawFeeString, Precise.StringMin(withdrawFeeString, minWithdrawFeeString))
                    }
                    var minNetworkWithdrawString interface{} = this.SafeString(chain, "minWithdrawAmount")
                    if IsTrue(!IsEqual(minNetworkWithdrawString, nil)) {
                        minWithdrawString = Ternary(IsTrue((IsEqual(minWithdrawString, nil))), minNetworkWithdrawString, Precise.StringMin(minNetworkWithdrawString, minWithdrawString))
                    }
                    var maxNetworkWithdrawString interface{} = this.SafeString(chain, "maxWithdrawAmount")
                    if IsTrue(!IsEqual(maxNetworkWithdrawString, nil)) {
                        maxWithdrawString = Ternary(IsTrue((IsEqual(maxWithdrawString, nil))), maxNetworkWithdrawString, Precise.StringMin(maxNetworkWithdrawString, maxWithdrawString))
                    }
                    var minNetworkDepositString interface{} = this.SafeString(chain, "depositDust")
                    if IsTrue(!IsEqual(minNetworkDepositString, nil)) {
                        minDepositString = Ternary(IsTrue((IsEqual(minDepositString, nil))), minNetworkDepositString, Precise.StringMin(minNetworkDepositString, minDepositString))
                    }
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "info": chain,
            "id": networkId,
            "network": networkCode,
            "active": IsTrue(depositAllowed) && IsTrue(withdrawAllowed),
            "deposit": depositAllowed,
            "withdraw": withdrawAllowed,
            "fee": this.ParseNumber(withdrawFeeString),
            "precision": precision,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minNetworkWithdrawString),
                    "max": this.ParseNumber(maxNetworkWithdrawString),
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minNetworkDepositString),
                    "max": nil,
                },
            },
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "info": currency,
            "code": code,
            "id": currencyId,
            "name": name,
            "active": IsTrue(deposit) && IsTrue(withdraw),
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": this.ParseNumber(minWithdrawFeeString),
            "precision": minPrecision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdrawString),
                    "max": this.ParseNumber(maxWithdrawString),
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minDepositString),
                    "max": nil,
                },
            },
            "networks": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.wazirx.com/#deposit-address-supporting-network-user_data
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code, you can get network from fetchCurrencies
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *wazirx) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12078 := (<-this.LoadMarkets())
            PanicOnError(retRes12078)
            var currency interface{} = this.Currency(code)
            var networkCode interface{} = this.SafeString(params, "network")
            params = this.Omit(params, "network")
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires a network parameter")))
            }
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "network": this.NetworkCodeToId(networkCode, code),
            }
        
            response:= (<-this.PrivateGetCryptoDepositsAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "address": "bc1qrzpyzh69pfclpqy7c3yg8rkjsy49se7642v4q3",
            //         "coin": "btc",
            //         "url": "https: //live.blockcypher.com/btc/address/bc1qrzpyzh69pfclpqy7c3yg8rkjsy49se7642v4q3"
            //     }
            //
        ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": this.NetworkCodeToId(networkCode, code),
                "address": this.SafeString(response, "address"),
                "tag": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name wazirx#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.wazirx.com/#withdraw-history-supporting-network-user_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *wazirx) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12488 := (<-this.LoadMarkets())
            PanicOnError(retRes12488)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateGetCryptoWithdraws(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
            //             "amount": "8.91000000",
            //             "createdAt": "2019-10-12 09:12:02",
            //             "lastUpdated": "2019-10-12 11:12:02",
            //             "coin": "USDT",
            //             "id": "b6ae22b3aa844210a7041aee7589627c",
            //             "withdrawOrderId": "WITHDRAWtest123",
            //             "network": "ETH",
            //             "status": 1,
            //             "transactionFee": "0.004",
            //             "failureInfo":"The address is not valid. Please confirm with the recipient",
            //             "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *wazirx) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "ok",
        "1": "fail",
        "2": "pending",
        "3": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *wazirx) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
    //         "amount": "8.91000000",
    //         "createdAt": "2019-10-12 09:12:02",
    //         "lastUpdated": "2019-10-12 11:12:02",
    //         "coin": "USDT",
    //         "id": "b6ae22b3aa844210a7041aee7589627c",
    //         "withdrawOrderId": "WITHDRAWtest123",
    //         "network": "ETH",
    //         "status": 1,
    //         "transactionFee": "0.004",
    //         "failureInfo": "The address is not valid. Please confirm with the recipient",
    //         "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "createdAt"))
    var updated interface{} = this.Parse8601(this.SafeString(transaction, "lastUpdated"))
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var feeCost interface{} = this.SafeNumber(transaction, "transactionFee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "txId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.NetworkIdToCode(this.SafeString(transaction, "network")),
        "address": this.SafeString(transaction, "address"),
        "addressTo": this.SafeString(transaction, "address"),
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": "withdrawal",
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": status,
        "updated": updated,
        "fee": fee,
        "internal": nil,
        "comment": nil,
    }
}
func  (this *wazirx) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), path)
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = this.Milliseconds()
        var data interface{} = this.Extend(map[string]interface{} {
            "recvWindow": GetValue(this.Options, "recvWindow"),
            "timestamp": timestamp,
        }, params)
        data = this.Keysort(data)
        var signature interface{} = this.Hmac(this.Encode(this.Urlencode(data)), this.Encode(this.Secret), sha256)
        url = Add(url, Add("?", this.Urlencode(data)))
        url = Add(url, Add(Add("&", "signature="), signature))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "X-Api-Key": this.ApiKey,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *wazirx) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    // {"code":2098,"message":"Request out of receiving window."}
    //
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorCode interface{} = this.SafeString(response, "code")
    if IsTrue(!IsEqual(errorCode, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *wazirx) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
