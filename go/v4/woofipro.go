package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type woofipro struct {
    Exchange

}

func NewWoofiproCore() woofipro {
   p := woofipro{}
   setDefaults(&p)
   return p
}

func  (this *woofipro) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "woofipro",
        "name": "WOOFI PRO",
        "countries": []interface{}{"KY"},
        "rateLimit": 100,
        "version": "v1",
        "certified": true,
        "pro": true,
        "dex": true,
        "hostname": "dex.woo.org",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelWithdraw": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": false,
            "createStopLossOrder": true,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": true,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": false,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": true,
            "setMargin": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1mon",
            "1y": "1y",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/9ba21b8a-a9c7-4770-b7f1-ce3bcbde68c1",
            "api": map[string]interface{} {
                "public": "https://api-evm.orderly.org",
                "private": "https://api-evm.orderly.org",
            },
            "test": map[string]interface{} {
                "public": "https://testnet-api-evm.orderly.org",
                "private": "https://testnet-api-evm.orderly.org",
            },
            "www": "https://dex.woo.org",
            "doc": []interface{}{"https://orderly.network/docs/build-on-evm/building-on-evm"},
            "fees": []interface{}{"https://dex.woo.org/en/orderly"},
            "referral": map[string]interface{} {
                "url": "https://dex.woo.org/en/trade?ref=CCXT",
                "discount": 0.05,
            },
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "public/volume/stats": 1,
                        "public/broker/name": 1,
                        "public/chain_info/{broker_id}": 1,
                        "public/system_info": 1,
                        "public/vault_balance": 1,
                        "public/insurancefund": 1,
                        "public/chain_info": 1,
                        "faucet/usdc": 1,
                        "public/account": 1,
                        "get_account": 1,
                        "registration_nonce": 1,
                        "get_orderly_key": 1,
                        "public/liquidation": 1,
                        "public/liquidated_positions": 1,
                        "public/config": 1,
                        "public/campaign/ranking": 10,
                        "public/campaign/stats": 10,
                        "public/campaign/user": 10,
                        "public/campaign/stats/details": 10,
                        "public/campaigns": 10,
                        "public/points/leaderboard": 1,
                        "client/points": 1,
                        "public/points/epoch": 1,
                        "public/points/epoch_dates": 1,
                        "public/referral/check_ref_code": 1,
                        "public/referral/verify_ref_code": 1,
                        "referral/admin_info": 1,
                        "referral/info": 1,
                        "referral/referee_info": 1,
                        "referral/referee_rebate_summary": 1,
                        "referral/referee_history": 1,
                        "referral/referral_history": 1,
                        "referral/rebate_summary": 1,
                        "client/distribution_history": 1,
                        "tv/config": 1,
                        "tv/history": 1,
                        "tv/symbol_info": 1,
                        "public/funding_rate_history": 1,
                        "public/funding_rate/{symbol}": 0.33,
                        "public/funding_rates": 1,
                        "public/info": 1,
                        "public/info/{symbol}": 1,
                        "public/market_trades": 1,
                        "public/token": 1,
                        "public/futures": 1,
                        "public/futures/{symbol}": 1,
                    },
                    "post": map[string]interface{} {
                        "register_account": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "client/key_info": 6,
                        "client/orderly_key_ip_restriction": 6,
                        "order/{oid}": 1,
                        "client/order/{client_order_id}": 1,
                        "algo/order/{oid}": 1,
                        "algo/client/order/{client_order_id}": 1,
                        "orders": 1,
                        "algo/orders": 1,
                        "trade/{tid}": 1,
                        "trades": 1,
                        "order/{oid}/trades": 1,
                        "client/liquidator_liquidations": 1,
                        "liquidations": 1,
                        "asset/history": 60,
                        "client/holding": 1,
                        "withdraw_nonce": 1,
                        "settle_nonce": 1,
                        "pnl_settlement/history": 1,
                        "volume/user/daily": 60,
                        "volume/user/stats": 60,
                        "client/statistics": 60,
                        "client/info": 60,
                        "client/statistics/daily": 60,
                        "positions": 3.33,
                        "position/{symbol}": 3.33,
                        "funding_fee/history": 30,
                        "notification/inbox/notifications": 60,
                        "notification/inbox/unread": 60,
                        "volume/broker/daily": 60,
                        "broker/fee_rate/default": 10,
                        "broker/user_info": 10,
                        "orderbook/{symbol}": 1,
                        "kline": 1,
                    },
                    "post": map[string]interface{} {
                        "orderly_key": 1,
                        "client/set_orderly_key_ip_restriction": 6,
                        "client/reset_orderly_key_ip_restriction": 6,
                        "order": 1,
                        "batch-order": 10,
                        "algo/order": 1,
                        "liquidation": 1,
                        "claim_insurance_fund": 1,
                        "withdraw_request": 1,
                        "settle_pnl": 1,
                        "notification/inbox/mark_read": 60,
                        "notification/inbox/mark_read_all": 60,
                        "client/leverage": 120,
                        "client/maintenance_config": 60,
                        "delegate_signer": 10,
                        "delegate_orderly_key": 10,
                        "delegate_settle_pnl": 10,
                        "delegate_withdraw_request": 10,
                        "broker/fee_rate/set": 10,
                        "broker/fee_rate/set_default": 10,
                        "broker/fee_rate/default": 10,
                        "referral/create": 10,
                        "referral/update": 10,
                        "referral/bind": 10,
                        "referral/edit_split": 10,
                    },
                    "put": map[string]interface{} {
                        "order": 1,
                        "algo/order": 1,
                    },
                    "delete": map[string]interface{} {
                        "order": 1,
                        "algo/order": 1,
                        "client/order": 1,
                        "algo/client/order": 1,
                        "algo/orders": 1,
                        "orders": 1,
                        "batch-order": 1,
                        "client/batch-order": 1,
                    },
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "accountId": true,
            "privateKey": false,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0002"),
                "taker": this.ParseNumber("0.0005"),
            },
        },
        "options": map[string]interface{} {
            "sandboxMode": false,
            "brokerId": "CCXT",
            "verifyingContractAddress": "0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": true,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "triggerPriceType": nil,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": nil,
                        "price": false,
                    },
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1000": ExchangeError,
                "-1001": AuthenticationError,
                "-1002": AuthenticationError,
                "-1003": RateLimitExceeded,
                "-1004": BadRequest,
                "-1005": BadRequest,
                "-1006": InvalidOrder,
                "-1007": BadRequest,
                "-1008": InvalidOrder,
                "-1009": InsufficientFunds,
                "-1011": NetworkError,
                "-1012": BadRequest,
                "-1101": InsufficientFunds,
                "-1102": InvalidOrder,
                "-1103": InvalidOrder,
                "-1104": InvalidOrder,
                "-1105": InvalidOrder,
                "-1201": BadRequest,
                "-1202": BadRequest,
                "29": BadRequest,
                "9": AuthenticationError,
                "3": AuthenticationError,
                "2": BadRequest,
                "15": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *woofipro) SetSandboxMode(enable interface{})  {
    this.Exchange.SetSandboxMode(enable)
    AddElementToObject(this.Options, "sandboxMode", enable)
}
/**
 * @method
 * @name woofipro#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-system-maintenance-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *woofipro) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetPublicSystemInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": 0,
            //             "msg": "System is functioning properly."
            //         },
            //         "timestamp": "1709274106602"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var status interface{} = this.SafeString(data, "status")
            if IsTrue(IsEqual(status, nil)) {
                status = "error"
            } else if IsTrue(IsEqual(status, "0")) {
                status = "ok"
            } else {
                status = "maintenance"
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-system-maintenance-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *woofipro) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetPublicSystemInfo(params))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": 0,
            //             "msg": "System is functioning properly."
            //         },
            //         "timestamp": "1709274106602"
            //     }
            //
        ch <- this.SafeInteger(response, "timestamp")
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseMarket(market interface{}) interface{}  {
    //
    //   {
    //     "symbol": "PERP_BTC_USDC",
    //     "quote_min": 123,
    //     "quote_max": 100000,
    //     "quote_tick": 0.1,
    //     "base_min": 0.00001,
    //     "base_max": 20,
    //     "base_tick": 0.00001,
    //     "min_notional": 1,
    //     "price_range": 0.02,
    //     "price_scope": 0.4,
    //     "std_liquidation_fee": 0.03,
    //     "liquidator_fee": 0.015,
    //     "claim_insurance_fund_discount": 0.0075,
    //     "funding_period": 8,
    //     "cap_funding": 0.000375,
    //     "floor_funding": -0.000375,
    //     "interest_rate": 0.0001,
    //     "created_time": 1684140107326,
    //     "updated_time": 1685345968053,
    //     "base_mmr": 0.05,
    //     "base_imr": 0.1,
    //     "imr_factor": 0.0002512,
    //     "liquidation_tier": "1"
    //   }
    //
    var marketId interface{} = this.SafeString(market, "symbol")
    var parts interface{} = Split(marketId, "_")
    var marketType interface{} = "swap"
    var baseId interface{} = this.SafeString(parts, 1)
    var quoteId interface{} = this.SafeString(parts, 2)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = this.SafeString(parts, 2)
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": marketType,
        "spot": false,
        "margin": false,
        "swap": true,
        "future": false,
        "option": false,
        "active": nil,
        "contract": true,
        "linear": true,
        "inverse": nil,
        "contractSize": this.ParseNumber("1"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "base_tick"),
            "price": this.SafeNumber(market, "quote_tick"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "base_min"),
                "max": this.SafeNumber(market, "base_max"),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "quote_min"),
                "max": this.SafeNumber(market, "quote_max"),
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_notional"),
                "max": nil,
            },
        },
        "created": this.SafeInteger(market, "created_time"),
        "info": market,
    }
}
/**
 * @method
 * @name woofipro#fetchMarkets
 * @description retrieves data on all markets for woofipro
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-available-symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *woofipro) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetPublicInfo(params))
            PanicOnError(response)
            //
            //   {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [
            //         {
            //           "symbol": "PERP_BTC_USDC",
            //           "quote_min": 123,
            //           "quote_max": 100000,
            //           "quote_tick": 0.1,
            //           "base_min": 0.00001,
            //           "base_max": 20,
            //           "base_tick": 0.00001,
            //           "min_notional": 1,
            //           "price_range": 0.02,
            //           "price_scope": 0.4,
            //           "std_liquidation_fee": 0.03,
            //           "liquidator_fee": 0.015,
            //           "claim_insurance_fund_discount": 0.0075,
            //           "funding_period": 8,
            //           "cap_funding": 0.000375,
            //           "floor_funding": -0.000375,
            //           "interest_rate": 0.0001,
            //           "created_time": 1684140107326,
            //           "updated_time": 1685345968053,
            //           "base_mmr": 0.05,
            //           "base_imr": 0.1,
            //           "imr_factor": 0.0002512,
            //           "liquidation_tier": "1"
            //         }
            //       ]
            //     }
            //   }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseMarkets(rows)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-token-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *woofipro) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var result interface{} = map[string]interface{} {}
        
            response:= (<-this.V1PublicGetPublicToken(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "token": "USDC",
            //         "decimals": 6,
            //         "minimum_withdraw_amount": 0.000001,
            //         "token_hash": "0xd6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa",
            //         "chain_details": [{
            //             "chain_id": 43113,
            //             "contract_address": "0x5d64c9cfb0197775b4b3ad9be4d3c7976e0d8dc3",
            //             "cross_chain_withdrawal_fee": 123,
            //             "decimals": 6,
            //             "withdraw_fee": 2
            //             }]
            //         }
            //       ]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var tokenRows interface{} = this.SafeList(data, "rows", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(tokenRows)); i++ {
                var token interface{} = GetValue(tokenRows, i)
                var currencyId interface{} = this.SafeString(token, "token")
                var networks interface{} = this.SafeList(token, "chain_details")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var minPrecision interface{} = nil
                var resultingNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
                    var network interface{} = GetValue(networks, j)
                    // TODO: transform chain id to human readable name
                    var networkId interface{} = this.SafeString(network, "chain_id")
                    var precision interface{} = this.ParsePrecision(this.SafeString(network, "decimals"))
                    if IsTrue(!IsEqual(precision, nil)) {
                        minPrecision = Ternary(IsTrue((IsEqual(minPrecision, nil))), precision, Precise.StringMin(precision, minPrecision))
                    }
                    AddElementToObject(resultingNetworks, networkId, map[string]interface{} {
            "id": networkId,
            "network": networkId,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": this.SafeNumber(network, "withdrawal_fee"),
            "precision": this.ParseNumber(precision),
            "info": network,
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "name": currencyId,
            "code": code,
            "precision": this.ParseNumber(minPrecision),
            "active": nil,
            "fee": nil,
            "networks": resultingNetworks,
            "deposit": nil,
            "withdraw": nil,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(token, "minimum_withdraw_amount"),
                    "max": nil,
                },
            },
            "info": token,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseTokenAndFeeTemp(item interface{}, feeTokenKey interface{}, feeAmountKey interface{}) interface{}  {
    var feeCost interface{} = this.SafeString(item, feeAmountKey)
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(item, feeTokenKey)
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    return fee
}
func  (this *woofipro) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public/market_trades
    //
    //     {
    //         "symbol": "SPOT_BTC_USDT",
    //         "side": "SELL",
    //         "executed_price": 46222.35,
    //         "executed_quantity": 0.0012,
    //         "executed_timestamp": "1683878609166"
    //     }
    //
    // fetchOrderTrades, fetchOrder
    //
    //     {
    //         "id": "99119876",
    //         "symbol": "SPOT_WOO_USDT",
    //         "fee": "0.0024",
    //         "side": "BUY",
    //         "executed_timestamp": "1641481113084",
    //         "order_id": "87001234",
    //         "order_tag": "default", <-- this param only in "fetchOrderTrades"
    //         "executed_price": "1",
    //         "executed_quantity": "12",
    //         "fee_asset": "WOO",
    //         "is_maker": "1"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var isFromFetchOrder interface{} =     (InOp(trade, "id"))
    var timestamp interface{} = this.SafeInteger(trade, "executed_timestamp")
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(trade, "executed_price")
    var amount interface{} = this.SafeString(trade, "executed_quantity")
    var order_id interface{} = this.SafeString(trade, "order_id")
    var fee interface{} = this.ParseTokenAndFeeTemp(trade, "fee_asset", "fee")
    var feeCost interface{} = this.SafeString(fee, "cost")
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "cost", feeCost)
    }
    var cost interface{} = Precise.StringMul(price, amount)
    var side interface{} = this.SafeStringLower(trade, "side")
    var id interface{} = this.SafeString(trade, "id")
    var takerOrMaker interface{} = nil
    if IsTrue(isFromFetchOrder) {
        var isMaker interface{} = IsEqual(this.SafeString(trade, "is_maker"), "1")
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": order_id,
        "takerOrMaker": takerOrMaker,
        "type": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name woofipro#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-market-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *woofipro) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8238 := (<-this.LoadMarkets())
            PanicOnError(retRes8238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1PublicGetPublicMarketTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "symbol": "PERP_ETH_USDC",
            //         "side": "BUY",
            //         "executed_price": 2050,
            //         "executed_quantity": 1,
            //         "executed_timestamp": 1683878609166
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTrades(rows, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseFundingRate(fundingRate interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //         {
    //             "symbol":"PERP_AAVE_USDT",
    //             "est_funding_rate":-0.00003447,
    //             "est_funding_rate_timestamp":1653633959001,
    //             "last_funding_rate":-0.00002094,
    //             "last_funding_rate_timestamp":1653631200000,
    //             "next_funding_time":1653634800000,
    //            "sum_unitary_funding": 521.367
    //         }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(fundingRate, "symbol")
    market = this.Market(symbol)
    var nextFundingTimestamp interface{} = this.SafeInteger(fundingRate, "next_funding_time")
    var estFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "est_funding_rate_timestamp")
    var lastFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "last_funding_rate_timestamp")
    var fundingTimeString interface{} = this.SafeString(fundingRate, "last_funding_rate_timestamp")
    var nextFundingTimeString interface{} = this.SafeString(fundingRate, "next_funding_time")
    var millisecondsInterval interface{} = Precise.StringSub(nextFundingTimeString, fundingTimeString)
    return map[string]interface{} {
        "info": fundingRate,
        "symbol": GetValue(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": this.ParseNumber("0"),
        "estimatedSettlePrice": nil,
        "timestamp": estFundingRateTimestamp,
        "datetime": this.Iso8601(estFundingRateTimestamp),
        "fundingRate": this.SafeNumber(fundingRate, "est_funding_rate"),
        "fundingTimestamp": nextFundingTimestamp,
        "fundingDatetime": this.Iso8601(nextFundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": this.SafeNumber(fundingRate, "last_funding_rate"),
        "previousFundingTimestamp": lastFundingRateTimestamp,
        "previousFundingDatetime": this.Iso8601(lastFundingRateTimestamp),
        "interval": this.ParseFundingInterval(millisecondsInterval),
    }
}
func  (this *woofipro) ParseFundingInterval(interval interface{}) interface{}  {
    var intervals interface{} = map[string]interface{} {
        "3600000": "1h",
        "14400000": "4h",
        "28800000": "8h",
        "57600000": "16h",
        "86400000": "24h",
    }
    return this.SafeString(intervals, interval, interval)
}
/**
 * @method
 * @name woofipro#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-predicted-funding-rate-for-one-market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woofipro) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes91515 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes91515)
                ch <- retRes91515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-predicted-funding-rate-for-one-market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woofipro) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9288 := (<-this.LoadMarkets())
            PanicOnError(retRes9288)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetPublicFundingRateSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "symbol": "PERP_ETH_USDC",
            //         "est_funding_rate": 123,
            //         "est_funding_rate_timestamp": 1683880020000,
            //         "last_funding_rate": 0.0001,
            //         "last_funding_rate_timestamp": 1683878400000,
            //         "next_funding_time": 1683907200000,
            //         "sum_unitary_funding": 521.367
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchFundingRates
 * @description fetch the current funding rate for multiple markets
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-predicted-funding-rates-for-all-markets
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woofipro) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9638 := (<-this.LoadMarkets())
            PanicOnError(retRes9638)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V1PublicGetPublicFundingRates(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "symbol": "PERP_ETH_USDC",
            //         "est_funding_rate": 123,
            //         "est_funding_rate_timestamp": 1683880020000,
            //         "last_funding_rate": 0.0001,
            //         "last_funding_rate_timestamp": 1683878400000,
            //         "next_funding_time": 1683907200000,
            //         "sum_unitary_funding": 521.367
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseFundingRates(rows, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-funding-rate-history-for-one-market
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *woofipro) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10028 := (<-this.LoadMarkets())
            PanicOnError(retRes10028)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes100619 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, "page", 25))
                    PanicOnError(retRes100619)
                    ch <- retRes100619
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = GetValue(market, "symbol")
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            requestparamsVariable := this.HandleUntilOption("end_t", request, params, 0.001);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V1PublicGetPublicFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "symbol": "PERP_ETH_USDC",
            //         "funding_rate": 0.0001,
            //         "funding_rate_timestamp": 1684224000000,
            //         "next_funding_time": 1684252800000
            //       }],
            //       "meta": {
            //         "total": 9,
            //         "records_per_page": 25,
            //         "current_page": 1
            //       }
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var result interface{} = this.SafeList(data, "rows", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var timestamp interface{} = this.SafeInteger(entry, "funding_rate_timestamp")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(marketId),
                    "fundingRate": this.SafeNumber(entry, "funding_rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-account-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *woofipro) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10668 := (<-this.LoadMarkets())
            PanicOnError(retRes10668)
        
            response:= (<-this.V1PrivateGetClientInfo(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "account_id": "<string>",
            //         "email": "test@test.com",
            //         "account_mode": "FUTURES",
            //         "max_leverage": 20,
            //         "taker_fee_rate": 123,
            //         "maker_fee_rate": 123,
            //         "futures_taker_fee_rate": 123,
            //         "futures_maker_fee_rate": 123,
            //         "maintenance_cancel_orders": true,
            //         "imr_factor": {
            //             "PERP_BTC_USDC": 123,
            //             "PERP_ETH_USDC": 123,
            //             "PERP_NEAR_USDC": 123
            //         },
            //         "max_notional": {
            //             "PERP_BTC_USDC": 123,
            //             "PERP_ETH_USDC": 123,
            //             "PERP_NEAR_USDC": 123
            //         }
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var maker interface{} = this.SafeString(data, "futures_maker_fee_rate")
            var taker interface{} = this.SafeString(data, "futures_taker_fee_rate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(Precise.StringDiv(maker, "10000")),
            "taker": this.ParseNumber(Precise.StringDiv(taker, "10000")),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/orderbook-snapshot
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *woofipro) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11248 := (<-this.LoadMarkets())
            PanicOnError(retRes11248)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                limit = mathMin(limit, 1000)
                AddElementToObject(request, "max_level", limit)
            }
        
            response:= (<-this.V1PrivateGetOrderbookSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "asks": [{
            //         "price": 10669.4,
            //         "quantity": 1.56263218
            //       }],
            //       "bids": [{
            //         "price": 10669.4,
            //         "quantity": 1.56263218
            //       }],
            //       "timestamp": 123
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "timestamp")
        
            ch <- this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "quantity")
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "start_timestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name woofipro#fetchOHLCV
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-kline
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *woofipro) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11808 := (<-this.LoadMarkets())
            PanicOnError(retRes11808)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
        
            response:= (<-this.V1PrivateGetKline(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "open": 66166.23,
            //         "close": 66124.56,
            //         "low": 66038.06,
            //         "high": 66176.97,
            //         "volume": 23.45528526,
            //         "amount": 1550436.21725288,
            //         "symbol": "PERP_BTC_USDC",
            //         "type": "1m",
            //         "start_timestamp": 1636388220000,
            //         "end_timestamp": 1636388280000
            //       }]
            //     }
            // }
            //
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseOHLCVs(rows, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Possible input functions:
    // * createOrder
    // * createOrders
    // * cancelOrder
    // * fetchOrder
    // * fetchOrders
    // const isFromFetchOrder = ('order_tag' in order); TO_DO
    //
    // stop order after creating it:
    //   {
    //     "orderId": "1578938",
    //     "clientOrderId": "0",
    //     "algoType": "STOP_LOSS",
    //     "quantity": "0.1"
    //   }
    // stop order after fetching it:
    //   {
    //       "algoOrderId": "1578958",
    //       "clientOrderId": "0",
    //       "rootAlgoOrderId": "1578958",
    //       "parentAlgoOrderId": "0",
    //       "symbol": "SPOT_LTC_USDT",
    //       "orderTag": "default",
    //       "algoType": "STOP_LOSS",
    //       "side": "BUY",
    //       "quantity": "0.1",
    //       "isTriggered": false,
    //       "triggerPrice": "100",
    //       "triggerStatus": "USELESS",
    //       "type": "LIMIT",
    //       "rootAlgoStatus": "CANCELLED",
    //       "algoStatus": "CANCELLED",
    //       "triggerPriceType": "MARKET_PRICE",
    //       "price": "75",
    //       "triggerTime": "0",
    //       "totalExecutedQuantity": "0",
    //       "averageExecutedPrice": "0",
    //       "totalFee": "0",
    //       "feeAsset": '',
    //       "reduceOnly": false,
    //       "createdTime": "1686149609.744",
    //       "updatedTime": "1686149903.362"
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"timestamp", "created_time", "createdTime"})
    var orderId interface{} = this.SafeStringN(order, []interface{}{"order_id", "orderId", "algoOrderId"})
    var clientOrderId interface{} = this.OmitZero(this.SafeString2(order, "client_order_id", "clientOrderId")) // Somehow, this always returns 0 for limit order
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString2(order, "order_price", "price")
    var amount interface{} = this.SafeString2(order, "order_quantity", "quantity") // This is base amount
    var cost interface{} = this.SafeString2(order, "order_amount", "amount") // This is quote amount
    var orderType interface{} = this.SafeStringLower2(order, "order_type", "type")
    var status interface{} = this.SafeValue2(order, "status", "algoStatus")
    var success interface{} = this.SafeBool(order, "success")
    if IsTrue(!IsEqual(success, nil)) {
        status = Ternary(IsTrue((success)), "NEW", "REJECTED")
    }
    var side interface{} = this.SafeStringLower(order, "side")
    var filled interface{} = this.OmitZero(this.SafeValue2(order, "executed", "totalExecutedQuantity"))
    var average interface{} = this.OmitZero(this.SafeString2(order, "average_executed_price", "averageExecutedPrice"))
    var remaining interface{} = Precise.StringSub(cost, filled)
    var fee interface{} = this.SafeValue2(order, "total_fee", "totalFee")
    var feeCurrency interface{} = this.SafeString2(order, "fee_asset", "feeAsset")
    var transactions interface{} = this.SafeValue(order, "Transactions")
    var triggerPrice interface{} = this.SafeNumber(order, "triggerPrice")
    var takeProfitPrice interface{} = nil
    var stopLossPrice interface{} = nil
    var childOrders interface{} = this.SafeValue(order, "childOrders")
    if IsTrue(!IsEqual(childOrders, nil)) {
        var first interface{} = this.SafeValue(childOrders, 0)
        var innerChildOrders interface{} = this.SafeValue(first, "childOrders", []interface{}{})
        var innerChildOrdersLength interface{} =         GetArrayLength(innerChildOrders)
        if IsTrue(IsGreaterThan(innerChildOrdersLength, 0)) {
            var takeProfitOrder interface{} = this.SafeValue(innerChildOrders, 0)
            var stopLossOrder interface{} = this.SafeValue(innerChildOrders, 1)
            takeProfitPrice = this.SafeNumber(takeProfitOrder, "triggerPrice")
            stopLossPrice = this.SafeNumber(stopLossOrder, "triggerPrice")
        }
    }
    var lastUpdateTimestamp interface{} = this.SafeInteger2(order, "updatedTime", "updated_time")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": this.ParseOrderType(orderType),
        "timeInForce": this.ParseTimeInForce(orderType),
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "reduce_only"),
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "cost": cost,
        "trades": transactions,
        "fee": map[string]interface{} {
            "cost": fee,
            "currency": feeCurrency,
        },
        "info": order,
    }, market)
}
func  (this *woofipro) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "ioc": "IOC",
        "fok": "FOK",
        "post_only": "PO",
    }
    return this.SafeString(timeInForces, timeInForce, nil)
}
func  (this *woofipro) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "NEW": "open",
            "FILLED": "closed",
            "CANCEL_SENT": "canceled",
            "CANCEL_ALL_SENT": "canceled",
            "CANCELLED": "canceled",
            "PARTIAL_FILLED": "open",
            "REJECTED": "rejected",
            "INCOMPLETE": "open",
            "COMPLETED": "closed",
        }
        return this.SafeString(statuses, status, status)
    }
    return status
}
func  (this *woofipro) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "LIMIT": "limit",
        "MARKET": "market",
        "POST_ONLY": "limit",
    }
    return this.SafeStringLower(types, typeVar, typeVar)
}
func  (this *woofipro) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name woofipro#createOrderRequest
    * @description helper function to build the request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
    var orderType interface{} = ToUpper(typeVar)
    var market interface{} = this.Market(symbol)
    var orderSide interface{} = ToUpper(side)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": orderSide,
    }
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    var stopLoss interface{} = this.SafeValue(params, "stopLoss")
    var takeProfit interface{} = this.SafeValue(params, "takeProfit")
    var algoType interface{} = this.SafeString(params, "algoType")
    var isConditional interface{} = IsTrue(IsTrue(IsTrue(!IsEqual(triggerPrice, nil)) || IsTrue(!IsEqual(stopLoss, nil))) || IsTrue(!IsEqual(takeProfit, nil))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
    var isMarket interface{} = IsEqual(orderType, "MARKET")
    var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
    var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
    var orderQtyKey interface{} = Ternary(IsTrue(isConditional), "quantity", "order_quantity")
    var priceKey interface{} = Ternary(IsTrue(isConditional), "price", "order_price")
    var typeKey interface{} = Ternary(IsTrue(isConditional), "type", "order_type")
    AddElementToObject(request, typeKey, orderType) // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
    if !IsTrue(isConditional) {
        if IsTrue(postOnly) {
            AddElementToObject(request, "order_type", "POST_ONLY")
        } else if IsTrue(IsEqual(timeInForce, "fok")) {
            AddElementToObject(request, "order_type", "FOK")
        } else if IsTrue(IsEqual(timeInForce, "ioc")) {
            AddElementToObject(request, "order_type", "IOC")
        }
    }
    if IsTrue(reduceOnly) {
        AddElementToObject(request, "reduce_only", reduceOnly)
    }
    if IsTrue(!IsEqual(price, nil)) {
        AddElementToObject(request, priceKey, this.PriceToPrecision(symbol, price))
    }
    if IsTrue(IsTrue(isMarket) && !IsTrue(isConditional)) {
        AddElementToObject(request, orderQtyKey, this.AmountToPrecision(symbol, amount))
    } else if IsTrue(!IsEqual(algoType, "POSITIONAL_TP_SL")) {
        AddElementToObject(request, orderQtyKey, this.AmountToPrecision(symbol, amount))
    }
    var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "client_order_id", clientOrderId)
    }
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
        AddElementToObject(request, "algo_type", "STOP")
    } else if IsTrue(IsTrue((!IsEqual(stopLoss, nil))) || IsTrue((!IsEqual(takeProfit, nil)))) {
        AddElementToObject(request, "algo_type", "TP_SL")
        var outterOrder interface{} = map[string]interface{} {
            "symbol": GetValue(market, "id"),
            "reduce_only": false,
            "algo_type": "POSITIONAL_TP_SL",
            "child_orders": []interface{}{},
        }
        var childOrders interface{} = GetValue(outterOrder, "child_orders")
        var closeSide interface{} = Ternary(IsTrue((IsEqual(orderSide, "BUY"))), "SELL", "BUY")
        if IsTrue(!IsEqual(stopLoss, nil)) {
            var stopLossPrice interface{} = this.SafeNumber2(stopLoss, "triggerPrice", "price", stopLoss)
            var stopLossOrder interface{} = map[string]interface{} {
                "side": closeSide,
                "algo_type": "TP_SL",
                "trigger_price": this.PriceToPrecision(symbol, stopLossPrice),
                "type": "LIMIT",
                "reduce_only": true,
            }
            AppendToArray(&childOrders,stopLossOrder)
        }
        if IsTrue(!IsEqual(takeProfit, nil)) {
            var takeProfitPrice interface{} = this.SafeNumber2(takeProfit, "triggerPrice", "price", takeProfit)
            var takeProfitOrder interface{} = map[string]interface{} {
                "side": closeSide,
                "algo_type": "TP_SL",
                "trigger_price": this.PriceToPrecision(symbol, takeProfitPrice),
                "type": "LIMIT",
                "reduce_only": true,
            }
            AppendToArray(&outterOrder,takeProfitOrder)
        }
        AddElementToObject(request, "child_orders", []interface{}{outterOrder})
    }
    params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only", "clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name woofipro#createOrder
 * @description create a trade order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.algoType] 'STOP'or 'TP_SL' or 'POSITIONAL_TP_SL'
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14898 := (<-this.LoadMarkets())
            PanicOnError(retRes14898)
            var market interface{} = this.Market(symbol)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            var stopLoss interface{} = this.SafeValue(params, "stopLoss")
            var takeProfit interface{} = this.SafeValue(params, "takeProfit")
            var isConditional interface{} = IsTrue(IsTrue(IsTrue(!IsEqual(triggerPrice, nil)) || IsTrue(!IsEqual(stopLoss, nil))) || IsTrue(!IsEqual(takeProfit, nil))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var response interface{} = nil
            if IsTrue(isConditional) {
                
        response = (<-this.V1PrivatePostAlgoOrder(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivatePostOrder(request))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data")
            AddElementToObject(data, "timestamp", this.SafeInteger(response, "timestamp"))
            var order interface{} = this.ParseOrder(data, market)
            AddElementToObject(order, "type", typeVar)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#createOrders
 * @description *contract only* create a list of trade orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-create-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15468 := (<-this.LoadMarkets())
            PanicOnError(retRes15468)
            var ordersRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var triggerPrice interface{} = this.SafeString2(orderParams, "triggerPrice", "stopPrice")
                var stopLoss interface{} = this.SafeValue(orderParams, "stopLoss")
                var takeProfit interface{} = this.SafeValue(orderParams, "takeProfit")
                var isConditional interface{} = IsTrue(IsTrue(IsTrue(!IsEqual(triggerPrice, nil)) || IsTrue(!IsEqual(stopLoss, nil))) || IsTrue(!IsEqual(takeProfit, nil))) || IsTrue((!IsEqual(this.SafeValue(orderParams, "childOrders"), nil)))
                if IsTrue(isConditional) {
                    panic(NotSupported(Add(this.Id, " createOrders() only support non-stop order")))
                }
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "orders": ordersRequests,
            }
        
            response:= (<-this.V1PrivatePostBatchOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "timestamp": 1702989203989,
            //         "data": {
            //             "rows": [{
            //                 "order_id": 13,
            //                 "client_order_id": "testclientid",
            //                 "order_type": "LIMIT",
            //                 "order_price": 100.12,
            //                 "order_quantity": 0.987654,
            //                 "order_amount": 0.8,
            //                 "error_message": "none"
            //             }]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseOrders(rows)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#editOrder
 * @description edit a trade order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/edit-order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/edit-algo-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
 * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes16118 := (<-this.LoadMarkets())
            PanicOnError(retRes16118)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var isConditional interface{} = IsTrue((!IsEqual(triggerPrice, nil))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var orderQtyKey interface{} = Ternary(IsTrue(isConditional), "quantity", "order_quantity")
            var priceKey interface{} = Ternary(IsTrue(isConditional), "price", "order_price")
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, priceKey, this.PriceToPrecision(symbol, price))
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, orderQtyKey, this.AmountToPrecision(symbol, amount))
            }
            params = this.Omit(params, []interface{}{"stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"})
            var response interface{} = nil
            if IsTrue(isConditional) {
                
        response = (<-this.V1PrivatePutAlgoOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "side", ToUpper(side))
                var orderType interface{} = ToUpper(typeVar)
                var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
                var isMarket interface{} = IsEqual(orderType, "MARKET")
                var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
                if IsTrue(postOnly) {
                    AddElementToObject(request, "order_type", "POST_ONLY")
                } else if IsTrue(IsEqual(timeInForce, "fok")) {
                    AddElementToObject(request, "order_type", "FOK")
                } else if IsTrue(IsEqual(timeInForce, "ioc")) {
                    AddElementToObject(request, "order_type", "IOC")
                } else {
                    AddElementToObject(request, "order_type", orderType)
                }
                var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
                params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce"})
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "client_order_id", clientOrderId)
                }
                // request['side'] = side.toUpperCase ();
                // request['symbol'] = market['id'];
                
        response = (<-this.V1PrivatePutOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "status": "EDIT_SENT"
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            AddElementToObject(data, "timestamp", this.SafeInteger(response, "timestamp"))
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#cancelOrder
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-order-by-client_order_id
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-algo-order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-algo-order-by-client_order_id
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(!IsTrue(trigger) && IsTrue((IsEqual(symbol, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes16938 := (<-this.LoadMarkets())
            PanicOnError(retRes16938)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderIdUnified interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "client_order_id", clientOrderIdUnified)
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var response interface{} = nil
            if IsTrue(trigger) {
                if IsTrue(isByClientOrder) {
                    AddElementToObject(request, "client_order_id", clientOrderIdExchangeSpecific)
                    params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
                    
        response = (<-this.V1PrivateDeleteAlgoClientOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    AddElementToObject(request, "order_id", id)
                    
        response = (<-this.V1PrivateDeleteAlgoOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(isByClientOrder) {
                    AddElementToObject(request, "client_order_id", clientOrderIdExchangeSpecific)
                    params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
                    
        response = (<-this.V1PrivateDeleteClientOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    AddElementToObject(request, "order_id", id)
                    
        response = (<-this.V1PrivateDeleteOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "status": "CANCEL_SENT"
            //     }
            // }
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "status": "CANCEL_SENT"
            // }
            //
            var extendParams interface{} = map[string]interface{} {
                "symbol": symbol,
            }
            if IsTrue(isByClientOrder) {
                AddElementToObject(extendParams, "client_order_id", clientOrderIdExchangeSpecific)
            } else {
                AddElementToObject(extendParams, "id", id)
            }
            if IsTrue(trigger) {
        
                ch <- this.Extend(this.ParseOrder(response), extendParams)
                return nil
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.Extend(this.ParseOrder(data), extendParams)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#cancelOrders
 * @description cancel multiple orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-cancel-orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-cancel-orders-by-client_order_id
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.client_order_ids] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17658 := (<-this.LoadMarkets())
            PanicOnError(retRes17658)
            var clientOrderIds interface{} = this.SafeListN(params, []interface{}{"clOrdIDs", "clientOrderIds", "client_order_ids"})
            params = this.Omit(params, []interface{}{"clOrdIDs", "clientOrderIds", "client_order_ids"})
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(clientOrderIds) {
                AddElementToObject(request, "client_order_ids", Join(clientOrderIds, ","))
                
        response = (<-this.V1PrivateDeleteClientBatchOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "order_ids", Join(ids, ","))
                
        response = (<-this.V1PrivateDeleteBatchOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "status": "CANCEL_ALL_SENT"
            //     }
            // }
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#cancelAllOrders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-all-pending-algo-orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-orders-in-bulk
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18038 := (<-this.LoadMarkets())
            PanicOnError(retRes18038)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.V1PrivateDeleteAlgoOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivateDeleteOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                // trigger
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //      "status": "CANCEL_ALL_SENT"
            // }
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "status": "CANCEL_ALL_SENT"
            //     }
            // }
            //
        ch <- []interface{}{map[string]interface{} {
            "info": response,
        }}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchOrder
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-order-by-order_id
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-order-by-client_order_id
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-order-by-order_id
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-order-by-client_order_id
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18558 := (<-this.LoadMarkets())
            PanicOnError(retRes18558)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
            params = this.Omit(params, []interface{}{"stop", "trigger", "clOrdID", "clientOrderId", "client_order_id"})
            var response interface{} = nil
            if IsTrue(trigger) {
                if IsTrue(clientOrderId) {
                    AddElementToObject(request, "client_order_id", clientOrderId)
                    
        response = (<-this.V1PrivateGetAlgoClientOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    AddElementToObject(request, "oid", id)
                    
        response = (<-this.V1PrivateGetAlgoOrderOid(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                if IsTrue(clientOrderId) {
                    AddElementToObject(request, "client_order_id", clientOrderId)
                    
        response = (<-this.V1PrivateGetClientOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    AddElementToObject(request, "oid", id)
                    
        response = (<-this.V1PrivateGetOrderOid(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "order_id": 78151,
            //         "user_id": 12345,
            //         "price": 0.67772,
            //         "type": "LIMIT",
            //         "quantity": 20,
            //         "amount": 10,
            //         "executed_quantity": 20,
            //         "total_executed_quantity": 20,
            //         "visible_quantity": 1,
            //         "symbol": "PERP_WOO_USDC",
            //         "side": "BUY",
            //         "status": "FILLED",
            //         "total_fee": 0.5,
            //         "fee_asset": "WOO",
            //         "client_order_id": 1,
            //         "average_executed_price": 0.67772,
            //         "created_time": 1653563963000,
            //         "updated_time": 1653564213000,
            //         "realized_pnl": 123
            //     }
            // }
            //
            var orders interface{} = this.SafeDict(response, "data", response)
        
            ch <- this.ParseOrder(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @param {int} params.until timestamp in ms of the latest order to fetch
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19318 := (<-this.LoadMarkets())
            PanicOnError(retRes19318)
            var paginate interface{} = false
            var isTrigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var maxLimit interface{} = Ternary(IsTrue((isTrigger)), 100, 500)
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes193719 :=  (<-this.FetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, params, "page", maxLimit))
                    PanicOnError(retRes193719)
                    ch <- retRes193719
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            } else {
                AddElementToObject(request, "size", maxLimit)
            }
            if IsTrue(isTrigger) {
                AddElementToObject(request, "algo_type", "STOP")
            }
            requestparamsVariable := this.HandleUntilOption("end_t", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(isTrigger) {
                
        response = (<-this.V1PrivateGetAlgoOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivateGetOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "success": true,
            //         "timestamp": 1702989203989,
            //         "data": {
            //             "meta": {
            //                 "total": 9,
            //                 "records_per_page": 25,
            //                 "current_page": 1
            //             },
            //             "rows": [{
            //                 "order_id": 78151,
            //                 "user_id": 12345,
            //                 "price": 0.67772,
            //                 "type": "LIMIT",
            //                 "quantity": 20,
            //                 "amount": 10,
            //                 "executed_quantity": 20,
            //                 "total_executed_quantity": 20,
            //                 "visible_quantity": 1,
            //                 "symbol": "PERP_WOO_USDC",
            //                 "side": "BUY",
            //                 "status": "FILLED",
            //                 "total_fee": 0.5,
            //                 "fee_asset": "WOO",
            //                 "client_order_id": 1,
            //                 "average_executed_price": 0.67772,
            //                 "created_time": 1653563963000,
            //                 "updated_time": 1653564213000,
            //                 "realized_pnl": 123
            //             }]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", response)
            var orders interface{} = this.SafeList(data, "rows")
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {int} params.until timestamp in ms of the latest order to fetch
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20218 := (<-this.LoadMarkets())
            PanicOnError(retRes20218)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "INCOMPLETE",
            })
        
                retRes202315 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes202315)
                ch <- retRes202315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchClosedOrders
 * @description fetches information on multiple orders made by the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/algo order
 * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {int} params.until timestamp in ms of the latest order to fetch
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woofipro) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20448 := (<-this.LoadMarkets())
            PanicOnError(retRes20448)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "COMPLETED",
            })
        
                retRes204615 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes204615)
                ch <- retRes204615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-all-trades-of-specific-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woofipro) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20628 := (<-this.LoadMarkets())
            PanicOnError(retRes20628)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "oid": id,
            }
        
            response:= (<-this.V1PrivateGetOrderOidTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "rows": [{
            //         "id": 2,
            //         "symbol": "PERP_BTC_USDC",
            //         "fee": 0.0001,
            //         "fee_asset": "USDC",
            //         "side": "BUY",
            //         "order_id": 1,
            //         "executed_price": 123,
            //         "executed_quantity": 0.05,
            //         "executed_timestamp": 1567382401000,
            //         "is_maker": 1,
            //         "realized_pnl": 123
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchMyTrades
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-trades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
 * @param {int} params.until timestamp in ms of the latest trade to fetch
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woofipro) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21118 := (<-this.LoadMarkets())
            PanicOnError(retRes21118)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes211519 :=  (<-this.FetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes211519)
                    ch <- retRes211519
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            } else {
                AddElementToObject(request, "size", 500)
            }
            requestparamsVariable := this.HandleUntilOption("end_t", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V1PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "meta": {
            //         "total": 9,
            //         "records_per_page": 25,
            //         "current_page": 1
            //       },
            //       "rows": [{
            //         "id": 2,
            //         "symbol": "PERP_BTC_USDC",
            //         "fee": 0.0001,
            //         "fee_asset": "USDC",
            //         "side": "BUY",
            //         "order_id": 1,
            //         "executed_price": 123,
            //         "executed_quantity": 0.05,
            //         "executed_timestamp": 1567382401000,
            //         "is_maker": 1,
            //         "realized_pnl": 123
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeList(response, "holding", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "token"))
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "holding"))
        AddElementToObject(account, "frozen", this.SafeString(balance, "frozen"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name woofipro#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-current-holding
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *woofipro) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21898 := (<-this.LoadMarkets())
            PanicOnError(retRes21898)
        
            response:= (<-this.V1PrivateGetClientHolding(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "holding": [{
            //         "updated_time": 1580794149000,
            //         "token": "BTC",
            //         "holding": -28.000752,
            //         "frozen": 123,
            //         "pending_short": -2000
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) GetAssetHistoryRows(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22118 := (<-this.LoadMarkets())
            PanicOnError(retRes22118)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "balance_token", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            var transactionType interface{} = this.SafeString(params, "type")
            params = this.Omit(params, "type")
            if IsTrue(!IsEqual(transactionType, nil)) {
                AddElementToObject(request, "type", transactionType)
            }
        
            response:= (<-this.V1PrivateGetAssetHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //       "meta": {
            //         "total": 9,
            //         "records_per_page": 25,
            //         "current_page": 1
            //       },
            //       "rows": [{
            //         "id": "230707030600002",
            //         "tx_id": "0x4b0714c63cc7abae72bf68e84e25860b88ca651b7d27dad1e32bf4c027fa5326",
            //         "side": "WITHDRAW",
            //         "token": "USDC",
            //         "amount": 555,
            //         "fee": 123,
            //         "trans_status": "FAILED",
            //         "created_time": 1688699193034,
            //         "updated_time": 1688699193096,
            //         "chain_id": "986532"
            //       }]
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- []interface{}{currency, this.SafeList(data, "rows", []interface{}{})}
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(item, "token")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var amount interface{} = this.SafeNumber(item, "amount")
    var side interface{} = this.SafeString(item, "token_side")
    var direction interface{} = Ternary(IsTrue((IsEqual(side, "DEPOSIT"))), "in", "out")
    var timestamp interface{} = this.SafeInteger(item, "created_time")
    var fee interface{} = this.ParseTokenAndFeeTemp(item, "fee_token", "fee_amount")
    return this.SafeLedgerEntry(map[string]interface{} {
        "id": this.SafeString(item, "id"),
        "currency": code,
        "account": this.SafeString(item, "account"),
        "referenceAccount": nil,
        "referenceId": this.SafeString(item, "tx_id"),
        "status": this.ParseTransactionStatus(this.SafeString(item, "status")),
        "amount": amount,
        "before": nil,
        "after": nil,
        "fee": fee,
        "direction": direction,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "info": item,
    }, currency)
}
func  (this *woofipro) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "BALANCE": "transaction",
        "COLLATERAL": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name woofipro#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *woofipro) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, params))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
            ch <- this.ParseLedger(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    // example in fetchLedger
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var code interface{} = this.SafeString(transaction, "token")
    var movementDirection interface{} = this.SafeStringLower(transaction, "token_side")
    if IsTrue(IsEqual(movementDirection, "withdraw")) {
        movementDirection = "withdrawal"
    }
    var fee interface{} = this.ParseTokenAndFeeTemp(transaction, "fee_token", "fee_amount")
    var addressTo interface{} = this.SafeString(transaction, "target_address")
    var addressFrom interface{} = this.SafeString(transaction, "source_address")
    var timestamp interface{} = this.SafeInteger(transaction, "created_time")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "id", "withdraw_id"),
        "txid": this.SafeString(transaction, "tx_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "tag": this.SafeString(transaction, "extra"),
        "tagFrom": nil,
        "tagTo": nil,
        "type": movementDirection,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": this.SafeInteger(transaction, "updated_time"),
        "comment": nil,
        "internal": nil,
        "fee": fee,
        "network": nil,
    }
}
func  (this *woofipro) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "pending",
        "CONFIRMING": "pending",
        "PROCESSING": "pending",
        "COMPLETED": "ok",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name woofipro#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woofipro) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "side": "DEPOSIT",
            }
        
                retRes237415 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes237415)
                ch <- retRes237415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woofipro) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "side": "WITHDRAW",
            }
        
                retRes239215 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes239215)
                ch <- retRes239215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woofipro) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, this.Extend(request, params)))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
                //
            //     {
            //         "rows":[],
            //         "meta":{
            //             "total":0,
            //             "records_per_page":25,
            //             "current_page":1
            //         },
            //         "success":true
            //     }
            //
        ch <- this.ParseTransactions(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) GetWithdrawNonce(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PrivateGetWithdrawNonce(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "timestamp": 1702989203989,
            //         "data": {
            //             "withdraw_nonce": 1
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeNumber(data, "withdraw_nonce")
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) HashMessage(message interface{}) interface{}  {
    return Add("0x", this.Hash(message, keccak, "hex"))
}
func  (this *woofipro) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    var r interface{} = GetValue(signature, "r")
    var s interface{} = GetValue(signature, "s")
    var v interface{} = this.IntToBase16(this.Sum(27, GetValue(signature, "v")))
    return Add(Add(Add("0x", PadStart(r, 64, "0")), PadStart(s, 64, "0")), v)
}
func  (this *woofipro) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
/**
 * @method
 * @name woofipro#withdraw
 * @description make a withdrawal
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-withdraw-request
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woofipro) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24698 := (<-this.LoadMarkets())
            PanicOnError(retRes24698)
            this.CheckAddress(address)
            if IsTrue(!IsEqual(code, nil)) {
                code = ToUpper(code)
                if IsTrue(!IsEqual(code, "USDC")) {
                    panic(NotSupported(Add(this.Id, " withdraw() only support USDC")))
                }
            }
            var currency interface{} = this.Currency(code)
            var verifyingContractAddress interface{} = this.SafeString(this.Options, "verifyingContractAddress")
            var chainId interface{} = this.SafeString(params, "chainId")
            var currencyNetworks interface{} = this.SafeDict(currency, "networks", map[string]interface{} {})
            var coinNetwork interface{} = this.SafeDict(currencyNetworks, chainId, map[string]interface{} {})
            var coinNetworkId interface{} = this.SafeNumber(coinNetwork, "id")
            if IsTrue(IsEqual(coinNetworkId, nil)) {
                panic(BadRequest(Add(this.Id, " withdraw() require chainId parameter")))
            }
        
            withdrawNonce:= (<-this.GetWithdrawNonce(params))
            PanicOnError(withdrawNonce)
            var nonce interface{} = this.Nonce()
            var domain interface{} = map[string]interface{} {
                "chainId": chainId,
                "name": "Orderly",
                "verifyingContract": verifyingContractAddress,
                "version": "1",
            }
            var messageTypes interface{} = map[string]interface{} {
                "Withdraw": []interface{}{map[string]interface{} {
            "name": "brokerId",
            "type": "string",
        }, map[string]interface{} {
            "name": "chainId",
            "type": "uint256",
        }, map[string]interface{} {
            "name": "receiver",
            "type": "address",
        }, map[string]interface{} {
            "name": "token",
            "type": "string",
        }, map[string]interface{} {
            "name": "amount",
            "type": "uint256",
        }, map[string]interface{} {
            "name": "withdrawNonce",
            "type": "uint64",
        }, map[string]interface{} {
            "name": "timestamp",
            "type": "uint64",
        }},
            }
            var withdrawRequest interface{} = map[string]interface{} {
                "brokerId": this.SafeString(this.Options, "keyBrokerId", "woofi_pro"),
                "chainId": this.ParseToInt(chainId),
                "receiver": address,
                "token": code,
                "amount": ToString(amount),
                "withdrawNonce": withdrawNonce,
                "timestamp": nonce,
            }
            var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, withdrawRequest)
            var signature interface{} = this.SignMessage(msg, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "signature": signature,
                "userAddress": address,
                "verifyingContract": verifyingContractAddress,
                "message": withdrawRequest,
            }
            params = this.Omit(params, "chainId")
        
            response:= (<-this.V1PrivatePostWithdrawRequest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "timestamp": 1702989203989,
            //         "data": {
            //             "withdraw_id": 123
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var leverageValue interface{} = this.SafeInteger(leverage, "max_leverage")
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": nil,
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name woofipro#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-account-information
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *woofipro) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25588 := (<-this.LoadMarkets())
            PanicOnError(retRes25588)
            var market interface{} = this.Market(symbol)
        
            response:= (<-this.V1PrivateGetClientInfo(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "account_id": "<string>",
            //         "email": "test@test.com",
            //         "account_mode": "FUTURES",
            //         "max_leverage": 20,
            //         "taker_fee_rate": 123,
            //         "maker_fee_rate": 123,
            //         "futures_taker_fee_rate": 123,
            //         "futures_maker_fee_rate": 123,
            //         "maintenance_cancel_orders": true,
            //         "imr_factor": {
            //             "PERP_BTC_USDC": 123,
            //             "PERP_ETH_USDC": 123,
            //             "PERP_NEAR_USDC": 123
            //         },
            //         "max_notional": {
            //             "PERP_BTC_USDC": 123,
            //             "PERP_ETH_USDC": 123,
            //             "PERP_NEAR_USDC": 123
            //         }
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#setLeverage
 * @description set the level of leverage for a market
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/update-leverage-setting
 * @param {int} [leverage] the rate of leverage
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *woofipro) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26038 := (<-this.LoadMarkets())
            PanicOnError(retRes26038)
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 50)))) {
                panic(BadRequest(Add(this.Id, " leverage should be between 1 and 50")))
            }
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
        
                retRes261015 :=  (<-this.V1PrivatePostClientLeverage(this.Extend(request, params)))
                PanicOnError(retRes261015)
                ch <- retRes261015
                return nil
        
            }()
            return ch
        }
func  (this *woofipro) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "IMR_withdraw_orders": 0.1,
    //     "MMR_with_orders": 0.05,
    //     "average_open_price": 27908.14386047,
    //     "cost_position": -139329.358492,
    //     "est_liq_price": 117335.92899428,
    //     "fee_24_h": 123,
    //     "imr": 0.1,
    //     "last_sum_unitary_funding": 70.38,
    //     "mark_price": 27794.9,
    //     "mmr": 0.05,
    //     "pending_long_qty": 123,
    //     "pending_short_qty": 123,
    //     "pnl_24_h": 123,
    //     "position_qty": -5,
    //     "settle_price": 27865.8716984,
    //     "symbol": "PERP_BTC_USDC",
    //     "timestamp": 1685429350571,
    //     "unsettled_pnl": 354.858492
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var contract interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(contract, market)
    var size interface{} = this.SafeString(position, "position_qty")
    var side interface{} = nil
    if IsTrue(Precise.StringGt(size, "0")) {
        side = "long"
    } else {
        side = "short"
    }
    var contractSize interface{} = this.SafeString(market, "contractSize")
    var markPrice interface{} = this.SafeString(position, "mark_price")
    var timestamp interface{} = this.SafeInteger(position, "timestamp")
    var entryPrice interface{} = this.SafeString(position, "average_open_price")
    var unrealisedPnl interface{} = this.SafeString(position, "unsettled_pnl")
    size = Precise.StringAbs(size)
    var notional interface{} = Precise.StringMul(size, markPrice)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "entryPrice": this.ParseNumber(entryPrice),
        "notional": this.ParseNumber(notional),
        "leverage": nil,
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(size),
        "contractSize": this.ParseNumber(contractSize),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber(position, "est_liq_price"),
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": "cross",
        "marginType": nil,
        "side": side,
        "percentage": nil,
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name woofipro#fetchPosition
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-one-position-info
 * @description fetch data on an open position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *woofipro) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26948 := (<-this.LoadMarkets())
            PanicOnError(retRes26948)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PrivateGetPositionSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "IMR_withdraw_orders": 0.1,
            //         "MMR_with_orders": 0.05,
            //         "average_open_price": 27908.14386047,
            //         "cost_position": -139329.358492,
            //         "est_liq_price": 117335.92899428,
            //         "fee_24_h": 123,
            //         "imr": 0.1,
            //         "last_sum_unitary_funding": 70.38,
            //         "mark_price": 27794.9,
            //         "mmr": 0.05,
            //         "pending_long_qty": 123,
            //         "pending_short_qty": 123,
            //         "pnl_24_h": 123,
            //         "position_qty": -5,
            //         "settle_price": 27865.8716984,
            //         "symbol": "PERP_BTC_USDC",
            //         "timestamp": 1685429350571,
            //         "unsettled_pnl": 354.858492
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParsePosition(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woofipro#fetchPositions
 * @description fetch all open positions
 * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-all-positions-info
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *woofipro) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27408 := (<-this.LoadMarkets())
            PanicOnError(retRes27408)
        
            response:= (<-this.V1PrivateGetPositions(params))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "timestamp": 1702989203989,
            //     "data": {
            //         "current_margin_ratio_with_orders": 1.2385,
            //         "free_collateral": 450315.09115,
            //         "initial_margin_ratio": 0.1,
            //         "initial_margin_ratio_with_orders": 0.1,
            //         "maintenance_margin_ratio": 0.05,
            //         "maintenance_margin_ratio_with_orders": 0.05,
            //         "margin_ratio": 1.2385,
            //         "open_margin_ratio": 1.2102,
            //         "total_collateral_value": 489865.71329,
            //         "total_pnl_24_h": 123,
            //         "rows": [{
            //             "IMR_withdraw_orders": 0.1,
            //             "MMR_with_orders": 0.05,
            //             "average_open_price": 27908.14386047,
            //             "cost_position": -139329.358492,
            //             "est_liq_price": 117335.92899428,
            //             "fee_24_h": 123,
            //             "imr": 0.1,
            //             "last_sum_unitary_funding": 70.38,
            //             "mark_price": 27794.9,
            //             "mmr": 0.05,
            //             "pending_long_qty": 123,
            //             "pending_short_qty": 123,
            //             "pnl_24_h": 123,
            //             "position_qty": -5,
            //             "settle_price": 27865.8716984,
            //             "symbol": "PERP_BTC_USDC",
            //             "timestamp": 1685429350571,
            //             "unsettled_pnl": 354.858492
            //         }]
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(result, "rows", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *woofipro) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *woofipro) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    section := GetArg(optionalArgs, 0, "public")
    _ = section
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(section, 0)
    var access interface{} = GetValue(section, 1)
    var pathWithParams interface{} = this.ImplodeParams(path, params)
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), access))
    url = Add(url, Add(Add("/", version), "/"))
    params = this.Omit(params, this.ExtractParams(path))
    params = this.Keysort(params)
    if IsTrue(IsEqual(access, "public")) {
        url = Add(url, pathWithParams)
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        if IsTrue(IsTrue((IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT")))) && IsTrue((IsTrue(IsTrue(IsEqual(path, "algo/order")) || IsTrue(IsEqual(path, "order"))) || IsTrue(IsEqual(path, "batch-order"))))) {
            var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            if !IsTrue(isSandboxMode) {
                var brokerId interface{} = this.SafeString(this.Options, "brokerId", "CCXT")
                if IsTrue(IsEqual(path, "batch-order")) {
                    var ordersList interface{} = this.SafeList(params, "orders", []interface{}{})
                    for i := 0; IsLessThan(i, GetArrayLength(ordersList)); i++ {
                        AddElementToObject(GetValue(GetValue(params, "orders"), i), "order_tag", brokerId)
                    }
                } else {
                    AddElementToObject(params, "order_tag", brokerId)
                }
            }
            params = this.Keysort(params)
        }
        var auth interface{} = ""
        var ts interface{} = ToString(this.Nonce())
        url = Add(url, pathWithParams)
        var apiKey interface{} = this.ApiKey
        if IsTrue(IsLessThan(GetIndexOf(apiKey, "ed25519:"), 0)) {
            apiKey = Add("ed25519:", apiKey)
        }
        headers = map[string]interface{} {
            "orderly-account-id": this.AccountId,
            "orderly-key": apiKey,
            "orderly-timestamp": ts,
        }
        auth = Add(Add(Add(Add(Add(ts, method), "/"), version), "/"), pathWithParams)
        if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) {
            body = this.Json(params)
            auth = Add(auth, body)
            AddElementToObject(headers, "content-type", "application/json")
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(params))) {
                url = Add(url, Add("?", this.Urlencode(params)))
                auth = Add(auth, Add("?", this.Rawencode(params)))
            }
            AddElementToObject(headers, "content-type", "application/x-www-form-urlencoded")
            if IsTrue(IsEqual(method, "DELETE")) {
                body = ""
            }
        }
        var secret interface{} = this.Secret
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(secret, "ed25519:"), 0)) {
            var parts interface{} = Split(secret, "ed25519:")
            secret = GetValue(parts, 1)
        }
        var signature interface{} = Eddsa(this.Encode(auth), this.Base58ToBinary(secret), ed25519)
        AddElementToObject(headers, "orderly-signature", this.UrlencodeBase64(this.Base64ToBinary(signature)))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *woofipro) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
    //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
    //
    var success interface{} = this.SafeBool(response, "success")
    var errorCode interface{} = this.SafeString(response, "code")
    if !IsTrue(success) {
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *woofipro) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
