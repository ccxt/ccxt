package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoincatchCore struct {
	*ccxt.CoincatchCore
	base *ccxt.CoincatchCore
}

func NewCoincatchCore() *CoincatchCore {
    p := &CoincatchCore{}
	base := &ccxt.CoincatchCore{}
	p.base = base
	p.CoincatchCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoincatchCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrders": true,
            "watchMyTrades": false,
            "watchTicker": true,
            "watchTickers": true,
            "watchBalance": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.coincatch.com/public/v1/stream",
                    "private": "wss://ws.coincatch.com/private/v1/stream",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 200,
            "timeframesForWs": map[string]interface{} {
                "1m": "1m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1H",
                "4h": "4H",
                "12h": "12H",
                "1d": "1D",
                "1w": "1W",
            },
            "watchOrderBook": map[string]interface{} {
                "checksum": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "30001": ccxt.BadRequest,
                    "30002": ccxt.AuthenticationError,
                    "30003": ccxt.BadRequest,
                    "30004": ccxt.AuthenticationError,
                    "30005": ccxt.AuthenticationError,
                    "30006": ccxt.RateLimitExceeded,
                    "30007": ccxt.RateLimitExceeded,
                    "30011": ccxt.AuthenticationError,
                    "30012": ccxt.AuthenticationError,
                    "30013": ccxt.AuthenticationError,
                    "30014": ccxt.BadRequest,
                    "30015": ccxt.AuthenticationError,
                },
                "broad": map[string]interface{} {},
            },
        },
    })
}
func  (this *CoincatchCore) GetMarketFromArg(entry interface{}) interface{}  {
    var instId interface{} = this.SafeString(entry, "instId")
    var instType interface{} = this.SafeString(entry, "instType")
    var baseAndQuote interface{} = this.ParseSpotMarketId(instId)
    var baseId interface{} = ccxt.GetValue(baseAndQuote, "baseId")
    var quoteId interface{} = ccxt.GetValue(baseAndQuote, "quoteId")
    var suffix interface{} = "_SPBL" // spot suffix
    if ccxt.IsTrue(ccxt.IsEqual(instType, "mc")) {
        if ccxt.IsTrue(ccxt.IsEqual(quoteId, "USD")) {
            suffix = "_DMCBL"
        } else {
            suffix = "_UMCBL"
        }
    }
    var marketId interface{} = ccxt.Add(ccxt.Add(this.SafeCurrencyCode(baseId), this.SafeCurrencyCode(quoteId)), suffix)
    return this.SafeMarketCustom(marketId)
}
func  (this *CoincatchCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var timestamp interface{} = ccxt.ToString(this.Seconds())
                var auth interface{} = ccxt.Add(ccxt.Add(timestamp, "GET"), "/user/verify")
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var operation interface{} = "login"
                var request interface{} = map[string]interface{} {
                    "op": operation,
                    "args": []interface{}{map[string]interface{} {
            "apiKey": this.ApiKey,
            "passphrase": this.Password,
            "timestamp": timestamp,
            "sign": signature,
        }},
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes12515 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes12515)
                ch <- retRes12515
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) WatchPublic(messageHash interface{}, subscribeHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes13515 :=  (<-this.Watch(url, messageHash, message, subscribeHash))
                ccxt.PanicOnError(retRes13515)
                ch <- retRes13515
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) UnWatchPublic(messageHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes14515 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes14515)
                ch <- retRes14515
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) WatchPrivate(messageHash interface{}, subscribeHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1498 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1498)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes15615 :=  (<-this.Watch(url, messageHash, message, subscribeHash))
                ccxt.PanicOnError(retRes15615)
                ch <- retRes15615
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) WatchPrivateMultiple(messageHashes interface{}, subscribeHashes interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1608 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1608)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": args,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes16715 :=  (<-this.WatchMultiple(url, messageHashes, message, subscribeHashes))
                ccxt.PanicOnError(retRes16715)
                ch <- retRes16715
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //  { event: "login", code: 0 }
    //
    var messageHash interface{} = "authenticated"
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
    future.(*ccxt.Future).Resolve(true)
}
func  (this *CoincatchCore) WatchPublicMultiple(messageHashes interface{}, subscribeHashes interface{}, argsArray interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": argsArray,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes18615 :=  (<-this.WatchMultiple(url, messageHashes, message, subscribeHashes))
                ccxt.PanicOnError(retRes18615)
                ch <- retRes18615
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) UnWatchChannel(symbol interface{}, channel interface{}, messageHashTopic interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1908)
            var market interface{} = this.Market(symbol)
            instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
            instType := ccxt.GetValue(instTypeinstIdVariable,0)
            instId := ccxt.GetValue(instTypeinstIdVariable,1)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", messageHashTopic), ":"), symbol)
            var args interface{} = map[string]interface{} {
                "instType": instType,
                "channel": channel,
                "instId": instId,
            }
        
                retRes19915 :=  (<-this.UnWatchPublic(messageHash, args, params))
                ccxt.PanicOnError(retRes19915)
                ch <- retRes19915
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) GetPublicInstTypeAndId(market interface{}) interface{}  {
    var instId interface{} = ccxt.Add(ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId"))
    var instType interface{} = nil
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        instType = "SP"
    } else if ccxt.IsTrue(ccxt.GetValue(market, "swap")) {
        instType = "MC"
    } else {
        panic(ccxt.NotSupported(ccxt.Add(this.Id, " supports only spot and swap markets")))
    }
    return []interface{}{instType, instId}
}
func  (this *CoincatchCore) HandleDMCBLMarketByMessageHashes(market interface{}, hash interface{}, client interface{}, optionalArgs ...interface{}) interface{}  {
    timeframe := ccxt.GetArg(optionalArgs, 0, nil)
    _ = timeframe
    var marketId interface{} = ccxt.GetValue(market, "id")
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), hash)
    // the exchange counts DMCBL markets as the same market with different quote currencies
    // for example symbols ETHUSD:ETH and ETH/USD:BTC both have the same marketId ETHUSD_DMCBL
    // we need to check all markets with the same marketId to find the correct market that is in messageHashes
    var marketsWithCurrentId interface{} = this.SafeList(this.Markets_by_id, marketId, []interface{}{})
    var suffix interface{} = ""
    if ccxt.IsTrue(!ccxt.IsEqual(timeframe, nil)) {
        suffix = ccxt.Add(":", timeframe)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketsWithCurrentId)); i++ {
        market = ccxt.GetValue(marketsWithCurrentId, i)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add(hash, symbol), suffix)
        if ccxt.IsTrue(this.InArray(messageHash, messageHashes)) {
            return market
        }
    }
    return market
}
/**
 * @method
 * @name coincatch#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coincatch.github.io/github.io/en/spot/#tickers-channel
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.instType] the type of the instrument to fetch the ticker for, 'SP' for spot markets, 'MC' for futures markets (default is 'SP')
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoincatchCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2488)
            var market interface{} = this.Market(symbol)
            instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
            instType := ccxt.GetValue(instTypeinstIdVariable,0)
            instId := ccxt.GetValue(instTypeinstIdVariable,1)
            var channel interface{} = "ticker"
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
            var args interface{} = map[string]interface{} {
                "instType": instType,
                "channel": channel,
                "instId": instId,
            }
        
                retRes25815 :=  (<-this.WatchPublic(messageHash, messageHash, args, params))
                ccxt.PanicOnError(retRes25815)
                ch <- retRes25815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#unWatchTicker
 * @description unsubscribe from the ticker channel
 * @see https://coincatch.github.io/github.io/en/mix/#tickers-channel
 * @param {string} symbol unified symbol of the market to unwatch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *CoincatchCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2718)
        
                retRes27215 :=  (<-this.UnWatchChannel(symbol, "ticker", "ticker", params))
                ccxt.PanicOnError(retRes27215)
                ch <- retRes27215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://coincatch.github.io/github.io/en/mix/#tickers-channel
 * @param {string[]} symbols unified symbol of the market to watch the tickers for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoincatchCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2858)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
                instType := ccxt.GetValue(instTypeinstIdVariable,0)
                instId := ccxt.GetValue(instTypeinstIdVariable,1)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                    "channel": "ticker",
                    "instId": instId,
                }
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
            }
        
            tickers:= (<-this.WatchPublicMultiple(messageHashes, messageHashes, topics, params))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(tickers, "symbol"), tickers)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     action: 'snapshot',
    //     arg: { instType: 'sp', channel: 'ticker', instId: 'ETHUSDT' },
    //     data: [
    //         {
    //             instId: 'ETHUSDT',
    //             last: '2421.06',
    //             open24h: '2416.93',
    //             high24h: '2441.47',
    //             low24h: '2352.99',
    //             bestBid: '2421.03',
    //             bestAsk: '2421.06',
    //             baseVolume: '9445.2043',
    //             quoteVolume: '22807159.1148',
    //             ts: 1728131730687,
    //             labeId: 0,
    //             openUtc: '2414.50',
    //             chgUTC: '0.00272',
    //             bidSz: '3.866',
    //             askSz: '0.124'
    //         }
    //     ],
    //     ts: 1728131730688
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var market interface{} = this.GetMarketFromArg(arg)
    var marketId interface{} = ccxt.GetValue(market, "id")
    var hash interface{} = "ticker:"
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
        market = this.HandleDMCBLMarketByMessageHashes(market, hash, client)
    }
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = this.ParseWsTicker(this.SafeDict(data, 0, map[string]interface{} {}), market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add(hash, symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *CoincatchCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         instId: 'ETHUSDT',
    //         last: '2421.06',
    //         open24h: '2416.93',
    //         high24h: '2441.47',
    //         low24h: '2352.99',
    //         bestBid: '2421.03',
    //         bestAsk: '2421.06',
    //         baseVolume: '9445.2043',
    //         quoteVolume: '22807159.1148',
    //         ts: 1728131730687,
    //         labeId: 0,
    //         openUtc: '2414.50',
    //         chgUTC: '0.00272',
    //         bidSz: '3.866',
    //         askSz: '0.124'
    //     }
    //
    // swap
    //     {
    //         instId: 'ETHUSDT',
    //         last: '2434.47',
    //         bestAsk: '2434.48',
    //         bestBid: '2434.47',
    //         high24h: '2471.68',
    //         low24h: '2400.01',
    //         priceChangePercent: '0.00674',
    //         capitalRate: '0.000082',
    //         nextSettleTime: 1728489600000,
    //         systemTime: 1728471993602,
    //         markPrice: '2434.46',
    //         indexPrice: '2435.44',
    //         holding: '171450.25',
    //         baseVolume: '1699298.91',
    //         quoteVolume: '4144522832.32',
    //         openUtc: '2439.67',
    //         chgUTC: '-0.00213',
    //         symbolType: 1,
    //         symbolId: 'ETHUSDT_UMCBL',
    //         deliveryPrice: '0',
    //         bidSz: '26.12',
    //         askSz: '49.6'
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var last interface{} = this.SafeString(ticker, "last")
    var timestamp interface{} = this.SafeInteger2(ticker, "ts", "systemTime")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high24h"),
        "low": this.SafeString(ticker, "low24h"),
        "bid": this.SafeString(ticker, "bestBid"),
        "bidVolume": this.SafeString(ticker, "bidSz"),
        "ask": this.SafeString(ticker, "bestAsk"),
        "askVolume": this.SafeString(ticker, "askSz"),
        "vwap": nil,
        "open": this.SafeString2(ticker, "open24h", "openUtc"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": ccxt.Precise.StringMul(this.SafeString(ticker, "chgUTC"), "100"),
        "average": nil,
        "baseVolume": this.SafeNumber(ticker, "baseVolume"),
        "quoteVolume": this.SafeNumber(ticker, "quoteVolume"),
        "indexPrice": this.SafeString(ticker, "indexPrice"),
        "markPrice": this.SafeString(ticker, "markPrice"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coincatch#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://coincatch.github.io/github.io/en/spot/#candlesticks-channel
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch (not including)
 * @param {int} [limit] the maximum amount of candles to fetch (not including)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.instType] the type of the instrument to fetch the ccxt.OHLCV data for, 'SP' for spot markets, 'MC' for futures markets (default is 'SP')
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *CoincatchCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4418)
            var market interface{} = this.Market(symbol)
            var timeframes interface{} = ccxt.GetValue(this.Options, "timeframesForWs")
            var channel interface{} = ccxt.Add("candle", this.SafeString(timeframes, timeframe))
            instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
            instType := ccxt.GetValue(instTypeinstIdVariable,0)
            instId := ccxt.GetValue(instTypeinstIdVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
                "channel": channel,
                "instId": instId,
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
        
            ohlcv:= (<-this.WatchPublic(messageHash, messageHash, args, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#unWatchOHLCV
 * @description unsubscribe from the ohlcv channel
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
 * @param {string} symbol unified symbol of the market to unwatch the ohlcv for
 * @param timeframe
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoincatchCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4708)
            var timeframes interface{} = ccxt.GetValue(this.Options, "timeframesForWs")
            var interval interface{} = this.SafeString(timeframes, timeframe)
            var channel interface{} = ccxt.Add("candle", interval)
        
                retRes47415 :=  (<-this.UnWatchChannel(symbol, channel, ccxt.Add("ohlcv:", interval), params))
                ccxt.PanicOnError(retRes47415)
                ch <- retRes47415
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         action: 'update',
    //         arg: { instType: 'sp', channel: 'candle1D', instId: 'ETHUSDT' },
    //         data: [
    //             [
    //                 '1728316800000',
    //                 '2474.5',
    //                 '2478.21',
    //                 '2459.8',
    //                 '2463.51',
    //                 '86.0551'
    //             ]
    //         ],
    //         ts: 1728317607657
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var market interface{} = this.GetMarketFromArg(arg)
    var marketId interface{} = ccxt.GetValue(market, "id")
    var hash interface{} = "ohlcv:"
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var channel interface{} = this.SafeString(arg, "channel")
    var klineType interface{} = ccxt.Slice(channel, 6, nil)
    var timeframe interface{} = this.FindTimeframe(klineType)
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
        market = this.HandleDMCBLMarketByMessageHashes(market, hash, client, timeframe)
    }
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var candle interface{} = this.SafeList(data, i, []interface{}{})
        var parsed interface{} = this.ParseWsOHLCV(candle, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(hash, symbol), ":"), timeframe)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CoincatchCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         '1728316800000',
    //         '2474.5',
    //         '2478.21',
    //         '2459.8',
    //         '2463.51',
    //         '86.0551'
    //     ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name coincatch#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coincatch.github.io/github.io/en/spot/#depth-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoincatchCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes55615 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes55615)
                ch <- retRes55615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://coincatch.github.io/github.io/en/spot/#depth-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoincatchCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5708)
            var channel interface{} = "books"
            var limit interface{} = this.SafeInteger(params, "limit")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, 5))) || ccxt.IsTrue((ccxt.IsEqual(limit, 15)))) {
                params = this.Omit(params, "limit")
                channel = ccxt.Add(channel, ccxt.ToString(limit))
            }
        
                retRes57715 :=  (<-this.UnWatchChannel(symbol, channel, channel, params))
                ccxt.PanicOnError(retRes57715)
                ch <- retRes57715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coincatch.github.io/github.io/en/spot/#depth-channel
 * @param symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoincatchCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5918 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5918)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = "books"
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
                instType := ccxt.GetValue(instTypeinstIdVariable,0)
                instId := ccxt.GetValue(instTypeinstIdVariable,1)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                    "channel": channel,
                    "instId": instId,
                }
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), symbol))
            }
        
            orderbook:= (<-this.WatchPublicMultiple(messageHashes, messageHashes, topics, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         action: 'update',
    //         arg: { instType: 'sp', channel: 'books', instId: 'ETHUSDT' },
    //         data: [
    //             {
    //                 asks: [ [ 2507.07, 0.4248 ] ],
    //                 bids: [ [ 2507.05, 0.1198 ] ],
    //                 checksum: -1400923312,
    //                 ts: '1728339446908'
    //             }
    //         ],
    //         ts: 1728339446908
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var market interface{} = this.GetMarketFromArg(arg)
    var marketId interface{} = ccxt.GetValue(market, "id")
    var hash interface{} = "books:"
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
        market = this.HandleDMCBLMarketByMessageHashes(market, hash, client)
    }
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var channel interface{} = this.SafeString(arg, "channel")
    var messageHash interface{} = ccxt.Add(hash, symbol)
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var rawOrderBook interface{} = this.SafeDict(data, 0)
    var timestamp interface{} = this.SafeInteger(rawOrderBook, "ts")
    var incrementalBook interface{} = channel
    if ccxt.IsTrue(incrementalBook) {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var ob interface{} = this.CountedOrderBook(map[string]interface{} {})
            ccxt.AddElementToObject(ob, "symbol", symbol)
            ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
        }
        var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var asks interface{} = this.SafeList(rawOrderBook, "asks", []interface{}{})
        var bids interface{} = this.SafeList(rawOrderBook, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(storedOrderBook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(storedOrderBook, "bids"), bids)
        ccxt.AddElementToObject(storedOrderBook, "timestamp", timestamp)
        ccxt.AddElementToObject(storedOrderBook, "datetime", this.Iso8601(timestamp))
        var checksum interface{} = this.SafeBool(this.Options, "checksum", true)
        var isSnapshot interface{} = ccxt.IsEqual(this.SafeString(message, "action"), "snapshot")
        if ccxt.IsTrue(!ccxt.IsTrue(isSnapshot) && ccxt.IsTrue(checksum)) {
            var storedAsks interface{} = ccxt.GetValue(storedOrderBook, "asks")
            var storedBids interface{} = ccxt.GetValue(storedOrderBook, "bids")
            var asksLength interface{} =             ccxt.GetArrayLength(storedAsks)
            var bidsLength interface{} =             ccxt.GetArrayLength(storedBids)
            var payloadArray interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, 25); i++ {
                if ccxt.IsTrue(ccxt.IsLessThan(i, bidsLength)) {
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedBids, i), 2), 0))
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedBids, i), 2), 1))
                }
                if ccxt.IsTrue(ccxt.IsLessThan(i, asksLength)) {
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 2), 0))
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 2), 1))
                }
            }
            var payload interface{} = ccxt.Join(payloadArray, ":")
            var calculatedChecksum interface{} = this.Crc32(payload, true)
            var responseChecksum interface{} = this.SafeInteger(rawOrderBook, "checksum")
            if ccxt.IsTrue(!ccxt.IsEqual(calculatedChecksum, responseChecksum)) {
                this.Spawn(this.HandleCheckSumError, client, symbol, messageHash)
                return
            }
        }
    } else {
        var orderbook interface{} = this.OrderBook(map[string]interface{} {})
        var parsedOrderbook interface{} = this.ParseOrderBook(rawOrderBook, symbol, timestamp)
        orderbook.(ccxt.OrderBookInterface).Reset(parsedOrderbook)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    }
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
}
func  (this *CoincatchCore) HandleCheckSumError(client interface{}, symbol interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            retRes6918 := (<-this.UnWatchOrderBook(symbol))
            ccxt.PanicOnError(retRes6918)
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            client.(ccxt.ClientInterface).Reject(error, messageHash)
                return nil
            }()
            return ch
        }
func  (this *CoincatchCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    ccxt.AppendToArray(&bidAsk, delta)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *CoincatchCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name coincatch#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coincatch.github.io/github.io/en/spot/#trades-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *CoincatchCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes72015 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes72015)
                ch <- retRes72015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#watchTradesForSymbols
 * @description watches information on multiple trades made in a market
 * @see https://coincatch.github.io/github.io/en/spot/#trades-channel
 * @param symbols
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *CoincatchCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes7398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7398)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                instTypeinstIdVariable := this.GetPublicInstTypeAndId(market)
                instType := ccxt.GetValue(instTypeinstIdVariable,0)
                instId := ccxt.GetValue(instTypeinstIdVariable,1)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                    "channel": "trade",
                    "instId": instId,
                }
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", symbol))
            }
        
            trades:= (<-this.WatchPublicMultiple(messageHashes, messageHashes, topics, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#unWatchTrades
 * @description unsubscribe from the trades channel
 * @see https://coincatch.github.io/github.io/en/spot/#trades-channel
 * @param {string} symbol unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *CoincatchCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7748)
        
                retRes77515 :=  (<-this.UnWatchChannel(symbol, "trade", "trade", params))
                ccxt.PanicOnError(retRes77515)
                ch <- retRes77515
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         action: 'update',
    //         arg: { instType: 'sp', channel: 'trade', instId: 'ETHUSDT' },
    //         data: [ [ '1728341807469', '2421.41', '0.478', 'sell' ] ],
    //         ts: 1728341807482
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var market interface{} = this.GetMarketFromArg(arg)
    var marketId interface{} = ccxt.GetValue(market, "id")
    var hash interface{} = "trade:"
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
        market = this.HandleDMCBLMarketByMessageHashes(market, hash, client)
    }
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        data = this.SortBy(data, 0)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var trade interface{} = this.SafeList(data, i)
            var parsed interface{} = this.ParseWsTrade(trade, market)
            stored.(ccxt.Appender).Append(parsed)
        }
    }
    var messageHash interface{} = ccxt.Add(hash, symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CoincatchCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         '1728341807469',
    //         '2421.41',
    //         '0.478',
    //         'sell'
    //     ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, 0)
    return this.SafeTrade(map[string]interface{} {
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "side": this.SafeStringLower(trade, 3),
        "price": this.SafeString(trade, 1),
        "amount": this.SafeString(trade, 2),
        "cost": nil,
        "takerOrMaker": nil,
        "type": nil,
        "order": nil,
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name coincatch#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coincatch.github.io/github.io/en/spot/#account-channel
 * @see https://coincatch.github.io/github.io/en/mix/#account-channel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.type] 'spot' or 'swap' (default is 'spot')
 * @param {string} [params.instType] *swap only* 'umcbl' or 'dmcbl' (default is 'umcbl')
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *CoincatchCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var instType interface{} = "spbl" // must be lower case for spot
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) {
                instType = "umcbl"
            }
            var channel interface{} = "account"
            instTypeparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "instType", instType)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
                "channel": channel,
                "instId": "default",
            }
            var messageHash interface{} = ccxt.Add("balance:", ccxt.ToLower(instType))
        
                retRes86615 :=  (<-this.WatchPrivate(messageHash, messageHash, args, params))
                ccxt.PanicOnError(retRes86615)
                ch <- retRes86615
                return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleBalance(client interface{}, message interface{})  {
    //
    //  spot
    //     {
    //         action: 'snapshot',
    //         arg: { instType: 'spbl', channel: 'account', instId: 'default' },
    //         data: [
    //             {
    //                 coinId: '3',
    //                 coinName: 'ETH',
    //                 available: '0.0000832',
    //                 frozen: '0',
    //                 lock: '0'
    //             }
    //         ],
    //         ts: 1728464548725
    //     }
    //
    // //  swap
    //     {
    //         action: 'snapshot',
    //         arg: { instType: 'dmcbl', channel: 'account', instId: 'default' },
    //         data: [
    //             {
    //                 marginCoin: 'ETH',
    //                 locked: '0.00000000',
    //                 available: '0.00001203',
    //                 maxOpenPosAvailable: '0.00001203',
    //                 maxTransferOut: '0.00001203',
    //                 equity: '0.00001203',
    //                 usdtEquity: '0.029092328738',
    //                 coinDisplayName: 'ETH'
    //             }
    //         ],
    //         ts: 1728650777643
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawBalance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString2(rawBalance, "coinName", "marginCoin")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
        var freeQuery interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(rawBalance, "maxTransferOut"))), "maxTransferOut", "available")
        ccxt.AddElementToObject(account, "free", this.SafeString(rawBalance, freeQuery))
        ccxt.AddElementToObject(account, "total", this.SafeString(rawBalance, "equity"))
        ccxt.AddElementToObject(account, "used", this.SafeString(rawBalance, "frozen"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    var arg interface{} = this.SafeDict(message, "arg")
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var messageHash interface{} = ccxt.Add("balance:", instType)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name coincatch#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://coincatch.github.io/github.io/en/spot/#order-channel
 * @see https://coincatch.github.io/github.io/en/mix/#order-channel
 * @see https://coincatch.github.io/github.io/en/mix/#plan-order-channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap'
 * @param {string} [params.instType] *swap only* 'umcbl' or 'dmcbl' (default is 'umcbl')
 * @param {bool} [params.trigger] *swap only* whether to watch trigger orders (default is false)
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *CoincatchCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "watchOrders"
        
            retRes9438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9438)
            var market interface{} = nil
            var marketId interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                marketId = ccxt.GetValue(market, "id")
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var instType interface{} = "spbl"
            var instId interface{} = marketId
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a symbol argument for "), marketType), " markets.")))
                }
            } else {
                instId = "default"
                instType = "umcbl"
                if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                    instTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "instType", instType)
                    instType = ccxt.GetValue(instTypeparamsVariable,0)
                    params = ccxt.GetValue(instTypeparamsVariable,1)
                } else {
                    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
                        instType = "dmcbl"
                    }
                }
            }
            var channel interface{} = "orders"
            var isTrigger interface{} = this.SafeBool(params, "trigger")
            if ccxt.IsTrue(isTrigger) {
                channel = "ordersAlgo" // channel does not return any data
                params = this.Omit(params, "trigger")
            }
            var args interface{} = map[string]interface{} {
                "instType": instType,
                "channel": channel,
                "instId": instId,
            }
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            orders:= (<-this.WatchPrivate(messageHash, messageHash, args, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         action: 'snapshot',
    //         arg: { instType: 'spbl', channel: 'orders', instId: 'ETHUSDT_SPBL' },
    //         data: [
    //             {
    //                 instId: 'ETHUSDT_SPBL',
    //                 ordId: '1228627925964996608',
    //                 clOrdId: 'f0cccf74-c535-4523-a53d-dbe3b9958559',
    //                 px: '2000',
    //                 sz: '0.001',
    //                 notional: '2',
    //                 ordType: 'limit',
    //                 force: 'normal',
    //                 side: 'buy',
    //                 accFillSz: '0',
    //                 avgPx: '0',
    //                 status: 'new',
    //                 cTime: 1728653645030,
    //                 uTime: 1728653645030,
    //                 orderFee: [],
    //                 eps: 'API'
    //             }
    //         ],
    //         ts: 1728653645046
    //     }
    //
    // swap
    //
    //     {
    //         action: 'snapshot',
    //         arg: { instType: 'umcbl', channel: 'orders', instId: 'default' },
    //         data: [
    //             {
    //                 accFillSz: '0',
    //                 cTime: 1728653796976,
    //                 clOrdId: '1228628563272753152',
    //                 eps: 'API',
    //                 force: 'normal',
    //                 hM: 'single_hold',
    //                 instId: 'ETHUSDT_UMCBL',
    //                 lever: '5',
    //                 low: false,
    //                 notionalUsd: '20',
    //                 ordId: '1228628563188867072',
    //                 ordType: 'limit',
    //                 orderFee: [],
    //                 posSide: 'net',
    //                 px: '2000',
    //                 side: 'buy',
    //                 status: 'new',
    //                 sz: '0.01',
    //                 tS: 'buy_single',
    //                 tdMode: 'cross',
    //                 tgtCcy: 'USDT',
    //                 uTime: 1728653796976
    //             }
    //         ],
    //         ts: 1728653797002
    //     }
    //
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeString(arg, "instType")
    var argInstId interface{} = this.SafeString(arg, "instId")
    var marketType interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(instType, "spbl")) {
        marketType = "spot"
    } else {
        marketType = "swap"
    }
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var hash interface{} = "orders"
    var stored interface{} = this.Orders
    var symbol interface{} = nil
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(order, "instId", argInstId)
        var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
        var parsed interface{} = this.ParseWsOrder(order, market)
        stored.(ccxt.Appender).Append(parsed)
        symbol = ccxt.GetValue(parsed, "symbol")
        var messageHash interface{} = ccxt.Add("orders:", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, hash)
}
func  (this *CoincatchCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         instId: 'ETHUSDT_SPBL',
    //         ordId: '1228627925964996608',
    //         clOrdId: 'f0cccf74-c535-4523-a53d-dbe3b9958559',
    //         px: '2000',
    //         sz: '0.001',
    //         notional: '2',
    //         ordType: 'limit',
    //         force: 'normal',
    //         side: 'buy',
    //         accFillSz: '0',
    //         avgPx: '0',
    //         status: 'new',
    //         cTime: 1728653645030,
    //         uTime: 1728653645030,
    //         orderFee: orderFee: [ { fee: '0', feeCcy: 'USDT' } ],
    //         eps: 'API'
    //     }
    //
    // swap
    //     {
    //         accFillSz: '0',
    //         cTime: 1728653796976,
    //         clOrdId: '1228628563272753152',
    //         eps: 'API',
    //         force: 'normal',
    //         hM: 'single_hold',
    //         instId: 'ETHUSDT_UMCBL',
    //         lever: '5',
    //         low: false,
    //         notionalUsd: '20',
    //         ordId: '1228628563188867072',
    //         ordType: 'limit',
    //         orderFee: [ { fee: '0', feeCcy: 'USDT' } ],
    //         posSide: 'net',
    //         px: '2000',
    //         side: 'buy',
    //         status: 'new',
    //         sz: '0.01',
    //         tS: 'buy_single',
    //         tdMode: 'cross',
    //         tgtCcy: 'USDT',
    //         uTime: 1728653796976
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "instId")
    var settleId interface{} = this.SafeString(order, "tgtCcy")
    market = this.SafeMarketCustom(marketId, market, settleId)
    var timestamp interface{} = this.SafeInteger(order, "cTime")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var rawStatus interface{} = this.SafeString(order, "status")
    var orderFee interface{} = this.SafeList(order, "orderFee", []interface{}{})
    var fee interface{} = this.SafeDict(orderFee, 0)
    var feeCost interface{} = ccxt.Precise.StringMul(this.SafeString(fee, "fee"), "-1")
    var feeCurrency interface{} = this.SafeString(fee, "feeCcy")
    var price interface{} = this.OmitZero(this.SafeString(order, "px"))
    var priceAvg interface{} = this.OmitZero(this.SafeString(order, "avgPx"))
    if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
        price = priceAvg
    }
    var typeVar interface{} = this.SafeStringLower(order, "ordType")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "ordId"),
        "clientOrderId": this.SafeString(order, "clOrdId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": this.SafeInteger(order, "uTime"),
        "status": this.ParseOrderStatus(rawStatus),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": this.ParseOrderTimeInForce(this.SafeStringLower(order, "force")),
        "side": this.SafeStringLower(order, "side"),
        "price": price,
        "average": this.SafeString(order, "avgPx"),
        "amount": this.SafeString(order, "sz"),
        "filled": this.SafeString(order, "accFillSz"),
        "remaining": nil,
        "triggerPrice": nil,
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "cost": this.SafeString(order, "notional"),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": feeCurrency,
            "cost": feeCost,
        },
        "reduceOnly": this.SafeBool(order, "low"),
        "postOnly": nil,
        "info": order,
    }, market)
}
/**
 * @method
 * @name coincatch#watchPositions
 * @description watch all open positions
 * @see https://coincatch.github.io/github.io/en/mix/#positions-channel
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *CoincatchCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11958)
            symbols = this.MarketSymbols(symbols, "swap")
            var messageHashes interface{} = []interface{}{}
            var hash interface{} = "positions"
            var instTypes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    var instType interface{} = this.GetPrivateInstType(market)
                    if !ccxt.IsTrue(this.InArray(instType, instTypes)) {
                        ccxt.AppendToArray(&instTypes, instType)
                    }
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(hash, "::"), symbol))
                }
            } else {
                instTypes = []interface{}{"umcbl", "dmcbl"}
                ccxt.AppendToArray(&messageHashes, hash)
            }
            var args interface{} = []interface{}{}
            var subscribeHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(instTypes)); i++ {
                var instType interface{} = ccxt.GetValue(instTypes, i)
                var arg interface{} = map[string]interface{} {
                    "instType": instType,
                    "channel": hash,
                    "instId": "default",
                }
                ccxt.AppendToArray(&subscribeHashes, ccxt.Add(ccxt.Add(hash, "::"), instType))
                ccxt.AppendToArray(&args, arg)
            }
        
            newPositions:= (<-this.WatchPrivateMultiple(messageHashes, subscribeHashes, args, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(newPositions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CoincatchCore) GetPrivateInstType(market interface{}) interface{}  {
    var marketId interface{} = ccxt.GetValue(market, "id")
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(marketId, "_DMCBL"), 0)) {
        return "dmcbl"
    }
    return "umcbl"
}
func  (this *CoincatchCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         action: 'snapshot',
    //         arg: { instType: 'umcbl', channel: 'positions', instId: 'default' },
    //         data: [
    //             {
    //                 posId: '1221355728745619456',
    //                 instId: 'ETHUSDT_UMCBL',
    //                 instName: 'ETHUSDT',
    //                 marginCoin: 'USDT',
    //                 margin: '5.27182',
    //                 marginMode: 'crossed',
    //                 holdSide: 'long',
    //                 holdMode: 'single_hold',
    //                 total: '0.01',
    //                 available: '0.01',
    //                 locked: '0',
    //                 averageOpenPrice: '2635.91',
    //                 leverage: 5,
    //                 achievedProfits: '0',
    //                 upl: '-0.0267',
    //                 uplRate: '-0.005064664576',
    //                 liqPx: '-3110.66866033',
    //                 keepMarginRate: '0.0033',
    //                 marginRate: '0.002460827254',
    //                 cTime: '1726919818102',
    //                 uTime: '1728919604312',
    //                 markPrice: '2633.24',
    //                 autoMargin: 'off'
    //             }
    //         ],
    //         ts: 1728919604329
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var rawPositions interface{} = this.SafeValue(message, "data", []interface{}{})
    var dataLength interface{} =     ccxt.GetArrayLength(rawPositions)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    var newPositions interface{} = []interface{}{}
    var symbols interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        ccxt.AppendToArray(&symbols, ccxt.GetValue(position, "symbol"))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var hash interface{} = "positions"
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), hash)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbol interface{} = ccxt.GetValue(parts, 1)
        if ccxt.IsTrue(this.InArray(symbol, symbols)) {
            var positionsForSymbol interface{} = []interface{}{}
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(newPositions)); j++ {
                var position interface{} = ccxt.GetValue(newPositions, j)
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(position, "symbol"), symbol)) {
                    ccxt.AppendToArray(&positionsForSymbol, position)
                }
            }
            client.(ccxt.ClientInterface).Resolve(positionsForSymbol, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, hash)
}
func  (this *CoincatchCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         posId: '1221355728745619456',
    //         instId: 'ETHUSDT_UMCBL',
    //         instName: 'ETHUSDT',
    //         marginCoin: 'USDT',
    //         margin: '5.27182',
    //         marginMode: 'crossed',
    //         holdSide: 'long',
    //         holdMode: 'single_hold',
    //         total: '0.01',
    //         available: '0.01',
    //         locked: '0',
    //         averageOpenPrice: '2635.91',
    //         leverage: 5,
    //         achievedProfits: '0',
    //         upl: '-0.0267',
    //         uplRate: '-0.005064664576',
    //         liqPx: '-3110.66866033',
    //         keepMarginRate: '0.0033',
    //         marginRate: '0.002460827254',
    //         cTime: '1726919818102',
    //         uTime: '1728919604312',
    //         markPrice: '2633.24',
    //         autoMargin: 'off'
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    var settleId interface{} = this.SafeString(position, "marginCoin")
    market = this.SafeMarketCustom(marketId, market, settleId)
    var timestamp interface{} = this.SafeInteger(position, "cTime")
    var marginModeId interface{} = this.SafeString(position, "marginMode")
    var marginMode interface{} = this.GetSupportedMapping(marginModeId, map[string]interface{} {
        "crossed": "cross",
        "isolated": "isolated",
    })
    var isHedged interface{} = nil
    var holdMode interface{} = this.SafeString(position, "holdMode")
    if ccxt.IsTrue(ccxt.IsEqual(holdMode, "double_hold")) {
        isHedged = true
    } else if ccxt.IsTrue(ccxt.IsEqual(holdMode, "single_hold")) {
        isHedged = false
    }
    var percentageDecimal interface{} = this.SafeString(position, "uplRate")
    var percentage interface{} = ccxt.Precise.StringMul(percentageDecimal, "100")
    var margin interface{} = this.SafeNumber(position, "margin")
    return this.SafePosition(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "contracts": this.SafeNumber(position, "total"),
        "contractSize": nil,
        "side": this.SafeStringLower(position, "holdSide"),
        "notional": margin,
        "leverage": this.SafeInteger(position, "leverage"),
        "unrealizedPnl": this.SafeNumber(position, "upl"),
        "realizedPnl": this.SafeNumber(position, "achievedProfits"),
        "collateral": nil,
        "entryPrice": this.SafeNumber(position, "averageOpenPrice"),
        "markPrice": this.SafeNumber(position, "markPrice"),
        "liquidationPrice": this.SafeNumber(position, "liqPx"),
        "marginMode": marginMode,
        "hedged": isHedged,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": this.SafeNumber(position, "keepMarginRate"),
        "initialMargin": margin,
        "initialMarginPercentage": nil,
        "marginRatio": this.SafeNumber(position, "marginRate"),
        "lastUpdateTimestamp": this.SafeInteger(position, "uTime"),
        "lastPrice": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "percentage": percentage,
        "info": position,
    })
}
func  (this *CoincatchCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    { event: "error", code: 30001, msg: "Channel does not exist" }
    //
    var event interface{} = this.SafeString(message, "event")
    
        {
            ret__ := func(this *CoincatchCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *CoincatchCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(e, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(e)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsEqual(event, "error")) {
                var code interface{} = this.SafeString(message, "code")
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), code, feedback)
                var msg interface{} = this.SafeString(message, "msg", "")
                this.ThrowBroadlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad"), msg, feedback)
                panic(ccxt.ExchangeError(feedback))
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *CoincatchCore) HandleMessage(client interface{}, message interface{})  {
    // todo handle with subscribe and unsubscribe
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var content interface{} = this.SafeString(message, "message")
    if ccxt.IsTrue(ccxt.IsEqual(content, "pong")) {
        this.HandlePong(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "login")) {
        this.HandleAuthenticate(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribe")) {
        this.HandleSubscriptionStatus(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "unsubscribe")) {
        this.HandleUnSubscriptionStatus(client, message)
        return
    }
    var data interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(data, "channel")
    if ccxt.IsTrue(ccxt.IsEqual(channel, "ticker")) {
        this.HandleTicker(client, message)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, "candle"), 0)) {
        this.HandleOHLCV(client, message)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, "books"), 0)) {
        this.HandleOrderBook(client, message)
    }
    if ccxt.IsTrue(ccxt.IsEqual(channel, "trade")) {
        this.HandleTrades(client, message)
    }
    if ccxt.IsTrue(ccxt.IsEqual(channel, "account")) {
        this.HandleBalance(client, message)
    }
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(channel, "orders"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "ordersAlgo")))) {
        this.HandleOrder(client, message)
    }
    if ccxt.IsTrue(ccxt.IsEqual(channel, "positions")) {
        this.HandlePositions(client, message)
    }
}
func  (this *CoincatchCore) Ping(client interface{}) interface{}  {
    return "ping"
}
func  (this *CoincatchCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *CoincatchCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    return message
}
func  (this *CoincatchCore) HandleUnSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    var argsList interface{} = this.SafeList(message, "args")
    if ccxt.IsTrue(ccxt.IsEqual(argsList, nil)) {
        argsList = []interface{}{this.SafeDict(message, "arg", map[string]interface{} {})}
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(argsList)); i++ {
        var arg interface{} = ccxt.GetValue(argsList, i)
        var channel interface{} = this.SafeString(arg, "channel")
        if ccxt.IsTrue(ccxt.IsEqual(channel, "books")) {
            this.HandleOrderBookUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(channel, "trade")) {
            this.HandleTradesUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(channel, "ticker")) {
            this.HandleTickerUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.StartsWith(channel, "candle")) {
            this.HandleOHLCVUnSubscription(client, message)
        }
    }
    return message
}
func  (this *CoincatchCore) HandleOrderBookUnSubscription(client interface{}, message interface{})  {
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "sp"))), "spot", "swap")
    var instId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:orderbook:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("orderbook:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " orderbook "), symbol))
    client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *CoincatchCore) HandleTradesUnSubscription(client interface{}, message interface{})  {
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "sp"))), "spot", "swap")
    var instId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:trade:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("trade:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
        ccxt.Remove(this.Trades, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " trades "), symbol))
    client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *CoincatchCore) HandleTickerUnSubscription(client interface{}, message interface{})  {
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "sp"))), "spot", "swap")
    var instId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("ticker:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Tickers, symbol)) {
        ccxt.Remove(this.Tickers, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " ticker "), symbol))
    client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *CoincatchCore) HandleOHLCVUnSubscription(client interface{}, message interface{})  {
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "sp"))), "spot", "swap")
    var instId interface{} = this.SafeString(arg, "instId")
    var channel interface{} = this.SafeString(arg, "channel")
    var interval interface{} = ccxt.Replace(channel, "candle", "")
    var timeframes interface{} = this.SafeDict(this.Options, "timeframesForWs")
    var timeframe interface{} = this.FindTimeframe(interval, timeframes)
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:ohlcv:", timeframe), ":"), ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    if ccxt.IsTrue(ccxt.InOp(this.Ohlcvs, symbol)) {
        if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)) {
            ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        }
    }
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
}


func (this *CoincatchCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
