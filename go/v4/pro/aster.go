package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type AsterCore struct {
	*ccxt.AsterCore
	base *ccxt.AsterCore
}

func NewAsterCore() *AsterCore {
    p := &AsterCore{}
	base := &ccxt.AsterCore{}
	p.base = base
	p.AsterCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *AsterCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchBidsAsks": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchMarkPrice": true,
            "watchMarkPrices": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchMarkPrice": true,
            "unWatchMarkPrices": true,
            "unWatchBidsAsks": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchOrderBook": true,
            "unWatchOrderBookForSymbols": true,
            "unWatchOHLCV": true,
            "unWatchOHLCVForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://sstream.asterdex.com/stream",
                    "swap": "wss://fstream.asterdex.com/stream",
                },
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *AsterCore) GetAccountTypeFromSubscriptions(subscriptions interface{}) interface{}  {
    var accountType interface{} = ""
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
        var subscription interface{} = ccxt.GetValue(subscriptions, i)
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, "spot"))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "swap")))) {
            accountType = subscription
            break
        }
    }
    return accountType
}
/**
 * @method
 * @name aster#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTicker")
        
            retRes788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes788)
            symbol = this.SafeSymbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTicker
 * @description unWatches a price ticker
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchTicker")
        
                retRes9615 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes9615)
                ch <- retRes9615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1108)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchTickers")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@ticker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1548)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchTickers")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@ticker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes17815 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes17815)
                ch <- retRes17815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchMarkPrice
 * @description watches a mark price for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchMarkPrice")
        
            retRes1938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1938)
            symbol = this.SafeSymbol(symbol)
        
            tickers:= (<-this.WatchMarkPrices([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchMarkPrice
 * @description unWatches a mark price for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchMarkPrice")
        
                retRes21115 :=  (<-this.UnWatchMarkPrices([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes21115)
                ch <- retRes21115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchMarkPrices
 * @description watches the mark price for all markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2258)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchMarkPrices")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            var use1sFreq interface{} = this.SafeBool(params, "use1sFreq", true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var suffix interface{} = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@markPrice"), suffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchMarkPrices
 * @description watches the mark price for all markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2718)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchMarkPrices")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            var use1sFreq interface{} = this.SafeBool(params, "use1sFreq", true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var suffix interface{} = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@markPrice"), suffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes29715 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes29715)
                ch <- retRes29715
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "trumpusdt@ticker",
    //         "data": {
    //             "e": "24hrTicker",
    //             "E": 1754451187277,
    //             "s": "CAKEUSDT",
    //             "p": "-0.08800",
    //             "P": "-3.361",
    //             "w": "2.58095",
    //             "c": "2.53000",
    //             "Q": "5",
    //             "o": "2.61800",
    //             "h": "2.64700",
    //             "l": "2.52400",
    //             "v": "15775",
    //             "q": "40714.46000",
    //             "O": 1754364780000,
    //             "C": 1754451187274,
    //             "F": 6571389,
    //             "L": 6574507,
    //             "n": 3119
    //         }
    //     }
    //     {
    //         "stream": "btcusdt@markPrice",
    //         "data": {
    //             "e": "markPriceUpdate",
    //             "E": 1754660466000,
    //             "s": "BTCUSDT",
    //             "p": "116809.60000000",
    //             "P": "116595.54012838",
    //             "i": "116836.93534884",
    //             "r": "0.00010000",
    //             "T": 1754668800000
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var ticker interface{} = this.SafeDict(message, "data")
    var parsed interface{} = this.ParseWsTicker(ticker, marketType)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *AsterCore) ParseWsTicker(message interface{}, marketType interface{}) interface{}  {
    var event interface{} = this.SafeString(message, "e")
    var part interface{} = ccxt.Split(event, "@")
    var channel interface{} = this.SafeString(part, 1)
    var marketId interface{} = this.SafeString(message, "s")
    var timestamp interface{} = this.SafeInteger(message, "E")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var last interface{} = this.SafeString(message, "c")
    if ccxt.IsTrue(ccxt.IsEqual(channel, "markPriceUpdate")) {
        return this.SafeTicker(map[string]interface{} {
            "symbol": ccxt.GetValue(market, "symbol"),
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
            "info": message,
            "markPrice": this.SafeString(message, "p"),
            "indexPrice": this.SafeString(message, "i"),
        })
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(message, "h"),
        "low": this.SafeString(message, "l"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": this.SafeString(message, "w"),
        "open": this.SafeString(message, "o"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(message, "p"),
        "percentage": this.SafeString(message, "P"),
        "average": nil,
        "baseVolume": this.SafeString(message, "v"),
        "quoteVolume": this.SafeString(message, "q"),
        "info": message,
    }, market)
}
/**
 * @method
 * @name aster#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-book-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4038)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBidsAsks() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@bookTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchBidsAsks
 * @description unWatches best bid & ask for symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-book-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4448 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4448)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchBidsAsks() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@bookTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:bidask:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes46515 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes46515)
                ch <- retRes46515
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@bookTicker",
    //         "data": {
    //             "e": "bookTicker",
    //             "u": 157240846459,
    //             "s": "BTCUSDT",
    //             "b": "122046.7",
    //             "B": "1.084",
    //             "a": "122046.8",
    //             "A": "0.001",
    //             "T": 1754896692922,
    //             "E": 1754896692926
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var ticker interface{} = this.ParseWsBidAsk(data, market)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *AsterCore) ParseWsBidAsk(message interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(message, "T")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(message, "a"),
        "askVolume": this.SafeString(message, "A"),
        "bid": this.SafeString(message, "b"),
        "bidVolume": this.SafeString(message, "B"),
        "info": message,
    }, market)
}
/**
 * @method
 * @name aster#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *AsterCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes52615 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes52615)
                ch <- retRes52615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTrades
 * @description unsubscribe from the trades channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *AsterCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchTrades")
        
                retRes54115 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes54115)
                ch <- retRes54115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *AsterCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5578)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchTradesForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@aggTrade"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", ccxt.GetValue(market, "symbol")))
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTradesForSymbols
 * @description unsubscribe from the trades channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *AsterCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6018)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchTradesForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@aggTrade"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trade:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes62515 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes62515)
                ch <- retRes62515
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@aggTrade",
    //         "data": {
    //             "e": "aggTrade",
    //             "E": 1754551358681,
    //             "a": 20505890,
    //             "s": "BTCUSDT",
    //             "p": "114783.7",
    //             "q": "0.020",
    //             "f": 26024678,
    //             "l": 26024682,
    //             "T": 1754551358528,
    //             "m": false
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var trade interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(trade, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var parsed interface{} = this.ParseWsTrade(trade, market)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *AsterCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "T")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var amountString interface{} = this.SafeString(trade, "q")
    var priceString interface{} = this.SafeString(trade, "p")
    var isMaker interface{} = this.SafeBool(trade, "m")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(isMaker, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(isMaker), "maker", "taker")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "a"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": nil,
        "type": nil,
        "side": nil,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name aster#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrderBook")
        
                retRes70515 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes70515)
                ch <- retRes70515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string} symbol symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchOrderBook")
        
                retRes72115 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes72115)
                ch <- retRes72115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7368)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOrderBookForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(limit, nil)) || ccxt.IsTrue((ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(limit, 5)) && ccxt.IsTrue(!ccxt.IsEqual(limit, 10))) && ccxt.IsTrue(!ccxt.IsEqual(limit, 20))))) {
                limit = 20
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@depth"), limit))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol")))
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOrderBookForSymbols
 * @description unsubscribe from the orderbook channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string[]} symbols unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7798)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchOrderBookForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            var limit interface{} = this.SafeNumber(params, "limit")
            params = this.Omit(params, "limit")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(limit, nil)) || ccxt.IsTrue((ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(limit, 5)) && ccxt.IsTrue(!ccxt.IsEqual(limit, 10))) && ccxt.IsTrue(!ccxt.IsEqual(limit, 20))))) {
                limit = 20
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@depth"), limit))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes80815 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes80815)
                ch <- retRes80815
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@depth20",
    //         "data": {
    //             "e": "depthUpdate",
    //             "E": 1754556878284,
    //             "T": 1754556878031,
    //             "s": "BTCUSDT",
    //             "U": 156391349814,
    //             "u": 156391349814,
    //             "pu": 156391348236,
    //             "b": [
    //                 [
    //                     "114988.3",
    //                     "0.147"
    //                 ]
    //             ],
    //             "a": [
    //                 [
    //                     "114988.4",
    //                     "1.060"
    //                 ]
    //             ]
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    var timestamp interface{} = this.SafeInteger(data, "T")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "b", "a")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name aster#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            retRes8728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8728)
            symbol = this.SafeSymbol(symbol)
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchOHLCV")
        
                retRes89115 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes89115)
                ch <- retRes89115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9078)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOHLCVForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@kline_"), timeframeId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol")), ":"), unfiedTimeframe))
            }
            symboltimeframestoredVariable := (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9558)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchOHLCVForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@kline_"), timeframeId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:ohlcv:", ccxt.GetValue(market, "symbol")), ":"), unfiedTimeframe))
            }
        
                retRes98415 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes98415)
                ch <- retRes98415
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@kline_1m",
    //         "data": {
    //             "e": "kline",
    //             "E": 1754655777119,
    //             "s": "BTCUSDT",
    //             "k": {
    //                 "t": 1754655720000,
    //                 "T": 1754655779999,
    //                 "s": "BTCUSDT",
    //                 "i": "1m",
    //                 "f": 26032629,
    //                 "L": 26032629,
    //                 "o": "116546.9",
    //                 "c": "116546.9",
    //                 "h": "116546.9",
    //                 "l": "116546.9",
    //                 "v": "0.011",
    //                 "n": 1,
    //                 "x": false,
    //                 "q": "1282.0159",
    //                 "V": "0.000",
    //                 "Q": "0.0000",
    //                 "B": "0"
    //             }
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var kline interface{} = this.SafeDict(data, "k")
    var timeframeId interface{} = this.SafeString(kline, "i")
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var ohlcvsByTimeframe interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ohlcvsByTimeframe, nil)) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ohlcvsByTimeframe, timeframe), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(kline)
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *AsterCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
func  (this *AsterCore) HandleMessage(client interface{}, message interface{})  {
    var stream interface{} = this.SafeString(message, "stream")
    if ccxt.IsTrue(!ccxt.IsEqual(stream, nil)) {
        var part interface{} = ccxt.Split(stream, "@")
        var topic interface{} = this.SafeString(part, 1, "")
        var part2 interface{} = ccxt.Split(topic, "_")
        topic = this.SafeString(part2, 0, "")
        var methods interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "aggTrade": this.HandleTrade,
            "depth5": this.HandleOrderBook,
            "depth10": this.HandleOrderBook,
            "depth20": this.HandleOrderBook,
            "kline": this.HandleOHLCV,
            "markPrice": this.HandleTicker,
            "bookTicker": this.HandleBidAsk,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *AsterCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
