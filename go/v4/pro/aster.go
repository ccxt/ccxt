package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type AsterCore struct {
	*ccxt.AsterCore
	base *ccxt.AsterCore
}

func NewAsterCore() *AsterCore {
    p := &AsterCore{}
	base := &ccxt.AsterCore{}
	p.base = base
	p.AsterCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *AsterCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchBidsAsks": true,
            "watchMarkPrice": true,
            "watchMarkPrices": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchPositions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchMyTrades": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchMarkPrice": true,
            "unWatchMarkPrices": true,
            "unWatchBidsAsks": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchOrderBook": true,
            "unWatchOrderBookForSymbols": true,
            "unWatchOHLCV": true,
            "unWatchOHLCVForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": map[string]interface{} {
                        "spot": "wss://sstream.asterdex.com/stream",
                        "swap": "wss://fstream.asterdex.com/stream",
                    },
                    "private": map[string]interface{} {
                        "spot": "wss://sstream.asterdex.com/ws",
                        "swap": "wss://fstream.asterdex.com/ws",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "listenKey": map[string]interface{} {
                "spot": nil,
                "swap": nil,
            },
            "lastAuthenticatedTime": map[string]interface{} {
                "spot": 0,
                "swap": 0,
            },
            "listenKeyRefreshRate": map[string]interface{} {
                "spot": 3600000,
                "swap": 3600000,
            },
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": false,
                "awaitBalanceSnapshot": true,
            },
            "wallet": "wb",
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *AsterCore) GetAccountTypeFromSubscriptions(subscriptions interface{}) interface{}  {
    var accountType interface{} = ""
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
        var subscription interface{} = ccxt.GetValue(subscriptions, i)
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, "spot"))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "swap")))) {
            accountType = subscription
            break
        }
    }
    return accountType
}
/**
 * @method
 * @name aster#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTicker")
        
            retRes1108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1108)
            symbol = this.SafeSymbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTicker
 * @description unWatches a price ticker
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchTicker")
        
                retRes12815 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes12815)
                ch <- retRes12815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1428)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchTickers")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@ticker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1868)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchTickers")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@ticker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes21015 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes21015)
                ch <- retRes21015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchMarkPrice
 * @description watches a mark price for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchMarkPrice")
        
            retRes2258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2258)
            symbol = this.SafeSymbol(symbol)
        
            tickers:= (<-this.WatchMarkPrices([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchMarkPrice
 * @description unWatches a mark price for a specific market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchMarkPrice")
        
                retRes24315 :=  (<-this.UnWatchMarkPrices([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes24315)
                ch <- retRes24315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchMarkPrices
 * @description watches the mark price for all markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2578)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchMarkPrices")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            var use1sFreq interface{} = this.SafeBool(params, "use1sFreq", true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var suffix interface{} = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@markPrice"), suffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchMarkPrices
 * @description watches the mark price for all markets
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3038)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchMarkPrices")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            var use1sFreq interface{} = this.SafeBool(params, "use1sFreq", true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var suffix interface{} = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@markPrice"), suffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes32915 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes32915)
                ch <- retRes32915
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "trumpusdt@ticker",
    //         "data": {
    //             "e": "24hrTicker",
    //             "E": 1754451187277,
    //             "s": "CAKEUSDT",
    //             "p": "-0.08800",
    //             "P": "-3.361",
    //             "w": "2.58095",
    //             "c": "2.53000",
    //             "Q": "5",
    //             "o": "2.61800",
    //             "h": "2.64700",
    //             "l": "2.52400",
    //             "v": "15775",
    //             "q": "40714.46000",
    //             "O": 1754364780000,
    //             "C": 1754451187274,
    //             "F": 6571389,
    //             "L": 6574507,
    //             "n": 3119
    //         }
    //     }
    //     {
    //         "stream": "btcusdt@markPrice",
    //         "data": {
    //             "e": "markPriceUpdate",
    //             "E": 1754660466000,
    //             "s": "BTCUSDT",
    //             "p": "116809.60000000",
    //             "P": "116595.54012838",
    //             "i": "116836.93534884",
    //             "r": "0.00010000",
    //             "T": 1754668800000
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var ticker interface{} = this.SafeDict(message, "data")
    var parsed interface{} = this.ParseWsTicker(ticker, marketType)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *AsterCore) ParseWsTicker(message interface{}, marketType interface{}) interface{}  {
    var event interface{} = this.SafeString(message, "e")
    var part interface{} = ccxt.Split(event, "@")
    var channel interface{} = this.SafeString(part, 1)
    var marketId interface{} = this.SafeString(message, "s")
    var timestamp interface{} = this.SafeInteger(message, "E")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var last interface{} = this.SafeString(message, "c")
    if ccxt.IsTrue(ccxt.IsEqual(channel, "markPriceUpdate")) {
        return this.SafeTicker(map[string]interface{} {
            "symbol": ccxt.GetValue(market, "symbol"),
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
            "info": message,
            "markPrice": this.SafeString(message, "p"),
            "indexPrice": this.SafeString(message, "i"),
        })
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(message, "h"),
        "low": this.SafeString(message, "l"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": this.SafeString(message, "w"),
        "open": this.SafeString(message, "o"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(message, "p"),
        "percentage": this.SafeString(message, "P"),
        "average": nil,
        "baseVolume": this.SafeString(message, "v"),
        "quoteVolume": this.SafeString(message, "q"),
        "info": message,
    }, market)
}
/**
 * @method
 * @name aster#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-book-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4358)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBidsAsks() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@bookTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(market, "symbol")))
            }
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchBidsAsks
 * @description unWatches best bid & ask for symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-symbol
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-symbol-book-ticker-streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *AsterCore) UnWatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4768)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchBidsAsks() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@bookTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:bidask:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes49715 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes49715)
                ch <- retRes49715
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@bookTicker",
    //         "data": {
    //             "e": "bookTicker",
    //             "u": 157240846459,
    //             "s": "BTCUSDT",
    //             "b": "122046.7",
    //             "B": "1.084",
    //             "a": "122046.8",
    //             "A": "0.001",
    //             "T": 1754896692922,
    //             "E": 1754896692926
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var ticker interface{} = this.ParseWsBidAsk(data, market)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *AsterCore) ParseWsBidAsk(message interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(message, "T")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(message, "a"),
        "askVolume": this.SafeString(message, "A"),
        "bid": this.SafeString(message, "b"),
        "bidVolume": this.SafeString(message, "B"),
        "info": message,
    }, market)
}
/**
 * @method
 * @name aster#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *AsterCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes55815 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes55815)
                ch <- retRes55815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTrades
 * @description unsubscribe from the trades channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *AsterCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchTrades")
        
                retRes57315 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes57315)
                ch <- retRes57315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *AsterCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5898)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchTradesForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@aggTrade"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", ccxt.GetValue(market, "symbol")))
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchTradesForSymbols
 * @description unsubscribe from the trades channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *AsterCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6338 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6338)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchTradesForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(this.SafeStringLower(market, "id"), "@aggTrade"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trade:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes65715 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes65715)
                ch <- retRes65715
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@aggTrade",
    //         "data": {
    //             "e": "aggTrade",
    //             "E": 1754551358681,
    //             "a": 20505890,
    //             "s": "BTCUSDT",
    //             "p": "114783.7",
    //             "q": "0.020",
    //             "f": 26024678,
    //             "l": 26024682,
    //             "T": 1754551358528,
    //             "m": false
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var trade interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(trade, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var parsed interface{} = this.ParseWsTrade(trade, market)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *AsterCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public watchTrades
    //
    //     {
    //         "e": "trade",       // event type
    //         "E": 1579481530911, // event time
    //         "s": "ETHBTC",      // symbol
    //         "t": 158410082,     // trade id
    //         "p": "0.01914100",  // price
    //         "q": "0.00700000",  // quantity
    //         "b": 586187049,     // buyer order id
    //         "a": 586186710,     // seller order id
    //         "T": 1579481530910, // trade time
    //         "m": false,         // is the buyer the market maker
    //         "M": true           // binance docs say it should be ignored
    //     }
    //
    //     {
    //        "e": "aggTrade",  // Event type
    //        "E": 123456789,   // Event time
    //        "s": "BNBBTC",    // Symbol
    //        "a": 12345,       // Aggregate trade ID
    //        "p": "0.001",     // Price
    //        "q": "100",       // Quantity
    //        "f": 100,         // First trade ID
    //        "l": 105,         // Last trade ID
    //        "T": 123456785,   // ccxt.Trade time
    //        "m": true,        // Is the buyer the market maker?
    //        "M": true         // Ignore
    //     }
    //
    // private watchMyTrades spot
    //
    //     {
    //         "e": "executionReport",
    //         "E": 1611063861489,
    //         "s": "BNBUSDT",
    //         "c": "m4M6AD5MF3b1ERe65l4SPq",
    //         "S": "BUY",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "2.00000000",
    //         "p": "0.00000000",
    //         "P": "0.00000000",
    //         "F": "0.00000000",
    //         "g": -1,
    //         "C": '',
    //         "x": "TRADE",
    //         "X": "PARTIALLY_FILLED",
    //         "r": "NONE",
    //         "i": 1296882607,
    //         "l": "0.33200000",
    //         "z": "0.33200000",
    //         "L": "46.86600000",
    //         "n": "0.00033200",
    //         "N": "BNB",
    //         "T": 1611063861488,
    //         "t": 109747654,
    //         "I": 2696953381,
    //         "w": false,
    //         "m": false,
    //         "M": true,
    //         "O": 1611063861488,
    //         "Z": "15.55951200",
    //         "Y": "15.55951200",
    //         "Q": "0.00000000"
    //     }
    //
    // private watchMyTrades future/delivery
    //
    //     {
    //         "s": "BTCUSDT",
    //         "c": "pb2jD6ZQHpfzSdUac8VqMK",
    //         "S": "SELL",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "0.001",
    //         "p": "0",
    //         "ap": "33468.46000",
    //         "sp": "0",
    //         "x": "TRADE",
    //         "X": "FILLED",
    //         "i": 13351197194,
    //         "l": "0.001",
    //         "z": "0.001",
    //         "L": "33468.46",
    //         "n": "0.00027086",
    //         "N": "BNB",
    //         "T": 1612095165362,
    //         "t": 458032604,
    //         "b": "0",
    //         "a": "0",
    //         "m": false,
    //         "R": false,
    //         "wt": "CONTRACT_PRICE",
    //         "ot": "MARKET",
    //         "ps": "BOTH",
    //         "cp": false,
    //         "rp": "0.00335000",
    //         "pP": false,
    //         "si": 0,
    //         "ss": 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString2(trade, "t", "a")
    var timestamp interface{} = this.SafeInteger(trade, "T")
    var price interface{} = this.SafeString2(trade, "L", "p")
    var amount interface{} = this.SafeString2(trade, "q", "l")
    var cost interface{} = this.SafeString(trade, "Y")
    if ccxt.IsTrue(ccxt.IsEqual(cost, nil)) {
        if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(price, nil))) && ccxt.IsTrue((!ccxt.IsEqual(amount, nil)))) {
            cost = ccxt.Precise.StringMul(price, amount)
        }
    }
    var marketId interface{} = this.SafeString(trade, "s")
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(market, nil))), this.SafeString(this.Options, "defaultType", "spot"), ccxt.GetValue(market, "type"))
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, defaultType)
    var side interface{} = this.SafeStringLower(trade, "S")
    var takerOrMaker interface{} = nil
    var orderId interface{} = this.SafeString(trade, "i")
    if ccxt.IsTrue(ccxt.InOp(trade, "m")) {
        if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
            side = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "sell", "buy") // this is reversed intentionally
        }
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "maker", "taker")
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "n")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "N")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var typeVar interface{} = this.SafeStringLower(trade, "o")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    })
}
/**
 * @method
 * @name aster#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrderBook")
        
                retRes86515 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes86515)
                ch <- retRes86515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string} symbol symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchOrderBook")
        
                retRes88115 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes88115)
                ch <- retRes88115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8968)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOrderBookForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(limit, nil)) || ccxt.IsTrue((ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(limit, 5)) && ccxt.IsTrue(!ccxt.IsEqual(limit, 10))) && ccxt.IsTrue(!ccxt.IsEqual(limit, 20))))) {
                limit = 20
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@depth"), ccxt.ToString(limit)))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol")))
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOrderBookForSymbols
 * @description unsubscribe from the orderbook channel
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
 * @param {string[]} symbols unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *AsterCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9398)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchOrderBookForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            var limit interface{} = this.SafeNumber(params, "limit")
            params = this.Omit(params, "limit")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(limit, nil)) || ccxt.IsTrue((ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(limit, 5)) && ccxt.IsTrue(!ccxt.IsEqual(limit, 10))) && ccxt.IsTrue(!ccxt.IsEqual(limit, 20))))) {
                limit = 20
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@depth"), limit))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", ccxt.GetValue(market, "symbol")))
            }
        
                retRes96815 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes96815)
                ch <- retRes96815
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@depth20",
    //         "data": {
    //             "e": "depthUpdate",
    //             "E": 1754556878284,
    //             "T": 1754556878031,
    //             "s": "BTCUSDT",
    //             "U": 156391349814,
    //             "u": 156391349814,
    //             "pu": 156391348236,
    //             "b": [
    //                 [
    //                     "114988.3",
    //                     "0.147"
    //                 ]
    //             ],
    //             "a": [
    //                 [
    //                     "114988.4",
    //                     "1.060"
    //                 ]
    //             ]
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    var timestamp interface{} = this.SafeInteger(data, "T")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "b", "a")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name aster#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            retRes10328 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10328)
            symbol = this.SafeSymbol(symbol)
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "unWatchOHLCV")
        
                retRes105115 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes105115)
                ch <- retRes105115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes10678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10678)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOHLCVForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@kline_"), timeframeId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol")), ":"), unfiedTimeframe))
            }
            symboltimeframestoredVariable := (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AsterCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11158)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            var methodName interface{} = nil
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "unWatchOHLCVForSymbols")
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires a non-empty array of symbols")))
            }
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = this.SafeString(firstMarket, "type", "swap")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), typeVar)
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(this.SafeStringLower(market, "id"), "@kline_"), timeframeId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:ohlcv:", ccxt.GetValue(market, "symbol")), ":"), unfiedTimeframe))
            }
        
                retRes114415 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), []interface{}{typeVar}))
                ccxt.PanicOnError(retRes114415)
                ch <- retRes114415
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "stream": "btcusdt@kline_1m",
    //         "data": {
    //             "e": "kline",
    //             "E": 1754655777119,
    //             "s": "BTCUSDT",
    //             "k": {
    //                 "t": 1754655720000,
    //                 "T": 1754655779999,
    //                 "s": "BTCUSDT",
    //                 "i": "1m",
    //                 "f": 26032629,
    //                 "L": 26032629,
    //                 "o": "116546.9",
    //                 "c": "116546.9",
    //                 "h": "116546.9",
    //                 "l": "116546.9",
    //                 "v": "0.011",
    //                 "n": 1,
    //                 "x": false,
    //                 "q": "1282.0159",
    //                 "V": "0.000",
    //                 "Q": "0.0000",
    //                 "B": "0"
    //             }
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var kline interface{} = this.SafeDict(data, "k")
    var timeframeId interface{} = this.SafeString(kline, "i")
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var ohlcvsByTimeframe interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ohlcvsByTimeframe, nil)) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ohlcvsByTimeframe, timeframe), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(kline)
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *AsterCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
func  (this *AsterCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    typeVar := ccxt.GetArg(optionalArgs, 0, "spot")
            _ = typeVar
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var time interface{} = this.Milliseconds()
            var lastAuthenticatedTimeOptions interface{} = this.SafeDict(this.Options, "lastAuthenticatedTime", map[string]interface{} {})
            var lastAuthenticatedTime interface{} = this.SafeInteger(lastAuthenticatedTimeOptions, typeVar, 0)
            var listenKeyRefreshRateOptions interface{} = this.SafeDict(this.Options, "listenKeyRefreshRate", map[string]interface{} {})
            var listenKeyRefreshRate interface{} = this.SafeInteger(listenKeyRefreshRateOptions, typeVar, 3600000) // 1 hour
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), listenKeyRefreshRate)) {
                var response interface{} = nil
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    
            response = (<-this.SapiPrivatePostV1ListenKey(params))
                        ccxt.PanicOnError(response)
                } else {
                    
            response = (<-this.FapiPrivatePostV1ListenKey(params))
                        ccxt.PanicOnError(response)
                }
                ccxt.AddElementToObject(ccxt.GetValue(this.Options, "listenKey"), typeVar, this.SafeString(response, "listenKey"))
                ccxt.AddElementToObject(ccxt.GetValue(this.Options, "lastAuthenticatedTime"), typeVar, time)
                params = this.Extend(map[string]interface{} {
                    "type": typeVar,
                }, params)
                this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
            }
                return nil
            }()
            return ch
        }
func  (this *AsterCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = this.SafeString(params, "type", "spot")
            var listenKeyOptions interface{} = this.SafeDict(this.Options, "listenKey", map[string]interface{} {})
            var listenKey interface{} = this.SafeString(listenKeyOptions, typeVar)
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            
                {
                     func(this *AsterCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *AsterCore) interface{} {
                                    // catch block:
                                            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), typeVar), "/"), listenKey)
                    var client interface{} = this.Client(url)
                    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
                        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
                        client.(ccxt.ClientInterface).Reject(error, messageHash)
                    }
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "listenKey"), typeVar, nil)
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "lastAuthenticatedTime"), typeVar, 0)
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes124212 := (<-this.SapiPrivatePutV1ListenKey())
                    ccxt.PanicOnError(retRes124212) // extend the expiry
            		    return nil
            	    }(this)
                
                    }
            // whether or not to schedule another listenKey keepAlive request
            var listenKeyRefreshOptions interface{} = this.SafeDict(this.Options, "listenKeyRefresh", map[string]interface{} {})
            var listenKeyRefreshRate interface{} = this.SafeInteger(listenKeyRefreshOptions, "listenKeyRefreshRate", 3600000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
                return nil
            }()
            return ch
        }
func  (this *AsterCore) GetPrivateUrl(optionalArgs ...interface{}) interface{}  {
    typeVar := ccxt.GetArg(optionalArgs, 0, "spot")
    _ = typeVar
    var listenKeyOptions interface{} = this.SafeDict(this.Options, "listenKey", map[string]interface{} {})
    var listenKey interface{} = this.SafeString(listenKeyOptions, typeVar)
    var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), typeVar), "/"), listenKey)
    return url
}
/**
 * @method
 * @name aster#watchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-account_update
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-balance-and-position-update
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', default is 'spot'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *AsterCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12798)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params, typeVar)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes12828 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes12828)
            var url interface{} = this.GetPrivateUrl(typeVar)
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar)
            var options interface{} = this.SafeDict(this.Options, "watchBalance")
            var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
            var awaitBalanceSnapshot interface{} = this.SafeBool(options, "awaitBalanceSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes129012 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes129012)
            }
            var messageHash interface{} = ccxt.Add(typeVar, ":balance")
            var message interface{} = nil
        
                retRes129415 :=  (<-this.Watch(url, messageHash, message, typeVar))
                ccxt.PanicOnError(retRes129415)
                ch <- retRes129415
                return nil
        
            }()
            return ch
        }
func  (this *AsterCore) SetBalanceCache(client interface{}, typeVar interface{})  {
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), typeVar))) && ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar)))) {
        return
    }
    var options interface{} = this.SafeValue(this.Options, "watchBalance")
    var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
    if ccxt.IsTrue(fetchBalanceSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash, typeVar)
        }
    } else {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
}
func  (this *AsterCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
        
            response:= (<-this.FetchBalance(params))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeValue(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve()
                client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
            }
                return nil
            }()
            return ch
        }
func  (this *AsterCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot balance update
    //     {
    //         "B": [
    //             {
    //                 "a": "USDT",
    //                 "f": "16.29445191",
    //                 "l": "0"
    //             },
    //             {
    //                 "a": "ETH",
    //                 "f": "0.00199920",
    //                 "l": "0"
    //             }
    //         ],
    //         "e": "outboundAccountPosition",
    //         "T": 1768547778317,
    //         "u": 1768547778317,
    //         "E": 1768547778321,
    //         "m": "ORDER"
    //     }
    //
    // swap balance and position update
    //     {
    //         "e": "ACCOUNT_UPDATE",
    //         "T": 1768551627708,
    //         "E": 1768551627710,
    //         "a": {
    //             "B": [
    //                 {
    //                     "a": "USDT",
    //                     "wb": "39.41184271",
    //                     "cw": "39.41184271",
    //                     "bc": "0"
    //                 }
    //             ],
    //             "P": [
    //                 {
    //                     "s": "ETHUSDT",
    //                     "pa": "0",
    //                     "ep": "0.00000000",
    //                     "cr": "-0.59070000",
    //                     "up": "0",
    //                     "mt": "isolated",
    //                     "iw": "0",
    //                     "ps": "BOTH",
    //                     "ma": "USDT"
    //                 }
    //             ],
    //             "m": "ORDER"
    //         }
    //     }
    //
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var messageHash interface{} = ccxt.Add(accountType, ":balance")
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(this.Balance, accountType), nil)) {
        ccxt.AddElementToObject(this.Balance, accountType, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "info", message)
    message = this.SafeDict(message, "a", message)
    var B interface{} = this.SafeList(message, "B", []interface{}{})
    var wallet interface{} = this.SafeString(this.Options, "wallet", "wb")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(B)); i++ {
        var entry interface{} = ccxt.GetValue(B, i)
        var currencyId interface{} = this.SafeString(entry, "a")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(entry, "f"))
        ccxt.AddElementToObject(account, "used", this.SafeString(entry, "l"))
        ccxt.AddElementToObject(account, "total", this.SafeString(entry, wallet))
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
    }
    var timestamp interface{} = this.SafeInteger(message, "E")
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Balance, accountType, this.SafeBalance(ccxt.GetValue(this.Balance, accountType)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, accountType), messageHash)
}
/**
 * @method
 * @name aster#watchPositions
 * @description watch all open positions
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-balance-and-position-update
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {number} [since] since timestamp
 * @param {number} [limit] limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *AsterCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14228)
            var typeVar interface{} = "swap"
        
            retRes14248 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes14248)
            var url interface{} = this.GetPrivateUrl(typeVar)
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client)
            var messageHashes interface{} = []interface{}{}
            var messageHash interface{} = "positions"
            symbols = this.MarketSymbols(symbols, "swap", true, true)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&messageHashes, messageHash)
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
                }
            }
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            var cache interface{} = this.Positions
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(cache, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
        
            newPositions:= (<-this.WatchMultiple(url, messageHashes, nil, []interface{}{typeVar}))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) SetPositionsCache(client interface{})  {
    if ccxt.IsTrue(!ccxt.IsEqual(this.Positions, nil)) {
        return
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    } else {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
}
func  (this *AsterCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions())
            ccxt.PanicOnError(positions)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "positions")
            }
                return nil
            }()
            return ch
        }
func  (this *AsterCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "ACCOUNT_UPDATE",
    //         "T": 1768551627708,
    //         "E": 1768551627710,
    //         "a": {
    //             "B": [
    //                 {
    //                     "a": "USDT",
    //                     "wb": "39.41184271",
    //                     "cw": "39.41184271",
    //                     "bc": "0"
    //                 }
    //             ],
    //             "P": [
    //                 {
    //                     "s": "ETHUSDT",
    //                     "pa": "0",
    //                     "ep": "0.00000000",
    //                     "cr": "-0.59070000",
    //                     "up": "0",
    //                     "mt": "isolated",
    //                     "iw": "0",
    //                     "ps": "BOTH",
    //                     "ma": "USDT"
    //                 }
    //             ],
    //             "m": "ORDER"
    //         }
    //     }
    //
    var messageHash interface{} = "positions"
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), messageHash)
    if !ccxt.IsTrue(this.IsEmpty(messageHashes)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
        }
        var cache interface{} = this.Positions
        var data interface{} = this.SafeDict(message, "a", map[string]interface{} {})
        var rawPositions interface{} = this.SafeList(data, "P", []interface{}{})
        var newPositions interface{} = []interface{}{}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
            var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
            var position interface{} = this.ParseWsPosition(rawPosition)
            var timestamp interface{} = this.SafeInteger(message, "E")
            ccxt.AddElementToObject(position, "timestamp", timestamp)
            ccxt.AddElementToObject(position, "datetime", this.Iso8601(timestamp))
            ccxt.AppendToArray(&newPositions, position)
            cache.(ccxt.Appender).Append(position)
            var symbol interface{} = ccxt.GetValue(position, "symbol")
            var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
            client.(ccxt.ClientInterface).Resolve(position, symbolMessageHash)
        }
        client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
    }
}
func  (this *AsterCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "s": "BTCUSDT", // Symbol
    //         "pa": "0", // ccxt.Position Amount
    //         "ep": "0.00000", // Entry Price
    //         "cr": "200", // (Pre-fee) Accumulated Realized
    //         "up": "0", // Unrealized PnL
    //         "mt": "isolated", // Margin Type
    //         "iw": "0.00000000", // Isolated Wallet (if isolated position)
    //         "ps": "BOTH" // ccxt.Position Side
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "s")
    var contracts interface{} = this.SafeString(position, "pa")
    var contractsAbs interface{} = ccxt.Precise.StringAbs(this.SafeString(position, "pa"))
    var positionSide interface{} = this.SafeStringLower(position, "ps")
    var hedged interface{} = true
    if ccxt.IsTrue(ccxt.IsEqual(positionSide, "both")) {
        hedged = false
        if !ccxt.IsTrue(ccxt.Precise.StringEq(contracts, "0")) {
            if ccxt.IsTrue(ccxt.Precise.StringLt(contracts, "0")) {
                positionSide = "short"
            } else {
                positionSide = "long"
            }
        }
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeSymbol(marketId, nil, nil, "swap"),
        "notional": nil,
        "marginMode": this.SafeString(position, "mt"),
        "liquidationPrice": nil,
        "entryPrice": this.SafeNumber(position, "ep"),
        "unrealizedPnl": this.SafeNumber(position, "up"),
        "percentage": nil,
        "contracts": this.ParseNumber(contractsAbs),
        "contractSize": nil,
        "markPrice": nil,
        "side": positionSide,
        "hedged": hedged,
        "timestamp": nil,
        "datetime": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
    })
}
/**
 * @method
 * @name aster#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-order-update
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-order-update
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', default is 'spot' if symbol is not provided
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *AsterCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16158)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var messageHash interface{} = "orders"
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params, typeVar)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes16248 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes16248)
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", symbol))
            }
            var url interface{} = this.GetPrivateUrl(typeVar)
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar)
        
            orders:= (<-this.WatchMultiple(url, []interface{}{messageHash}, nil, []interface{}{typeVar}))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name aster#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-order-update
 * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-order-update
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', default is 'spot' if symbol is not provided
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *AsterCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16528)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var messageHash interface{} = "myTrades"
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params, typeVar)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes16618 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes16618)
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", symbol))
            }
            var url interface{} = this.GetPrivateUrl(typeVar)
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar)
        
            trades:= (<-this.WatchMultiple(url, []interface{}{messageHash}, nil, []interface{}{typeVar}))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *AsterCore) HandleOrderUpdate(client interface{}, message interface{})  {
    var rawOrder interface{} = this.SafeDict(message, "o", message)
    var e interface{} = this.SafeString(message, "e")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(e, "ORDER_TRADE_UPDATE"))) || ccxt.IsTrue((ccxt.IsEqual(e, "ALGO_UPDATE")))) {
        message = this.SafeDict(message, "o", message)
    }
    this.HandleOrder(client, rawOrder)
    this.HandleMyTrade(client, message)
}
func  (this *AsterCore) HandleMyTrade(client interface{}, message interface{})  {
    var messageHash interface{} = "myTrades"
    var executionType interface{} = this.SafeString(message, "x")
    if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        var isSwap interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "fstream"), 0)
        var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSwap), "swap", "spot")
        var fakeMarket interface{} = this.SafeMarketStructure(map[string]interface{} {
            "type": typeVar,
        })
        var trade interface{} = this.ParseWsTrade(message, fakeMarket)
        var orderId interface{} = this.SafeString(trade, "order")
        var tradeFee interface{} = this.SafeDict(trade, "fee", map[string]interface{} {})
        tradeFee = this.Extend(map[string]interface{} {}, tradeFee)
        var symbol interface{} = this.SafeString(trade, "symbol")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(orderId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(tradeFee, nil))) && ccxt.IsTrue(!ccxt.IsEqual(symbol, nil))) {
            var cachedOrders interface{} = this.Orders
            if ccxt.IsTrue(!ccxt.IsEqual(cachedOrders, nil)) {
                var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
                var order interface{} = this.SafeValue(orders, orderId)
                if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
                    // accumulate order fees
                    var fees interface{} = this.SafeValue(order, "fees")
                    var fee interface{} = this.SafeValue(order, "fee")
                    if !ccxt.IsTrue(this.IsEmpty(fees)) {
                        var insertNewFeeCurrency interface{} = true
                        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(fees)); i++ {
                            var orderFee interface{} = ccxt.GetValue(fees, i)
                            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderFee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                                var feeCost interface{} = this.Sum(ccxt.GetValue(tradeFee, "cost"), ccxt.GetValue(orderFee, "cost"))
                                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(order, "fees"), i), "cost", ccxt.ParseFloat(this.CurrencyToPrecision(ccxt.GetValue(tradeFee, "currency"), feeCost)))
                                insertNewFeeCurrency = false
                                break
                            }
                        }
                        if ccxt.IsTrue(insertNewFeeCurrency) {
                            retRes171832 := ccxt.GetValue(order, "fees")
                            ccxt.AppendToArray(&retRes171832, tradeFee)
                        }
                    } else if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                            var feeCost interface{} = this.Sum(ccxt.GetValue(fee, "cost"), ccxt.GetValue(tradeFee, "cost"))
                            ccxt.AddElementToObject(ccxt.GetValue(order, "fee"), "cost", ccxt.ParseFloat(this.CurrencyToPrecision(ccxt.GetValue(tradeFee, "currency"), feeCost)))
                        } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), nil)) {
                            ccxt.AddElementToObject(order, "fee", tradeFee)
                        } else {
                            ccxt.AddElementToObject(order, "fees", []interface{}{fee, tradeFee})
                            ccxt.AddElementToObject(order, "fee", nil)
                        }
                    } else {
                        ccxt.AddElementToObject(order, "fee", tradeFee)
                    }
                    // save this trade in the order
                    var orderTrades interface{} = this.SafeList(order, "trades", []interface{}{})
                    ccxt.AppendToArray(&orderTrades, trade)
                    ccxt.AddElementToObject(order, "trades", orderTrades)
                }
            }
        }
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var myTrades interface{} = this.MyTrades
        myTrades.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
        var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHashSymbol)
    }
}
func  (this *AsterCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot
    //     {
    //         "e": "executionReport",        // Event type
    //         "E": 1499405658658,            // Event time
    //         "s": "ETHBTC",                 // Symbol
    //         "c": "mUvoqJxFIILMdfAW5iGSOW", // ccxt.Client order ID
    //         "S": "BUY",                    // Side
    //         "o": "LIMIT",                  // ccxt.Order type
    //         "f": "GTC",                    // Time in force
    //         "q": "1.00000000",             // ccxt.Order quantity
    //         "p": "0.10264410",             // ccxt.Order price
    //         "P": "0.00000000",             // Stop price
    //         "F": "0.00000000",             // Iceberg quantity
    //         "g": -1,                       // OrderListId
    //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
    //         "x": "NEW",                    // Current execution type
    //         "X": "NEW",                    // Current order status
    //         "r": "NONE",                   // ccxt.Order reject reason; will be an error code.
    //         "i": 4293153,                  // ccxt.Order ID
    //         "l": "0.00000000",             // Last executed quantity
    //         "z": "0.00000000",             // Cumulative filled quantity
    //         "L": "0.00000000",             // Last executed price
    //         "n": "0",                      // Commission amount
    //         "N": null,                     // Commission asset
    //         "T": 1499405658657,            // ccxt.Transaction time
    //         "t": -1,                       // ccxt.Trade ID
    //         "I": 8641984,                  // Ignore
    //         "w": true,                     // Is the order on the book?
    //         "m": false,                    // Is this trade the maker side?
    //         "M": false,                    // Ignore
    //         "O": 1499405658657,            // ccxt.Order creation time
    //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
    //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
    //         "Q": "0.00000000"              // Quote ccxt.Order Qty
    //     }
    //
    // swap
    //     {
    //         "s":"BTCUSDT",                 // Symbol
    //         "c":"TEST",                    // ccxt.Client ccxt.Order Id
    //                                        // special client order id:
    //                                        // starts with "autoclose-": liquidation order
    //                                        // "adl_autoclose": ADL auto close order
    //         "S":"SELL",                    // Side
    //         "o":"TRAILING_STOP_MARKET",    // ccxt.Order Type
    //         "f":"GTC",                     // Time in Force
    //         "q":"0.001",                   // Original Quantity
    //         "p":"0",                       // Original Price
    //         "ap":"0",                      // Average Price
    //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //         "x":"NEW",                     // Execution Type
    //         "X":"NEW",                     // ccxt.Order Status
    //         "i":8886774,                   // ccxt.Order Id
    //         "l":"0",                       // ccxt.Order Last Filled Quantity
    //         "z":"0",                       // ccxt.Order Filled Accumulated Quantity
    //         "L":"0",                       // Last Filled Price
    //         "N":"USDT",                    // Commission Asset, will not push if no commission
    //         "n":"0",                       // Commission, will not push if no commission
    //         "T":1568879465651,             // ccxt.Order ccxt.Trade Time
    //         "t":0,                         // ccxt.Trade Id
    //         "b":"0",                       // ccxt.Bids Notional
    //         "a":"9.91",                    // Ask Notional
    //         "m":false,                     // Is this trade the maker side?
    //         "R":false,                     // Is this reduce only
    //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
    //         "ot":"TRAILING_STOP_MARKET",   // Original ccxt.Order Type
    //         "ps":"LONG",                   // ccxt.Position Side
    //         "cp":false,                    // If Close-All, pushed with conditional order
    //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //         "rp":"0"                       // Realized Profit of the trade
    //     }
    //
    var messageHash interface{} = "orders"
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), messageHash)
    if !ccxt.IsTrue(this.IsEmpty(messageHashes)) {
        var market interface{} = this.GetMarketFromOrder(client, message)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cache interface{} = this.Orders
        var parsed interface{} = this.ParseWsOrder(message, market)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
        cache.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(cache, symbolMessageHash)
        client.(ccxt.ClientInterface).Resolve(cache, messageHash)
    }
}
func  (this *AsterCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var executionType interface{} = this.SafeString(order, "x")
    var marketId interface{} = this.SafeString(order, "s")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(order, "O")
    var T interface{} = this.SafeInteger(order, "T")
    var lastTradeTimestamp interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(executionType, "NEW")) || ccxt.IsTrue(ccxt.IsEqual(executionType, "AMENDMENT"))) || ccxt.IsTrue(ccxt.IsEqual(executionType, "CANCELED"))) {
        if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
            timestamp = T
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        lastTradeTimestamp = T
    }
    var lastUpdateTimestamp interface{} = T
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "n")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(feeCost, nil))) && ccxt.IsTrue((ccxt.Precise.StringGt(feeCost, "0")))) {
        var feeCurrencyId interface{} = this.SafeString(order, "N")
        var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    var rawStatus interface{} = this.SafeString(order, "X")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    var clientOrderId interface{} = this.SafeString2(order, "C", "caid")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(clientOrderId, nil))) || ccxt.IsTrue((ccxt.IsEqual(ccxt.GetLength(clientOrderId), 0)))) {
        clientOrderId = this.SafeString(order, "c")
    }
    var stopPrice interface{} = this.SafeStringN(order, []interface{}{"P", "sp", "tp"})
    var timeInForce interface{} = this.SafeString(order, "f")
    if ccxt.IsTrue(ccxt.IsEqual(timeInForce, "GTX")) {
        // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
        timeInForce = "PO"
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": this.SafeString2(order, "i", "aid"),
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "type": this.ParseOrderType(this.SafeStringLower(order, "o")),
        "timeInForce": timeInForce,
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "R"),
        "side": this.SafeStringLower(order, "S"),
        "price": this.SafeString(order, "p"),
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": this.SafeString(order, "q"),
        "cost": this.SafeString(order, "Z"),
        "average": this.SafeString(order, "ap"),
        "filled": this.SafeString(order, "z"),
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": nil,
    })
}
func  (this *AsterCore) GetMarketFromOrder(client interface{}, order interface{}) interface{}  {
    var marketId interface{} = this.SafeString(order, "s")
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var marketType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    return this.SafeMarket(marketId, nil, nil, marketType)
}
func  (this *AsterCore) HandleMessage(client interface{}, message interface{})  {
    var stream interface{} = this.SafeString(message, "stream")
    if ccxt.IsTrue(!ccxt.IsEqual(stream, nil)) {
        var part interface{} = ccxt.Split(stream, "@")
        var topic interface{} = this.SafeString(part, 1, "")
        var part2 interface{} = ccxt.Split(topic, "_")
        topic = this.SafeString(part2, 0, "")
        var methods interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "aggTrade": this.HandleTrade,
            "depth5": this.HandleOrderBook,
            "depth10": this.HandleOrderBook,
            "depth20": this.HandleOrderBook,
            "kline": this.HandleOHLCV,
            "markPrice": this.HandleTicker,
            "bookTicker": this.HandleBidAsk,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    } else {
        // private messages
        var event interface{} = this.SafeString(message, "e")
        if ccxt.IsTrue(ccxt.IsEqual(event, "outboundAccountPosition")) {
            this.HandleBalance(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "ACCOUNT_UPDATE")) {
            this.HandleBalance(client, message)
            this.HandlePositions(client, message)
        } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(event, "ORDER_TRADE_UPDATE"))) || ccxt.IsTrue((ccxt.IsEqual(event, "executionReport")))) {
            this.HandleOrderUpdate(client, message)
        }
    }
}


func (this *AsterCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
