package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CexCore struct {
	*ccxt.CexCore
	base *ccxt.CexCore
}

func NewCexCore() *CexCore {
    p := &CexCore{}
	base := &ccxt.CexCore{}
	p.base = base
	p.CexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
            "watchPosition": nil,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "fetchOrderWs": true,
            "fetchOpenOrdersWs": true,
            "fetchTickerWs": true,
            "fetchBalanceWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.cex.io/ws",
            },
        },
        "options": map[string]interface{} {
            "orderbook": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *CexCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return ccxt.ToString(requestId)
}
/**
 * @method
 * @name cex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://cex.io/websocket-api#get-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *CexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes668 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes668)
            var messageHash interface{} = this.RequestId()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "e": "get-balance",
                "data": map[string]interface{} {},
                "oid": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes7515 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes7515)
                ch <- retRes7515
                return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "get-balance",
    //         "data": {
    //             "balance": {
    //                 "BTC": "0.00000000",
    //                 "USD": "0.00",
    //                 ...
    //             },
    //             "obalance": {
    //                 "BTC": "0.00000000",
    //                 "USD": "0.00",
    //                 ...
    //             },
    //             "time": 1663761159605
    //         },
    //         "oid": 1,
    //         "ok": "ok"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var freeBalance interface{} = this.SafeValue(data, "balance", map[string]interface{} {})
    var usedBalance interface{} = this.SafeValue(data, "obalance", map[string]interface{} {})
    var result interface{} = map[string]interface{} {
        "info": data,
    }
    var currencyIds interface{} = ccxt.ObjectKeys(freeBalance)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = ccxt.GetValue(currencyIds, i)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(freeBalance, currencyId))
        ccxt.AddElementToObject(account, "used", this.SafeString(usedBalance, currencyId))
        var code interface{} = this.SafeCurrencyCode(currencyId)
        ccxt.AddElementToObject(result, code, account)
    }
    this.Balance = this.SafeBalance(result)
    var messageHash interface{} = this.SafeString(message, "oid")
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name cex#watchTrades
 * @description get the list of most recent trades for a particular symbol. Note: can only watch one symbol at a time.
 * @see https://cex.io/websocket-api#old-pair-room
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1318)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "trades"
            var subscriptionHash interface{} = ccxt.Add("old:", symbol)
            ccxt.AddElementToObject(this.Options, "currentWatchTradeSymbol", symbol) // exchange supports only 1 symbol for this watchTrades channel
            var client interface{} = this.SafeValue(this.Clients, url)
            if ccxt.IsTrue(!ccxt.IsEqual(client, nil)) {
                var subscriptionKeys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionKeys)); i++ {
                    var subscriptionKey interface{} = ccxt.GetValue(subscriptionKeys, i)
                    if ccxt.IsTrue(ccxt.IsEqual(subscriptionKey, subscriptionHash)) {
                        continue
                    }
                    subscriptionKey = ccxt.Slice(subscriptionKey, 0, 3)
                    if ccxt.IsTrue(ccxt.IsEqual(subscriptionKey, "old")) {
                        panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchTrades() only supports watching one symbol at a time.")))
                    }
                }
            }
            var message interface{} = map[string]interface{} {
                "e": "subscribe",
                "rooms": []interface{}{ccxt.Add(ccxt.Add(ccxt.Add("pair-", ccxt.GetValue(market, "base")), "-"), ccxt.GetValue(market, "quote"))},
            }
            var request interface{} = this.DeepExtend(message, params)
        
            trades:= (<-this.Watch(url, messageHash, request, subscriptionHash))
            ccxt.PanicOnError(trades)
            // assing symbol to the trades as message does not contain symbol information
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
                ccxt.AddElementToObject(ccxt.GetValue(trades, i), "symbol", symbol)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleTradesSnapshot(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "history",
    //         "data": [
    //            'buy:1710255706095:444444:71222.2:14892622'
    //            'sell:1710255658251:42530:71300:14892621'
    //            'buy:1710252424241:87913:72800:14892620'
    //            ... timestamp descending
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    var stored interface{} = ccxt.NewArrayCache(limit)
    var symbol interface{} = this.SafeString(this.Options, "currentWatchTradeSymbol")
    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
        return
    }
    var market interface{} = this.Market(symbol)
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    for i := 0; ccxt.IsLessThan(i, dataLength); i++ {
        var index interface{} = ccxt.Subtract(ccxt.Subtract(dataLength, 1), i)
        var rawTrade interface{} = ccxt.GetValue(data, index)
        var parsed interface{} = this.ParseWsOldTrade(rawTrade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = "trades"
    this.Trades = stored // trades don't have symbol
    client.(ccxt.ClientInterface).Resolve(this.Trades, messageHash)
}
func  (this *CexCore) ParseWsOldTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  snapshot trade
    //    "sell:1665467367741:3888551:19058.8:14541219"
    //  update trade
    //    ['buy', '1665467516704', '98070', "19057.7", "14541220"]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    if !ccxt.IsTrue(ccxt.IsArray(trade)) {
        trade = ccxt.Split(trade, ":")
    }
    var side interface{} = this.SafeString(trade, 0)
    var timestamp interface{} = this.SafeInteger(trade, 1)
    var amount interface{} = this.SafeString(trade, 2)
    var price interface{} = this.SafeString(trade, 3)
    var id interface{} = this.SafeString(trade, 4)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "type": nil,
        "side": side,
        "order": nil,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *CexCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "history-update",
    //         "data": [
    //             ['buy', '1665467516704', '98070', "19057.7", "14541220"]
    //         ]
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var stored interface{} = this.Trades // to do fix this, this.trades is not meant to be used like this
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    for i := 0; ccxt.IsLessThan(i, dataLength); i++ {
        var index interface{} = ccxt.Subtract(ccxt.Subtract(dataLength, 1), i)
        var rawTrade interface{} = ccxt.GetValue(data, index)
        var parsed interface{} = this.ParseWsOldTrade(rawTrade)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = "trades"
    this.Trades = stored
    client.(ccxt.ClientInterface).Resolve(this.Trades, messageHash)
}
/**
 * @method
 * @name cex#watchTicker
 * @see https://cex.io/websocket-api#ticker-subscription
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] public or private
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2638)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var method interface{} = this.SafeString(params, "method", "private") // default to private because the specified ticker is received quicker
            var message interface{} = map[string]interface{} {
                "e": "subscribe",
                "rooms": []interface{}{"tickers"},
            }
            var subscriptionHash interface{} = "tickers"
            if ccxt.IsTrue(ccxt.IsEqual(method, "private")) {
        
                retRes27712 := (<-this.Authenticate())
                ccxt.PanicOnError(retRes27712)
                message = map[string]interface{} {
                    "e": "ticker",
                    "data": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                    "oid": this.RequestId(),
                }
                subscriptionHash = ccxt.Add("ticker:", symbol)
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes28815 :=  (<-this.Watch(url, messageHash, request, subscriptionHash))
                ccxt.PanicOnError(retRes28815)
                ch <- retRes28815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#watchTickers
 * @see https://cex.io/websocket-api#ticker-subscription
 * @description watches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3018)
            symbols = this.MarketSymbols(symbols)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "tickers"
            var message interface{} = map[string]interface{} {
                "e": "subscribe",
                "rooms": []interface{}{"tickers"},
            }
            var request interface{} = this.DeepExtend(message, params)
        
            ticker:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ticker)
            var tickerSymbol interface{} = ccxt.GetValue(ticker, "symbol")
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) && !ccxt.IsTrue(this.InArray(tickerSymbol, symbols))) {
        
                    retRes31519 :=  (<-this.WatchTickers(symbols, params))
                    ccxt.PanicOnError(retRes31519)
                    ch <- retRes31519
                    return nil
            }
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, tickerSymbol, ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#fetchTickerWs
 * @see https://docs.cex.io/#ws-api-ticker-deprecated
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CexCore) FetchTickerWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3358)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = this.RequestId()
            var request interface{} = this.Extend(map[string]interface{} {
                "e": "ticker",
                "oid": messageHash,
                "data": []interface{}{ccxt.GetValue(market, "base"), ccxt.GetValue(market, "quote")},
            }, params)
        
                retRes34415 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes34415)
                ch <- retRes34415
                return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "tick",
    //         "data": {
    //             "symbol1": "LRC",
    //             "symbol2": "USD",
    //             "price": "0.305",
    //             "open24": "0.301",
    //             "volume": "241421.641700"
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var ticker interface{} = this.ParseWsTicker(data)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
        return
    }
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    client.(ccxt.ClientInterface).Resolve(ticker, "tickers")
    messageHash = this.SafeString(message, "oid")
    if ccxt.IsTrue(!ccxt.IsEqual(messageHash, nil)) {
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *CexCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  public
    //    {
    //        "symbol1": "LRC",
    //        "symbol2": "USD",
    //        "price": "0.305",
    //        "open24": "0.301",
    //        "volume": "241421.641700"
    //    }
    //  private
    //    {
    //        "timestamp": "1663764969",
    //        "low": "18756.3",
    //        "high": "19200",
    //        "last": "19200",
    //        "volume": "0.94735907",
    //        "volume30d": "64.61299999",
    //        "bid": 19217.2,
    //        "ask": 19247.5,
    //        "priceChange": "44.3",
    //        "priceChangePercentage": "0.23",
    //        "pair": ["BTC", "USDT"]
    //    }
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var pair interface{} = this.SafeValue(ticker, "pair", []interface{}{})
    var baseId interface{} = this.SafeString(ticker, "symbol1")
    if ccxt.IsTrue(ccxt.IsEqual(baseId, nil)) {
        baseId = this.SafeString(pair, 0)
    }
    var quoteId interface{} = this.SafeString(ticker, "symbol2")
    if ccxt.IsTrue(ccxt.IsEqual(quoteId, nil)) {
        quoteId = this.SafeString(pair, 1)
    }
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    if ccxt.IsTrue(!ccxt.IsEqual(timestamp, nil)) {
        timestamp = ccxt.Multiply(timestamp, 1000)
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open24"),
        "close": nil,
        "last": this.SafeString2(ticker, "price", "last"),
        "previousClose": nil,
        "change": this.SafeString(ticker, "priceChange"),
        "percentage": this.SafeString(ticker, "priceChangePercentage"),
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeString(ticker, "volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name cex#fetchBalanceWs
 * @see https://docs.cex.io/#ws-api-get-balance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *CexCore) FetchBalanceWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4498)
        
            retRes4508 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4508)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = this.RequestId()
            var request interface{} = this.Extend(map[string]interface{} {
                "e": "get-balance",
                "oid": messageHash,
            }, params)
        
                retRes45715 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes45715)
                ch <- retRes45715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#watchOrders
 * @description get the list of orders associated with the user. Note: In CEX.IO system, orders can be present in trade engine or in archive database. There can be time periods (~2 seconds or more), when order is done/canceled, but still not moved to archive database. That means, you cannot see it using calls: archived-orders/open-orders.
 * @see https://docs.cex.io/#ws-api-open-orders
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrders() requires a symbol argument")))
            }
        
            retRes4758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4758)
        
            retRes4768 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes4768)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orders:", symbol)
            var message interface{} = map[string]interface{} {
                "e": "open-orders",
                "data": map[string]interface{} {
                    "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                },
                "oid": symbol,
            }
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#watchMyTrades
 * @description get the list of trades associated with the user. Note: In CEX.IO system, orders can be present in trade engine or in archive database. There can be time periods (~2 seconds or more), when order is done/canceled, but still not moved to archive database. That means, you cannot see it using calls: archived-orders/open-orders.
 * @see https://docs.cex.io/#ws-api-open-orders
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchMyTrades() requires a symbol argument")))
            }
        
            retRes5148 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5148)
        
            retRes5158 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes5158)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(market, "symbol"))
            var subscriptionHash interface{} = ccxt.Add("orders:", ccxt.GetValue(market, "symbol"))
            var message interface{} = map[string]interface{} {
                "e": "open-orders",
                "data": map[string]interface{} {
                    "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                },
                "oid": ccxt.GetValue(market, "symbol"),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, subscriptionHash, request))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, ccxt.GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleTransaction(client interface{}, message interface{})  {
    var data interface{} = this.SafeValue(message, "data")
    var symbol2 interface{} = this.SafeString(data, "symbol2")
    if ccxt.IsTrue(ccxt.IsEqual(symbol2, nil)) {
        return
    }
    this.HandleOrderUpdate(client, message)
    this.HandleMyTrades(client, message)
}
func  (this *CexCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "tx",
    //         "data": {
    //             "d": "order:59091012956:a:USD",
    //             "c": "user:up105393824:a:USD",
    //             "a": "0.01",
    //             "ds": 0,
    //             "cs": "15.27",
    //             "user": "up105393824",
    //             "symbol": "USD",
    //             "order": 59091012956,
    //             "amount": "-18.49",
    //             "type": "buy",
    //             "time": "2022-09-24T19:36:18.466Z",
    //             "balance": "15.27",
    //             "id": "59091012966"
    //         }
    //     }
    //     {
    //         "e": "tx",
    //         "data": {
    //             "d": "order:59091012956:a:BTC",
    //             "c": "user:up105393824:a:BTC",
    //             "a": "0.00096420",
    //             "ds": 0,
    //             "cs": "0.00096420",
    //             "user": "up105393824",
    //             "symbol": "BTC",
    //             "symbol2": "USD",
    //             "amount": "0.00096420",
    //             "buy": 59091012956,
    //             "order": 59091012956,
    //             "sell": 59090796005,
    //             "price": 19135,
    //             "type": "buy",
    //             "time": "2022-09-24T19:36:18.466Z",
    //             "balance": "0.00096420",
    //             "fee_amount": "0.05",
    //             "id": "59091012962"
    //         }
    //     }
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var stored interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = stored
    }
    var trade interface{} = this.ParseWsTrade(data)
    stored.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(trade, "symbol"))
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CexCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "d": "order:59091012956:a:BTC",
    //         "c": "user:up105393824:a:BTC",
    //         "a": "0.00096420",
    //         "ds": 0,
    //         "cs": "0.00096420",
    //         "user": "up105393824",
    //         "symbol": "BTC",
    //         "symbol2": "USD",
    //         "amount": "0.00096420",
    //         "buy": 59091012956,
    //         "order": 59091012956,
    //         "sell": 59090796005,
    //         "price": 19135,
    //         "type": "buy",
    //         "time": "2022-09-24T19:36:18.466Z",
    //         "balance": "0.00096420",
    //         "fee_amount": "0.05",
    //         "id": "59091012962"
    //     }
    // Note symbol and symbol2 are inverse on sell and ammount is in symbol currency.
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeString(trade, "type")
    var price interface{} = this.SafeString(trade, "price")
    var datetime interface{} = this.SafeString(trade, "time")
    var baseId interface{} = this.SafeString(trade, "symbol")
    var quoteId interface{} = this.SafeString(trade, "symbol2")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var amount interface{} = this.SafeString(trade, "amount")
    if ccxt.IsTrue(ccxt.IsEqual(side, "sell")) {
        symbol = ccxt.Add(ccxt.Add(quote, "/"), base)
        amount = ccxt.Precise.StringDiv(amount, price) // due to rounding errors amount in not exact to trade
    }
    var parsedTrade interface{} = map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "order": this.SafeString(trade, "order"),
        "info": trade,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "cost": nil,
        "amount": amount,
        "fee": nil,
    }
    var fee interface{} = this.SafeString(trade, "fee_amount")
    if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
        ccxt.AddElementToObject(parsedTrade, "fee", map[string]interface{} {
    "cost": fee,
    "currency": quote,
    "rate": nil,
})
    }
    return this.SafeTrade(parsedTrade, market)
}
func  (this *CexCore) HandleOrderUpdate(client interface{}, message interface{})  {
    //
    //  partialExecution
    //     {
    //         "e": "order",
    //         "data": {
    //             "id": "150714937",
    //             "remains": "1000000",
    //             "price": "17513",
    //             "amount": 2000000, As ccxt.Precision
    //             "time": "1654506118448",
    //             "type": "buy",
    //             "pair": {
    //                 "symbol1": "BTC",
    //                 "symbol2": "USD"
    //             },
    //             "fee": "0.15"
    //         }
    //     }
    //  canceled order
    //     {
    //         "e": "order",
    //         "data": {
    //             "id": "6310857",
    //             "remains": "200000000"
    //             "fremains": "2.00000000"
    //             "cancel": true,
    //             "pair": {
    //                 "symbol1": "BTC",
    //                 "symbol2": "USD"
    //             }
    //         }
    //     }
    //  fulfilledOrder
    //     {
    //         "e": "order",
    //         "data": {
    //             "id": "59098421630",
    //             "remains": "0",
    //             "pair": {
    //                 "symbol1": "BTC",
    //                 "symbol2": "USD"
    //             }
    //         }
    //     }
    //     {
    //         "e": "tx",
    //         "data": {
    //             "d": "order:59425993014:a:BTC",
    //             "c": "user:up105393824:a:BTC",
    //             "a": "0.00098152",
    //             "ds": 0,
    //             "cs": "0.00098152",
    //             "user": "up105393824",
    //             "symbol": "BTC",
    //             "symbol2": "USD",
    //             "amount": "0.00098152",
    //             "buy": 59425993014,
    //             "order": 59425993014,
    //             "sell": 59425986168,
    //             "price": 19306.6,
    //             "type": "buy",
    //             "time": "2022-10-02T01:11:15.148Z",
    //             "balance": "0.00098152",
    //             "fee_amount": "0.05",
    //             "id": "59425993020"
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var isTransaction interface{} = ccxt.IsEqual(this.SafeString(message, "e"), "tx")
    var orderId interface{} = this.SafeString2(data, "id", "order")
    var remains interface{} = this.SafeString(data, "remains")
    var baseId interface{} = this.SafeString(data, "symbol")
    var quoteId interface{} = this.SafeString(data, "symbol2")
    var pair interface{} = this.SafeValue(data, "pair")
    if ccxt.IsTrue(!ccxt.IsEqual(pair, nil)) {
        baseId = this.SafeString(pair, "symbol1")
        quoteId = this.SafeString(pair, "symbol2")
    }
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var market interface{} = this.SafeMarket(symbol)
    remains = this.CurrencyFromPrecision(base, remains)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var storedOrders interface{} = this.Orders
    var ordersBySymbol interface{} = this.SafeValue(storedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
    var order interface{} = this.SafeValue(ordersBySymbol, orderId)
    if ccxt.IsTrue(ccxt.IsEqual(order, nil)) {
        order = this.ParseWsOrderUpdate(data, market)
    }
    ccxt.AddElementToObject(order, "remaining", remains)
    var canceled interface{} = this.SafeBool(data, "cancel", false)
    if ccxt.IsTrue(canceled) {
        ccxt.AddElementToObject(order, "status", "canceled")
    }
    if ccxt.IsTrue(isTransaction) {
        ccxt.AddElementToObject(order, "status", "closed")
    }
    var fee interface{} = this.SafeNumber(data, "fee")
    if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
        ccxt.AddElementToObject(order, "fee", map[string]interface{} {
    "cost": fee,
    "currency": quote,
    "rate": nil,
})
    }
    var timestamp interface{} = this.SafeInteger(data, "time")
    ccxt.AddElementToObject(order, "timestamp", timestamp)
    ccxt.AddElementToObject(order, "datetime", this.Iso8601(timestamp))
    order = this.SafeOrder(order)
    storedOrders.(ccxt.Appender).Append(order)
    var messageHash interface{} = ccxt.Add("orders:", symbol)
    client.(ccxt.ClientInterface).Resolve(storedOrders, messageHash)
}
func  (this *CexCore) ParseWsOrderUpdate(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //      {
    //          "id": "150714937",
    //          "remains": "1000000",
    //          "price": "17513",
    //          "amount": 2000000, As ccxt.Precision
    //          "time": "1654506118448",
    //          "type": "buy",
    //          "pair": {
    //              "symbol1": "BTC",
    //              "symbol2": "USD"
    //          },
    //          "fee": "0.15"
    //      }
    //  transaction
    //      {
    //           "d": "order:59425993014:a:BTC",
    //           "c": "user:up105393824:a:BTC",
    //           "a": "0.00098152",
    //           "ds": 0,
    //           "cs": "0.00098152",
    //           "user": "up105393824",
    //           "symbol": "BTC",
    //           "symbol2": "USD",
    //           "amount": "0.00098152",
    //           "buy": 59425993014,
    //           "order": 59425993014,
    //           "sell": 59425986168,
    //           "price": 19306.6,
    //           "type": "buy",
    //           "time": "2022-10-02T01:11:15.148Z",
    //           "balance": "0.00098152",
    //           "fee_amount": "0.05",
    //           "id": "59425993020"
    //       }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var isTransaction interface{} = !ccxt.IsEqual(this.SafeValue(order, "d"), nil)
    var remainsPrecision interface{} = this.SafeString(order, "remains")
    var remaining interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(remainsPrecision, nil)) {
        remaining = this.CurrencyFromPrecision(ccxt.GetValue(market, "base"), remainsPrecision)
    }
    var amount interface{} = this.SafeString(order, "amount")
    if !ccxt.IsTrue(isTransaction) {
        this.CurrencyFromPrecision(ccxt.GetValue(market, "base"), amount)
    }
    var baseId interface{} = this.SafeString(order, "symbol")
    var quoteId interface{} = this.SafeString(order, "symbol2")
    var pair interface{} = this.SafeValue(order, "pair")
    if ccxt.IsTrue(!ccxt.IsEqual(pair, nil)) {
        baseId = this.SafeString(order, "symbol1")
        quoteId = this.SafeString(order, "symbol2")
    }
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(base, nil)) && ccxt.IsTrue(!ccxt.IsEqual(quote, nil))) {
        symbol = ccxt.Add(ccxt.Add(base, "/"), quote)
    }
    market = this.SafeMarket(symbol, market)
    var time interface{} = this.SafeInteger(order, "time", this.Milliseconds())
    var timestamp interface{} = time
    if ccxt.IsTrue(isTransaction) {
        timestamp = this.Parse8601(time)
    }
    var canceled interface{} = this.SafeBool(order, "cancel", false)
    var status interface{} = "open"
    if ccxt.IsTrue(canceled) {
        status = "canceled"
    } else if ccxt.IsTrue(isTransaction) {
        status = "closed"
    }
    var parsedOrder interface{} = map[string]interface{} {
        "id": this.SafeString2(order, "id", "order"),
        "clientOrderId": nil,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": nil,
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString(order, "type"),
        "price": this.SafeNumber(order, "price"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "average": nil,
        "cost": nil,
        "amount": amount,
        "filled": nil,
        "remaining": remaining,
        "fee": map[string]interface{} {
            "cost": this.SafeNumber2(order, "fee", "fee_amount"),
            "currency": quote,
            "rate": nil,
        },
        "trades": nil,
    }
    if ccxt.IsTrue(isTransaction) {
        ccxt.AddElementToObject(parsedOrder, "trades", this.ParseWsTrade(order, market))
    }
    return this.SafeOrder(parsedOrder, market)
}
func  (this *CexCore) FromPrecision(amount interface{}, scale interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(amount, nil)) {
        return nil
    }
    precise := ccxt.NewPrecise(amount)
    precise.Decimals = this.Sum(precise.Decimals, scale)
    precise.Reduce()
    return ccxt.ToString(precise)
}
func  (this *CexCore) CurrencyFromPrecision(currency interface{}, amount interface{}) interface{}  {
    var scale interface{} = this.SafeInteger(ccxt.GetValue(this.Currencies, currency), "precision", 0)
    return this.FromPrecision(amount, scale)
}
func  (this *CexCore) HandleOrdersSnapshot(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "open-orders",
    //         "data": [{
    //             "id": "59098421630",
    //             "time": "1664062285425",
    //             "type": "buy",
    //             "price": "18920",
    //             "amount": "0.00100000",
    //             "pending": "0.00100000"
    //         }],
    //         "oid": 1,
    //         "ok": "ok"
    //     }
    //
    var symbol interface{} = this.SafeString(message, "oid") // symbol is set as requestId in watchOrders
    var rawOrders interface{} = this.SafeValue(message, "data", []interface{}{})
    var myOrders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        myOrders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var rawOrder interface{} = ccxt.GetValue(rawOrders, i)
        var market interface{} = this.SafeMarket(symbol)
        var order interface{} = this.ParseOrder(rawOrder, market)
        ccxt.AddElementToObject(order, "status", "open")
        myOrders.(ccxt.Appender).Append(order)
    }
    this.Orders = myOrders
    var messageHash interface{} = ccxt.Add("orders:", symbol)
    var ordersLength interface{} =     ccxt.GetArrayLength(myOrders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(ordersLength, 0)) {
        client.(ccxt.ClientInterface).Resolve(myOrders, messageHash)
    }
}
/**
 * @method
 * @name cex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://cex.io/websocket-api#orderbook-subscribe
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9558)
        
            retRes9568 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9568)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var depth interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(limit, nil))), 0, limit)
            var subscribe interface{} = map[string]interface{} {
                "e": "order-book-subscribe",
                "data": map[string]interface{} {
                    "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                    "subscribe": true,
                    "depth": depth,
                },
                "oid": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleOrderBookSnapshot(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "order-book-subscribe",
    //         "data": {
    //             "timestamp": 1663762032,
    //             "timestamp_ms": 1663762031680,
    //             "bids": [
    //                 [ 241.947, 155.91626 ],
    //                 [ 241, 154 ],
    //             ],
    //             "asks": [
    //                 [ 242.947, 155.91626 ],
    //                 [ 243, 154 ],    ],
    //             "pair": "BTC:USDT",
    //             "id": 616267120,
    //             "sell_total": "13.59066946",
    //             "buy_total": "163553.625948"
    //         },
    //         "oid": "1",
    //         "ok": "ok"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var pair interface{} = this.SafeString(data, "pair")
    var symbol interface{} = this.PairToSymbol(pair)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var timestamp interface{} = this.SafeInteger2(data, "timestamp_ms", "timestamp")
    var incrementalId interface{} = this.SafeInteger(data, "id")
    var orderbook interface{} = this.OrderBook(map[string]interface{} {})
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks")
    ccxt.AddElementToObject(snapshot, "nonce", incrementalId)
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "orderbook"), symbol, map[string]interface{} {
    "incrementalId": incrementalId,
})
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *CexCore) PairToSymbol(pair interface{}) interface{}  {
    var parts interface{} = ccxt.Split(pair, ":")
    var baseId interface{} = this.SafeString(parts, 0)
    var quoteId interface{} = this.SafeString(parts, 1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    return symbol
}
func  (this *CexCore) HandleOrderBookUpdate(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "md_update",
    //         "data": {
    //             "id": 616267121,
    //             "pair": "BTC:USDT",
    //             "time": 1663762031719,
    //             "bids": [],
    //             "asks": [
    //                 [122, 23]
    //             ]
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var incrementalId interface{} = this.SafeInteger(data, "id")
    var pair interface{} = this.SafeString(data, "pair", "")
    var symbol interface{} = this.PairToSymbol(pair)
    var storedOrderBook interface{} = this.SafeValue(this.Orderbooks, symbol)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if ccxt.IsTrue(!ccxt.IsEqual(incrementalId, ccxt.Add(ccxt.GetValue(storedOrderBook, "nonce"), 1))) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        client.(ccxt.ClientInterface).Reject(ccxt.Add(this.Id, " watchOrderBook() skipped a message"), messageHash)
        return
    }
    var timestamp interface{} = this.SafeInteger(data, "time")
    var asks interface{} = this.SafeValue(data, "asks", []interface{}{})
    var bids interface{} = this.SafeValue(data, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(storedOrderBook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(storedOrderBook, "bids"), bids)
    ccxt.AddElementToObject(storedOrderBook, "timestamp", timestamp)
    ccxt.AddElementToObject(storedOrderBook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(storedOrderBook, "nonce", incrementalId)
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *CexCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *CexCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name cex#watchOHLCV
 * @see https://cex.io/websocket-api#minute-data
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market. It will return the last 120 minutes with the selected timeframe and then 1m candle updates after that.
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents.
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *CexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10908)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "e": "ccxt.Init-ohlcv",
                "i": timeframe,
                "rooms": []interface{}{ccxt.Add(ccxt.Add(ccxt.Add("pair-", ccxt.GetValue(market, "baseId")), "-"), ccxt.GetValue(market, "quoteId"))},
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *CexCore) HandleInitOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "ccxt.Init-ohlcv-data",
    //         "data": [
    //             [
    //                 1663660680,
    //                 "19396.4",
    //                 "19396.4",
    //                 "19396.4",
    //                 "19396.4",
    //                 "1262861"
    //             ],
    //             ...
    //         ],
    //         "pair": "BTC:USDT"
    //     }
    //
    var pair interface{} = this.SafeString(message, "pair")
    var parts interface{} = ccxt.Split(pair, ":")
    var baseId interface{} = this.SafeString(parts, 0)
    var quoteId interface{} = this.SafeString(parts, 1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var market interface{} = this.SafeMarket(symbol)
    var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
    stored := ccxt.NewArrayCacheByTimestamp(limit)
    var sorted interface{} = this.SortBy(data, 0)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(sorted)); i++ {
        stored.Append(this.ParseOHLCV(ccxt.GetValue(sorted, i), market))
    }
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), "unknown", stored)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CexCore) HandleOHLCV24(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "e": "ohlcv24",
    //         "data": [ '18793.2', '19630', '18793.2', "19104.1", "314157273" ],
    //         "pair": "BTC:USDT"
    //     }
    //
    return message
}
func  (this *CexCore) HandleOHLCV1m(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "ohlcv1m",
    //         "data": {
    //             "pair": "BTC:USD",
    //             "time": "1665436800",
    //             "o": "19279.6",
    //             "h": "19279.6",
    //             "l": "19266.7",
    //             "c": "19266.7",
    //             "v": 3343884,
    //             "d": 3343884
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var pair interface{} = this.SafeString(data, "pair")
    var symbol interface{} = this.PairToSymbol(pair)
    var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
    var ohlcv interface{} = []interface{}{this.SafeTimestamp(data, "time"), this.SafeNumber(data, "o"), this.SafeNumber(data, "h"), this.SafeNumber(data, "l"), this.SafeNumber(data, "c"), this.SafeNumber(data, "v")}
    var stored interface{} = this.SafeValue(this.Ohlcvs, symbol)
    stored.(ccxt.Appender).Append(ohlcv)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CexCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "ohlcv",
    //         "data": [
    //             [1665461100, '19068.2', '19068.2', '19068.2', "19068.2", 268478]
    //         ],
    //         "pair": "BTC:USD"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var pair interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.PairToSymbol(pair)
    var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
    // const stored = this.safeValue (this.ohlcvs, symbol)
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), "unknown")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ohlcv interface{} = []interface{}{this.SafeTimestamp(ccxt.GetValue(data, i), 0), this.SafeNumber(ccxt.GetValue(data, i), 1), this.SafeNumber(ccxt.GetValue(data, i), 2), this.SafeNumber(ccxt.GetValue(data, i), 3), this.SafeNumber(ccxt.GetValue(data, i), 4), this.SafeNumber(ccxt.GetValue(data, i), 5)}
        stored.(ccxt.Appender).Append(ohlcv)
    }
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsGreaterThan(dataLength, 0)) {
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name cex#fetchOrderWs
 * @description fetches information on an order made by the user
 * @see https://docs.cex.io/#ws-api-get-order
 * @param {string} id the order id
 * @param {string} symbol not used by cex fetchOrder
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CexCore) FetchOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12388)
        
            retRes12398 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes12398)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var data interface{} = this.Extend(map[string]interface{} {
                "order_id": ccxt.ToString(id),
            }, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "e": "get-order",
                "oid": messageHash,
                "data": data,
            }
        
            response:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#fetchOpenOrdersWs
 * @see https://docs.cex.io/#ws-api-open-orders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CexCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " fetchOpenOrdersWs requires a symbol.")))
            }
        
            retRes12738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12738)
        
            retRes12748 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes12748)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = this.RequestId()
            var data interface{} = this.Extend(map[string]interface{} {
                "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
            }, params)
            var request interface{} = map[string]interface{} {
                "e": "open-orders",
                "oid": messageHash,
                "data": data,
            }
        
            response:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#createOrderWs
 * @see https://docs.cex.io/#ws-api-order-placement
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the kraken api endpoint
 * @param {boolean} [params.maker_only] Optional, maker only places an order only if offers best sell (<= max) or buy(>= max) price for this pair, if not order placement will be rejected with an error - "ccxt.Order is not maker"
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *CexCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " createOrderWs requires a price argument")))
            }
        
            retRes13088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13088)
        
            retRes13098 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes13098)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = this.RequestId()
            var data interface{} = this.Extend(map[string]interface{} {
                "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                "amount": amount,
                "price": price,
                "type": side,
            }, params)
            var request interface{} = map[string]interface{} {
                "e": "place-order",
                "oid": messageHash,
                "data": data,
            }
        
            rawOrder:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(rawOrder)
        
            ch <- this.ParseOrder(rawOrder, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#editOrderWs
 * @description edit a trade order
 * @see https://docs.cex.io/#ws-api-cancel-replace
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *CexCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(amount, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " editOrder() requires a amount argument")))
            }
            if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " editOrder() requires a price argument")))
            }
        
            retRes13498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13498)
        
            retRes13508 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes13508)
            var market interface{} = this.Market(symbol)
            var data interface{} = this.Extend(map[string]interface{} {
                "pair": []interface{}{ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")},
                "type": side,
                "amount": amount,
                "price": price,
                "order_id": id,
            }, params)
            var messageHash interface{} = this.RequestId()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "e": "cancel-replace-order",
                "oid": messageHash,
                "data": data,
            }
        
            response:= (<-this.Watch(url, messageHash, request, messageHash, messageHash))
            ccxt.PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#cancelOrderWs
 * @see https://docs.cex.io/#ws-api-order-cancel
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol not used by cex cancelOrder ()
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CexCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13818)
        
            retRes13828 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes13828)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var data interface{} = this.Extend(map[string]interface{} {
                "order_id": id,
            }, params)
            var messageHash interface{} = this.RequestId()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "e": "cancel-order",
                "oid": messageHash,
                "data": data,
            }
        
            response:= (<-this.Watch(url, messageHash, request, messageHash, messageHash))
            ccxt.PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cex#cancelOrdersWs
 * @description cancel multiple orders
 * @see https://docs.cex.io/#ws-api-mass-cancel-place
 * @param {string[]} ids order ids
 * @param {string} symbol not used by cex cancelOrders()
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CexCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrderWs does not allow filtering by symbol")))
            }
        
            retRes14158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14158)
        
            retRes14168 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes14168)
            var messageHash interface{} = this.RequestId()
            var data interface{} = this.Extend(map[string]interface{} {
                "cancel-orders": ids,
            }, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "e": "mass-cancel-place-orders",
                "oid": messageHash,
                "data": data,
            }
        
            response:= (<-this.Watch(url, messageHash, request, messageHash, messageHash))
            ccxt.PanicOnError(response)
            //
            //    {
            //        "cancel-orders": [{
            //            "order_id": 69202557979,
            //            "fremains": "0.15000000"
            //        }],
            //        "place-orders": [],
            //        "placed-cancelled": []
            //    }
            //
            var canceledOrders interface{} = this.SafeValue(response, "cancel-orders")
        
            ch <- this.ParseOrders(canceledOrders, nil, nil, nil, params)
            return nil
        
            }()
            return ch
        }
func  (this *CexCore) ResolveData(client interface{}, message interface{})  {
    //
    //    "e": "open-orders",
    //    "data": [
    //       {
    //          "id": "2477098",
    //          "time": "1435927928618",
    //          "type": "buy",
    //          "price": "241.9477",
    //          "amount": "0.02000000",
    //          "pending": "0.02000000"
    //       },
    //       ...
    //    ],
    //    "oid": "1435927928274_9_open-orders",
    //    "ok": "ok"
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    var messageHash interface{} = this.SafeString(message, "oid")
    client.(ccxt.ClientInterface).Resolve(data, messageHash)
}
func  (this *CexCore) HandleConnected(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "e": "connected"
    //     }
    //
    return message
}
func  (this *CexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    
        {
            ret__ := func(this *CexCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *CexCore) interface{} {
                            // catch block:
                                    var messageHash interface{} = this.SafeString(message, "oid")
            var future interface{} = this.SafeValue(ccxt.GetValue(client, "futures"), messageHash)
            if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                return true
            } else {
                panic(error)
            }
                            
                        }(this)
                    }
                }()
    		    // try block:
                        var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
            var error interface{} = this.SafeString(data, "error")
            var event interface{} = this.SafeString(message, "e", "")
            var feedback interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), event), " "), error)
            this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), error, feedback)
            this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), error, feedback)
            panic(ccxt.ExchangeError(feedback))
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *CexCore) HandleMessage(client interface{}, message interface{})  {
    var ok interface{} = this.SafeString(message, "ok")
    if ccxt.IsTrue(ccxt.IsEqual(ok, "error")) {
        this.HandleErrorMessage(client, message)
        return
    }
    var event interface{} = this.SafeString(message, "e")
    var handlers interface{} = map[string]interface{} {
        "auth": this.HandleAuthenticationMessage,
        "connected": this.HandleConnected,
        "tick": this.HandleTicker,
        "ticker": this.HandleTicker,
        "ccxt.Init-ohlcv-data": this.HandleInitOHLCV,
        "ohlcv24": this.HandleOHLCV24,
        "ohlcv1m": this.HandleOHLCV1m,
        "ohlcv": this.HandleOHLCV,
        "get-balance": this.HandleBalance,
        "order-book-subscribe": this.HandleOrderBookSnapshot,
        "md_update": this.HandleOrderBookUpdate,
        "open-orders": this.ResolveData,
        "order": this.HandleOrderUpdate,
        "history-update": this.HandleTrade,
        "history": this.HandleTradesSnapshot,
        "tx": this.HandleTransaction,
        "place-order": this.ResolveData,
        "cancel-replace-order": this.ResolveData,
        "cancel-order": this.ResolveData,
        "mass-cancel-place-orders": this.ResolveData,
        "get-order": this.ResolveData,
    }
    var handler interface{} = this.SafeValue(handlers, event)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
    }
}
func  (this *CexCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "auth",
    //         "data": {
    //             "ok": "ok"
    //         },
    //         "ok": "ok",
    //         "timestamp":1448034593
    //     }
    //
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        future.(*ccxt.Future).Resolve(true)
    }
}
func  (this *CexCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture("authenticated")
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
                var nonce interface{} = ccxt.ToString(this.Seconds())
                var auth interface{} = ccxt.Add(nonce, this.ApiKey)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = map[string]interface{} {
                    "e": "auth",
                    "auth": map[string]interface{} {
                        "key": this.ApiKey,
                        "signature": ccxt.ToUpper(signature),
                        "timestamp": nonce,
                    },
                }
                this.Watch(url, messageHash, this.Extend(request, params), messageHash)
            }
        
                retRes157715 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes157715)
                ch <- retRes157715
                return nil
        
            }()
            return ch
        }


func (this *CexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
