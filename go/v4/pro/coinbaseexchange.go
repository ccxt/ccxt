package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoinbaseexchangeCore struct {
	*ccxt.CoinbaseexchangeCore
	base *ccxt.CoinbaseexchangeCore
}

func NewCoinbaseexchangeCore() *CoinbaseexchangeCore {
    p := &CoinbaseexchangeCore{}
	base := &ccxt.CoinbaseexchangeCore{}
	p.base = base
	p.CoinbaseexchangeCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoinbaseexchangeCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTradesForSymbols": true,
            "watchBalance": false,
            "watchStatus": false,
            "watchOrders": true,
            "watchOrdersForSymbols": true,
            "watchMyTrades": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws-feed.exchange.coinbase.com",
            },
            "test": map[string]interface{} {
                "ws": "wss://ws-feed-public.sandbox.exchange.coinbase.com",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "myTradesLimit": 1000,
        },
    })
}
func  (this *CoinbaseexchangeCore) Authenticate() interface{}  {
    this.CheckRequiredCredentials()
    var path interface{} = "/users/self/verify"
    var nonce interface{} = this.Nonce()
    var payload interface{} = ccxt.Add(ccxt.Add(ccxt.ToString(nonce), "GET"), path)
    var signature interface{} = this.Hmac(this.Encode(payload), this.Base64ToBinary(this.Secret), ccxt.Sha256, "base64")
    return map[string]interface{} {
        "timestamp": nonce,
        "key": this.ApiKey,
        "signature": signature,
        "passphrase": this.Password,
    }
}
func  (this *CoinbaseexchangeCore) Subscribe(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            messageHashStart := ccxt.GetArg(optionalArgs, 1, nil)
            _ = messageHashStart
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes628)
            var market interface{} = nil
            var messageHash interface{} = messageHashStart
            var productIds interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&productIds, ccxt.GetValue(market, "id"))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            if ccxt.IsTrue(ccxt.InOp(params, "signature")) {
                // need to distinguish between public trades and user trades
                url = ccxt.Add(url, "?")
            }
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": productIds,
                "channels": []interface{}{name},
            }
            var request interface{} = this.Extend(subscribe, params)
        
                retRes8415 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes8415)
                ch <- retRes8415
                return nil
        
            }()
            return ch
        }
func  (this *CoinbaseexchangeCore) SubscribeMultiple(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, []interface{}{})
            _ = symbols
            messageHashStart := ccxt.GetArg(optionalArgs, 1, nil)
            _ = messageHashStart
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes888)
            var market interface{} = nil
            symbols = this.MarketSymbols(symbols)
            var messageHashes interface{} = []interface{}{}
            var productIds interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                market = this.Market(symbol)
                ccxt.AppendToArray(&productIds, ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHashStart, ":"), ccxt.GetValue(market, "symbol")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            if ccxt.IsTrue(ccxt.InOp(params, "signature")) {
                // need to distinguish between public trades and user trades
                url = ccxt.Add(url, "?")
            }
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": productIds,
                "channels": []interface{}{name},
            }
            var request interface{} = this.Extend(subscribe, params)
        
                retRes11215 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes11215)
                ch <- retRes11215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoinbaseexchangeCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var name interface{} = "ticker"
        
                retRes12515 :=  (<-this.Subscribe(name, symbol, name, params))
                ccxt.PanicOnError(retRes12515)
                ch <- retRes12515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoinbaseexchangeCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1388)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.BadSymbol(ccxt.Add(this.Id, " watchTickers requires a non-empty symbols array")))
            }
            var channel interface{} = "ticker"
            var messageHash interface{} = "ticker"
        
            ticker:= (<-this.SubscribeMultiple(channel, symbols, messageHash, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *CoinbaseexchangeCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1658)
            symbol = this.Symbol(symbol)
            var name interface{} = "matches"
        
            trades:= (<-this.Subscribe(name, symbol, name, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *CoinbaseexchangeCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes1908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1908)
            symbols = this.MarketSymbols(symbols)
            var name interface{} = "matches"
        
            trades:= (<-this.SubscribeMultiple(name, symbols, name, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *CoinbaseexchangeCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchMyTrades() requires a symbol argument")))
            }
        
            retRes2168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2168)
            symbol = this.Symbol(symbol)
            var name interface{} = "user"
            var messageHash interface{} = "myTrades"
            var authentication interface{} = this.Authenticate()
        
            trades:= (<-this.Subscribe(name, symbol, messageHash, this.Extend(params, authentication)))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchMyTradesForSymbols
 * @description watches information on multiple trades made by the user
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *CoinbaseexchangeCore) WatchMyTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            symbols = this.MarketSymbols(symbols, nil, false)
        
            retRes2408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2408)
            var name interface{} = "user"
            var messageHash interface{} = "myTrades"
            var authentication interface{} = this.Authenticate()
        
            trades:= (<-this.SubscribeMultiple(name, symbols, messageHash, this.Extend(params, authentication)))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchOrdersForSymbols
 * @description watches information on multiple orders made by the user
 * @param {string[]} symbols unified symbol of the market to fetch orders for
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *CoinbaseexchangeCore) WatchOrdersForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2648 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2648)
            symbols = this.MarketSymbols(symbols, nil, false)
            var name interface{} = "user"
            var messageHash interface{} = "orders"
            var authentication interface{} = this.Authenticate()
        
            orders:= (<-this.SubscribeMultiple(name, symbols, messageHash, this.Extend(params, authentication)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(orders, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(orders).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *CoinbaseexchangeCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadSymbol(ccxt.Add(this.Id, " watchMyTrades requires a symbol")))
            }
        
            retRes2928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2928)
            symbol = this.Symbol(symbol)
            var name interface{} = "user"
            var messageHash interface{} = "orders"
            var authentication interface{} = this.Authenticate()
        
            orders:= (<-this.Subscribe(name, symbol, messageHash, this.Extend(params, authentication)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseexchangeCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            var name interface{} = "level2"
        
            retRes3198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3198)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, symbolsLength); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, ":"), marketId))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": marketIds,
                "channels": []interface{}{name},
            }
            var request interface{} = this.Extend(subscribe, params)
            var subscription interface{} = map[string]interface{} {
                "messageHash": name,
                "symbols": symbols,
                "marketIds": marketIds,
                "limit": limit,
            }
            var authentication interface{} = this.Authenticate()
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, authentication), messageHashes, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseexchangeCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var name interface{} = "level2"
        
            retRes3588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3588)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": []interface{}{ccxt.GetValue(market, "id")},
                "channels": []interface{}{name},
            }
            var request interface{} = this.Extend(subscribe, params)
            var subscription interface{} = map[string]interface{} {
                "messageHash": messageHash,
                "symbol": symbol,
                "marketId": ccxt.GetValue(market, "id"),
                "limit": limit,
            }
            var authentication interface{} = this.Authenticate()
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, authentication), messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseexchangeCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "match",
    //         "trade_id": 82047307,
    //         "maker_order_id": "0f358725-2134-435e-be11-753912a326e0",
    //         "taker_order_id": "252b7002-87a3-425c-ac73-f5b9e23f3caf",
    //         "side": "sell",
    //         "size": "0.00513192",
    //         "price": "9314.78",
    //         "product_id": "BTC-USD",
    //         "sequence": 12038915443,
    //         "time": "2020-01-31T20:03:41.158814Z"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var trade interface{} = this.ParseWsTrade(message)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        // the exchange sends type = 'match'
        // but requires 'matches' upon subscribing
        // therefore we resolve 'matches' here instead of 'match'
        var typeVar interface{} = "matches"
        var messageHash interface{} = ccxt.Add(ccxt.Add(typeVar, ":"), marketId)
        var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
            var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            tradesArray = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
        }
        tradesArray.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    }
    return message
}
func  (this *CoinbaseexchangeCore) HandleMyTrade(client interface{}, message interface{}) interface{}  {
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var trade interface{} = this.ParseWsTrade(message)
        var typeVar interface{} = "myTrades"
        var messageHash interface{} = ccxt.Add(ccxt.Add(typeVar, ":"), marketId)
        var tradesArray interface{} = this.MyTrades
        if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "myTradesLimit", 1000)
            tradesArray = ccxt.NewArrayCacheBySymbolById(limit)
            this.MyTrades = tradesArray
        }
        tradesArray.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    }
    return message
}
func  (this *CoinbaseexchangeCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // private trades
    // {
    //     "type": "match",
    //     "trade_id": 10,
    //     "sequence": 50,
    //     "maker_order_id": "ac928c66-ca53-498f-9c13-a110027a60e8",
    //     "taker_order_id": "132fb6ae-456b-4654-b4e0-d681ac05cea1",
    //     "time": "2014-11-07T08:19:27.028459Z",
    //     "product_id": "BTC-USD",
    //     "size": "5.23512",
    //     "price": "400.23",
    //     "side": "sell",
    //     "taker_user_id: "5844eceecf7e803e259d0365",
    //     "user_id": "5844eceecf7e803e259d0365",
    //     "taker_profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
    //     "profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
    //     "taker_fee_rate": "0.005"
    // }
    //
    // {
    //     "type": "match",
    //     "trade_id": 10,
    //     "sequence": 50,
    //     "maker_order_id": "ac928c66-ca53-498f-9c13-a110027a60e8",
    //     "taker_order_id": "132fb6ae-456b-4654-b4e0-d681ac05cea1",
    //     "time": "2014-11-07T08:19:27.028459Z",
    //     "product_id": "BTC-USD",
    //     "size": "5.23512",
    //     "price": "400.23",
    //     "side": "sell",
    //     "maker_user_id: "5844eceecf7e803e259d0365",
    //     "maker_id": "5844eceecf7e803e259d0365",
    //     "maker_profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
    //     "profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
    //     "maker_fee_rate": "0.001"
    // }
    //
    // public trades
    // {
    //     "type": "received",
    //     "time": "2014-11-07T08:19:27.028459Z",
    //     "product_id": "BTC-USD",
    //     "sequence": 10,
    //     "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
    //     "size": "1.34",
    //     "price": "502.1",
    //     "side": "buy",
    //     "order_type": "limit"
    // }
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var parsed interface{} = this.base.ParseTrade(trade)
    var feeRate interface{} = nil
    var isMaker interface{} = false
    if ccxt.IsTrue(ccxt.InOp(trade, "maker_fee_rate")) {
        isMaker = true
        ccxt.AddElementToObject(parsed, "takerOrMaker", "maker")
        feeRate = this.SafeNumber(trade, "maker_fee_rate")
    } else {
        ccxt.AddElementToObject(parsed, "takerOrMaker", "taker")
        feeRate = this.SafeNumber(trade, "taker_fee_rate")
        // side always represents the maker side of the trade
        // so if we're taker, we invert it
        var currentSide interface{} = ccxt.GetValue(parsed, "side")
        ccxt.AddElementToObject(parsed, "side", this.SafeString(map[string]interface{} {
    "buy": "sell",
    "sell": "buy",
}, currentSide, currentSide))
    }
    var idKey interface{} = ccxt.Ternary(ccxt.IsTrue(isMaker), "maker_order_id", "taker_order_id")
    ccxt.AddElementToObject(parsed, "order", this.SafeString(trade, idKey))
    market = this.Market(ccxt.GetValue(parsed, "symbol"))
    var feeCurrency interface{} = ccxt.GetValue(market, "quote")
    var feeCost interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(parsed, "cost"), nil))) && ccxt.IsTrue((!ccxt.IsEqual(feeRate, nil)))) {
        var cost interface{} = this.SafeNumber(parsed, "cost")
        feeCost = ccxt.Multiply(cost, feeRate)
    }
    ccxt.AddElementToObject(parsed, "fee", map[string]interface{} {
    "rate": feeRate,
    "cost": feeCost,
    "currency": feeCurrency,
})
    return parsed
}
func  (this *CoinbaseexchangeCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "filled": "closed",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, "open")
}
func  (this *CoinbaseexchangeCore) HandleOrder(client interface{}, message interface{})  {
    //
    // ccxt.Order is created
    //
    //     {
    //         "type": "received",
    //         "side": "sell",
    //         "product_id": "BTC-USDC",
    //         "time": "2021-03-05T16:42:21.878177Z",
    //         "sequence": 5641953814,
    //         "profile_id": "774ee0ce-fdda-405f-aa8d-47189a14ba0a",
    //         "user_id": "54fc141576dcf32596000133",
    //         "order_id": "11838707-bf9c-4d65-8cec-b57c9a7cab42",
    //         "order_type": "limit",
    //         "size": "0.0001",
    //         "price": "50000",
    //         "client_oid": "a317abb9-2b30-4370-ebfe-0deecb300180"
    //     }
    //
    //     {
    //         "type": "received",
    //         "time": "2014-11-09T08:19:27.028459Z",
    //         "product_id": "BTC-USD",
    //         "sequence": 12,
    //         "order_id": "dddec984-77a8-460a-b958-66f114b0de9b",
    //         "funds": "3000.234",
    //         "side": "buy",
    //         "order_type": "market"
    //     }
    //
    // ccxt.Order is on the order book
    //
    //     {
    //         "type": "open",
    //         "side": "sell",
    //         "product_id": "BTC-USDC",
    //         "time": "2021-03-05T16:42:21.878177Z",
    //         "sequence": 5641953815,
    //         "profile_id": "774ee0ce-fdda-405f-aa8d-47189a14ba0a",
    //         "user_id": "54fc141576dcf32596000133",
    //         "price": "50000",
    //         "order_id": "11838707-bf9c-4d65-8cec-b57c9a7cab42",
    //         "remaining_size": "0.0001"
    //     }
    //
    // ccxt.Order is partially or completely filled
    //
    //     {
    //         "type": "match",
    //         "side": "sell",
    //         "product_id": "BTC-USDC",
    //         "time": "2021-03-05T16:37:13.396107Z",
    //         "sequence": 5641897876,
    //         "profile_id": "774ee0ce-fdda-405f-aa8d-47189a14ba0a",
    //         "user_id": "54fc141576dcf32596000133",
    //         "trade_id": 5455505,
    //         "maker_order_id": "e5f5754d-70a3-4346-95a6-209bcb503629",
    //         "taker_order_id": "88bf7086-7b15-40ff-8b19-ab4e08516d69",
    //         "size": "0.00021019",
    //         "price": "47338.46",
    //         "taker_profile_id": "774ee0ce-fdda-405f-aa8d-47189a14ba0a",
    //         "taker_user_id": "54fc141576dcf32596000133",
    //         "taker_fee_rate": "0.005"
    //     }
    //
    // ccxt.Order is canceled / closed
    //
    //     {
    //         "type": "done",
    //         "side": "buy",
    //         "product_id": "BTC-USDC",
    //         "time": "2021-03-05T16:37:13.396107Z",
    //         "sequence": 5641897877,
    //         "profile_id": "774ee0ce-fdda-405f-aa8d-47189a14ba0a",
    //         "user_id": "54fc141576dcf32596000133",
    //         "order_id": "88bf7086-7b15-40ff-8b19-ab4e08516d69",
    //         "reason": "filled"
    //     }
    //
    var currentOrders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(currentOrders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        currentOrders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = currentOrders
    }
    var typeVar interface{} = this.SafeString(message, "type")
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var messageHash interface{} = ccxt.Add("orders:", marketId)
        var symbol interface{} = this.SafeSymbol(marketId)
        var orderId interface{} = this.SafeString(message, "order_id")
        var makerOrderId interface{} = this.SafeString(message, "maker_order_id")
        var takerOrderId interface{} = this.SafeString(message, "taker_order_id")
        var orders interface{} = this.Orders
        var previousOrders interface{} = this.SafeValue(orders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var previousOrder interface{} = this.SafeValue(previousOrders, orderId)
        if ccxt.IsTrue(ccxt.IsEqual(previousOrder, nil)) {
            previousOrder = this.SafeValue2(previousOrders, makerOrderId, takerOrderId)
        }
        if ccxt.IsTrue(ccxt.IsEqual(previousOrder, nil)) {
            var parsed interface{} = this.ParseWsOrder(message)
            orders.(ccxt.Appender).Append(parsed)
            client.(ccxt.ClientInterface).Resolve(orders, messageHash)
        } else {
            var sequence interface{} = this.SafeInteger(message, "sequence")
            var previousInfo interface{} = this.SafeValue(previousOrder, "info", map[string]interface{} {})
            var previousSequence interface{} = this.SafeInteger(previousInfo, "sequence")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(previousSequence, nil))) || ccxt.IsTrue((ccxt.IsGreaterThan(sequence, previousSequence)))) {
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "match")) {
                    var trade interface{} = this.ParseWsTrade(message)
                    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "trades"), nil)) {
                        ccxt.AddElementToObject(previousOrder, "trades", []interface{}{})
                    }
                    retRes64524 := ccxt.GetValue(previousOrder, "trades")
                    ccxt.AppendToArray(&retRes64524, trade)
                    ccxt.AddElementToObject(previousOrder, "lastTradeTimestamp", ccxt.GetValue(trade, "timestamp"))
                    var totalCost interface{} = 0
                    var totalAmount interface{} = 0
                    var trades interface{} = ccxt.GetValue(previousOrder, "trades")
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
                        var tradeEntry interface{} = ccxt.GetValue(trades, i)
                        totalCost = this.Sum(totalCost, ccxt.GetValue(tradeEntry, "cost"))
                        totalAmount = this.Sum(totalAmount, ccxt.GetValue(tradeEntry, "amount"))
                    }
                    if ccxt.IsTrue(ccxt.IsGreaterThan(totalAmount, 0)) {
                        ccxt.AddElementToObject(previousOrder, "average", ccxt.Divide(totalCost, totalAmount))
                    }
                    ccxt.AddElementToObject(previousOrder, "cost", totalCost)
                    if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "filled"), nil)) {
                        ccxt.AddElementToObject(previousOrder, "filled", ccxt.Add(ccxt.GetValue(previousOrder, "filled"), ccxt.GetValue(trade, "amount")))
                        if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "amount"), nil)) {
                            ccxt.AddElementToObject(previousOrder, "remaining", ccxt.Subtract(ccxt.GetValue(previousOrder, "amount"), ccxt.GetValue(previousOrder, "filled")))
                        }
                    }
                    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "fee"), nil)) {
                        ccxt.AddElementToObject(previousOrder, "fee", map[string]interface{} {
    "cost": 0,
    "currency": ccxt.GetValue(ccxt.GetValue(trade, "fee"), "currency"),
})
                    }
                    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"), nil))) && ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost"), nil)))) {
                        ccxt.AddElementToObject(ccxt.GetValue(previousOrder, "fee"), "cost", this.Sum(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"), ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost")))
                    }
                    // update the newUpdates count
                    orders.(ccxt.Appender).Append(previousOrder)
                    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
                } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "received"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "done")))) {
                    var info interface{} = this.Extend(ccxt.GetValue(previousOrder, "info"), message)
                    var order interface{} = this.ParseWsOrder(info)
                    var keys interface{} = ccxt.ObjectKeys(order)
                    // update the reference
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
                        var key interface{} = ccxt.GetValue(keys, i)
                        if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(order, key), nil)) {
                            ccxt.AddElementToObject(previousOrder, key, ccxt.GetValue(order, key))
                        }
                    }
                    // update the newUpdates count
                    orders.(ccxt.Appender).Append(previousOrder)
                    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
                }
            }
        }
    }
}
func  (this *CoinbaseexchangeCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var clientOrderId interface{} = this.SafeString(order, "client_oid")
    var marketId interface{} = this.SafeString(order, "product_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var side interface{} = this.SafeString(order, "side")
    var price interface{} = this.SafeNumber(order, "price")
    var amount interface{} = this.SafeNumber2(order, "size", "funds")
    var time interface{} = this.SafeString(order, "time")
    var timestamp interface{} = this.Parse8601(time)
    var reason interface{} = this.SafeString(order, "reason")
    var status interface{} = this.ParseWsOrderStatus(reason)
    var orderType interface{} = this.SafeString(order, "order_type")
    var remaining interface{} = this.SafeNumber(order, "remaining_size")
    var typeVar interface{} = this.SafeString(order, "type")
    var filled interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(amount, nil))) && ccxt.IsTrue((!ccxt.IsEqual(remaining, nil)))) {
        filled = ccxt.Subtract(amount, remaining)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "received")) {
        filled = 0
        if ccxt.IsTrue(!ccxt.IsEqual(amount, nil)) {
            remaining = ccxt.Subtract(amount, filled)
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": orderType,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": nil,
        "trades": nil,
    })
}
func  (this *CoinbaseexchangeCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "ticker",
    //         "sequence": 12042642428,
    //         "product_id": "BTC-USD",
    //         "price": "9380.55",
    //         "open_24h": "9450.81000000",
    //         "volume_24h": "9611.79166047",
    //         "low_24h": "9195.49000000",
    //         "high_24h": "9475.19000000",
    //         "volume_30d": "327812.00311873",
    //         "best_bid": "9380.54",
    //         "best_ask": "9380.55",
    //         "side": "buy",
    //         "time": "2020-02-01T01:40:16.253563Z",
    //         "trade_id": 82062566,
    //         "last_size": "0.41969131"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var ticker interface{} = this.ParseTicker(message)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        var messageHash interface{} = ccxt.Add("ticker:", symbol)
        var idMessageHash interface{} = ccxt.Add("ticker:", marketId)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
        client.(ccxt.ClientInterface).Resolve(ticker, idMessageHash)
    }
    return message
}
func  (this *CoinbaseexchangeCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "type": "ticker",
    //         "sequence": 7388547310,
    //         "product_id": "BTC-USDT",
    //         "price": "22345.67",
    //         "open_24h": "22308.13",
    //         "volume_24h": "470.21123644",
    //         "low_24h": "22150",
    //         "high_24h": "22495.15",
    //         "volume_30d": "25713.98401605",
    //         "best_bid": "22345.67",
    //         "best_bid_size": "0.10647825",
    //         "best_ask": "22349.68",
    //         "best_ask_size": "0.03131702",
    //         "side": "sell",
    //         "time": "2023-03-04T03:37:20.799258Z",
    //         "trade_id": 11586478,
    //         "last_size": "0.00352175"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var typeVar interface{} = this.SafeString(ticker, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
        return this.base.ParseTicker(ticker, market)
    }
    var marketId interface{} = this.SafeString(ticker, "product_id")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "time"))
    var last interface{} = this.SafeString(ticker, "price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high_24h"),
        "low": this.SafeString(ticker, "low_24h"),
        "bid": this.SafeString(ticker, "best_bid"),
        "bidVolume": this.SafeString(ticker, "best_bid_size"),
        "ask": this.SafeString(ticker, "best_ask"),
        "askVolume": this.SafeString(ticker, "best_ask_size"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open_24h"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume_24h"),
        "quoteVolume": nil,
        "info": ticker,
    })
}
func  (this *CoinbaseexchangeCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeNumber(delta, 0)
    var amount interface{} = this.SafeNumber(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *CoinbaseexchangeCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *CoinbaseexchangeCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // first message (snapshot)
    //
    //     {
    //         "type": "snapshot",
    //         "product_id": "BTC-USD",
    //         "bids": [
    //             ["10101.10", "0.45054140"]
    //         ],
    //         "asks": [
    //             ["10102.55", "0.57753524"]
    //         ]
    //     }
    //
    // subsequent updates
    //
    //     {
    //         "type": "l2update",
    //         "product_id": "BTC-USD",
    //         "time": "2019-08-14T20:42:27.265Z",
    //         "changes": [
    //             [ "buy", "10101.80000000", "0.162567" ]
    //         ]
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var marketId interface{} = this.SafeString(message, "product_id")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var name interface{} = "level2"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), marketId)
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
    var limit interface{} = this.SafeInteger(subscription, "limit")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), this.SafeValue(message, "asks", []interface{}{}))
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), this.SafeValue(message, "bids", []interface{}{}))
        ccxt.AddElementToObject(orderbook, "timestamp", nil)
        ccxt.AddElementToObject(orderbook, "datetime", nil)
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "l2update")) {
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.Parse8601(this.SafeString(message, "time"))
        var changes interface{} = this.SafeValue(message, "changes", []interface{}{})
        var sides interface{} = map[string]interface{} {
            "sell": "asks",
            "buy": "bids",
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(changes)); i++ {
            var change interface{} = ccxt.GetValue(changes, i)
            var key interface{} = this.SafeString(change, 0)
            var side interface{} = this.SafeString(sides, key)
            var price interface{} = this.SafeNumber(change, 1)
            var amount interface{} = this.SafeNumber(change, 2)
            var bookside interface{} = ccxt.GetValue(orderbook, side)
            bookside.(ccxt.IOrderBookSide).Store(price, amount)
        }
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *CoinbaseexchangeCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "subscriptions",
    //         "channels": [
    //             {
    //                 "name": "level2",
    //                 "product_ids": [ "ETH-BTC" ]
    //             }
    //         ]
    //     }
    //
    return message
}
func  (this *CoinbaseexchangeCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "error",
    //         "message": "error message",
    //         /* ... */
    //     }
    //
    // auth error
    //
    //     {
    //         "type": "error",
    //         "message": "Authentication Failed",
    //         "reason": "{"message":"Invalid API Key"}"
    //     }
    //
    var errMsg interface{} = this.SafeString(message, "message")
    var reason interface{} = this.SafeString(message, "reason")
    
        {
            ret__ := func(this *CoinbaseexchangeCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *CoinbaseexchangeCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(error)
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsEqual(errMsg, "Authentication Failed")) {
                panic(ccxt.AuthenticationError(ccxt.Add("Authentication failed: ", reason)))
            } else {
                panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), reason)))
            }
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *CoinbaseexchangeCore) HandleMessage(client interface{}, message interface{})  {
    var typeVar interface{} = this.SafeString(message, "type")
    var methods interface{} = map[string]interface{} {
        "snapshot": this.HandleOrderBook,
        "l2update": this.HandleOrderBook,
        "subscribe": this.HandleSubscriptionStatus,
        "ticker": this.HandleTicker,
        "received": this.HandleOrder,
        "open": this.HandleOrder,
        "change": this.HandleOrder,
        "done": this.HandleOrder,
        "error": this.HandleErrorMessage,
    }
    var length interface{} = ccxt.Subtract(ccxt.GetLength(client.(ccxt.ClientInterface).GetUrl()), 0)
    var authenticated interface{} = ccxt.IsEqual(ccxt.GetValue(client.(ccxt.ClientInterface).GetUrl(), ccxt.Subtract(length, 1)), "?")
    var method interface{} = this.SafeValue(methods, typeVar)
    if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "match")) {
            if ccxt.IsTrue(authenticated) {
                this.HandleMyTrade(client, message)
                this.HandleOrder(client, message)
            } else {
                this.HandleTrade(client, message)
            }
        }
    } else {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *CoinbaseexchangeCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
