package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HashkeyCore struct {
	*ccxt.HashkeyCore
	base *ccxt.HashkeyCore
}

func NewHashkeyCore() *HashkeyCore {
    p := &HashkeyCore{}
	base := &ccxt.HashkeyCore{}
	p.base = base
	p.HashkeyCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *HashkeyCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPositions": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://stream-glb.hashkey.com/quote/ws/v1",
                    "private": "wss://stream-glb.hashkey.com/api/v1/ws",
                },
                "test": map[string]interface{} {
                    "ws": map[string]interface{} {
                        "public": "wss://stream-glb.sim.hashkeydev.com/quote/ws/v1",
                        "private": "wss://stream-glb.sim.hashkeydev.com/api/v1/ws",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "listenKeyRefreshRate": 3600000,
            "listenKey": nil,
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": true,
                "awaitBalanceSnapshot": false,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 10000,
        },
    })
}
func  (this *HashkeyCore) WathPublic(market interface{}, topic interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
                "topic": topic,
                "event": "sub",
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
        
                retRes6015 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes6015)
                ch <- retRes6015
                return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) WatchPrivate(messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            listenKey:= (<-this.Authenticate())
            ccxt.PanicOnError(listenKey)
            var url interface{} = this.GetPrivateUrl(listenKey)
        
                retRes6615 :=  (<-this.Watch(url, messageHash, nil, messageHash))
                ccxt.PanicOnError(retRes6615)
                ch <- retRes6615
                return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) GetPrivateUrl(listenKey interface{}) interface{}  {
    return ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), listenKey)
}
/**
 * @method
 * @name hashkey#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.binary] true or false - default false
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HashkeyCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes878)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var topic interface{} = ccxt.Add("kline_", interval)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
        
            ohlcv:= (<-this.WathPublic(market, topic, messageHash, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "symbol": "DOGEUSDT",
    //         "symbolName": "DOGEUSDT",
    //         "topic": "kline",
    //         "params": {
    //             "realtimeInterval": "24h",
    //             "klineType": "1m"
    //         },
    //         "data": [
    //             {
    //                 "t": 1722861660000,
    //                 "s": "DOGEUSDT",
    //                 "sn": "DOGEUSDT",
    //                 "c": "0.08389",
    //                 "h": "0.08389",
    //                 "l": "0.08389",
    //                 "o": "0.08389",
    //                 "v": "0"
    //             }
    //         ],
    //         "f": true,
    //         "sendTime": 1722861664258,
    //         "shared": false
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    var params interface{} = this.SafeDict(message, "params")
    var klineType interface{} = this.SafeString(params, "klineType")
    var timeframe interface{} = this.FindTimeframe(klineType)
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var candle interface{} = this.SafeDict(data, i, map[string]interface{} {})
        var parsed interface{} = this.ParseWsOHLCV(candle, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *HashkeyCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "t": 1722861660000,
    //         "s": "DOGEUSDT",
    //         "sn": "DOGEUSDT",
    //         "c": "0.08389",
    //         "h": "0.08389",
    //         "l": "0.08389",
    //         "o": "0.08389",
    //         "v": "0"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name hahskey#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.binary] true or false - default false
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *HashkeyCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1858)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = "realtimes"
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
        
                retRes19015 :=  (<-this.WathPublic(market, topic, messageHash, params))
                ccxt.PanicOnError(retRes19015)
                ch <- retRes19015
                return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "topic": "realtimes",
    //         "params": {
    //             "realtimeInterval": "24h"
    //         },
    //         "data": [
    //             {
    //                 "t": 1722864411064,
    //                 "s": "ETHUSDT",
    //                 "sn": "ETHUSDT",
    //                 "c": "2195",
    //                 "h": "2918.85",
    //                 "l": "2135.5",
    //                 "o": "2915.78",
    //                 "v": "666.5019",
    //                 "qv": "1586902.757079",
    //                 "m": "-0.2472",
    //                 "e": 301
    //             }
    //         ],
    //         "f": false,
    //         "sendTime": 1722864411086,
    //         "shared": false
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = this.ParseTicker(this.SafeDict(data, 0))
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
/**
 * @method
 * @name hashkey#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.binary] true or false - default false
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *HashkeyCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2438)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = "trade"
            var messageHash interface{} = ccxt.Add("trades:", symbol)
        
            trades:= (<-this.WathPublic(market, topic, messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "topic": "trade",
    //         "params": {
    //             "realtimeInterval": "24h"
    //         },
    //         "data": [
    //             {
    //                 "v": "1745922896272048129",
    //                 "t": 1722866228075,
    //                 "p": "2340.41",
    //                 "q": "0.0132",
    //                 "m": true
    //             },
    //             ...
    //         ],
    //         "f": true,
    //         "sendTime": 1722869464248,
    //         "channelId": "668498fffeba4108-00000001-00113184-562e27d215e43f9c-c188b319",
    //         "shared": false
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    var data interface{} = this.SafeList(message, "data")
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        data = this.SortBy(data, "t")
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var trade interface{} = this.SafeDict(data, i)
            var parsed interface{} = this.ParseWsTrade(trade, market)
            stored.(ccxt.Appender).Append(parsed)
        }
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("trades", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name hashkey#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#public-stream
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *HashkeyCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3128)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = "depth"
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
        
            orderbook:= (<-this.WathPublic(market, topic, messageHash, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "symbol": "ETHUSDT",
    //         "symbolName": "ETHUSDT",
    //         "topic": "depth",
    //         "params": { "realtimeInterval": "24h" },
    //         "data": [
    //             {
    //                 "e": 301,
    //                 "s": "ETHUSDT",
    //                 "t": 1722873144371,
    //                 "v": "84661262_18",
    //                 "b": [
    //                     [ "1650", "0.0864" ],
    //                     ...
    //                 ],
    //                 "a": [
    //                     ["4085", "0.0074" ],
    //                     ...
    //                 ],
    //                 "o": 0
    //             }
    //         ],
    //         "f": false,
    //         "sendTime": 1722873144589,
    //         "channelId": "2265aafffe68b588-00000001-0011510c-9e9ca710b1500854-551830bd",
    //         "shared": false
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var dataEntry interface{} = this.SafeDict(data, 0)
    var timestamp interface{} = this.SafeInteger(dataEntry, "t")
    var snapshot interface{} = this.ParseOrderBook(dataEntry, symbol, timestamp, "b", "a")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(message, "id"))
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name hashkey#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *HashkeyCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3808)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.WatchPrivate(messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleOrder(client interface{}, message interface{})  {
    //
    // swap
    //     {
    //         "e": "contractExecutionReport",
    //         "E": "1723037391181",
    //         "s": "ETHUSDT-PERPETUAL",
    //         "c": "1723037389677",
    //         "S": "BUY_OPEN",
    //         "o": "LIMIT",
    //         "f": "IOC",
    //         "q": "1",
    //         "p": "2561.75",
    //         "X": "FILLED",
    //         "i": "1747358716129257216",
    //         "l": "1",
    //         "z": "1",
    //         "L": "2463.36",
    //         "n": "0.001478016",
    //         "N": "USDT",
    //         "u": true,
    //         "w": true,
    //         "m": false,
    //         "O": "1723037391140",
    //         "Z": "2463.36",
    //         "C": false,
    //         "v": "5",
    //         "reqAmt": "0",
    //         "d": "1747358716255075840",
    //         "r": "0",
    //         "V": "2463.36",
    //         "P": "0",
    //         "lo": false,
    //         "lt": ""
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var parsed interface{} = this.ParseWsOrder(message)
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orders, symbolSpecificMessageHash)
}
func  (this *HashkeyCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "s")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(order, "O")
    var side interface{} = this.SafeStringLower(order, "S")
    var reduceOnly interface{} = nil
    sidereduceOnlyVariable := this.ParseOrderSideAndReduceOnly(side)
    side = ccxt.GetValue(sidereduceOnlyVariable,0)
    reduceOnly = ccxt.GetValue(sidereduceOnlyVariable,1)
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "o"))
    var timeInForce interface{} = this.SafeString(order, "f")
    var postOnly interface{} = nil
    typeVartimeInForcepostOnlyVariable := this.ParseOrderTypeTimeInForceAndPostOnly(typeVar, timeInForce)
    typeVar = ccxt.GetValue(typeVartimeInForcepostOnlyVariable,0)
    timeInForce = ccxt.GetValue(typeVartimeInForcepostOnlyVariable,1)
    postOnly = ccxt.GetValue(typeVartimeInForcepostOnlyVariable,2)
    if ccxt.IsTrue(ccxt.GetValue(market, "contract")) {
        typeVar = nil
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "i"),
        "clientOrderId": this.SafeString(order, "c"),
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "X")),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": this.SafeString(order, "p"),
        "average": this.SafeString(order, "V"),
        "amount": this.OmitZero(this.SafeString(order, "q")),
        "filled": this.SafeString(order, "z"),
        "remaining": this.SafeString(order, "r"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "cost": this.OmitZero(this.SafeString(order, "Z")),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(this.SafeString(order, "N")),
            "amount": this.OmitZero(this.SafeString(order, "n")),
        },
        "reduceOnly": reduceOnly,
        "postOnly": postOnly,
        "info": order,
    }, market)
}
/**
 * @method
 * @name hashkey#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *HashkeyCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5028)
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            trades:= (<-this.WatchPrivate(messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandleMyTrade(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     {
    //         "e": "ticketInfo",
    //         "E": "1723037391156",
    //         "s": "ETHUSDT-PERPETUAL",
    //         "q": "1.00",
    //         "t": "1723037391147",
    //         "p": "2463.36",
    //         "T": "1747358716187197441",
    //         "o": "1747358716129257216",
    //         "c": "1723037389677",
    //         "a": "1735619524953226496",
    //         "m": false,
    //         "S": "BUY"
    //     }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = subscription
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var tradesArray interface{} = this.MyTrades
    var parsed interface{} = this.ParseWsTrade(message)
    tradesArray.(ccxt.Appender).Append(parsed)
    this.MyTrades = tradesArray
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(tradesArray, symbolSpecificMessageHash)
}
func  (this *HashkeyCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // watchTrades
    //     {
    //         "v": "1745922896272048129",
    //         "t": 1722866228075,
    //         "p": "2340.41",
    //         "q": "0.0132",
    //         "m": true
    //     }
    //
    // watchMyTrades
    //     {
    //         "e": "ticketInfo",
    //         "E": "1723037391156",
    //         "s": "ETHUSDT-PERPETUAL",
    //         "q": "1.00",
    //         "t": "1723037391147",
    //         "p": "2463.36",
    //         "T": "1747358716187197441",
    //         "o": "1747358716129257216",
    //         "c": "1723037389677",
    //         "a": "1735619524953226496",
    //         "m": false,
    //         "S": "BUY"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "s")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "t")
    var isMaker interface{} = this.SafeBool(trade, "m")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(isMaker, nil)) {
        if ccxt.IsTrue(isMaker) {
            takerOrMaker = "maker"
        } else {
            takerOrMaker = "taker"
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString2(trade, "v", "T"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "side": this.SafeStringLower(trade, "S"),
        "price": this.SafeString(trade, "p"),
        "amount": this.SafeString(trade, "q"),
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "type": nil,
        "order": this.SafeString(trade, "o"),
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name hashkey#watchPositions
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *HashkeyCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6158)
        
            listenKey:= (<-this.Authenticate())
            ccxt.PanicOnError(listenKey)
            symbols = this.MarketSymbols(symbols)
            var messageHash interface{} = "positions"
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&messageHashes, messageHash)
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
                }
            }
            var url interface{} = this.GetPrivateUrl(listenKey)
        
            positions:= (<-this.WatchMultiple(url, messageHashes, nil, messageHashes))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) HandlePosition(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "outboundContractPositionInfo",
    //         "E": "1723084699801",
    //         "A": "1735619524953226496",
    //         "s": "ETHUSDT-PERPETUAL",
    //         "S": "LONG",
    //         "p": "2429.6",
    //         "P": "2",
    //         "a": "2",
    //         "f": "10760.14",
    //         "m": "1.0085",
    //         "r": "-0.0029",
    //         "up": "0.0478",
    //         "pr": "0.0492",
    //         "pv": "4.8592",
    //         "v": "5.00",
    //         "mt": "CROSS",
    //         "mm": "0.0367"
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var positions interface{} = this.Positions
    var parsed interface{} = this.ParseWsPosition(message)
    positions.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = "positions"
    client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    client.(ccxt.ClientInterface).Resolve(parsed, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
}
func  (this *HashkeyCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "s")
    market = this.SafeMarket(marketId)
    var timestamp interface{} = this.SafeInteger(position, "E")
    return this.SafePosition(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "contracts": this.SafeNumber(position, "P"),
        "contractSize": nil,
        "side": this.SafeStringLower(position, "S"),
        "notional": this.SafeNumber(position, "pv"),
        "leverage": this.SafeInteger(position, "v"),
        "unrealizedPnl": this.SafeNumber(position, "up"),
        "realizedPnl": this.SafeNumber(position, "r"),
        "collateral": nil,
        "entryPrice": this.SafeNumber(position, "p"),
        "markPrice": nil,
        "liquidationPrice": this.SafeNumber(position, "f"),
        "marginMode": this.SafeStringLower(position, "mt"),
        "hedged": true,
        "maintenanceMargin": this.SafeNumber(position, "mm"),
        "maintenanceMarginPercentage": nil,
        "initialMargin": this.SafeNumber(position, "m"),
        "initialMarginPercentage": nil,
        "marginRatio": nil,
        "lastUpdateTimestamp": nil,
        "lastPrice": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "percentage": nil,
        "info": position,
    })
}
/**
 * @method
 * @name hashkey#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://hashkeyglobal-apidoc.readme.io/reference/websocket-api#private-stream
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to watch balance for (default 'spot')
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *HashkeyCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            listenKey:= (<-this.Authenticate())
            ccxt.PanicOnError(listenKey)
        
            retRes7178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7178)
            var typeVar interface{} = "spot"
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params, typeVar)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var messageHash interface{} = ccxt.Add("balance:", typeVar)
            var url interface{} = this.GetPrivateUrl(listenKey)
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, messageHash)
            var fetchBalanceSnapshot interface{} = nil
            var awaitBalanceSnapshot interface{} = nil
            fetchBalanceSnapshotparamsVariable := this.HandleOptionAndParams(this.Options, "watchBalance", "fetchBalanceSnapshot", true)
            fetchBalanceSnapshot = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,1)
            awaitBalanceSnapshotparamsVariable := this.HandleOptionAndParams(this.Options, "watchBalance", "awaitBalanceSnapshot", false)
            awaitBalanceSnapshot = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes72912 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes72912)
            }
        
                retRes73115 :=  (<-this.Watch(url, messageHash, nil, messageHash))
                ccxt.PanicOnError(retRes73115)
                ch <- retRes73115
                return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) SetBalanceCache(client interface{}, typeVar interface{}, subscribeHash interface{})  {
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscribeHash)) {
        return
    }
    var options interface{} = this.SafeDict(this.Options, "watchBalance")
    var snapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", true)
    if ccxt.IsTrue(snapshot) {
        var messageHash interface{} = ccxt.Add(ccxt.Add(typeVar, ":"), "fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash, typeVar)
        }
    }
    ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
}
func  (this *HashkeyCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            response:= (<-this.FetchBalance(map[string]interface{} {
            "type": typeVar,
        }))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeValue(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve()
            client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add("balance:", typeVar))
                return nil
            }()
            return ch
        }
func  (this *HashkeyCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "outboundContractAccountInfo",        // event type
    //                                                    // outboundContractAccountInfo
    //         "E": "1714717314118",                      // event time
    //         "T": true,                                 // can trade
    //         "W": true,                                 // can withdraw
    //         "D": true,                                 // can deposit
    //         "B": [                                     // balances changed
    //             {
    //                 "a": "USDT",                       // asset
    //                 "f": "474960.65",                  // free amount
    //                 "l": "24835.178056020383226869",   // locked amount
    //                 "r": ""                            // to be released
    //             }
    //         ]
    //     }
    //
    var event interface{} = this.SafeString(message, "e")
    var data interface{} = this.SafeList(message, "B", []interface{}{})
    var balanceUpdate interface{} = this.SafeDict(data, 0)
    var isSpot interface{} = ccxt.IsEqual(event, "outboundAccountInfo")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar))) {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "info", message)
    var currencyId interface{} = this.SafeString(balanceUpdate, "a")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(balanceUpdate, "f"))
    ccxt.AddElementToObject(account, "used", this.SafeString(balanceUpdate, "l"))
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(ccxt.GetValue(this.Balance, typeVar)))
    var messageHash interface{} = ccxt.Add("balance:", typeVar)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), messageHash)
}
func  (this *HashkeyCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            if ccxt.IsTrue(!ccxt.IsEqual(listenKey, nil)) {
        
                ch <- listenKey
                return nil
            }
        
            response:= (<-this.PrivatePostApiV1UserDataStream(params))
            ccxt.PanicOnError(response)
            //
            //    {
            //        "listenKey": "atbNEcWnBqnmgkfmYQeTuxKTpTStlZzgoPLJsZhzAOZTbAlxbHqGNWiYaUQzMtDz"
            //    }
            //
            listenKey = this.SafeString(response, "listenKey")
            ccxt.AddElementToObject(this.Options, "listenKey", listenKey)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 3600000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, listenKey, params)
        
            ch <- listenKey
            return nil
        
            }()
            return ch
        }
func  (this *HashkeyCore) KeepAliveListenKey(listenKey interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            var request interface{} = map[string]interface{} {
                "listenKey": listenKey,
            }
            
                {
                     func(this *HashkeyCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *HashkeyCore) interface{} {
                                    // catch block:
                                            var url interface{} = this.GetPrivateUrl(listenKey)
                    var client interface{} = this.Client(url)
                    ccxt.AddElementToObject(this.Options, "listenKey", nil)
                    client.(ccxt.ClientInterface).Reject(error)
                    ccxt.Remove(this.Clients, url)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes82512 := (<-this.PrivatePutApiV1UserDataStream(this.Extend(request, params)))
                    ccxt.PanicOnError(retRes82512)
                    var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1200000)
                    this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, listenKey, params)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *HashkeyCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        message = this.SafeDict(message, 0, map[string]interface{} {})
    }
    var topic interface{} = this.SafeString2(message, "topic", "e")
    if ccxt.IsTrue(ccxt.IsEqual(topic, "kline")) {
        this.HandleOHLCV(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(topic, "realtimes")) {
        this.HandleTicker(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(topic, "trade")) {
        this.HandleTrades(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(topic, "depth")) {
        this.HandleOrderBook(client, message)
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(topic, "contractExecutionReport"))) || ccxt.IsTrue((ccxt.IsEqual(topic, "executionReport")))) {
        this.HandleOrder(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(topic, "ticketInfo")) {
        this.HandleMyTrade(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(topic, "outboundContractPositionInfo")) {
        this.HandlePosition(client, message)
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(topic, "outboundAccountInfo"))) || ccxt.IsTrue((ccxt.IsEqual(topic, "outboundContractAccountInfo")))) {
        this.HandleBalance(client, message)
    }
}


func (this *HashkeyCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
