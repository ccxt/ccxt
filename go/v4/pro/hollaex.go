package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HollaexCore struct {
	*ccxt.HollaexCore
	base *ccxt.HollaexCore
}

func NewHollaexCore() *HollaexCore {
    p := &HollaexCore{}
	base := &ccxt.HollaexCore{}
	p.base = base
	p.HollaexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *HollaexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": false,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": false,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.hollaex.com/stream",
            },
            "test": map[string]interface{} {
                "ws": "wss://api.sandbox.hollaex.com/stream",
            },
        },
        "options": map[string]interface{} {
            "watchBalance": map[string]interface{} {},
            "watchOrders": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "Bearer or HMAC authentication required": ccxt.BadSymbol,
                    "ccxt.Error: wrong input": ccxt.BadRequest,
                },
            },
        },
    })
}
/**
 * @method
 * @name hollaex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apidocs.hollaex.com/#sending-receiving-messages
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HollaexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes688 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes688)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), ccxt.GetValue(market, "id"))
        
            orderbook:= (<-this.WatchPublic(messageHash, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"orderbook",
    //         "action":"partial",
    //         "symbol":"ltc-usdt",
    //         "data":{
    //             "bids":[
    //                 [104.29, 5.2264],
    //                 [103.86,1.3629],
    //                 [101.82,0.5942]
    //             ],
    //             "asks":[
    //                 [104.81,9.5531],
    //                 [105.54,0.6416],
    //                 [106.18,1.4141],
    //             ],
    //             "timestamp":"2022-04-12T08:17:05.932Z"
    //         },
    //         "time":1649751425
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var channel interface{} = this.SafeString(message, "topic")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var data interface{} = this.SafeValue(message, "data")
    var timestamp interface{} = this.SafeString(data, "timestamp")
    var timestampMs interface{} = this.Parse8601(timestamp)
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestampMs)
    var orderbook interface{} = nil
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        orderbook = this.OrderBook(snapshot)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    } else {
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name hollaex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidocs.hollaex.com/#sending-receiving-messages
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *HollaexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1298 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1298)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), ccxt.GetValue(market, "id"))
        
            trades:= (<-this.WatchPublic(messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "trade",
    //         "action": "partial",
    //         "symbol": "btc-usdt",
    //         "data": [
    //             {
    //                 "size": 0.05145,
    //                 "price": 41977.9,
    //                 "side": "buy",
    //                 "timestamp": "2022-04-11T09:40:10.881Z"
    //             },
    //         ]
    //     }
    //
    var channel interface{} = this.SafeString(message, "topic")
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var parsedTrades interface{} = this.ParseTrades(data, market)
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(parsedTrades)); j++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsedTrades, j))
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    client.(ccxt.ClientInterface).Resolve(stored, channel)
}
/**
 * @method
 * @name hollaex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://apidocs.hollaex.com/#sending-receiving-messages
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *HollaexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1888)
            var messageHash interface{} = "usertrade"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
            }
        
            trades:= (<-this.WatchPrivate(messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleMyTrades(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    // {
    //     "topic":"usertrade",
    //     "action":"insert",
    //     "user_id":"103",
    //     "symbol":"xht-usdt",
    //     "data":[
    //        {
    //           "size":1,
    //           "side":"buy",
    //           "price":0.24,
    //           "symbol":"xht-usdt",
    //           "timestamp":"2022-05-13T09:30:15.014Z",
    //           "order_id":"6065a66e-e9a4-44a3-9726-4f8fa54b6bb6",
    //           "fee":0.001,
    //           "fee_coin":"xht",
    //           "is_same":true
    //        }
    //     ],
    //     "time":1652434215
    // }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var channel interface{} = this.SafeString(message, "topic")
    var rawTrades interface{} = this.SafeValue(message, "data")
    // usually the first message is an empty array
    // when the user does not have any trades yet
    var dataLength interface{} =     ccxt.GetArrayLength(rawTrades)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCache(limit)
    }
    var stored interface{} = this.MyTrades
    var marketIds interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var trade interface{} = ccxt.GetValue(rawTrades, i)
        var parsed interface{} = this.ParseTrade(trade)
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        var market interface{} = this.Market(symbol)
        var marketId interface{} = ccxt.GetValue(market, "id")
        ccxt.AddElementToObject(marketIds, marketId, true)
    }
    // non-symbol specific
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, channel)
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var marketId interface{} = ccxt.GetValue(keys, i)
        var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
    }
}
/**
 * @method
 * @name hollaex#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://apidocs.hollaex.com/#sending-receiving-messages
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HollaexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2718)
            var messageHash interface{} = "order"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
            }
        
            orders:= (<-this.WatchPrivate(messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleOrder(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     {
    //         "topic": "order",
    //         "action": "insert",
    //         "user_id": 155328,
    //         "symbol": "ltc-usdt",
    //         "data": {
    //             "symbol": "ltc-usdt",
    //             "side": "buy",
    //             "size": 0.05,
    //             "type": "market",
    //             "price": 0,
    //             "fee_structure": { maker: 0.1, taker: 0.1 },
    //             "fee_coin": "ltc",
    //             "id": "ce38fd48-b336-400b-812b-60c636454231",
    //             "created_by": 155328,
    //             "filled": 0.05,
    //             "method": "market",
    //             "created_at": "2022-04-11T14:09:00.760Z",
    //             "updated_at": "2022-04-11T14:09:00.760Z",
    //             "status": "filled"
    //         },
    //         "time": 1649686140
    //     }
    //
    //    {
    //        "topic":"order",
    //        "action":"partial",
    //        "user_id":155328,
    //        "data":[
    //           {
    //              "created_at":"2022-05-13T08:19:07.694Z",
    //              "fee":0,
    //              "meta":{
    //
    //              },
    //              "symbol":"ltc-usdt",
    //              "side":"buy",
    //              "size":0.1,
    //              "type":"limit",
    //              "price":55,
    //              "fee_structure":{
    //                 "maker":0.1,
    //                 "taker":0.1
    //              },
    //              "fee_coin":"ltc",
    //              "id":"d5e77182-ad4c-4ac9-8ce4-a97f9b43e33c",
    //              "created_by":155328,
    //              "filled":0,
    //              "status":"new",
    //              "updated_at":"2022-05-13T08:19:07.694Z",
    //              "stop":null
    //           }
    //        ],
    //        "time":1652430035
    //       }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var channel interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    // usually the first message is an empty array
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.Orders
    var rawOrders interface{} = nil
    if !ccxt.IsTrue(ccxt.IsArray(data)) {
        rawOrders = []interface{}{data}
    } else {
        rawOrders = data
    }
    var marketIds interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var order interface{} = ccxt.GetValue(rawOrders, i)
        var parsed interface{} = this.ParseOrder(order)
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(order, "symbol")
        var market interface{} = this.Market(symbol)
        var marketId interface{} = ccxt.GetValue(market, "id")
        ccxt.AddElementToObject(marketIds, marketId, true)
    }
    // non-symbol specific
    client.(ccxt.ClientInterface).Resolve(this.Orders, channel)
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var marketId interface{} = ccxt.GetValue(keys, i)
        var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    }
}
/**
 * @method
 * @name hollaex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apidocs.hollaex.com/#sending-receiving-messages
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *HollaexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "wallet"
        
                retRes39215 :=  (<-this.WatchPrivate(messageHash, params))
                ccxt.PanicOnError(retRes39215)
                ch <- retRes39215
                return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "wallet",
    //         "action": "partial",
    //         "user_id": 155328,
    //         "data": {
    //             "eth_balance": 0,
    //             "eth_available": 0,
    //             "usdt_balance": 18.94344188,
    //             "usdt_available": 18.94344188,
    //             "ltc_balance": 0.00005,
    //             "ltc_available": 0.00005,
    //         },
    //         "time": 1649687396
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeValue(message, "data")
    var keys interface{} = ccxt.ObjectKeys(data)
    var timestamp interface{} = this.SafeTimestamp(message, "time")
    ccxt.AddElementToObject(this.Balance, "info", data)
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        var parts interface{} = ccxt.Split(key, "_")
        var currencyId interface{} = this.SafeString(parts, 0)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
        var second interface{} = this.SafeString(parts, 1)
        var freeOrTotal interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(second, "available"))), "free", "total")
        ccxt.AddElementToObject(account, freeOrTotal, this.SafeString(data, key))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *HollaexCore) WatchPublic(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{messageHash},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes44115 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes44115)
                ch <- retRes44115
                return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) WatchPrivate(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var expires interface{} = this.SafeString(this.Options, "ws-expires")
            if ccxt.IsTrue(ccxt.IsEqual(expires, nil)) {
                var timeout interface{} = ccxt.ParseInt(ccxt.ToString((ccxt.Divide(this.Timeout, 1000))))
                expires = this.Sum(this.Seconds(), timeout)
                expires = ccxt.ToString(expires)
                // we need to memoize these values to avoid generating a new url on each method execution
                // that would trigger a new connection on each received message
                ccxt.AddElementToObject(this.Options, "ws-expires", expires)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var auth interface{} = ccxt.Add(ccxt.Add("CONNECT", "/stream"), expires)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
            var authParams interface{} = map[string]interface{} {
                "api-key": this.ApiKey,
                "api-signature": signature,
                "api-expires": expires,
            }
            var signedUrl interface{} = ccxt.Add(ccxt.Add(url, "?"), this.Urlencode(authParams))
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{messageHash},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes46915 :=  (<-this.Watch(signedUrl, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes46915)
                ch <- retRes46915
                return nil
        
            }()
            return ch
        }
func  (this *HollaexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     { error: "Bearer or HMAC authentication required" }
    //     { error: "ccxt.Error: wrong input" }
    //
    var error interface{} = this.SafeInteger(message, "error")
    
        {
             func(this *HollaexCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *HollaexCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                return false
            }
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), error, feedback)
            }
    		    return nil
    	    }(this)
        
            }
    return message
}
func  (this *HollaexCore) HandleMessage(client interface{}, message interface{})  {
    //
    // pong
    //
    //     { message: "pong" }
    //
    // trade
    //
    //     {
    //         "topic": "trade",
    //         "action": "partial",
    //         "symbol": "btc-usdt",
    //         "data": [
    //             {
    //                 "size": 0.05145,
    //                 "price": 41977.9,
    //                 "side": "buy",
    //                 "timestamp": "2022-04-11T09:40:10.881Z"
    //             },
    //         ]
    //     }
    //
    // orderbook
    //
    //     {
    //         "topic": "orderbook",
    //         "action": "partial",
    //         "symbol": "ltc-usdt",
    //         "data": {
    //             "bids": [
    //                 [104.29, 5.2264],
    //                 [103.86,1.3629],
    //                 [101.82,0.5942]
    //             ],
    //             "asks": [
    //                 [104.81,9.5531],
    //                 [105.54,0.6416],
    //                 [106.18,1.4141],
    //             ],
    //             "timestamp": "2022-04-11T10:37:01.227Z"
    //         },
    //         "time": 1649673421
    //     }
    //
    // order
    //
    //     {
    //         "topic": "order",
    //         "action": "insert",
    //         "user_id": 155328,
    //         "symbol": "ltc-usdt",
    //         "data": {
    //             "symbol": "ltc-usdt",
    //             "side": "buy",
    //             "size": 0.05,
    //             "type": "market",
    //             "price": 0,
    //             "fee_structure": { maker: 0.1, taker: 0.1 },
    //             "fee_coin": "ltc",
    //             "id": "ce38fd48-b336-400b-812b-60c636454231",
    //             "created_by": 155328,
    //             "filled": 0.05,
    //             "method": "market",
    //             "created_at": "2022-04-11T14:09:00.760Z",
    //             "updated_at": "2022-04-11T14:09:00.760Z",
    //             "status": "filled"
    //         },
    //         "time": 1649686140
    //     }
    //
    // balance
    //
    //     {
    //         "topic": "wallet",
    //         "action": "partial",
    //         "user_id": 155328,
    //         "data": {
    //             "eth_balance": 0,
    //             "eth_available": 0,
    //             "usdt_balance": 18.94344188,
    //             "usdt_available": 18.94344188,
    //             "ltc_balance": 0.00005,
    //             "ltc_available": 0.00005,
    //         }
    //     }
    //
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var content interface{} = this.SafeString(message, "message")
    if ccxt.IsTrue(ccxt.IsEqual(content, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var methods interface{} = map[string]interface{} {
        "trade": this.HandleTrades,
        "orderbook": this.HandleOrderBook,
        "order": this.HandleOrder,
        "wallet": this.HandleBalance,
        "usertrade": this.HandleMyTrades,
    }
    var topic interface{} = this.SafeValue(message, "topic")
    var method interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *HollaexCore) Ping(client interface{}) interface{}  {
    // hollaex does not support built-in ws protocol-level ping-pong
    return map[string]interface{} {
        "op": "ping",
    }
}
func  (this *HollaexCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *HollaexCore) OnError(client interface{}, error interface{})  {
    ccxt.AddElementToObject(this.Options, "ws-expires", nil)
    this.base.OnError(client, error)
}
func  (this *HollaexCore) OnClose(client interface{}, error interface{})  {
    ccxt.AddElementToObject(this.Options, "ws-expires", nil)
    this.base.OnClose(client, error)
}


func (this *HollaexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
