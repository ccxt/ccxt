package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type UpbitCore struct {
	*ccxt.UpbitCore
	base *ccxt.UpbitCore
}

func NewUpbitCore() *UpbitCore {
    p := &UpbitCore{}
	base := &ccxt.UpbitCore{}
	p.base = base
	p.UpbitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *UpbitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOHLCV": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchBalance": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://{hostname}/websocket/v1",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
        },
    })
}
func  (this *UpbitCore) WatchPublicMultiple(symbols interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes408)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), map[string]interface{} {
                "hostname": this.Hostname,
            })
            var client interface{} = this.Client(url)
            var subscriptionsKey interface{} = "upbitPublicSubscriptions"
            if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey))) {
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey, map[string]interface{} {})
            }
            var subscriptions interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey)
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                if !ccxt.IsTrue((ccxt.InOp(subscriptions, messageHash))) {
                    ccxt.AddElementToObject(subscriptions, messageHash, map[string]interface{} {
            "type": channel,
            "codes": []interface{}{marketId},
        })
                }
            }
            var finalMessage interface{} = []interface{}{map[string]interface{} {
            "ticket": this.Uuid(),
        }}
            var channelKeys interface{} = ccxt.ObjectKeys(subscriptions)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(channelKeys)); i++ {
                var key interface{} = ccxt.GetValue(channelKeys, i)
                ccxt.AppendToArray(&finalMessage, ccxt.GetValue(subscriptions, key))
            }
        
                retRes7815 :=  (<-this.WatchMultiple(url, messageHashes, finalMessage, messageHashes))
                ccxt.PanicOnError(retRes7815)
                ch <- retRes7815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://global-docs.upbit.com/reference/websocket-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *UpbitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes9115 :=  (<-this.WatchPublicMultiple([]interface{}{symbol}, "ticker"))
                ccxt.PanicOnError(retRes9115)
                ch <- retRes9115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://global-docs.upbit.com/reference/websocket-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *UpbitCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            newTickers:= (<-this.WatchPublicMultiple(symbols, "ticker"))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://global-docs.upbit.com/reference/websocket-trade
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *UpbitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes12515 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes12515)
                ch <- retRes12515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://global-docs.upbit.com/reference/websocket-trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *UpbitCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.WatchPublicMultiple(symbols, "trade"))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://global-docs.upbit.com/reference/websocket-orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *UpbitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            orderbook:= (<-this.WatchPublicMultiple([]interface{}{symbol}, "orderbook"))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchOHLCV
 * @description watches information an ccxt.OHLCV with timestamp, openingPrice, highPrice, lowPrice, tradePrice, baseVolume in 1s.
 * @see https://docs.upbit.com/kr/reference/websocket-candle for Upbit KR
 * @see https://global-docs.upbit.com/reference/websocket-candle for Upbit Global
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {string} timeframe specifies the ccxt.OHLCV candle interval to watch. As of now, Upbit only supports 1s candles.
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {ccxt.OHLCV[]} a list of [ccxt.OHLCV structures]{@link https://docs.ccxt.com/?id=ohlcv-structure}
 */
func  (this *UpbitCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1s")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(timeframe, "1s")) {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchOHLCV does not support"), timeframe), " candle.")))
            }
            var timeFrameOHLCV interface{} = ccxt.Add("candle.", timeframe)
        
                retRes18215 :=  (<-this.WatchPublicMultiple([]interface{}{symbol}, timeFrameOHLCV))
                ccxt.PanicOnError(retRes18215)
                ch <- retRes18215
                return nil
        
            }()
            return ch
        }
func  (this *UpbitCore) HandleTicker(client interface{}, message interface{})  {
    // 2020-03-17T23:07:36.511Z "onMessage" <Buffer 7b 22 74 79 70 65 22 3a 22 74 69 63 6b 65 72 22 2c 22 63 6f 64 65 22 3a 22 42 54 43 2d 45 54 48 22 2c 22 6f 70 65 6e 69 6e 67 5f 70 72 69 63 65 22 3a ... >
    // { type: "ticker",
    //   "code": "BTC-ETH",
    //   "opening_price": 0.02295092,
    //   "high_price": 0.02295092,
    //   "low_price": 0.02161249,
    //   "trade_price": 0.02161249,
    //   "prev_closing_price": 0.02185802,
    //   "acc_trade_price": 2.32732482,
    //   "change": "FALL",
    //   "change_price": 0.00024553,
    //   "signed_change_price": -0.00024553,
    //   "change_rate": 0.0112329479,
    //   "signed_change_rate": -0.0112329479,
    //   "ask_bid": "ASK",
    //   "trade_volume": 2.12,
    //   "acc_trade_volume": 106.11798418,
    //   "trade_date": "20200317",
    //   "trade_time": "215843",
    //   "trade_timestamp": 1584482323000,
    //   "acc_ask_volume": 90.16935908,
    //   "acc_bid_volume": 15.9486251,
    //   "highest_52_week_price": 0.03537414,
    //   "highest_52_week_date": "2019-04-08",
    //   "lowest_52_week_price": 0.01614901,
    //   "lowest_52_week_date": "2019-09-06",
    //   "trade_status": null,
    //   "market_state": "ACTIVE",
    //   "market_state_for_ios": null,
    //   "is_trading_suspended": false,
    //   "delisting_date": null,
    //   "market_warning": "NONE",
    //   "timestamp": 1584482323378,
    //   "acc_trade_price_24h": 2.5955306323568927,
    //   "acc_trade_volume_24h": 118.38798416,
    //   "stream_type": "SNAPSHOT" }
    var ticker interface{} = this.ParseTicker(message)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *UpbitCore) HandleOrderBook(client interface{}, message interface{})  {
    // { type: "orderbook",
    //   "code": "BTC-ETH",
    //   "timestamp": 1584486737444,
    //   "total_ask_size": 16.76384456,
    //   "total_bid_size": 168.9020623,
    //   "orderbook_units":
    //    [ { ask_price: 0.02295077,
    //        "bid_price": 0.02161249,
    //        "ask_size": 3.57100696,
    //        "bid_size": 22.5303265 },
    //      { ask_price: 0.02295078,
    //        "bid_price": 0.02152658,
    //        "ask_size": 0.52451651,
    //        "bid_size": 2.30355128 },
    //      { ask_price: 0.02295086,
    //        "bid_price": 0.02150802,
    //        "ask_size": 1.585,
    //        "bid_size": 5 }, ... ],
    //   "stream_type": "SNAPSHOT" }
    var marketId interface{} = this.SafeString(message, "code")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var typeVar interface{} = this.SafeString(message, "stream_type")
    var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
    var limit interface{} = this.SafeInteger(options, "limit", 15)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "SNAPSHOT")) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    // upbit always returns a snapshot of 15 topmost entries
    // the "REALTIME" deltas are not incremental
    // therefore we reset the orderbook on each update
    // and reinitialize it again with new bidasks
    orderbook.(ccxt.OrderBookInterface).Reset(map[string]interface{} {})
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    var bids interface{} = ccxt.GetValue(orderbook, "bids")
    var asks interface{} = ccxt.GetValue(orderbook, "asks")
    var data interface{} = this.SafeValue(message, "orderbook_units", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var entry interface{} = ccxt.GetValue(data, i)
        var ask_price interface{} = this.SafeFloat(entry, "ask_price")
        var ask_size interface{} = this.SafeFloat(entry, "ask_size")
        var bid_price interface{} = this.SafeFloat(entry, "bid_price")
        var bid_size interface{} = this.SafeFloat(entry, "bid_size")
        asks.(ccxt.IOrderBookSide).Store(ask_price, ask_size)
        bids.(ccxt.IOrderBookSide).Store(bid_price, bid_size)
    }
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    var datetime interface{} = this.Iso8601(timestamp)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", datetime)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *UpbitCore) HandleTrades(client interface{}, message interface{})  {
    // { type: "trade",
    //   "code": "KRW-BTC",
    //   "timestamp": 1584508285812,
    //   "trade_date": "2020-03-18",
    //   "trade_time": "05:11:25",
    //   "trade_timestamp": 1584508285000,
    //   "trade_price": 6747000,
    //   "trade_volume": 0.06499468,
    //   "ask_bid": "ASK",
    //   "prev_closing_price": 6774000,
    //   "change": "FALL",
    //   "change_price": 27000,
    //   "sequential_id": 1584508285000002,
    //   "stream_type": "REALTIME" }
    var trade interface{} = this.ParseTrade(message)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *UpbitCore) HandleOHLCV(client interface{}, message interface{})  {
    // {
    //     type: 'candle.1s',
    //     code: 'KRW-USDT',
    //     candle_date_time_utc: '2025-04-22T09:50:34',
    //     candle_date_time_kst: '2025-04-22T18:50:34',
    //     opening_price: 1438,
    //     high_price: 1438,
    //     low_price: 1438,
    //     trade_price: 1438,
    //     candle_acc_trade_volume: 1145.8935,
    //     candle_acc_trade_price: 1647794.853,
    //     timestamp: 1745315434125,
    //     stream_type: 'REALTIME'
    //   }
    var marketId interface{} = this.SafeString(message, "code")
    var symbol interface{} = this.SafeSymbol(marketId, nil)
    var messageHash interface{} = ccxt.Add("candle.1s:", symbol)
    var ohlcv interface{} = this.ParseOHLCV(message)
    client.(ccxt.ClientInterface).Resolve(ohlcv, messageHash)
}
func  (this *UpbitCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var wsOptions interface{} = this.SafeDict(this.Options, "ws", map[string]interface{} {})
            var authenticated interface{} = this.SafeString(wsOptions, "token")
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var auth interface{} = map[string]interface{} {
                    "access_key": this.ApiKey,
                    "nonce": this.Uuid(),
                }
                var token interface{} = ccxt.Jwt(auth, this.Encode(this.Secret), ccxt.Sha256, false)
                ccxt.AddElementToObject(wsOptions, "token", token)
                ccxt.AddElementToObject(wsOptions, "options", map[string]interface{} {
            "headers": map[string]interface{} {
                "authorization": ccxt.Add("Bearer ", token),
            },
        })
                ccxt.AddElementToObject(this.Options, "ws", wsOptions)
            }
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/private")
            var client interface{} = this.Client(url)
        
            ch <- client
            return nil
        
            }()
            return ch
        }
func  (this *UpbitCore) WatchPrivate(symbol interface{}, channel interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3588 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes3588)
            var request interface{} = map[string]interface{} {
                "type": channel,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        
                retRes36312 := (<-this.LoadMarkets())
                ccxt.PanicOnError(retRes36312)
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                var symbols interface{} = []interface{}{symbol}
                var marketIds interface{} = this.MarketIds(symbols)
                ccxt.AddElementToObject(request, "codes", marketIds)
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), map[string]interface{} {
                "hostname": this.Hostname,
            })
            url = ccxt.Add(url, "/private")
            var client interface{} = this.Client(url)
            // Track private channel subscriptions to support multiple concurrent watches
            var subscriptionsKey interface{} = "upbitPrivateSubscriptions"
            if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey))) {
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey, map[string]interface{} {})
            }
            var channelKey interface{} = channel
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                channelKey = ccxt.Add(ccxt.Add(channel, ":"), symbol)
            }
            var subscriptions interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionsKey)
            var isNewChannel interface{} =     !ccxt.IsTrue((ccxt.InOp(subscriptions, channelKey)))
            if ccxt.IsTrue(isNewChannel) {
                ccxt.AddElementToObject(subscriptions, channelKey, request)
            }
            // Build subscription message with all requested private channels
            // Format: [{'ticket': uuid}, {'type': 'myOrder'}, {'type': 'myAsset'}, ...]
            var requests interface{} = []interface{}{}
            var channelKeys interface{} = ccxt.ObjectKeys(subscriptions)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(channelKeys)); i++ {
                ccxt.AppendToArray(&requests, ccxt.GetValue(subscriptions, ccxt.GetValue(channelKeys, i)))
            }
            var message interface{} = []interface{}{map[string]interface{} {
            "ticket": this.Uuid(),
        }}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(requests)); i++ {
                ccxt.AppendToArray(&message, ccxt.GetValue(requests, i))
            }
        
                retRes40515 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes40515)
                ch <- retRes40515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://global-docs.upbit.com/reference/websocket-myorder
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *UpbitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4208)
            var channel interface{} = "myOrder"
            var messageHash interface{} = "myOrder"
        
            orders:= (<-this.WatchPrivate(symbol, channel, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://global-docs.upbit.com/reference/websocket-myorder
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *UpbitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4428)
            var channel interface{} = "myOrder"
            var messageHash interface{} = "myTrades"
        
            trades:= (<-this.WatchPrivate(symbol, channel, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *UpbitCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "wait": "open",
        "done": "closed",
        "cancel": "canceled",
        "watch": "open",
        "trade": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *UpbitCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "type": "myOrder",
    //     "code": "SGD-XRP",
    //     "uuid": "ac2dc2a3-fce9-40a2-a4f6-5987c25c438f",
    //     "ask_bid": "BID",
    //     "order_type": "limit",
    //     "state": "trade",
    //     "price": 0.001453,
    //     "avg_price": 0.00145372,
    //     "volume": 30925891.29839369,
    //     "remaining_volume": 29968038.09235948,
    //     "executed_volume": 30925891.29839369,
    //     "trades_count": 1,
    //     "reserved_fee": 44.23943970238218,
    //     "remaining_fee": 21.77177967409916,
    //     "paid_fee": 22.467660028283017,
    //     "locked": 43565.33112787242,
    //     "executed_funds": 44935.32005656603,
    //     "order_timestamp": 1710751590000,
    //     "timestamp": 1710751597500,
    //     "stream_type": "REALTIME"
    // }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "uuid")
    var side interface{} = this.SafeStringLower(order, "ask_bid")
    if ccxt.IsTrue(ccxt.IsEqual(side, "bid")) {
        side = "buy"
    } else {
        side = "sell"
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "order_timestamp"))
    var status interface{} = this.ParseWsOrderStatus(this.SafeString(order, "state"))
    var marketId interface{} = this.SafeString(order, "code")
    market = this.SafeMarket(marketId, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "paid_fee")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": ccxt.GetValue(market, "quote"),
            "cost": feeCost,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeString(order, "trade_timestamp"),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": this.SafeString(order, "order_type"),
        "timeInForce": this.SafeString(order, "time_in_force"),
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "price"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "cost": this.SafeString(order, "executed_funds"),
        "average": this.SafeString(order, "avg_price"),
        "amount": this.SafeString(order, "volume"),
        "filled": this.SafeString(order, "executed_volume"),
        "remaining": this.SafeString(order, "remaining_volume"),
        "status": status,
        "fee": fee,
        "trades": nil,
    })
}
func  (this *UpbitCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // see: parseWsOrder
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeStringLower(trade, "ask_bid")
    if ccxt.IsTrue(ccxt.IsEqual(side, "bid")) {
        side = "buy"
    } else {
        side = "sell"
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "trade_timestamp"))
    var marketId interface{} = this.SafeString(trade, "code")
    market = this.SafeMarket(marketId, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "paid_fee")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": ccxt.GetValue(market, "quote"),
            "cost": feeCost,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "trade_uuid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "side": side,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "volume"),
        "cost": this.SafeString(trade, "executed_funds"),
        "order": this.SafeString(trade, "uuid"),
        "takerOrMaker": nil,
        "type": this.SafeString(trade, "order_type"),
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *UpbitCore) HandleMyOrder(client interface{}, message interface{})  {
    // see: parseWsOrder
    var tradeId interface{} = this.SafeString(message, "trade_uuid")
    if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
        this.HandleMyTrade(client, message)
    }
    this.HandleOrder(client, message)
}
func  (this *UpbitCore) HandleMyTrade(client interface{}, message interface{})  {
    // see: parseWsOrder
    var myTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(myTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trade interface{} = this.ParseWsTrade(message)
    myTrades.(ccxt.Appender).Append(trade)
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
    messageHash = ccxt.Add("myTrades:", ccxt.GetValue(trade, "symbol"))
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
}
func  (this *UpbitCore) HandleOrder(client interface{}, message interface{})  {
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedOrders interface{} = this.Orders
    var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
    var order interface{} = this.SafeValue(orders, orderId)
    if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
        var fee interface{} = this.SafeValue(order, "fee")
        if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
            ccxt.AddElementToObject(parsed, "fee", fee)
        }
        var fees interface{} = this.SafeValue(order, "fees")
        if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
            ccxt.AddElementToObject(parsed, "fees", fees)
        }
        ccxt.AddElementToObject(parsed, "trades", this.SafeValue(order, "trades"))
        ccxt.AddElementToObject(parsed, "timestamp", this.SafeInteger(order, "timestamp"))
        ccxt.AddElementToObject(parsed, "datetime", this.SafeString(order, "datetime"))
    }
    cachedOrders.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = "myOrder"
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
/**
 * @method
 * @name upbit#watchBalance
 * @see https://global-docs.upbit.com/reference/websocket-myasset
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *UpbitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6338 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6338)
            var channel interface{} = "myAsset"
            var messageHash interface{} = "myAsset"
        
                retRes63615 :=  (<-this.WatchPrivate(nil, channel, messageHash))
                ccxt.PanicOnError(retRes63615)
                ch <- retRes63615
                return nil
        
            }()
            return ch
        }
func  (this *UpbitCore) HandleBalance(client interface{}, message interface{})  {
    //
    // {
    //     "type": "myAsset",
    //     "asset_uuid": "e635f223-1609-4969-8fb6-4376937baad6",
    //     "assets": [
    //       {
    //         "currency": "SGD",
    //         "balance": 1386929.37231066771348207123,
    //         "locked": 10329.670127489597585685
    //       }
    //     ],
    //     "asset_timestamp": 1710146517259,
    //     "timestamp": 1710146517267,
    //     "stream_type": "REALTIME"
    // }
    //
    var data interface{} = this.SafeList(message, "assets", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var balance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var available interface{} = this.SafeString(balance, "balance")
        var frozen interface{} = this.SafeString(balance, "locked")
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", available)
        ccxt.AddElementToObject(account, "used", frozen)
        ccxt.AddElementToObject(this.Balance, code, account)
        this.Balance = this.SafeBalance(this.Balance)
    }
    var messageHash interface{} = this.SafeString(message, "type")
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *UpbitCore) HandleMessage(client interface{}, message interface{})  {
    var methods interface{} = map[string]interface{} {
        "ticker": this.HandleTicker,
        "orderbook": this.HandleOrderBook,
        "trade": this.HandleTrades,
        "myOrder": this.HandleMyOrder,
        "myAsset": this.HandleBalance,
        "candle.1s": this.HandleOHLCV,
    }
    var methodName interface{} = this.SafeString(message, "type")
    var method interface{} = this.SafeValue(methods, methodName)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *UpbitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
