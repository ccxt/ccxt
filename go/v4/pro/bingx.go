package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BingxCore struct {
	*ccxt.BingxCore
	base *ccxt.BingxCore
}

func NewBingxCore() *BingxCore {
    p := &BingxCore{}
	base := &ccxt.BingxCore{}
	p.base = base
	p.BingxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BingxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchBalance": true,
            "unWatchOHLCV": true,
            "unWatchOrderBook": true,
            "unWatchTicker": true,
            "unWatchTrades": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://open-api-ws.bingx.com/market",
                    "linear": "wss://open-api-swap.bingx.com/swap-market",
                    "inverse": "wss://open-api-cswap-ws.bingx.com/market",
                },
            },
        },
        "options": map[string]interface{} {
            "listenKeyRefreshRate": 3540000,
            "ws": map[string]interface{} {
                "gunzip": true,
            },
            "swap": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "1h",
                    "2h": "2h",
                    "4h": "4h",
                    "6h": "6h",
                    "12h": "12h",
                    "1d": "1d",
                    "3d": "3d",
                    "1w": "1w",
                    "1M": "1M",
                },
            },
            "spot": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1min",
                    "5m": "5min",
                    "15m": "15min",
                    "30m": "30min",
                    "1h": "60min",
                    "1d": "1day",
                },
            },
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": true,
                "awaitBalanceSnapshot": false,
            },
            "watchOrderBook": map[string]interface{} {
                "depth": 100,
            },
            "watchTrades": map[string]interface{} {
                "ignoreDuplicates": true,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 1800000,
        },
    })
}
func  (this *BingxCore) UnWatch(messageHash interface{}, subMessageHash interface{}, subscribeHash interface{}, dataType interface{}, topic interface{}, market interface{}, methodName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var marketType interface{} = nil
            var subType interface{} = nil
            var url interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams(methodName, market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType)
            }
            var id interface{} = this.Uuid()
            var request interface{} = map[string]interface{} {
                "id": id,
                "dataType": dataType,
                "reqType": "unsub",
            }
            var symbols interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                ccxt.AppendToArray(&symbols, ccxt.GetValue(market, "symbol"))
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": id,
                "subMessageHashes": []interface{}{subMessageHash},
                "messageHashes": []interface{}{messageHash},
                "symbols": symbols,
                "topic": topic,
            }
            var symbolsAndTimeframes interface{} = this.SafeList(params, "symbolsAndTimeframes")
            if ccxt.IsTrue(!ccxt.IsEqual(symbolsAndTimeframes, nil)) {
                ccxt.AddElementToObject(subscription, "symbolsAndTimeframes", symbolsAndTimeframes)
                params = this.Omit(params, "symbolsAndTimeframes")
            }
        
                retRes12615 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), subscribeHash, subscription))
                ccxt.PanicOnError(retRes12615)
                ch <- retRes12615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20to%2024-hour%20Price%20Change
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20to%2024-hour%20price%20changes
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%2024-Hour%20Price%20Change
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BingxCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1418)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = nil
            var subType interface{} = nil
            var url interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchTicker", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchTicker", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType)
            }
            var dataType interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@ticker")
            var messageHash interface{} = this.GetMessageHash("ticker", ccxt.GetValue(market, "symbol"))
            var uuid interface{} = this.Uuid()
            var request interface{} = map[string]interface{} {
                "id": uuid,
                "dataType": dataType,
            }
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                ccxt.AddElementToObject(request, "reqType", "sub")
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": false,
                "id": uuid,
            }
        
                retRes16715 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes16715)
                ch <- retRes16715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20to%2024-hour%20Price%20Change
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20to%2024-hour%20price%20changes
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%2024-Hour%20Price%20Change
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BingxCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1828)
            var market interface{} = this.Market(symbol)
            var dataType interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@ticker")
            var subMessageHash interface{} = this.GetMessageHash("ticker", ccxt.GetValue(market, "symbol"))
            var messageHash interface{} = ccxt.Add("unsubscribe::", subMessageHash)
            var topic interface{} = "ticker"
            var methodName interface{} = "unWatchTicker"
        
                retRes18915 :=  (<-this.UnWatch(messageHash, subMessageHash, messageHash, dataType, topic, market, methodName, params))
                ccxt.PanicOnError(retRes18915)
                ch <- retRes18915
                return nil
        
            }()
            return ch
        }
func  (this *BingxCore) HandleTicker(client interface{}, message interface{})  {
    //
    // swap
    //
    //     {
    //         "code": 0,
    //         "dataType": "BTC-USDT@ticker",
    //         "data": {
    //             "e": "24hTicker",
    //             "E": 1706498923556,
    //             "s": "BTC-USDT",
    //             "p": "346.4",
    //             "P": "0.82",
    //             "c": "42432.5",
    //             "L": "0.0529",
    //             "h": "42855.4",
    //             "l": "41578.3",
    //             "v": "64310.9754",
    //             "q": "2728360284.15",
    //             "o": "42086.1",
    //             "O": 1706498922655,
    //             "C": 1706498883023,
    //             "A": "42437.8",
    //             "a": "1.4160",
    //             "B": "42437.1",
    //             "b": "2.5747"
    //         }
    //     }
    //
    // spot
    //
    //     {
    //         "code": 0,
    //         "timestamp": 1706506795473,
    //         "data": {
    //             "e": "24hTicker",
    //             "E": 1706506795472,
    //             "s": "BTC-USDT",
    //             "p": -372.12,
    //             "P": "-0.87%",
    //             "o": 42548.95,
    //             "h": 42696.1,
    //             "l": 41621.29,
    //             "c": 42176.83,
    //             "v": 4943.33,
    //             "q": 208842236.5,
    //             "O": 1706420395472,
    //             "C": 1706506795472,
    //             "A": 42177.23,
    //             "a": 5.14484,
    //             "B": 42176.38,
    //             "b": 5.36117
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    // const marketId = messageHash.split('@')[0]
    var isSwap interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "swap"), 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSwap), "swap", "spot")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ticker interface{} = this.ParseWsTicker(data, market)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, this.GetMessageHash("ticker", symbol))
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeString(message, "dataType"), "all@ticker")) {
        client.(ccxt.ClientInterface).Resolve(ticker, this.GetMessageHash("ticker"))
    }
}
func  (this *BingxCore) ParseWsTicker(message interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "e": "24hTicker",
    //         "E": 1706498923556,
    //         "s": "BTC-USDT",
    //         "p": "346.4",
    //         "P": "0.82",
    //         "c": "42432.5",
    //         "L": "0.0529",
    //         "h": "42855.4",
    //         "l": "41578.3",
    //         "v": "64310.9754",
    //         "q": "2728360284.15",
    //         "o": "42086.1",
    //         "O": 1706498922655,
    //         "C": 1706498883023,
    //         "A": "42437.8",
    //         "a": "1.4160",
    //         "B": "42437.1",
    //         "b": "2.5747"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(message, "C")
    var marketId interface{} = this.SafeString(message, "s")
    market = this.SafeMarket(marketId, market)
    var close interface{} = this.SafeString(message, "c")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(message, "h"),
        "low": this.SafeString(message, "l"),
        "bid": this.SafeString(message, "B"),
        "bidVolume": this.SafeString(message, "b"),
        "ask": this.SafeString(message, "A"),
        "askVolume": this.SafeString(message, "a"),
        "vwap": nil,
        "open": this.SafeString(message, "o"),
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": this.SafeString(message, "p"),
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(message, "v"),
        "quoteVolume": this.SafeString(message, "q"),
        "info": message,
    }, market)
}
func  (this *BingxCore) GetOrderBookLimitByMarketType(marketType interface{}, optionalArgs ...interface{}) interface{}  {
    limit := ccxt.GetArg(optionalArgs, 0, nil)
    _ = limit
    if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
        limit = 100
    } else {
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) || ccxt.IsTrue(ccxt.IsEqual(marketType, "future"))) {
            limit = this.FindNearestCeiling([]interface{}{5, 10, 20, 50, 100}, limit)
        } else if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
            limit = this.FindNearestCeiling([]interface{}{20, 100}, limit)
        }
    }
    return limit
}
func  (this *BingxCore) GetMessageHash(unifiedChannel interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbol
    extra := ccxt.GetArg(optionalArgs, 1, nil)
    _ = extra
    var hash interface{} = unifiedChannel
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        hash = ccxt.Add(hash, ccxt.Add("::", symbol))
    } else {
        hash = ccxt.Add(hash, "s") // tickers, orderbooks, ohlcvs ...
    }
    if ccxt.IsTrue(!ccxt.IsEqual(extra, nil)) {
        hash = ccxt.Add(hash, ccxt.Add("::", extra))
    }
    return hash
}
/**
 * @method
 * @name bingx#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscription%20transaction%20by%20transaction
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20the%20Latest%20Trade%20Detail
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscription%20transaction%20by%20transaction
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BingxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3538)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketType interface{} = nil
            var subType interface{} = nil
            var url interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchTrades", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchTrades", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType)
            }
            var rawHash interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@trade")
            var messageHash interface{} = ccxt.Add("trade::", symbol)
            var uuid interface{} = this.Uuid()
            var request interface{} = map[string]interface{} {
                "id": uuid,
                "dataType": rawHash,
            }
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                ccxt.AddElementToObject(request, "reqType", "sub")
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": false,
                "id": uuid,
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
            var result interface{} = this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            if ccxt.IsTrue(this.HandleOption("watchTrades", "ignoreDuplicates", true)) {
                var filtered interface{} = this.RemoveRepeatedTradesFromArray(result)
                filtered = this.SortBy(filtered, "timestamp")
        
                ch <- filtered
                return nil
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#unWatchTrades
 * @description unsubscribes from the trades channel
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscription%20transaction%20by%20transaction
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20the%20Latest%20Trade%20Detail
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscription%20transaction%20by%20transaction
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BingxCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4068)
            var market interface{} = this.Market(symbol)
            var dataType interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@trade")
            var subMessageHash interface{} = this.GetMessageHash("trade", ccxt.GetValue(market, "symbol"))
            var messageHash interface{} = ccxt.Add("unsubscribe::", subMessageHash)
            var topic interface{} = "trades"
            var methodName interface{} = "unWatchTrades"
        
                retRes41315 :=  (<-this.UnWatch(messageHash, subMessageHash, messageHash, dataType, topic, market, methodName, params))
                ccxt.PanicOnError(retRes41315)
                ch <- retRes41315
                return nil
        
            }()
            return ch
        }
func  (this *BingxCore) HandleTrades(client interface{}, message interface{})  {
    //
    // spot: first snapshot
    //
    //    {
    //      "id": "d83b78ce-98be-4dc2-b847-12fe471b5bc5",
    //      "code": 0,
    //      "msg": "SUCCESS",
    //      "timestamp": 1690214699854
    //    }
    //
    // spot: subsequent updates
    //
    //     {
    //         "code": 0,
    //         "data": {
    //           "E": 1690214529432,
    //           "T": 1690214529386,
    //           "e": "trade",
    //           "m": true,
    //           "p": "29110.19",
    //           "q": "0.1868",
    //           "s": "BTC-USDT",
    //           "t": "57903921"
    //         },
    //         "dataType": "BTC-USDT@trade",
    //         "success": true
    //     }
    //
    // linear swap: first snapshot
    //
    //    {
    //        "id": "2aed93b1-6e1e-4038-aeba-f5eeaec2ca48",
    //        "code": 0,
    //        "msg": '',
    //        "dataType": '',
    //        "data": null
    //    }
    //
    // linear swap: subsequent updates
    //
    //    {
    //        "code": 0,
    //        "dataType": "BTC-USDT@trade",
    //        "data": [
    //            {
    //                "q": "0.0421",
    //                "p": "29023.5",
    //                "T": 1690221401344,
    //                "m": false,
    //                "s": "BTC-USDT"
    //            },
    //            ...
    //        ]
    //    }
    //
    // inverse swap: first snapshot
    //
    //     {
    //         "code": 0,
    //         "id": "a2e482ca-f71b-42f8-a83a-8ff85a713e64",
    //         "msg": "SUCCESS",
    //         "timestamp": 1722920589426
    //     }
    //
    // inverse swap: subsequent updates
    //
    //     {
    //         "code": 0,
    //         "dataType": "BTC-USD@trade",
    //         "data": {
    //             "e": "trade",
    //             "E": 1722920589665,
    //             "s": "BTC-USD",
    //             "t": "39125001",
    //             "p": "55360.0",
    //             "q": "1",
    //             "T": 1722920589582,
    //             "m": false
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var rawHash interface{} = this.SafeString(message, "dataType")
    var marketId interface{} = ccxt.GetValue(ccxt.Split(rawHash, "@"), 0)
    var isSwap interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "swap"), 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSwap), "swap", "spot")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trade::", symbol)
    var trades interface{} = nil
    if ccxt.IsTrue(ccxt.IsArray(data)) {
        trades = this.ParseTrades(data, market)
    } else {
        trades = []interface{}{this.ParseTrade(data, market)}
    }
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(trades, j))
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name bingx#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20Market%20Depth%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20Market%20Depth%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Limited%20Depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BingxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5378)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = nil
            var subType interface{} = nil
            var url interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchOrderBook", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchOrderBook", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType)
            }
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeInteger(options, "depth", 100)
            var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), "depth"), this.NumberToString(depth))
            var messageHash interface{} = this.GetMessageHash("orderbook", ccxt.GetValue(market, "symbol"))
            var uuid interface{} = this.Uuid()
            var request interface{} = map[string]interface{} {
                "id": uuid,
                "dataType": subscriptionHash,
            }
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                ccxt.AddElementToObject(request, "reqType", "sub")
            }
            var subscriptionArgs interface{} = map[string]interface{} {}
            if ccxt.IsTrue(ccxt.GetValue(market, "inverse")) {
                subscriptionArgs = map[string]interface{} {
                    "id": uuid,
                    "unsubscribe": false,
                    "count": limit,
                    "params": params,
                }
            } else {
                subscriptionArgs = map[string]interface{} {
                    "id": uuid,
                    "unsubscribe": false,
                    "level": limit,
                    "params": params,
                }
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), subscriptionHash, subscriptionArgs))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#Subscribe%20Market%20Depth%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20Market%20Depth%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Limited%20Depth
 * @param {string} symbol unified symbol of the market
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BingxCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5938)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeInteger(options, "depth", 100)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), "depth"), this.NumberToString(depth))
            var messageHash interface{} = ccxt.Add("unsubscribe::", subMessageHash)
            var topic interface{} = "orderbook"
            var methodName interface{} = "unWatchOrderBook"
        
                retRes60115 :=  (<-this.UnWatch(messageHash, subMessageHash, messageHash, subMessageHash, topic, market, methodName, params))
                ccxt.PanicOnError(retRes60115)
                ch <- retRes60115
                return nil
        
            }()
            return ch
        }
func  (this *BingxCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat2(delta, 0, "p")
    var amount interface{} = this.SafeFloat2(delta, 1, "a")
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BingxCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "code":0,
    //         "data":
    //         {
    //             "asks":[
    //                 ["84119.73","0.000011"],
    //                 ["84116.52","0.000014"],
    //                 ["84116.40","0.000039"]
    //             ],
    //             "bids":[
    //                 ["83656.98","2.570805"],
    //                 ["83655.51","0.000347"],
    //                 ["83654.59","0.000082"]
    //             ],
    //             "lastUpdateId":13565694850
    //         },
    //         "dataType":"BTC-USDT@depth100",
    //         "success":true,
    //         "timestamp":1743241379958
    //     }
    //
    // linear swap
    //
    //     {
    //         "code":0,
    //         "dataType":"BTC-USDT@depth100@500ms",
    //         "ts":1743241563651,
    //         "data":
    //         {
    //             "bids":[
    //                 ["83363.2","0.1908"],
    //                 ["83360.0","0.0003"],
    //                 ["83356.5","0.0245"],
    //             ],
    //             "asks":[
    //                 ["83495.0","0.0024"],
    //                 ["83490.0","0.0001"],
    //                 ["83488.0","0.0004"],
    //             ]
    //         }
    //     }
    //
    // inverse swap
    //
    //     {
    //         "code":0,
    //         "dataType":"BTC-USD@depth100",
    //         "data":{
    //             "symbol":"BTC-USD",
    //             "bids":[
    //                 {"p":"83411.2","a":"2.979216","v":"2485.0"},
    //                 {"p":"83411.1","a":"1.592114","v":"1328.0"},
    //                 {"p":"83410.8","a":"2.656730","v":"2216.0"},
    //             ],
    //             "asks":[
    //                 {"p":"88200.0","a":"0.344671","v":"304.0"},
    //                 {"p":"88023.8","a":"0.045442","v":"40.0"},
    //                 {"p":"88001.0","a":"0.003409","v":"3.0"},
    //             ],
    //             "aggPrecision":"0.1",
    //             "timestamp":1743242290710
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var dataType interface{} = this.SafeString(message, "dataType")
    var parts interface{} = ccxt.Split(dataType, "@")
    var firstPart interface{} = ccxt.GetValue(parts, 0)
    var isAllEndpoint interface{} =     (ccxt.IsEqual(firstPart, "all"))
    var marketId interface{} = this.SafeString(data, "symbol", firstPart)
    var isSwap interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "swap"), 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSwap), "swap", "spot")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        // const limit = [ 5, 10, 20, 50, 100 ]
        var subscriptionHash interface{} = dataType
        var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
        var limit interface{} = this.SafeInteger(subscription, "limit")
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    orderbook = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = nil
    var timestamp interface{} = this.SafeInteger2(message, "timestamp", "ts")
    timestamp = this.SafeInteger2(data, "timestamp", "ts", timestamp)
    if ccxt.IsTrue(ccxt.GetValue(market, "inverse")) {
        snapshot = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "p", "a")
    } else {
        snapshot = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", 0, 1)
    }
    var nonce interface{} = this.SafeInteger(data, "lastUpdateId")
    ccxt.AddElementToObject(snapshot, "nonce", nonce)
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = this.GetMessageHash("orderbook", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    // resolve for "all"
    if ccxt.IsTrue(isAllEndpoint) {
        var messageHashForAll interface{} = this.GetMessageHash("orderbook")
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHashForAll)
    }
}
func  (this *BingxCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "c": "28909.0",
    //        "o": "28915.4",
    //        "h": "28915.4",
    //        "l": "28896.1",
    //        "v": "27.6919",
    //        "T": 1696687499999,
    //        "t": 1696687440000
    //    }
    //
    // for spot, opening-time (t) is used instead of closing-time (T), to be compatible with fetchOHLCV
    // for linear swap, (T) is the opening time
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.GetValue(market, "spot"))), "t", "T")
    if ccxt.IsTrue(ccxt.GetValue(market, "swap")) {
        timestamp = ccxt.Ternary(ccxt.IsTrue((ccxt.GetValue(market, "inverse"))), "t", "T")
    }
    return []interface{}{this.SafeInteger(ohlcv, timestamp), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
func  (this *BingxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // spot:
    //
    //   {
    //       "code": 0,
    //       "data": {
    //         "E": 1696687498608,
    //         "K": {
    //           "T": 1696687499999,
    //           "c": "27917.829",
    //           "h": "27918.427",
    //           "i": "1min",
    //           "l": "27917.7",
    //           "n": 262,
    //           "o": "27917.91",
    //           "q": "25715.359197",
    //           "s": "BTC-USDT",
    //           "t": 1696687440000,
    //           "v": "0.921100"
    //         },
    //         "e": "kline",
    //         "s": "BTC-USDT"
    //       },
    //       "dataType": "BTC-USDT@kline_1min",
    //       "success": true
    //   }
    //
    // linear swap:
    //
    //    {
    //        "code": 0,
    //        "dataType": "BTC-USDT@kline_1m",
    //        "s": "BTC-USDT",
    //        "data": [
    //            {
    //            "c": "28909.0",
    //            "o": "28915.4",
    //            "h": "28915.4",
    //            "l": "28896.1",
    //            "v": "27.6919",
    //            "T": 1690907580000
    //            }
    //        ]
    //    }
    //
    // inverse swap:
    //
    //     {
    //         "code": 0,
    //         "timestamp": 1723769354547,
    //         "dataType": "BTC-USD@kline_1m",
    //         "data": {
    //             "t": 1723769340000,
    //             "o": 57485.1,
    //             "c": 57468,
    //             "l": 57464.9,
    //             "h": 57485.1,
    //             "a": 0.189663,
    //             "v": 109,
    //             "u": 92,
    //             "s": "BTC-USD"
    //         }
    //     }
    //
    var isSwap interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "swap"), 0)
    var dataType interface{} = this.SafeString(message, "dataType")
    var parts interface{} = ccxt.Split(dataType, "@")
    var firstPart interface{} = ccxt.GetValue(parts, 0)
    var isAllEndpoint interface{} =     (ccxt.IsEqual(firstPart, "all"))
    var marketId interface{} = this.SafeString(message, "s", firstPart)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSwap), "swap", "spot")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var candles interface{} = nil
    if ccxt.IsTrue(isSwap) {
        if ccxt.IsTrue(ccxt.GetValue(market, "inverse")) {
            candles = []interface{}{this.SafeDict(message, "data", map[string]interface{} {})}
        } else {
            candles = this.SafeList(message, "data", []interface{}{})
        }
    } else {
        var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        candles = []interface{}{this.SafeDict(data, "K", map[string]interface{} {})}
    }
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var rawTimeframe interface{} = ccxt.GetValue(ccxt.Split(dataType, "_"), 1)
    var marketOptions interface{} = this.SafeDict(this.Options, marketType)
    var timeframes interface{} = this.SafeDict(marketOptions, "timeframes", map[string]interface{} {})
    var unifiedTimeframe interface{} = this.FindTimeframe(rawTimeframe, timeframes)
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), rawTimeframe), nil)) {
        var subscriptionHash interface{} = dataType
        var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
        var limit interface{} = this.SafeInteger(subscription, "limit")
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(candles)); i++ {
        var candle interface{} = ccxt.GetValue(candles, i)
        var parsed interface{} = this.ParseWsOHLCV(candle, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var resolveData interface{} = []interface{}{symbol, unifiedTimeframe, stored}
    var messageHash interface{} = this.GetMessageHash("ohlcv", symbol, unifiedTimeframe)
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
    // resolve for "all"
    if ccxt.IsTrue(isAllEndpoint) {
        var messageHashForAll interface{} = this.GetMessageHash("ohlcv", nil, unifiedTimeframe)
        client.(ccxt.ClientInterface).Resolve(resolveData, messageHashForAll)
    }
}
/**
 * @method
 * @name bingx#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#K-line%20Streams
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20K-Line%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Latest%20Trading%20Pair%20K-Line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BingxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8728)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = nil
            var subType interface{} = nil
            var url interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchOHLCV", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchOHLCV", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                url = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType)
            }
            if ccxt.IsTrue(ccxt.IsEqual(url, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchOHLCV is not supported for "), marketType), " markets.")))
            }
            var options interface{} = this.SafeValue(this.Options, marketType, map[string]interface{} {})
            var timeframes interface{} = this.SafeValue(options, "timeframes", map[string]interface{} {})
            var rawTimeframe interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var messageHash interface{} = this.GetMessageHash("ohlcv", ccxt.GetValue(market, "symbol"), timeframe)
            var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@kline_"), rawTimeframe)
            var uuid interface{} = this.Uuid()
            var request interface{} = map[string]interface{} {
                "id": uuid,
                "dataType": subscriptionHash,
            }
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
                ccxt.AddElementToObject(request, "reqType", "sub")
            }
            var subscriptionArgs interface{} = map[string]interface{} {
                "id": uuid,
                "unsubscribe": false,
                "interval": rawTimeframe,
                "params": params,
            }
        
            result:= (<-this.Watch(url, messageHash, this.Extend(request, params), subscriptionHash, subscriptionArgs))
            ccxt.PanicOnError(result)
            var ohlcv interface{} = ccxt.GetValue(result, 2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/market.html#K-line%20Streams
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/market.html#Subscribe%20K-Line%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/market.html#Subscribe%20to%20Latest%20Trading%20Pair%20K-Line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BingxCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9278)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeValue(this.Options, ccxt.GetValue(market, "type"), map[string]interface{} {})
            var timeframes interface{} = this.SafeValue(options, "timeframes", map[string]interface{} {})
            var rawTimeframe interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@kline_"), rawTimeframe)
            var messageHash interface{} = ccxt.Add("unsubscribe::", subMessageHash)
            var topic interface{} = "ohlcv"
            var methodName interface{} = "unWatchOHLCV"
            var symbolsAndTimeframes interface{} = []interface{}{[]interface{}{ccxt.GetValue(market, "symbol"), timeframe}}
            ccxt.AddElementToObject(params, "symbolsAndTimeframes", symbolsAndTimeframes)
        
                retRes93815 :=  (<-this.UnWatch(messageHash, subMessageHash, messageHash, subMessageHash, topic, market, methodName, params))
                ccxt.PanicOnError(retRes93815)
                ch <- retRes93815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20order%20update%20data
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#ccxt.Order%20update%20push
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#ccxt.Order%20update%20push
 * @param {string} [symbol] unified market symbol of the market orders are made in
 * @param {int} [since] the earliest time in ms to watch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BingxCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9558)
        
            retRes9568 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9568)
            var typeVar interface{} = nil
            var subType interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchOrders", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var spotHash interface{} = "spot:private"
            var swapHash interface{} = "swap:private"
            var subscriptionHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotHash, swapHash)
            var spotMessageHash interface{} = "spot:order"
            var swapMessageHash interface{} = "swap:order"
            var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotMessageHash, swapMessageHash)
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var uuid interface{} = this.Uuid()
            var baseUrl interface{} = nil
            var request interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) {
                if ccxt.IsTrue(ccxt.IsEqual(subType, "inverse")) {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchOrders is not supported for inverse swap markets yet")))
                }
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
                request = map[string]interface{} {
                    "id": uuid,
                    "reqType": "sub",
                    "dataType": "spot.executionReport",
                }
            }
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": false,
                "id": uuid,
            }
        
            orders:= (<-this.Watch(url, messageHash, request, subscriptionHash, subscription))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20order%20update%20data
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#ccxt.Order%20update%20push
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#ccxt.Order%20update%20push
 * @param {string} [symbol] unified market symbol of the market the trades are made in
 * @param {int} [since] the earliest time in ms to watch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *BingxCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10188)
        
            retRes10198 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10198)
            var typeVar interface{} = nil
            var subType interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchMyTrades", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var spotHash interface{} = "spot:private"
            var swapHash interface{} = "swap:private"
            var subscriptionHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotHash, swapHash)
            var spotMessageHash interface{} = "spot:mytrades"
            var swapMessageHash interface{} = "swap:mytrades"
            var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotMessageHash, swapMessageHash)
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var uuid interface{} = this.Uuid()
            var baseUrl interface{} = nil
            var request interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) {
                if ccxt.IsTrue(ccxt.IsEqual(subType, "inverse")) {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchMyTrades is not supported for inverse swap markets yet")))
                }
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
                request = map[string]interface{} {
                    "id": uuid,
                    "reqType": "sub",
                    "dataType": "spot.executionReport",
                }
            }
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": false,
                "id": uuid,
            }
        
            trades:= (<-this.Watch(url, messageHash, request, subscriptionHash, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bingx#watchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://bingx-api.github.io/docs/#/en-us/spot/socket/account.html#Subscription%20account%20balance%20push
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/socket/account.html#ccxt.Account%20balance%20and%20position%20update%20push
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/socket/account.html#ccxt.Account%20balance%20and%20position%20update%20push
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BingxCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10788)
        
            retRes10798 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10798)
            var typeVar interface{} = nil
            var subType interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchBalance", nil, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var spotSubHash interface{} = "spot:balance"
            var swapSubHash interface{} = "swap:private"
            var spotMessageHash interface{} = "spot:balance"
            var swapMessageHash interface{} = "swap:balance"
            var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotMessageHash, swapMessageHash)
            var subscriptionHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotSubHash, swapSubHash)
            var request interface{} = nil
            var baseUrl interface{} = nil
            var uuid interface{} = this.Uuid()
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) {
                if ccxt.IsTrue(ccxt.IsEqual(subType, "inverse")) {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchBalance is not supported for inverse swap markets yet")))
                }
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subType)
            } else {
                baseUrl = this.SafeString(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
                request = map[string]interface{} {
                    "id": uuid,
                    "dataType": "ACCOUNT_UPDATE",
                }
            }
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, subType, subscriptionHash, params)
            var fetchBalanceSnapshot interface{} = nil
            var awaitBalanceSnapshot interface{} = nil
            fetchBalanceSnapshotparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "fetchBalanceSnapshot", true)
            fetchBalanceSnapshot = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,1)
            awaitBalanceSnapshotparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "awaitBalanceSnapshot", false)
            awaitBalanceSnapshot = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes111412 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes111412)
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": false,
                "id": uuid,
            }
        
                retRes112015 :=  (<-this.Watch(url, messageHash, request, subscriptionHash, subscription))
                ccxt.PanicOnError(retRes112015)
                ch <- retRes112015
                return nil
        
            }()
            return ch
        }
func  (this *BingxCore) SetBalanceCache(client interface{}, typeVar interface{}, subType interface{}, subscriptionHash interface{}, params interface{})  {
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)) {
        return
    }
    var fetchBalanceSnapshot interface{} = this.HandleOptionAndParams(params, "watchBalance", "fetchBalanceSnapshot", true)
    if ccxt.IsTrue(fetchBalanceSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash, typeVar, subType)
        }
    } else {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
}
func  (this *BingxCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}, subType interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            response:= (<-this.FetchBalance(map[string]interface{} {
            "type": typeVar,
            "subType": subType,
        }))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeValue(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve()
                client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
            }
                return nil
            }()
            return ch
        }
func  (this *BingxCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // { code: 100400, msg: '', timestamp: 1696245808833 }
    //
    // {
    //     "code": 100500,
    //     "id": "9cd37d32-da98-440b-bd04-37e7dbcf51ad",
    //     "msg": '',
    //     "timestamp": 1696245842307
    // }
    var code interface{} = this.SafeString(message, "code")
    
        {
             func(this *BingxCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BingxCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
            }
    		    return nil
    	    }(this)
        
            }
    return true
}
func  (this *BingxCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            
                {
                     func(this *BingxCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *BingxCore) interface{} {
                                    // catch block:
                                            var types interface{} = []interface{}{"spot", "linear", "inverse"}
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(types)); i++ {
                        var typeVar interface{} = ccxt.GetValue(types, i)
                        var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "?listenKey="), listenKey)
                        var client interface{} = this.Client(url)
                        var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
                            var messageHash interface{} = ccxt.GetValue(messageHashes, j)
                            client.(ccxt.ClientInterface).Reject(error, messageHash)
                        }
                    }
                    ccxt.AddElementToObject(this.Options, "listenKey", nil)
                    ccxt.AddElementToObject(this.Options, "lastAuthenticatedTime", 0)
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes117912 := (<-this.UserAuthPrivatePutUserDataStream(map[string]interface{} {
                        "listenKey": listenKey,
                    }))
                    ccxt.PanicOnError(retRes117912) // extend the expiry
            		    return nil
            	    }(this)
                
                    }
            // whether or not to schedule another listenKey keepAlive request
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 3600000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
                return nil
            }()
            return ch
        }
func  (this *BingxCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var time interface{} = this.Milliseconds()
            var lastAuthenticatedTime interface{} = this.SafeInteger(this.Options, "lastAuthenticatedTime", 0)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 3600000) // 1 hour
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), listenKeyRefreshRate)) {
        
                response:= (<-this.UserAuthPrivatePostUserDataStream())
                ccxt.PanicOnError(response)
                ccxt.AddElementToObject(this.Options, "listenKey", this.SafeString(response, "listenKey"))
                ccxt.AddElementToObject(this.Options, "lastAuthenticatedTime", time)
                this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
            }
                return nil
            }()
            return ch
        }
func  (this *BingxCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    
                {
                     func(this *BingxCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *BingxCore) interface{} {
                                    // catch block:
                                            error := ccxt.NetworkError(ccxt.Add(ccxt.Add(this.Id, " pong failed with error "), this.Json(e)))
                    client.(ccxt.ClientInterface).Reset(error)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                if ccxt.IsTrue(ccxt.IsEqual(message, "Ping")) {
            
                        retRes122516 := (<-client.(ccxt.ClientInterface).Send("Pong"))
                        ccxt.PanicOnError(retRes122516)
                    } else {
                        var ping interface{} = this.SafeString(message, "ping")
                        var time interface{} = this.SafeString(message, "time")
            
                        retRes122916 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                            "pong": ping,
                            "time": time,
                        }))
                        ccxt.PanicOnError(retRes122916)
                    }
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *BingxCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "code": 0,
    //         "dataType": "spot.executionReport",
    //         "data": {
    //            "e": "executionReport",
    //            "E": 1694680212947,
    //            "s": "LTC-USDT",
    //            "S": "BUY",
    //            "o": "LIMIT",
    //            "q": 0.1,
    //            "p": 50,
    //            "x": "NEW",
    //            "X": "PENDING",
    //            "i": 1702238305204043800,
    //            "l": 0,
    //            "z": 0,
    //            "L": 0,
    //            "n": 0,
    //            "N": "",
    //            "T": 0,
    //            "t": 0,
    //            "O": 1694680212676,
    //            "Z": 0,
    //            "Y": 0,
    //            "Q": 0,
    //            "m": false
    //         }
    //      }
    //
    //      {
    //         "code": 0,
    //         "dataType": "spot.executionReport",
    //         "data": {
    //           "e": "executionReport",
    //           "E": 1694681809302,
    //           "s": "LTC-USDT",
    //           "S": "BUY",
    //           "o": "MARKET",
    //           "q": 0,
    //           "p": 62.29,
    //           "x": "TRADE",
    //           "X": "FILLED",
    //           "i": "1702245001712369664",
    //           "l": 0.0802,
    //           "z": 0.0802,
    //           "L": 62.308,
    //           "n": -0.0000802,
    //           "N": "LTC",
    //           "T": 1694681809256,
    //           "t": 38259147,
    //           "O": 1694681809248,
    //           "Z": 4.9971016,
    //           "Y": 4.9971016,
    //           "Q": 5,
    //           "m": false
    //         }
    //       }
    // swap
    //    {
    //        "e": "ORDER_TRADE_UPDATE",
    //        "E": 1696843635475,
    //        "o": {
    //           "s": "LTC-USDT",
    //           "c": "",
    //           "i": "1711312357852147712",
    //           "S": "BUY",
    //           "o": "MARKET",
    //           "q": "0.10000000",
    //           "p": "64.35010000",
    //           "ap": "64.36000000",
    //           "x": "TRADE",
    //           "X": "FILLED",
    //           "N": "USDT",
    //           "n": "-0.00321800",
    //           "T": 0,
    //           "wt": "MARK_PRICE",
    //           "ps": "LONG",
    //           "rp": "0.00000000",
    //           "z": "0.10000000"
    //        }
    //    }
    //
    var isSpot interface{} =     (ccxt.InOp(message, "dataType"))
    var data interface{} = this.SafeValue2(message, "data", "o", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.Orders
    var parsedOrder interface{} = this.ParseOrder(data)
    stored.(ccxt.Appender).Append(parsedOrder)
    var symbol interface{} = ccxt.GetValue(parsedOrder, "symbol")
    var spotHash interface{} = "spot:order"
    var swapHash interface{} = "swap:order"
    var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), spotHash, swapHash)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
}
func  (this *BingxCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //
    //      {
    //         "code": 0,
    //         "dataType": "spot.executionReport",
    //         "data": {
    //           "e": "executionReport",
    //           "E": 1694681809302,
    //           "s": "LTC-USDT",
    //           "S": "BUY",
    //           "o": "MARKET",
    //           "q": 0,
    //           "p": 62.29,
    //           "x": "TRADE",
    //           "X": "FILLED",
    //           "i": "1702245001712369664",
    //           "l": 0.0802,
    //           "z": 0.0802,
    //           "L": 62.308,
    //           "n": -0.0000802,
    //           "N": "LTC",
    //           "T": 1694681809256,
    //           "t": 38259147,
    //           "O": 1694681809248,
    //           "Z": 4.9971016,
    //           "Y": 4.9971016,
    //           "Q": 5,
    //           "m": false
    //         }
    //       }
    //
    //  swap
    //    {
    //        "e": "ORDER_TRADE_UPDATE",
    //        "E": 1696843635475,
    //        "o": {
    //           "s": "LTC-USDT",
    //           "c": "",
    //           "i": "1711312357852147712",
    //           "S": "BUY",
    //           "o": "MARKET",
    //           "q": "0.10000000",
    //           "p": "64.35010000",
    //           "ap": "64.36000000",
    //           "x": "TRADE",
    //           "X": "FILLED",
    //           "N": "USDT",
    //           "n": "-0.00321800",
    //           "T": 0,
    //           "wt": "MARK_PRICE",
    //           "ps": "LONG",
    //           "rp": "0.00000000",
    //           "z": "0.10000000"
    //        }
    //    }
    //
    var isSpot interface{} =     (ccxt.InOp(message, "dataType"))
    var result interface{} = this.SafeDict2(message, "data", "o", map[string]interface{} {})
    var cachedTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(cachedTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        cachedTrades = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = cachedTrades
    }
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    var marketId interface{} = this.SafeString(result, "s")
    var market interface{} = this.SafeMarket(marketId, nil, "-", typeVar)
    var parsed interface{} = this.ParseTrade(result, market)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var spotHash interface{} = "spot:mytrades"
    var swapHash interface{} = "swap:mytrades"
    var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotHash, swapHash)
    cachedTrades.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(cachedTrades, messageHash)
    client.(ccxt.ClientInterface).Resolve(cachedTrades, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
}
func  (this *BingxCore) HandleBalance(client interface{}, message interface{})  {
    // spot
    //     {
    //         "e":"ACCOUNT_UPDATE",
    //         "E":1696242817000,
    //         "T":1696242817142,
    //         "a":{
    //            "B":[
    //               {
    //                  "a":"USDT",
    //                  "bc":"-1.00000000000000000000",
    //                  "cw":"86.59497382000000050000",
    //                  "wb":"86.59497382000000050000"
    //               }
    //            ],
    //            "m":"ASSET_TRANSFER"
    //         }
    //     }
    // swap
    //     {
    //         "e":"ACCOUNT_UPDATE",
    //         "E":1696244249320,
    //         "a":{
    //            "m":"WITHDRAW",
    //            "B":[
    //               {
    //                  "a":"USDT",
    //                  "wb":"49.81083984",
    //                  "cw":"49.81083984",
    //                  "bc":"-1.00000000"
    //               }
    //            ],
    //            "P":[
    //            ]
    //         }
    //     }
    //
    var a interface{} = this.SafeDict(message, "a", map[string]interface{} {})
    var data interface{} = this.SafeList(a, "B", []interface{}{})
    var timestamp interface{} = this.SafeInteger2(message, "T", "E")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(a, "P"))), "swap", "spot")
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar))) {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "info", data)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var balance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "a")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "info", balance)
        ccxt.AddElementToObject(account, "used", this.SafeString(balance, "lk"))
        ccxt.AddElementToObject(account, "free", this.SafeString(balance, "wb"))
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
    }
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(ccxt.GetValue(this.Balance, typeVar)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
}
func  (this *BingxCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    // public subscriptions
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(message, "Ping"))) || ccxt.IsTrue((ccxt.InOp(message, "ping")))) {
        this.Spawn(this.Pong, client, message)
        return
    }
    var dataType interface{} = this.SafeString(message, "dataType", "")
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(dataType, "@depth"), 0)) {
        this.HandleOrderBook(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(dataType, "@ticker"), 0)) {
        this.HandleTicker(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(dataType, "@trade"), 0)) {
        this.HandleTrades(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(dataType, "@kline"), 0)) {
        this.HandleOHLCV(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(dataType, "executionReport"), 0)) {
        var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
        var typeVar interface{} = this.SafeString(data, "x")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "TRADE")) {
            this.HandleMyTrades(client, message)
        }
        this.HandleOrder(client, message)
        return
    }
    var e interface{} = this.SafeString(message, "e")
    if ccxt.IsTrue(ccxt.IsEqual(e, "ACCOUNT_UPDATE")) {
        this.HandleBalance(client, message)
    }
    if ccxt.IsTrue(ccxt.IsEqual(e, "ORDER_TRADE_UPDATE")) {
        this.HandleOrder(client, message)
        var data interface{} = this.SafeValue(message, "o", map[string]interface{} {})
        var typeVar interface{} = this.SafeString(data, "x")
        var status interface{} = this.SafeString(data, "X")
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "TRADE"))) && ccxt.IsTrue((ccxt.IsEqual(status, "FILLED")))) {
            this.HandleMyTrades(client, message)
        }
    }
    var msgData interface{} = this.SafeValue(message, "data")
    var msgEvent interface{} = this.SafeString(msgData, "e")
    if ccxt.IsTrue(ccxt.IsEqual(msgEvent, "24hTicker")) {
        this.HandleTicker(client, message)
    }
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(dataType, "")) && ccxt.IsTrue(ccxt.IsEqual(msgEvent, nil))) && ccxt.IsTrue(ccxt.IsEqual(e, nil))) {
        this.HandleSubscriptionStatus(client, message)
    }
}
func  (this *BingxCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "code": 0,
    //         "id": "b6ed9cb4-f3d0-4641-ac3f-f59eb47a3abd",
    //         "msg": "SUCCESS",
    //         "timestamp": 1759225965363
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeDict(subscriptionsById, id, map[string]interface{} {})
    var isUnSubMessage interface{} = this.SafeBool(subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSubMessage) {
        this.HandleUnSubscription(client, subscription)
    }
    return message
}
func  (this *BingxCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, i)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    }
    this.CleanCache(subscription)
}


func (this *BingxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
