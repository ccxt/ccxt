package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type PhemexCore struct {
	*ccxt.PhemexCore
	base *ccxt.PhemexCore
}

func NewPhemexCore() *PhemexCore {
    p := &PhemexCore{}
	base := &ccxt.PhemexCore{}
	p.base = base
	p.PhemexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *PhemexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
            "watchPositions": nil,
            "watchOrderBookForSymbols": false,
            "watchTradesForSymbols": false,
            "watchOHLCVForSymbols": false,
            "watchBalance": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": "wss://testnet-api.phemex.com/ws",
            },
            "api": map[string]interface{} {
                "ws": "wss://ws.phemex.com",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
        },
        "streaming": map[string]interface{} {
            "keepAlive": 9000,
        },
    })
}
func  (this *PhemexCore) FromEn(en interface{}, scale interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(en, nil)) {
        return nil
    }
    precise := ccxt.NewPrecise(en)
    precise.Decimals = this.Sum(precise.Decimals, scale)
    precise.Reduce()
    return ccxt.ToString(precise)
}
func  (this *PhemexCore) FromEp(ep interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(ep, nil))) || ccxt.IsTrue((ccxt.IsEqual(market, nil)))) {
        return ep
    }
    return this.FromEn(ep, this.SafeInteger(market, "priceScale"))
}
func  (this *PhemexCore) FromEv(ev interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(ev, nil))) || ccxt.IsTrue((ccxt.IsEqual(market, nil)))) {
        return ev
    }
    return this.FromEn(ev, this.SafeInteger(market, "valueScale"))
}
func  (this *PhemexCore) FromEr(er interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(er, nil))) || ccxt.IsTrue((ccxt.IsEqual(market, nil)))) {
        return er
    }
    return this.FromEn(er, this.SafeInteger(market, "ratioScale"))
}
func  (this *PhemexCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
func  (this *PhemexCore) ParseSwapTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": 442800,
    //         "fundingRate": 10000,
    //         "high": 445400,
    //         "indexPrice": 442621,
    //         "low": 428400,
    //         "markPrice": 442659,
    //         "open": 432200,
    //         "openInterest": 744183,
    //         "predFundingRate": 10000,
    //         "symbol": "LTCUSD",
    //         "turnover": 8133238294,
    //         "volume": 934292
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeIntegerProduct(ticker, "timestamp", 0.000001)
    var lastString interface{} = this.FromEp(this.SafeString(ticker, "close"), market)
    var last interface{} = this.ParseNumber(lastString)
    var quoteVolume interface{} = this.ParseNumber(this.FromEv(this.SafeString(ticker, "turnover"), market))
    var baseVolume interface{} = this.ParseNumber(this.FromEv(this.SafeString(ticker, "volume"), market))
    var change interface{} = nil
    var percentage interface{} = nil
    var average interface{} = nil
    var openString interface{} = this.OmitZero(this.FromEp(this.SafeString(ticker, "open"), market))
    var open interface{} = this.ParseNumber(openString)
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(openString, nil))) && ccxt.IsTrue((!ccxt.IsEqual(lastString, nil)))) {
        change = this.ParseNumber(ccxt.Precise.StringSub(lastString, openString))
        average = this.ParseNumber(ccxt.Precise.StringDiv(ccxt.Precise.StringAdd(lastString, openString), "2"))
        percentage = this.ParseNumber(ccxt.Precise.StringMul(ccxt.Precise.StringSub(ccxt.Precise.StringDiv(lastString, openString), "1"), "100"))
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.ParseNumber(this.FromEp(this.SafeString(ticker, "high"), market)),
        "low": this.ParseNumber(this.FromEp(this.SafeString(ticker, "low"), market)),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": percentage,
        "average": average,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "markPrice": this.ParseNumber(this.FromEp(this.SafeString(ticker, "markPrice"), market)),
        "indexPrice": this.ParseNumber(this.FromEp(this.SafeString(ticker, "indexPrice"), market)),
        "info": ticker,
    })
}
func  (this *PhemexCore) ParsePerpetualTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [
    //        "STXUSDT",
    //        "0.64649",
    //        "0.8628",
    //        "0.61215",
    //        "0.71737",
    //        "4519387",
    //        "3210827.98166",
    //        "697635",
    //        "0.71720205",
    //        "0.71720205",
    //        "0.0001",
    //        "0.0001",
    //    ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, 0)
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var lastString interface{} = this.FromEp(this.SafeString(ticker, 4), market)
    var last interface{} = this.ParseNumber(lastString)
    var quoteVolume interface{} = this.ParseNumber(this.FromEv(this.SafeString(ticker, 6), market))
    var baseVolume interface{} = this.ParseNumber(this.FromEv(this.SafeString(ticker, 5), market))
    var change interface{} = nil
    var percentage interface{} = nil
    var average interface{} = nil
    var openString interface{} = this.OmitZero(this.FromEp(this.SafeString(ticker, 1), market))
    var open interface{} = this.ParseNumber(openString)
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(openString, nil))) && ccxt.IsTrue((!ccxt.IsEqual(lastString, nil)))) {
        change = this.ParseNumber(ccxt.Precise.StringSub(lastString, openString))
        average = this.ParseNumber(ccxt.Precise.StringDiv(ccxt.Precise.StringAdd(lastString, openString), "2"))
        percentage = this.ParseNumber(ccxt.Precise.StringMul(ccxt.Precise.StringSub(ccxt.Precise.StringDiv(lastString, openString), "1"), "100"))
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.ParseNumber(this.FromEp(this.SafeString(ticker, 2), market)),
        "low": this.ParseNumber(this.FromEp(this.SafeString(ticker, 3), market)),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": percentage,
        "average": average,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    })
}
func  (this *PhemexCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "spot_market24h": {
    //             "askEp": 958148000000,
    //             "bidEp": 957884000000,
    //             "highEp": 962000000000,
    //             "lastEp": 958220000000,
    //             "lowEp": 928049000000,
    //             "openEp": 935597000000,
    //             "symbol": "sBTCUSDT",
    //             "turnoverEv": 146074214388978,
    //             "volumeEv": 15492228900
    //         },
    //         "timestamp": 1592847265888272100
    //     }
    //
    // swap
    //
    //     {
    //         "market24h": {
    //             "close": 442800,
    //             "fundingRate": 10000,
    //             "high": 445400,
    //             "indexPrice": 442621,
    //             "low": 428400,
    //             "markPrice": 442659,
    //             "open": 432200,
    //             "openInterest": 744183,
    //             "predFundingRate": 10000,
    //             "symbol": "LTCUSD",
    //             "turnover": 8133238294,
    //             "volume": 934292
    //         },
    //         "timestamp": 1592845585373374500
    //     }
    //
    // perpetual
    //
    //    {
    //        "data": [
    //            [
    //                "STXUSDT",
    //                "0.64649",
    //                "0.8628",
    //                "0.61215",
    //                "0.71737",
    //                "4519387",
    //                "3210827.98166",
    //                "697635",
    //                "0.71720205",
    //                "0.71720205",
    //                "0.0001",
    //                "0.0001",
    //            ],
    //            ...
    //        ],
    //        "fields": [
    //            "symbol",
    //            "openRp",
    //            "highRp",
    //            "lowRp",
    //            "lastRp",
    //            "volumeRq",
    //            "turnoverRv",
    //            "openInterestRv",
    //            "indexRp",
    //            "markRp",
    //            "fundingRateRr",
    //            "predFundingRateRr",
    //        ],
    //        "method": "perp_market24h_pack_p.update",
    //        "timestamp": "1677094918686806209",
    //        "type": "snapshot",
    //    }
    //
    var tickers interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.InOp(message, "market24h")) {
        var ticker interface{} = this.SafeValue(message, "market24h")
        ccxt.AppendToArray(&tickers, this.ParseSwapTicker(ticker))
    } else if ccxt.IsTrue(ccxt.InOp(message, "spot_market24h")) {
        var ticker interface{} = this.SafeValue(message, "spot_market24h")
        ccxt.AppendToArray(&tickers, this.ParseTicker(ticker))
    } else if ccxt.IsTrue(ccxt.InOp(message, "data")) {
        var data interface{} = this.SafeValue(message, "data", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            ccxt.AppendToArray(&tickers, this.ParsePerpetualTicker(ccxt.GetValue(data, i)))
        }
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tickers)); i++ {
        var ticker interface{} = ccxt.GetValue(tickers, i)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        var messageHash interface{} = ccxt.Add("ticker:", symbol)
        var timestamp interface{} = this.SafeIntegerProduct(message, "timestamp", 0.000001)
        ccxt.AddElementToObject(ticker, "timestamp", timestamp)
        ccxt.AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
/**
 * @method
 * @name phemex#watchBalance
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-account-order-position-aop
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-account-order-position-aop
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-wallet-order-messages
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.settle] set to USDT to use hedged perpetual api
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *PhemexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3198)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var usePerpetualApi interface{} = ccxt.IsEqual(this.SafeString(params, "settle"), "USDT")
            var messageHash interface{} = ":balance"
            messageHash = ccxt.Ternary(ccxt.IsTrue(usePerpetualApi), ccxt.Add("perpetual", messageHash), ccxt.Add(typeVar, messageHash))
        
                retRes32515 :=  (<-this.SubscribePrivate(typeVar, messageHash, params))
                ccxt.PanicOnError(retRes32515)
                ch <- retRes32515
                return nil
        
            }()
            return ch
        }
func  (this *PhemexCore) HandleBalance(typeVar interface{}, client interface{}, message interface{})  {
    // spot
    //    [
    //       {
    //           "balanceEv": 0,
    //           "currency": "BTC",
    //           "lastUpdateTimeNs": "1650442638722099092",
    //           "lockedTradingBalanceEv": 0,
    //           "lockedWithdrawEv": 0,
    //           "userID": 2647224
    //         },
    //         {
    //           "balanceEv": 1154232337,
    //           "currency": "USDT",
    //           "lastUpdateTimeNs": "1650442617610017597",
    //           "lockedTradingBalanceEv": 0,
    //           "lockedWithdrawEv": 0,
    //           "userID": 2647224
    //         }
    //    ]
    // swap
    //    [
    //        {
    //            "accountBalanceEv": 0,
    //            "accountID": 26472240001,
    //            "bonusBalanceEv": 0,
    //            "currency": "BTC",
    //            "totalUsedBalanceEv": 0,
    //            "userID": 2647224
    //        }
    //    ]
    // perpetual
    //    [
    //        {
    //            "accountBalanceRv": "1508.452588802237",
    //            "accountID": 9328670003,
    //            "bonusBalanceRv": "0",
    //            "currency": "USDT",
    //            "totalUsedBalanceRv": "343.132599666883",
    //            "userID": 932867
    //        }
    //    ]
    //
    ccxt.AddElementToObject(this.Balance, "info", message)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var balance interface{} = ccxt.GetValue(message, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var currency interface{} = this.SafeValue(this.Currencies, code, map[string]interface{} {})
        var scale interface{} = this.SafeInteger(currency, "valueScale", 8)
        var account interface{} = this.Account()
        var used interface{} = this.SafeString(balance, "totalUsedBalanceRv")
        if ccxt.IsTrue(ccxt.IsEqual(used, nil)) {
            var usedEv interface{} = this.SafeString(balance, "totalUsedBalanceEv")
            if ccxt.IsTrue(ccxt.IsEqual(usedEv, nil)) {
                var lockedTradingBalanceEv interface{} = this.SafeString(balance, "lockedTradingBalanceEv")
                var lockedWithdrawEv interface{} = this.SafeString2(balance, "lockedWithdrawEv", "lockedWithdrawRv")
                usedEv = ccxt.Precise.StringAdd(lockedTradingBalanceEv, lockedWithdrawEv)
            }
            used = this.FromEn(usedEv, scale)
        }
        var total interface{} = this.SafeString(balance, "accountBalanceRv")
        if ccxt.IsTrue(ccxt.IsEqual(total, nil)) {
            var totalEv interface{} = this.SafeString2(balance, "accountBalanceEv", "balanceEv")
            total = this.FromEn(totalEv, scale)
        }
        ccxt.AddElementToObject(account, "used", used)
        ccxt.AddElementToObject(account, "total", total)
        ccxt.AddElementToObject(this.Balance, code, account)
        this.Balance = this.SafeBalance(this.Balance)
    }
    var messageHash interface{} = ccxt.Add(typeVar, ":balance")
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *PhemexCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "sequence": 1795484727,
    //         "symbol": "sBTCUSDT",
    //         "trades": [
    //             [ 1592891002064516600, "Buy", 964020000000, 1431000 ],
    //             [ 1592890978987934500, "Sell", 963704000000, 1401800 ],
    //             [ 1592890972918701800, "Buy", 963938000000, 2018600 ],
    //         ],
    //         "type": "snapshot"
    //     }
    //  perpetual
    //     {
    //         "sequence": 1230197759,
    //         "symbol": "BTCUSDT",
    //         "trades_p": [
    //             [
    //                 1677094244729433000,
    //                 "Buy",
    //                 "23800.4",
    //                 "2.455",
    //             ],
    //         ],
    //         "type": "snapshot",
    //     }
    //
    var name interface{} = "trade"
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var trades interface{} = this.SafeValue2(message, "trades", "trades_p", []interface{}{})
    var parsed interface{} = this.ParseTrades(trades, market)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsed, i))
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *PhemexCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "kline": [
    //             [ 1592905200, 60, 960688000000, 960709000000, 960709000000, 960400000000, 960400000000, 848100, 8146756046 ],
    //             [ 1592905140, 60, 960718000000, 960716000000, 960717000000, 960560000000, 960688000000, 4284900, 41163743512 ],
    //             [ 1592905080, 60, 960513000000, 960684000000, 960718000000, 960684000000, 960718000000, 4880500, 46887494349 ],
    //         ],
    //         "sequence": 1804401474,
    //         "symbol": "sBTCUSDT",
    //         "type": "snapshot"
    //     }
    // perpetual
    //     {
    //         "kline_p": [
    //             [
    //                 1677094560,
    //                 60,
    //                 "23746.2",
    //                 "23746.1",
    //                 "23757.6",
    //                 "23736.9",
    //                 "23754.8",
    //                 "34.273",
    //                 "813910.208",
    //             ],
    //         ],
    //         "sequence": 1230786017,
    //         "symbol": "BTCUSDT",
    //         "type": "incremental",
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var candles interface{} = this.SafeValue2(message, "kline", "kline_p", []interface{}{})
    var first interface{} = this.SafeValue(candles, 0, []interface{}{})
    var interval interface{} = this.SafeString(first, 1)
    var timeframe interface{} = this.FindTimeframe(interval)
    if ccxt.IsTrue(!ccxt.IsEqual(timeframe, nil)) {
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline:", timeframe), ":"), symbol)
        var ohlcvs interface{} = this.ParseOHLCVs(candles, market)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(ohlcvs)); i++ {
            var candle interface{} = ccxt.GetValue(ohlcvs, i)
            stored.(ccxt.Appender).Append(candle)
        }
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name phemex#watchTicker
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-24-hours-ticker
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-24-hours-ticker
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-24-hours-ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *PhemexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5188)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var isSwap interface{} = ccxt.GetValue(market, "swap")
            var settleIsUSDT interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            var name interface{} = "spot_market24h"
            if ccxt.IsTrue(isSwap) {
                name = ccxt.Ternary(ccxt.IsTrue(settleIsUSDT), "perp_market24h_pack_p", "market24h")
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var subscriptionHash interface{} = ccxt.Add(name, ".subscribe")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var subscribe interface{} = map[string]interface{} {
                "method": subscriptionHash,
                "id": requestId,
                "params": []interface{}{},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes53715 :=  (<-this.Watch(url, messageHash, request, subscriptionHash))
                ccxt.PanicOnError(retRes53715)
                ch <- retRes53715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name phemex#watchTickers
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-24-hours-ticker
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-24-hours-ticker
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-24-hours-ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *PhemexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5538)
            symbols = this.MarketSymbols(symbols, nil, false)
            var first interface{} = ccxt.GetValue(symbols, 0)
            var market interface{} = this.Market(first)
            var isSwap interface{} = ccxt.GetValue(market, "swap")
            var settleIsUSDT interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            var name interface{} = "spot_market24h"
            if ccxt.IsTrue(isSwap) {
                name = ccxt.Ternary(ccxt.IsTrue(settleIsUSDT), "perp_market24h_pack_p", "market24h")
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var subscriptionHash interface{} = ccxt.Add(name, ".subscribe")
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(symbols, i)))
            }
            var subscribe interface{} = map[string]interface{} {
                "method": subscriptionHash,
                "id": requestId,
                "params": []interface{}{},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name phemex#watchTrades
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-trade
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-trade
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-trade
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *PhemexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5998)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var isSwap interface{} = ccxt.GetValue(market, "swap")
            var settleIsUSDT interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            var name interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(isSwap) && ccxt.IsTrue(settleIsUSDT))), "trade_p", "trade")
            var messageHash interface{} = ccxt.Add("trade:", symbol)
            var method interface{} = ccxt.Add(name, ".subscribe")
            var subscribe interface{} = map[string]interface{} {
                "method": method,
                "id": requestId,
                "params": []interface{}{ccxt.GetValue(market, "id")},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name phemex#watchOrderBook
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-orderbook
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-orderbook-for-new-model
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-30-levels-orderbook
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-full-orderbook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *PhemexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6388)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var isSwap interface{} = ccxt.GetValue(market, "swap")
            var settleIsUSDT interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            var name interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(isSwap) && ccxt.IsTrue(settleIsUSDT))), "orderbook_p", "orderbook")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var method interface{} = ccxt.Add(name, ".subscribe")
            var subscribe interface{} = map[string]interface{} {
                "method": method,
                "id": requestId,
                "params": []interface{}{ccxt.GetValue(market, "id")},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name phemex#watchOHLCV
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Hedged-Perpetual-API.md#subscribe-kline
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#subscribe-kline
 * @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Spot-API-en.md#subscribe-kline
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *PhemexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6758)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var isSwap interface{} = ccxt.GetValue(market, "swap")
            var settleIsUSDT interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            var name interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(isSwap) && ccxt.IsTrue(settleIsUSDT))), "kline_p", "kline")
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline:", timeframe), ":"), symbol)
            var method interface{} = ccxt.Add(name, ".subscribe")
            var subscribe interface{} = map[string]interface{} {
                "method": method,
                "id": requestId,
                "params": []interface{}{ccxt.GetValue(market, "id"), this.SafeInteger(this.Timeframes, timeframe)},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *PhemexCore) CustomHandleDelta(bookside interface{}, delta interface{}, optionalArgs ...interface{})  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var bidAsk interface{} = this.CustomParseBidAsk(delta, 0, 1, market)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *PhemexCore) CustomHandleDeltas(bookside interface{}, deltas interface{}, optionalArgs ...interface{})  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.CustomHandleDelta(bookside, ccxt.GetValue(deltas, i), market)
    }
}
func  (this *PhemexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "book": {
    //             "asks": [
    //                 [ 960316000000, 6993800 ],
    //                 [ 960318000000, 13183000 ],
    //                 [ 960319000000, 9170200 ],
    //             ],
    //             "bids": [
    //                 [ 959941000000, 8385300 ],
    //                 [ 959939000000, 10296600 ],
    //                 [ 959930000000, 3672400 ],
    //             ]
    //         },
    //         "depth": 30,
    //         "sequence": 1805784701,
    //         "symbol": "sBTCUSDT",
    //         "timestamp": 1592908460404461600,
    //         "type": "snapshot"
    //     }
    //  perpetual
    //    {
    //        "depth": 30,
    //        "orderbook_p": {
    //            "asks": [
    //                [
    //                    "23788.5",
    //                    "0.13",
    //                ],
    //            ],
    //            "bids": [
    //                [
    //                    "23787.8",
    //                    "1.836",
    //                ],
    //            ],
    //        },
    //        "sequence": 1230347368,
    //        "symbol": "BTCUSDT",
    //        "timestamp": "1677093457306978852",
    //        "type": "snapshot",
    //    }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var typeVar interface{} = this.SafeString(message, "type")
    var depth interface{} = this.SafeInteger(message, "depth")
    var name interface{} = "orderbook"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), symbol)
    var nonce interface{} = this.SafeInteger(message, "sequence")
    var timestamp interface{} = this.SafeIntegerProduct(message, "timestamp", 0.000001)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        var book interface{} = this.SafeValue2(message, "book", "orderbook_p", map[string]interface{} {})
        var snapshot interface{} = this.CustomParseOrderBook(book, symbol, timestamp, "bids", "asks", 0, 1, market)
        ccxt.AddElementToObject(snapshot, "nonce", nonce)
        var orderbook interface{} = this.OrderBook(snapshot, depth)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    } else {
        if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            var changes interface{} = this.SafeDict2(message, "book", "orderbook_p", map[string]interface{} {})
            var asks interface{} = this.SafeList(changes, "asks", []interface{}{})
            var bids interface{} = this.SafeList(changes, "bids", []interface{}{})
            this.CustomHandleDeltas(ccxt.GetValue(orderbook, "asks"), asks, market)
            this.CustomHandleDeltas(ccxt.GetValue(orderbook, "bids"), bids, market)
            ccxt.AddElementToObject(orderbook, "nonce", nonce)
            ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
            ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
            ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    }
}
/**
 * @method
 * @name phemex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *PhemexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8008 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8008)
            var market interface{} = nil
            var typeVar interface{} = nil
            var messageHash interface{} = "trades:"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.GetValue(market, "symbol"))
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")) {
                    params = this.Extend(params)
                    ccxt.AddElementToObject(params, "settle", "USDT")
                }
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                var settle interface{} = this.SafeString(params, "settle")
                messageHash = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(settle, "USDT"))), (ccxt.Add(messageHash, "perpetual")), (ccxt.Add(messageHash, typeVar)))
            }
        
            trades:= (<-this.SubscribePrivate(typeVar, messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *PhemexCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // swap
    //    [
    //        {
    //            "avgPriceEp":4138763000000,
    //            "baseCurrency":"BTC",
    //            "baseQtyEv":0,
    //            "clOrdID":"7956e0be-e8be-93a0-2887-ca504d85cda2",
    //            "execBaseQtyEv":30100,
    //            "execFeeEv":31,
    //            "execID":"d3b10cfa-84e3-5752-828e-78a79617e598",
    //            "execPriceEp":4138763000000,
    //            "execQuoteQtyEv":1245767663,
    //            "feeCurrency":"BTC",
    //            "lastLiquidityInd":"RemovedLiquidity",
    //            "ordType":"ccxt.Market",
    //            "orderID":"34a4b1a8-ac3a-4580-b3e6-a6d039f27195",
    //            "priceEp":4549022000000,
    //            "qtyType":"ByQuote",
    //            "quoteCurrency":"USDT",
    //            "quoteQtyEv":1248000000,
    //            "side":"Buy",
    //            "symbol":"sBTCUSDT",
    //            "tradeType":"ccxt.Trade",
    //            "transactTimeNs":"1650442617609928764",
    //            "userID":2647224
    //        }
    //    ]
    // perpetual
    //    [
    //        {
    //            "accountID": 9328670003,
    //            "action": "New",
    //            "actionBy": "ByUser",
    //            "actionTimeNs": 1666858780876924611,
    //            "addedSeq": 77751555,
    //            "apRp": "0",
    //            "bonusChangedAmountRv": "0",
    //            "bpRp": "0",
    //            "clOrdID": "c0327a7d-9064-62a9-28f6-2db9aaaa04e0",
    //            "closedPnlRv": "0",
    //            "closedSize": "0",
    //            "code": 0,
    //            "cumFeeRv": "0",
    //            "cumQty": "0",
    //            "cumValueRv": "0",
    //            "curAccBalanceRv": "1508.489893982237",
    //            "curAssignedPosBalanceRv": "24.62786650928",
    //            "curBonusBalanceRv": "0",
    //            "curLeverageRr": "-10",
    //            "curPosSide": "Buy",
    //            "curPosSize": "0.043",
    //            "curPosTerm": 1,
    //            "curPosValueRv": "894.0689",
    //            "curRiskLimitRv": "1000000",
    //            "currency": "USDT",
    //            "cxlRejReason": 0,
    //            "displayQty": "0.003",
    //            "execFeeRv": "0",
    //            "execID": "00000000-0000-0000-0000-000000000000",
    //            "execPriceRp": "20723.7",
    //            "execQty": "0",
    //            "execSeq": 77751555,
    //            "execStatus": "New",
    //            "execValueRv": "0",
    //            "feeRateRr": "0",
    //            "leavesQty": "0.003",
    //            "leavesValueRv": "63.4503",
    //            "message": "No error",
    //            "ordStatus": "New",
    //            "ordType": "ccxt.Market",
    //            "orderID": "fa64c6f2-47a4-4929-aab4-b7fa9bbc4323",
    //            "orderQty": "0.003",
    //            "pegOffsetValueRp": "0",
    //            "posSide": "Long",
    //            "priceRp": "21150.1",
    //            "relatedPosTerm": 1,
    //            "relatedReqNum": 11,
    //            "side": "Buy",
    //            "slTrigger": "ByMarkPrice",
    //            "stopLossRp": "0",
    //            "stopPxRp": "0",
    //            "symbol": "BTCUSDT",
    //            "takeProfitRp": "0",
    //            "timeInForce": "ImmediateOrCancel",
    //            "tpTrigger": "ByLastPrice",
    //            "tradeType": "Amend",
    //            "transactTimeNs": 1666858780881545305,
    //            "userID": 932867
    //        },
    //        ...
    //    ]
    //
    var channel interface{} = "trades"
    var tradesLength interface{} =     ccxt.GetArrayLength(message)
    if ccxt.IsTrue(ccxt.IsEqual(tradesLength, 0)) {
        return
    }
    var cachedTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(cachedTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        cachedTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var marketIds interface{} = map[string]interface{} {}
    var typeVar interface{} = nil
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var rawTrade interface{} = ccxt.GetValue(message, i)
        var marketId interface{} = this.SafeString(rawTrade, "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var parsed interface{} = this.ParseTrade(rawTrade)
        cachedTrades.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
            typeVar = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT"))), "perpetual", ccxt.GetValue(market, "type"))
        }
        ccxt.AddElementToObject(marketIds, symbol, true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var market interface{} = ccxt.GetValue(keys, i)
        var hash interface{} = ccxt.Add(ccxt.Add(channel, ":"), market)
        client.(ccxt.ClientInterface).Resolve(cachedTrades, hash)
    }
    // generic subscription
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), typeVar)
    client.(ccxt.ClientInterface).Resolve(cachedTrades, messageHash)
}
/**
 * @method
 * @name phemex#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *PhemexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9658)
            var messageHash interface{} = "orders:"
            var market interface{} = nil
            var typeVar interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.GetValue(market, "symbol"))
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")) {
                    params = this.Extend(params)
                    ccxt.AddElementToObject(params, "settle", "USDT")
                }
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isUSDTSettled interface{} = ccxt.IsEqual(this.SafeString(params, "settle"), "USDT")
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Ternary(ccxt.IsTrue((isUSDTSettled)), (ccxt.Add(messageHash, "perpetual")), (ccxt.Add(messageHash, typeVar)))
            }
        
            orders:= (<-this.SubscribePrivate(typeVar, messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *PhemexCore) HandleOrders(client interface{}, message interface{})  {
    // spot update
    // {
    //        "closed":[
    //           {
    //              "action":"New",
    //              "avgPriceEp":4138763000000,
    //              "baseCurrency":"BTC",
    //              "baseQtyEv":0,
    //              "bizError":0,
    //              "clOrdID":"7956e0be-e8be-93a0-2887-ca504d85cda2",
    //              "createTimeNs":"1650442617606017583",
    //              "cumBaseQtyEv":30100,
    //              "cumFeeEv":31,
    //              "cumQuoteQtyEv":1245767663,
    //              "cxlRejReason":0,
    //              "feeCurrency":"BTC",
    //              "leavesBaseQtyEv":0,
    //              "leavesQuoteQtyEv":0,
    //              "ordStatus":"Filled",
    //              "ordType":"ccxt.Market",
    //              "orderID":"34a4b1a8-ac3a-4580-b3e6-a6d039f27195",
    //              "pegOffsetValueEp":0,
    //              "priceEp":4549022000000,
    //              "qtyType":"ByQuote",
    //              "quoteCurrency":"USDT",
    //              "quoteQtyEv":1248000000,
    //              "side":"Buy",
    //              "stopPxEp":0,
    //              "symbol":"sBTCUSDT",
    //              "timeInForce":"ImmediateOrCancel",
    //              "tradeType":"ccxt.Trade",
    //              "transactTimeNs":"1650442617609928764",
    //              "triggerTimeNs":0,
    //              "userID":2647224
    //           }
    //        ],
    //        "fills":[
    //           {
    //              "avgPriceEp":4138763000000,
    //              "baseCurrency":"BTC",
    //              "baseQtyEv":0,
    //              "clOrdID":"7956e0be-e8be-93a0-2887-ca504d85cda2",
    //              "execBaseQtyEv":30100,
    //              "execFeeEv":31,
    //              "execID":"d3b10cfa-84e3-5752-828e-78a79617e598",
    //              "execPriceEp":4138763000000,
    //              "execQuoteQtyEv":1245767663,
    //              "feeCurrency":"BTC",
    //              "lastLiquidityInd":"RemovedLiquidity",
    //              "ordType":"ccxt.Market",
    //              "orderID":"34a4b1a8-ac3a-4580-b3e6-a6d039f27195",
    //              "priceEp":4549022000000,
    //              "qtyType":"ByQuote",
    //              "quoteCurrency":"USDT",
    //              "quoteQtyEv":1248000000,
    //              "side":"Buy",
    //              "symbol":"sBTCUSDT",
    //              "tradeType":"ccxt.Trade",
    //              "transactTimeNs":"1650442617609928764",
    //              "userID":2647224
    //           }
    //        ],
    //        "open":[
    //           {
    //              "action":"New",
    //              "avgPriceEp":0,
    //              "baseCurrency":"LTC",
    //              "baseQtyEv":0,
    //              "bizError":0,
    //              "clOrdID":"2c0e5eb5-efb7-60d3-2e5f-df175df412ef",
    //              "createTimeNs":"1650446670073853755",
    //              "cumBaseQtyEv":0,
    //              "cumFeeEv":0,
    //              "cumQuoteQtyEv":0,
    //              "cxlRejReason":0,
    //              "feeCurrency":"LTC",
    //              "leavesBaseQtyEv":0,
    //              "leavesQuoteQtyEv":1000000000,
    //              "ordStatus":"New",
    //              "ordType":"ccxt.Limit",
    //              "orderID":"d2aad92f-50f5-441a-957b-8184b146e3fb",
    //              "pegOffsetValueEp":0,
    //              "priceEp":5000000000,
    //              "qtyType":"ByQuote",
    //              "quoteCurrency":"USDT",
    //              "quoteQtyEv":1000000000,
    //              "side":"Buy",
    //            }
    //        ]
    //  },
    // perpetual
    //    [
    //        {
    //          "accountID": 40183400003,
    //          "action": "New",
    //          "actionBy": "ByUser",
    //          "actionTimeNs": "1674110665380190869",
    //          "addedSeq": 678760103,
    //          "apRp": "0",
    //          "bonusChangedAmountRv": "0",
    //          "bpRp": "0",
    //          "clOrdID": '',
    //          "cl_req_code": 0,
    //          "closedPnlRv": "0",
    //          "closedSize": "0",
    //          "code": 0,
    //          "cumFeeRv": "0",
    //          "cumQty": "0.001",
    //          "cumValueRv": "20.849",
    //          "curAccBalanceRv": "19.9874906",
    //          "curAssignedPosBalanceRv": "0",
    //          "curBonusBalanceRv": "0",
    //          "curLeverageRr": "-10",
    //          "curPosSide": "Buy",
    //          "curPosSize": "0.001",
    //          "curPosTerm": 1,
    //          "curPosValueRv": "20.849",
    //          "curRiskLimitRv": "1000000",
    //          "currency": "USDT",
    //          "cxlRejReason": 0,
    //          "displayQty": "0.001",
    //          "execFeeRv": "0.0125094",
    //          "execID": "b88d2950-04a2-52d8-8927-346059900242",
    //          "execPriceRp": "20849",
    //          "execQty": "0.001",
    //          "execSeq": 678760103,
    //          "execStatus": "TakerFill",
    //          "execValueRv": "20.849",
    //          "feeRateRr": "0.0006",
    //          "lastLiquidityInd": "RemovedLiquidity",
    //          "leavesQty": "0",
    //          "leavesValueRv": "0",
    //          "message": "No error",
    //          "ordStatus": "Filled",
    //          "ordType": "ccxt.Market",
    //          "orderID": "79620ed2-54c6-4645-a35c-7057e687c576",
    //          "orderQty": "0.001",
    //          "pegOffsetProportionRr": "0",
    //          "pegOffsetValueRp": "0",
    //          "posSide": "Long",
    //          "priceRp": "21476.3",
    //          "relatedPosTerm": 1,
    //          "relatedReqNum": 4,
    //          "side": "Buy",
    //          "slTrigger": "ByMarkPrice",
    //          "stopLossRp": "0",
    //          "stopPxRp": "0",
    //          "symbol": "BTCUSDT",
    //          "takeProfitRp": "0",
    //          "timeInForce": "ImmediateOrCancel",
    //          "tpTrigger": "ByLastPrice",
    //          "tradeType": "ccxt.Trade",
    //          "transactTimeNs": "1674110665387882268",
    //          "userID": 4018340
    //        },
    //        ...
    //    ]
    //
    var trades interface{} = []interface{}{}
    var parsedOrders interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "closed"))) || ccxt.IsTrue((ccxt.InOp(message, "fills")))) || ccxt.IsTrue((ccxt.InOp(message, "open")))) {
        var closed interface{} = this.SafeValue(message, "closed", []interface{}{})
        var open interface{} = this.SafeValue(message, "open", []interface{}{})
        var orders interface{} = this.ArrayConcat(open, closed)
        var ordersLength interface{} =         ccxt.GetArrayLength(orders)
        if ccxt.IsTrue(ccxt.IsEqual(ordersLength, 0)) {
            return
        }
        trades = this.SafeValue(message, "fills", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
            var rawOrder interface{} = ccxt.GetValue(orders, i)
            var parsedOrder interface{} = this.ParseOrder(rawOrder)
            ccxt.AppendToArray(&parsedOrders, parsedOrder)
        }
    } else {
        var messageLength interface{} =         ccxt.GetArrayLength(message)
        if ccxt.IsTrue(ccxt.IsEqual(messageLength, 0)) {
            return
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
            var update interface{} = ccxt.GetValue(message, i)
            var action interface{} = this.SafeString(update, "action")
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(action, nil))) && ccxt.IsTrue((!ccxt.IsEqual(action, "ccxt.Cancel")))) {
                // order + trade info together
                ccxt.AppendToArray(&trades, update)
            }
            var parsedOrder interface{} = this.ParseWSSwapOrder(update)
            ccxt.AppendToArray(&parsedOrders, parsedOrder)
        }
    }
    this.HandleMyTrades(client, trades)
    var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
    var marketIds interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var typeVar interface{} = nil
    var stored interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsedOrders)); i++ {
        var parsed interface{} = ccxt.GetValue(parsedOrders, i)
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        var market interface{} = this.Market(symbol)
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
            var isUsdt interface{} = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDT")
            typeVar = ccxt.Ternary(ccxt.IsTrue(isUsdt), "perpetual", ccxt.GetValue(market, "type"))
        }
        ccxt.AddElementToObject(marketIds, symbol, true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var currentMessageHash interface{} = ccxt.Add(ccxt.Add("orders", ":"), ccxt.GetValue(keys, i))
        client.(ccxt.ClientInterface).Resolve(this.Orders, currentMessageHash)
    }
    // resolve generic subscription (spot or swap)
    var messageHash interface{} = ccxt.Add("orders:", typeVar)
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *PhemexCore) ParseWSSwapOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // swap
    //    {
    //        "accountID":26472240002,
    //        "action":"ccxt.Cancel",
    //        "actionBy":"ByUser",
    //        "actionTimeNs":"1650450096104760797",
    //        "addedSeq":26975849309,
    //        "bonusChangedAmountEv":0,
    //        "clOrdID":"d9675963-5e4e-6fc8-898a-ec8b934c1c61",
    //        "closedPnlEv":0,
    //        "closedSize":0,
    //        "code":0,
    //        "cumQty":0,
    //        "cumValueEv":0,
    //        "curAccBalanceEv":400079,
    //        "curAssignedPosBalanceEv":0,
    //        "curBonusBalanceEv":0,
    //        "curLeverageEr":0,
    //        "curPosSide":"None",
    //        "curPosSize":0,
    //        "curPosTerm":1,
    //        "curPosValueEv":0,
    //        "curRiskLimitEv":5000000000,
    //        "currency":"USD",
    //        "cxlRejReason":0,
    //        "displayQty":0,
    //        "execFeeEv":0,
    //        "execID":"00000000-0000-0000-0000-000000000000",
    //        "execPriceEp":0,
    //        "execQty":1,
    //        "execSeq":26975862338,
    //        "execStatus":"Canceled",
    //        "execValueEv":0,
    //        "feeRateEr":0,
    //        "leavesQty":0,
    //        "leavesValueEv":0,
    //        "message":"No error",
    //        "ordStatus":"Canceled",
    //        "ordType":"ccxt.Limit",
    //        "orderID":"8141deb9-8f94-48f6-9421-a4e3a791537b",
    //        "orderQty":1,
    //        "pegOffsetValueEp":0,
    //        "priceEp":9521,
    //        "relatedPosTerm":1,
    //        "relatedReqNum":4,
    //        "side":"Buy",
    //        "slTrigger":"ByMarkPrice",
    //        "stopLossEp":0,
    //        "stopPxEp":0,
    //        "symbol":"ADAUSD",
    //        "takeProfitEp":0,
    //        "timeInForce":"GoodTillCancel",
    //        "tpTrigger":"ByLastPrice",
    //        "transactTimeNs":"1650450096108143014",
    //        "userID":2647224
    //    }
    // perpetual
    //    {
    //        "accountID": 40183400003,
    //        "action": "New",
    //        "actionBy": "ByUser",
    //        "actionTimeNs": "1674110665380190869",
    //        "addedSeq": 678760103,
    //        "apRp": "0",
    //        "bonusChangedAmountRv": "0",
    //        "bpRp": "0",
    //        "clOrdID": '',
    //        "cl_req_code": 0,
    //        "closedPnlRv": "0",
    //        "closedSize": "0",
    //        "code": 0,
    //        "cumFeeRv": "0",
    //        "cumQty": "0.001",
    //        "cumValueRv": "20.849",
    //        "curAccBalanceRv": "19.9874906",
    //        "curAssignedPosBalanceRv": "0",
    //        "curBonusBalanceRv": "0",
    //        "curLeverageRr": "-10",
    //        "curPosSide": "Buy",
    //        "curPosSize": "0.001",
    //        "curPosTerm": 1,
    //        "curPosValueRv": "20.849",
    //        "curRiskLimitRv": "1000000",
    //        "currency": "USDT",
    //        "cxlRejReason": 0,
    //        "displayQty": "0.001",
    //        "execFeeRv": "0.0125094",
    //        "execID": "b88d2950-04a2-52d8-8927-346059900242",
    //        "execPriceRp": "20849",
    //        "execQty": "0.001",
    //        "execSeq": 678760103,
    //        "execStatus": "TakerFill",
    //        "execValueRv": "20.849",
    //        "feeRateRr": "0.0006",
    //        "lastLiquidityInd": "RemovedLiquidity",
    //        "leavesQty": "0",
    //        "leavesValueRv": "0",
    //        "message": "No error",
    //        "ordStatus": "Filled",
    //        "ordType": "ccxt.Market",
    //        "orderID": "79620ed2-54c6-4645-a35c-7057e687c576",
    //        "orderQty": "0.001",
    //        "pegOffsetProportionRr": "0",
    //        "pegOffsetValueRp": "0",
    //        "posSide": "Long",
    //        "priceRp": "21476.3",
    //        "relatedPosTerm": 1,
    //        "relatedReqNum": 4,
    //        "side": "Buy",
    //        "slTrigger": "ByMarkPrice",
    //        "stopLossRp": "0",
    //        "stopPxRp": "0",
    //        "symbol": "BTCUSDT",
    //        "takeProfitRp": "0",
    //        "timeInForce": "ImmediateOrCancel",
    //        "tpTrigger": "ByLastPrice",
    //        "tradeType": "ccxt.Trade",
    //        "transactTimeNs": "1674110665387882268",
    //        "userID": 4018340
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "orderID")
    var clientOrderId interface{} = this.SafeString(order, "clOrdID")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(clientOrderId, nil))) && ccxt.IsTrue((ccxt.IsLessThan(ccxt.GetLength(clientOrderId), 1)))) {
        clientOrderId = nil
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "ordStatus"))
    var side interface{} = this.SafeStringLower(order, "side")
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "ordType"))
    var price interface{} = this.SafeString(order, "priceRp", this.FromEp(this.SafeString(order, "priceEp"), market))
    var amount interface{} = this.SafeString(order, "orderQty")
    var filled interface{} = this.SafeString(order, "cumQty")
    var remaining interface{} = this.SafeString(order, "leavesQty")
    var timestamp interface{} = this.SafeIntegerProduct(order, "actionTimeNs", 0.000001)
    var cost interface{} = this.SafeString(order, "cumValueRv", this.FromEv(this.SafeString(order, "cumValueEv"), market))
    var lastTradeTimestamp interface{} = this.SafeIntegerProduct(order, "transactTimeNs", 0.000001)
    if ccxt.IsTrue(ccxt.IsEqual(lastTradeTimestamp, 0)) {
        lastTradeTimestamp = nil
    }
    var timeInForce interface{} = this.ParseTimeInForce(this.SafeString(order, "timeInForce"))
    var stopPrice interface{} = this.SafeString(order, "stopPx")
    var postOnly interface{} =     (ccxt.IsEqual(timeInForce, "PO"))
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "cost": cost,
        "average": nil,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *PhemexCore) HandleMessage(client interface{}, message interface{})  {
    // private spot update
    // {
    //     "orders": { closed: [ ], fills: [ ], open: [] },
    //     "sequence": 40435835,
    //     "timestamp": "1650443245600839241",
    //     "type": "snapshot",
    //     "wallets": [
    //       {
    //         "balanceEv": 0,
    //         "currency": "BTC",
    //         "lastUpdateTimeNs": "1650442638722099092",
    //         "lockedTradingBalanceEv": 0,
    //         "lockedWithdrawEv": 0,
    //         "userID": 2647224
    //       },
    //       {
    //         "balanceEv": 1154232337,
    //         "currency": "USDT",
    //         "lastUpdateTimeNs": "1650442617610017597",
    //         "lockedTradingBalanceEv": 0,
    //         "lockedWithdrawEv": 0,
    //         "userID": 2647224
    //       }
    //     ]
    // }
    // private swap update
    // {
    //     "sequence": 83839628,
    //     "timestamp": "1650382581827447829",
    //     "type": "snapshot",
    //     "accounts": [
    //       {
    //         "accountBalanceEv": 0,
    //         "accountID": 26472240001,
    //         "bonusBalanceEv": 0,
    //         "currency": "BTC",
    //         "totalUsedBalanceEv": 0,
    //         "userID": 2647224
    //       }
    //     ],
    //     "orders": [],
    //     "positions": [
    //       {
    //         "accountID": 26472240001,
    //         "assignedPosBalanceEv": 0,
    //         "avgEntryPriceEp": 0,
    //         "bankruptCommEv": 0,
    //         "bankruptPriceEp": 0,
    //         "buyLeavesQty": 0,
    //         "buyLeavesValueEv": 0,
    //         "buyValueToCostEr": 1150750,
    //         "createdAtNs": 0,
    //         "crossSharedBalanceEv": 0,
    //         "cumClosedPnlEv": 0,
    //         "cumFundingFeeEv": 0,
    //         "cumTransactFeeEv": 0,
    //         "curTermRealisedPnlEv": 0,
    //         "currency": "BTC",
    //         "dataVer": 2,
    //         "deleveragePercentileEr": 0,
    //         "displayLeverageEr": 10000000000,
    //         "estimatedOrdLossEv": 0,
    //         "execSeq": 0,
    //         "freeCostEv": 0,
    //         "freeQty": 0,
    //         "initMarginReqEr": 1000000,
    //         "lastFundingTime": "1640601827712091793",
    //         "lastTermEndTime": 0,
    //         "leverageEr": 0,
    //         "liquidationPriceEp": 0,
    //         "maintMarginReqEr": 500000,
    //         "makerFeeRateEr": 0,
    //         "markPriceEp": 507806777,
    //         "orderCostEv": 0,
    //         "posCostEv": 0,
    //         "positionMarginEv": 0,
    //         "positionStatus": "Normal",
    //         "riskLimitEv": 10000000000,
    //         "sellLeavesQty": 0,
    //         "sellLeavesValueEv": 0,
    //         "sellValueToCostEr": 1149250,
    //         "side": "None",
    //         "size": 0,
    //         "symbol": "BTCUSD",
    //         "takerFeeRateEr": 0,
    //         "term": 1,
    //         "transactTimeNs": 0,
    //         "unrealisedPnlEv": 0,
    //         "updatedAtNs": 0,
    //         "usedBalanceEv": 0,
    //         "userID": 2647224,
    //         "valueEv": 0
    //       }
    //     ]
    // }
    var id interface{} = this.SafeString(message, "id")
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
        var method interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        if ccxt.IsTrue(!ccxt.IsEqual(method, true)) {
            ccxt.CallDynamically(method, client, message)
            return
        }
    }
    var methodName interface{} = this.SafeString(message, "method", "")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "market24h"))) || ccxt.IsTrue((ccxt.InOp(message, "spot_market24h")))) || ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(methodName, "perp_market24h_pack_p"), 0)))) {
        this.HandleTicker(client, message)
        return
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "trades"))) || ccxt.IsTrue((ccxt.InOp(message, "trades_p")))) {
        this.HandleTrades(client, message)
        return
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "kline"))) || ccxt.IsTrue((ccxt.InOp(message, "kline_p")))) {
        this.HandleOHLCV(client, message)
        return
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "book"))) || ccxt.IsTrue((ccxt.InOp(message, "orderbook_p")))) {
        this.HandleOrderBook(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "orders"))) || ccxt.IsTrue((ccxt.InOp(message, "orders_p")))) {
        var orders interface{} = this.SafeValue2(message, "orders", "orders_p", map[string]interface{} {})
        this.HandleOrders(client, orders)
    }
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(message, "accounts"))) || ccxt.IsTrue((ccxt.InOp(message, "accounts_p")))) || ccxt.IsTrue((ccxt.InOp(message, "wallets")))) {
        var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(message, "accounts"))), "swap", "spot")
        if ccxt.IsTrue(ccxt.InOp(message, "accounts_p")) {
            typeVar = "perpetual"
        }
        var accounts interface{} = this.SafeValueN(message, []interface{}{"accounts", "accounts_p", "wallets"}, []interface{}{})
        this.HandleBalance(typeVar, client, accounts)
    }
}
func  (this *PhemexCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    // {
    //     "error": null,
    //     "id": 1234,
    //     "result": {
    //       "status": "success"
    //     }
    // }
    //
    var result interface{} = this.SafeValue(message, "result")
    var status interface{} = this.SafeString(result, "status")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(ccxt.IsEqual(status, "success")) {
        client.(ccxt.ClientInterface).Resolve(message, messageHash)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
func  (this *PhemexCore) SubscribePrivate(typeVar interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15418)
        
            retRes15428 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes15428)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.Seconds()
            var settleIsUSDT interface{} =     (ccxt.IsEqual(this.SafeValue(params, "settle", ""), "USDT"))
            params = this.Omit(params, "settle")
            var channel interface{} = "aop.subscribe"
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                channel = "wo.subscribe"
            }
            if ccxt.IsTrue(settleIsUSDT) {
                channel = "aop_p.subscribe"
            }
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "method": channel,
                "params": []interface{}{},
            }
            request = this.Extend(request, params)
        
                retRes156015 :=  (<-this.Watch(url, messageHash, request, channel))
                ccxt.PanicOnError(retRes156015)
                ch <- retRes156015
                return nil
        
            }()
            return ch
        }
func  (this *PhemexCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = "authenticated"
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                var expiryDelta interface{} = this.SafeInteger(this.Options, "expires", 120)
                var expiration interface{} = ccxt.Add(this.Seconds(), expiryDelta)
                var payload interface{} = ccxt.Add(this.ApiKey, ccxt.ToString(expiration))
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256)
                var method interface{} = "user.auth"
                var request interface{} = map[string]interface{} {
                    "method": method,
                    "params": []interface{}{"API", this.ApiKey, signature, expiration},
                    "id": requestId,
                }
                var subscriptionHash interface{} = ccxt.ToString(requestId)
                var message interface{} = this.Extend(request, params)
                if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash, this.HandleAuthenticate)
                }
                
            future = (<-this.Watch(url, messageHash, message, messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }


func (this *PhemexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
