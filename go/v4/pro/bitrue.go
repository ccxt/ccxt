package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitrueCore struct {
	*ccxt.BitrueCore
	base *ccxt.BitrueCore
}

func NewBitrueCore() *BitrueCore {
    p := &BitrueCore{}
	base := &ccxt.BitrueCore{}
	p.base = base
	p.BitrueCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitrueCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": false,
            "watchTickers": false,
            "watchTrades": false,
            "watchMyTrades": false,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "open": "https://open.bitrue.com",
                "ws": map[string]interface{} {
                    "public": "wss://ws.bitrue.com/market/ws",
                    "private": "wss://wsapi.bitrue.com",
                },
            },
        },
        "api": map[string]interface{} {
            "open": map[string]interface{} {
                "v1": map[string]interface{} {
                    "private": map[string]interface{} {
                        "post": map[string]interface{} {
                            "poseidon/api/v1/listenKey": 1,
                        },
                        "put": map[string]interface{} {
                            "poseidon/api/v1/listenKey/{listenKey}": 1,
                        },
                        "delete": map[string]interface{} {
                            "poseidon/api/v1/listenKey/{listenKey}": 1,
                        },
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "listenKeyRefreshRate": 1800000,
            "ws": map[string]interface{} {
                "gunzip": true,
            },
        },
    })
}
/**
 * @method
 * @name bitrue#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#balance-update
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BitrueCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            url:= (<-this.Authenticate())
            ccxt.PanicOnError(url)
            var messageHash interface{} = "balance"
            var message interface{} = map[string]interface{} {
                "event": "sub",
                "params": map[string]interface{} {
                    "channel": "user_balance_update",
                },
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes7615 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes7615)
                ch <- retRes7615
                return nil
        
            }()
            return ch
        }
func  (this *BitrueCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "BALANCE",
    //         "x": "OutboundAccountPositionTradeEvent",
    //         "E": 1657799510175,
    //         "I": "302274978401288200",
    //         "i": 1657799510175,
    //         "B": [{
    //                 "a": "btc",
    //                 "F": "0.0006000000000000",
    //                 "T": 1657799510000,
    //                 "f": "0.0006000000000000",
    //                 "t": 0
    //             },
    //             {
    //                 "a": "usdt",
    //                 "T": 0,
    //                 "L": "0.0000000000000000",
    //                 "l": "-11.8705317318000000",
    //                 "t": 1657799510000
    //             }
    //         ],
    //         "u": 1814396
    //     }
    //
    //     {
    //      "e": "BALANCE",
    //      "x": "OutboundAccountPositionOrderEvent",
    //      "E": 1670051332478,
    //      "I": "353662845694083072",
    //      "i": 1670051332478,
    //      "B": [
    //        {
    //          "a": "eth",
    //          "F": "0.0400000000000000",
    //          "T": 1670051332000,
    //          "f": "-0.0100000000000000",
    //          "L": "0.0100000000000000",
    //          "l": "0.0100000000000000",
    //          "t": 1670051332000
    //        }
    //      ],
    //      "u": 2285311
    //    }
    //
    var balances interface{} = this.SafeValue(message, "B", []interface{}{})
    this.ParseWSBalances(balances)
    var messageHash interface{} = "balance"
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *BitrueCore) ParseWSBalances(balances interface{})  {
    //
    //    [{
    //         "a": "btc",
    //         "F": "0.0006000000000000",
    //         "T": 1657799510000,
    //         "f": "0.0006000000000000",
    //         "t": 0
    //     },
    //     {
    //         "a": "usdt",
    //         "T": 0,
    //         "L": "0.0000000000000000",
    //         "l": "-11.8705317318000000",
    //         "t": 1657799510000
    //     }]
    //
    ccxt.AddElementToObject(this.Balance, "info", balances)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
        var balance interface{} = ccxt.GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "a")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var free interface{} = this.SafeString(balance, "F")
        var used interface{} = this.SafeString(balance, "L")
        var balanceUpdateTime interface{} = this.SafeInteger(balance, "T", 0)
        var lockBalanceUpdateTime interface{} = this.SafeInteger(balance, "t", 0)
        var updateFree interface{} = !ccxt.IsEqual(balanceUpdateTime, 0)
        var updateUsed interface{} = !ccxt.IsEqual(lockBalanceUpdateTime, 0)
        if ccxt.IsTrue(ccxt.IsTrue(updateFree) || ccxt.IsTrue(updateUsed)) {
            if ccxt.IsTrue(updateFree) {
                ccxt.AddElementToObject(account, "free", free)
            }
            if ccxt.IsTrue(updateUsed) {
                ccxt.AddElementToObject(account, "used", used)
            }
            ccxt.AddElementToObject(this.Balance, code, account)
        }
    }
    this.Balance = this.SafeBalance(this.Balance)
}
/**
 * @method
 * @name bitrue#watchOrders
 * @description watches information on user orders
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#order-update
 * @param {string} symbol
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum amount of orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order structure]{@link https://docs.ccxt.com/?id=order-structure} indexed by market symbols
 */
func  (this *BitrueCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1858)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
        
            url:= (<-this.Authenticate())
            ccxt.PanicOnError(url)
            var messageHash interface{} = "orders"
            var message interface{} = map[string]interface{} {
                "event": "sub",
                "params": map[string]interface{} {
                    "channel": "user_order_update",
                },
            }
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitrueCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "e": "ORDER",
    //        "i": 16122802798,
    //        "E": 1657882521876,
    //        "I": "302623154710888464",
    //        "u": 1814396,
    //        "s": "btcusdt",
    //        "S": 2,
    //        "o": 1,
    //        "q": "0.0005",
    //        "p": "60000",
    //        "X": 0,
    //        "x": 1,
    //        "z": "0",
    //        "n": "0",
    //        "N": "usdt",
    //        "O": 1657882521876,
    //        "L": "0",
    //        "l": "0",
    //        "Y": "0"
    //    }
    //
    var parsed interface{} = this.ParseWsOrder(message)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *BitrueCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "e": "ORDER",
    //        "i": 16122802798,
    //        "E": 1657882521876,
    //        "I": "302623154710888464",
    //        "u": 1814396,
    //        "s": "btcusdt",
    //        "S": 2,
    //        "o": 1,
    //        "q": "0.0005",
    //        "p": "60000",
    //        "X": 0,
    //        "x": 1,
    //        "z": "0",
    //        "n": "0",
    //        "N": "usdt",
    //        "O": 1657882521876,
    //        "L": "0",
    //        "l": "0",
    //        "Y": "0"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "E")
    var marketId interface{} = this.SafeStringUpper(order, "s")
    var typeId interface{} = this.SafeString(order, "o")
    var sideId interface{} = this.SafeInteger(order, "S")
    // 1: buy
    // 2: sell
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, 1))), "buy", "sell")
    var statusId interface{} = this.SafeString(order, "X")
    var feeCurrencyId interface{} = this.SafeString(order, "N")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "i"),
        "clientOrderId": this.SafeString(order, "c"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "T"),
        "symbol": this.SafeSymbol(marketId, market),
        "type": this.ParseWsOrderType(typeId),
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "p"),
        "triggerPrice": nil,
        "amount": this.SafeString(order, "q"),
        "cost": this.SafeString(order, "Y"),
        "average": nil,
        "filled": this.SafeString(order, "z"),
        "remaining": nil,
        "status": this.ParseWsOrderStatus(statusId),
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": this.SafeNumber(order, "n"),
        },
    }, market)
}
func  (this *BitrueCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3028)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var marketIdLowercase interface{} = ccxt.ToLower(ccxt.GetValue(market, "id"))
            var channel interface{} = ccxt.Add(ccxt.Add("market_", marketIdLowercase), "_simple_depth_step0")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var message interface{} = map[string]interface{} {
                "event": "sub",
                "params": map[string]interface{} {
                    "cb_id": marketIdLowercase,
                    "channel": channel,
                },
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes31715 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes31715)
                ch <- retRes31715
                return nil
        
            }()
            return ch
        }
func  (this *BitrueCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "market_ethbtc_simple_depth_step0",
    //         "ts": 1670056708670,
    //         "tick": {
    //             "buys": [
    //                 [
    //                     "0.075170",
    //                     "67.153"
    //                 ],
    //                 [
    //                     "0.075169",
    //                     "17.195"
    //                 ],
    //                 [
    //                     "0.075166",
    //                     "29.788"
    //                 ],
    //             ]
    //              "asks": [
    //                 [
    //                     "0.075171",
    //                     "0.256"
    //                 ],
    //                 [
    //                     "0.075172",
    //                     "0.160"
    //                 ],
    //             ]
    //         }
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, "_")
    var marketId interface{} = this.SafeStringUpper(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(tick, symbol, timestamp, "buys", "asks")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BitrueCore) ParseWsOrderType(typeId interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "1": "limit",
        "2": "market",
        "3": "limit",
    }
    return this.SafeString(types, typeId, typeId)
}
func  (this *BitrueCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "open",
        "1": "open",
        "2": "closed",
        "3": "open",
        "4": "canceled",
        "7": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *BitrueCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *BitrueCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            //     {
            //         "ping": 1670057540627
            //     }
            //
            var time interface{} = this.SafeInteger(message, "ping")
            var pong interface{} = map[string]interface{} {
                "pong": time,
            }
        
            retRes4058 := (<-client.(ccxt.ClientInterface).Send(pong))
            ccxt.PanicOnError(retRes4058)
                return nil
            }()
            return ch
        }
func  (this *BitrueCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.InOp(message, "channel")) {
        this.HandleOrderBook(client, message)
    } else if ccxt.IsTrue(ccxt.InOp(message, "ping")) {
        this.HandlePing(client, message)
    } else {
        var event interface{} = this.SafeString(message, "e")
        var handlers interface{} = map[string]interface{} {
            "BALANCE": this.HandleBalance,
            "ORDER": this.HandleOrder,
        }
        var handler interface{} = this.SafeValue(handlers, event)
        if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
            ccxt.CallDynamically(handler, client, message)
        }
    }
}
func  (this *BitrueCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeValue(this.Options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                response:= (<-this.OpenV1PrivatePostPoseidonApiV1ListenKey(params))
                ccxt.PanicOnError(response)
                //
                //     {
                //         "msg": "succ",
                //         "code": 200,
                //         "data": {
                //             "listenKey": "7d1ec51340f499d85bb33b00a96ef680bda28869d5c3374a444c5ca4847d1bf0"
                //         }
                //     }
                //
                var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                var key interface{} = this.SafeString(data, "listenKey")
                ccxt.AddElementToObject(this.Options, "listenKey", key)
                ccxt.AddElementToObject(this.Options, "listenKeyUrl", ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/stream?listenKey="), key))
                var refreshTimeout interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1800000)
                this.Delay(refreshTimeout, this.KeepAliveListenKey)
            }
        
            ch <- ccxt.GetValue(this.Options, "listenKeyUrl")
            return nil
        
            }()
            return ch
        }
func  (this *BitrueCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            var request interface{} = map[string]interface{} {
                "listenKey": listenKey,
            }
            
                {
                     func(this *BitrueCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *BitrueCore) interface{} {
                                    // catch block:
                                            ccxt.AddElementToObject(this.Options, "listenKey", nil)
                    ccxt.AddElementToObject(this.Options, "listenKeyUrl", nil)
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes45512 := (<-this.OpenV1PrivatePutPoseidonApiV1ListenKeyListenKey(this.Extend(request, params)))
                    ccxt.PanicOnError(retRes45512)
            		    return nil
            	    }(this)
                
                    }
            var refreshTimeout interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1800000)
            this.Delay(refreshTimeout, this.KeepAliveListenKey)
                return nil
            }()
            return ch
        }


func (this *BitrueCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
