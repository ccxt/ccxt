package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ToobitCore struct {
	*ccxt.ToobitCore
	base *ccxt.ToobitCore
}

func NewToobitCore() *ToobitCore {
    p := &ToobitCore{}
	base := &ccxt.ToobitCore{}
	p.base = base
	p.ToobitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ToobitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "common": "wss://stream.toobit.com",
                },
            },
        },
        "options": map[string]interface{} {
            "ws": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "1h",
                    "2h": "2h",
                    "4h": "4h",
                    "6h": "6h",
                    "8h": "8h",
                    "12h": "12h",
                    "1d": "1d",
                    "1w": "1w",
                    "1M": "1M",
                },
                "watchOrderBook": map[string]interface{} {
                    "channel": "depth",
                },
                "listenKeyRefreshRate": 1200000,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": ccxt.Multiply(ccxt.Multiply((ccxt.Subtract(60, 1)), 5), 1000),
            "ping": this.Ping,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {},
            },
        },
    })
}
func  (this *ToobitCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "ping": this.Milliseconds(),
    }
}
func  (this *ToobitCore) HandleMessage(client interface{}, message interface{})  {
    //
    // public
    //
    //     {
    //         topic: "trade",
    //         symbol: "DOGEUSDT",
    //         symbolName: "DOGEUSDT",
    //         params: {
    //             realtimeInterval: "24h",
    //             binary: "false",
    //         },
    //         data: [
    //             {
    //                 v: "4864732022868004630",
    //                 t: 1757243788405,
    //                 p: "0.21804",
    //                 q: "80",
    //                 m: true,
    //             },
    //         ],
    //         f: true,  // initial first snapshot or not
    //         sendTime: 1757244002117,
    //         shared: false,
    //     }
    //
    // private
    //
    //     [
    //       {
    //         e: 'outboundContractAccountInfo',
    //         E: '1758228398234',
    //         T: true,
    //         W: true,
    //         D: true,
    //         B: [ [Object] ]
    //       }
    //     ]
    //
    var topic interface{} = this.SafeString(message, "topic")
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    // handle ping-pong: { ping: 1758540450000 }
    //
    var pongTimestamp interface{} = this.SafeInteger(message, "pong")
    if ccxt.IsTrue(!ccxt.IsEqual(pongTimestamp, nil)) {
        this.HandleIncomingPong(client, pongTimestamp)
        return
    }
    var methods interface{} = map[string]interface{} {
        "trade": this.HandleTrades,
        "kline": this.HandleOHLCV,
        "realtimes": this.HandleTickers,
        "depth": this.HandleOrderBookPartialSnapshot,
        "diffDepth": this.HandleOrderBook,
        "outboundAccountInfo": this.HandleBalance,
        "outboundContractAccountInfo": this.HandleBalance,
        "executionReport": this.HandleOrder,
        "contractExecutionReport": this.HandleOrder,
        "ticketInfo": this.HandleMyTrade,
        "outboundContractPositionInfo": this.HandlePositions,
    }
    var method interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    } else {
        // check private streams
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
            var item interface{} = ccxt.GetValue(message, i)
            var event interface{} = this.SafeString(item, "e")
            var method2 interface{} = this.SafeValue(methods, event)
            if ccxt.IsTrue(!ccxt.IsEqual(method2, nil)) {
                ccxt.CallDynamically(method2, client, item)
            }
        }
    }
}
func  (this *ToobitCore) HandleIncomingPong(client interface{}, pongTimestamp interface{})  {
    client.(ccxt.ClientInterface).SetLastPong(pongTimestamp)
}
/**
 * @method
 * @name toobit#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#trade-streams
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *ToobitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes17415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes17415)
                ch <- retRes17415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name toobit#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#trade-streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *ToobitCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1908)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade::", symbol))
                var rawHash interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "common"), "/quote/ws/v1")
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.Join(marketIds, ","),
                "topic": "trade",
                "event": "sub",
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         symbol: "DOGEUSDT",
    //         symbolName: "DOGEUSDT",
    //         topic: "trade",
    //         params: {
    //             realtimeInterval: "24h",
    //             binary: "false",
    //         },
    //         data: [
    //             {
    //                 v: "4864732022868004630",
    //                 t: 1757243788405,
    //                 p: "0.21804",
    //                 q: "80",
    //                 m: true,
    //             },
    //         ],
    //         f: true,  // initial first snapshot or not
    //         sendTime: 1757244002117,
    //         shared: false,
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var parsed interface{} = this.ParseWsTrades(data, market)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        var trade interface{} = ccxt.GetValue(parsed, i)
        ccxt.AddElementToObject(trade, "symbol", symbol)
        stored.(ccxt.Appender).Append(trade)
    }
    var messageHash interface{} = ccxt.Add("trade::", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *ToobitCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTrade(trade, market)
}
/**
 * @method
 * @name toobit#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ToobitCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name toobit#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ToobitCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2948)
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "common"), "/quote/ws/v1")
            var messageHashes interface{} = []interface{}{}
            var timeframes interface{} = this.SafeDict(ccxt.GetValue(this.Options, "ws"), "timeframes", map[string]interface{} {})
            var marketIds interface{} = []interface{}{}
            var selectedTimeframe interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolStr interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolStr)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var unfiedTimeframe interface{} = this.SafeString(data, 1, "1m")
                var rawTimeframe interface{} = this.SafeString(timeframes, unfiedTimeframe, unfiedTimeframe)
                if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(selectedTimeframe, nil)) && ccxt.IsTrue(!ccxt.IsEqual(selectedTimeframe, rawTimeframe))) {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchOHLCVForSymbols() only supports a single timeframe for all symbols")))
                } else {
                    selectedTimeframe = rawTimeframe
                }
                ccxt.AppendToArray(&marketIds, marketId)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbolStr), "::"), unfiedTimeframe))
            }
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.Join(marketIds, ","),
                "topic": ccxt.Add("kline_", selectedTimeframe),
                "event": "sub",
            }
            symboltimeframestoredVariable := (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         symbol: 'DOGEUSDT',
    //         symbolName: 'DOGEUSDT',
    //         klineType: '1m',
    //         topic: 'kline',
    //         params: { realtimeInterval: '24h', klineType: '1m', binary: 'false' },
    //         data: [
    //             {
    //                 t: 1757251200000,
    //                 s: 'DOGEUSDT',
    //                 sn: 'DOGEUSDT',
    //                 c: '0.21889',
    //                 h: '0.21898',
    //                 l: '0.21889',
    //                 o: '0.21897',
    //                 v: '5247',
    //                 st: 0
    //             }
    //         ],
    //         f: true,
    //         sendTime: 1757251217643,
    //         shared: false
    //     }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var timeframeId interface{} = this.SafeString(params, "klineType")
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var parsed interface{} = this.ParseWsOHLCV(ccxt.GetValue(data, i), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *ToobitCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //             {
    //                 t: 1757251200000,
    //                 o: '0.21897',
    //                 h: '0.21898',
    //                 l: '0.21889',
    //                 c: '0.21889',
    //                 v: '5247',
    //                 s: 'DOGEUSDT',
    //                 sn: 'DOGEUSDT',
    //                 st: 0
    //             }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var parsed interface{} = this.ParseOHLCV(ohlcv, market)
    return parsed
}
/**
 * @method
 * @name toobit#watchTicker
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#individual-symbol-ticker-streams
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ToobitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4068)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name toobit#watchTickers
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#individual-symbol-ticker-streams
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ToobitCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4228)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker::", symbol))
                var rawHash interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "common"), "/quote/ws/v1")
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.Join(marketIds, ","),
                "topic": "realtimes",
                "event": "sub",
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleTickers(client interface{}, message interface{})  {
    //
    //    {
    //        "symbol": "DOGEUSDT",
    //        "symbolName": "DOGEUSDT",
    //        "topic": "realtimes",
    //        "params": {
    //            "realtimeInterval": "24h"
    //        },
    //        "data": [
    //            {
    //                "t": 1757257643683,
    //                "s": "DOGEUSDT",
    //                "o": "0.21462",
    //                "h": "0.22518",
    //                "l": "0.21229",
    //                "c": "0.2232",
    //                "v": "283337017",
    //                "qv": "62063771.42702",
    //                "sn": "DOGEUSDT",
    //                "m": "0.04",
    //                "e": 301,
    //                "c24h": "0.2232",
    //                "h24h": "0.22518",
    //                "l24h": "0.21229",
    //                "o24h": "0.21462",
    //                "v24h": "283337017",
    //                "qv24h": "62063771.42702",
    //                "m24h": "0.04"
    //            }
    //        ],
    //        "f": false,
    //        "sendTime": 1757257643751,
    //        "shared": false
    //    }
    //
    var data interface{} = this.SafeList(message, "data")
    var newTickers interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseWsTicker(ticker)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, parsed)
        ccxt.AddElementToObject(newTickers, symbol, parsed)
        var messageHash interface{} = ccxt.Add("ticker::", symbol)
        client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(newTickers, "tickers")
}
func  (this *ToobitCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTicker(ticker, market)
}
/**
 * @method
 * @name toobit#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#partial-book-depth-streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ToobitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes51415 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes51415)
                ch <- retRes51415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name toobit#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#partial-book-depth-streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ToobitCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5288)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "channel", "depth")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var messageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("orderBook::", symbol), "::"), channel))
                var rawHash interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "common"), "/quote/ws/v1")
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.Join(marketIds, ","),
                "topic": channel,
                "event": "sub",
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         symbol: 'DOGEUSDT',
    //         symbolName: 'DOGEUSDT',
    //         topic: 'depth',
    //         params: { realtimeInterval: '24h' },
    //         data: [
    //             {
    //             e: 301,
    //             t: 1757304842860,
    //             v: '9814355_1E-18',
    //             b: [Array],
    //             a: [Array],
    //             o: 0
    //             }
    //         ],
    //         f: false,
    //         sendTime: 1757304843047,
    //         shared: false
    //     }
    //
    var isSnapshot interface{} = this.SafeBool(message, "f", false)
    if ccxt.IsTrue(isSnapshot) {
        this.SetOrderBookSnapshot(client, message, "diffDepth")
        return
    }
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var entry interface{} = ccxt.GetValue(data, i)
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderBook::", symbol), "::"), "diffDepth")
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var limit interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "orderBookLimit", 1000)
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.SafeInteger(entry, "t")
        var bids interface{} = this.SafeList(entry, "b", []interface{}{})
        var asks interface{} = this.SafeList(entry, "a", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderBook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderBook, "bids"), bids)
        ccxt.AddElementToObject(orderBook, "timestamp", timestamp)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderBook)
        client.(ccxt.ClientInterface).Resolve(orderBook, messageHash)
    }
}
func  (this *ToobitCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *ToobitCore) HandleOrderBookPartialSnapshot(client interface{}, message interface{})  {
    //
    //     {
    //         symbol: 'DOGEUSDT',
    //         symbolName: 'DOGEUSDT',
    //         topic: 'depth',
    //         params: { realtimeInterval: '24h' },
    //         data: [
    //             {
    //             e: 301,
    //             s: 'DOGEUSDT',
    //             t: 1757304842860,
    //             v: '9814355_1E-18',
    //             b: [Array],
    //             a: [Array],
    //             o: 0
    //             }
    //         ],
    //         f: false,
    //         sendTime: 1757304843047,
    //         shared: false
    //     }
    //
    this.SetOrderBookSnapshot(client, message, "depth")
}
func  (this *ToobitCore) SetOrderBookSnapshot(client interface{}, message interface{}, channel interface{})  {
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsEqual(length, 0)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, length); i++ {
        var entry interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(entry, "s")
        var symbol interface{} = this.SafeSymbol(marketId)
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderBook::", symbol), "::"), channel)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var limit interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "orderBookLimit", 1000)
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.SafeInteger(entry, "t")
        var snapshot interface{} = this.ParseOrderBook(entry, symbol, timestamp, "b", "a")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
/**
 * @method
 * @name toobit#watchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-account-update
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *ToobitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6658)
        
            retRes6668 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6668)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(marketType, "spot"))
            var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
            var spotSubHash interface{} = "spot:balance"
            var swapSubHash interface{} = "contract:private"
            var spotMessageHash interface{} = "spot:balance"
            var swapMessageHash interface{} = "contract:balance"
            var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotMessageHash, swapMessageHash)
            var subscriptionHash interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotSubHash, swapSubHash)
            var url interface{} = this.GetUserStreamUrl()
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, marketType, subscriptionHash, params)
            client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot"))
        
                retRes68115 :=  (<-this.Watch(url, messageHash, params, subscriptionHash))
                ccxt.PanicOnError(retRes68115)
                ch <- retRes68115
                return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) SetBalanceCache(client interface{}, marketType interface{}, optionalArgs ...interface{})  {
    subscriptionHash := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscriptionHash
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)) {
        return
    }
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marketType, "spot"))), "spot", "contract")
    var messageHash interface{} = ccxt.Add(typeVar, ":fetchBalanceSnapshot")
    if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
        client.(ccxt.ClientInterface).Future(messageHash)
        this.Spawn(this.LoadBalanceSnapshot, client, messageHash, marketType)
    }
}
func  (this *ToobitCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    // [
    //     {
    //         e: 'outboundAccountInfo',
    //         E: '1758226989725',
    //         T: true,
    //         W: true,
    //         D: true,
    //         B: [
    //             {
    //               a: "USDT",
    //               f: "6.37242839",
    //               l: "0",
    //             },
    //         ]
    //     }
    // ]
    //
    // contract
    //
    // [
    //     {
    //         e: 'outboundContractAccountInfo',
    //         E: '1758226989742',
    //         T: true,
    //         W: true,
    //         D: true,
    //         B: [ [Object] ]
    //     }
    // ]
    //
    var channel interface{} = this.SafeString(message, "e")
    var data interface{} = this.SafeList(message, "B", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "E")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(channel, "outboundContractAccountInfo"))), "contract", "spot")
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar))) {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "info", data)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var balance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "a")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "info", balance)
        ccxt.AddElementToObject(account, "used", this.SafeString(balance, "l"))
        ccxt.AddElementToObject(account, "free", this.SafeString(balance, "f"))
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
    }
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(ccxt.GetValue(this.Balance, typeVar)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
}
func  (this *ToobitCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, marketType interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            response:= (<-this.FetchBalance(map[string]interface{} {
            "type": marketType,
        }))
            ccxt.PanicOnError(response)
            var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marketType, "spot"))), "spot", "contract")
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeDict(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve()
                client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":fetchBalanceSnapshot"))
                client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance")) // we should also resolve right away after snapshot, so user doesn't double-fetch balance
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name toobit#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-order-update
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ToobitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7798)
        
            retRes7808 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7808)
            var market interface{} = this.MarketOrNull(symbol)
            symbol = this.SafeString(market, "symbol", symbol)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var url interface{} = this.GetUserStreamUrl()
        
            orders:= (<-this.Watch(url, messageHash, params, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "e": "executionReport",
    //        "E": "1758311011844",
    //        "s": "DOGEUSDT",
    //        "c": "1758311011948",
    //        "S": "BUY",
    //        "o": "LIMIT",
    //        "f": "GTC",
    //        "q": "22",
    //        "p": "0.23",
    //        "pt": "INPUT",
    //        "X": "NEW",
    //        "i": "2043255292855185152",
    //        "l": "0", // Last executed quantity
    //        "z": "0", // Cumulative filled quantity
    //        "L": "0", // Last executed price
    //        "n": "0",
    //        "N": "",
    //        "u": true,
    //        "w": true,
    //        "m": false,
    //        "O": "1758311011833",
    //        "U": "1758311011841",
    //        "Z": "0",
    //        "C": false,
    //        "v": "0",
    //        "rp": "0",
    //        "td": "0"
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var order interface{} = this.ParseWsOrder(message)
    orders.(ccxt.Appender).Append(order)
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    messageHash = ccxt.Add("orders:", this.SafeString(order, "symbol"))
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
func  (this *ToobitCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "O")
    var marketId interface{} = this.SafeString(order, "s")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var priceType interface{} = this.SafeStringLower(order, "pt")
    var rawOrderType interface{} = this.SafeStringLower(order, "o")
    var orderType interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(priceType, "market")) {
        orderType = "market"
    } else {
        orderType = rawOrderType
    }
    var feeCost interface{} = this.SafeNumber(order, "n")
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": nil,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "i"),
        "clientOrderId": this.SafeString(order, "c"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": this.SafeInteger2(order, "U", "E"),
        "symbol": symbol,
        "type": orderType,
        "timeInForce": this.SafeStringUpper(order, "f"),
        "postOnly": nil,
        "side": this.SafeStringLower(order, "S"),
        "price": this.SafeString(order, "L"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": this.SafeString(order, "q"),
        "cost": nil,
        "average": this.SafeString(order, "p"),
        "filled": this.SafeString(order, "z"),
        "remaining": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "X")),
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name toobit#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#payload-ticket-push
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *ToobitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8998)
        
            retRes9008 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9008)
            var market interface{} = this.MarketOrNull(symbol)
            symbol = this.SafeString(market, "symbol", symbol)
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var url interface{} = this.GetUserStreamUrl()
        
            trades:= (<-this.Watch(url, messageHash, params, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //    {
    //        "e": "ticketInfo",
    //        "E": "1758314657847",
    //        "s": "DOGEUSDT",
    //        "q": "22.0",
    //        "t": "1758314657842",
    //        "p": "0.26667",
    //        "T": "4864732022877055421",
    //        "o": "2043285877770284800",
    //        "c": "1758314657002",
    //        "a": "1783404067076253952",
    //        "m": false,
    //        "S": "BUY"
    //    }
    //
    var myTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(myTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trade interface{} = this.ParseMyTrade(message)
    myTrades.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(trade, "symbol"))
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
    messageHash = "myTrades"
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
}
func  (this *ToobitCore) ParseMyTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "s")
    var ts interface{} = this.SafeString(trade, "t")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "T"),
        "timestamp": ts,
        "datetime": this.Iso8601(ts),
        "symbol": this.SafeSymbol(marketId, market),
        "order": this.SafeString(trade, "o"),
        "type": nil,
        "side": this.SafeStringLower(trade, "S"),
        "takerOrMaker": ccxt.Ternary(ccxt.IsTrue(this.SafeBool(trade, "m")), "maker", "taker"),
        "price": this.SafeString(trade, "p"),
        "amount": this.SafeString(trade, "q"),
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name toobit#watchPositions
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#event-position-update
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *ToobitCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9778 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9778)
        
            retRes9788 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9788)
            var messageHash interface{} = ""
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.MarketSymbols(symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var url interface{} = this.GetUserStreamUrl()
            var client interface{} = this.Client(url)
        
            retRes9868 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes9868)
            this.SetPositionsCache(client, symbols)
            var cache interface{} = this.Positions
            if ccxt.IsTrue(ccxt.IsEqual(cache, nil)) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
        
            newPositions:= (<-this.Watch(url, messageHash, nil, messageHash))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    isPortfolioMargin := ccxt.GetArg(optionalArgs, 1, false)
    _ = isPortfolioMargin
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if ccxt.IsTrue(ccxt.InOp(this.Positions, typeVar)) {
        return
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchPositionsSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash, typeVar, isPortfolioMargin)
        }
    } else {
        ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
    }
}
func  (this *ToobitCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}, typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
        
            positions:= (<-this.FetchPositions(nil, params))
            ccxt.PanicOnError(positions)
            ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
            var cache interface{} = ccxt.GetValue(this.Positions, typeVar)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                cache.(ccxt.Appender).Append(position)
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, ccxt.Add(typeVar, ":positions"))
            }
                return nil
            }()
            return ch
        }
func  (this *ToobitCore) HandlePositions(client interface{}, message interface{})  {
    //
    // [
    //     {
    //         e: 'outboundContractPositionInfo',
    //         E: '1758316454554',
    //         A: '1783404067076253954',
    //         s: 'DOGE-SWAP-USDT',
    //         S: 'LONG',
    //         p: '0',
    //         P: '0',
    //         a: '0',
    //         f: '0.1228',
    //         m: '0',
    //         r: '0',
    //         up: '0',
    //         pr: '0',
    //         pv: '0',
    //         v: '3.0',
    //         mt: 'CROSS',
    //         mm: '0',
    //         mp: '0.265410000000000000'
    //     }
    // ]
    //
    var subscriptions interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
    var accountType interface{} = ccxt.GetValue(subscriptions, 0)
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if !ccxt.IsTrue((ccxt.InOp(this.Positions, accountType))) {
        ccxt.AddElementToObject(this.Positions, accountType, ccxt.NewArrayCacheBySymbolBySide())
    }
    var cache interface{} = ccxt.GetValue(this.Positions, accountType)
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var rawPosition interface{} = ccxt.GetValue(message, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        var timestamp interface{} = this.SafeInteger(rawPosition, "E")
        ccxt.AddElementToObject(position, "timestamp", timestamp)
        ccxt.AddElementToObject(position, "datetime", this.Iso8601(timestamp))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(accountType, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(accountType, ":positions"))
}
func  (this *ToobitCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "s")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeSymbol(marketId, nil),
        "notional": this.OmitZero(this.SafeString(position, "pv")),
        "marginMode": this.SafeStringLower(position, "mt"),
        "liquidationPrice": this.SafeString(position, "f"),
        "entryPrice": this.SafeString(position, "p"),
        "unrealizedPnl": this.SafeString(position, "up"),
        "realizedPnl": this.SafeNumber(position, "r"),
        "percentage": nil,
        "contracts": nil,
        "contractSize": nil,
        "markPrice": this.SafeString(position, "mp"),
        "side": this.SafeStringLower(position, "S"),
        "hedged": nil,
        "timestamp": nil,
        "datetime": nil,
        "maintenanceMargin": this.SafeString(position, "mm"),
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": this.OmitZero(this.SafeString(position, "m")),
        "initialMarginPercentage": nil,
        "leverage": this.SafeString(position, "v"),
        "marginRatio": nil,
    })
}
func  (this *ToobitCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var client interface{} = this.Client(this.GetUserStreamUrl())
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
                var time interface{} = this.Milliseconds()
                var lastAuthenticatedTime interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "lastAuthenticatedTime", 0)
                var listenKeyRefreshRate interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "listenKeyRefreshRate", 1200000)
                var delay interface{} = this.Sum(listenKeyRefreshRate, 10000)
                if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), delay)) {
                    
                        {
                             func(this *ToobitCore) (ret_ interface{}) {
                    		    defer func() {
                                    if e := recover(); e != nil {
                                        if e == "break" {
                                            return
                                        }
                                        ret_ = func(this *ToobitCore) interface{} {
                                            // catch block:
                                                            err := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.ExceptionMessage(e)))
                                    client.(ccxt.ClientInterface).Reject(err, messageHash)
                                    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                                        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                                    }
                                            return nil
                                        }(this)
                                    }
                                }()
                    		    // try block:
                                                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, true)
                    
                                    response:= (<-this.PrivatePostApiV1UserDataStream(params))
                                    ccxt.PanicOnError(response)
                                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "listenKey", this.SafeString(response, "listenKey"))
                                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "lastAuthenticatedTime", time)
                                    future.(*ccxt.Future).Resolve(true)
                                    this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
                    		    return nil
                    	    }(this)
                        
                            }
                }
            }
        
                retRes115415 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes115415)
                ch <- retRes115415
                return nil
        
            }()
            return ch
        }
func  (this *ToobitCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "ws", map[string]interface{} {})
            var listenKey interface{} = this.SafeString(options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            
                {
                     func(this *ToobitCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *ToobitCore) interface{} {
                                    // catch block:
                                            var url interface{} = this.GetUserStreamUrl()
                    var client interface{} = this.Client(url)
                    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
                        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
                        client.(ccxt.ClientInterface).Reject(error, messageHash)
                    }
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "listenKey", nil)
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "lastAuthenticatedTime", 0)
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    response:= (<-this.PrivatePostApiV1UserDataStream(params))
                    ccxt.PanicOnError(response)
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "listenKey", this.SafeString(response, "listenKey"))
                    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "lastAuthenticatedTime", this.Milliseconds())
            		    return nil
            	    }(this)
                
                    }
            // whether or not to schedule another listenKey keepAlive request
            var listenKeyRefreshRate interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "ws"), "listenKeyRefreshRate", 1200000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
                return nil
            }()
            return ch
        }
func  (this *ToobitCore) GetUserStreamUrl() interface{}  {
    return ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "common"), "/api/v1/ws/"), ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "listenKey"))
}
func  (this *ToobitCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "code": '-100010',
    //        "desc": "Invalid Symbols!"
    //    }
    //
    var code interface{} = this.SafeString(message, "code")
    if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
        var desc interface{} = this.SafeString(message, "desc")
        var msg interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " code: "), code), " message: "), desc)
        exception := ccxt.ExchangeError(        msg) // c# fix
        client.(ccxt.ClientInterface).Reject(exception)
        return true
    }
    return false
}


func (this *ToobitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
