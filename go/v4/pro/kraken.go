package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type KrakenCore struct {
	*ccxt.KrakenCore
	base *ccxt.KrakenCore
}

func NewKrakenCore() *KrakenCore {
    p := &KrakenCore{}
	base := &ccxt.KrakenCore{}
	p.base = base
	p.KrakenCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *KrakenCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "cancelAllOrdersWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.kraken.com",
                    "private": "wss://ws-auth.kraken.com",
                    "privateV2": "wss://ws-auth.kraken.com/v2",
                    "publicV2": "wss://ws.kraken.com/v2",
                    "beta": "wss://beta-ws.kraken.com",
                    "beta-private": "wss://beta-ws-auth.kraken.com",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "ordersLimit": 1000,
            "symbolsByOrderId": map[string]interface{} {},
            "watchOrderBook": map[string]interface{} {
                "checksum": false,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 6000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "Event(s) not found": ccxt.BadRequest,
                },
                "broad": map[string]interface{} {
                    "Already subscribed": ccxt.BadRequest,
                    "ccxt.Currency pair not in ISO 4217-A3 format": ccxt.BadSymbol,
                    "ccxt.Currency pair not supported": ccxt.BadSymbol,
                    "Malformed request": ccxt.BadRequest,
                    "Pair field must be an array": ccxt.BadRequest,
                    "Pair field unsupported for this subscription type": ccxt.BadRequest,
                    "Pair(s) not found": ccxt.BadSymbol,
                    "Subscription book depth must be an integer": ccxt.BadRequest,
                    "Subscription depth not supported": ccxt.BadRequest,
                    "Subscription field must be an object": ccxt.BadRequest,
                    "Subscription name invalid": ccxt.BadRequest,
                    "Subscription object unsupported field": ccxt.BadRequest,
                    "Subscription ohlc interval must be an integer": ccxt.BadRequest,
                    "Subscription ohlc interval not supported": ccxt.BadRequest,
                    "Subscription ohlc requires interval": ccxt.BadRequest,
                    "EAccount:Invalid permissions": ccxt.PermissionDenied,
                    "EAuth:ccxt.Account temporary disabled": ccxt.AccountSuspended,
                    "EAuth:ccxt.Account unconfirmed": ccxt.AuthenticationError,
                    "EAuth:Rate limit exceeded": ccxt.RateLimitExceeded,
                    "EAuth:Too many requests": ccxt.RateLimitExceeded,
                    "EDatabase: Internal error (to be deprecated)": ccxt.ExchangeError,
                    "EGeneral:Internal error[:<code>]": ccxt.ExchangeError,
                    "EGeneral:Invalid arguments": ccxt.BadRequest,
                    "EOrder:Cannot open opposing position": ccxt.InvalidOrder,
                    "EOrder:Cannot open position": ccxt.InvalidOrder,
                    "EOrder:Insufficient funds (insufficient user funds)": ccxt.InsufficientFunds,
                    "EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)": ccxt.InsufficientFunds,
                    "EOrder:Invalid price": ccxt.InvalidOrder,
                    "EOrder:Margin allowance exceeded": ccxt.InvalidOrder,
                    "EOrder:Margin level too low": ccxt.InvalidOrder,
                    "EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)": ccxt.InvalidOrder,
                    "EOrder:ccxt.Order minimum not met (volume too low)": ccxt.InvalidOrder,
                    "EOrder:Orders limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Positions limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Rate limit exceeded": ccxt.RateLimitExceeded,
                    "EOrder:Scheduled orders limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Unknown position": ccxt.OrderNotFound,
                    "EOrder:Unknown order": ccxt.OrderNotFound,
                    "EOrder:Invalid order": ccxt.InvalidOrder,
                    "EService:Deadline elapsed": ccxt.ExchangeNotAvailable,
                    "EService:ccxt.Market in cancel_only mode": ccxt.NotSupported,
                    "EService:ccxt.Market in limit_only mode": ccxt.NotSupported,
                    "EService:ccxt.Market in post_only mode": ccxt.NotSupported,
                    "EService:Unavailable": ccxt.ExchangeNotAvailable,
                    "ETrade:Invalid request": ccxt.BadRequest,
                    "ESession:Invalid session": ccxt.AuthenticationError,
                },
            },
        },
    })
}
func  (this *KrakenCore) OrderRequestWs(method interface{}, symbol interface{}, typeVar interface{}, request interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := ccxt.GetArg(optionalArgs, 0, nil)
    _ = price
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var isLimitOrder interface{} = ccxt.EndsWith(typeVar, "limit") // supporting limit, stop-loss-limit, take-profit-limit, etc
    if ccxt.IsTrue(isLimitOrder) {
        if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
            panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " limit orders require a price argument")))
        }
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, price)))
    }
    var isMarket interface{} =     (ccxt.IsEqual(typeVar, "market"))
    var postOnly interface{} = nil
    postOnlyparamsVariable := this.HandlePostOnly(isMarket, false, params)
    postOnly = ccxt.GetValue(postOnlyparamsVariable,0)
    params = ccxt.GetValue(postOnlyparamsVariable,1)
    if ccxt.IsTrue(postOnly) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "post_only", true)
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "cl_ord_id", clientOrderId)
    }
    var cost interface{} = this.SafeString(params, "cost")
    if ccxt.IsTrue(!ccxt.IsEqual(cost, nil)) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_qty", this.ParseToNumeric(this.CostToPrecision(symbol, cost)))
    }
    var stopLoss interface{} = this.SafeDict(params, "stopLoss", map[string]interface{} {})
    var takeProfit interface{} = this.SafeDict(params, "takeProfit", map[string]interface{} {})
    var presetStopLoss interface{} = this.SafeString(stopLoss, "triggerPrice")
    var presetTakeProfit interface{} = this.SafeString(takeProfit, "triggerPrice")
    var presetStopLossLimit interface{} = this.SafeString(stopLoss, "price")
    var presetTakeProfitLimit interface{} = this.SafeString(takeProfit, "price")
    var isPresetStopLoss interface{} = !ccxt.IsEqual(presetStopLoss, nil)
    var isPresetTakeProfit interface{} = !ccxt.IsEqual(presetTakeProfit, nil)
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var isStopLossPriceOrder interface{} = !ccxt.IsEqual(stopLossPrice, nil)
    var isTakeProfitPriceOrder interface{} = !ccxt.IsEqual(takeProfitPrice, nil)
    var trailingAmount interface{} = this.SafeString(params, "trailingAmount")
    var trailingPercent interface{} = this.SafeString(params, "trailingPercent")
    var trailingLimitAmount interface{} = this.SafeString(params, "trailingLimitAmount")
    var trailingLimitPercent interface{} = this.SafeString(params, "trailingLimitPercent")
    var isTrailingAmountOrder interface{} = !ccxt.IsEqual(trailingAmount, nil)
    var isTrailingPercentOrder interface{} = !ccxt.IsEqual(trailingPercent, nil)
    var isTrailingLimitAmountOrder interface{} = !ccxt.IsEqual(trailingLimitAmount, nil)
    var isTrailingLimitPercentOrder interface{} = !ccxt.IsEqual(trailingLimitPercent, nil)
    var offset interface{} = this.SafeString(params, "offset", "") // can set this to - for minus
    var trailingAmountString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingAmount, nil))), ccxt.Add(offset, this.NumberToString(trailingAmount)), nil)
    var trailingPercentString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingPercent, nil))), ccxt.Add(offset, this.NumberToString(trailingPercent)), nil)
    var trailingLimitAmountString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingLimitAmount, nil))), ccxt.Add(offset, this.NumberToString(trailingLimitAmount)), nil)
    var trailingLimitPercentString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingLimitPercent, nil))), ccxt.Add(offset, this.NumberToString(trailingLimitPercent)), nil)
    var priceType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(isTrailingPercentOrder) || ccxt.IsTrue(isTrailingLimitPercentOrder))), "pct", "quote")
    if ccxt.IsTrue(ccxt.IsEqual(method, "createOrderWs")) {
        var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
        if ccxt.IsTrue(reduceOnly) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "reduce_only", true)
        }
        var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
        if ccxt.IsTrue(!ccxt.IsEqual(timeInForce, nil)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "time_in_force", timeInForce)
        }
        params = this.Omit(params, []interface{}{"reduceOnly", "timeInForce"})
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) || ccxt.IsTrue(isTrailingAmountOrder)) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "triggers", map[string]interface{} {})
        }
        if ccxt.IsTrue(ccxt.IsTrue(isPresetStopLoss) || ccxt.IsTrue(isPresetTakeProfit)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "conditional", map[string]interface{} {})
            if ccxt.IsTrue(isPresetStopLoss) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "stop-loss")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetStopLoss)))
            } else if ccxt.IsTrue(isPresetTakeProfit) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "take-profit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetTakeProfit)))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(presetStopLossLimit, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "stop-loss-limit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetStopLossLimit)))
            } else if ccxt.IsTrue(!ccxt.IsEqual(presetTakeProfitLimit, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "take-profit-limit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetTakeProfitLimit)))
            }
            params = this.Omit(params, []interface{}{"stopLoss", "takeProfit"})
        } else if ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) {
            if ccxt.IsTrue(isStopLossPriceOrder) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
                if ccxt.IsTrue(isLimitOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "stop-loss-limit")
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "stop-loss")
                }
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
                if ccxt.IsTrue(isLimitOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "take-profit-limit")
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "take-profit")
                }
            }
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price_type", priceType)
            if ccxt.IsTrue(!ccxt.IsTrue(isLimitOrder) && ccxt.IsTrue((ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)))) {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "trailing-stop")
                if ccxt.IsTrue(isTrailingAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingPercentString))
                }
            } else {
                // trailing limit orders are not conventionally supported because the static limit_price_type param is not available for trailing-stop-limit orders
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price_type", priceType)
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "trailing-stop-limit")
                if ccxt.IsTrue(isTrailingLimitAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingLimitAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingLimitPercentString))
                }
            }
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(method, "editOrderWs")) {
        if ccxt.IsTrue(ccxt.IsTrue(isPresetStopLoss) || ccxt.IsTrue(isPresetTakeProfit)) {
            panic(ccxt.NotSupported(ccxt.Add(this.Id, " editing the stopLoss and takeProfit on existing orders is currently not supported")))
        }
        if ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) {
            if ccxt.IsTrue(isStopLossPriceOrder) {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
            }
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price_type", priceType)
            if ccxt.IsTrue(!ccxt.IsTrue(isLimitOrder) && ccxt.IsTrue((ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)))) {
                if ccxt.IsTrue(isTrailingAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingPercentString))
                }
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price_type", priceType)
                if ccxt.IsTrue(isTrailingLimitAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingLimitAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingLimitPercentString))
                }
            }
        }
    }
    params = this.Omit(params, []interface{}{"clientOrderId", "cost", "offset", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent"})
    return []interface{}{request, params}
}
/**
 * @method
 * @name kraken#createOrderWs
 * @description create a trade order
 * @see https://docs.kraken.com/api/docs/websocket-v2/add_order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2818)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "add_order",
                "params": map[string]interface{} {
                    "order_type": typeVar,
                    "side": side,
                    "order_qty": this.ParseToNumeric(this.AmountToPrecision(symbol, amount)),
                    "symbol": ccxt.GetValue(market, "symbol"),
                    "token": token,
                },
                "req_id": requestId,
            }
            requestparamsVariable := this.OrderRequestWs("createOrderWs", symbol, typeVar, request, amount, price, params)
            request = ccxt.GetValue(requestparamsVariable,0)
            params = ccxt.GetValue(requestparamsVariable,1)
        
                retRes29915 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes29915)
                ch <- retRes29915
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCreateEditOrder(client interface{}, message interface{})  {
    //
    //  createOrder
    //     {
    //         "method": "add_order",
    //         "req_id": 1,
    //         "result": {
    //             "order_id": "OXM2QD-EALR2-YBAVEU"
    //         },
    //         "success": true,
    //         "time_in": "2025-05-13T10:12:13.876173Z",
    //         "time_out": "2025-05-13T10:12:13.890137Z"
    //     }
    //
    //  editOrder
    //     {
    //         "method": "amend_order",
    //         "req_id": 1,
    //         "result": {
    //             "amend_id": "TYDLSQ-OYNYU-3MNRER",
    //             "order_id": "OGL7HR-SWFO4-NRQTHO"
    //         },
    //         "success": true,
    //         "time_in": "2025-05-14T13:54:10.840342Z",
    //         "time_out": "2025-05-14T13:54:10.855046Z"
    //     }
    //
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var order interface{} = this.ParseOrder(result)
    var messageHash interface{} = this.SafeString2(message, "reqid", "req_id")
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name kraken#editOrderWs
 * @description edit a trade order
 * @see https://docs.kraken.com/api/docs/websocket-v2/amend_order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3508)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "amend_order",
                "params": map[string]interface{} {
                    "order_id": id,
                    "order_qty": this.ParseToNumeric(this.AmountToPrecision(symbol, amount)),
                    "token": token,
                },
                "req_id": requestId,
            }
            requestparamsVariable := this.OrderRequestWs("editOrderWs", symbol, typeVar, request, amount, price, params)
            request = ccxt.GetValue(requestparamsVariable,0)
            params = ccxt.GetValue(requestparamsVariable,1)
        
                retRes36515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes36515)
                ch <- retRes36515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#cancelOrdersWs
 * @description cancel multiple orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelOrdersWs () does not support cancelling orders for a specific symbol.")))
            }
        
            retRes3828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3828)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_order",
                "params": map[string]interface{} {
                    "order_id": ids,
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes39515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes39515)
                ch <- retRes39515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#cancelOrderWs
 * @description cancels an open order
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelOrderWs () does not support cancelling orders for a specific symbol.")))
            }
        
            retRes4128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4128)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_order",
                "params": map[string]interface{} {
                    "order_id": []interface{}{id},
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes42515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes42515)
                ch <- retRes42515
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCancelOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "cancel_order",
    //         "req_id": 123456789,
    //         "result": {
    //             "order_id": "OKAGJC-YHIWK-WIOZWG"
    //         },
    //         "success": true,
    //         "time_in": "2023-09-21T14:36:57.428972Z",
    //         "time_out": "2023-09-21T14:36:57.437952Z"
    //     }
    //
    var reqId interface{} = this.SafeString(message, "req_id")
    client.(ccxt.ClientInterface).Resolve(message, reqId)
}
/**
 * @method
 * @name kraken#cancelAllOrdersWs
 * @description cancel all open orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_all
 * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelAllOrdersWs () does not support cancelling orders in a specific market.")))
            }
        
            retRes4588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4588)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_all",
                "params": map[string]interface{} {
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes47015 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes47015)
                ch <- retRes47015
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCancelAllOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "cancel_all",
    //         "req_id": 123456789,
    //         "result": {
    //             "count": 1
    //         },
    //         "success": true,
    //         "time_in": "2023-09-21T14:36:57.428972Z",
    //         "time_out": "2023-09-21T14:36:57.437952Z"
    //     }
    //
    var reqId interface{} = this.SafeString(message, "req_id")
    client.(ccxt.ClientInterface).Resolve(message, reqId)
}
func  (this *KrakenCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "ticker",
    //         "type": "snapshot",
    //         "data": [
    //             {
    //                 "symbol": "BTC/USD",
    //                 "bid": 108359.8,
    //                 "bid_qty": 0.01362603,
    //                 "ask": 108359.9,
    //                 "ask_qty": 17.17988863,
    //                 "last": 108359.8,
    //                 "volume": 2158.32346723,
    //                 "vwap": 108894.5,
    //                 "low": 106824,
    //                 "high": 111300,
    //                 "change": -2679.9,
    //                 "change_pct": -2.41
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = ccxt.GetValue(data, 0)
    var symbol interface{} = this.SafeString(ticker, "symbol")
    var messageHash interface{} = this.GetMessageHash("ticker", nil, symbol)
    var vwap interface{} = this.SafeString(ticker, "vwap")
    var quoteVolume interface{} = nil
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(baseVolume, nil)) && ccxt.IsTrue(!ccxt.IsEqual(vwap, nil))) {
        quoteVolume = ccxt.Precise.StringMul(baseVolume, vwap)
    }
    var last interface{} = this.SafeString(ticker, "last")
    var result interface{} = this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bid_qty"),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "ask_qty"),
        "vwap": vwap,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "change"),
        "percentage": this.SafeString(ticker, "change_pct"),
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    })
    ccxt.AddElementToObject(this.Tickers, symbol, result)
    client.(ccxt.ClientInterface).Resolve(result, messageHash)
}
func  (this *KrakenCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "trade",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "side": "sell",
    //                 "price": 0.5117,
    //                 "qty": 40.0,
    //                 "ord_type": "market",
    //                 "trade_id": 4665906,
    //                 "timestamp": "2023-09-25T07:49:37.708706Z"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var trade interface{} = ccxt.GetValue(data, 0)
    var symbol interface{} = this.SafeString(trade, "symbol")
    var messageHash interface{} = this.GetMessageHash("trade", nil, symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var market interface{} = this.Market(symbol)
    var parsed interface{} = this.ParseTrades(data, market)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsed, i))
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *KrakenCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "ohlc",
    //         "type": "update",
    //         "timestamp": "2023-10-04T16:26:30.524394914Z",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "open": 0.5624,
    //                 "high": 0.5628,
    //                 "low": 0.5622,
    //                 "close": 0.5627,
    //                 "trades": 12,
    //                 "volume": 30927.68066226,
    //                 "vwap": 0.5626,
    //                 "interval_begin": "2023-10-04T16:25:00.000000000Z",
    //                 "interval": 5,
    //                 "timestamp": "2023-10-04T16:30:00.000000Z"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var first interface{} = ccxt.GetValue(data, 0)
    var marketId interface{} = this.SafeString(first, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    var interval interface{} = this.SafeInteger(first, "interval")
    var timeframe interface{} = this.FindTimeframe(interval)
    var messageHash interface{} = this.GetMessageHash("ohlcv", nil, symbol)
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcvsLength interface{} =     ccxt.GetArrayLength(data)
    for i := 0; ccxt.IsLessThan(i, ohlcvsLength); i++ {
        var candle interface{} = ccxt.GetValue(data, ccxt.Subtract(ccxt.Subtract(ohlcvsLength, i), 1))
        var datetime interface{} = this.SafeString(candle, "timestamp")
        var timestamp interface{} = this.Parse8601(datetime)
        var parsed interface{} = []interface{}{timestamp, this.SafeString(candle, "open"), this.SafeString(candle, "high"), this.SafeString(candle, "low"), this.SafeString(candle, "close"), this.SafeString(candle, "volume")}
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *KrakenCore) RequestId() interface{}  {
    // their support said that reqid must be an int32, not documented
    this.LockId()
    var reqid interface{} = this.Sum(this.SafeInteger(this.Options, "reqid", 0), 1)
    ccxt.AddElementToObject(this.Options, "reqid", reqid)
    this.UnlockId()
    return reqid
}
/**
 * @method
 * @name kraken#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6638)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string[]} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6798)
            symbols = this.MarketSymbols(symbols, nil, false)
        
            ticker:= (<-this.WatchMultiHelper("ticker", "ticker", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7008 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7008)
            symbols = this.MarketSymbols(symbols, nil, false)
            ccxt.AddElementToObject(params, "event_trigger", "bbo")
        
            ticker:= (<-this.WatchMultiHelper("bidask", "ticker", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.kraken.com/api/docs/websocket-v2/trade
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KrakenCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes72415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes72415)
                ch <- retRes72415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://docs.kraken.com/api/docs/websocket-v2/trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KrakenCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.WatchMultiHelper("trade", "trade", symbols, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeList(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kraken.com/api/docs/websocket-v2/book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes75915 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes75915)
                ch <- retRes75915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kraken.com/api/docs/websocket-v2/book
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var requiredParams interface{} = map[string]interface{} {}
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(this.InArray(limit, []interface{}{10, 25, 100, 500, 1000})) {
                    ccxt.AddElementToObject(requiredParams, "depth", limit) // default 10, valid options 10, 25, 100, 500, 1000
                } else {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only")))
                }
            }
        
            orderbook:= (<-this.WatchMultiHelper("orderbook", "book", symbols, map[string]interface{} {
            "limit": limit,
        }, this.Extend(requiredParams, params)))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.kraken.com/api/docs/websocket-v2/ohlc
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *KrakenCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7988 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7988)
            var name interface{} = "ohlc"
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "publicV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.GetMessageHash("ohlcv", nil, symbol)
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": name,
                    "symbol": []interface{}{symbol},
                    "interval": this.SafeValue(this.Timeframes, timeframe, timeframe),
                },
                "req_id": requestId,
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) LoadMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    reload := ccxt.GetArg(optionalArgs, 0, false)
            _ = reload
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.base.LoadMarkets(reload, params))
            ccxt.PanicOnError(markets)
            var marketsByWsName interface{} = this.SafeValue(this.Options, "marketsByWsName")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketsByWsName, nil))) || ccxt.IsTrue(reload)) {
                marketsByWsName = map[string]interface{} {}
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(this.Symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(this.Symbols, i)
                    var market interface{} = ccxt.GetValue(this.Markets, symbol)
                    var info interface{} = this.SafeValue(market, "info", map[string]interface{} {})
                    var wsName interface{} = this.SafeString(info, "wsname")
                    ccxt.AddElementToObject(marketsByWsName, wsName, market)
                }
                ccxt.AddElementToObject(this.Options, "marketsByWsName", marketsByWsName)
            }
        
            ch <- markets
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) Ping(client interface{}) interface{}  {
    var url interface{} = client.(ccxt.ClientInterface).GetUrl()
    var request interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "v2"), 0)) {
        ccxt.AddElementToObject(request, "method", "ping")
    } else {
        ccxt.AddElementToObject(request, "event", "ping")
    }
    return request
}
func  (this *KrakenCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *KrakenCore) WatchHeartbeat(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8568)
            var event interface{} = "heartbeat"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "publicV2")
        
                retRes85915 :=  (<-this.Watch(url, event))
                ccxt.PanicOnError(retRes85915)
                ch <- retRes85915
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleHeartbeat(client interface{}, message interface{})  {
    //
    // every second (approx) if no other updates are sent
    //
    //     { "channel": "heartbeat" }
    //
    var event interface{} = this.SafeString(message, "channel")
    client.(ccxt.ClientInterface).Resolve(message, event)
}
func  (this *KrakenCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // first message (snapshot)
    //
    //     {
    //         "channel": "book",
    //         "type": "snapshot",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "bids": [
    //                     {
    //                         "price": 0.5666,
    //                         "qty": 4831.75496356
    //                     },
    //                     {
    //                         "price": 0.5665,
    //                         "qty": 6658.22734739
    //                     }
    //                 ],
    //                 "asks": [
    //                     {
    //                         "price": 0.5668,
    //                         "qty": 4410.79769741
    //                     },
    //                     {
    //                         "price": 0.5669,
    //                         "qty": 4655.40412487
    //                     }
    //                 ],
    //                 "checksum": 2439117997
    //             }
    //         ]
    //     }
    //
    // subsequent updates
    //
    //     {
    //         "channel": "book",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "bids": [
    //                     {
    //                         "price": 0.5657,
    //                         "qty": 1098.3947558
    //                     }
    //                 ],
    //                 "asks": [],
    //                 "checksum": 2114181697,
    //                 "timestamp": "2023-10-06T17:35:55.440295Z"
    //             }
    //         ]
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
    var symbol interface{} = this.SafeString(first, "symbol")
    var a interface{} = this.SafeValue(first, "asks", []interface{}{})
    var b interface{} = this.SafeValue(first, "bids", []interface{}{})
    var c interface{} = this.SafeInteger(first, "checksum")
    var messageHash interface{} = this.GetMessageHash("orderbook", nil, symbol)
    var orderbook interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
        var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
        if ccxt.IsTrue(!ccxt.IsEqual(a, nil)) {
            this.CustomHandleDeltas(storedAsks, a)
        }
        if ccxt.IsTrue(!ccxt.IsEqual(b, nil)) {
            this.CustomHandleDeltas(storedBids, b)
        }
        var datetime interface{} = this.SafeString(first, "timestamp")
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
        ccxt.AddElementToObject(orderbook, "datetime", datetime)
    } else {
        // snapshot
        var depth interface{} =         ccxt.GetArrayLength(a)
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, depth))
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        var keys interface{} = []interface{}{"asks", "bids"}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var key interface{} = ccxt.GetValue(keys, i)
            var bookside interface{} = ccxt.GetValue(orderbook, key)
            var deltas interface{} = this.SafeValue(first, key, []interface{}{})
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(deltas), 0)) {
                this.CustomHandleDeltas(bookside, deltas)
            }
        }
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
    }
    orderbook.(ccxt.OrderBookInterface).Limit()
    // checksum temporarily disabled because the exchange checksum was not reliable
    var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", false)
    if ccxt.IsTrue(checksum) {
        var payloadArray interface{} = []interface{}{}
        if ccxt.IsTrue(!ccxt.IsEqual(c, nil)) {
            var checkAsks interface{} = ccxt.GetValue(orderbook, "asks")
            var checkBids interface{} = ccxt.GetValue(orderbook, "bids")
            // const checkAsks = asks.map ((elem) => [ elem['price'], elem['qty'] ])
            // const checkBids = bids.map ((elem) => [ elem['price'], elem['qty'] ])
            for i := 0; ccxt.IsLessThan(i, 10); i++ {
                var currentAsk interface{} = this.SafeValue(checkAsks, i, map[string]interface{} {})
                var formattedAsk interface{} = ccxt.Add(this.FormatNumber(ccxt.GetValue(currentAsk, 0)), this.FormatNumber(ccxt.GetValue(currentAsk, 1)))
                ccxt.AppendToArray(&payloadArray, formattedAsk)
            }
            for i := 0; ccxt.IsLessThan(i, 10); i++ {
                var currentBid interface{} = this.SafeValue(checkBids, i, map[string]interface{} {})
                var formattedBid interface{} = ccxt.Add(this.FormatNumber(ccxt.GetValue(currentBid, 0)), this.FormatNumber(ccxt.GetValue(currentBid, 1)))
                ccxt.AppendToArray(&payloadArray, formattedBid)
            }
        }
        var payload interface{} = ccxt.Join(payloadArray, "")
        var localChecksum interface{} = this.Crc32(payload, false)
        if ccxt.IsTrue(!ccxt.IsEqual(localChecksum, c)) {
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            ccxt.Remove(this.Orderbooks, symbol)
            client.(ccxt.ClientInterface).Reject(error, messageHash)
            return
        }
    }
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *KrakenCore) CustomHandleDeltas(bookside interface{}, deltas interface{})  {
    // const sortOrder = (key === 'bids') ? true : false
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(deltas)); j++ {
        var delta interface{} = ccxt.GetValue(deltas, j)
        var price interface{} = this.SafeNumber(delta, "price")
        var amount interface{} = this.SafeNumber(delta, "qty")
        bookside.(ccxt.IOrderBookSide).Store(price, amount)
    }
}
func  (this *KrakenCore) FormatNumber(data interface{}) interface{}  {
    var parts interface{} = ccxt.Split(data, ".")
    var integer interface{} = this.SafeString(parts, 0)
    var decimals interface{} = this.SafeString(parts, 1, "")
    var joinedResult interface{} = ccxt.Add(integer, decimals)
    var i interface{} = 0
    for ccxt.IsEqual(ccxt.GetValue(joinedResult, i), "0") {
        i = ccxt.Add(i, 1)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThan(i, 0)) {
        joinedResult = ccxt.Slice(joinedResult, i, nil)
    }
    return joinedResult
}
func  (this *KrakenCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "connectionID": 15527282728335292000,
    //         "event": "systemStatus",
    //         "status": "online", // online|maintenance|(custom status tbd)
    //         "version": "0.2.0"
    //     }
    //
    // v2
    //     {
    //         channel: 'status',
    //         type: 'update',
    //         data: [
    //             {
    //                 version: '2.0.10',
    //                 system: 'online',
    //                 api_version: 'v2',
    //                 connection_id: 6447481662169813000
    //             }
    //         ]
    //     }
    //
    return message
}
func  (this *KrakenCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var client interface{} = this.Client(url)
            var authenticated interface{} = "authenticated"
            var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), authenticated)
            var now interface{} = this.Seconds()
            var start interface{} = this.SafeInteger(subscription, "start")
            var expires interface{} = this.SafeInteger(subscription, "expires")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, nil))) || ccxt.IsTrue((ccxt.IsTrue((!ccxt.IsEqual(subscription, nil))) && ccxt.IsTrue(ccxt.IsLessThanOrEqual((ccxt.Add(start, expires)), now))))) {
                // https://docs.kraken.com/api/docs/rest-api/get-websockets-token
        
                response:= (<-this.PrivatePostGetWebSocketsToken(params))
                ccxt.PanicOnError(response)
                //
                //     {
                //         "error":[],
                //         "result":{
                //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
                //             "expires":900
                //         }
                //     }
                //
                subscription = this.SafeDict(response, "result")
                ccxt.AddElementToObject(subscription, "start", now)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), authenticated, subscription)
            }
        
            ch <- this.SafeString(subscription, "token")
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) WatchPrivate(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10928)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var subscriptionHash interface{} = "executions"
            var messageHash interface{} = name
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": "executions",
                    "token": token,
                },
                "req_id": requestId,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(params, nil)) {
                ccxt.AddElementToObject(subscribe, "params", this.DeepExtend(ccxt.GetValue(subscribe, "params"), params))
            }
        
            result:= (<-this.Watch(url, messageHash, subscribe, subscriptionHash))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(result).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(result, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://docs.kraken.com/api/docs/websocket-v2/executions
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *KrakenCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "snap_trades", true)
        
                retRes113315 :=  (<-this.WatchPrivate("myTrades", symbol, since, limit, params))
                ccxt.PanicOnError(retRes113315)
                ch <- retRes113315
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleMyTrades(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     {
    //         "channel": "executions",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "order_id": "O6NTZC-K6FRH-ATWBCK",
    //                 "exec_id": "T5DIUI-5N4KO-Z5BPXK",
    //                 "exec_type": "trade",
    //                 "trade_id": 8253473,
    //                 "symbol": "USDC/USD",
    //                 "side": "sell",
    //                 "last_qty": 15.44,
    //                 "last_price": 1.0002,
    //                 "liquidity_ind": "t",
    //                 "cost": 15.443088,
    //                 "order_userref": 0,
    //                 "order_status": "filled",
    //                 "order_type": "market",
    //                 "fee_usd_equiv": 0.03088618,
    //                 "fees": [
    //                     {
    //                         "asset": "USD",
    //                         "qty": 0.3458
    //                     }
    //                 ]
    //             }
    //         ],
    //         "sequence": 10
    //     }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var allTrades interface{} = this.SafeList(message, "data", []interface{}{})
    var allTradesLength interface{} =     ccxt.GetArrayLength(allTrades)
    if ccxt.IsTrue(ccxt.IsGreaterThan(allTradesLength, 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCache(limit)
        }
        var stored interface{} = this.MyTrades
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(allTrades)); i++ {
            var trade interface{} = this.SafeDict(allTrades, i, map[string]interface{} {})
            var parsed interface{} = this.ParseWsTrade(trade)
            stored.(ccxt.Appender).Append(parsed)
            var symbol interface{} = ccxt.GetValue(parsed, "symbol")
            ccxt.AddElementToObject(symbols, symbol, true)
        }
        var name interface{} = "myTrades"
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, name)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(keys, i))
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
        }
    }
}
func  (this *KrakenCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "order_id": "O6NTZC-K6FRH-ATWBCK",
    //         "exec_id": "T5DIUI-5N4KO-Z5BPXK",
    //         "exec_type": "trade",
    //         "trade_id": 8253473,
    //         "symbol": "USDC/USD",
    //         "side": "sell",
    //         "last_qty": 15.44,
    //         "last_price": 1.0002,
    //         "liquidity_ind": "t",
    //         "cost": 15.443088,
    //         "order_userref": 0,
    //         "order_status": "filled",
    //         "order_type": "market",
    //         "fee_usd_equiv": 0.03088618,
    //         "fees": [
    //             {
    //                 "asset": "USD",
    //                 "qty": 0.3458
    //             }
    //         ]
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(trade, "symbol")
    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
        symbol = ccxt.GetValue(market, "symbol")
    }
    var fee interface{} = nil
    if ccxt.IsTrue(ccxt.InOp(trade, "fees")) {
        var fees interface{} = this.SafeList(trade, "fees", []interface{}{})
        var firstFee interface{} = this.SafeDict(fees, 0, map[string]interface{} {})
        fee = map[string]interface{} {
            "cost": this.SafeNumber(firstFee, "qty"),
            "currency": this.SafeString(firstFee, "asset"),
        }
    }
    var datetime interface{} = this.SafeString(trade, "timestamp")
    var liquidityIndicator interface{} = this.SafeString(trade, "liquidity_ind")
    var takerOrMaker interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(liquidityIndicator, "t"))), "taker", "maker")
    return map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "exec_id"),
        "order": this.SafeString(trade, "order_id"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": symbol,
        "type": this.SafeString(trade, "order_type"),
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": takerOrMaker,
        "price": this.SafeNumber(trade, "last_price"),
        "amount": this.SafeNumber(trade, "last_qty"),
        "cost": this.SafeNumber(trade, "cost"),
        "fee": fee,
    }
}
/**
 * @method
 * @name kraken#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.kraken.com/api/docs/websocket-v2/executions
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve
 * @param {object} [params] maximum number of orderic to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KrakenCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes126415 :=  (<-this.WatchPrivate("orders", symbol, since, limit, this.Extend(params, map[string]interface{} {
                "snap_orders": true,
            })))
                ccxt.PanicOnError(retRes126415)
                ch <- retRes126415
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleOrders(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     {
    //         "channel": "executions",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "order_id": "OK4GJX-KSTLS-7DZZO5",
    //                 "order_userref": 3,
    //                 "symbol": "BTC/USD",
    //                 "order_qty": 0.005,
    //                 "cum_cost": 0.0,
    //                 "time_in_force": "GTC",
    //                 "exec_type": "pending_new",
    //                 "side": "sell",
    //                 "order_type": "limit",
    //                 "limit_price_type": "static",
    //                 "limit_price": 26500.0,
    //                 "stop_price": 0.0,
    //                 "order_status": "pending_new",
    //                 "fee_usd_equiv": 0.0,
    //                 "fee_ccy_pref": "fciq",
    //                 "timestamp": "2023-09-22T10:33:05.709950Z"
    //             }
    //         ],
    //         "sequence": 8
    //     }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var allOrders interface{} = this.SafeList(message, "data", []interface{}{})
    var allOrdersLength interface{} =     ccxt.GetArrayLength(allOrders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(allOrdersLength, 0)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(allOrders)); i++ {
            var order interface{} = this.SafeDict(allOrders, i, map[string]interface{} {})
            var id interface{} = this.SafeString(order, "order_id")
            var parsed interface{} = this.ParseWsOrder(order)
            var symbol interface{} = this.SafeString(order, "symbol")
            var previousOrders interface{} = this.SafeValue(stored.(*ccxt.ArrayCache).Hashmap, symbol)
            var previousOrder interface{} = this.SafeValue(previousOrders, id)
            var newOrder interface{} = parsed
            if ccxt.IsTrue(!ccxt.IsEqual(previousOrder, nil)) {
                var newRawOrder interface{} = this.Extend(ccxt.GetValue(previousOrder, "info"), ccxt.GetValue(newOrder, "info"))
                newOrder = this.ParseWsOrder(newRawOrder)
            }
            var length interface{} =             ccxt.GetArrayLength(stored)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(length, limit)) && ccxt.IsTrue((ccxt.IsEqual(previousOrder, nil)))) {
                var first interface{} = ccxt.GetValue(stored, 0)
                var symbolsByOrderId interface{} = this.SafeValue(this.Options, "symbolsByOrderId", map[string]interface{} {})
                if ccxt.IsTrue(ccxt.InOp(symbolsByOrderId, ccxt.GetValue(first, "id"))) {
                    ccxt.Remove(symbolsByOrderId, ccxt.GetValue(first, "id"))
                }
            }
            stored.(ccxt.Appender).Append(newOrder)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                ccxt.AddElementToObject(symbols, symbol, true)
            }
        }
        var name interface{} = "orders"
        client.(ccxt.ClientInterface).Resolve(this.Orders, name)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(keys, i))
            client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        }
    }
}
func  (this *KrakenCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // watchOrders
    //
    // open order
    //     {
    //         "order_id": "OK4GJX-KSTLS-7DZZO5",
    //         "order_userref": 3,
    //         "symbol": "BTC/USD",
    //         "order_qty": 0.005,
    //         "cum_cost": 0.0,
    //         "time_in_force": "GTC",
    //         "exec_type": "pending_new",
    //         "side": "sell",
    //         "order_type": "limit",
    //         "limit_price_type": "static",
    //         "limit_price": 26500.0,
    //         "stop_price": 0.0,
    //         "order_status": "pending_new",
    //         "fee_usd_equiv": 0.0,
    //         "fee_ccy_pref": "fciq",
    //         "timestamp": "2023-09-22T10:33:05.709950Z"
    //     }
    //
    // canceled order
    //
    //     {
    //         "timestamp": "2025-10-11T15:11:47.695226Z",
    //         "order_status": "canceled",
    //         "exec_type": "canceled",
    //         "order_userref": 0,
    //         "order_id": "OGAB7Y-BKX5F-PTK5RW",
    //         "cum_qty": 0,
    //         "cum_cost": 0,
    //         "fee_usd_equiv": 0,
    //         "avg_price": 0,
    //         "cancel_reason": "User requested",
    //         "reason": "User requested"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeString(order, "fee_usd_equiv"),
        "currency": "USD",
    }
    var stopPrice interface{} = this.SafeString(order, "stop_price")
    var datetime interface{} = this.SafeString(order, "timestamp")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(order, "order_userref"),
        "info": order,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastTradeTimestamp": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "order_status")),
        "symbol": this.SafeString(order, "symbol"),
        "type": this.SafeString(order, "order_type"),
        "timeInForce": this.SafeString(order, "time_in_force"),
        "postOnly": nil,
        "side": this.SafeString(order, "side"),
        "price": this.SafeString(order, "limit_price"),
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "cost": this.SafeString(order, "cum_cost"),
        "amount": this.SafeString2(order, "order_qty", "cum_qty"),
        "filled": nil,
        "average": this.SafeString(order, "avg_price"),
        "remaining": nil,
        "fee": fee,
        "trades": nil,
    })
}
func  (this *KrakenCore) WatchMultiHelper(unifiedName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            subscriptionArgs := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscriptionArgs
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14128)
            // symbols are required
            symbols = this.MarketSymbols(symbols, nil, false, true, false)
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var eventTrigger interface{} = this.SafeString(params, "event_trigger")
                if ccxt.IsTrue(!ccxt.IsEqual(eventTrigger, nil)) {
                    ccxt.AppendToArray(&messageHashes, this.GetMessageHash(channelName, nil, this.Symbol(ccxt.GetValue(symbols, i))))
                } else {
                    ccxt.AppendToArray(&messageHashes, this.GetMessageHash(unifiedName, nil, this.Symbol(ccxt.GetValue(symbols, i))))
                }
            }
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": channelName,
                    "symbol": symbols,
                },
                "req_id": this.RequestId(),
            }
            ccxt.AddElementToObject(request, "params", this.DeepExtend(ccxt.GetValue(request, "params"), params))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "publicV2")
        
                retRes143415 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes, subscriptionArgs))
                ccxt.PanicOnError(retRes143415)
                ch <- retRes143415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *KrakenCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14468 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14468)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var messageHash interface{} = "balances"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "req_id": requestId,
                "params": map[string]interface{} {
                    "channel": "balances",
                    "token": token,
                },
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes146015 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes146015)
                ch <- retRes146015
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "balances",
    //         "data": [
    //             {
    //                 "asset": "BTC",
    //                 "asset_class": "currency",
    //                 "balance": 1.2,
    //                 "wallets": [
    //                     {
    //                         "type": "spot",
    //                         "id": "main",
    //                         "balance": 1.2
    //                     }
    //                 ]
    //             }
    //         ],
    //         "type": "snapshot",
    //         "sequence": 1
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": message,
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var currencyId interface{} = this.SafeString(ccxt.GetValue(data, i), "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var eq interface{} = this.SafeString(ccxt.GetValue(data, i), "balance")
        ccxt.AddElementToObject(account, "total", eq)
        ccxt.AddElementToObject(result, code, account)
    }
    var typeVar interface{} = "spot"
    var balance interface{} = this.SafeBalance(result)
    var oldBalance interface{} = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
    var newBalance interface{} = this.DeepExtend(oldBalance, balance)
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(newBalance))
    var channel interface{} = this.SafeString(message, "channel")
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), channel)
}
func  (this *KrakenCore) GetMessageHash(unifiedElementName interface{}, optionalArgs ...interface{}) interface{}  {
    // unifiedElementName can be : orderbook, trade, ticker, bidask ...
    // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
    subChannelName := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subChannelName
    symbol := ccxt.GetArg(optionalArgs, 1, nil)
    _ = symbol
    var withSymbol interface{} = !ccxt.IsEqual(symbol, nil)
    var messageHash interface{} = unifiedElementName
    if !ccxt.IsTrue(withSymbol) {
        messageHash = ccxt.Add(messageHash, "s")
    } else {
        messageHash = ccxt.Add(messageHash, ccxt.Add("@", symbol))
    }
    if ccxt.IsTrue(!ccxt.IsEqual(subChannelName, nil)) {
        messageHash = ccxt.Add(messageHash, ccxt.Add("#", subChannelName))
    }
    return messageHash
}
func  (this *KrakenCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    // public
    //
    //     {
    //         "channelID": 210,
    //         "channelName": "book-10",
    //         "event": "subscriptionStatus",
    //         "reqid": 1574146735269,
    //         "pair": "ETH/XBT",
    //         "status": "subscribed",
    //         "subscription": { depth: 10, name: "book" }
    //     }
    //
    // private
    //
    //     {
    //         "channelName": "openOrders",
    //         "event": "subscriptionStatus",
    //         "reqid": 1,
    //         "status": "subscribed",
    //         "subscription": { maxratecount: 125, name: "openOrders" }
    //     }
    //
    var channelId interface{} = this.SafeString(message, "channelID")
    if ccxt.IsTrue(!ccxt.IsEqual(channelId, nil)) {
        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), channelId, message)
    }
}
func  (this *KrakenCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "errorMessage": "ccxt.Currency pair not in ISO 4217-A3 format foobar",
    //         "event": "subscriptionStatus",
    //         "pair": "foobar",
    //         "reqid": 1574146735269,
    //         "status": "error",
    //         "subscription": { name: "ticker" }
    //     }
    //
    // v2
    //     {
    //         "error": "Unsupported field: 'price' for the given msg type: add order",
    //         "method": "add_order",
    //         "success": false,
    //         "time_in": "2025-05-13T08:59:44.803511Z",
    //         "time_out": "2025-05-13T08:59:44.803542Z'
    //     }
    //
    var errorMessage interface{} = this.SafeString2(message, "errorMessage", "error")
    if ccxt.IsTrue(!ccxt.IsEqual(errorMessage, nil)) {
        var requestId interface{} = this.SafeString2(message, "reqid", "req_id")
        var broad interface{} = ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad")
        var broadKey interface{} = this.FindBroadlyMatchedKey(broad, errorMessage)
        var exception interface{} = nil
        if ccxt.IsTrue(ccxt.IsEqual(broadKey, nil)) {
            exception = ccxt.ExchangeError(            errorMessage) // c# requirement to convert the errorMessage to string
        } else {
            exception = ccxt.CallDynamically(ccxt.GetValue(broad, broadKey), errorMessage)
        }
        if ccxt.IsTrue(!ccxt.IsEqual(requestId, nil)) {
            client.(ccxt.ClientInterface).Reject(exception, requestId)
        }
        return false
    }
    return true
}
func  (this *KrakenCore) HandleMessage(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(channel, "executions")) {
            var data interface{} = this.SafeList(message, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
            var execType interface{} = this.SafeString(first, "exec_type")
            channel = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(execType, "trade"))), "myTrades", "orders")
        }
        var methods interface{} = map[string]interface{} {
            "balances": this.HandleBalance,
            "book": this.HandleOrderBook,
            "ohlc": this.HandleOHLCV,
            "ticker": this.HandleTicker,
            "trade": this.HandleTrades,
            "myTrades": this.HandleMyTrades,
            "orders": this.HandleOrders,
        }
        var method interface{} = this.SafeValue(methods, channel)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        var event interface{} = this.SafeString2(message, "event", "method")
        var methods interface{} = map[string]interface{} {
            "heartbeat": this.HandleHeartbeat,
            "systemStatus": this.HandleSystemStatus,
            "subscriptionStatus": this.HandleSubscriptionStatus,
            "add_order": this.HandleCreateEditOrder,
            "amend_order": this.HandleCreateEditOrder,
            "cancel_order": this.HandleCancelOrder,
            "cancel_all": this.HandleCancelAllOrders,
            "pong": this.HandlePong,
        }
        var method interface{} = this.SafeValue(methods, event)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *KrakenCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
