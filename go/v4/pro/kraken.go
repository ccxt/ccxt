package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type KrakenCore struct {
	*ccxt.KrakenCore
	base *ccxt.KrakenCore
}

func NewKrakenCore() *KrakenCore {
    p := &KrakenCore{}
	base := &ccxt.KrakenCore{}
	p.base = base
	p.KrakenCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *KrakenCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "cancelAllOrdersWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.kraken.com",
                    "private": "wss://ws-auth.kraken.com",
                    "privateV2": "wss://ws-auth.kraken.com/v2",
                    "publicV2": "wss://ws.kraken.com/v2",
                    "beta": "wss://beta-ws.kraken.com",
                    "beta-private": "wss://beta-ws-auth.kraken.com",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "ordersLimit": 1000,
            "symbolsByOrderId": map[string]interface{} {},
            "watchOrderBook": map[string]interface{} {
                "checksum": false,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 6000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "Event(s) not found": ccxt.BadRequest,
                },
                "broad": map[string]interface{} {
                    "Already subscribed": ccxt.BadRequest,
                    "ccxt.Currency pair not in ISO 4217-A3 format": ccxt.BadSymbol,
                    "ccxt.Currency pair not supported": ccxt.BadSymbol,
                    "Malformed request": ccxt.BadRequest,
                    "Pair field must be an array": ccxt.BadRequest,
                    "Pair field unsupported for this subscription type": ccxt.BadRequest,
                    "Pair(s) not found": ccxt.BadSymbol,
                    "Subscription book depth must be an integer": ccxt.BadRequest,
                    "Subscription depth not supported": ccxt.BadRequest,
                    "Subscription field must be an object": ccxt.BadRequest,
                    "Subscription name invalid": ccxt.BadRequest,
                    "Subscription object unsupported field": ccxt.BadRequest,
                    "Subscription ohlc interval must be an integer": ccxt.BadRequest,
                    "Subscription ohlc interval not supported": ccxt.BadRequest,
                    "Subscription ohlc requires interval": ccxt.BadRequest,
                    "EAccount:Invalid permissions": ccxt.PermissionDenied,
                    "EAuth:ccxt.Account temporary disabled": ccxt.AccountSuspended,
                    "EAuth:ccxt.Account unconfirmed": ccxt.AuthenticationError,
                    "EAuth:Rate limit exceeded": ccxt.RateLimitExceeded,
                    "EAuth:Too many requests": ccxt.RateLimitExceeded,
                    "EDatabase: Internal error (to be deprecated)": ccxt.ExchangeError,
                    "EGeneral:Internal error[:<code>]": ccxt.ExchangeError,
                    "EGeneral:Invalid arguments": ccxt.BadRequest,
                    "EOrder:Cannot open opposing position": ccxt.InvalidOrder,
                    "EOrder:Cannot open position": ccxt.InvalidOrder,
                    "EOrder:Insufficient funds (insufficient user funds)": ccxt.InsufficientFunds,
                    "EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)": ccxt.InsufficientFunds,
                    "EOrder:Invalid price": ccxt.InvalidOrder,
                    "EOrder:Margin allowance exceeded": ccxt.InvalidOrder,
                    "EOrder:Margin level too low": ccxt.InvalidOrder,
                    "EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)": ccxt.InvalidOrder,
                    "EOrder:ccxt.Order minimum not met (volume too low)": ccxt.InvalidOrder,
                    "EOrder:Orders limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Positions limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Rate limit exceeded": ccxt.RateLimitExceeded,
                    "EOrder:Scheduled orders limit exceeded": ccxt.InvalidOrder,
                    "EOrder:Unknown position": ccxt.OrderNotFound,
                    "EOrder:Unknown order": ccxt.OrderNotFound,
                    "EOrder:Invalid order": ccxt.InvalidOrder,
                    "EService:Deadline elapsed": ccxt.ExchangeNotAvailable,
                    "EService:ccxt.Market in cancel_only mode": ccxt.NotSupported,
                    "EService:ccxt.Market in limit_only mode": ccxt.NotSupported,
                    "EService:ccxt.Market in post_only mode": ccxt.NotSupported,
                    "EService:Unavailable": ccxt.ExchangeNotAvailable,
                    "ETrade:Invalid request": ccxt.BadRequest,
                    "ESession:Invalid session": ccxt.AuthenticationError,
                },
            },
        },
    })
}
func  (this *KrakenCore) OrderRequestWs(method interface{}, symbol interface{}, typeVar interface{}, request interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := ccxt.GetArg(optionalArgs, 0, nil)
    _ = price
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var isLimitOrder interface{} = ccxt.EndsWith(typeVar, "limit") // supporting limit, stop-loss-limit, take-profit-limit, etc
    if ccxt.IsTrue(isLimitOrder) {
        if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
            panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " limit orders require a price argument")))
        }
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, price)))
    }
    var isMarket interface{} =     (ccxt.IsEqual(typeVar, "market"))
    var postOnly interface{} = nil
    postOnlyparamsVariable := this.HandlePostOnly(isMarket, false, params)
    postOnly = ccxt.GetValue(postOnlyparamsVariable,0)
    params = ccxt.GetValue(postOnlyparamsVariable,1)
    if ccxt.IsTrue(postOnly) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "post_only", true)
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "cl_ord_id", clientOrderId)
    }
    var cost interface{} = this.SafeString(params, "cost")
    if ccxt.IsTrue(!ccxt.IsEqual(cost, nil)) {
        ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_qty", this.ParseToNumeric(this.CostToPrecision(symbol, cost)))
    }
    var stopLoss interface{} = this.SafeDict(params, "stopLoss", map[string]interface{} {})
    var takeProfit interface{} = this.SafeDict(params, "takeProfit", map[string]interface{} {})
    var presetStopLoss interface{} = this.SafeString(stopLoss, "triggerPrice")
    var presetTakeProfit interface{} = this.SafeString(takeProfit, "triggerPrice")
    var presetStopLossLimit interface{} = this.SafeString(stopLoss, "price")
    var presetTakeProfitLimit interface{} = this.SafeString(takeProfit, "price")
    var isPresetStopLoss interface{} = !ccxt.IsEqual(presetStopLoss, nil)
    var isPresetTakeProfit interface{} = !ccxt.IsEqual(presetTakeProfit, nil)
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var isStopLossPriceOrder interface{} = !ccxt.IsEqual(stopLossPrice, nil)
    var isTakeProfitPriceOrder interface{} = !ccxt.IsEqual(takeProfitPrice, nil)
    var trailingAmount interface{} = this.SafeString(params, "trailingAmount")
    var trailingPercent interface{} = this.SafeString(params, "trailingPercent")
    var trailingLimitAmount interface{} = this.SafeString(params, "trailingLimitAmount")
    var trailingLimitPercent interface{} = this.SafeString(params, "trailingLimitPercent")
    var isTrailingAmountOrder interface{} = !ccxt.IsEqual(trailingAmount, nil)
    var isTrailingPercentOrder interface{} = !ccxt.IsEqual(trailingPercent, nil)
    var isTrailingLimitAmountOrder interface{} = !ccxt.IsEqual(trailingLimitAmount, nil)
    var isTrailingLimitPercentOrder interface{} = !ccxt.IsEqual(trailingLimitPercent, nil)
    var offset interface{} = this.SafeString(params, "offset", "") // can set this to - for minus
    var trailingAmountString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingAmount, nil))), ccxt.Add(offset, this.NumberToString(trailingAmount)), nil)
    var trailingPercentString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingPercent, nil))), ccxt.Add(offset, this.NumberToString(trailingPercent)), nil)
    var trailingLimitAmountString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingLimitAmount, nil))), ccxt.Add(offset, this.NumberToString(trailingLimitAmount)), nil)
    var trailingLimitPercentString interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(trailingLimitPercent, nil))), ccxt.Add(offset, this.NumberToString(trailingLimitPercent)), nil)
    var priceType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(isTrailingPercentOrder) || ccxt.IsTrue(isTrailingLimitPercentOrder))), "pct", "quote")
    if ccxt.IsTrue(ccxt.IsEqual(method, "createOrderWs")) {
        var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
        if ccxt.IsTrue(reduceOnly) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "reduce_only", true)
        }
        var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
        if ccxt.IsTrue(!ccxt.IsEqual(timeInForce, nil)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "time_in_force", timeInForce)
        }
        params = this.Omit(params, []interface{}{"reduceOnly", "timeInForce"})
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) || ccxt.IsTrue(isTrailingAmountOrder)) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "triggers", map[string]interface{} {})
        }
        if ccxt.IsTrue(ccxt.IsTrue(isPresetStopLoss) || ccxt.IsTrue(isPresetTakeProfit)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "conditional", map[string]interface{} {})
            if ccxt.IsTrue(isPresetStopLoss) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "stop-loss")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetStopLoss)))
            } else if ccxt.IsTrue(isPresetTakeProfit) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "take-profit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetTakeProfit)))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(presetStopLossLimit, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "stop-loss-limit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetStopLossLimit)))
            } else if ccxt.IsTrue(!ccxt.IsEqual(presetTakeProfitLimit, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "order_type", "take-profit-limit")
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "conditional"), "limit_price", this.ParseToNumeric(this.PriceToPrecision(symbol, presetTakeProfitLimit)))
            }
            params = this.Omit(params, []interface{}{"stopLoss", "takeProfit"})
        } else if ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) {
            if ccxt.IsTrue(isStopLossPriceOrder) {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
                if ccxt.IsTrue(isLimitOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "stop-loss-limit")
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "stop-loss")
                }
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
                if ccxt.IsTrue(isLimitOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "take-profit-limit")
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "take-profit")
                }
            }
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price_type", priceType)
            if ccxt.IsTrue(!ccxt.IsTrue(isLimitOrder) && ccxt.IsTrue((ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)))) {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "trailing-stop")
                if ccxt.IsTrue(isTrailingAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingPercentString))
                }
            } else {
                // trailing limit orders are not conventionally supported because the static limit_price_type param is not available for trailing-stop-limit orders
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price_type", priceType)
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "order_type", "trailing-stop-limit")
                if ccxt.IsTrue(isTrailingLimitAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingLimitAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "params"), "triggers"), "price", this.ParseToNumeric(trailingLimitPercentString))
                }
            }
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(method, "editOrderWs")) {
        if ccxt.IsTrue(ccxt.IsTrue(isPresetStopLoss) || ccxt.IsTrue(isPresetTakeProfit)) {
            panic(ccxt.NotSupported(ccxt.Add(this.Id, " editing the stopLoss and takeProfit on existing orders is currently not supported")))
        }
        if ccxt.IsTrue(ccxt.IsTrue(isStopLossPriceOrder) || ccxt.IsTrue(isTakeProfitPriceOrder)) {
            if ccxt.IsTrue(isStopLossPriceOrder) {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
            }
        } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isTrailingLimitAmountOrder)) || ccxt.IsTrue(isTrailingLimitPercentOrder)) {
            ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price_type", priceType)
            if ccxt.IsTrue(!ccxt.IsTrue(isLimitOrder) && ccxt.IsTrue((ccxt.IsTrue(isTrailingAmountOrder) || ccxt.IsTrue(isTrailingPercentOrder)))) {
                if ccxt.IsTrue(isTrailingAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingPercentString))
                }
            } else {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit_price_type", priceType)
                if ccxt.IsTrue(isTrailingLimitAmountOrder) {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingLimitAmountString))
                } else {
                    ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "trigger_price", this.ParseToNumeric(trailingLimitPercentString))
                }
            }
        }
    }
    params = this.Omit(params, []interface{}{"clientOrderId", "cost", "offset", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingLimitAmount", "trailingLimitPercent"})
    return []interface{}{request, params}
}
/**
 * @method
 * @name kraken#createOrderWs
 * @description create a trade order
 * @see https://docs.kraken.com/api/docs/websocket-v2/add_order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2818)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "add_order",
                "params": map[string]interface{} {
                    "order_type": typeVar,
                    "side": side,
                    "order_qty": this.ParseToNumeric(this.AmountToPrecision(symbol, amount)),
                    "symbol": ccxt.GetValue(market, "symbol"),
                    "token": token,
                },
                "req_id": requestId,
            }
            requestparamsVariable := this.OrderRequestWs("createOrderWs", symbol, typeVar, request, amount, price, params)
            request = ccxt.GetValue(requestparamsVariable,0)
            params = ccxt.GetValue(requestparamsVariable,1)
        
                retRes29915 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes29915)
                ch <- retRes29915
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCreateEditOrder(client interface{}, message interface{})  {
    //
    //  createOrder
    //     {
    //         "method": "add_order",
    //         "req_id": 1,
    //         "result": {
    //             "order_id": "OXM2QD-EALR2-YBAVEU"
    //         },
    //         "success": true,
    //         "time_in": "2025-05-13T10:12:13.876173Z",
    //         "time_out": "2025-05-13T10:12:13.890137Z"
    //     }
    //
    //  editOrder
    //     {
    //         "method": "amend_order",
    //         "req_id": 1,
    //         "result": {
    //             "amend_id": "TYDLSQ-OYNYU-3MNRER",
    //             "order_id": "OGL7HR-SWFO4-NRQTHO"
    //         },
    //         "success": true,
    //         "time_in": "2025-05-14T13:54:10.840342Z",
    //         "time_out": "2025-05-14T13:54:10.855046Z"
    //     }
    //
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var order interface{} = this.ParseOrder(result)
    var messageHash interface{} = this.SafeString2(message, "reqid", "req_id")
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name kraken#editOrderWs
 * @description edit a trade order
 * @see https://docs.kraken.com/api/docs/websocket-v2/amend_order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3508)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "amend_order",
                "params": map[string]interface{} {
                    "order_id": id,
                    "order_qty": this.ParseToNumeric(this.AmountToPrecision(symbol, amount)),
                    "token": token,
                },
                "req_id": requestId,
            }
            requestparamsVariable := this.OrderRequestWs("editOrderWs", symbol, typeVar, request, amount, price, params)
            request = ccxt.GetValue(requestparamsVariable,0)
            params = ccxt.GetValue(requestparamsVariable,1)
        
                retRes36515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes36515)
                ch <- retRes36515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#cancelOrdersWs
 * @description cancel multiple orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelOrdersWs () does not support cancelling orders for a specific symbol.")))
            }
        
            retRes3828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3828)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_order",
                "params": map[string]interface{} {
                    "order_id": ids,
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes39515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes39515)
                ch <- retRes39515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#cancelOrderWs
 * @description cancels an open order
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_order
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelOrderWs () does not support cancelling orders for a specific symbol.")))
            }
        
            retRes4128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4128)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_order",
                "params": map[string]interface{} {
                    "order_id": []interface{}{id},
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes42515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes42515)
                ch <- retRes42515
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCancelOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "cancel_order",
    //         "req_id": 123456789,
    //         "result": {
    //             "order_id": "OKAGJC-YHIWK-WIOZWG"
    //         },
    //         "success": true,
    //         "time_in": "2023-09-21T14:36:57.428972Z",
    //         "time_out": "2023-09-21T14:36:57.437952Z"
    //     }
    //
    var reqId interface{} = this.SafeString(message, "req_id")
    client.(ccxt.ClientInterface).Resolve(message, reqId)
}
/**
 * @method
 * @name kraken#cancelAllOrdersWs
 * @description cancel all open orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/cancel_all
 * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelAllOrdersWs () does not support cancelling orders in a specific market.")))
            }
        
            retRes4588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4588)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var messageHash interface{} = this.NumberToString(requestId)
            var request interface{} = map[string]interface{} {
                "method": "cancel_all",
                "params": map[string]interface{} {
                    "token": token,
                },
                "req_id": requestId,
            }
        
                retRes47015 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes47015)
                ch <- retRes47015
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleCancelAllOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "cancel_all",
    //         "req_id": 123456789,
    //         "result": {
    //             "count": 1
    //         },
    //         "success": true,
    //         "time_in": "2023-09-21T14:36:57.428972Z",
    //         "time_out": "2023-09-21T14:36:57.437952Z"
    //     }
    //
    var reqId interface{} = this.SafeString(message, "req_id")
    client.(ccxt.ClientInterface).Resolve(message, reqId)
}
func  (this *KrakenCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "ticker",
    //         "type": "snapshot",
    //         "data": [
    //             {
    //                 "symbol": "BTC/USD",
    //                 "bid": 108359.8,
    //                 "bid_qty": 0.01362603,
    //                 "ask": 108359.9,
    //                 "ask_qty": 17.17988863,
    //                 "last": 108359.8,
    //                 "volume": 2158.32346723,
    //                 "vwap": 108894.5,
    //                 "low": 106824,
    //                 "high": 111300,
    //                 "change": -2679.9,
    //                 "change_pct": -2.41
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = ccxt.GetValue(data, 0)
    var symbol interface{} = this.SafeString(ticker, "symbol")
    var messageHash interface{} = this.GetMessageHash("ticker", nil, symbol)
    var vwap interface{} = this.SafeString(ticker, "vwap")
    var quoteVolume interface{} = nil
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(baseVolume, nil)) && ccxt.IsTrue(!ccxt.IsEqual(vwap, nil))) {
        quoteVolume = ccxt.Precise.StringMul(baseVolume, vwap)
    }
    var last interface{} = this.SafeString(ticker, "last")
    var result interface{} = this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bid_qty"),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "ask_qty"),
        "vwap": vwap,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "change"),
        "percentage": this.SafeString(ticker, "change_pct"),
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    })
    ccxt.AddElementToObject(this.Tickers, symbol, result)
    client.(ccxt.ClientInterface).Resolve(result, messageHash)
}
func  (this *KrakenCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "trade",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "side": "sell",
    //                 "price": 0.5117,
    //                 "qty": 40.0,
    //                 "ord_type": "market",
    //                 "trade_id": 4665906,
    //                 "timestamp": "2023-09-25T07:49:37.708706Z"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var trade interface{} = ccxt.GetValue(data, 0)
    var symbol interface{} = this.SafeString(trade, "symbol")
    var messageHash interface{} = this.GetMessageHash("trade", nil, symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var market interface{} = this.Market(symbol)
    var parsed interface{} = this.ParseTrades(data, market)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsed, i))
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *KrakenCore) HandleOHLCV(client interface{}, message interface{}, subscription interface{})  {
    //
    //     [
    //         216, // channelID
    //         [
    //             "1574454214.962096", // Time, seconds since epoch
    //             "1574454240.000000", // End timestamp of the interval
    //             "0.020970", // Open price at midnight UTC
    //             "0.020970", // Intraday high price
    //             "0.020970", // Intraday low price
    //             "0.020970", // Closing price at midnight UTC
    //             "0.020970", // Volume weighted average price
    //             "0.08636138", // Accumulated volume today
    //             1, // Number of trades today
    //         ],
    //         "ohlc-1", // Channel Name of subscription
    //         "ETH/XBT", // Asset pair
    //     ]
    //
    var info interface{} = this.SafeValue(subscription, "subscription", map[string]interface{} {})
    var interval interface{} = this.SafeInteger(info, "interval")
    var name interface{} = this.SafeString(info, "name")
    var wsName interface{} = this.SafeString(message, 3)
    var market interface{} = this.SafeValue(ccxt.GetValue(this.Options, "marketsByWsName"), wsName)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timeframe interface{} = this.FindTimeframe(interval)
    var duration interface{} = this.ParseTimeframe(timeframe)
    if ccxt.IsTrue(!ccxt.IsEqual(timeframe, nil)) {
        var candle interface{} = this.SafeValue(message, 1)
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, ":"), timeframe), ":"), wsName)
        var timestamp interface{} = this.SafeFloat(candle, 1)
        timestamp = ccxt.Subtract(timestamp, duration)
        var ts interface{} = this.ParseToInt(ccxt.Multiply(timestamp, 1000))
        var result interface{} = []interface{}{ts, this.SafeFloat(candle, 2), this.SafeFloat(candle, 3), this.SafeFloat(candle, 4), this.SafeFloat(candle, 5), this.SafeFloat(candle, 7)}
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(result)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
func  (this *KrakenCore) RequestId() interface{}  {
    // their support said that reqid must be an int32, not documented
    var reqid interface{} = this.Sum(this.SafeInteger(this.Options, "reqid", 0), 1)
    ccxt.AddElementToObject(this.Options, "reqid", reqid)
    return reqid
}
func  (this *KrakenCore) WatchPublic(name interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6478 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6478)
            var market interface{} = this.Market(symbol)
            var wsName interface{} = this.SafeValue(ccxt.GetValue(market, "info"), "wsname")
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), wsName)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "reqid": requestId,
                "pair": []interface{}{wsName},
                "subscription": map[string]interface{} {
                    "name": name,
                },
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes66415 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes66415)
                ch <- retRes66415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6778 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6778)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string[]} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6938)
            symbols = this.MarketSymbols(symbols, nil, false)
        
            ticker:= (<-this.WatchMultiHelper("ticker", "ticker", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.kraken.com/api/docs/websocket-v2/ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7148 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7148)
            symbols = this.MarketSymbols(symbols, nil, false)
            ccxt.AddElementToObject(params, "event_trigger", "bbo")
        
            ticker:= (<-this.WatchMultiHelper("bidask", "ticker", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.kraken.com/api/docs/websocket-v2/trade
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KrakenCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes73815 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes73815)
                ch <- retRes73815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://docs.kraken.com/api/docs/websocket-v2/trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KrakenCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.WatchMultiHelper("trade", "trade", symbols, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeList(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kraken.com/api/docs/websocket-v2/book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes77315 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes77315)
                ch <- retRes77315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kraken.com/api/docs/websocket-v2/book
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var requiredParams interface{} = map[string]interface{} {}
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(this.InArray(limit, []interface{}{10, 25, 100, 500, 1000})) {
                    ccxt.AddElementToObject(requiredParams, "depth", limit) // default 10, valid options 10, 25, 100, 500, 1000
                } else {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only")))
                }
            }
        
            orderbook:= (<-this.WatchMultiHelper("orderbook", "book", symbols, map[string]interface{} {
            "limit": limit,
        }, this.Extend(requiredParams, params)))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.kraken.com/api/docs/websocket-v1/ohlc
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *KrakenCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8128)
            var name interface{} = "ohlc"
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var wsName interface{} = this.SafeValue(ccxt.GetValue(market, "info"), "wsname")
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, ":"), timeframe), ":"), wsName)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "reqid": requestId,
                "pair": []interface{}{wsName},
                "subscription": map[string]interface{} {
                    "name": name,
                    "interval": this.SafeValue(this.Timeframes, timeframe, timeframe),
                },
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) LoadMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    reload := ccxt.GetArg(optionalArgs, 0, false)
            _ = reload
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.base.LoadMarkets(reload, params))
            ccxt.PanicOnError(markets)
            var marketsByWsName interface{} = this.SafeValue(this.Options, "marketsByWsName")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketsByWsName, nil))) || ccxt.IsTrue(reload)) {
                marketsByWsName = map[string]interface{} {}
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(this.Symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(this.Symbols, i)
                    var market interface{} = ccxt.GetValue(this.Markets, symbol)
                    var info interface{} = this.SafeValue(market, "info", map[string]interface{} {})
                    var wsName interface{} = this.SafeString(info, "wsname")
                    ccxt.AddElementToObject(marketsByWsName, wsName, market)
                }
                ccxt.AddElementToObject(this.Options, "marketsByWsName", marketsByWsName)
            }
        
            ch <- markets
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) Ping(client interface{}) interface{}  {
    var url interface{} = client.(ccxt.ClientInterface).GetUrl()
    var request interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "v2"), 0)) {
        ccxt.AddElementToObject(request, "method", "ping")
    } else {
        ccxt.AddElementToObject(request, "event", "ping")
    }
    return request
}
func  (this *KrakenCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *KrakenCore) WatchHeartbeat(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8738)
            var event interface{} = "heartbeat"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
        
                retRes87615 :=  (<-this.Watch(url, event))
                ccxt.PanicOnError(retRes87615)
                ch <- retRes87615
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleHeartbeat(client interface{}, message interface{})  {
    //
    // every second (approx) if no other updates are sent
    //
    //     { "event": "heartbeat" }
    //
    var event interface{} = this.SafeString(message, "event")
    client.(ccxt.ClientInterface).Resolve(message, event)
}
func  (this *KrakenCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // first message (snapshot)
    //
    //     {
    //         "channel": "book",
    //         "type": "snapshot",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "bids": [
    //                     {
    //                         "price": 0.5666,
    //                         "qty": 4831.75496356
    //                     },
    //                     {
    //                         "price": 0.5665,
    //                         "qty": 6658.22734739
    //                     }
    //                 ],
    //                 "asks": [
    //                     {
    //                         "price": 0.5668,
    //                         "qty": 4410.79769741
    //                     },
    //                     {
    //                         "price": 0.5669,
    //                         "qty": 4655.40412487
    //                     }
    //                 ],
    //                 "checksum": 2439117997
    //             }
    //         ]
    //     }
    //
    // subsequent updates
    //
    //     {
    //         "channel": "book",
    //         "type": "update",
    //         "data": [
    //             {
    //                 "symbol": "MATIC/USD",
    //                 "bids": [
    //                     {
    //                         "price": 0.5657,
    //                         "qty": 1098.3947558
    //                     }
    //                 ],
    //                 "asks": [],
    //                 "checksum": 2114181697,
    //                 "timestamp": "2023-10-06T17:35:55.440295Z"
    //             }
    //         ]
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
    var symbol interface{} = this.SafeString(first, "symbol")
    var a interface{} = this.SafeValue(first, "asks", []interface{}{})
    var b interface{} = this.SafeValue(first, "bids", []interface{}{})
    var c interface{} = this.SafeInteger(first, "checksum")
    var messageHash interface{} = this.GetMessageHash("orderbook", nil, symbol)
    var orderbook interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
        var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
        if ccxt.IsTrue(!ccxt.IsEqual(a, nil)) {
            this.CustomHandleDeltas(storedAsks, a)
        }
        if ccxt.IsTrue(!ccxt.IsEqual(b, nil)) {
            this.CustomHandleDeltas(storedBids, b)
        }
        var datetime interface{} = this.SafeString(first, "timestamp")
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
        ccxt.AddElementToObject(orderbook, "datetime", datetime)
    } else {
        // snapshot
        var depth interface{} =         ccxt.GetArrayLength(a)
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, depth))
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        var keys interface{} = []interface{}{"asks", "bids"}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var key interface{} = ccxt.GetValue(keys, i)
            var bookside interface{} = ccxt.GetValue(orderbook, key)
            var deltas interface{} = this.SafeValue(first, key, []interface{}{})
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(deltas), 0)) {
                this.CustomHandleDeltas(bookside, deltas)
            }
        }
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
    }
    orderbook.(ccxt.OrderBookInterface).Limit()
    // checksum temporarily disabled because the exchange checksum was not reliable
    var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", false)
    if ccxt.IsTrue(checksum) {
        var payloadArray interface{} = []interface{}{}
        if ccxt.IsTrue(!ccxt.IsEqual(c, nil)) {
            var checkAsks interface{} = ccxt.GetValue(orderbook, "asks")
            var checkBids interface{} = ccxt.GetValue(orderbook, "bids")
            // const checkAsks = asks.map ((elem) => [ elem['price'], elem['qty'] ])
            // const checkBids = bids.map ((elem) => [ elem['price'], elem['qty'] ])
            for i := 0; ccxt.IsLessThan(i, 10); i++ {
                var currentAsk interface{} = this.SafeValue(checkAsks, i, map[string]interface{} {})
                var formattedAsk interface{} = ccxt.Add(this.FormatNumber(ccxt.GetValue(currentAsk, 0)), this.FormatNumber(ccxt.GetValue(currentAsk, 1)))
                ccxt.AppendToArray(&payloadArray, formattedAsk)
            }
            for i := 0; ccxt.IsLessThan(i, 10); i++ {
                var currentBid interface{} = this.SafeValue(checkBids, i, map[string]interface{} {})
                var formattedBid interface{} = ccxt.Add(this.FormatNumber(ccxt.GetValue(currentBid, 0)), this.FormatNumber(ccxt.GetValue(currentBid, 1)))
                ccxt.AppendToArray(&payloadArray, formattedBid)
            }
        }
        var payload interface{} = ccxt.Join(payloadArray, "")
        var localChecksum interface{} = this.Crc32(payload, false)
        if ccxt.IsTrue(!ccxt.IsEqual(localChecksum, c)) {
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            ccxt.Remove(this.Orderbooks, symbol)
            client.(ccxt.ClientInterface).Reject(error, messageHash)
            return
        }
    }
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *KrakenCore) CustomHandleDeltas(bookside interface{}, deltas interface{})  {
    // const sortOrder = (key === 'bids') ? true : false
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(deltas)); j++ {
        var delta interface{} = ccxt.GetValue(deltas, j)
        var price interface{} = this.SafeNumber(delta, "price")
        var amount interface{} = this.SafeNumber(delta, "qty")
        bookside.(ccxt.IOrderBookSide).Store(price, amount)
    }
}
func  (this *KrakenCore) FormatNumber(data interface{}) interface{}  {
    var parts interface{} = ccxt.Split(data, ".")
    var integer interface{} = this.SafeString(parts, 0)
    var decimals interface{} = this.SafeString(parts, 1, "")
    var joinedResult interface{} = ccxt.Add(integer, decimals)
    var i interface{} = 0
    for ccxt.IsEqual(ccxt.GetValue(joinedResult, i), "0") {
        i = ccxt.Add(i, 1)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThan(i, 0)) {
        joinedResult = ccxt.Slice(joinedResult, i, nil)
    }
    return joinedResult
}
func  (this *KrakenCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "connectionID": 15527282728335292000,
    //         "event": "systemStatus",
    //         "status": "online", // online|maintenance|(custom status tbd)
    //         "version": "0.2.0"
    //     }
    //
    // v2
    //     {
    //         channel: 'status',
    //         type: 'update',
    //         data: [
    //             {
    //                 version: '2.0.10',
    //                 system: 'online',
    //                 api_version: 'v2',
    //                 connection_id: 6447481662169813000
    //             }
    //         ]
    //     }
    //
    return message
}
func  (this *KrakenCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var client interface{} = this.Client(url)
            var authenticated interface{} = "authenticated"
            var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), authenticated)
            var now interface{} = this.Seconds()
            var start interface{} = this.SafeInteger(subscription, "start")
            var expires interface{} = this.SafeInteger(subscription, "expires")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, nil))) || ccxt.IsTrue((ccxt.IsTrue((!ccxt.IsEqual(subscription, nil))) && ccxt.IsTrue(ccxt.IsLessThanOrEqual((ccxt.Add(start, expires)), now))))) {
                // https://docs.kraken.com/api/docs/rest-api/get-websockets-token
        
                response:= (<-this.PrivatePostGetWebSocketsToken(params))
                ccxt.PanicOnError(response)
                //
                //     {
                //         "error":[],
                //         "result":{
                //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
                //             "expires":900
                //         }
                //     }
                //
                subscription = this.SafeDict(response, "result")
                ccxt.AddElementToObject(subscription, "start", now)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), authenticated, subscription)
            }
        
            ch <- this.SafeString(subscription, "token")
            return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) WatchPrivate(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11098)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var subscriptionHash interface{} = name
            var messageHash interface{} = name
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "reqid": requestId,
                "subscription": map[string]interface{} {
                    "name": name,
                    "token": token,
                },
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            result:= (<-this.Watch(url, messageHash, request, subscriptionHash))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(result).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(result, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://docs.kraken.com/api/docs/websocket-v1/owntrades
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *KrakenCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes114715 :=  (<-this.WatchPrivate("ownTrades", symbol, since, limit, params))
                ccxt.PanicOnError(retRes114715)
                ch <- retRes114715
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleMyTrades(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     [
    //         [
    //             {
    //                 "TT5UC3-GOIRW-6AZZ6R": {
    //                     "cost": "1493.90107",
    //                     "fee": "3.88415",
    //                     "margin": "0.00000",
    //                     "ordertxid": "OTLAS3-RRHUF-NDWH5A",
    //                     "ordertype": "market",
    //                     "pair": "XBT/USDT",
    //                     "postxid": "TKH2SE-M7IF5-CFI7LT",
    //                     "price": "6851.50005",
    //                     "time": "1586822919.335498",
    //                     "type": "sell",
    //                     "vol": "0.21804000"
    //                 }
    //             },
    //             {
    //                 "TIY6G4-LKLAI-Y3GD4A": {
    //                     "cost": "22.17134",
    //                     "fee": "0.05765",
    //                     "margin": "0.00000",
    //                     "ordertxid": "ODQXS7-MOLK6-ICXKAA",
    //                     "ordertype": "market",
    //                     "pair": "ETH/USD",
    //                     "postxid": "TKH2SE-M7IF5-CFI7LT",
    //                     "price": "169.97999",
    //                     "time": "1586340530.895739",
    //                     "type": "buy",
    //                     "vol": "0.13043500"
    //                 }
    //             },
    //         ],
    //         "ownTrades",
    //         { sequence: 1 }
    //     ]
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var allTrades interface{} = this.SafeValue(message, 0, []interface{}{})
    var allTradesLength interface{} =     ccxt.GetArrayLength(allTrades)
    if ccxt.IsTrue(ccxt.IsGreaterThan(allTradesLength, 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCache(limit)
        }
        var stored interface{} = this.MyTrades
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(allTrades)); i++ {
            var trades interface{} = this.SafeValue(allTrades, i, map[string]interface{} {})
            var ids interface{} = ccxt.ObjectKeys(trades)
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(ids)); j++ {
                var id interface{} = ccxt.GetValue(ids, j)
                var trade interface{} = ccxt.GetValue(trades, id)
                var parsed interface{} = this.ParseWsTrade(this.Extend(map[string]interface{} {
                    "id": id,
                }, trade))
                stored.(ccxt.Appender).Append(parsed)
                var symbol interface{} = ccxt.GetValue(parsed, "symbol")
                ccxt.AddElementToObject(symbols, symbol, true)
            }
        }
        var name interface{} = "ownTrades"
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, name)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(keys, i))
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
        }
    }
}
func  (this *KrakenCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "TIMIRG-WUNNE-RRJ6GT", // injected from outside
    //         "ordertxid": "OQRPN2-LRHFY-HIFA7D",
    //         "postxid": "TKH2SE-M7IF5-CFI7LT",
    //         "pair": "USDCUSDT",
    //         "time": 1586340086.457,
    //         "type": "sell",
    //         "ordertype": "market",
    //         "price": "0.99860000",
    //         "cost": "22.16892001",
    //         "fee": "0.04433784",
    //         "vol": "22.20000000",
    //         "margin": "0.00000000",
    //         "misc": ''
    //     }
    //
    //     {
    //         "id": "TIY6G4-LKLAI-Y3GD4A",
    //         "cost": "22.17134",
    //         "fee": "0.05765",
    //         "margin": "0.00000",
    //         "ordertxid": "ODQXS7-MOLK6-ICXKAA",
    //         "ordertype": "market",
    //         "pair": "ETH/USD",
    //         "postxid": "TKH2SE-M7IF5-CFI7LT",
    //         "price": "169.97999",
    //         "time": "1586340530.895739",
    //         "type": "buy",
    //         "vol": "0.13043500"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var wsName interface{} = this.SafeString(trade, "pair")
    market = this.SafeValue(ccxt.GetValue(this.Options, "marketsByWsName"), wsName, market)
    var symbol interface{} = nil
    var orderId interface{} = this.SafeString(trade, "ordertxid")
    var id interface{} = this.SafeString2(trade, "id", "postxid")
    var timestamp interface{} = this.SafeTimestamp(trade, "time")
    var side interface{} = this.SafeString(trade, "type")
    var typeVar interface{} = this.SafeString(trade, "ordertype")
    var price interface{} = this.SafeFloat(trade, "price")
    var amount interface{} = this.SafeFloat(trade, "vol")
    var cost interface{} = nil
    var fee interface{} = nil
    if ccxt.IsTrue(ccxt.InOp(trade, "fee")) {
        var currency interface{} = nil
        if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
            currency = ccxt.GetValue(market, "quote")
        }
        fee = map[string]interface{} {
            "cost": this.SafeFloat(trade, "fee"),
            "currency": currency,
        }
    }
    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
        symbol = ccxt.GetValue(market, "symbol")
    }
    if ccxt.IsTrue(!ccxt.IsEqual(price, nil)) {
        if ccxt.IsTrue(!ccxt.IsEqual(amount, nil)) {
            cost = ccxt.Multiply(price, amount)
        }
    }
    return map[string]interface{} {
        "id": id,
        "order": orderId,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    }
}
/**
 * @method
 * @name kraken#watchOrders
 * @see https://docs.kraken.com/api/docs/websocket-v1/openorders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve
 * @param {object} [params] maximum number of orderic to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes131215 :=  (<-this.WatchPrivate("openOrders", symbol, since, limit, params))
                ccxt.PanicOnError(retRes131215)
                ch <- retRes131215
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleOrders(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //     [
    //         [
    //             {
    //                 "OGTT3Y-C6I3P-XRI6HX": {
    //                     "cost": "0.00000",
    //                     "descr": {
    //                         "close": "",
    //                         "leverage": "0:1",
    //                         "order": "sell 10.00345345 XBT/EUR @ limit 34.50000 with 0:1 leverage",
    //                         "ordertype": "limit",
    //                         "pair": "XBT/EUR",
    //                         "price": "34.50000",
    //                         "price2": "0.00000",
    //                         "type": "sell"
    //                     },
    //                     "expiretm": "0.000000",
    //                     "fee": "0.00000",
    //                     "limitprice": "34.50000",
    //                     "misc": "",
    //                     "oflags": "fcib",
    //                     "opentm": "0.000000",
    //                     "price": "34.50000",
    //                     "refid": "OKIVMP-5GVZN-Z2D2UA",
    //                     "starttm": "0.000000",
    //                     "status": "open",
    //                     "stopprice": "0.000000",
    //                     "userref": 0,
    //                     "vol": "10.00345345",
    //                     "vol_exec": "0.00000000"
    //                 }
    //             },
    //             {
    //                 "OGTT3Y-C6I3P-XRI6HX": {
    //                     "cost": "0.00000",
    //                     "descr": {
    //                         "close": "",
    //                         "leverage": "0:1",
    //                         "order": "sell 0.00000010 XBT/EUR @ limit 5334.60000 with 0:1 leverage",
    //                         "ordertype": "limit",
    //                         "pair": "XBT/EUR",
    //                         "price": "5334.60000",
    //                         "price2": "0.00000",
    //                         "type": "sell"
    //                     },
    //                     "expiretm": "0.000000",
    //                     "fee": "0.00000",
    //                     "limitprice": "5334.60000",
    //                     "misc": "",
    //                     "oflags": "fcib",
    //                     "opentm": "0.000000",
    //                     "price": "5334.60000",
    //                     "refid": "OKIVMP-5GVZN-Z2D2UA",
    //                     "starttm": "0.000000",
    //                     "status": "open",
    //                     "stopprice": "0.000000",
    //                     "userref": 0,
    //                     "vol": "0.00000010",
    //                     "vol_exec": "0.00000000"
    //                 }
    //             },
    //         ],
    //         "openOrders",
    //         { "sequence": 234 }
    //     ]
    //
    // status-change
    //
    //     [
    //         [
    //             { "OGTT3Y-C6I3P-XRI6HX": { "status": "closed" }},
    //             { "OGTT3Y-C6I3P-XRI6HX": { "status": "closed" }},
    //         ],
    //         "openOrders",
    //         { "sequence": 59342 }
    //     ]
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var allOrders interface{} = this.SafeValue(message, 0, []interface{}{})
    var allOrdersLength interface{} =     ccxt.GetArrayLength(allOrders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(allOrdersLength, 0)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(allOrders)); i++ {
            var orders interface{} = this.SafeValue(allOrders, i, map[string]interface{} {})
            var ids interface{} = ccxt.ObjectKeys(orders)
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(ids)); j++ {
                var id interface{} = ccxt.GetValue(ids, j)
                var order interface{} = ccxt.GetValue(orders, id)
                var parsed interface{} = this.ParseWsOrder(order)
                ccxt.AddElementToObject(parsed, "id", id)
                var symbol interface{} = nil
                var symbolsByOrderId interface{} = this.SafeValue(this.Options, "symbolsByOrderId", map[string]interface{} {})
                if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(parsed, "symbol"), nil)) {
                    symbol = ccxt.GetValue(parsed, "symbol")
                    ccxt.AddElementToObject(symbolsByOrderId, id, symbol)
                    ccxt.AddElementToObject(this.Options, "symbolsByOrderId", symbolsByOrderId)
                } else {
                    symbol = this.SafeString(symbolsByOrderId, id)
                }
                var previousOrders interface{} = this.SafeValue(stored.(*ccxt.ArrayCache).Hashmap, symbol)
                var previousOrder interface{} = this.SafeValue(previousOrders, id)
                var newOrder interface{} = parsed
                if ccxt.IsTrue(!ccxt.IsEqual(previousOrder, nil)) {
                    var newRawOrder interface{} = this.Extend(ccxt.GetValue(previousOrder, "info"), ccxt.GetValue(newOrder, "info"))
                    newOrder = this.ParseWsOrder(newRawOrder)
                    ccxt.AddElementToObject(newOrder, "id", id)
                }
                var length interface{} =                 ccxt.GetArrayLength(stored)
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(length, limit)) && ccxt.IsTrue((ccxt.IsEqual(previousOrder, nil)))) {
                    var first interface{} = ccxt.GetValue(stored, 0)
                    if ccxt.IsTrue(ccxt.InOp(symbolsByOrderId, ccxt.GetValue(first, "id"))) {
                        ccxt.Remove(symbolsByOrderId, ccxt.GetValue(first, "id"))
                    }
                }
                stored.(ccxt.Appender).Append(newOrder)
                ccxt.AddElementToObject(symbols, symbol, true)
            }
        }
        var name interface{} = "openOrders"
        client.(ccxt.ClientInterface).Resolve(this.Orders, name)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(keys, i))
            client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        }
    }
}
func  (this *KrakenCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //    {
    //        "avg_price": "0.00000",
    //        "cost": "0.00000",
    //        "descr": {
    //            "close": null,
    //            "leverage": null,
    //            "order": "sell 0.01000000 ETH/USDT @ limit 1900.00000",
    //            "ordertype": "limit",
    //            "pair": "ETH/USDT",
    //            "price": "1900.00000",
    //            "price2": "0.00000",
    //            "type": "sell"
    //        },
    //        "expiretm": null,
    //        "fee": "0.00000",
    //        "limitprice": "0.00000",
    //        "misc": '',
    //        "oflags": "fciq",
    //        "opentm": "1667522705.757622",
    //        "refid": null,
    //        "starttm": null,
    //        "status": "open",
    //        "stopprice": "0.00000",
    //        "timeinforce": "GTC",
    //        "userref": 0,
    //        "vol": "0.01000000",
    //        "vol_exec": "0.00000000"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var description interface{} = this.SafeValue(order, "descr", map[string]interface{} {})
    var orderDescription interface{} = this.SafeString(description, "order")
    var side interface{} = nil
    var typeVar interface{} = nil
    var wsName interface{} = nil
    var price interface{} = nil
    var amount interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(orderDescription, nil)) {
        var parts interface{} = ccxt.Split(orderDescription, " ")
        side = this.SafeString(parts, 0)
        amount = this.SafeString(parts, 1)
        wsName = this.SafeString(parts, 2)
        typeVar = this.SafeString(parts, 4)
        price = this.SafeString(parts, 5)
    }
    side = this.SafeString(description, "type", side)
    typeVar = this.SafeString(description, "ordertype", typeVar)
    wsName = this.SafeString(description, "pair", wsName)
    market = this.SafeValue(ccxt.GetValue(this.Options, "marketsByWsName"), wsName, market)
    var symbol interface{} = nil
    var timestamp interface{} = this.SafeTimestamp(order, "opentm")
    amount = this.SafeString(order, "vol", amount)
    var filled interface{} = this.SafeString(order, "vol_exec")
    var fee interface{} = nil
    var cost interface{} = this.SafeString(order, "cost")
    price = this.SafeString(description, "price", price)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(price, nil))) || ccxt.IsTrue((ccxt.Precise.StringEq(price, "0.0")))) {
        price = this.SafeString(description, "price2")
    }
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(price, nil))) || ccxt.IsTrue((ccxt.Precise.StringEq(price, "0.0")))) {
        price = this.SafeString(order, "price", price)
    }
    var average interface{} = this.SafeString2(order, "avg_price", "price")
    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
        symbol = ccxt.GetValue(market, "symbol")
        if ccxt.IsTrue(ccxt.InOp(order, "fee")) {
            var flags interface{} = ccxt.GetValue(order, "oflags")
            var feeCost interface{} = this.SafeString(order, "fee")
            fee = map[string]interface{} {
                "cost": feeCost,
                "rate": nil,
            }
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(flags, "fciq"), 0)) {
                ccxt.AddElementToObject(fee, "currency", ccxt.GetValue(market, "quote"))
            } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(flags, "fcib"), 0)) {
                ccxt.AddElementToObject(fee, "currency", ccxt.GetValue(market, "base"))
            }
        }
    }
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var id interface{} = this.SafeString(order, "id")
    if ccxt.IsTrue(ccxt.IsEqual(id, nil)) {
        var txid interface{} = this.SafeValue(order, "txid")
        id = this.SafeString(txid, 0)
    }
    var clientOrderId interface{} = this.SafeString(order, "userref")
    var rawTrades interface{} = this.SafeValue(order, "trades")
    var trades interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(rawTrades, nil)) {
        trades = this.ParseTrades(rawTrades, market, nil, nil, map[string]interface{} {
            "order": id,
        })
    }
    var stopPrice interface{} = this.SafeNumber(order, "stopprice")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "cost": cost,
        "amount": amount,
        "filled": filled,
        "average": average,
        "remaining": nil,
        "fee": fee,
        "trades": trades,
    })
}
func  (this *KrakenCore) WatchMultiHelper(unifiedName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            subscriptionArgs := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscriptionArgs
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes15698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15698)
            // symbols are required
            symbols = this.MarketSymbols(symbols, nil, false, true, false)
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var eventTrigger interface{} = this.SafeString(params, "event_trigger")
                if ccxt.IsTrue(!ccxt.IsEqual(eventTrigger, nil)) {
                    ccxt.AppendToArray(&messageHashes, this.GetMessageHash(channelName, nil, this.Symbol(ccxt.GetValue(symbols, i))))
                } else {
                    ccxt.AppendToArray(&messageHashes, this.GetMessageHash(unifiedName, nil, this.Symbol(ccxt.GetValue(symbols, i))))
                }
            }
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": channelName,
                    "symbol": symbols,
                },
                "req_id": this.RequestId(),
            }
            ccxt.AddElementToObject(request, "params", this.DeepExtend(ccxt.GetValue(request, "params"), params))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "publicV2")
        
                retRes159115 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes, subscriptionArgs))
                ccxt.PanicOnError(retRes159115)
                ch <- retRes159115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kraken#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.kraken.com/api/docs/websocket-v2/balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *KrakenCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16038)
        
            token:= (<-this.Authenticate())
            ccxt.PanicOnError(token)
            var messageHash interface{} = "balances"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "req_id": requestId,
                "params": map[string]interface{} {
                    "channel": "balances",
                    "token": token,
                },
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes161715 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes161715)
                ch <- retRes161715
                return nil
        
            }()
            return ch
        }
func  (this *KrakenCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "balances",
    //         "data": [
    //             {
    //                 "asset": "BTC",
    //                 "asset_class": "currency",
    //                 "balance": 1.2,
    //                 "wallets": [
    //                     {
    //                         "type": "spot",
    //                         "id": "main",
    //                         "balance": 1.2
    //                     }
    //                 ]
    //             }
    //         ],
    //         "type": "snapshot",
    //         "sequence": 1
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": message,
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var currencyId interface{} = this.SafeString(ccxt.GetValue(data, i), "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var eq interface{} = this.SafeString(ccxt.GetValue(data, i), "balance")
        ccxt.AddElementToObject(account, "total", eq)
        ccxt.AddElementToObject(result, code, account)
    }
    var typeVar interface{} = "spot"
    var balance interface{} = this.SafeBalance(result)
    var oldBalance interface{} = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
    var newBalance interface{} = this.DeepExtend(oldBalance, balance)
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(newBalance))
    var channel interface{} = this.SafeString(message, "channel")
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), channel)
}
func  (this *KrakenCore) GetMessageHash(unifiedElementName interface{}, optionalArgs ...interface{}) interface{}  {
    // unifiedElementName can be : orderbook, trade, ticker, bidask ...
    // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
    subChannelName := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subChannelName
    symbol := ccxt.GetArg(optionalArgs, 1, nil)
    _ = symbol
    var withSymbol interface{} = !ccxt.IsEqual(symbol, nil)
    var messageHash interface{} = unifiedElementName
    if !ccxt.IsTrue(withSymbol) {
        messageHash = ccxt.Add(messageHash, "s")
    } else {
        messageHash = ccxt.Add(messageHash, ccxt.Add("@", symbol))
    }
    if ccxt.IsTrue(!ccxt.IsEqual(subChannelName, nil)) {
        messageHash = ccxt.Add(messageHash, ccxt.Add("#", subChannelName))
    }
    return messageHash
}
func  (this *KrakenCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    // public
    //
    //     {
    //         "channelID": 210,
    //         "channelName": "book-10",
    //         "event": "subscriptionStatus",
    //         "reqid": 1574146735269,
    //         "pair": "ETH/XBT",
    //         "status": "subscribed",
    //         "subscription": { depth: 10, name: "book" }
    //     }
    //
    // private
    //
    //     {
    //         "channelName": "openOrders",
    //         "event": "subscriptionStatus",
    //         "reqid": 1,
    //         "status": "subscribed",
    //         "subscription": { maxratecount: 125, name: "openOrders" }
    //     }
    //
    var channelId interface{} = this.SafeString(message, "channelID")
    if ccxt.IsTrue(!ccxt.IsEqual(channelId, nil)) {
        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), channelId, message)
    }
}
func  (this *KrakenCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "errorMessage": "ccxt.Currency pair not in ISO 4217-A3 format foobar",
    //         "event": "subscriptionStatus",
    //         "pair": "foobar",
    //         "reqid": 1574146735269,
    //         "status": "error",
    //         "subscription": { name: "ticker" }
    //     }
    //
    // v2
    //     {
    //         "error": "Unsupported field: 'price' for the given msg type: add order",
    //         "method": "add_order",
    //         "success": false,
    //         "time_in": "2025-05-13T08:59:44.803511Z",
    //         "time_out": "2025-05-13T08:59:44.803542Z'
    //     }
    //
    var errorMessage interface{} = this.SafeString2(message, "errorMessage", "error")
    if ccxt.IsTrue(!ccxt.IsEqual(errorMessage, nil)) {
        var requestId interface{} = this.SafeString2(message, "reqid", "req_id")
        var broad interface{} = ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad")
        var broadKey interface{} = this.FindBroadlyMatchedKey(broad, errorMessage)
        var exception interface{} = nil
        if ccxt.IsTrue(ccxt.IsEqual(broadKey, nil)) {
            exception = ccxt.ExchangeError(            errorMessage) // c# requirement to convert the errorMessage to string
        } else {
            exception = ccxt.CallDynamically(ccxt.GetValue(broad, broadKey), errorMessage)
        }
        if ccxt.IsTrue(!ccxt.IsEqual(requestId, nil)) {
            client.(ccxt.ClientInterface).Reject(exception, requestId)
        }
        return false
    }
    return true
}
func  (this *KrakenCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        var channelId interface{} = this.SafeString(message, 0)
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), channelId, map[string]interface{} {})
        var info interface{} = this.SafeValue(subscription, "subscription", map[string]interface{} {})
        var messageLength interface{} =         ccxt.GetArrayLength(message)
        var channelName interface{} = this.SafeString(message, ccxt.Subtract(messageLength, 2))
        var name interface{} = this.SafeString(info, "name")
        var methods interface{} = map[string]interface{} {
            "ohlc": this.HandleOHLCV,
            "openOrders": this.HandleOrders,
            "ownTrades": this.HandleMyTrades,
        }
        var method interface{} = this.SafeValue2(methods, name, channelName)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message, subscription)
        }
    } else {
        var channel interface{} = this.SafeString(message, "channel")
        if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
            var methods interface{} = map[string]interface{} {
                "balances": this.HandleBalance,
                "book": this.HandleOrderBook,
                "ticker": this.HandleTicker,
                "trade": this.HandleTrades,
            }
            var method interface{} = this.SafeValue(methods, channel)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
            }
        }
        if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
            var event interface{} = this.SafeString2(message, "event", "method")
            var methods interface{} = map[string]interface{} {
                "heartbeat": this.HandleHeartbeat,
                "systemStatus": this.HandleSystemStatus,
                "subscriptionStatus": this.HandleSubscriptionStatus,
                "add_order": this.HandleCreateEditOrder,
                "amend_order": this.HandleCreateEditOrder,
                "cancel_order": this.HandleCancelOrder,
                "cancel_all": this.HandleCancelAllOrders,
                "pong": this.HandlePong,
            }
            var method interface{} = this.SafeValue(methods, event)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
            }
        }
    }
}


func (this *KrakenCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
