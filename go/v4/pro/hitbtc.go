package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HitbtcCore struct {
	*ccxt.HitbtcCore
	base *ccxt.HitbtcCore
}

func NewHitbtcCore() *HitbtcCore {
    p := &HitbtcCore{}
	base := &ccxt.HitbtcCore{}
	p.base = base
	p.HitbtcCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *HitbtcCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOrderBook": true,
            "watchBalance": true,
            "watchOrders": true,
            "watchOHLCV": true,
            "watchMyTrades": false,
            "createOrderWs": true,
            "cancelOrderWs": true,
            "fetchOpenOrdersWs": true,
            "cancelAllOrdersWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.hitbtc.com/api/3/ws/public",
                    "private": "wss://api.hitbtc.com/api/3/ws/trading",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.demo.hitbtc.com/api/3/ws/public",
                    "private": "wss://api.demo.hitbtc.com/api/3/ws/trading",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "watchTicker": map[string]interface{} {
                "method": "ticker/{speed}",
            },
            "watchTickers": map[string]interface{} {
                "method": "ticker/{speed}",
            },
            "watchBidsAsks": map[string]interface{} {
                "method": "orderbook/top/{speed}",
            },
            "watchOrderBook": map[string]interface{} {
                "method": "orderbook/full",
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "M1",
            "3m": "M3",
            "5m": "M5",
            "15m": "M15",
            "30m": "M30",
            "1h": "H1",
            "4h": "H4",
            "1d": "D1",
            "1w": "D7",
            "1M": "1M",
        },
        "streaming": map[string]interface{} {
            "keepAlive": 4000,
        },
    })
}
/**
 * @ignore
 * @method
 * @description authenticates the user to access private web socket channels
 * @see https://api.hitbtc.com/#socket-authentication
 * @returns {object} response from exchange
 */
func  (this *HitbtcCore) Authenticate() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                this.CheckRequiredCredentials()
        var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
        var messageHash interface{} = "authenticated"
        var client interface{} = this.Client(url)
        var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
        var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
            var timestamp interface{} = this.Milliseconds()
            var signature interface{} = this.Hmac(this.Encode(this.NumberToString(timestamp)), this.Encode(this.Secret), ccxt.Sha256, "hex")
            var request interface{} = map[string]interface{} {
                "method": "login",
                "params": map[string]interface{} {
                    "type": "HS256",
                    "api_key": this.ApiKey,
                    "timestamp": timestamp,
                    "signature": signature,
                },
            }
            this.Watch(url, messageHash, request, messageHash)
        }
        
            retRes12515 := <- future.(*ccxt.Future).Await()
            ccxt.PanicOnError(retRes12515)
            ch <- retRes12515
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @param {string} name websocket endpoint name
 * @param {string} messageHashPrefix prefix for the message hash
 * @param {string[]} [symbols] unified CCXT symbol(s)
 * @param {object} [params] extra parameters specific to the hitbtc api
 */
func  (this *HitbtcCore) SubscribePublic(name interface{}, messageHashPrefix interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1378)
            symbols = this.MarketSymbols(symbols)
            var isBatch interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(name, "batch"), 0)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) && !ccxt.IsTrue(isBatch)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHashPrefix, "::"), ccxt.GetValue(symbols, i)))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, messageHashPrefix)
            }
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "id": this.Nonce(),
                "ch": name,
            }
            var request interface{} = this.Extend(subscribe, params)
        
                retRes15515 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes15515)
                ch <- retRes15515
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @param {string} name websocket endpoint name
 * @param {string} [symbol] unified CCXT symbol
 * @param {object} [params] extra parameters specific to the hitbtc api
 */
func  (this *HitbtcCore) SubscribePrivate(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1668)
        
            retRes1678 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1678)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var splitName interface{} = ccxt.Split(name, "_subscribe")
            var messageHash interface{} = this.SafeString(splitName, 0)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
            }
            var subscribe interface{} = map[string]interface{} {
                "method": name,
                "params": params,
                "id": this.Nonce(),
            }
        
                retRes17915 :=  (<-this.Watch(url, messageHash, subscribe, messageHash))
                ccxt.PanicOnError(retRes17915)
                ch <- retRes17915
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @param {string} name websocket endpoint name
 * @param {object} [params] extra parameters specific to the hitbtc api
 */
func  (this *HitbtcCore) TradeRequest(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1898)
        
            retRes1908 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1908)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var subscribe interface{} = map[string]interface{} {
                "method": name,
                "params": params,
                "id": messageHash,
            }
        
                retRes19815 :=  (<-this.Watch(url, messageHash, subscribe, messageHash))
                ccxt.PanicOnError(retRes19815)
                ch <- retRes19815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.hitbtc.com/#subscribe-to-full-order-book
 * @see https://api.hitbtc.com/#subscribe-to-partial-order-book
 * @see https://api.hitbtc.com/#subscribe-to-partial-order-book-in-batches
 * @see https://api.hitbtc.com/#subscribe-to-top-of-book
 * @see https://api.hitbtc.com/#subscribe-to-top-of-book-in-batches
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] 'orderbook/full', 'orderbook/{depth}/{speed}', 'orderbook/{depth}/{speed}/batch'
 * @param {int} [params.depth] 5 , 10, or 20 (default)
 * @param {int} [params.speed] 100 (default), 500, or 1000
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HitbtcCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook")
            var defaultMethod interface{} = this.SafeString(options, "method", "orderbook/full")
            var name interface{} = this.SafeString2(params, "method", "defaultMethod", defaultMethod)
            var depth interface{} = this.SafeString(params, "depth", "20")
            var speed interface{} = this.SafeString(params, "depth", "100")
            if ccxt.IsTrue(ccxt.IsEqual(name, "orderbook/{depth}/{speed}")) {
                name = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("orderbook/D", depth), "/"), speed), "ms")
            } else if ccxt.IsTrue(ccxt.IsEqual(name, "orderbook/{depth}/{speed}/batch")) {
                name = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("orderbook/D", depth), "/"), speed), "ms/batch")
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "params": map[string]interface{} {
                    "symbols": []interface{}{ccxt.GetValue(market, "id")},
                },
            }
        
            orderbook:= (<-this.SubscribePublic(name, "orderbooks", []interface{}{symbol}, this.DeepExtend(request, params)))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "ch": "orderbook/full",                 // Channel
    //        "snapshot": {
    //            "ETHBTC": {
    //                "t": 1626866578796,             // Timestamp in milliseconds
    //                "s": 27617207,                  // Sequence number
    //                "a": [                          // ccxt.Asks
    //                    ["0.060506", "0"],
    //                    ["0.060549", "12.6431"],
    //                    ["0.060570", "0"],
    //                    ["0.060612", "0"]
    //                ],
    //                "b": [                          // ccxt.Bids
    //                    ["0.060439", "4.4095"],
    //                    ["0.060414", "0"],
    //                    ["0.060407", "7.3349"],
    //                    ["0.060390", "0"]
    //                ]
    //            }
    //        }
    //    }
    //
    var snapshot interface{} = this.SafeDict(message, "snapshot")
    var update interface{} = this.SafeDict(message, "update")
    var data interface{} = ccxt.Ternary(ccxt.IsTrue(snapshot), snapshot, update)
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(snapshot), "snapshot", "update")
    var marketIds interface{} = ccxt.ObjectKeys(data)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var item interface{} = ccxt.GetValue(data, marketId)
        var messageHash interface{} = ccxt.Add("orderbooks::", symbol)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var subscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
            var limit interface{} = this.SafeInteger(subscription, "limit")
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.SafeInteger(item, "t")
        var nonce interface{} = this.SafeInteger(item, "s")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
            var parsedSnapshot interface{} = this.ParseOrderBook(item, symbol, timestamp, "b", "a")
            orderbook.(ccxt.OrderBookInterface).Reset(parsedSnapshot)
        } else {
            var asks interface{} = this.SafeList(item, "a", []interface{}{})
            var bids interface{} = this.SafeList(item, "b", []interface{}{})
            this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
            this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        }
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(orderbook, "nonce", nonce)
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *HitbtcCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeNumber(delta, 0)
    var amount interface{} = this.SafeNumber(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *HitbtcCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name hitbtc#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.hitbtc.com/#subscribe-to-ticker
 * @see https://api.hitbtc.com/#subscribe-to-ticker-in-batches
 * @see https://api.hitbtc.com/#subscribe-to-mini-ticker
 * @see https://api.hitbtc.com/#subscribe-to-mini-ticker-in-batches
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] 'ticker/{speed}' (default), or 'ticker/price/{speed}'
 * @param {string} [params.speed] '1s' (default), or '3s'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HitbtcCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            ticker:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(ticker)
        
            ch <- this.SafeValue(ticker, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string[]} [symbols]
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {string} params.method 'ticker/{speed}' ,'ticker/price/{speed}', 'ticker/{speed}/batch' (default), or 'ticker/{speed}/price/batch''
 * @param {string} params.speed '1s' (default), or '3s'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *HitbtcCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3428)
            symbols = this.MarketSymbols(symbols)
            var options interface{} = this.SafeValue(this.Options, "watchTicker")
            var defaultMethod interface{} = this.SafeString(options, "method", "ticker/{speed}/batch")
            var method interface{} = this.SafeString2(params, "method", "defaultMethod", defaultMethod)
            var speed interface{} = this.SafeString(params, "speed", "1s")
            var name interface{} = this.ImplodeParams(method, map[string]interface{} {
                "speed": speed,
            })
            params = this.Omit(params, []interface{}{"method", "speed"})
            var marketIds interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&marketIds, "*")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var marketId interface{} = this.MarketId(ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&marketIds, marketId)
                }
            }
            var request interface{} = map[string]interface{} {
                "params": map[string]interface{} {
                    "symbols": marketIds,
                },
            }
        
            newTickers:= (<-this.SubscribePublic(name, "tickers", symbols, this.DeepExtend(request, params)))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                if !ccxt.IsTrue(ccxt.IsArray(newTickers)) {
                    var tickers interface{} = map[string]interface{} {}
                    ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                    ch <- tickers
                    return nil
                }
            }
        
            ch <- this.FilterByArray(newTickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "ch": "ticker/1s",
    //        "data": {
    //            "ETHBTC": {
    //                "t": 1614815872000,             // Timestamp in milliseconds
    //                "a": "0.031175",                // Best ask
    //                "A": "0.03329",                 // Best ask quantity
    //                "b": "0.031148",                // Best bid
    //                "B": "0.10565",                 // Best bid quantity
    //                "c": "0.031210",                // Last price
    //                "o": "0.030781",                // Open price
    //                "h": "0.031788",                // High price
    //                "l": "0.030733",                // Low price
    //                "v": "62.587",                  // Base asset volume
    //                "q": "1.951420577",             // Quote asset volume
    //                "p": "0.000429",                // Price change
    //                "P": "1.39",                    // Price change percent
    //                "L": 1182694927                 // Last trade identifier
    //            }
    //        }
    //    }
    //
    //    {
    //        "ch": "ticker/price/1s",
    //        "data": {
    //            "BTCUSDT": {
    //                "t": 1614815872030,
    //                "o": "32636.79",
    //                "c": "32085.51",
    //                "h": "33379.92",
    //                "l": "30683.28",
    //                "v": "11.90667",
    //                "q": "384081.1955629"
    //            }
    //        }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var marketIds interface{} = ccxt.ObjectKeys(data)
    var result interface{} = []interface{}{}
    var topic interface{} = "tickers"
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var ticker interface{} = this.ParseWsTicker(ccxt.GetValue(data, marketId), market)
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        ccxt.AppendToArray(&result, ticker)
        var messageHash interface{} = ccxt.Add(ccxt.Add(topic, "::"), symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
func  (this *HitbtcCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "t": 1614815872000,             // Timestamp in milliseconds
    //        "a": "0.031175",                // Best ask
    //        "A": "0.03329",                 // Best ask quantity
    //        "b": "0.031148",                // Best bid
    //        "B": "0.10565",                 // Best bid quantity
    //        "c": "0.031210",                // Last price
    //        "o": "0.030781",                // Open price
    //        "h": "0.031788",                // High price
    //        "l": "0.030733",                // Low price
    //        "v": "62.587",                  // Base asset volume
    //        "q": "1.951420577",             // Quote asset volume
    //        "p": "0.000429",                // Price change
    //        "P": "1.39",                    // Price change percent
    //        "L": 1182694927                 // Last trade identifier
    //    }
    //
    //    {
    //        "t": 1614815872030,
    //        "o": "32636.79",
    //        "c": "32085.51",
    //        "h": "33379.92",
    //        "l": "30683.28",
    //        "v": "11.90667",
    //        "q": "384081.1955629"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var symbol interface{} = this.SafeSymbol(nil, market)
    var last interface{} = this.SafeString(ticker, "c")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "h"),
        "low": this.SafeString(ticker, "l"),
        "bid": this.SafeString(ticker, "b"),
        "bidVolume": this.SafeString(ticker, "B"),
        "ask": this.SafeString(ticker, "a"),
        "askVolume": this.SafeString(ticker, "A"),
        "vwap": nil,
        "open": this.SafeString(ticker, "o"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": this.SafeString(ticker, "q"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name hitbtc#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://api.hitbtc.com/#subscribe-to-top-of-book
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] 'orderbook/top/{speed}' or 'orderbook/top/{speed}/batch (default)'
 * @param {string} [params.speed] '100ms' (default) or '500ms' or '1000ms'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HitbtcCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4998)
            symbols = this.MarketSymbols(symbols, nil, false)
            var options interface{} = this.SafeValue(this.Options, "watchBidsAsks")
            var defaultMethod interface{} = this.SafeString(options, "method", "orderbook/top/{speed}/batch")
            var method interface{} = this.SafeString2(params, "method", "defaultMethod", defaultMethod)
            var speed interface{} = this.SafeString(params, "speed", "100ms")
            var name interface{} = this.ImplodeParams(method, map[string]interface{} {
                "speed": speed,
            })
            params = this.Omit(params, []interface{}{"method", "speed"})
            var marketIds interface{} = this.MarketIds(symbols)
            var request interface{} = map[string]interface{} {
                "params": map[string]interface{} {
                    "symbols": marketIds,
                },
            }
        
            newTickers:= (<-this.SubscribePublic(name, "bidask", symbols, this.DeepExtend(request, params)))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                if !ccxt.IsTrue(ccxt.IsArray(newTickers)) {
                    var tickers interface{} = map[string]interface{} {}
                    ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                    ch <- tickers
                    return nil
                }
            }
        
            ch <- this.FilterByArray(newTickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "ch": "orderbook/top/100ms", // or 'orderbook/top/100ms/batch'
    //         "data": {
    //             "BTCUSDT": {
    //                 "t": 1727276919771,
    //                 "a": "63931.45",
    //                 "A": "0.02879",
    //                 "b": "63926.97",
    //                 "B": "0.00100"
    //             }
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketIds interface{} = ccxt.ObjectKeys(data)
    var result interface{} = []interface{}{}
    var topic interface{} = "bidask"
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var ticker interface{} = this.ParseWsBidAsk(ccxt.GetValue(data, marketId), market)
        ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
        ccxt.AppendToArray(&result, ticker)
        var messageHash interface{} = ccxt.Add(ccxt.Add(topic, "::"), symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
func  (this *HitbtcCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "a"),
        "askVolume": this.SafeString(ticker, "A"),
        "bid": this.SafeString(ticker, "b"),
        "bidVolume": this.SafeString(ticker, "B"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name hitbtc#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.hitbtc.com/#subscribe-to-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *HitbtcCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5828)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "params": map[string]interface{} {
                    "symbols": []interface{}{ccxt.GetValue(market, "id")},
                },
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(request, "limit", limit)
            }
            var name interface{} = "trades"
        
            trades:= (<-this.SubscribePublic(name, "trades", []interface{}{symbol}, this.DeepExtend(request, params)))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp")
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleTrades(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "result": {
    //            "ch": "trades",                           // Channel
    //            "subscriptions": ["ETHBTC", "BTCUSDT"]
    //        },
    //        "id": 123
    //    }
    //
    // Notification snapshot
    //
    //    {
    //        "ch": "trades",                               // Channel
    //        "snapshot": {
    //            "BTCUSDT": [{
    //                "t": 1626861109494,                   // Timestamp in milliseconds
    //                "i": 1555634969,                      // ccxt.Trade identifier
    //                "p": "30881.96",                      // Price
    //                "q": "12.66828",                      // Quantity
    //                "s": "buy"                            // Side
    //            }]
    //        }
    //    }
    //
    // Notification update
    //
    //    {
    //        "ch": "trades",
    //        "update": {
    //            "BTCUSDT": [{
    //                "t": 1626861123552,
    //                "i": 1555634969,
    //                "p": "30877.68",
    //                "q": "0.00006",
    //                "s": "sell"
    //            }]
    //        }
    //    }
    //
    var data interface{} = this.SafeValue2(message, "snapshot", "update", map[string]interface{} {})
    var marketIds interface{} = ccxt.ObjectKeys(data)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            stored = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        var trades interface{} = this.ParseWsTrades(ccxt.GetValue(data, marketId), market)
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
            stored.(ccxt.Appender).Append(ccxt.GetValue(trades, j))
        }
        var messageHash interface{} = ccxt.Add("trades::", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *HitbtcCore) ParseWsTrades(trades interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    since := ccxt.GetArg(optionalArgs, 1, nil)
    _ = since
    limit := ccxt.GetArg(optionalArgs, 2, nil)
    _ = limit
    params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    trades = this.ToArray(trades)
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = this.Extend(this.ParseWsTrade(ccxt.GetValue(trades, i), market), params)
        ccxt.AppendToArray(&result, trade)
    }
    result = this.SortBy2(result, "timestamp", "id")
    var symbol interface{} = this.SafeString(market, "symbol")
    return this.FilterBySymbolSinceLimit(result, symbol, since, limit)
}
func  (this *HitbtcCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "t": 1626861123552,       // Timestamp in milliseconds
    //        "i": 1555634969,          // ccxt.Trade identifier
    //        "p": "30877.68",          // Price
    //        "q": "0.00006",           // Quantity
    //        "s": "sell"               // Side
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "t")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "i"),
        "order": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "type": nil,
        "side": this.SafeString(trade, "s"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "p"),
        "amount": this.SafeString(trade, "q"),
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name hitbtc#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api.hitbtc.com/#subscribe-to-candles
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} [timeframe] the length of time each candle represents
 * @param {int} [since] not used by hitbtc watchOHLCV
 * @param {int} [limit] 0 – 1000, default value = 0 (no history returned)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HitbtcCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var period interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var name interface{} = ccxt.Add("candles/", period)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "params": map[string]interface{} {
                    "symbols": []interface{}{ccxt.GetValue(market, "id")},
                },
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "limit", limit)
            }
        
            ohlcv:= (<-this.SubscribePublic(name, "candles", []interface{}{symbol}, this.DeepExtend(request, params)))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0)
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "ch": "candles/M1",                     // Channel
    //        "snapshot": {
    //            "BTCUSDT": [{
    //                "t": 1626860340000,             // Message timestamp
    //                "o": "30881.95",                // Open price
    //                "c": "30890.96",                // Last price
    //                "h": "30900.8",                 // High price
    //                "l": "30861.27",                // Low price
    //                "v": "1.27852",                 // Base asset volume
    //                "q": "39493.9021811"            // Quote asset volume
    //            }
    //            ...
    //            ]
    //        }
    //    }
    //
    //    {
    //        "ch": "candles/M1",
    //        "update": {
    //            "ETHBTC": [{
    //                "t": 1626860880000,
    //                "o": "0.060711",
    //                "c": "0.060749",
    //                "h": "0.060749",
    //                "l": "0.060711",
    //                "v": "12.2800",
    //                "q": "0.7455339675"
    //          }]
    //        }
    //    }
    //
    var data interface{} = this.SafeValue2(message, "snapshot", "update", map[string]interface{} {})
    var marketIds interface{} = ccxt.ObjectKeys(data)
    var channel interface{} = this.SafeString(message, "ch")
    var splitChannel interface{} = ccxt.Split(channel, "/")
    var period interface{} = this.SafeString(splitChannel, 1)
    var timeframe interface{} = this.FindTimeframe(period)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        var ohlcvs interface{} = this.ParseWsOHLCVs(ccxt.GetValue(data, marketId), market)
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(ohlcvs)); j++ {
            stored.(ccxt.Appender).Append(ccxt.GetValue(ohlcvs, j))
        }
        var messageHash interface{} = ccxt.Add("candles::", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *HitbtcCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "t": 1626860340000,             // Message timestamp
    //        "o": "30881.95",                // Open price
    //        "c": "30890.96",                // Last price
    //        "h": "30900.8",                 // High price
    //        "l": "30861.27",                // Low price
    //        "v": "1.27852",                 // Base asset volume
    //        "q": "39493.9021811"            // Quote asset volume
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name hitbtc#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://api.hitbtc.com/#subscribe-to-reports
 * @see https://api.hitbtc.com/#subscribe-to-reports-2
 * @see https://api.hitbtc.com/#subscribe-to-reports-3
 * @param {string} [symbol] unified CCXT market symbol
 * @param {int} [since] timestamp in ms of the earliest order to fetch
 * @param {int} [limit] the maximum amount of orders to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *HitbtcCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8308 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8308)
            var marketType interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var name interface{} = this.GetSupportedMapping(marketType, map[string]interface{} {
                "spot": "spot_subscribe",
                "margin": "margin_subscribe",
                "swap": "futures_subscribe",
                "future": "futures_subscribe",
            })
        
            orders:= (<-this.SubscribePrivate(name, symbol, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp")
            return nil
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleOrder(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "jsonrpc": "2.0",
    //        "method": "spot_order",                            // "margin_order", "future_order"
    //        "params": {
    //            "id": 584244931496,
    //            "client_order_id": "b5acd79c0a854b01b558665bcf379456",
    //            "symbol": "BTCUSDT",
    //            "side": "buy",
    //            "status": "new",
    //            "type": "limit",
    //            "time_in_force": "GTC",
    //            "quantity": "0.01000",
    //            "quantity_cumulative": "0",
    //            "price": "0.01",                              // only updates and snapshots
    //            "post_only": false,
    //            "reduce_only": false,                         // only margin and contract
    //            "display_quantity": "0",                      // only updates and snapshot
    //            "created_at": "2021-07-02T22:52:32.864Z",
    //            "updated_at": "2021-07-02T22:52:32.864Z",
    //            "trade_id": 1361977606,                       // only trades
    //            "trade_quantity": "0.00001",                  // only trades
    //            "trade_price": "49595.04",                    // only trades
    //            "trade_fee": "0.001239876000",                // only trades
    //            "trade_taker": true,                          // only trades, only spot
    //            "trade_position_id": 485308,                  // only trades, only margin
    //            "report_type": "new"                          // "trade", "status" (snapshot)
    //        }
    //    }
    //
    //    {
    //       "jsonrpc": "2.0",
    //       "method": "spot_orders",                            // "margin_orders", "future_orders"
    //       "params": [
    //            {
    //                "id": 584244931496,
    //                "client_order_id": "b5acd79c0a854b01b558665bcf379456",
    //                "symbol": "BTCUSDT",
    //                "side": "buy",
    //                "status": "new",
    //                "type": "limit",
    //                "time_in_force": "GTC",
    //                "quantity": "0.01000",
    //                "quantity_cumulative": "0",
    //                "price": "0.01",                              // only updates and snapshots
    //                "post_only": false,
    //                "reduce_only": false,                         // only margin and contract
    //                "display_quantity": "0",                      // only updates and snapshot
    //                "created_at": "2021-07-02T22:52:32.864Z",
    //                "updated_at": "2021-07-02T22:52:32.864Z",
    //                "trade_id": 1361977606,                       // only trades
    //                "trade_quantity": "0.00001",                  // only trades
    //                "trade_price": "49595.04",                    // only trades
    //                "trade_fee": "0.001239876000",                // only trades
    //                "trade_taker": true,                          // only trades, only spot
    //                "trade_position_id": 485308,                  // only trades, only margin
    //                "report_type": "new"                          // "trade", "status" (snapshot)
    //            }
    //        ]
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit")
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var data interface{} = this.SafeValue(message, "params", []interface{}{})
    if ccxt.IsTrue(ccxt.IsArray(data)) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var order interface{} = ccxt.GetValue(data, i)
            this.HandleOrderHelper(client, message, order)
        }
    } else {
        this.HandleOrderHelper(client, message, data)
    }
    return message
}
func  (this *HitbtcCore) HandleOrderHelper(client interface{}, message interface{}, order interface{})  {
    var orders interface{} = this.Orders
    var marketId interface{} = this.SafeStringLower2(order, "instrument", "symbol")
    var method interface{} = this.SafeString(message, "method")
    var splitMethod interface{} = ccxt.Split(method, "_order")
    var messageHash interface{} = this.SafeString(splitMethod, 0)
    var symbol interface{} = this.SafeSymbol(marketId)
    var parsed interface{} = this.ParseOrder(order)
    orders.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
}
func  (this *HitbtcCore) ParseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": 584244931496,
    //        "client_order_id": "b5acd79c0a854b01b558665bcf379456",
    //        "symbol": "BTCUSDT",
    //        "side": "buy",
    //        "status": "new",
    //        "type": "limit",
    //        "time_in_force": "GTC",
    //        "quantity": "0.01000",
    //        "quantity_cumulative": "0",
    //        "price": "0.01",                              // only updates and snapshots
    //        "post_only": false,
    //        "reduce_only": false,                         // only margin and contract
    //        "display_quantity": "0",                      // only updates and snapshot
    //        "created_at": "2021-07-02T22:52:32.864Z",
    //        "updated_at": "2021-07-02T22:52:32.864Z",
    //        "trade_id": 1361977606,                       // only trades
    //        "trade_quantity": "0.00001",                  // only trades
    //        "trade_price": "49595.04",                    // only trades
    //        "trade_fee": "0.001239876000",                // only trades
    //        "trade_taker": true,                          // only trades, only spot
    //        "trade_position_id": 485308,                  // only trades, only margin
    //        "report_type": "new"                          // "trade", "status" (snapshot)
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "created_at")
    var marketId interface{} = this.SafeString(trade, "symbol")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "trade_id"),
        "order": this.SafeString(trade, "id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeMarket(marketId, market),
        "type": nil,
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": this.SafeString(trade, "trade_taker"),
        "price": this.SafeString(trade, "trade_price"),
        "amount": this.SafeString(trade, "trade_quantity"),
        "cost": nil,
        "fee": map[string]interface{} {
            "cost": this.SafeString(trade, "trade_fee"),
            "currency": nil,
            "rate": nil,
        },
    }, market)
}
func  (this *HitbtcCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": 584244931496,
    //        "client_order_id": "b5acd79c0a854b01b558665bcf379456",
    //        "symbol": "BTCUSDT",
    //        "side": "buy",
    //        "status": "new",
    //        "type": "limit",
    //        "time_in_force": "GTC",
    //        "quantity": "0.01000",
    //        "quantity_cumulative": "0",
    //        "price": "0.01",                              // only updates and snapshots
    //        "post_only": false,
    //        "reduce_only": false,                         // only margin and contract
    //        "display_quantity": "0",                      // only updates and snapshot
    //        "created_at": "2021-07-02T22:52:32.864Z",
    //        "updated_at": "2021-07-02T22:52:32.864Z",
    //        "trade_id": 1361977606,                       // only trades
    //        "trade_quantity": "0.00001",                  // only trades
    //        "trade_price": "49595.04",                    // only trades
    //        "trade_fee": "0.001239876000",                // only trades
    //        "trade_taker": true,                          // only trades, only spot
    //        "trade_position_id": 485308,                  // only trades, only margin
    //        "report_type": "new"                          // "trade", "status" (snapshot)
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeString(order, "created_at")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var tradeId interface{} = this.SafeString(order, "trade_id")
    var trades interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
        var trade interface{} = this.ParseWsOrderTrade(order, market)
        trades = []interface{}{trade}
    }
    var rawStatus interface{} = this.SafeString(order, "status")
    var report_type interface{} = this.SafeString(order, "report_type")
    var parsedStatus interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(report_type, "canceled")) {
        parsedStatus = this.ParseOrderStatus(report_type)
    } else {
        parsedStatus = this.ParseOrderStatus(rawStatus)
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "id"),
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": ccxt.GetValue(market, "symbol"),
        "price": this.SafeString(order, "price"),
        "amount": this.SafeString(order, "quantity"),
        "type": this.SafeString(order, "type"),
        "side": this.SafeStringUpper(order, "side"),
        "timeInForce": this.SafeString(order, "time_in_force"),
        "postOnly": this.SafeString(order, "post_only"),
        "reduceOnly": this.SafeValue(order, "reduce_only"),
        "filled": nil,
        "remaining": nil,
        "cost": nil,
        "status": parsedStatus,
        "average": nil,
        "trades": trades,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name hitbtc#watchBalance
 * @description watches balance updates, cannot subscribe to margin account balances
 * @see https://api.hitbtc.com/#subscribe-to-spot-balances
 * @see https://api.hitbtc.com/#subscribe-to-futures-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot', 'swap', or 'future'
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.mode] 'updates' or 'batches' (default), 'updates' = messages arrive after balance updates, 'batches' = messages arrive at equal intervals if there were any updates
 * @returns {object[]} a list of [balance structures]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *HitbtcCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10748)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var name interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "spot": "spot_balance_subscribe",
                "swap": "futures_balance_subscribe",
                "future": "futures_balance_subscribe",
            })
            var mode interface{} = this.SafeString(params, "mode", "batches")
            params = this.Omit(params, "mode")
            var request interface{} = map[string]interface{} {
                "mode": mode,
            }
        
                retRes108715 :=  (<-this.SubscribePrivate(name, nil, this.Extend(request, params)))
                ccxt.PanicOnError(retRes108715)
                ch <- retRes108715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#createOrder
 * @description create a trade order
 * @see https://api.hitbtc.com/#create-new-spot-order
 * @see https://api.hitbtc.com/#create-margin-order
 * @see https://api.hitbtc.com/#create-futures-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported for spot-margin, swap supports both, default is 'cross'
 * @param {bool} [params.margin] true for creating a margin order
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", "Day", "GTD"
 * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *HitbtcCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11118)
            var market interface{} = this.Market(symbol)
            var request interface{} = nil
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            requestparamsVariable := this.CreateOrderRequest(market, marketType, typeVar, side, amount, price, marginMode, params)
            request = ccxt.GetValue(requestparamsVariable,0)
            params = ccxt.GetValue(requestparamsVariable,1)
            request = this.Extend(request, params)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
        
                    retRes112119 :=  (<-this.TradeRequest("futures_new_order", request))
                    ccxt.PanicOnError(retRes112119)
                    ch <- retRes112119
                    return nil
            } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketType, "margin"))) || ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))) {
        
                    retRes112319 :=  (<-this.TradeRequest("margin_new_order", request))
                    ccxt.PanicOnError(retRes112319)
                    ch <- retRes112319
                    return nil
            } else {
        
                    retRes112519 :=  (<-this.TradeRequest("spot_new_order", request))
                    ccxt.PanicOnError(retRes112519)
                    ch <- retRes112519
                    return nil
            }
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#cancelOrderWs
 * @see https://api.hitbtc.com/#cancel-spot-order-2
 * @see https://api.hitbtc.com/#cancel-futures-order-2
 * @see https://api.hitbtc.com/#cancel-margin-order-2
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for canceling a margin order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HitbtcCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11448 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11448)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "client_order_id": id,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrderWs", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("cancelOrderWs", params)
            marginMode := ccxt.GetValue(marginModequeryVariable,0)
            query := ccxt.GetValue(marginModequeryVariable,1)
            request = this.Extend(request, query)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
        
                    retRes115719 :=  (<-this.TradeRequest("futures_cancel_order", request))
                    ccxt.PanicOnError(retRes115719)
                    ch <- retRes115719
                    return nil
            } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketType, "margin"))) || ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))) {
        
                    retRes115919 :=  (<-this.TradeRequest("margin_cancel_order", request))
                    ccxt.PanicOnError(retRes115919)
                    ch <- retRes115919
                    return nil
            } else {
        
                    retRes116119 :=  (<-this.TradeRequest("spot_cancel_order", request))
                    ccxt.PanicOnError(retRes116119)
                    ch <- retRes116119
                    return nil
            }
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#cancelAllOrdersWs
 * @see https://api.hitbtc.com/#cancel-spot-orders
 * @see https://api.hitbtc.com/#cancel-futures-order-3
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for canceling margin orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HitbtcCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11788)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrdersWs", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrdersWs", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
        
                    retRes118819 :=  (<-this.TradeRequest("futures_cancel_orders", params))
                    ccxt.PanicOnError(retRes118819)
                    ch <- retRes118819
                    return nil
            } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketType, "margin"))) || ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " cancelAllOrdersWs is not supported for margin orders")))
            } else {
        
                    retRes119219 :=  (<-this.TradeRequest("spot_cancel_orders", params))
                    ccxt.PanicOnError(retRes119219)
                    ch <- retRes119219
                    return nil
            }
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOpenOrdersWs
 * @see https://api.hitbtc.com/#get-active-futures-orders-2
 * @see https://api.hitbtc.com/#get-margin-orders
 * @see https://api.hitbtc.com/#get-active-spot-orders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching open margin orders
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HitbtcCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12128)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                ccxt.AddElementToObject(request, "symbol", ccxt.GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrdersWs", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrdersWs", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "swap")) {
        
                    retRes122419 :=  (<-this.TradeRequest("futures_get_orders", request))
                    ccxt.PanicOnError(retRes122419)
                    ch <- retRes122419
                    return nil
            } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(marketType, "margin"))) || ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))) {
        
                    retRes122619 :=  (<-this.TradeRequest("margin_get_orders", request))
                    ccxt.PanicOnError(retRes122619)
                    ch <- retRes122619
                    return nil
            } else {
        
                    retRes122819 :=  (<-this.TradeRequest("spot_get_orders", request))
                    ccxt.PanicOnError(retRes122819)
                    ch <- retRes122819
                    return nil
            }
        
            }()
            return ch
        }
func  (this *HitbtcCore) HandleBalance(client interface{}, message interface{})  {
    //
    //    {
    //        "jsonrpc": "2.0",
    //        "method": "futures_balance",
    //        "params": [
    //            {
    //                "currency": "BCN",
    //                "available": "100.000000000000",
    //                "reserved": "0",
    //                "reserved_margin": "0"
    //            },
    //            ...
    //        ]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "method")
    var params interface{} = this.SafeValue(message, "params")
    var balance interface{} = this.ParseBalance(params)
    this.Balance = this.DeepExtend(this.Balance, balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *HitbtcCore) HandleNotification(client interface{}, message interface{}) interface{}  {
    //
    //     { jsonrpc: "2.0", result: true, id: null }
    //
    return message
}
func  (this *HitbtcCore) HandleOrderRequest(client interface{}, message interface{}) interface{}  {
    //
    // createOrderWs, cancelOrderWs
    //
    //    {
    //        "jsonrpc": "2.0",
    //        "result": {
    //            "id": 1130310696965,
    //            "client_order_id": "OPC2oyHSkEBqIpPtniLqeW-597hUL3Yo",
    //            "symbol": "ADAUSDT",
    //            "side": "buy",
    //            "status": "new",
    //            "type": "limit",
    //            "time_in_force": "GTC",
    //            "quantity": "4",
    //            "quantity_cumulative": "0",
    //            "price": "0.3300000",
    //            "post_only": false,
    //            "created_at": "2023-11-17T14:58:15.903Z",
    //            "updated_at": "2023-11-17T14:58:15.903Z",
    //            "original_client_order_id": "d6b645556af740b1bd1683400fd9cbce",       // spot_replace_order only
    //            "report_type": "new"
    //            "margin_mode": "isolated",                                            // margin and future only
    //            "reduce_only": false,                                                 // margin and future only
    //        },
    //        "id": 1700233093414
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeValue(message, "result", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsArray(result)) {
        var parsedOrders interface{} = []interface{}{}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
            var parsedOrder interface{} = this.ParseWsOrder(ccxt.GetValue(result, i))
            ccxt.AppendToArray(&parsedOrders, parsedOrder)
        }
        client.(ccxt.ClientInterface).Resolve(parsedOrders, messageHash)
    } else {
        var parsedOrder interface{} = this.ParseWsOrder(result)
        client.(ccxt.ClientInterface).Resolve(parsedOrder, messageHash)
    }
    return message
}
func  (this *HitbtcCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleError(client, message)) {
        return
    }
    var channel interface{} = this.SafeString2(message, "ch", "method")
    if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
        var splitChannel interface{} = ccxt.Split(channel, "/")
        channel = this.SafeString(splitChannel, 0)
        if ccxt.IsTrue(ccxt.IsEqual(channel, "orderbook")) {
            var channel2 interface{} = this.SafeString(splitChannel, 1)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(channel2, nil)) && ccxt.IsTrue(ccxt.IsEqual(channel2, "top"))) {
                channel = "orderbook/top"
            }
        }
        var methods interface{} = map[string]interface{} {
            "candles": this.HandleOHLCV,
            "ticker": this.HandleTicker,
            "trades": this.HandleTrades,
            "orderbook": this.HandleOrderBook,
            "orderbook/top": this.HandleBidAsk,
            "spot_order": this.HandleOrder,
            "spot_orders": this.HandleOrder,
            "margin_order": this.HandleOrder,
            "margin_orders": this.HandleOrder,
            "futures_order": this.HandleOrder,
            "futures_orders": this.HandleOrder,
            "spot_balance": this.HandleBalance,
            "futures_balance": this.HandleBalance,
        }
        var method interface{} = this.SafeValue(methods, channel)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    } else {
        var result interface{} = this.SafeValue(message, "result")
        var clientOrderId interface{} = this.SafeString(result, "client_order_id")
        if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
            this.HandleOrderRequest(client, message)
        }
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(result, true))) && !ccxt.IsTrue((ccxt.InOp(message, "id")))) {
            this.HandleAuthenticate(client, message)
        }
        if ccxt.IsTrue(ccxt.IsArray(result)) {
            // to do improve this, not very reliable right now
            var first interface{} = this.SafeValue(result, 0, map[string]interface{} {})
            var arrayLength interface{} =             ccxt.GetArrayLength(result)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(arrayLength, 0))) || ccxt.IsTrue((ccxt.InOp(first, "client_order_id")))) {
                this.HandleOrderRequest(client, message)
            }
        }
    }
}
func  (this *HitbtcCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "jsonrpc": "2.0",
    //        "result": true
    //    }
    //
    var success interface{} = this.SafeValue(message, "result")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(success) {
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
    return message
}
func  (this *HitbtcCore) HandleError(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        jsonrpc: '2.0',
    //        error: {
    //          code: 20001,
    //          message: 'Insufficient funds',
    //          description: 'Check that the funds are sufficient, given commissions'
    //        },
    //        id: 1700228604325
    //    }
    //
    var error interface{} = this.SafeValue(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        
            {
                 func(this *HitbtcCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *HitbtcCore) interface{} {
                                // catch block:
                                            if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                        var messageHash interface{} = "authenticated"
                        client.(ccxt.ClientInterface).Reject(e, messageHash)
                        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                        }
                    } else {
                        var id interface{} = this.SafeString(message, "id")
                        client.(ccxt.ClientInterface).Reject(e, id)
                    }
                    return true
                                
                            }(this)
                        }
                    }()
        		    // try block:
                                var code interface{} = this.SafeValue(error, "code")
                    var errorMessage interface{} = this.SafeString(error, "message")
                    var description interface{} = this.SafeString(error, "description")
                    var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), description)
                    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), errorMessage, feedback)
                    panic(ccxt.ExchangeError(feedback))
        		    
        	    }(this)
            
                }
    }
    return nil
}


func (this *HitbtcCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
