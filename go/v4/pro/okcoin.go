package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type OkcoinCore struct {
	*ccxt.OkcoinCore
	base *ccxt.OkcoinCore
}

func NewOkcoinCore() *OkcoinCore {
    p := &OkcoinCore{}
	base := &ccxt.OkcoinCore{}
	p.base = base
	p.OkcoinCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *OkcoinCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchBalance": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://real.okcoin.com:8443/ws/v3",
            },
            "logo": "https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",
            "www": "https://www.okcoin.com",
            "doc": "https://www.okcoin.com/docs/en/",
            "fees": "https://www.okcoin.com/coin-fees",
            "referral": "https://www.okcoin.com/account/register?flag=activity&channelId=600001513",
        },
        "options": map[string]interface{} {
            "fetchMarkets": []interface{}{"spot"},
            "watchOrders": "order",
            "watchOrderBook": map[string]interface{} {
                "limit": 400,
                "type": "spot",
                "depth": "depth_l2_tbt",
            },
            "watchBalance": "spot",
            "ws": map[string]interface{} {
                "inflate": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 20000,
        },
    })
}
func  (this *OkcoinCore) Subscribe(channel interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes598)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "type"), "/"), channel), ":"), ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{messageHash},
            }
        
                retRes6715 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes6715)
                ch <- retRes6715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okcoin#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-public-channel-trades-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *OkcoinCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes828)
            symbol = this.Symbol(symbol)
        
            trades:= (<-this.Subscribe("trade", symbol, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okcoin#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-private-channel-order-channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OkcoinCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1038)
        
            retRes1048 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1048)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
            }
            var orderType interface{} = this.SafeString(this.Options, "watchOrders", "order")
        
            trades:= (<-this.Subscribe(orderType, symbol, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) HandleOrders(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    // {
    //     "table": "spot/order",
    //     "data": [
    //       {
    //         "client_oid": '',
    //         "created_at": "2022-03-04T16:44:58.530Z",
    //         "event_code": "0",
    //         "event_message": '',
    //         "fee": '',
    //         "fee_currency": '',
    //         "filled_notional": "0",
    //         "filled_size": "0",
    //         "instrument_id": "LTC-USD",
    //         "last_amend_result": '',
    //         "last_fill_id": "0",
    //         "last_fill_px": "0",
    //         "last_fill_qty": "0",
    //         "last_fill_time": "1970-01-01T00:00:00.000Z",
    //         "last_request_id": '',
    //         "margin_trading": "1",
    //         "notional": '',
    //         "order_id": "8629537900471296",
    //         "order_type": "0",
    //         "price": "1500",
    //         "rebate": '',
    //         "rebate_currency": '',
    //         "side": "sell",
    //         "size": "0.0133",
    //         "state": "0",
    //         "status": "open",
    //         "timestamp": "2022-03-04T16:44:58.530Z",
    //         "type": "limit"
    //       }
    //     ]
    //   }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var table interface{} = this.SafeString(message, "table")
    var orders interface{} = this.SafeValue(message, "data", []interface{}{})
    var ordersLength interface{} =     ccxt.GetArrayLength(orders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(ordersLength, 0)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        var marketIds interface{} = map[string]interface{} {}
        var parsed interface{} = this.ParseOrders(orders)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
            var order interface{} = ccxt.GetValue(parsed, i)
            stored.(ccxt.Appender).Append(order)
            var symbol interface{} = ccxt.GetValue(order, "symbol")
            var market interface{} = this.Market(symbol)
            ccxt.AddElementToObject(marketIds, ccxt.GetValue(market, "id"), true)
        }
        var keys interface{} = ccxt.ObjectKeys(marketIds)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), ccxt.GetValue(keys, i))
            client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        }
    }
}
/**
 * @method
 * @name okcoin#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-public-channel-tickers-channel
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OkcoinCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes19015 :=  (<-this.Subscribe("ticker", symbol, params))
                ccxt.PanicOnError(retRes19015)
                ch <- retRes19015
                return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "table": "spot/trade",
    //         "data": [
    //             {
    //                 "side": "buy",
    //                 "trade_id": "30770973",
    //                 "price": "4665.4",
    //                 "size": "0.019",
    //                 "instrument_id": "BTC-USDT",
    //                 "timestamp": "2020-03-16T13:41:46.526Z"
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(data, i))
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        var marketId interface{} = this.SafeString(ccxt.GetValue(trade, "info"), "instrument_id")
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), marketId)
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            stored = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        stored.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *OkcoinCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "table": "spot/ticker",
    //         "data": [
    //             {
    //                 "last": "4634.1",
    //                 "open_24h": "5305.6",
    //                 "best_bid": "4631.6",
    //                 "high_24h": "5950",
    //                 "low_24h": "4448.8",
    //                 "base_volume_24h": "147913.11435388",
    //                 "quote_volume_24h": "756850119.99108082",
    //                 "best_ask": "4631.7",
    //                 "instrument_id": "BTC-USDT",
    //                 "timestamp": "2020-03-16T13:16:25.677Z",
    //                 "best_bid_size": "0.12348942",
    //                 "best_ask_size": "0.00100014",
    //                 "last_qty": "0.00331822"
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.ParseTicker(ccxt.GetValue(data, i))
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        var marketId interface{} = this.SafeString(ccxt.GetValue(ticker, "info"), "instrument_id")
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), marketId)
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    return message
}
/**
 * @method
 * @name okcoin#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-public-channel-candlesticks-channel
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OkcoinCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2778 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2778)
            symbol = this.Symbol(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var name interface{} = ccxt.Add(ccxt.Add("candle", interval), "s")
        
            ohlcv:= (<-this.Subscribe(name, symbol, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "spot/candle60s",
    //         "data": [
    //             {
    //                 "candle": [
    //                     "2020-03-16T14:29:00.000Z",
    //                     "4948.3",
    //                     "4966.7",
    //                     "4939.1",
    //                     "4945.3",
    //                     "238.36021657"
    //                 ],
    //                 "instrument_id": "BTC-USDT"
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var parts interface{} = ccxt.Split(table, "/")
    var part1 interface{} = this.SafeString(parts, 1)
    var interval interface{} = ccxt.Replace(part1, "candle", "")
    interval = ccxt.Replace(interval, "s", "")
    // use a reverse lookup in a static map instead
    var timeframe interface{} = this.FindTimeframe(interval)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var marketId interface{} = this.SafeString(ccxt.GetValue(data, i), "instrument_id")
        var candle interface{} = this.SafeValue(ccxt.GetValue(data, i), "candle")
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var parsed interface{} = this.ParseOHLCV(candle, market)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), marketId)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name okcoin#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-public-channel-order-book-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *OkcoinCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeString(options, "depth", "depth_l2_tbt")
        
            orderbook:= (<-this.Subscribe(depth, symbol, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *OkcoinCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *OkcoinCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTC-USDT",
    //         "asks": [
    //             ["4568.5", "0.49723138", "2"],
    //             ["4568.7", "0.5013", "1"],
    //             ["4569.1", "0.4398", "1"],
    //         ],
    //         "bids": [
    //             ["4568.4", "0.84187666", "5"],
    //             ["4568.3", "0.75661506", "6"],
    //             ["4567.8", "2.01", "2"],
    //         ],
    //         "timestamp": "2020-03-16T11:11:43.388Z",
    //         "checksum": 473370408
    //     }
    //
    var asks interface{} = this.SafeValue(message, "asks", []interface{}{})
    var bids interface{} = this.SafeValue(message, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
    var timestamp interface{} = this.Parse8601(this.SafeString(message, "timestamp"))
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    return orderbook
}
func  (this *OkcoinCore) HandleOrderBook(client interface{}, message interface{}) interface{}  {
    //
    // first message (snapshot)
    //
    //     {
    //         "table": "spot/depth",
    //         "action": "partial",
    //         "data": [
    //             {
    //                 "instrument_id": "BTC-USDT",
    //                 "asks": [
    //                     ["4568.5", "0.49723138", "2"],
    //                     ["4568.7", "0.5013", "1"],
    //                     ["4569.1", "0.4398", "1"],
    //                 ],
    //                 "bids": [
    //                     ["4568.4", "0.84187666", "5"],
    //                     ["4568.3", "0.75661506", "6"],
    //                     ["4567.8", "2.01", "2"],
    //                 ],
    //                 "timestamp": "2020-03-16T11:11:43.388Z",
    //                 "checksum": 473370408
    //             }
    //         ]
    //     }
    //
    // subsequent updates
    //
    //     {
    //         "table": "spot/depth",
    //         "action": "update",
    //         "data": [
    //             {
    //                 "instrument_id":   "BTC-USDT",
    //                 "asks": [
    //                     ["4598.8", "0", "0"],
    //                     ["4599.1", "0", "0"],
    //                     ["4600.3", "0", "0"],
    //                 ],
    //                 "bids": [
    //                     ["4598.5", "0.08", "1"],
    //                     ["4598.2", "0.0337323", "1"],
    //                     ["4598.1", "0.12681801", "3"],
    //                 ],
    //                 "timestamp": "2020-03-16T11:20:35.139Z",
    //                 "checksum": 740786981
    //             }
    //         ]
    //     }
    //
    var action interface{} = this.SafeString(message, "action")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var table interface{} = this.SafeString(message, "table")
    if ccxt.IsTrue(ccxt.IsEqual(action, "partial")) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var update interface{} = ccxt.GetValue(data, i)
            var marketId interface{} = this.SafeString(update, "instrument_id")
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            // default limit is 400 bidasks
            var limit interface{} = this.SafeInteger(options, "limit", 400)
            var orderbook interface{} = this.OrderBook(map[string]interface{} {}, limit)
            ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
            this.HandleOrderBookMessage(client, update, orderbook)
            var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), marketId)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    } else {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var update interface{} = ccxt.GetValue(data, i)
            var marketId interface{} = this.SafeString(update, "instrument_id")
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
                var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
                this.HandleOrderBookMessage(client, update, orderbook)
                var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), marketId)
                client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            }
        }
    }
    return message
}
func  (this *OkcoinCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "login"
            var client interface{} = this.Client(url)
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                future = client.(ccxt.ClientInterface).Future("authenticated")
                var timestamp interface{} = ccxt.ToString(this.Seconds())
                var method interface{} = "GET"
                var path interface{} = "/users/self/verify"
                var auth interface{} = ccxt.Add(ccxt.Add(timestamp, method), path)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var request interface{} = map[string]interface{} {
                    "op": messageHash,
                    "args": []interface{}{this.ApiKey, this.Password, timestamp, signature},
                }
                this.Spawn(this.Watch, url, messageHash, request, messageHash, future)
            }
        
                retRes50015 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes50015)
                ch <- retRes50015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okcoin#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.okcoin.com/docs-v5/en/#websocket-api-private-channel-account-channel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *OkcoinCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var defaultType interface{} = this.SafeString2(this.Options, "watchBalance", "defaultType")
            var typeVar interface{} = this.SafeString(params, "type", defaultType)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBalance requires a type parameter (one of \\'spot\\', \\'margin\\', \\'futures\\', \\'swap\\')")))
            }
            // const query = this.omit (params, 'type')
            negotiation:= (<-this.Authenticate())
            ccxt.PanicOnError(negotiation)
        
                retRes51915 :=  (<-this.SubscribeToUserAccount(negotiation, params))
                ccxt.PanicOnError(retRes51915)
                ch <- retRes51915
                return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) SubscribeToUserAccount(negotiation interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var defaultType interface{} = this.SafeString2(this.Options, "watchBalance", "defaultType")
            var typeVar interface{} = this.SafeString(params, "type", defaultType)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBalance requires a type parameter (one of \\'spot\\', \\'margin\\', \\'futures\\', \\'swap\\')")))
            }
        
            retRes5288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5288)
            var currencyId interface{} = this.SafeString(params, "currency")
            var code interface{} = this.SafeString(params, "code", this.SafeCurrencyCode(currencyId))
            var currency interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var symbol interface{} = this.SafeString(params, "symbol")
            var market interface{} = this.Market(symbol)
            var marketUndefined interface{} =     (ccxt.IsEqual(market, nil))
            var currencyUndefined interface{} =     (ccxt.IsEqual(currency, nil))
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                if ccxt.IsTrue(currencyUndefined) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchBalance requires a \\'currency\\' (id) or a unified \\'code\\' parameter for "), typeVar), " accounts")))
                }
            } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "swap")))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "option")))) {
                if ccxt.IsTrue(marketUndefined) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchBalance requires a \\'instrument_id\\' (id) or a unified \\'symbol\\' parameter for "), typeVar), " accounts")))
                }
            } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "futures")) {
                if ccxt.IsTrue(ccxt.IsTrue(currencyUndefined) && ccxt.IsTrue(marketUndefined)) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchBalance requires a \\'currency\\' (id), or unified \\'code\\', or \\'instrument_id\\' (id), or unified \\'symbol\\' parameter for "), typeVar), " accounts")))
                }
            }
            var suffix interface{} = nil
            if !ccxt.IsTrue(currencyUndefined) {
                suffix = ccxt.GetValue(currency, "id")
            } else if !ccxt.IsTrue(marketUndefined) {
                suffix = ccxt.GetValue(market, "id")
            }
            var accountType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin"))), "spot", typeVar)
            var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin"))), "margin_account", "account")
            var messageHash interface{} = ccxt.Add(ccxt.Add(accountType, "/"), account)
            var subscriptionHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), suffix)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{subscriptionHash},
            }
            var query interface{} = this.Omit(params, []interface{}{"currency", "code", "instrument_id", "symbol", "type"})
        
                retRes56815 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, query), subscriptionHash))
                ccxt.PanicOnError(retRes56815)
                ch <- retRes56815
                return nil
        
            }()
            return ch
        }
func  (this *OkcoinCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "table": "spot/account",
    //         "data": [
    //             {
    //                 "available": "11.044827320825",
    //                 "currency": "USDT",
    //                 "id": '',
    //                 "balance": "11.044827320825",
    //                 "hold": "0"
    //             }
    //         ]
    //     }
    //
    // margin
    //
    //     {
    //         "table": "spot/margin_account",
    //         "data": [
    //             {
    //                 "maint_margin_ratio": "0.08",
    //                 "liquidation_price": "0",
    //                 "currency:USDT": { available: "0", balance: "0", borrowed: "0", hold: "0", lending_fee: "0" },
    //                 "tiers": "1",
    //                 "instrument_id":   "ETH-USDT",
    //                 "currency:ETH": { available: "0", balance: "0", borrowed: "0", hold: "0", lending_fee: "0" }
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var parts interface{} = ccxt.Split(table, "/")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    ccxt.AddElementToObject(this.Balance, "info", data)
    var typeVar interface{} = this.SafeString(parts, 0)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        var part1 interface{} = this.SafeString(parts, 1)
        if ccxt.IsTrue(ccxt.IsEqual(part1, "margin_account")) {
            typeVar = "margin"
        }
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var balance interface{} = this.ParseBalanceByType(typeVar, data)
        var oldBalance interface{} = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
        var newBalance interface{} = this.DeepExtend(oldBalance, balance)
        ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(newBalance))
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), table)
    }
}
func  (this *OkcoinCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {"event":"subscribe","channel":"spot/depth:BTC-USDT"}
    //
    // const channel = this.safeString (message, 'channel')
    // client.(*ccxt.WSClient).Subscriptions[channel] = message
    return message
}
func  (this *OkcoinCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //     { event: "login", success: true }
    //
    client.(ccxt.ClientInterface).Resolve(message, "authenticated")
    return message
}
func  (this *OkcoinCore) Ping(client interface{}) interface{}  {
    // okex does not support built-in ws protocol-level ping-pong
    // instead it requires custom text-based ping-pong
    return "ping"
}
func  (this *OkcoinCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *OkcoinCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     { event: "error", message: "Invalid sign", errorCode: 30013 }
    //     {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
    //     { event: "error", message: "Channel spot/order doesn't exist", errorCode: 30040 }
    //
    var errorCode interface{} = this.SafeString(message, "errorCode")
    
        {
             func(this *OkcoinCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *OkcoinCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                client.(ccxt.ClientInterface).Reject(e, "authenticated")
                var method interface{} = "login"
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), method)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), method)
                }
                return false
            }
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                var messageString interface{} = this.SafeValue(message, "message")
                if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                }
            }
    		    return nil
    	    }(this)
        
            }
    return message
}
func  (this *OkcoinCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
    //     {"event":"subscribe","channel":"spot/depth:BTC-USDT"}
    //     {
    //         "table": "spot/depth",
    //         "action": "partial",
    //         "data": [
    //             {
    //                 "instrument_id":   "BTC-USDT",
    //                 "asks": [
    //                     ["5301.8", "0.03763319", "1"],
    //                     ["5302.4", "0.00305", "2"],
    //                 ],
    //                 "bids": [
    //                     ["5301.7", "0.58911427", "6"],
    //                     ["5301.6", "0.01222922", "4"],
    //                 ],
    //                 "timestamp": "2020-03-16T03:25:00.440Z",
    //                 "checksum": -2088736623
    //             }
    //         ]
    //     }
    // {
    //     "table":"spot/order",
    //     "data":[
    //         {
    //             "client_oid":"",
    //             "filled_notional":"0",
    //             "filled_size":"0",
    //             "instrument_id":"ETC-USDT",
    //             "last_fill_px":"0",
    //             "last_fill_qty":"0",
    //             "last_fill_time":"1970-01-01T00:00:00.000Z",
    //             "margin_trading":"1",
    //             "notional":"",
    //             "order_id":"3576398568830976",
    //             "order_type":"0",
    //             "price":"5.826",
    //             "side":"buy",
    //             "size":"0.1",
    //             "state":"0",
    //             "status":"open",
    //             "fee_currency":"ETC",
    //             "fee":"-0.01",
    //             "rebate_currency":"open",
    //             "rebate":"0.05",
    //             "timestamp":"2019-09-24T06:45:11.394Z",
    //             "type":"limit",
    //             "created_at":"2019-09-24T06:45:11.394Z"
    //         }
    //     ]
    // }
    //
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var table interface{} = this.SafeString(message, "table")
    if ccxt.IsTrue(ccxt.IsEqual(table, nil)) {
        var event interface{} = this.SafeString(message, "event")
        if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
            var methods interface{} = map[string]interface{} {
                "login": this.HandleAuthenticate,
                "subscribe": this.HandleSubscriptionStatus,
            }
            var method interface{} = this.SafeValue(methods, event)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
            }
        }
    } else {
        var parts interface{} = ccxt.Split(table, "/")
        var name interface{} = this.SafeString(parts, 1)
        var methods interface{} = map[string]interface{} {
            "depth": this.HandleOrderBook,
            "depth5": this.HandleOrderBook,
            "depth_l2_tbt": this.HandleOrderBook,
            "ticker": this.HandleTicker,
            "trade": this.HandleTrade,
            "account": this.HandleBalance,
            "margin_account": this.HandleBalance,
            "order": this.HandleOrders,
        }
        var method interface{} = this.SafeValue(methods, name)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(name, "candle"), 0)) {
            method = this.HandleOHLCV
        }
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *OkcoinCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
