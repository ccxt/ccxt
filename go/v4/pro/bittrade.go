package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BittradeCore struct {
	*ccxt.BittradeCore
	base *ccxt.BittradeCore
}

func NewBittradeCore() *BittradeCore {
    p := &BittradeCore{}
	base := &ccxt.BittradeCore{}
	p.base = base
	p.BittradeCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BittradeCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchTickers": false,
            "watchTicker": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchBalance": false,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "api": map[string]interface{} {
                        "public": "wss://{hostname}/ws",
                        "private": "wss://{hostname}/ws/v2",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "api": "api",
            "ws": map[string]interface{} {
                "gunzip": true,
            },
        },
    })
}
func  (this *BittradeCore) RequestId() interface{}  {
    this.LockId()
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    this.UnlockId()
    return ccxt.ToString(requestId)
}
/**
 * @method
 * @name bittrade#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BittradeCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes628)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            // only supports a limit of 150 at this time
            var messageHash interface{} = ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".detail")
            var api interface{} = this.SafeString(this.Options, "api", "api")
            var hostname interface{} = map[string]interface{} {
                "hostname": this.Hostname,
            }
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "public"), hostname)
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "sub": messageHash,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "params": params,
            }
        
                retRes8115 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes8115)
                ch <- retRes8115
                return nil
        
            }()
            return ch
        }
func  (this *BittradeCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "ch": "market.btcusdt.detail",
    //         "ts": 1583494163784,
    //         "tick": {
    //             "id": 209988464418,
    //             "low": 8988,
    //             "high": 9155.41,
    //             "open": 9078.91,
    //             "close": 9136.46,
    //             "vol": 237813910.5928412,
    //             "amount": 26184.202558551195,
    //             "version": 209988464418,
    //             "count": 265673
    //         }
    //     }
    //
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var ticker interface{} = this.ParseTicker(tick, market)
    var timestamp interface{} = this.SafeValue(message, "ts")
    ccxt.AddElementToObject(ticker, "timestamp", timestamp)
    ccxt.AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, ch)
    return message
}
/**
 * @method
 * @name bittrade#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BittradeCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1288)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            // only supports a limit of 150 at this time
            var messageHash interface{} = ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".trade.detail")
            var api interface{} = this.SafeString(this.Options, "api", "api")
            var hostname interface{} = map[string]interface{} {
                "hostname": this.Hostname,
            }
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "public"), hostname)
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "sub": messageHash,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "params": params,
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BittradeCore) HandleTrades(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "ch": "market.btcusdt.trade.detail",
    //         "ts": 1583495834011,
    //         "tick": {
    //             "id": 105004645372,
    //             "ts": 1583495833751,
    //             "data": [
    //                 {
    //                     "id": 1.050046453727319e+22,
    //                     "ts": 1583495833751,
    //                     "tradeId": 102090727790,
    //                     "amount": 0.003893,
    //                     "price": 9150.01,
    //                     "direction": "sell"
    //                 }
    //             ]
    //         }
    //     }
    //
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var data interface{} = this.SafeValue(tick, "data", map[string]interface{} {})
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var tradesCache interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesCache, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesCache = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesCache)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(data, i), market)
        tradesCache.(ccxt.Appender).Append(trade)
    }
    client.(ccxt.ClientInterface).Resolve(tradesCache, ch)
    return message
}
/**
 * @method
 * @name bittrade#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BittradeCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2088)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".kline."), interval)
            var api interface{} = this.SafeString(this.Options, "api", "api")
            var hostname interface{} = map[string]interface{} {
                "hostname": this.Hostname,
            }
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "public"), hostname)
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "sub": messageHash,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "timeframe": timeframe,
                "params": params,
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *BittradeCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "ch": "market.btcusdt.kline.1min",
    //         "ts": 1583501786794,
    //         "tick": {
    //             "id": 1583501760,
    //             "open": 9094.5,
    //             "close": 9094.51,
    //             "low": 9094.5,
    //             "high": 9094.51,
    //             "amount": 0.44639786263800907,
    //             "vol": 4059.76919054,
    //             "count": 16
    //         }
    //     }
    //
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(parts, 3)
    var timeframe interface{} = this.FindTimeframe(interval)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var tick interface{} = this.SafeValue(message, "tick")
    var parsed interface{} = this.ParseOHLCV(tick, market)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, ch)
}
/**
 * @method
 * @name bittrade#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BittradeCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(limit, nil))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 150)))) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook accepts limit = 150 only")))
            }
        
            retRes2858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2858)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            // only supports a limit of 150 at this time
            limit = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(limit, nil))), 150, limit)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".mbp."), ccxt.ToString(limit))
            var api interface{} = this.SafeString(this.Options, "api", "api")
            var hostname interface{} = map[string]interface{} {
                "hostname": this.Hostname,
            }
            var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "public"), hostname)
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "sub": messageHash,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "limit": limit,
                "params": params,
                "method": this.HandleOrderBookSubscription,
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BittradeCore) HandleOrderBookSnapshot(client interface{}, message interface{}, subscription interface{})  {
    //
    //     {
    //         "id": 1583473663565,
    //         "rep": "market.btcusdt.mbp.150",
    //         "status": "ok",
    //         "data": {
    //             "seqNum": 104999417756,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var messageHash interface{} = this.SafeString(subscription, "messageHash")
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var data interface{} = this.SafeValue(message, "data")
    var snapshot interface{} = this.ParseOrderBook(data, symbol)
    ccxt.AddElementToObject(snapshot, "nonce", this.SafeInteger(data, "seqNum"))
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    // unroll the accumulated deltas
    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
        this.HandleOrderBookMessage(client, ccxt.GetValue(messages, i), orderbook)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BittradeCore) WatchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var messageHash interface{} = this.SafeString(subscription, "messageHash")
            
                {
                     func(this *BittradeCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *BittradeCore) interface{} {
                                    // catch block:
                                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                var symbol interface{} = this.SafeString(subscription, "symbol")
                    var limit interface{} = this.SafeInteger(subscription, "limit")
                    var params interface{} = this.SafeValue(subscription, "params")
                    var api interface{} = this.SafeString(this.Options, "api", "api")
                    var hostname interface{} = map[string]interface{} {
                        "hostname": this.Hostname,
                    }
                    var url interface{} = this.ImplodeParams(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "public"), hostname)
                    var requestId interface{} = this.RequestId()
                    var request interface{} = map[string]interface{} {
                        "req": messageHash,
                        "id": requestId,
                    }
                    // this is a temporary subscription by a specific requestId
                    // it has a very short lifetime until the snapshot is received over ws
                    var snapshotSubscription interface{} = map[string]interface{} {
                        "id": requestId,
                        "messageHash": messageHash,
                        "symbol": symbol,
                        "limit": limit,
                        "params": params,
                        "method": this.HandleOrderBookSnapshot,
                    }
            
                    orderbook:= (<-this.Watch(url, requestId, request, requestId, snapshotSubscription))
                    ccxt.PanicOnError(orderbook)
            
                    ch <- orderbook.(ccxt.OrderBookInterface).Limit()
                    return nil
            		    
            	    }(this)
                
                    }
        
            return nil
        
            }()
            return ch
        }
func  (this *BittradeCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BittradeCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BittradeCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    //
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var seqNum interface{} = this.SafeInteger(tick, "seqNum")
    var prevSeqNum interface{} = this.SafeInteger(tick, "prevSeqNum")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual(prevSeqNum, ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThan(seqNum, ccxt.GetValue(orderbook, "nonce"))))) {
        var asks interface{} = this.SafeValue(tick, "asks", []interface{}{})
        var bids interface{} = this.SafeValue(tick, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "nonce", seqNum)
        var timestamp interface{} = this.SafeInteger(message, "ts")
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    return orderbook
}
func  (this *BittradeCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // deltas
    //
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "ch")
    var ch interface{} = this.SafeValue(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var symbol interface{} = this.SafeSymbol(marketId)
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderbook, "nonce"), nil)) {
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        this.HandleOrderBookMessage(client, message, orderbook)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *BittradeCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var limit interface{} = this.SafeInteger(subscription, "limit")
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    // watch the snapshot in a separate async call
    this.Spawn(this.WatchOrderBookSnapshot, client, message, subscription)
}
func  (this *BittradeCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "id": 1583414227,
    //         "status": "ok",
    //         "subbed": "market.btcusdt.mbp.150",
    //         "ts": 1583414229143
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeValue(subscriptionsById, id)
    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
        var method interface{} = this.SafeValue(subscription, "method")
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            return ccxt.CallDynamically(method, client, message, subscription)
        }
        // clean up
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        }
    }
    return message
}
func  (this *BittradeCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "id": "1578090234088", // connectId
    //         "type": "welcome",
    //     }
    //
    return message
}
func  (this *BittradeCore) HandleSubject(client interface{}, message interface{})  {
    //
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    var ch interface{} = this.SafeValue(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var typeVar interface{} = this.SafeString(parts, 0)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "market")) {
        var methodName interface{} = this.SafeString(parts, 2)
        var methods interface{} = map[string]interface{} {
            "mbp": this.HandleOrderBook,
            "detail": this.HandleTicker,
            "trade": this.HandleTrades,
            "kline": this.HandleOHLCV,
        }
        var method interface{} = this.SafeValue(methods, methodName)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *BittradeCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            //     { ping: 1583491673714 }
            //
        
            retRes5618 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                "pong": this.SafeInteger(message, "ping"),
            }))
            ccxt.PanicOnError(retRes5618)
                return nil
            }()
            return ch
        }
func  (this *BittradeCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *BittradeCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "ts": 1586323747018,
    //         "status": "error",
    //         'err-code': "bad-request",
    //         'err-msg': "invalid mbp.150.symbol linkusdt",
    //         "id": "2"
    //     }
    //
    var status interface{} = this.SafeString(message, "status")
    if ccxt.IsTrue(ccxt.IsEqual(status, "error")) {
        var id interface{} = this.SafeString(message, "id")
        var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
        var subscription interface{} = this.SafeValue(subscriptionsById, id)
        if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
            var errorCode interface{} = this.SafeString(message, "err-code")
            
                {
                     func(this *BittradeCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *BittradeCore) interface{} {
                                    // catch block:
                                                    var messageHash interface{} = this.SafeString(subscription, "messageHash")
                            client.(ccxt.ClientInterface).Reject(e, messageHash)
                            client.(ccxt.ClientInterface).Reject(e, id)
                            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
                                ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
                            }
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, this.Json(message))
            		    return nil
            	    }(this)
                
                    }
        }
        return false
    }
    return message
}
func  (this *BittradeCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        //
        //     {"id":1583414227,"status":"ok","subbed":"market.btcusdt.mbp.150","ts":1583414229143}
        //
        //           ________________________
        //
        // sometimes bittrade responds with half of a JSON response like
        //
        //     " {"ch":"market.ethbtc.m "
        //
        // this is passed to handleMessage as a string since it failed to be decoded as JSON
        //
        if ccxt.IsTrue(!ccxt.IsEqual(this.SafeString(message, "id"), nil)) {
            this.HandleSubscriptionStatus(client, message)
        } else if ccxt.IsTrue(!ccxt.IsEqual(this.SafeString(message, "ch"), nil)) {
            // route by channel aka topic aka subject
            this.HandleSubject(client, message)
        } else if ccxt.IsTrue(!ccxt.IsEqual(this.SafeString(message, "ping"), nil)) {
            this.HandlePing(client, message)
        }
    }
}


func (this *BittradeCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
