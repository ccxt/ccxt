package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BullishCore struct {
	*ccxt.BullishCore
	base *ccxt.BullishCore
}

func NewBullishCore() *BullishCore {
    p := &BullishCore{}
	base := &ccxt.BullishCore{}
	p.base = base
	p.BullishCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BullishCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTrades": true,
            "watchPositions": true,
            "watchMyTrades": true,
            "watchBalance": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.exchange.bullish.com",
                    "private": "wss://api.exchange.bullish.com/trading-api/v1/private-data",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.simnext.bullish-test.com",
                    "private": "wss://api.simnext.bullish-test.com/trading-api/v1/private-data",
                },
            },
        },
        "options": map[string]interface{} {
            "ws": map[string]interface{} {
                "cookies": map[string]interface{} {},
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 99000,
        },
    })
}
func  (this *BullishCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
func  (this *BullishCore) Ping(client interface{}) interface{}  {
    // bullish does not support built-in ws protocol-level ping-pong
    // https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--keep-websocket-open
    var id interface{} = ccxt.ToString(this.RequestId())
    return map[string]interface{} {
        "jsonrpc": "2.0",
        "type": "command",
        "method": "keepalivePing",
        "params": map[string]interface{} {},
        "id": id,
    }
}
func  (this *BullishCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "id": "7",
    //         "jsonrpc": "2.0",
    //         "result": {
    //             "responseCodeName": "OK",
    //             "responseCode": "200",
    //             "message": "Keep alive pong"
    //         }
    //     }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message  // current line is for transpilation compatibility
}
func  (this *BullishCore) WatchPublic(url interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    request := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = request
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var id interface{} = ccxt.ToString(this.RequestId())
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "type": "command",
                "method": "subscribe",
                "params": request,
                "id": id,
            }
            var fullUrl interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), url)
        
                retRes9715 :=  (<-this.Watch(fullUrl, messageHash, this.DeepExtend(message, params), messageHash))
                ccxt.PanicOnError(retRes9715)
                ch <- retRes9715
                return nil
        
            }()
            return ch
        }
func  (this *BullishCore) WatchPrivate(messageHash interface{}, subscribeHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    request := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = request
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
        
            token:= (<-this.HandleToken())
            ccxt.PanicOnError(token)
            var cookies interface{} = map[string]interface{} {
                "JWT_COOKIE": token,
            }
            ccxt.AddElementToObject(ccxt.GetValue(this.Options, "ws"), "cookies", cookies)
            var id interface{} = ccxt.ToString(this.RequestId())
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "type": "command",
                "method": "subscribe",
                "params": request,
                "id": id,
            }
        
            result:= (<-this.Watch(url, messageHash, this.DeepExtend(message, params), subscribeHash))
            ccxt.PanicOnError(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bullish#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--unified-anonymous-trades-websocket-unauthenticated
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BullishCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1318)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("trades::", ccxt.GetValue(market, "symbol"))
            var url interface{} = "/trading-api/v1/market-data/trades"
            var request interface{} = map[string]interface{} {
                "topic": "anonymousTrades",
                "symbol": ccxt.GetValue(market, "id"),
            }
        
            trades:= (<-this.WatchPublic(url, messageHash, request, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "snapshot",
    //         "dataType": "V1TAAnonymousTradeUpdate",
    //         "data": {
    //             "trades": [
    //                 {
    //                     "tradeId": "100086000000609304",
    //                     "isTaker": true,
    //                     "price": "104889.2063",
    //                     "createdAtTimestamp": "1749124509118",
    //                     "quantity": "0.01000000",
    //                     "publishedAtTimestamp": "1749124531466",
    //                     "side": "BUY",
    //                     "createdAtDatetime": "2025-06-05T11:55:09.118Z",
    //                     "symbol": "BTCUSDC"
    //                 }
    //             ],
    //             "createdAtTimestamp": "1749124509118",
    //             "publishedAtTimestamp": "1749124531466",
    //             "symbol": "BTCUSDC"
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.Market(symbol)
    var rawTrades interface{} = this.SafeList(data, "trades", []interface{}{})
    var trades interface{} = this.ParseTrades(rawTrades, market)
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArrayCache := ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArrayCache)
    }
    var tradesArray interface{} = ccxt.GetValue(this.Trades, symbol)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        tradesArray.(ccxt.Appender).Append(ccxt.GetValue(trades, i))
    }
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    var messageHash interface{} = ccxt.Add("trades::", ccxt.GetValue(market, "symbol"))
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name bullish#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--anonymous-market-data-price-tick-unauthenticated
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BullishCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2018)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "/trading-api/v1/market-data/tick/"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("ticker::", symbol)
        
                retRes20615 :=  (<-this.Watch(url, messageHash, params, messageHash))
                ccxt.PanicOnError(retRes20615)
                ch <- retRes20615  // no need to send a subscribe message, the server sends a ticker update on connect
                return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "update",
    //         "dataType": "V1TATickerResponse",
    //         "data": {
    //             "askVolume": "0.00100822",
    //             "average": "104423.1806",
    //             "baseVolume": "472.83799258",
    //             "bestAsk": "104324.6000",
    //             "bestBid": "104324.5000",
    //             "bidVolume": "0.00020146",
    //             "change": "-198.4864",
    //             "close": "104323.9374",
    //             "createdAtTimestamp": "1749132838951",
    //             "publishedAtTimestamp": "1749132838955",
    //             "high": "105966.6577",
    //             "last": "104323.9374",
    //             "lastTradeDatetime": "2025-06-05T14:13:56.111Z",
    //             "lastTradeSize": "0.02396100",
    //             "low": "104246.6662",
    //             "open": "104522.4238",
    //             "percentage": "-0.19",
    //             "quoteVolume": "49662592.6712",
    //             "symbol": "BTC-USDC-PERP",
    //             "type": "ticker",
    //             "vwap": "105030.6996",
    //             "currentPrice": "104324.7747",
    //             "ammData": [
    //                 {
    //                     "feeTierId": "1",
    //                     "currentPrice": "104324.7747",
    //                     "baseReservesQuantity": "8.27911366",
    //                     "quoteReservesQuantity": "1067283.0234",
    //                     "bidSpreadFee": "0.00000000",
    //                     "askSpreadFee": "0.00000000"
    //                 }
    //             ],
    //             "createdAtDatetime": "2025-06-05T14:13:58.951Z",
    //             "markPrice": "104289.6884",
    //             "fundingRate": "-0.000192",
    //             "openInterest": "92.24146651"
    //         }
    //     }
    //
    var updateType interface{} = this.SafeString(message, "type", "")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var parsed interface{} = nil
    if ccxt.IsTrue((ccxt.IsEqual(updateType, "snapshot"))) {
        parsed = this.ParseTicker(data, market)
    } else if ccxt.IsTrue(ccxt.IsEqual(updateType, "update")) {
        var ticker interface{} = this.SafeDict(this.Tickers, symbol, map[string]interface{} {})
        var rawTicker interface{} = this.SafeDict(ticker, "info", map[string]interface{} {})
        var merged interface{} = this.Extend(rawTicker, data)
        parsed = this.ParseTicker(merged, market)
    }
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    var messageHash interface{} = ccxt.Add("ticker::", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
/**
 * @method
 * @name bullish#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--multi-orderbook-websocket-unauthenticated
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BullishCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2848 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2848)
            var market interface{} = this.Market(symbol)
            var url interface{} = "/trading-api/v1/market-data/orderbook"
            var messageHash interface{} = ccxt.Add("orderbook::", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "topic": "l2Orderbook",
                "symbol": ccxt.GetValue(market, "id"),
            }
        
            orderbook:= (<-this.WatchPublic(url, messageHash, request, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "snapshot",
    //         "dataType": "V1TALevel2",
    //         "data": {
    //             "timestamp": "1749372632028",
    //             "bids": [
    //                 "105523.3000",
    //                 "0.00046045",
    //             ],
    //             "asks": [
    //                 "105523.4000",
    //                 "0.00117112",
    //             ],
    //             "publishedAtTimestamp": "1749372632073",
    //             "datetime": "2025-06-08T08:50:32.028Z",
    //             "sequenceNumberRange": [ 1967862061, 1967862062 ],
    //             "symbol": "BTCUSDC"
    //         }
    //     }
    //
    // current channel is 'l2Orderbook' which returns only snapshots
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add("orderbook::", symbol)
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var bids interface{} = this.SeparateBidsOrAsks(this.SafeList(data, "bids", []interface{}{}))
    var asks interface{} = this.SeparateBidsOrAsks(this.SafeList(data, "asks", []interface{}{}))
    var snapshot interface{} = map[string]interface{} {
        "bids": bids,
        "asks": asks,
    }
    var parsed interface{} = this.ParseOrderBook(snapshot, symbol, timestamp)
    var sequenceNumberRange interface{} = this.SafeList(data, "sequenceNumberRange", []interface{}{})
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(sequenceNumberRange), 0)) {
        var lastIndex interface{} = ccxt.Subtract(ccxt.GetArrayLength(sequenceNumberRange), 1)
        ccxt.AddElementToObject(parsed, "nonce", this.SafeInteger(sequenceNumberRange, lastIndex))
    }
    orderbook.(ccxt.OrderBookInterface).Reset(parsed)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BullishCore) SeparateBidsOrAsks(entry interface{}) interface{}  {
    var result interface{} = []interface{}{}
    // 300 = '54885.0000000'
    // 301 = '0.06141566'
    // 302 ='53714.0000000'
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(entry)); i++ {
        if ccxt.IsTrue(!ccxt.IsEqual(ccxt.Mod(i, 2), 0)) {
            continue
        }
        var price interface{} = this.SafeString(entry, i)
        var amount interface{} = this.SafeString(entry, ccxt.Add(i, 1))
        ccxt.AppendToArray(&result, []interface{}{price, amount})
    }
    return result
}
/**
 * @method
 * @name bullish#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BullishCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3748)
            var subscribeHash interface{} = "orders"
            var messageHash interface{} = subscribeHash
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
            }
            var request interface{} = map[string]interface{} {
                "topic": "orders",
            }
            var tradingAccountId interface{} = this.SafeString(params, "tradingAccountId")
            if ccxt.IsTrue(!ccxt.IsEqual(tradingAccountId, nil)) {
                ccxt.AddElementToObject(request, "tradingAccountId", tradingAccountId)
                params = this.Omit(params, "tradingAccountId")
            }
        
            orders:= (<-this.WatchPrivate(messageHash, subscribeHash, request, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleOrders(client interface{}, message interface{})  {
    // snapshot
    //     {
    //         "type": "snapshot",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TAOrder",
    //         "data": [ ... ] // could be an empty list or a list of orders
    //     }
    //
    // update
    //     {
    //         "type": "update",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TAOrder",
    //         "data": {
    //             "status": "OPEN",
    //             "createdAtTimestamp": "1751893427971",
    //             "quoteFee": "0.000000",
    //             "stopPrice": null,
    //             "quantityFilled": "0.00000000",
    //             "handle": null,
    //             "clientOrderId": null,
    //             "quantity": "0.10000000",
    //             "margin": false,
    //             "side": "BUY",
    //             "createdAtDatetime": "2025-07-07T13:03:47.971Z",
    //             "isLiquidation": false,
    //             "borrowedQuoteQuantity": null,
    //             "borrowedBaseQuantity": null,
    //             "timeInForce": "GTC",
    //             "borrowedQuantity": null,
    //             "baseFee": "0.000000",
    //             "quoteAmount": "0.0000000",
    //             "price": "0.0000000",
    //             "statusReason": "ccxt.Order accepted",
    //             "type": "MKT",
    //             "statusReasonCode": 6014,
    //             "allowBorrow": false,
    //             "orderId": "862317981870850049",
    //             "publishedAtTimestamp": "1751893427975",
    //             "symbol": "ETHUSDT",
    //             "averageFillPrice": null
    //         }
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var rawOrders interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        ccxt.AppendToArray(&rawOrders, data) // update is a single order
    } else {
        rawOrders = this.SafeList(message, "data", []interface{}{}) // snapshot is a list of orders
    }
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(rawOrders), 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var orders interface{} = this.Orders
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
            var rawOrder interface{} = ccxt.GetValue(rawOrders, i)
            var parsedOrder interface{} = this.ParseOrder(rawOrder)
            orders.(ccxt.Appender).Append(parsedOrder)
            var symbol interface{} = this.SafeString(parsedOrder, "symbol")
            ccxt.AddElementToObject(symbols, symbol, true)
        }
        var messageHash interface{} = "orders"
        client.(ccxt.ClientInterface).Resolve(orders, messageHash)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var hashSymbol interface{} = ccxt.GetValue(keys, i)
            var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), hashSymbol)
            client.(ccxt.ClientInterface).Resolve(this.Orders, symbolMessageHash)
        }
    }
}
/**
 * @method
 * @name bullish#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BullishCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4878)
            var subscribeHash interface{} = "myTrades"
            var messageHash interface{} = subscribeHash
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", symbol))
            }
            var request interface{} = map[string]interface{} {
                "topic": "trades",
            }
            var tradingAccountId interface{} = this.SafeString(params, "tradingAccountId")
            if ccxt.IsTrue(!ccxt.IsEqual(tradingAccountId, nil)) {
                ccxt.AddElementToObject(request, "tradingAccountId", tradingAccountId)
                params = this.Omit(params, "tradingAccountId")
            }
        
            trades:= (<-this.WatchPrivate(messageHash, subscribeHash, request, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // snapshot
    //     {
    //         "type": "snapshot",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TATrade",
    //         "data": [ ... ] // could be an empty list or a list of trades
    //     }
    //
    // update
    //     {
    //         "type": "update",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TATrade",
    //         "data": {
    //             "clientOtcTradeId": null,
    //             "tradeId": "100203000003940164",
    //             "baseFee": "0.00000000",
    //             "isTaker": true,
    //             "quoteAmount": "253.6012195",
    //             "price": "2536.0121950",
    //             "createdAtTimestamp": "1751914859840",
    //             "quoteFee": "0.0000000",
    //             "tradeRebateAmount": null,
    //             "tradeRebateAssetSymbol": null,
    //             "handle": null,
    //             "otcTradeId": null,
    //             "otcMatchId": null,
    //             "orderId": "862407873644725249",
    //             "quantity": "0.10000000",
    //             "publishedAtTimestamp": "1751914859843",
    //             "side": "SELL",
    //             "createdAtDatetime": "2025-07-07T19:00:59.840Z",
    //             "symbol": "ETHUSDT"
    //         }
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var rawTrades interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        ccxt.AppendToArray(&rawTrades, data) // update is a single trade
    } else {
        rawTrades = this.SafeList(message, "data", []interface{}{}) // snapshot is a list of trades
    }
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(rawTrades), 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var trades interface{} = this.MyTrades
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
            var rawTrade interface{} = ccxt.GetValue(rawTrades, i)
            var parsedTrade interface{} = this.ParseTrade(rawTrade)
            trades.(ccxt.Appender).Append(parsedTrade)
            var symbol interface{} = this.SafeString(parsedTrade, "symbol")
            ccxt.AddElementToObject(symbols, symbol, true)
        }
        var messageHash interface{} = "myTrades"
        client.(ccxt.ClientInterface).Resolve(trades, messageHash)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var hashSymbol interface{} = ccxt.GetValue(keys, i)
            var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), hashSymbol)
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, symbolMessageHash)
        }
    }
}
/**
 * @method
 * @name bullish#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.tradingAccountId] the trading account id to fetch entries for
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BullishCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5908)
            var request interface{} = map[string]interface{} {
                "topic": "assetAccounts",
            }
            var messageHash interface{} = "balance"
            var tradingAccountId interface{} = this.SafeString(params, "tradingAccountId")
            if ccxt.IsTrue(!ccxt.IsEqual(tradingAccountId, nil)) {
                params = this.Omit(params, "tradingAccountId")
                ccxt.AddElementToObject(request, "tradingAccountId", tradingAccountId)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", tradingAccountId))
            }
        
                retRes60115 :=  (<-this.WatchPrivate(messageHash, messageHash, request, params))
                ccxt.PanicOnError(retRes60115)
                ch <- retRes60115
                return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandleBalance(client interface{}, message interface{})  {
    //
    // snapshot
    //     {
    //         "type": "snapshot",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TAAssetAccount",
    //         "data": [
    //             {
    //                 "updatedAtTimestamp": "1751989627509",
    //                 "borrowedQuantity": "0.0000",
    //                 "tradingAccountId": "111309424211255",
    //                 "loanedQuantity": "0.0000",
    //                 "lockedQuantity": "0.0000",
    //                 "assetId": "5",
    //                 "assetSymbol": "USDC",
    //                 "publishedAtTimestamp": "1751989627512",
    //                 "availableQuantity": "999672939.8767",
    //                 "updatedAtDatetime": "2025-07-08T15:47:07.509Z"
    //             }
    //         ]
    //     }
    //
    // update
    //     {
    //         "type": "update",
    //         "tradingAccountId": "111309424211255",
    //         "dataType": "V1TAAssetAccount",
    //         "data": {
    //             "updatedAtTimestamp": "1751989627509",
    //             "borrowedQuantity": "0.0000",
    //             "tradingAccountId": "111309424211255",
    //             "loanedQuantity": "0.0000",
    //             "lockedQuantity": "0.0000",
    //             "assetId": "5",
    //             "assetSymbol": "USDC",
    //             "publishedAtTimestamp": "1751989627512",
    //             "availableQuantity": "999672939.8767",
    //             "updatedAtDatetime": "2025-07-08T15:47:07.509Z"
    //         }
    //     }
    //
    var tradingAccountId interface{} = this.SafeString(message, "tradingAccountId")
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, tradingAccountId))) {
        ccxt.AddElementToObject(this.Balance, tradingAccountId, map[string]interface{} {})
    }
    var messageType interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(messageType, "snapshot")) {
        var data interface{} = this.SafeList(message, "data", []interface{}{})
        ccxt.AddElementToObject(this.Balance, tradingAccountId, this.ParseBalance(data))
    } else {
        var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        var assetId interface{} = this.SafeString(data, "assetSymbol")
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "total", this.SafeString(data, "availableQuantity"))
        ccxt.AddElementToObject(account, "used", this.SafeString(data, "lockedQuantity"))
        var code interface{} = this.SafeCurrencyCode(assetId)
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, tradingAccountId), code, account)
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, tradingAccountId), "info", message)
        ccxt.AddElementToObject(this.Balance, tradingAccountId, this.SafeBalance(ccxt.GetValue(this.Balance, tradingAccountId)))
    }
    var messageHash interface{} = "balance"
    var tradingAccountIdHash interface{} = ccxt.Add("::", tradingAccountId)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, tradingAccountId), messageHash)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, tradingAccountId), ccxt.Add(messageHash, tradingAccountIdHash))
}
/**
 * @method
 * @name bullish#watchPositions
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BullishCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6838 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6838)
            var subscribeHash interface{} = "positions"
            var messageHash interface{} = subscribeHash
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.MarketSymbols(symbols)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var request interface{} = map[string]interface{} {
                "topic": "derivativesPositionsV2",
            }
        
            positions:= (<-this.WatchPrivate(messageHash, subscribeHash, request, params))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BullishCore) HandlePositions(client interface{}, message interface{})  {
    // exchange does not return messages for sandbox mode
    // current method is implemented blindly
    // todo: check if this works with not-sandbox mode
    var messageType interface{} = this.SafeString(message, "type")
    var rawPositions interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(messageType, "update")) {
        var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        ccxt.AppendToArray(&rawPositions, data)
    } else {
        rawPositions = this.SafeList(message, "data", []interface{}{})
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var positions interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParsePosition(rawPosition)
        positions.(ccxt.Appender).Append(position)
        ccxt.AppendToArray(&newPositions, position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var symbolPositions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(symbolPositions)) {
            client.(ccxt.ClientInterface).Resolve(symbolPositions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(positions, "positions")
}
func  (this *BullishCore) HandleErrorMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "errorCode": 401,
    //             "errorCodeName": "UNAUTHORIZED",
    //             "message": "Unable to authenticate; JWT is missing/invalid or unauthorised to access account"
    //         },
    //         "dataType": "V1TAErrorResponse",
    //         "type": "error"
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(data))
    
        {
             func(this *BullishCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BullishCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        var errorCode interface{} = this.SafeString(data, "errorCode")
            var errorCodeName interface{} = this.SafeString(data, "errorCodeName")
            this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
            this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), errorCodeName, feedback)
            panic(ccxt.ExchangeError(feedback))
    		    
    	    }(this)
        
            }
}
func  (this *BullishCore) HandleMessage(client interface{}, message interface{})  {
    var dataType interface{} = this.SafeString(message, "dataType")
    var result interface{} = this.SafeDict(message, "result")
    if ccxt.IsTrue(!ccxt.IsEqual(result, nil)) {
        var response interface{} = this.SafeString(result, "message")
        if ccxt.IsTrue(ccxt.IsEqual(response, "Keep alive pong")) {
            this.HandlePong(client, message)
        }
    } else if ccxt.IsTrue(!ccxt.IsEqual(dataType, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TAAnonymousTradeUpdate")) {
            this.HandleTrades(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TATickerResponse")) {
            this.HandleTicker(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TALevel2")) {
            this.HandleOrderBook(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TAOrder")) {
            this.HandleOrders(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TATrade")) {
            this.HandleMyTrades(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TAAssetAccount")) {
            this.HandleBalance(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(dataType, "V1TAErrorResponse")) {
            this.HandleErrorMessage(client, message)
        }
    }
}


func (this *BullishCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
