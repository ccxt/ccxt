package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitvavoCore struct {
	*ccxt.BitvavoCore
	base *ccxt.BitvavoCore
}

func NewBitvavoCore() *BitvavoCore {
    p := &BitvavoCore{}
	base := &ccxt.BitvavoCore{}
	p.base = base
	p.BitvavoCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitvavoCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelOrdersWs": false,
            "fetchTradesWs": false,
            "watchOrderBook": true,
            "watchTrades": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchOHLCV": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "cancelAllOrdersWs": true,
            "cancelOrderWs": true,
            "createOrderWs": true,
            "createStopLimitOrderWs": true,
            "createStopMarketOrderWs": true,
            "createStopOrderWs": true,
            "editOrderWs": true,
            "fetchBalanceWs": true,
            "fetchCurrenciesWS": true,
            "fetchDepositAddressWs": false,
            "fetchDepositsWs": true,
            "fetchDepositWithdrawFeesWs": false,
            "fetchMyTradesWs": true,
            "fetchOHLCVWs": true,
            "fetchOpenOrdersWs": true,
            "fetchOrderWs": true,
            "fetchOrderBookWs": false,
            "fetchOrdersWs": true,
            "fetchTickerWs": false,
            "fetchTickersWs": false,
            "fetchTimeWs": false,
            "fetchTradingFeesWs": true,
            "fetchWithdrawalsWs": true,
            "withdrawWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.bitvavo.com/v2",
            },
        },
        "options": map[string]interface{} {
            "supressMultipleWsRequestsError": false,
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
        },
    })
}
func  (this *BitvavoCore) WatchPublic(name interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes678)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": name,
            "markets": []interface{}{ccxt.GetValue(market, "id")},
        }},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes8315 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes8315)
                ch <- retRes8315
                return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) WatchPublicMultiple(methodName interface{}, channelName interface{}, symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes878)
            symbols = this.MarketSymbols(symbols)
            var messageHashes interface{} = []interface{}{methodName}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&args, ccxt.GetValue(market, "id"))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": channelName,
            "markets": args,
        }},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes10615 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes10615)
                ch <- retRes10615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.bitvavo.com/#tag/ccxt.Market-data-subscription-WebSocket/paths/~1subscribeTicker24h/post
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitvavoCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes11915 :=  (<-this.WatchPublic("ticker24h", symbol, params))
                ccxt.PanicOnError(retRes11915)
                ch <- retRes11915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.bitvavo.com/#tag/ccxt.Market-data-subscription-WebSocket/paths/~1subscribeTicker24h/post
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitvavoCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1328 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1328)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = "ticker24h"
        
            tickers:= (<-this.WatchPublicMultiple(channel, channel, symbols, params))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "ticker24h",
    //         "data": [
    //             {
    //                 "market": "ETH-EUR",
    //                 "open": "193.5",
    //                 "high": "202.72",
    //                 "low": "192.46",
    //                 "last": "199.01",
    //                 "volume": "3587.05020246",
    //                 "volumeQuote": "708030.17",
    //                 "bid": "199.56",
    //                 "bidSize": "4.14730802",
    //                 "ask": "199.57",
    //                 "askSize": "6.13642074",
    //                 "timestamp": 1590770885217
    //             }
    //         ]
    //     }
    //
    this.HandleBidAsk(client, message)
    var event interface{} = this.SafeString(message, "event")
    var tickers interface{} = this.SafeValue(message, "data", []interface{}{})
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tickers)); i++ {
        var data interface{} = ccxt.GetValue(tickers, i)
        var marketId interface{} = this.SafeString(data, "market")
        var market interface{} = this.SafeMarket(marketId, nil, "-")
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, "@"), marketId)
        var ticker interface{} = this.ParseTicker(data, market)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        ccxt.AppendToArray(&result, ticker)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(result, event)
}
/**
 * @method
 * @name bitvavo#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.bitvavo.com/#tag/ccxt.Market-data-subscription-WebSocket/paths/~1subscribeTicker24h/post
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitvavoCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1898)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = "ticker24h"
        
            tickers:= (<-this.WatchPublicMultiple("bidask", channel, symbols, params))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleBidAsk(client interface{}, message interface{})  {
    var event interface{} = "bidask"
    var tickers interface{} = this.SafeValue(message, "data", []interface{}{})
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tickers)); i++ {
        var data interface{} = ccxt.GetValue(tickers, i)
        var ticker interface{} = this.ParseWsBidAsk(data)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
        ccxt.AppendToArray(&result, ticker)
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(result, event)
}
func  (this *BitvavoCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "market")
    market = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(ticker, "ask"),
        "askVolume": this.SafeNumber(ticker, "askSize"),
        "bid": this.SafeNumber(ticker, "bid"),
        "bidVolume": this.SafeNumber(ticker, "bidSize"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitvavo#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitvavoCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2408)
            symbol = this.Symbol(symbol)
        
            trades:= (<-this.WatchPublic("trades", symbol, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "trade",
    //         "timestamp": 1590779594547,
    //         "market": "ETH-EUR",
    //         "id": "450c3298-f082-4461-9e2c-a0262cc7cc2e",
    //         "amount": "0.05026233",
    //         "price": "198.46",
    //         "side": "buy"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var name interface{} = "trades"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), marketId)
    var trade interface{} = this.ParseTrade(message, market)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    tradesArray.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name bitvavo#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitvavoCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2898)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var name interface{} = "candles"
            var marketId interface{} = ccxt.GetValue(market, "id")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, "@"), marketId), "_"), interval)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": "candles",
            "interval": []interface{}{interval},
            "markets": []interface{}{marketId},
        }},
            }
            var message interface{} = this.Extend(request, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleFetchOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'getCandles',
    //        response: [
    //            [1690325820000, '26453', '26453', '26436', '26447', '0.01626246'],
    //            [1690325760000, '26454', '26454', '26453', '26453', '0.00037707']
    //        ]
    //    }
    //
    var response interface{} = this.SafeValue(message, "response")
    var ohlcv interface{} = this.ParseOHLCVs(response, nil, nil, nil)
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(ohlcv, messageHash)
}
func  (this *BitvavoCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "candle",
    //         "market": "BTC-EUR",
    //         "interval": "1m",
    //         "candle": [
    //             [
    //                 1590797160000,
    //                 "8480.9",
    //                 "8480.9",
    //                 "8480.9",
    //                 "8480.9",
    //                 "0.01038628"
    //             ]
    //         ]
    //     }
    //
    var name interface{} = "candles"
    var marketId interface{} = this.SafeString(message, "market")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(message, "interval")
    // use a reverse lookup in a static map instead
    var timeframe interface{} = this.FindTimeframe(interval)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, "@"), marketId), "_"), interval)
    var candles interface{} = this.SafeValue(message, "candle")
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(candles)); i++ {
        var candle interface{} = ccxt.GetValue(candles, i)
        var parsed interface{} = this.ParseOHLCV(candle, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name bitvavo#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitvavoCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3838 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3838)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var name interface{} = "book"
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": name,
            "markets": []interface{}{ccxt.GetValue(market, "id")},
        }},
            }
            var subscription interface{} = map[string]interface{} {
                "messageHash": messageHash,
                "name": name,
                "symbol": symbol,
                "marketId": ccxt.GetValue(market, "id"),
                "method": this.HandleOrderBookSubscription,
                "limit": limit,
                "params": params,
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BitvavoCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BitvavoCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    //
    //     {
    //         "event": "book",
    //         "market": "BTC-EUR",
    //         "nonce": 36947383,
    //         "bids": [
    //             [ "8477.8", "0" ]
    //         ],
    //         "asks": [
    //             [ "8550.9", "0" ]
    //         ]
    //     }
    //
    var nonce interface{} = this.SafeInteger(message, "nonce")
    if ccxt.IsTrue(ccxt.IsGreaterThan(nonce, ccxt.GetValue(orderbook, "nonce"))) {
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), this.SafeValue(message, "asks", []interface{}{}))
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), this.SafeValue(message, "bids", []interface{}{}))
        ccxt.AddElementToObject(orderbook, "nonce", nonce)
    }
    return orderbook
}
func  (this *BitvavoCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "book",
    //         "market": "BTC-EUR",
    //         "nonce": 36729561,
    //         "bids": [
    //             [ "8513.3", "0" ],
    //             [ '8518.8', "0.64236203" ],
    //             [ '8513.6', "0.32435481" ],
    //         ],
    //         "asks": []
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    var marketId interface{} = this.SafeString(message, "market")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(event, "@"), ccxt.GetValue(market, "id"))
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderbook, "nonce"), nil)) {
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
        var watchingOrderBookSnapshot interface{} = this.SafeValue(subscription, "watchingOrderBookSnapshot")
        if ccxt.IsTrue(ccxt.IsEqual(watchingOrderBookSnapshot, nil)) {
            ccxt.AddElementToObject(subscription, "watchingOrderBookSnapshot", true)
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, subscription)
            var options interface{} = this.SafeValue(this.Options, "watchOrderBookSnapshot", map[string]interface{} {})
            var delay interface{} = this.SafeInteger(options, "delay", this.RateLimit)
            // fetch the snapshot in a separate async call after a warmup delay
            this.Delay(delay, this.WatchOrderBookSnapshot, client, message, subscription)
        }
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        this.HandleOrderBookMessage(client, message, orderbook)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *BitvavoCore) WatchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = this.SafeValue(subscription, "params")
            var marketId interface{} = this.SafeString(subscription, "marketId")
            var name interface{} = "getBook"
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), marketId)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "action": name,
                "market": marketId,
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleOrderBookSnapshot(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "getBook",
    //         "response": {
    //             "market": "BTC-EUR",
    //             "nonce": 36946120,
    //             "bids": [
    //                 [ '8494.9', "0.24399521" ],
    //                 [ '8494.8', "0.34884085" ],
    //                 [ '8493.9', "0.14535128" ],
    //             ],
    //             "asks": [
    //                 [ "8495", "0.46982463" ],
    //                 [ '8495.1', "0.12178267" ],
    //                 [ '8496.2', "0.21924143" ],
    //             ]
    //         }
    //     }
    //
    var response interface{} = this.SafeValue(message, "response")
    if ccxt.IsTrue(ccxt.IsEqual(response, nil)) {
        return
    }
    var marketId interface{} = this.SafeString(response, "market")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var name interface{} = "book"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), marketId)
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(response, symbol)
    ccxt.AddElementToObject(snapshot, "nonce", this.SafeInteger(response, "nonce"))
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    // unroll the accumulated deltas
    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
        var messageItem interface{} = ccxt.GetValue(messages, i)
        this.HandleOrderBookMessage(client, messageItem, orderbook)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BitvavoCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var limit interface{} = this.SafeInteger(subscription, "limit")
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
}
func  (this *BitvavoCore) HandleOrderBookSubscriptions(client interface{}, message interface{}, marketIds interface{})  {
    var name interface{} = "book"
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = this.SafeString(marketIds, i)
        var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
        var messageHash interface{} = ccxt.Add(ccxt.Add(name, "@"), marketId)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            var method interface{} = this.SafeValue(subscription, "method")
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message, subscription)
            }
        }
    }
}
/**
 * @method
 * @name bitvavo#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrders() requires a symbol argument")))
            }
        
            retRes5858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5858)
        
            retRes5868 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5868)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var name interface{} = "account"
            var messageHash interface{} = ccxt.Add("order:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": name,
            "markets": []interface{}{marketId},
        }},
            }
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitvavoCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchMyTrades() requires a symbol argument")))
            }
        
            retRes6238 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6238)
        
            retRes6248 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6248)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var name interface{} = "account"
            var messageHash interface{} = ccxt.Add("myTrades:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channels": []interface{}{map[string]interface{} {
            "name": name,
            "markets": []interface{}{marketId},
        }},
            }
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#createOrderWs
 * @description create a trade order
 * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/post
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
 * @param {float} [params.stopPrice] The price at which a trigger order is triggered at
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] If true, the order will only be posted to the order book and not executed immediately
 * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
 * @param {string} [params.triggerType] "price"
 * @param {string} [params.triggerReference] "lastTrade", "bestBid", "bestAsk", "midPrice" Only for stop orders: Use this to determine which parameter will trigger the order
 * @param {string} [params.selfTradePrevention] "decrementAndCancel", "cancelOldest", "cancelNewest", "cancelBoth"
 * @param {bool} [params.disableMarketProtection] don't cancel if the next fill price is 10% worse than the best fill price
 * @param {bool} [params.responseRequired] ccxt.Set this to 'false' when only an acknowledgement of success or failure is required, this is faster.
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6728)
        
            retRes6738 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6738)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
        
                retRes67515 :=  (<-this.WatchRequest("privateCreateOrder", request))
                ccxt.PanicOnError(retRes67515)
                ch <- retRes67515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#editOrderWs
 * @description edit a trade order
 * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/put
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} [amount] how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6938)
        
            retRes6948 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6948)
            var request interface{} = this.EditOrderRequest(id, symbol, typeVar, side, amount, price, params)
        
                retRes69615 :=  (<-this.WatchRequest("privateUpdateOrder", request))
                ccxt.PanicOnError(retRes69615)
                ch <- retRes69615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#cancelOrderWs
 * @see https://docs.bitvavo.com/#tag/Orders/paths/~1order/delete
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7108)
        
            retRes7118 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7118)
            var request interface{} = this.CancelOrderRequest(id, symbol, params)
        
                retRes71315 :=  (<-this.WatchRequest("privateCancelOrder", request))
                ccxt.PanicOnError(retRes71315)
                ch <- retRes71315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#cancelAllOrdersWs
 * @see https://docs.bitvavo.com/#tag/Orders/paths/~1orders/delete
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7268)
        
            retRes7278 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7278)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                ccxt.AddElementToObject(request, "market", ccxt.GetValue(market, "id"))
            }
        
                retRes73415 :=  (<-this.WatchRequest("privateCancelOrders", this.Extend(request, params)))
                ccxt.PanicOnError(retRes73415)
                ch <- retRes73415
                return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleMultipleOrders(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateCancelOrders',
    //        response: [{
    //            orderId: 'd71df826-1130-478a-8741-d219128675b0'
    //        }]
    //    }
    //
    // const action = this.safeString (message, 'action')
    var response interface{} = this.SafeList(message, "response")
    // const firstRawOrder = this.safeValue (response, 0, {})
    // const marketId = this.safeString (firstRawOrder, 'market')
    var orders interface{} = this.ParseOrders(response)
    // let messageHash = this.buildMessageHash (action, { 'market': marketId })
    // client.resolve (orders, messageHash)
    // messageHash = this.buildMessageHash (action, message)
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
/**
 * @method
 * @name bitvavo#fetchOrderWs
 * @see https://docs.bitvavo.com/#tag/General/paths/~1assets/get
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) FetchOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes7728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7728)
        
            retRes7738 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "orderId": id,
                "market": ccxt.GetValue(market, "id"),
            }
        
                retRes77915 :=  (<-this.WatchRequest("privateGetOrder", this.Extend(request, params)))
                ccxt.PanicOnError(retRes77915)
                ch <- retRes77915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchOrdersWs
 * @see https://docs.bitvavo.com/#tag/Orders/paths/~1orders/get
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) FetchOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " fetchOrdersWs() requires a symbol argument")))
            }
        
            retRes7978 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7978)
        
            retRes7988 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7988)
            var request interface{} = this.FetchOrdersRequest(symbol, since, limit, params)
        
            orders:= (<-this.WatchRequest("privateGetOrders", request))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) RequestId() interface{}  {
    var ts interface{} = ccxt.ToString(this.Milliseconds())
    var randomNumber interface{} = this.RandNumber(4)
    var randomPart interface{} = ccxt.ToString(randomNumber)
    return ccxt.ParseInt(ccxt.Add(ts, randomPart))
}
func  (this *BitvavoCore) WatchRequest(action interface{}, request interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var messageHash interface{} = this.RequestId()
            var messageHashStr interface{} = ccxt.ToString(messageHash)
            ccxt.AddElementToObject(request, "action", action)
            ccxt.AddElementToObject(request, "requestId", messageHash)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes81715 :=  (<-this.Watch(url, messageHashStr, request, messageHashStr))
                ccxt.PanicOnError(retRes81715)
                ch <- retRes81715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchOpenOrdersWs
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitvavoCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8318)
        
            retRes8328 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8328)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                ccxt.AddElementToObject(request, "market", ccxt.GetValue(market, "id"))
            }
        
            orders:= (<-this.WatchRequest("privateGetOrdersOpen", this.Extend(request, params)))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchMyTradesWs
 * @see https://docs.bitvavo.com/#tag/Trades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {ccxt.Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitvavoCore) FetchMyTradesWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " fetchMyTradesWs() requires a symbol argument")))
            }
        
            retRes8608 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8608)
        
            retRes8618 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8618)
            var request interface{} = this.FetchMyTradesRequest(symbol, since, limit, params)
        
            myTrades:= (<-this.WatchRequest("privateGetTrades", request))
            ccxt.PanicOnError(myTrades)
        
            ch <- this.FilterBySymbolSinceLimit(myTrades, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateGetTrades',
    //        response: [
    //            {
    //                "id": "108c3633-0276-4480-a902-17a01829deae",
    //                "orderId": "1d671998-3d44-4df4-965f-0d48bd129a1b",
    //                "timestamp": 1542967486256,
    //                "market": "BTC-EUR",
    //                "side": "buy",
    //                "amount": "0.005",
    //                "price": "5000.1",
    //                "taker": true,
    //                "fee": "0.03",
    //                "feeCurrency": "EUR",
    //                "settled": true
    //            }
    //        ]
    //    }
    //
    //
    // const action = this.safeString (message, 'action')
    var response interface{} = this.SafeList(message, "response")
    // const marketId = this.safeString (firstRawTrade, 'market')
    var trades interface{} = this.ParseTrades(response, nil, nil, nil)
    // const messageHash = this.buildMessageHash (action, { 'market': marketId })
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name bitvavo#withdrawWs
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *BitvavoCore) WithdrawWs(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    tag := ccxt.GetArg(optionalArgs, 0, nil)
            _ = tag
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
            tag = ccxt.GetValue(tagparamsVariable,0)
            params = ccxt.GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes9128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9128)
        
            retRes9138 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9138)
            var request interface{} = this.WithdrawRequest(code, amount, address, tag, params)
        
                retRes91515 :=  (<-this.WatchRequest("privateWithdrawAssets", request))
                ccxt.PanicOnError(retRes91515)
                ch <- retRes91515
                return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleWithdraw(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateWithdrawAssets',
    //        response: {
    //         "success": true,
    //         "symbol": "BTC",
    //         "amount": "1.5"
    //        }
    //    }
    //
    // const action = this.safeString (message, 'action')
    // const messageHash = this.buildMessageHash (action, message)
    var messageHash interface{} = this.SafeString(message, "requestId")
    var response interface{} = this.SafeValue(message, "response")
    var withdraw interface{} = this.ParseTransaction(response)
    client.(ccxt.ClientInterface).Resolve(withdraw, messageHash)
}
/**
 * @method
 * @name bitvavo#fetchWithdrawalsWs
 * @see https://docs.bitvavo.com/#tag/ccxt.Account/paths/~1withdrawalHistory/get
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *BitvavoCore) FetchWithdrawalsWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    code := ccxt.GetArg(optionalArgs, 0, nil)
            _ = code
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9498)
        
            retRes9508 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9508)
            var request interface{} = this.FetchWithdrawalsRequest(code, since, limit, params)
        
            withdraws:= (<-this.WatchRequest("privateGetWithdrawalHistory", request))
            ccxt.PanicOnError(withdraws)
        
            ch <- this.FilterByCurrencySinceLimit(withdraws, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleWithdraws(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateGetWithdrawalHistory',
    //        response: [{
    //                timestamp: 1689792085000,
    //                symbol: 'BTC',
    //                amount: '0.0009',
    //                fee: '0',
    //                status: 'completed',
    //                txId: '7dbadc658d7d59c129de1332c55ee8e08d0ab74432faae03b417b9809c819d1f'
    //            },
    //            ...
    //        ]
    //    }
    //
    // const action = this.safeString (message, 'action')
    // const messageHash = this.buildMessageHash (action, message)
    var response interface{} = this.SafeList(message, "response")
    var messageHash interface{} = this.SafeString(message, "requestId")
    var withdrawals interface{} = this.ParseTransactions(response, nil, nil, nil, map[string]interface{} {
        "type": "withdrawal",
    })
    client.(ccxt.ClientInterface).Resolve(withdrawals, messageHash)
}
/**
 * @method
 * @name bitvavo#fetchOHLCVWs
 * @see https://docs.bitvavo.com/#tag/ccxt.Market-Data/paths/~1{market}~1candles/get
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitvavoCore) FetchOHLCVWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9938)
            var request interface{} = this.FetchOHLCVRequest(symbol, timeframe, since, limit, params)
            var action interface{} = "getCandles"
        
            ohlcv:= (<-this.WatchRequest(action, request))
            ccxt.PanicOnError(ohlcv)
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchDepositsWs
 * @see https://docs.bitvavo.com/#tag/ccxt.Account/paths/~1depositHistory/get
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *BitvavoCore) FetchDepositsWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    code := ccxt.GetArg(optionalArgs, 0, nil)
            _ = code
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10128)
        
            retRes10138 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10138)
            var request interface{} = this.FetchDepositsRequest(code, since, limit, params)
        
            deposits:= (<-this.WatchRequest("privateGetDepositHistory", request))
            ccxt.PanicOnError(deposits)
        
            ch <- this.FilterByCurrencySinceLimit(deposits, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleDeposits(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateGetDepositHistory',
    //        response: [{
    //                timestamp: 1689792085000,
    //                symbol: 'BTC',
    //                amount: '0.0009',
    //                fee: '0',
    //                status: 'completed',
    //                txId: '7dbadc658d7d59c129de1332c55ee8e08d0ab74432faae03b417b9809c819d1f'
    //            },
    //            ...
    //        ]
    //    }
    //
    var response interface{} = this.SafeValue(message, "response")
    var deposits interface{} = this.ParseTransactions(response, nil, nil, nil, map[string]interface{} {
        "type": "deposit",
    })
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(deposits, messageHash)
}
/**
 * @method
 * @name bitvavo#fetchTradingFeesWs
 * @see https://docs.bitvavo.com/#tag/ccxt.Account/paths/~1account/get
 * @description fetch the trading fees for multiple markets
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *BitvavoCore) FetchTradingFeesWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10508)
        
            retRes10518 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10518)
        
                retRes105215 :=  (<-this.WatchRequest("privateGetAccount", params))
                ccxt.PanicOnError(retRes105215)
                ch <- retRes105215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchMarketsWs
 * @see https://docs.bitvavo.com/#tag/General/paths/~1markets/get
 * @description retrieves data on all markets for bitvavo
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *BitvavoCore) FetchMarketsWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes106415 :=  (<-this.WatchRequest("getMarkets", params))
                ccxt.PanicOnError(retRes106415)
                ch <- retRes106415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitvavo#fetchCurrenciesWs
 * @see https://docs.bitvavo.com/#tag/General/paths/~1assets/get
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *BitvavoCore) FetchCurrenciesWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10768)
        
                retRes107715 :=  (<-this.WatchRequest("getAssets", params))
                ccxt.PanicOnError(retRes107715)
                ch <- retRes107715
                return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleFetchCurrencies(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'getAssets',
    //        response: [{
    //                symbol: '1INCH',
    //                name: '1inch',
    //                decimals: 8,
    //                depositFee: '0',
    //                depositConfirmations: 64,
    //                depositStatus: 'OK',
    //                withdrawalFee: '13',
    //                withdrawalMinAmount: '13',
    //                withdrawalStatus: 'OK',
    //                networks: [Array],
    //                message: ''
    //            },
    //            ...
    //        ]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "requestId")
    var response interface{} = this.SafeValue(message, "response")
    var currencies interface{} = this.ParseCurrencies(response)
    client.(ccxt.ClientInterface).Resolve(currencies, messageHash)
}
func  (this *BitvavoCore) HandleTradingFees(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateGetAccount',
    //        response: {
    //            fees: {
    //                taker: '0.0025',
    //                maker: '0.0015',
    //                volume: '1693.74'
    //            }
    //        }
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "requestId")
    var response interface{} = this.SafeValue(message, "response")
    var fees interface{} = this.ParseTradingFees(response)
    client.(ccxt.ClientInterface).Resolve(fees, messageHash)
}
/**
 * @method
 * @name bitvavo#fetchBalanceWs
 * @see https://docs.bitvavo.com/#tag/ccxt.Account/paths/~1balance/get
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the bitvavo api endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
 */
func  (this *BitvavoCore) FetchBalanceWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11358)
        
            retRes11368 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes11368)
        
                retRes113715 :=  (<-this.WatchRequest("privateGetBalance", params))
                ccxt.PanicOnError(retRes113715)
                ch <- retRes113715
                return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleFetchBalance(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateGetBalance',
    //        response: [{
    //                symbol: 'ADA',
    //                available: '0',
    //                inOrder: '0'
    //            },
    //            ...
    //        ]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "requestId")
    var response interface{} = this.SafeValue(message, "response", []interface{}{})
    var balance interface{} = this.ParseBalance(response)
    client.(ccxt.ClientInterface).Resolve(balance, messageHash)
}
func  (this *BitvavoCore) HandleSingleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'privateCreateOrder',
    //        response: {
    //            orderId: 'd71df826-1130-478a-8741-d219128675b0',
    //            market: 'BTC-EUR',
    //            created: 1689792749748,
    //            updated: 1689792749748,
    //            status: 'new',
    //            side: 'sell',
    //            orderType: 'limit',
    //            amount: '0.0002',
    //            amountRemaining: '0.0002',
    //            price: '37000',
    //            onHold: '0.0002',
    //            onHoldCurrency: 'BTC',
    //            filledAmount: '0',
    //            filledAmountQuote: '0',
    //            feePaid: '0',
    //            feeCurrency: 'EUR',
    //            fills: [],
    //            selfTradePrevention: 'decrementAndCancel',
    //            visible: true,
    //            timeInForce: 'GTC',
    //            postOnly: false
    //        }
    //    }
    //
    var response interface{} = this.SafeValue(message, "response", map[string]interface{} {})
    var order interface{} = this.ParseOrder(response)
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
func  (this *BitvavoCore) HandleMarkets(client interface{}, message interface{})  {
    //
    //    {
    //        action: 'getMarkets',
    //        response: [{
    //                market: '1INCH-EUR',
    //                status: 'trading',
    //                base: '1INCH',
    //                quote: 'EUR',
    //                pricePrecision: 5,
    //                minOrderInBaseAsset: '2',
    //                minOrderInQuoteAsset: '5',
    //                maxOrderInBaseAsset: '1000000000',
    //                maxOrderInQuoteAsset: '1000000000',
    //                orderTypes: [Array]
    //            },
    //            ...
    //        ]
    //    }
    //
    var response interface{} = this.SafeValue(message, "response", map[string]interface{} {})
    var markets interface{} = this.ParseMarkets(response)
    var messageHash interface{} = this.SafeString(message, "requestId")
    client.(ccxt.ClientInterface).Resolve(markets, messageHash)
}
func  (this *BitvavoCore) BuildMessageHash(action interface{}, optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var methods interface{} = map[string]interface{} {
        "privateCreateOrder": this.ActionAndMarketMessageHash,
        "privateUpdateOrder": this.ActionAndOrderIdMessageHash,
        "privateCancelOrder": this.ActionAndOrderIdMessageHash,
        "privateGetOrder": this.ActionAndOrderIdMessageHash,
        "privateGetTrades": this.ActionAndMarketMessageHash,
    }
    var method interface{} = this.SafeValue(methods, action)
    var messageHash interface{} = action
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        messageHash = ccxt.CallDynamically(method, action, params)
    }
    return messageHash
}
func  (this *BitvavoCore) ActionAndMarketMessageHash(action interface{}, optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var symbol interface{} = this.SafeString(params, "market", "")
    return ccxt.Add(action, symbol)
}
func  (this *BitvavoCore) ActionAndOrderIdMessageHash(action interface{}, optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var orderId interface{} = this.SafeString(params, "orderId")
    if ccxt.IsTrue(ccxt.IsEqual(orderId, nil)) {
        panic(ccxt.ExchangeError(ccxt.Add(this.Id, " privateUpdateOrderMessageHash requires a orderId parameter")))
    }
    return ccxt.Add(action, orderId)
}
func  (this *BitvavoCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "order",
    //         "orderId": "f0e5180f-9497-4d05-9dc2-7056e8a2de9b",
    //         "market": "ETH-EUR",
    //         "created": 1590948500319,
    //         "updated": 1590948500319,
    //         "status": "new",
    //         "side": "sell",
    //         "orderType": "limit",
    //         "amount": "0.1",
    //         "amountRemaining": "0.1",
    //         "price": "300",
    //         "onHold": "0.1",
    //         "onHoldCurrency": "ETH",
    //         "selfTradePrevention": "decrementAndCancel",
    //         "visible": true,
    //         "timeInForce": "GTC",
    //         "postOnly": false
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("order:", symbol)
    var order interface{} = this.ParseOrder(message, market)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(order)
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *BitvavoCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "fill",
    //         "timestamp": 1590964470132,
    //         "market": "ETH-EUR",
    //         "orderId": "85d082e1-eda4-4209-9580-248281a29a9a",
    //         "fillId": "861d2da5-aa93-475c-8d9a-dce431bd4211",
    //         "side": "sell",
    //         "amount": "0.1",
    //         "price": "211.46",
    //         "taker": true,
    //         "fee": "0.056",
    //         "feeCurrency": "EUR"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("myTrades:", symbol)
    var trade interface{} = this.ParseTrade(message, market)
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCache(limit)
    }
    var tradesArray interface{} = this.MyTrades
    tradesArray.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
func  (this *BitvavoCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "event": "subscribed",
    //         "subscriptions": {
    //             "book": [ "BTC-EUR" ]
    //         }
    //     }
    //
    var subscriptions interface{} = this.SafeValue(message, "subscriptions", map[string]interface{} {})
    var methods interface{} = map[string]interface{} {
        "book": this.HandleOrderBookSubscriptions,
    }
    var names interface{} = ccxt.ObjectKeys(subscriptions)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(names)); i++ {
        var name interface{} = ccxt.GetValue(names, i)
        var method interface{} = this.SafeValue(methods, name)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            var subscription interface{} = this.SafeValue(subscriptions, name)
            ccxt.CallDynamically(method, client, message, subscription)
        }
    }
    return message
}
func  (this *BitvavoCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                var timestamp interface{} = this.Milliseconds()
                var stringTimestamp interface{} = ccxt.ToString(timestamp)
                var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(stringTimestamp, "GET/"), this.Version), "/websocket")
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
                var action interface{} = "authenticate"
                var request interface{} = map[string]interface{} {
                    "action": action,
                    "key": this.ApiKey,
                    "signature": signature,
                    "timestamp": timestamp,
                }
                var message interface{} = this.Extend(request, params)
                
            future = (<-this.Watch(url, messageHash, message, messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }
func  (this *BitvavoCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "authenticate",
    //         "authenticated": true
    //     }
    //
    var messageHash interface{} = "authenticated"
    var authenticated interface{} = this.SafeBool(message, "authenticated", false)
    if ccxt.IsTrue(authenticated) {
        // we resolve the future here permanently so authentication only happens once
        client.(ccxt.ClientInterface).Resolve(message, messageHash)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        // allows further authentication attempts
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
func  (this *BitvavoCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        action: 'privateCreateOrder',
    //        market: 'BTC-EUR',
    //        errorCode: 217,
    //        error: 'Minimum order size in quote currency is 5 EUR or 0.001 BTC.'
    //    }
    //    {
    //        action: 'privateCreateOrder',
    //        requestId: '17317539426571916',
    //        market: 'USDT-EUR',
    //        errorCode: 216,
    //        error: 'You do not have sufficient balance to complete this operation.'
    //    }
    //
    var error interface{} = this.SafeString(message, "error")
    var code interface{} = this.SafeInteger(error, "errorCode")
    var action interface{} = this.SafeString(message, "action")
    var buildMessage interface{} = this.BuildMessageHash(action, message)
    var messageHash interface{} = this.SafeString(message, "requestId", buildMessage)
    var rejected interface{} = false
    
        {
             func(this *BitvavoCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BitvavoCore) interface{} {
                            // catch block:
                                    rejected = true
            client.(ccxt.ClientInterface).Reject(e, messageHash)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        this.HandleErrors(code, error, client.(ccxt.ClientInterface).GetUrl(), "", map[string]interface{} {}, error, message, map[string]interface{} {}, map[string]interface{} {})
    		    return nil
    	    }(this)
        
            }
    if !ccxt.IsTrue(rejected) {
        client.(ccxt.ClientInterface).Reject(message, messageHash)
        return true
    }
    return nil
}
func  (this *BitvavoCore) HandleMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "subscribed",
    //         "subscriptions": {
    //             "book": [ "BTC-EUR" ]
    //         }
    //     }
    //
    //     {
    //         "event": "book",
    //         "market": "BTC-EUR",
    //         "nonce": 36729561,
    //         "bids": [
    //             [ "8513.3", "0" ],
    //             [ '8518.8', "0.64236203" ],
    //             [ '8513.6', "0.32435481" ],
    //         ],
    //         "asks": []
    //     }
    //
    //     {
    //         "action": "getBook",
    //         "response": {
    //             "market": "BTC-EUR",
    //             "nonce": 36946120,
    //             "bids": [
    //                 [ '8494.9', "0.24399521" ],
    //                 [ '8494.8', "0.34884085" ],
    //                 [ '8493.9', "0.14535128" ],
    //             ],
    //             "asks": [
    //                 [ "8495", "0.46982463" ],
    //                 [ '8495.1', "0.12178267" ],
    //                 [ '8496.2', "0.21924143" ],
    //             ]
    //         }
    //     }
    //
    //     {
    //         "event": "authenticate",
    //         "authenticated": true
    //     }
    //
    var error interface{} = this.SafeString(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        this.HandleErrorMessage(client, message)
    }
    var methods interface{} = map[string]interface{} {
        "subscribed": this.HandleSubscriptionStatus,
        "book": this.HandleOrderBook,
        "getBook": this.HandleOrderBookSnapshot,
        "trade": this.HandleTrade,
        "candle": this.HandleOHLCV,
        "ticker24h": this.HandleTicker,
        "authenticate": this.HandleAuthenticationMessage,
        "order": this.HandleOrder,
        "fill": this.HandleMyTrade,
        "privateCreateOrder": this.HandleSingleOrder,
        "privateUpdateOrder": this.HandleSingleOrder,
        "privateGetBalance": this.HandleFetchBalance,
        "privateCancelOrders": this.HandleMultipleOrders,
        "privateGetOrders": this.HandleMultipleOrders,
        "privateGetOrder": this.HandleSingleOrder,
        "privateCancelOrder": this.HandleSingleOrder,
        "privateGetOrdersOpen": this.HandleMultipleOrders,
        "privateGetAccount": this.HandleTradingFees,
        "privateGetDepositHistory": this.HandleDeposits,
        "privateGetWithdrawalHistory": this.HandleWithdraws,
        "privateWithdrawAssets": this.HandleWithdraw,
        "privateGetTrades": this.HandleMyTrades,
        "getAssets": this.HandleFetchCurrencies,
        "getCandles": this.HandleFetchOHLCV,
        "getMarkets": this.HandleMarkets,
    }
    var event interface{} = this.SafeString(message, "event")
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
        var action interface{} = this.SafeString(message, "action")
        method = this.SafeValue(methods, action)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    } else {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *BitvavoCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
