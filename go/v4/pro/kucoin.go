package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type KucoinCore struct {
	*ccxt.KucoinCore
	base *ccxt.KucoinCore
}

func NewKucoinCore() *KucoinCore {
    p := &KucoinCore{}
	base := &ccxt.KucoinCore{}
	p.base = base
	p.KucoinCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *KucoinCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "watchBidsAsks": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchTickers": true,
            "watchTicker": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBookForSymbols": true,
            "watchBalance": true,
            "watchOHLCV": true,
            "unWatchTicker": true,
            "unWatchOHLCV": true,
            "unWatchOrderBook": true,
            "unWatchTrades": true,
            "unWatchhTradesForSymbols": true,
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "watchTicker": map[string]interface{} {
                "name": "market/snapshot",
            },
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 5,
                "snapshotMaxRetries": 3,
                "method": "/market/level2",
            },
            "watchMyTrades": map[string]interface{} {
                "method": "/spotMarket/tradeOrders",
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
    })
}
func  (this *KucoinCore) Negotiate(privateChannel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var connectId interface{} = ccxt.Ternary(ccxt.IsTrue(privateChannel), "private", "public")
            var urls interface{} = this.SafeValue(this.Options, "urls", map[string]interface{} {})
            var future interface{} = this.SafeValue(urls, connectId)
            if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        
                    retRes6819 := <- future.(*ccxt.Future).Await()
                    ccxt.PanicOnError(retRes6819)
                    ch <- retRes6819
                    return nil
            }
            // we store an awaitable to the url
            // so that multiple calls don't asynchronously
            // fetch different urls and overwrite each other
            ccxt.AddElementToObject(urls, connectId, this.Spawn(this.NegotiateHelper, privateChannel, params))
            ccxt.AddElementToObject(this.Options, "urls", urls)
            future = ccxt.GetValue(urls, connectId)
        
                retRes7615 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes7615)
                ch <- retRes7615
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) NegotiateHelper(privateChannel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var response interface{} = nil
            var connectId interface{} = ccxt.Ternary(ccxt.IsTrue(privateChannel), "private", "public")
            
                {
                     func(this *KucoinCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *KucoinCore) interface{} {
                                    // catch block:
                                            var future interface{} = this.SafeValue(ccxt.GetValue(this.Options, "urls"), connectId)
                    future.(*ccxt.Future).Reject(e)
                    ccxt.Remove(ccxt.GetValue(this.Options, "urls"), connectId)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                if ccxt.IsTrue(privateChannel) {
                        
                response = (<-this.PrivatePostBulletPrivate(params))
                            ccxt.PanicOnError(response)
                    } else {
                        
                response = (<-this.PublicPostBulletPublic(params))
                            ccxt.PanicOnError(response)
                    }
                    var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                    var instanceServers interface{} = this.SafeValue(data, "instanceServers", []interface{}{})
                    var firstInstanceServer interface{} = this.SafeValue(instanceServers, 0)
                    var pingInterval interface{} = this.SafeInteger(firstInstanceServer, "pingInterval")
                    var endpoint interface{} = this.SafeString(firstInstanceServer, "endpoint")
                    var token interface{} = this.SafeString(data, "token")
                    var result interface{} = ccxt.Add(ccxt.Add(endpoint, "?"), this.Urlencode(map[string]interface{} {
                "token": token,
                "privateChannel": privateChannel,
                "connectId": connectId,
            }))
                    var client interface{} = this.Client(result)
                    client.(ccxt.ClientInterface).SetKeepAlive(pingInterval)
            
                    ch <- result
                    return nil
            		    
            	    }(this)
                
                    }
        
            return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) RequestId() interface{}  {
    this.LockId()
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    this.UnlockId()
    return requestId
}
func  (this *KucoinCore) Subscribe(url interface{}, messageHash interface{}, subscriptionHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": subscriptionHash,
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
            var client interface{} = this.Client(url)
            if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash))) {
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), requestId, subscriptionHash)
            }
        
                retRes14815 :=  (<-this.Watch(url, messageHash, message, subscriptionHash, subscription))
                ccxt.PanicOnError(retRes14815)
                ch <- retRes14815
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) UnSubscribe(url interface{}, messageHash interface{}, topic interface{}, subscriptionHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
        
                retRes15215 :=  (<-this.UnSubscribeMultiple(url, []interface{}{messageHash}, topic, []interface{}{subscriptionHash}, params, subscription))
                ccxt.PanicOnError(retRes15215)
                ch <- retRes15215
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) SubscribeMultiple(url interface{}, messageHashes interface{}, topic interface{}, subscriptionHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": topic,
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
            var client interface{} = this.Client(url)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionHashes)); i++ {
                var subscriptionHash interface{} = ccxt.GetValue(subscriptionHashes, i)
                if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash))) {
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), requestId, subscriptionHash)
                }
            }
        
                retRes17115 :=  (<-this.WatchMultiple(url, messageHashes, message, subscriptionHashes, subscription))
                ccxt.PanicOnError(retRes17115)
                ch <- retRes17115
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) UnSubscribeMultiple(url interface{}, messageHashes interface{}, topic interface{}, subscriptionHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "unsubscribe",
                "topic": topic,
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
            if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                ccxt.AddElementToObject(subscription, requestId, requestId)
            }
            var client interface{} = this.Client(url)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionHashes)); i++ {
                var subscriptionHash interface{} = ccxt.GetValue(subscriptionHashes, i)
                if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash))) {
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), requestId, subscriptionHash)
                }
            }
        
                retRes19315 :=  (<-this.WatchMultiple(url, messageHashes, message, subscriptionHashes, subscription))
                ccxt.PanicOnError(retRes19315)
                ch <- retRes19315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/market-snapshot
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KucoinCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2068)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            methodqueryVariable := this.HandleOptionAndParams(params, "watchTicker", "method", "/market/snapshot")
            method := ccxt.GetValue(methodqueryVariable,0)
            query := ccxt.GetValue(methodqueryVariable,1)
            var topic interface{} = ccxt.Add(ccxt.Add(method, ":"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
        
                retRes21315 :=  (<-this.Subscribe(url, messageHash, topic, query))
                ccxt.PanicOnError(retRes21315)
                ch <- retRes21315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/market-snapshot
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KucoinCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2268)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchTicker", "method", "/market/snapshot")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var topic interface{} = ccxt.Add(ccxt.Add(method, ":"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", symbol)
            var subMessageHash interface{} = ccxt.Add("ticker:", symbol)
            var subscription interface{} = map[string]interface{} {
                "messageHashes": []interface{}{messageHash},
                "subMessageHashes": []interface{}{subMessageHash},
                "topic": "trades",
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
            }
        
                retRes24215 :=  (<-this.UnSubscribe(url, messageHash, topic, subMessageHash, params, subscription))
                ccxt.PanicOnError(retRes24215)
                ch <- retRes24215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#watchTickers
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/snapshot' or '/market/ticker' default is '/market/ticker'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KucoinCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2568)
            symbols = this.MarketSymbols(symbols)
            var messageHash interface{} = "tickers"
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "method", "/market/ticker")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
                    var market interface{} = this.Market(symbol)
                    ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(method, ":"), ccxt.GetValue(market, "id")))
                }
            }
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var tickers interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                var allTopic interface{} = ccxt.Add(method, ":all")
                
            tickers = (<-this.Subscribe(url, messageHash, allTopic, params))
                    ccxt.PanicOnError(tickers)
                if ccxt.IsTrue(this.NewUpdates) {
        
                    ch <- tickers
                    return nil
                }
            } else {
                var marketIds interface{} = this.MarketIds(symbols)
                var symbolsTopic interface{} = ccxt.Add(ccxt.Add(method, ":"), ccxt.Join(marketIds, ","))
                
            tickers = (<-this.SubscribeMultiple(url, messageHashes, symbolsTopic, topics, params))
                    ccxt.PanicOnError(tickers)
                if ccxt.IsTrue(this.NewUpdates) {
                    var newDict interface{} = map[string]interface{} {}
                    ccxt.AddElementToObject(newDict, ccxt.GetValue(tickers, "symbol"), tickers)
        
                    ch <- newDict
                    return nil
                }
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleTicker(client interface{}, message interface{})  {
    //
    // market/snapshot
    //
    // updates come in every 2 sec unless there
    // were no changes since the previous update
    //
    //     {
    //         "data": {
    //             "sequence": "1545896669291",
    //             "data": {
    //                 "trading": true,
    //                 "symbol": "KCS-BTC",
    //                 "buy": 0.00011,
    //                 "sell": 0.00012,
    //                 "sort": 100,
    //                 "volValue": 3.13851792584, // total
    //                 "baseCurrency": "KCS",
    //                 "market": "BTC",
    //                 "quoteCurrency": "BTC",
    //                 "symbolCode": "KCS-BTC",
    //                 "datetime": 1548388122031,
    //                 "high": 0.00013,
    //                 "vol": 27514.34842,
    //                 "low": 0.0001,
    //                 "changePrice": -1.0e-5,
    //                 "changeRate": -0.0769,
    //                 "lastTradedPrice": 0.00012,
    //                 "board": 0,
    //                 "mark": 0
    //             }
    //         },
    //         "subject": "trade.snapshot",
    //         "topic": "/market/snapshot:KCS-BTC",
    //         "type": "message"
    //     }
    //
    // market/ticker
    //
    //     {
    //         "type": "message",
    //         "topic": "/market/ticker:BTC-USDT",
    //         "subject": "trade.ticker",
    //         "data": {
    //             "bestAsk": "62163",
    //             "bestAskSize": "0.99011388",
    //             "bestBid": "62162.9",
    //             "bestBidSize": "0.04794181",
    //             "price": "62162.9",
    //             "sequence": "1621383371852",
    //             "size": "0.00832274",
    //             "time": 1634641987564
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var market interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        var parts interface{} = ccxt.Split(topic, ":")
        var first interface{} = this.SafeString(parts, 1)
        var marketId interface{} = nil
        if ccxt.IsTrue(ccxt.IsEqual(first, "all")) {
            marketId = this.SafeString(message, "subject")
        } else {
            marketId = first
        }
        market = this.SafeMarket(marketId, market, "-")
    }
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var rawTicker interface{} = this.SafeValue(data, "data", data)
    var ticker interface{} = this.ParseTicker(rawTicker, market)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    // watchTickers
    var allTickers interface{} = map[string]interface{} {}
    ccxt.AddElementToObject(allTickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(allTickers, "tickers")
}
/**
 * @method
 * @name kucoin#watchBidsAsks
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KucoinCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            ticker:= (<-this.WatchMultiHelper("watchBidsAsks", "/spotMarket/level1:", symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) WatchMultiHelper(methodName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3938)
            symbols = this.MarketSymbols(symbols, nil, false, true, false)
            var length interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsGreaterThan(length, 100)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() accepts a maximum of 100 symbols")))
            }
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask@", ccxt.GetValue(market, "symbol")))
            }
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var marketIds interface{} = this.MarketIds(symbols)
            var joined interface{} = ccxt.Join(marketIds, ",")
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": ccxt.Add(channelName, joined),
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes41615 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes41615)
                ch <- retRes41615
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    // arrives one symbol dict
    //
    //     {
    //         topic: '/spotMarket/level1:ETH-USDT',
    //         type: 'message',
    //         data: {
    //             asks: [ '3347.42', '2.0778387' ],
    //             bids: [ '3347.41', '6.0411697' ],
    //             timestamp: 1712231142085
    //         },
    //         subject: 'level1'
    //     }
    //
    var parsedTicker interface{} = this.ParseWsBidAsk(message)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask@", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *KucoinCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var topic interface{} = this.SafeString(ticker, "topic")
    var parts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = ccxt.GetValue(parts, 1)
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var data interface{} = this.SafeDict(ticker, "data", map[string]interface{} {})
    var ask interface{} = this.SafeList(data, "asks", []interface{}{})
    var bid interface{} = this.SafeList(data, "bids", []interface{}{})
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(ask, 0),
        "askVolume": this.SafeNumber(ask, 1),
        "bid": this.SafeNumber(bid, 0),
        "bidVolume": this.SafeNumber(bid, 1),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name kucoin#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/klines
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *KucoinCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4768)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var period interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("/market/candles:", ccxt.GetValue(market, "id")), "_"), period)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
        
            ohlcv:= (<-this.Subscribe(url, messageHash, topic, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/klines
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *KucoinCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5018)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var period interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("/market/candles:", ccxt.GetValue(market, "id")), "_"), period)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:candles:", symbol), ":"), timeframe)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
            var subscription interface{} = map[string]interface{} {
                "messageHashes": []interface{}{messageHash},
                "subMessageHashes": []interface{}{subMessageHash},
                "topic": "ohlcv",
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
            }
        
                retRes51615 :=  (<-this.UnSubscribe(url, messageHash, topic, messageHash, params, subscription))
                ccxt.PanicOnError(retRes51615)
                ch <- retRes51615
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "symbol": "BTC-USDT",
    //             "candles": [
    //                 "1624881240",
    //                 "34138.8",
    //                 "34121.6",
    //                 "34138.8",
    //                 "34097.9",
    //                 "3.06097133",
    //                 "104430.955068564"
    //             ],
    //             "time": 1624881284466023700
    //         },
    //         "subject": "trade.candles.update",
    //         "topic": "/market/candles:BTC-USDT_1min",
    //         "type": "message"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var candles interface{} = this.SafeValue(data, "candles", []interface{}{})
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, "_")
    var interval interface{} = this.SafeString(parts, 1)
    // use a reverse lookup in a static map instead
    var timeframe interface{} = this.FindTimeframe(interval)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcv interface{} = this.ParseOHLCV(candles, market)
    stored.(ccxt.Appender).Append(ohlcv)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name kucoin#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/match-execution-data
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KucoinCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes57515 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes57515)
                ch <- retRes57515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/match-execution-data
 * @param {string[]} symbols
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KucoinCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes5948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5948)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var messageHashes interface{} = []interface{}{}
            var subscriptionHashes interface{} = []interface{}{}
            var topic interface{} = ccxt.Add("/market/match:", ccxt.Join(marketIds, ","))
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", symbol))
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("/market/match:", marketId))
            }
        
            trades:= (<-this.SubscribeMultiple(url, messageHashes, topic, subscriptionHashes, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchTradesForSymbols
 * @description unWatches trades stream
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/match-execution-data
 * @param {string} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KucoinCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6268)
            symbols = this.MarketSymbols(symbols, nil, false)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var messageHashes interface{} = []interface{}{}
            var subscriptionHashes interface{} = []interface{}{}
            var topic interface{} = ccxt.Add("/market/match:", ccxt.Join(marketIds, ","))
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trades:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("trades:", symbol))
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": messageHashes,
                "subMessageHashes": subscriptionHashes,
                "topic": "trades",
                "unsubscribe": true,
                "symbols": symbols,
            }
        
                retRes64515 :=  (<-this.UnSubscribeMultiple(url, messageHashes, topic, messageHashes, params, subscription))
                ccxt.PanicOnError(retRes64515)
                ch <- retRes64515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchTrades
 * @description unWatches trades stream
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/match-execution-data
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KucoinCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes65815 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes65815)
                ch <- retRes65815
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "sequence": "1568787654360",
    //             "symbol": "BTC-USDT",
    //             "side": "buy",
    //             "size": "0.00536577",
    //             "price": "9345",
    //             "takerOrderId": "5e356c4a9f1a790008f8d921",
    //             "time": "1580559434436443257",
    //             "type": "match",
    //             "makerOrderId": "5e356bffedf0010008fa5d7f",
    //             "tradeId": "5e356c4aeefabd62c62a1ece"
    //         },
    //         "subject": "trade.l3match",
    //         "topic": "/market/match:BTC-USDT",
    //         "type": "message"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var trade interface{} = this.ParseTrade(data)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var trades interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        trades = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, trades)
    }
    trades.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name kucoin#watchOrderBook
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            // https://docs.kucoin.com/#level-2-market-data
            //
            // 1. After receiving the websocket Level 2 data flow, cache the data.
            // 2. Initiate a REST request to get the snapshot data of Level 2 order book.
            // 3. Playback the cached Level 2 data flow.
            // 4. Apply the new Level 2 data flow to the local snapshot to ensure that
            // the sequence of the new Level 2 update lines up with the sequence of
            // the previous Level 2 data. Discard all the message prior to that
            // sequence, and then playback the change to snapshot.
            // 5. Update the level2 full data based on sequence according to the
            // size. If the price is 0, ignore the messages and update the sequence.
            // If the size=0, update the sequence and remove the price of which the
            // size is 0 out of level 2. Fr other cases, please update the price.
            //
            limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes72515 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes72515)
        ch <- retRes72515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchOrderBook
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes74215 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes74215)
                ch <- retRes74215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#watchOrderBookForSymbols
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(limit, 20))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 100)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 50)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 5)))) {
                    panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook \\'limit\\' argument must be undefined, 5, 20, 50 or 100")))
                }
            }
        
            retRes7698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7698)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "method", "/market/level2")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, 5))) || ccxt.IsTrue((ccxt.IsEqual(limit, 50)))) {
                method = ccxt.Add("/spotMarket/level2Depth", ccxt.ToString(limit))
            }
            var topic interface{} = ccxt.Add(ccxt.Add(method, ":"), ccxt.Join(marketIds, ","))
            var messageHashes interface{} = []interface{}{}
            var subscriptionHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add(ccxt.Add(method, ":"), marketId))
            }
            var subscription interface{} = map[string]interface{} {}
            if ccxt.IsTrue(ccxt.IsEqual(method, "/market/level2")) {
                subscription = map[string]interface{} {
                    "method": this.HandleOrderBookSubscription,
                    "symbols": symbols,
                    "limit": limit,
                }
            }
        
            orderbook:= (<-this.SubscribeMultiple(url, messageHashes, topic, subscriptionHashes, params, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#unWatchOrderBookForSymbols
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level1-bbo-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-market-data
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-5-best-ask-bid-orders
 * @see https://www.kucoin.com/docs/websocket/spot-trading/public-channels/level2-50-best-ask-bid-orders
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var limit interface{} = this.SafeInteger(params, "limit")
            params = this.Omit(params, "limit")
        
            retRes8158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8158)
            symbols = this.MarketSymbols(symbols, nil, false)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "method", "/market/level2")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, 5))) || ccxt.IsTrue((ccxt.IsEqual(limit, 50)))) {
                method = ccxt.Add("/spotMarket/level2Depth", ccxt.ToString(limit))
            }
            var topic interface{} = ccxt.Add(ccxt.Add(method, ":"), ccxt.Join(marketIds, ","))
            var messageHashes interface{} = []interface{}{}
            var subscriptionHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("orderbook:", symbol))
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": messageHashes,
                "symbols": symbols,
                "unsubscribe": true,
                "topic": "orderbook",
                "subMessageHashes": subscriptionHashes,
            }
        
                retRes83915 :=  (<-this.UnSubscribeMultiple(url, messageHashes, topic, messageHashes, params, subscription))
                ccxt.PanicOnError(retRes83915)
                ch <- retRes83915
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //     {
    //         "type":"message",
    //         "topic":"/market/level2:BTC-USDT",
    //         "subject":"trade.l2update",
    //         "data":{
    //             "sequenceStart":1545896669105,
    //             "sequenceEnd":1545896669106,
    //             "symbol":"BTC-USDT",
    //             "changes": {
    //                 "asks": [["6","1","1545896669105"]], // price, size, sequence
    //                 "bids": [["4","1","1545896669106"]]
    //             }
    //         }
    //     }
    //
    //     {
    //         "topic": "/spotMarket/level2Depth5:BTC-USDT",
    //         "type": "message",
    //         "data": {
    //             "asks": [
    //                 [
    //                     "42815.6",
    //                     "1.24016245"
    //                 ]
    //             ],
    //             "bids": [
    //                 [
    //                     "42815.5",
    //                     "0.08652716"
    //                 ]
    //             ],
    //             "timestamp": 1707204474018
    //         },
    //         "subject": "level2"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data")
    var subject interface{} = this.SafeString(message, "subject")
    var topic interface{} = this.SafeString(message, "topic")
    var topicParts interface{} = ccxt.Split(topic, ":")
    var topicSymbol interface{} = this.SafeString(topicParts, 1)
    var topicChannel interface{} = this.SafeString(topicParts, 0)
    var marketId interface{} = this.SafeString(data, "symbol", topicSymbol)
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    // let orderbook = this.safeDict (this.orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(subject, "level2")) {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
        } else {
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            orderbook.(ccxt.OrderBookInterface).Reset()
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Orderbooks, symbol), "symbol", symbol)
    } else {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var nonce interface{} = this.SafeInteger(orderbook, "nonce")
        var deltaEnd interface{} = this.SafeInteger2(data, "sequenceEnd", "timestamp")
        if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
            var cacheLength interface{} =             ccxt.GetArrayLength(orderbook.(ccxt.OrderBookInterface).GetCache())
            var subscriptions interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
            var subscription interface{} = nil
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
                var key interface{} = ccxt.GetValue(subscriptions, i)
                if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(key, topicSymbol), 0))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(key, topicChannel), 0)))) {
                    subscription = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), key)
                    break
                }
            }
            var limit interface{} = this.SafeInteger(subscription, "limit")
            var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 5)
            if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
                this.Spawn(this.LoadOrderBook, client, messageHash, symbol, limit, map[string]interface{} {})
            }
            ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), data)
            return
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(nonce, deltaEnd)) {
            return
        }
    }
    this.HandleDelta(ccxt.GetValue(this.Orderbooks, symbol), data)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
}
func  (this *KucoinCore) GetCacheIndex(orderbook interface{}, cache interface{}) interface{}  {
    var firstDelta interface{} = this.SafeValue(cache, 0)
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    var firstDeltaStart interface{} = this.SafeInteger(firstDelta, "sequenceStart")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(firstDeltaStart, 1))) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaStart interface{} = this.SafeInteger(delta, "sequenceStart")
        var deltaEnd interface{} = this.SafeInteger(delta, "sequenceEnd")
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(nonce, ccxt.Subtract(deltaStart, 1)))) && ccxt.IsTrue((ccxt.IsLessThan(nonce, deltaEnd)))) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
func  (this *KucoinCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var timestamp interface{} = this.SafeInteger2(delta, "time", "timestamp")
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(delta, "sequenceEnd", timestamp))
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var changes interface{} = this.SafeValue(delta, "changes", delta)
    var bids interface{} = this.SafeValue(changes, "bids", []interface{}{})
    var asks interface{} = this.SafeValue(changes, "asks", []interface{}{})
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    this.HandleBidAsks(storedBids, bids)
    this.HandleBidAsks(storedAsks, asks)
}
func  (this *KucoinCore) HandleBidAsks(bookSide interface{}, bidAsks interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidAsks)); i++ {
        var bidAsk interface{} = this.ParseBidAsk(ccxt.GetValue(bidAsks, i))
        bookSide.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    }
}
func  (this *KucoinCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var limit interface{} = this.SafeInteger(subscription, "limit")
    var symbols interface{} = this.SafeValue(subscription, "symbols")
    if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
        var symbol interface{} = this.SafeString(subscription, "symbol")
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    } else {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
            var symbol interface{} = ccxt.GetValue(symbols, i)
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
    }
}
func  (this *KucoinCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "id": "1578090438322",
    //         "type": "ack"
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id))) {
        return
    }
    var subscriptionHash interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var method interface{} = this.SafeValue(subscription, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message, subscription)
    }
    var isUnSub interface{} = this.SafeBool(subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSub) {
        var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
        var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
            var messageHash interface{} = ccxt.GetValue(messageHashes, i)
            var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
            this.CleanUnsubscription(client.(*ccxt.Client), subHash, messageHash)
        }
        this.CleanCache(subscription)
    }
}
func  (this *KucoinCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "id": "1578090234088", // connectId
    //         "type": "welcome",
    //     }
    //
    return message
}
/**
 * @method
 * @name kucoin#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.kucoin.com/docs/websocket/spot-trading/private-channels/private-order-change
 * @see https://www.kucoin.com/docs/websocket/spot-trading/private-channels/stop-order-event
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] trigger orders are watched if true
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KucoinCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10508)
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var topic interface{} = ccxt.Ternary(ccxt.IsTrue(trigger), "/spotMarket/advancedOrders", "/spotMarket/tradeOrders")
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.Subscribe(url, messageHash, topic, this.Extend(request, params)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "open": "open",
        "filled": "closed",
        "match": "open",
        "update": "open",
        "canceled": "canceled",
        "cancel": "canceled",
        "TRIGGERED": "triggered",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *KucoinCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // /spotMarket/tradeOrders
    //
    //    {
    //        "symbol": "XCAD-USDT",
    //        "orderType": "limit",
    //        "side": "buy",
    //        "orderId": "6249167327218b000135e749",
    //        "type": "canceled",
    //        "orderTime": 1648957043065280224,
    //        "size": "100.452",
    //        "filledSize": "0",
    //        "price": "2.9635",
    //        "clientOid": "buy-XCAD-USDT-1648957043010159",
    //        "remainSize": "0",
    //        "status": "done",
    //        "ts": 1648957054031001037
    //    }
    //
    // /spotMarket/advancedOrders
    //
    //    {
    //        "createdAt": 1589789942337,
    //        "orderId": "5ec244f6a8a75e0009958237",
    //        "orderPrice": "0.00062",
    //        "orderType": "stop",
    //        "side": "sell",
    //        "size": "1",
    //        "stop": "entry",
    //        "stopPrice": "0.00062",
    //        "symbol": "KCS-BTC",
    //        "tradeType": "TRADE",
    //        "triggerSuccess": true,
    //        "ts": 1589790121382281286,
    //        "type": "triggered"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var rawType interface{} = this.SafeString(order, "type")
    var status interface{} = this.ParseWsOrderStatus(rawType)
    var timestamp interface{} = this.SafeInteger2(order, "orderTime", "createdAt")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var triggerPrice interface{} = this.SafeString(order, "stopPrice")
    var triggerSuccess interface{} = this.SafeValue(order, "triggerSuccess")
    var triggerFail interface{} = ccxt.IsTrue((!ccxt.IsEqual(triggerSuccess, true))) && ccxt.IsTrue((!ccxt.IsEqual(triggerSuccess, nil))) // TODO: updated to triggerSuccess === False once transpiler transpiles it correctly
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(status, "triggered"))) && ccxt.IsTrue(triggerFail)) {
        status = "canceled"
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": this.SafeString(order, "clientOid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": this.SafeStringLower(order, "orderType"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeStringLower(order, "side"),
        "price": this.SafeString2(order, "price", "orderPrice"),
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "amount": this.SafeString(order, "size"),
        "cost": nil,
        "average": nil,
        "filled": this.SafeString(order, "filledSize"),
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *KucoinCore) HandleOrder(client interface{}, message interface{})  {
    //
    // Trigger Orders
    //
    //    {
    //        "createdAt": 1692745706437,
    //        "error": "ccxt.Balance insufficient!",       // not always there
    //        "orderId": "vs86kp757vlda6ni003qs70v",
    //        "orderPrice": "0.26",
    //        "orderType": "stop",
    //        "side": "sell",
    //        "size": "5",
    //        "stop": "loss",
    //        "stopPrice": "0.26",
    //        "symbol": "ADA-USDT",
    //        "tradeType": "TRADE",
    //        "triggerSuccess": false,                // not always there
    //        "ts": "1692745706442929298",
    //        "type": "open"
    //    }
    //
    var messageHash interface{} = "orders"
    var data interface{} = this.SafeValue(message, "data")
    var tradeId interface{} = this.SafeString(data, "tradeId")
    if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
        this.HandleMyTrade(client, message)
    }
    var parsed interface{} = this.ParseWsOrder(data)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    var triggerPrice interface{} = this.SafeValue(parsed, "triggerPrice")
    var isTriggerOrder interface{} =     (!ccxt.IsEqual(triggerPrice, nil))
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.TriggerOrders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedOrders interface{} = ccxt.Ternary(ccxt.IsTrue(isTriggerOrder), this.TriggerOrders, this.Orders)
    var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
    var order interface{} = this.SafeValue(orders, orderId)
    if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
        // todo add others to calculate average etc
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(order, "status"), "closed")) {
            ccxt.AddElementToObject(parsed, "status", "closed")
        }
    }
    cachedOrders.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(cachedOrders, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(cachedOrders, symbolSpecificMessageHash)
}
/**
 * @method
 * @name kucoin#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://www.kucoin.com/docs/websocket/spot-trading/private-channels/private-order-change
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] '/spotMarket/tradeOrders' or '/spot/tradeFills' default is '/spotMarket/tradeOrders'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *KucoinCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12248 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12248)
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var topic interface{} = nil
            topicparamsVariable := this.HandleOptionAndParams(params, "watchMyTrades", "method", "/spotMarket/tradeOrders")
            topic = ccxt.GetValue(topicparamsVariable,0)
            params = ccxt.GetValue(topicparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(market, "symbol"))
            }
        
            trades:= (<-this.Subscribe(url, messageHash, topic, this.Extend(request, params)))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "message",
    //         "topic": "/spotMarket/tradeOrders",
    //         "subject": "orderChange",
    //         "channelType": "private",
    //         "data": {
    //             "symbol": "KCS-USDT",
    //             "orderType": "limit",
    //             "side": "sell",
    //             "orderId": "5efab07953bdea00089965fa",
    //             "liquidity": "taker",
    //             "type": "match",
    //             "feeType": "takerFee",
    //             "orderTime": 1670329987026,
    //             "size": "0.1",
    //             "filledSize": "0.1",
    //             "price": "0.938",
    //             "matchPrice": "0.96738",
    //             "matchSize": "0.1",
    //             "tradeId": "5efab07a4ee4c7000a82d6d9",
    //             "clientOid": "1593487481000313",
    //             "remainSize": "0",
    //             "status": "match",
    //             "ts": 1670329987311000000
    //         }
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var data interface{} = this.SafeDict(message, "data")
    var parsed interface{} = this.ParseWsTrade(data)
    var myTrades interface{} = this.MyTrades
    myTrades.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(parsed, "symbol"))
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, symbolSpecificMessageHash)
}
func  (this *KucoinCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // /spotMarket/tradeOrders
    //
    //     {
    //         "symbol": "KCS-USDT",
    //         "orderType": "limit",
    //         "side": "sell",
    //         "orderId": "5efab07953bdea00089965fa",
    //         "liquidity": "taker",
    //         "type": "match",
    //         "feeType": "takerFee",
    //         "orderTime": 1670329987026,
    //         "size": "0.1",
    //         "filledSize": "0.1",
    //         "price": "0.938",
    //         "matchPrice": "0.96738",
    //         "matchSize": "0.1",
    //         "tradeId": "5efab07a4ee4c7000a82d6d9",
    //         "clientOid": "1593487481000313",
    //         "remainSize": "0",
    //         "status": "match",
    //         "ts": 1670329987311000000
    //     }
    //
    // /spot/tradeFills
    //
    //    {
    //        "fee": 0.00262148,
    //        "feeCurrency": "USDT",
    //        "feeRate": 0.001,
    //        "orderId": "62417436b29df8000183df2f",
    //        "orderType": "market",
    //        "price": 131.074,
    //        "side": "sell",
    //        "size": 0.02,
    //        "symbol": "LTC-USDT",
    //        "time": "1648456758734571745",
    //        "tradeId": "624174362e113d2f467b3043"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var typeVar interface{} = this.SafeString(trade, "orderType")
    var side interface{} = this.SafeString(trade, "side")
    var tradeId interface{} = this.SafeString(trade, "tradeId")
    var price interface{} = this.SafeString(trade, "matchPrice")
    var amount interface{} = this.SafeString(trade, "matchSize")
    if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
        // /spot/tradeFills
        price = this.SafeString(trade, "price")
        amount = this.SafeString(trade, "size")
    }
    var order interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeIntegerProduct2(trade, "ts", "time", 0.000001)
    var feeCurrency interface{} = ccxt.GetValue(market, "quote")
    var feeRate interface{} = this.SafeString(trade, "feeRate")
    var feeCost interface{} = this.SafeString(trade, "fee")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": tradeId,
        "order": order,
        "type": typeVar,
        "takerOrMaker": this.SafeString(trade, "liquidity"),
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": map[string]interface{} {
            "cost": feeCost,
            "rate": feeRate,
            "currency": feeCurrency,
        },
    }, market)
}
/**
 * @method
 * @name kucoin#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.kucoin.com/docs/websocket/spot-trading/private-channels/account-balance-change
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *KucoinCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13768)
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var topic interface{} = "/account/balance"
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var messageHash interface{} = "balance"
        
                retRes138315 :=  (<-this.Subscribe(url, messageHash, topic, this.Extend(request, params)))
                ccxt.PanicOnError(retRes138315)
                ch <- retRes138315
                return nil
        
            }()
            return ch
        }
func  (this *KucoinCore) HandleBalance(client interface{}, message interface{})  {
    //
    // {
    //     "id":"6217a451294b030001e3a26a",
    //     "type":"message",
    //     "topic":"/account/balance",
    //     "userId":"6217707c52f97f00012a67db",
    //     "channelType":"private",
    //     "subject":"account.balance",
    //     "data":{
    //        "accountId":"62177fe67810720001db2f18",
    //        "available":"89",
    //        "availableChange":"-30",
    //        "currency":"USDT",
    //        "hold":"0",
    //        "holdChange":"0",
    //        "relationContext":{
    //        },
    //        "relationEvent":"main.transfer",
    //        "relationEventId":"6217a451294b030001e3a26a",
    //        "time":"1645716561816",
    //        "total":"89"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var messageHash interface{} = "balance"
    var currencyId interface{} = this.SafeString(data, "currency")
    var relationEvent interface{} = this.SafeString(data, "relationEvent")
    var requestAccountType interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(relationEvent, nil)) {
        var relationEventParts interface{} = ccxt.Split(relationEvent, ".")
        requestAccountType = this.SafeString(relationEventParts, 0)
    }
    var selectedType interface{} = this.SafeString2(this.Options, "watchBalance", "defaultType", "trade") // trade, main, margin or other
    var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType")
    var uniformType interface{} = this.SafeString(accountsByType, requestAccountType, "trade")
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, uniformType))) {
        ccxt.AddElementToObject(this.Balance, uniformType, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, uniformType), "info", data)
    var timestamp interface{} = this.SafeInteger(data, "time")
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, uniformType), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, uniformType), "datetime", this.Iso8601(timestamp))
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(data, "available"))
    ccxt.AddElementToObject(account, "used", this.SafeString(data, "hold"))
    ccxt.AddElementToObject(account, "total", this.SafeString(data, "total"))
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, uniformType), code, account)
    ccxt.AddElementToObject(this.Balance, uniformType, this.SafeBalance(ccxt.GetValue(this.Balance, uniformType)))
    if ccxt.IsTrue(ccxt.IsEqual(uniformType, selectedType)) {
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, uniformType), messageHash)
    }
}
func  (this *KucoinCore) HandleSubject(client interface{}, message interface{})  {
    //
    //     {
    //         "type":"message",
    //         "topic":"/market/level2:BTC-USDT",
    //         "subject":"trade.l2update",
    //         "data":{
    //             "sequenceStart":1545896669105,
    //             "sequenceEnd":1545896669106,
    //             "symbol":"BTC-USDT",
    //             "changes": {
    //                 "asks": [["6","1","1545896669105"]], // price, size, sequence
    //                 "bids": [["4","1","1545896669106"]]
    //             }
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    if ccxt.IsTrue(ccxt.IsEqual(topic, "/market/ticker:all")) {
        this.HandleTicker(client, message)
        return
    }
    var subject interface{} = this.SafeString(message, "subject")
    var methods interface{} = map[string]interface{} {
        "level1": this.HandleBidAsk,
        "level2": this.HandleOrderBook,
        "trade.l2update": this.HandleOrderBook,
        "trade.ticker": this.HandleTicker,
        "trade.snapshot": this.HandleTicker,
        "trade.l3match": this.HandleTrade,
        "trade.candles.update": this.HandleOHLCV,
        "account.balance": this.HandleBalance,
        "orderChange": this.HandleOrder,
        "stopOrder": this.HandleOrder,
        "/spot/tradeFills": this.HandleMyTrade,
    }
    var method interface{} = this.SafeValue(methods, subject)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *KucoinCore) Ping(client interface{}) interface{}  {
    // kucoin does not support built-in ws protocol-level ping-pong
    // instead it requires a custom json-based text ping-pong
    // https://docs.kucoin.com/#ping
    var id interface{} = ccxt.ToString(this.RequestId())
    return map[string]interface{} {
        "id": id,
        "type": "ping",
    }
}
func  (this *KucoinCore) HandlePong(client interface{}, message interface{})  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
}
func  (this *KucoinCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "id": "1",
    //        "type": "error",
    //        "code": 415,
    //        "data": "type is not supported"
    //    }
    //
    var data interface{} = this.SafeString(message, "data", "")
    if ccxt.IsTrue(ccxt.IsEqual(data, "token is expired")) {
        var typeVar interface{} = "public"
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "connectId=private"), 0)) {
            typeVar = "private"
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "urls"), typeVar, nil)
    }
    this.HandleErrors(1, "", client.(ccxt.ClientInterface).GetUrl(), "", map[string]interface{} {}, data, message, map[string]interface{} {}, map[string]interface{} {})
    return false
}
func  (this *KucoinCore) HandleMessage(client interface{}, message interface{})  {
    var typeVar interface{} = this.SafeString(message, "type")
    var methods interface{} = map[string]interface{} {
        "welcome": this.HandleSystemStatus,
        "ack": this.HandleSubscriptionStatus,
        "message": this.HandleSubject,
        "pong": this.HandlePong,
        "error": this.HandleErrorMessage,
    }
    var method interface{} = this.SafeValue(methods, typeVar)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *KucoinCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
