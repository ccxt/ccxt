package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type IndependentreserveCore struct {
	*ccxt.IndependentreserveCore
	base *ccxt.IndependentreserveCore
}

func NewIndependentreserveCore() *IndependentreserveCore {
    p := &IndependentreserveCore{}
	base := &ccxt.IndependentreserveCore{}
	p.base = base
	p.IndependentreserveCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *IndependentreserveCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchTicker": false,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": false,
            "watchOrders": false,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://websockets.independentreserve.com",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "checksum": true,
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name independentreserve#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *IndependentreserveCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes538)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "?subscribe=ticker-"), ccxt.GetValue(market, "base")), "-"), ccxt.GetValue(market, "quote"))
            var messageHash interface{} = ccxt.Add("trades:", symbol)
        
            trades:= (<-this.Watch(url, messageHash, nil, messageHash))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *IndependentreserveCore) HandleTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "Channel": "ticker-btc-usd",
    //        "Nonce": 130,
    //        "Data": {
    //          "TradeGuid": "7a669f2a-d564-472b-8493-6ef982eb1e96",
    //          "Pair": "btc-aud",
    //          "TradeDate": "2023-02-12T10:04:13.0804889+11:00",
    //          "Price": 31640,
    //          "Volume": 0.00079029,
    //          "BidGuid": "ba8a78b5-be69-4d33-92bb-9df0daa6314e",
    //          "OfferGuid": "27d20270-f21f-4c25-9905-152e70b2f6ec",
    //          "Side": "Buy"
    //        },
    //        "Time": 1676156653111,
    //        "Event": "ccxt.Trade"
    //    }
    //
    var data interface{} = this.SafeValue(message, "Data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "Pair")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var trade interface{} = this.ParseWsTrade(data)
    stored.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *IndependentreserveCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "TradeGuid": "2f316718-0d0b-4e33-a30c-c2c06f3cfb34",
    //        "Pair": "xbt-aud",
    //        "TradeDate": "2023-02-12T09:22:35.4207494+11:00",
    //        "Price": 31573.8,
    //        "Volume": 0.05,
    //        "BidGuid": "adb63d74-4c02-47f9-9cc3-f287e3b48ab6",
    //        "OfferGuid": "b94d9bc4-addd-4633-a18f-69cf7e1b6f47",
    //        "Side": "Buy"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(trade, "TradeDate")
    var marketId interface{} = this.SafeString(market, "Pair")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "TradeGuid"),
        "order": this.SafeString(trade, "orderNo"),
        "symbol": this.SafeSymbol(marketId, market, "-"),
        "side": this.SafeStringLower(trade, "Side"),
        "type": nil,
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "Price"),
        "amount": this.SafeString(trade, "Volume"),
        "cost": nil,
        "fee": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
    }, market)
}
/**
 * @method
 * @name independentreserve#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *IndependentreserveCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1398)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 100
            }
            var limitString interface{} = this.NumberToString(limit)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/orderbook/"), limitString), "?subscribe="), ccxt.GetValue(market, "base")), "-"), ccxt.GetValue(market, "quote"))
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook:", symbol), ":"), limitString)
            var subscription interface{} = map[string]interface{} {
                "receivedSnapshot": false,
            }
        
            orderbook:= (<-this.Watch(url, messageHash, nil, messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *IndependentreserveCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "Channel": "orderbook/1/eth/aud",
    //        "Data": {
    //          "ccxt.Bids": [
    //            {
    //              "Price": 2198.09,
    //              "Volume": 0.16143952,
    //            },
    //          ],
    //          "Offers": [
    //            {
    //              "Price": 2201.25,
    //              "Volume": 15,
    //            },
    //          ],
    //          "ccxt.Crc32": 1519697650,
    //        },
    //        "Time": 1676150558254,
    //        "Event": "OrderBookSnapshot",
    //    }
    //
    var event interface{} = this.SafeString(message, "Event")
    var channel interface{} = this.SafeString(message, "Channel")
    var parts interface{} = ccxt.Split(channel, "/")
    var depth interface{} = this.SafeString(parts, 1)
    var baseId interface{} = this.SafeString(parts, 2)
    var quoteId interface{} = this.SafeString(parts, 3)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var orderBook interface{} = this.SafeDict(message, "Data", map[string]interface{} {})
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook:", symbol), ":"), depth)
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
    var receivedSnapshot interface{} = this.SafeBool(subscription, "receivedSnapshot", false)
    var timestamp interface{} = this.SafeInteger(message, "Time")
    // let orderbook = this.safeValue (this.orderbooks, symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(event, "OrderBookSnapshot")) {
        var snapshot interface{} = this.ParseOrderBook(orderBook, symbol, timestamp, "ccxt.Bids", "Offers", "Price", "Volume")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        ccxt.AddElementToObject(subscription, "receivedSnapshot", true)
    } else {
        var asks interface{} = this.SafeList(orderBook, "Offers", []interface{}{})
        var bids interface{} = this.SafeList(orderBook, "ccxt.Bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
    if ccxt.IsTrue(ccxt.IsTrue(checksum) && ccxt.IsTrue(receivedSnapshot)) {
        var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
        var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
        var asksLength interface{} =         ccxt.GetArrayLength(storedAsks)
        var bidsLength interface{} =         ccxt.GetArrayLength(storedBids)
        var payload interface{} = ""
        for i := 0; ccxt.IsLessThan(i, 10); i++ {
            if ccxt.IsTrue(ccxt.IsLessThan(i, bidsLength)) {
                payload = ccxt.Add(ccxt.Add(payload, this.ValueToChecksum(ccxt.GetValue(ccxt.GetValue(storedBids, i), 0))), this.ValueToChecksum(ccxt.GetValue(ccxt.GetValue(storedBids, i), 1)))
            }
        }
        for i := 0; ccxt.IsLessThan(i, 10); i++ {
            if ccxt.IsTrue(ccxt.IsLessThan(i, asksLength)) {
                payload = ccxt.Add(ccxt.Add(payload, this.ValueToChecksum(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 0))), this.ValueToChecksum(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 1)))
            }
        }
        var calculatedChecksum interface{} = this.Crc32(payload, true)
        var responseChecksum interface{} = this.SafeInteger(orderBook, "ccxt.Crc32")
        if ccxt.IsTrue(!ccxt.IsEqual(calculatedChecksum, responseChecksum)) {
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            ccxt.Remove(this.Orderbooks, symbol)
            client.(ccxt.ClientInterface).Reject(error, messageHash)
            return
        }
    }
    if ccxt.IsTrue(receivedSnapshot) {
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *IndependentreserveCore) ValueToChecksum(value interface{}) interface{}  {
    var result interface{} = ccxt.ToFixed(value, 8)
    result = ccxt.Replace(result, ".", "")
    // remove leading zeros
    result = this.ParseNumber(result)
    result = this.NumberToString(result)
    return result
}
func  (this *IndependentreserveCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, "Price", "Volume")
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *IndependentreserveCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *IndependentreserveCore) HandleHeartbeat(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "Time": 1676156208182,
    //        "Event": "Heartbeat"
    //    }
    //
    return message
}
func  (this *IndependentreserveCore) HandleSubscriptions(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "Data": [ "ticker-btc-sgd" ],
    //        "Time": 1676157556223,
    //        "Event": "Subscriptions"
    //    }
    //
    return message
}
func  (this *IndependentreserveCore) HandleMessage(client interface{}, message interface{})  {
    var event interface{} = this.SafeString(message, "Event")
    var handlers interface{} = map[string]interface{} {
        "Subscriptions": this.HandleSubscriptions,
        "Heartbeat": this.HandleHeartbeat,
        "ccxt.Trade": this.HandleTrades,
        "OrderBookSnapshot": this.HandleOrderBook,
        "OrderBookChange": this.HandleOrderBook,
    }
    var handler interface{} = this.SafeValue(handlers, event)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
        return
    }
    panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " received an unsupported message: "), this.Json(message))))
}


func (this *IndependentreserveCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
