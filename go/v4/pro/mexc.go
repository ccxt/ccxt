package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type MexcCore struct {
	*ccxt.MexcCore
	base *ccxt.MexcCore
}

func NewMexcCore() *MexcCore {
    p := &MexcCore{}
	base := &ccxt.MexcCore{}
	p.base = base
	p.MexcCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *MexcCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelAllOrdersWs": false,
            "cancelOrdersWs": false,
            "cancelOrderWs": false,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchBalanceWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "fetchTradesWs": false,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchBidsAsks": true,
            "unWatchOHLCV": true,
            "unWatchOrderBook": true,
            "unWatchTrades": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://wbs-api.mexc.com/ws",
                    "swap": "wss://contract.mexc.com/edge",
                },
            },
        },
        "options": map[string]interface{} {
            "listenKeyRefreshRate": 1200000,
            "decompressBinary": false,
            "timeframes": map[string]interface{} {
                "1m": "Min1",
                "5m": "Min5",
                "15m": "Min15",
                "30m": "Min30",
                "1h": "Min60",
                "4h": "Hour4",
                "8h": "Hour8",
                "1d": "Day1",
                "1w": "Week1",
                "1M": "Month1",
            },
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 25,
                "snapshotMaxRetries": 3,
            },
            "listenKey": nil,
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 8000,
        },
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name mexc#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#miniticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.miniTicker] set to true for using the miniTicker endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes958)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                var channel interface{} = ccxt.Add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", ccxt.GetValue(market, "id"))
        
                    retRes10019 :=  (<-this.WatchSpotPublic(channel, messageHash, params))
                    ccxt.PanicOnError(retRes10019)
                    ch <- retRes10019
                    return nil
            } else {
                var channel interface{} = "sub.ticker"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
        
                    retRes10619 :=  (<-this.WatchSwapPublic(channel, messageHash, requestParams, params))
                    ccxt.PanicOnError(retRes10619)
                    ch <- retRes10619
                    return nil
            }
        
            }()
            return ch
        }
func  (this *MexcCore) HandleTicker(client interface{}, message interface{})  {
    //
    // swap
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "data": {
    //             "symbol": "BTC_USDT",
    //             "lastPrice": 76376.2,
    //             "riseFallRate": -0.0006,
    //             "fairPrice": 76374.4,
    //             "indexPrice": 76385.8,
    //             "volume24": 962062810,
    //             "amount24": 7344207079.96768,
    //             "maxBidPrice": 84024.3,
    //             "minAskPrice": 68747.2,
    //             "lower24Price": 75620.2,
    //             "high24Price": 77210,
    //             "timestamp": 1731137509138,
    //             "bid1": 76376.2,
    //             "ask1": 76376.3,
    //             "holdVol": 95479623,
    //             "riseFallValue": -46.5,
    //             "fundingRate": 0.0001,
    //             "zone": "UTC+8",
    //             "riseFallRates": [ -0.0006, 0.1008, 0.2262, 0.2628, 0.2439, 1.0564 ],
    //             "riseFallRatesOfTimezone": [ 0.0065, -0.0013, -0.0006 ]
    //         },
    //         "channel": "push.ticker",
    //         "ts": 1731137509138
    //     }
    //
    // spot
    //
    //    {
    //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
    //        "d": {
    //            "A": "4.70432",
    //            "B": "6.714863",
    //            "a": "20744.54",
    //            "b": "20744.17"
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1678643605721
    //    }
    //
    // spot miniTicker
    //
    //     {
    //         "d": {
    //             "s": "BTCUSDT",
    //             "p": "76522",
    //             "r": "0.0012",
    //             "tr": "0.0012",
    //             "h": "77196.3",
    //             "l": "75630.77",
    //             "v": "584664223.92",
    //             "q": "7666.720258",
    //             "lastRT": "-1",
    //             "MT": "0",
    //             "NV": "--",
    //             "t": "1731135533126"
    //         },
    //         "c": "spot@public.miniTicker.v3.api@BTCUSDT@UTC+8",
    //         "t": 1731135533126,
    //         "s": "BTCUSDT"
    //     }
    //
    this.HandleBidAsk(client, message)
    var rawTicker interface{} = this.SafeDictN(message, []interface{}{"d", "data", "publicAggreBookTicker"})
    var marketId interface{} = this.SafeString2(message, "s", "symbol")
    var timestamp interface{} = this.SafeInteger2(message, "t", "sendTime")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ticker interface{} = nil
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        ticker = this.ParseWsTicker(rawTicker, market)
        ccxt.AddElementToObject(ticker, "timestamp", timestamp)
        ccxt.AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
    } else {
        ticker = this.ParseTicker(rawTicker, market)
    }
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
/**
 * @method
 * @name mexc#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#minitickers
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.miniTicker] set to true for using the miniTicker endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2108)
            symbols = this.MarketSymbols(symbols, nil)
            var messageHashes interface{} = []interface{}{}
            var firstSymbol interface{} = this.SafeString(symbols, 0)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(firstSymbol, nil)) {
                market = this.Market(firstSymbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchTickers", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var url interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot"), ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap"))
            var request interface{} = map[string]interface{} {}
            if ccxt.IsTrue(isSpot) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchTickers does not support spot markets")))
            } else {
                ccxt.AddElementToObject(request, "method", "sub.tickers")
                ccxt.AddElementToObject(request, "params", map[string]interface{} {})
                ccxt.AppendToArray(&messageHashes, "ticker")
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(ccxt.IsTrue(isSpot) && ccxt.IsTrue(this.NewUpdates)) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleTickers(client interface{}, message interface{})  {
    //
    // swap
    //
    //     {
    //       "channel": "push.tickers",
    //       "data": [
    //         {
    //           "symbol": "ETH_USDT",
    //           "lastPrice": 2324.5,
    //           "riseFallRate": 0.0356,
    //           "fairPrice": 2324.32,
    //           "indexPrice": 2325.44,
    //           "volume24": 25868309,
    //           "amount24": 591752573.9792,
    //           "maxBidPrice": 2557.98,
    //           "minAskPrice": 2092.89,
    //           "lower24Price": 2239.39,
    //           "high24Price": 2332.59,
    //           "timestamp": 1725872514111
    //         }
    //       ],
    //       "ts": 1725872514111
    //     }
    //
    // spot
    //
    //    {
    //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
    //        "d": {
    //            "A": "4.70432",
    //            "B": "6.714863",
    //            "a": "20744.54",
    //            "b": "20744.17"
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1678643605721
    //    }
    //
    // spot miniTicker
    //
    //     {
    //         "d": {
    //             "s": "BTCUSDT",
    //             "p": "76522",
    //             "r": "0.0012",
    //             "tr": "0.0012",
    //             "h": "77196.3",
    //             "l": "75630.77",
    //             "v": "584664223.92",
    //             "q": "7666.720258",
    //             "lastRT": "-1",
    //             "MT": "0",
    //             "NV": "--",
    //             "t": "1731135533126"
    //         },
    //         "c": "spot@public.miniTicker.v3.api@BTCUSDT@UTC+8",
    //         "t": 1731135533126,
    //         "s": "BTCUSDT"
    //     }
    //
    var data interface{} = this.SafeList2(message, "data", "d")
    var channel interface{} = this.SafeString(message, "c", "")
    var marketId interface{} = this.SafeString(message, "s")
    var market interface{} = this.SafeMarket(marketId)
    var channelStartsWithSpot interface{} = ccxt.StartsWith(channel, "spot")
    var marketIdIsUndefined interface{} = ccxt.IsEqual(marketId, nil)
    var isSpot interface{} = ccxt.Ternary(ccxt.IsTrue(marketIdIsUndefined), channelStartsWithSpot, ccxt.GetValue(market, "spot"))
    var spotPrefix interface{} = "spot:"
    var messageHashPrefix interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), spotPrefix, "")
    var topic interface{} = ccxt.Add(messageHashPrefix, "ticker")
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var entry interface{} = ccxt.GetValue(data, i)
        var ticker interface{} = nil
        if ccxt.IsTrue(isSpot) {
            ticker = this.ParseWsTicker(entry, market)
        } else {
            ticker = this.ParseTicker(entry)
        }
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        ccxt.AppendToArray(&result, ticker)
        var messageHash interface{} = ccxt.Add("ticker:", symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
func  (this *MexcCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    // protobuf ticker
    // "bidprice": "93387.28",  // Best bid price
    // "bidquantity": "3.73485", // Best bid quantity
    // "askprice": "93387.29", // Best ask price
    // "askquantity": "7.669875" // Best ask quantity
    //
    // spot
    //
    //     {
    //         "A": "4.70432",
    //         "B": "6.714863",
    //         "a": "20744.54",
    //         "b": "20744.17"
    //     }
    //
    // spot miniTicker
    //
    //     {
    //         "s": "BTCUSDT",
    //         "p": "76521",
    //         "r": "0.0012",
    //         "tr": "0.0012",
    //         "h": "77196.3",
    //         "l": "75630.77",
    //         "v": "584664223.92",
    //         "q": "7666.720258",
    //         "lastRT": "-1",
    //         "MT": "0",
    //         "NV": "--",
    //         "t": "1731135533126"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "s")
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var price interface{} = this.SafeString(ticker, "p")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "open": nil,
        "high": this.SafeNumber(ticker, "h"),
        "low": this.SafeNumber(ticker, "l"),
        "close": price,
        "last": price,
        "bid": this.SafeNumber2(ticker, "b", "bidPrice"),
        "bidVolume": this.SafeNumber2(ticker, "B", "bidQuantity"),
        "ask": this.SafeNumber2(ticker, "a", "askPrice"),
        "askVolume": this.SafeNumber2(ticker, "A", "askQuantity"),
        "vwap": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeNumber(ticker, "tr"),
        "average": nil,
        "baseVolume": this.SafeNumber(ticker, "v"),
        "quoteVolume": this.SafeNumber(ticker, "q"),
    }, market)
}
/**
 * @method
 * @name mexc#watchBidsAsks
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#individual-symbol-book-ticker-streams
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4248 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4248)
            symbols = this.MarketSymbols(symbols, nil, true, false, true)
            var marketType interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBidsAsks required symbols argument")))
            }
            var markets interface{} = this.MarketsForSymbols(symbols)
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBidsAsks", ccxt.GetValue(markets, 0), params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var isSpot interface{} = ccxt.IsEqual(marketType, "spot")
            if !ccxt.IsTrue(isSpot) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchBidsAsks only support spot market")))
            }
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                if ccxt.IsTrue(isSpot) {
                    var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&topics, ccxt.Add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", ccxt.GetValue(market, "id")))
                }
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(symbols, i)))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIPTION",
                "params": topics,
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //    {
    //        "c": "spot@public.bookTicker.v3.api@BTCUSDT",
    //        "d": {
    //            "A": "4.70432",
    //            "B": "6.714863",
    //            "a": "20744.54",
    //            "b": "20744.17"
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1678643605721
    //    }
    //
    var parsedTicker interface{} = this.ParseWsBidAsk(message)
    var symbol interface{} = this.SafeString(parsedTicker, "symbol")
    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
        return
    }
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *MexcCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var data interface{} = this.SafeDict(ticker, "d")
    var marketId interface{} = this.SafeString(ticker, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(data, "a"),
        "askVolume": this.SafeNumber(data, "A"),
        "bid": this.SafeNumber(data, "b"),
        "bidVolume": this.SafeNumber(data, "B"),
        "info": ticker,
    }, market)
}
func  (this *MexcCore) WatchSpotPublic(channel interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var unsubscribed interface{} = this.SafeBool(params, "unsubscribed", false)
            params = this.Omit(params, []interface{}{"unsubscribed"})
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
            var method interface{} = ccxt.Ternary(ccxt.IsTrue((unsubscribed)), "UNSUBSCRIPTION", "SUBSCRIPTION")
            var request interface{} = map[string]interface{} {
                "method": method,
                "params": []interface{}{channel},
            }
        
                retRes51015 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes51015)
                ch <- retRes51015
                return nil
        
            }()
            return ch
        }
func  (this *MexcCore) WatchSpotPrivate(channel interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            listenKey:= (<-this.Authenticate(channel))
            ccxt.PanicOnError(listenKey)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot"), "?listenKey="), listenKey)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIPTION",
                "params": []interface{}{channel},
            }
        
                retRes52115 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), channel))
                ccxt.PanicOnError(retRes52115)
                ch <- retRes52115
                return nil
        
            }()
            return ch
        }
func  (this *MexcCore) WatchSwapPublic(channel interface{}, messageHash interface{}, requestParams interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
            var request interface{} = map[string]interface{} {
                "method": channel,
                "param": requestParams,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes53115 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes53115)
                ch <- retRes53115
                return nil
        
            }()
            return ch
        }
func  (this *MexcCore) WatchSwapPrivate(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var channel interface{} = "login"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
            var timestamp interface{} = ccxt.ToString(this.Milliseconds())
            var payload interface{} = ccxt.Add(this.ApiKey, timestamp)
            var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256)
            var request interface{} = map[string]interface{} {
                "method": channel,
                "param": map[string]interface{} {
                    "apiKey": this.ApiKey,
                    "signature": signature,
                    "reqTime": timestamp,
                },
            }
            var message interface{} = this.Extend(request, params)
        
                retRes55015 :=  (<-this.Watch(url, messageHash, message, channel))
                ccxt.PanicOnError(retRes55015)
                ch <- retRes55015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#watchOHLCV
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *MexcCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5668)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var timeframeId interface{} = this.SafeString(timeframes, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
            var ohlcv interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("spot@public.kline.v3.api.pb@", ccxt.GetValue(market, "id")), "@"), timeframeId)
                
            ohlcv = (<-this.WatchSpotPublic(channel, messageHash, params))
                    ccxt.PanicOnError(ohlcv)
            } else {
                var channel interface{} = "sub.kline"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                    "interval": timeframeId,
                }
                
            ohlcv = (<-this.WatchSwapPublic(channel, messageHash, requestParams, params))
                    ccxt.PanicOnError(ohlcv)
            }
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // spot
    //
    //    {
    //        "d": {
    //            "e": "spot@public.kline.v3.api",
    //            "k": {
    //                "t": 1678642261,
    //                "o": 20626.94,
    //                "c": 20599.69,
    //                "h": 20626.94,
    //                "l": 20597.06,
    //                "v": 27.678686,
    //                "a": 570332.77,
    //                "T": 1678642320,
    //                "i": "Min1"
    //            }
    //        },
    //        "c": "spot@public.kline.v3.api@BTCUSDT@Min1",
    //        "t": 1678642276459,
    //        "s": "BTCUSDT"
    //    }
    //
    // swap
    //
    //   {
    //       "channel": "push.kline",
    //       "data": {
    //         "a": 325653.3287,
    //         "c": 38839,
    //         "h": 38909.5,
    //         "interval": "Min1",
    //         "l": 38833,
    //         "o": 38901.5,
    //         "q": 83808,
    //         "rc": 38839,
    //         "rh": 38909.5,
    //         "rl": 38833,
    //         "ro": 38909.5,
    //         "symbol": "BTC_USDT",
    //         "t": 1651230660
    //       },
    //       "symbol": "BTC_USDT",
    //       "ts": 1651230713067
    //   }
    // protobuf
    //  {
    //    "channel":"spot@public.kline.v3.api.pb@BTCUSDT@Min1",
    //    "symbol":"BTCUSDT",
    //    "symbolId":"2fb942154ef44a4ab2ef98c8afb6a4a7",
    //    "createTime":"1754737941062",
    //    "publicSpotKline":{
    //       "interval":"Min1",
    //       "windowStart":"1754737920",
    //       "openingPrice":"117317.31",
    //       "closingPrice":"117325.26",
    //       "highestPrice":"117341",
    //       "lowestPrice":"117317.3",
    //       "volume":"3.12599854",
    //       "amount":"366804.43",
    //       "windowEnd":"1754737980"
    //    }
    // }
    //
    var parsed interface{} = nil
    var symbol interface{} = nil
    var timeframe interface{} = nil
    if ccxt.IsTrue(ccxt.InOp(message, "publicSpotKline")) {
        symbol = this.Symbol(this.SafeString(message, "symbol"))
        var data interface{} = this.SafeDict(message, "publicSpotKline", map[string]interface{} {})
        var timeframeId interface{} = this.SafeString(data, "interval")
        timeframe = this.FindTimeframe(timeframeId, ccxt.GetValue(this.Options, "timeframes"))
        parsed = this.ParseWsOHLCV(data, this.SafeMarket(symbol))
    } else {
        var d interface{} = this.SafeValue2(message, "d", "data", map[string]interface{} {})
        var rawOhlcv interface{} = this.SafeValue(d, "k", d)
        var timeframeId interface{} = this.SafeString2(rawOhlcv, "i", "interval")
        var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
        timeframe = this.FindTimeframe(timeframeId, timeframes)
        var marketId interface{} = this.SafeString2(message, "s", "symbol")
        var market interface{} = this.SafeMarket(marketId)
        symbol = ccxt.GetValue(market, "symbol")
        parsed = this.ParseWsOHLCV(rawOhlcv, market)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *MexcCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        "t": 1678642260,
    //        "o": 20626.94,
    //        "c": 20599.69,
    //        "h": 20626.94,
    //        "l": 20597.06,
    //        "v": 27.678686,
    //        "a": 570332.77,
    //        "T": 1678642320,
    //        "i": "Min1"
    //    }
    //
    // swap
    //    {
    //       "symbol": "BTC_USDT",
    //       "interval": "Min1",
    //       "t": 1680055080,
    //       "o": 27301.9,
    //       "c": 27301.8,
    //       "h": 27301.9,
    //       "l": 27301.8,
    //       "a": 8.19054,
    //       "q": 3,
    //       "ro": 27301.8,
    //       "rc": 27301.8,
    //       "rh": 27301.8,
    //       "rl": 27301.8
    //     }
    // protobuf
    //
    //       "interval":"Min1",
    //       "windowStart":"1754737920",
    //       "openingPrice":"117317.31",
    //       "closingPrice":"117325.26",
    //       "highestPrice":"117341",
    //       "lowestPrice":"117317.3",
    //       "volume":"3.12599854",
    //       "amount":"366804.43",
    //       "windowEnd":"1754737980"
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp2(ohlcv, "t", "windowStart"), this.SafeNumber2(ohlcv, "o", "openingPrice"), this.SafeNumber2(ohlcv, "h", "highestPrice"), this.SafeNumber2(ohlcv, "l", "lowestPrice"), this.SafeNumber2(ohlcv, "c", "closingPrice"), this.SafeNumber2(ohlcv, "v", "volume")}
}
/**
 * @method
 * @name mexc#watchOrderBook
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.frequency] the frequency of the order book updates, default is '10ms', can be '100ms' or '10ms
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *MexcCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7548)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var orderbook interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                var frequency interface{} = nil
                frequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "frequency", "100ms")
                frequency = ccxt.GetValue(frequencyparamsVariable,0)
                params = ccxt.GetValue(frequencyparamsVariable,1)
                var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("spot@public.aggre.depth.v3.api.pb@", frequency), "@"), ccxt.GetValue(market, "id"))
                
            orderbook = (<-this.WatchSpotPublic(channel, messageHash, params))
                    ccxt.PanicOnError(orderbook)
            } else {
                var channel interface{} = "sub.depth"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
                
            orderbook = (<-this.WatchSwapPublic(channel, messageHash, requestParams, params))
                    ccxt.PanicOnError(orderbook)
            }
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleOrderBookSubscription(client interface{}, message interface{})  {
    // spot
    //     { id: 0, code: 0, msg: "spot@public.increase.depth.v3.api@BTCUSDT" }
    //
    var msg interface{} = this.SafeString(message, "msg")
    var parts interface{} = ccxt.Split(msg, "@")
    var marketId interface{} = this.SafeString(parts, 2)
    var symbol interface{} = this.SafeSymbol(marketId)
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
}
func  (this *MexcCore) GetCacheIndex(orderbook interface{}, cache interface{}) interface{}  {
    // return the first index of the cache that can be applied to the orderbook or -1 if not possible
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    var firstDelta interface{} = this.SafeValue(cache, 0)
    var firstDeltaNonce interface{} = this.SafeIntegerN(firstDelta, []interface{}{"r", "version", "fromVersion"})
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(firstDeltaNonce, 1))) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaNonce interface{} = this.SafeIntegerN(delta, []interface{}{"r", "version", "fromVersion"})
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(deltaNonce, nonce)) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
func  (this *MexcCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "c": "spot@public.increase.depth.v3.api@BTCUSDT",
    //        "d": {
    //            "asks": [{
    //                "p": "20290.89",
    //                "v": "0.000000"
    //            }],
    //            "e": "spot@public.increase.depth.v3.api",
    //            "r": "3407459756"
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1661932660144
    //    }
    //
    //
    //
    // swap
    //  {
    //      "channel":"push.depth",
    //      "data":{
    //         "asks":[
    //            [
    //               39146.5,
    //               11264,
    //               1
    //            ]
    //         ],
    //         "bids":[
    //            [
    //               39144,
    //               35460,
    //               1
    //            ]
    //         ],
    //         "end":4895965272,
    //         "begin":4895965271
    //      },
    //      "symbol":"BTC_USDT",
    //      "ts":1651239652372
    //  }
    // protofbuf
    // {
    //      "channel":"spot@public.aggre.depth.v3.api.pb@100ms@BTCUSDT",
    //      "symbol":"BTCUSDT",
    //      "sendTime":"1754741322152",
    //      "publicAggreDepths":{
    //          "asks":[
    //              {
    //                  "price":"117145.49",
    //                  "quantity":"0"
    //              }
    //          ],
    //          "bids":[
    //              {
    //                  "price":"117053.41",
    //                  "quantity":"1.86837271"
    //              }
    //          ],
    //          "eventType":"spot@public.aggre.depth.v3.api.pb@100ms",
    //          "fromVersion":"43296363236",
    //          "toVersion":"43296363255"
    //      }
    // }
    //
    var data interface{} = this.SafeDictN(message, []interface{}{"d", "data", "publicAggreDepths"})
    var marketId interface{} = this.SafeString2(message, "s", "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    var limit interface{} = this.SafeInteger(subscription, "limit")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeInteger(storedOrderBook, "nonce")
    var shouldReturn interface{} = false
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        var cacheLength interface{} =         ccxt.GetArrayLength(storedOrderBook.(ccxt.OrderBookInterface).GetCache())
        var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 25)
        if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
            this.Spawn(this.LoadOrderBook, client, messageHash, symbol, limit, map[string]interface{} {})
        }
        ccxt.AppendToArray(storedOrderBook.(ccxt.OrderBookInterface).GetCache(), data)
        return
    }
    
        {
             func(this *MexcCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *MexcCore) interface{} {
                            // catch block:
                                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            client.(ccxt.ClientInterface).Reject(e, messageHash)
            // return
            shouldReturn = true
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        this.HandleDelta(storedOrderBook, data)
            var timestamp interface{} = this.SafeIntegerN(message, []interface{}{"t", "ts", "sendTime"})
            ccxt.AddElementToObject(storedOrderBook, "timestamp", timestamp)
            ccxt.AddElementToObject(storedOrderBook, "datetime", this.Iso8601(timestamp))
    		    return nil
    	    }(this)
        
            }
    if ccxt.IsTrue(shouldReturn) {
        return  // go requirement
    }
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *MexcCore) HandleBooksideDelta(bookside interface{}, bidasks interface{})  {
    //
    //    [{
    //        "p": "20290.89",
    //        "v": "0.000000"
    //    }]
    //
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidasks)); i++ {
        var bidask interface{} = ccxt.GetValue(bidasks, i)
        if ccxt.IsTrue(ccxt.IsArray(bidask)) {
            bookside.(ccxt.IOrderBookSide).StoreArray(bidask)
        } else {
            var price interface{} = this.SafeFloat2(bidask, "p", "price")
            var amount interface{} = this.SafeFloat2(bidask, "v", "quantity")
            bookside.(ccxt.IOrderBookSide).Store(price, amount)
        }
    }
}
func  (this *MexcCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var existingNonce interface{} = this.SafeInteger(orderbook, "nonce")
    var deltaNonce interface{} = this.SafeIntegerN(delta, []interface{}{"r", "version", "fromVersion"})
    if ccxt.IsTrue(ccxt.IsLessThan(deltaNonce, existingNonce)) {
        // even when doing < comparison, this happens: https://app.travis-ci.com/github/ccxt/ccxt/builds/269234741#L1809
        // so, we just skip old updates
        return
    }
    ccxt.AddElementToObject(orderbook, "nonce", deltaNonce)
    var asks interface{} = this.SafeList(delta, "asks", []interface{}{})
    var bids interface{} = this.SafeList(delta, "bids", []interface{}{})
    var asksOrderSide interface{} = ccxt.GetValue(orderbook, "asks")
    var bidsOrderSide interface{} = ccxt.GetValue(orderbook, "bids")
    this.HandleBooksideDelta(asksOrderSide, asks)
    this.HandleBooksideDelta(bidsOrderSide, bids)
}
/**
 * @method
 * @name mexc#watchTrades
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-market-streams#trade-streams
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#public-channels
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *MexcCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9578)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            var trades interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                var channel interface{} = ccxt.Add("spot@public.aggre.deals.v3.api.pb@100ms@", ccxt.GetValue(market, "id"))
                
            trades = (<-this.WatchSpotPublic(channel, messageHash, params))
                    ccxt.PanicOnError(trades)
            } else {
                var channel interface{} = "sub.deal"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
                
            trades = (<-this.WatchSwapPublic(channel, messageHash, requestParams, params))
                    ccxt.PanicOnError(trades)
            }
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleTrades(client interface{}, message interface{})  {
    // protobuf
    // {
    // "channel": "spot@public.aggre.deals.v3.api.pb@100ms@BTCUSDT",
    // "publicdeals": {
    //     "dealsList": [
    //     {
    //         "price": "93220.00", // ccxt.Trade price
    //         "quantity": "0.04438243", // ccxt.Trade quantity
    //         "tradetype": 2, // ccxt.Trade type (1: Buy, 2: Sell)
    //         "time": 1736409765051 // ccxt.Trade time
    //     }
    //     ],
    //     "eventtype": "spot@public.aggre.deals.v3.api.pb@100ms" // Event type
    // },
    // "symbol": "BTCUSDT", // Trading pair
    // "sendtime": 1736409765052 // Event time
    // }
    //
    //    {
    //        "c": "spot@public.deals.v3.api@BTCUSDT",
    //        "d": {
    //            "deals": [{
    //                "p": "20382.70",
    //                "v": "0.043800",
    //                "S": 1,
    //                "t": 1678593222456,
    //            }, ],
    //            "e": "spot@public.deals.v3.api",
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1678593222460,
    //    }
    //
    // swap
    //     {
    //         "symbol": "BTC_USDT",
    //         "data": [
    //            {
    //                "p": 114350.4,
    //                "v": 4,
    //                "T": 2,
    //                "O": 3,
    //                "M": 2,
    //                "t": 1760368563597
    //            }
    //         ],
    //         "channel": "push.deal",
    //         "ts": 1680055941870
    //     }
    //
    var marketId interface{} = this.SafeString2(message, "s", "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var d interface{} = this.SafeDictN(message, []interface{}{"d", "publicAggreDeals"})
    var trades interface{} = this.SafeList2(d, "deals", "dealsList", []interface{}{d})
    if ccxt.IsTrue(ccxt.IsEqual(d, nil)) {
        trades = this.SafeList(message, "data", []interface{}{})
    }
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        var parsedTrade interface{} = nil
        if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
            parsedTrade = this.ParseWsTrade(ccxt.GetValue(trades, j), market)
        } else {
            parsedTrade = this.ParseTrade(ccxt.GetValue(trades, j), market)
        }
        stored.(ccxt.Appender).Append(parsedTrade)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name mexc#watchMyTrades
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-deals
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#private-channels
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *MexcCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10698)
            var messageHash interface{} = "myTrades"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var trades interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var channel interface{} = "spot@private.deals.v3.api.pb"
                
            trades = (<-this.WatchSpotPrivate(channel, messageHash, params))
                    ccxt.PanicOnError(trades)
            } else {
                
            trades = (<-this.WatchSwapPrivate(messageHash, params))
                    ccxt.PanicOnError(trades)
            }
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleMyTrade(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //    {
    //        "c": "spot@private.deals.v3.api",
    //        "d": {
    //            "p": "22339.99",
    //            "v": "0.000235",
    //            "S": 1,
    //            "T": 1678670940695,
    //            "t": "9f6a47fb926442e496c5c4c104076ae3",
    //            "c": '',
    //            "i": "e2b9835d1b6745f8a10ab74a81a16d50",
    //            "m": 0,
    //            "st": 0
    //        },
    //        "s": "BTCUSDT",
    //        "t": 1678670940700
    //    }
    //    {
    //      channel: "spot@private.deals.v3.api.pb",
    //      symbol: "MXUSDT",
    //      sendTime: 1736417034332,
    //      privateDeals {
    //        price: "3.6962",
    //        quantity: "1",
    //        amount: "3.6962",
    //        tradeType: 2,
    //        tradeId: "505979017439002624X1",
    //        orderId: "C02__505979017439002624115",
    //        feeAmount: "0.0003998377369698171",
    //        feeCurrency: "MX",
    //        time: 1736417034280
    //      }
    // }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var messageHash interface{} = "myTrades"
    var data interface{} = this.SafeDictN(message, []interface{}{"d", "data", "privateDeals"})
    var futuresMarketId interface{} = this.SafeString(data, "symbol")
    var marketId interface{} = this.SafeString2(message, "s", "symbol", futuresMarketId)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var trade interface{} = nil
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        trade = this.ParseWsTrade(data, market)
    } else {
        trade = this.ParseTrade(data, market)
    }
    var trades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        trades = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = trades
    }
    trades.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(trades, symbolSpecificMessageHash)
}
func  (this *MexcCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public trade (protobuf)
    //    {
    //        "p": "20382.70",
    //        "v": "0.043800",
    //        "S": 1,
    //        "t": 1678593222456,
    //    }
    // private trade
    //    {
    //        "S": 1,
    //        "T": 1661938980268,
    //        "c": "",
    //        "i": "c079b0fcb80a46e8b128b281ce4e4f38",
    //        "m": 1,
    //        "p": "1.008",
    //        "st": 0,
    //        "t": "4079b1522a0b40e7919f609e1ea38d44",
    //        "v": "5"
    //    }
    //
    //   d: {
    //       p: '1.0005',
    //       v: '5.71',
    //       a: '5.712855',
    //       S: 1,
    //       T: 1714325698237,
    //       t: 'edafcd9fdc2f426e82443d114691f724',
    //       c: '',
    //       i: 'C02__413321238354677760043',
    //       m: 0,
    //       st: 0,
    //       n: '0.005712855',
    //       N: 'USDT'
    //   }
    // protobuf
    //
    //     {
    //        price: "3.6962",
    //        quantity: "1",
    //        amount: "3.6962",
    //        tradeType: 2,
    //        tradeId: "505979017439002624X1",
    //        orderId: "C02__505979017439002624115",
    //        feeAmount: "0.0003998377369698171",
    //        feeCurrency: "MX",
    //        time: 1736417034280
    //      }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "T", "time")
    var tradeId interface{} = this.SafeString2(trade, "t", "tradeId")
    if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
        timestamp = this.SafeInteger(trade, "t")
        tradeId = nil
    }
    var priceString interface{} = this.SafeString2(trade, "p", "price")
    var amountString interface{} = this.SafeString2(trade, "v", "quantity")
    var rawSide interface{} = this.SafeString2(trade, "S", "tradeType")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(rawSide, "1"))), "buy", "sell")
    var isMaker interface{} = this.SafeInteger(trade, "m")
    var feeAmount interface{} = this.SafeString2(trade, "n", "feeAmount")
    var feeCurrencyId interface{} = this.SafeString2(trade, "N", "feeCurrency")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": tradeId,
        "order": this.SafeString2(trade, "i", "orderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeSymbol(nil, market),
        "type": nil,
        "side": side,
        "takerOrMaker": ccxt.Ternary(ccxt.IsTrue((isMaker)), "maker", "taker"),
        "price": priceString,
        "amount": amountString,
        "cost": this.SafeString(trade, "amount"),
        "fee": map[string]interface{} {
            "cost": feeAmount,
            "currency": this.SafeCurrencyCode(feeCurrencyId),
        },
    }, market)
}
/**
 * @method
 * @name mexc#watchOrders
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#margin-account-orders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} params.type the type of orders to retrieve, can be 'spot' or 'margin'
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *MexcCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12488)
            var messageHash interface{} = "orders"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var orders interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var channel interface{} = "spot@private.orders.v3.api.pb"
                
            orders = (<-this.WatchSpotPrivate(channel, messageHash, params))
                    ccxt.PanicOnError(orders)
            } else {
                
            orders = (<-this.WatchSwapPrivate(messageHash, params))
                    ccxt.PanicOnError(orders)
            }
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "c": "spot@private.orders.v3.api",
    //        "d": {
    //              "A":8.0,
    //              "O":1661938138000,
    //              "S":1,
    //              "V":10,
    //              "a":8,
    //              "c":"",
    //              "i":"e03a5c7441e44ed899466a7140b71391",
    //              "m":0,
    //              "o":1,
    //              "p":0.8,
    //              "s":1,
    //              "v":10,
    //              "ap":0,
    //              "cv":0,
    //              "ca":0
    //        },
    //        "s": "MXUSDT",
    //        "t": 1661938138193
    //    }
    // spot - stop
    //    {
    //        "c": "spot@private.orders.v3.api",
    //        "d": {
    //              "N":"USDT",
    //              "O":1661938853715,
    //              "P":0.9,
    //              "S":1,
    //              "T":"LE",
    //              "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
    //              "o":100,
    //              "p":1.01,
    //              "s":"NEW",
    //              "v":6
    //        },
    //        "s": "MXUSDT",
    //        "t": 1661938853727
    //    }
    // margin
    //    {
    //        "c": "margin@private.orders.v3.api",
    //        "d":{
    //             "O":1661938138000,
    //             "p":"0.8",
    //             "a":"8",
    //             "v":"10",
    //            "da":"0",
    //            "dv":"0",
    //             "A":"8.0",
    //             "V":"10",
    //             "n": "0",
    //             "N": "USDT",
    //             "S":1,
    //             "o":1,
    //             "s":1,
    //             "i":"e03a5c7441e44ed899466a7140b71391",
    //        },
    //        "s": "MXUSDT",
    //        "t":1661938138193
    //    }
    // protobuf
    //   {
    //      channel: "spot@private.orders.v3.api.pb",
    //      symbol: "MXUSDT",
    //      sendTime: 1736417034281,
    //      privateOrders {}
    //   }
    //
    var messageHash interface{} = "orders"
    var data interface{} = this.SafeDictN(message, []interface{}{"d", "data", "privateOrders"})
    var futuresMarketId interface{} = this.SafeString(data, "symbol")
    var marketId interface{} = this.SafeString2(message, "s", "symbol", futuresMarketId)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var parsed interface{} = nil
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        parsed = this.ParseWsOrder(data, market)
    } else {
        parsed = this.ParseOrder(data, market)
    }
    var orders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = orders
    }
    orders.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orders, symbolSpecificMessageHash)
}
func  (this *MexcCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //          "A":8.0,
    //          "O":1661938138000,
    //          "S":1,
    //          "V":10,
    //          "a":8,
    //          "c":"",
    //          "i":"e03a5c7441e44ed899466a7140b71391",
    //          "m":0,
    //          "o":1,
    //          "p":0.8,
    //          "s":1,
    //          "v":10,
    //          "ap":0,
    //          "cv":0,
    //          "ca":0
    //    }
    // spot - stop
    //    {
    //        "N":"USDT",
    //        "O":1661938853715,
    //        "P":0.9,
    //        "S":1,
    //        "T":"LE",
    //        "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
    //        "o":100,
    //        "p":1.01,
    //        "s":"NEW",
    //        "v":6
    //    }
    // margin
    //    {
    //        "O":1661938138000,
    //        "p":"0.8",
    //        "a":"8",
    //        "v":"10",
    //       "da":"0",
    //       "dv":"0",
    //        "A":"8.0",
    //        "V":"10",
    //        "n": "0",
    //        "N": "USDT",
    //        "S":1,
    //        "o":1,
    //        "s":1,
    //        "i":"e03a5c7441e44ed899466a7140b71391",
    //    }
    // protofbuf spot order
    // {
    //     "id":"C02__583905164440776704043",
    //     "price":"0.001053",
    //     "quantity":"2000",
    //     "amount":"0",
    //     "avgPrice":"0.001007",
    //     "orderType":5,
    //     "tradeType":1,
    //     "remainAmount":"0.092",
    //     "remainQuantity":"0",
    //     "lastDealQuantity":"2000",
    //     "cumulativeQuantity":"2000",
    //     "cumulativeAmount":"2.014",
    //     "status":2,
    //     "createTime":"1754996075502"
    // }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "createTime")
    var side interface{} = this.SafeString(order, "tradeType")
    var status interface{} = this.SafeString(order, "status")
    var typeVar interface{} = this.SafeString(order, "orderType")
    var fee interface{} = nil
    var feeCurrency interface{} = this.SafeString(order, "N")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCurrency, nil)) {
        fee = map[string]interface{} {
            "currency": feeCurrency,
            "cost": nil,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "id"),
        "clientOrderId": this.SafeString(order, "clientId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": this.ParseWsOrderStatus(status, market),
        "symbol": this.SafeSymbol(nil, market),
        "type": this.ParseWsOrderType(typeVar),
        "timeInForce": this.ParseWsTimeInForce(typeVar),
        "side": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "1"))), "buy", "sell"),
        "price": this.SafeString(order, "price"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "average": this.SafeString(order, "avgPrice"),
        "amount": this.SafeString(order, "quantity"),
        "cost": this.SafeString(order, "amount"),
        "filled": this.SafeString(order, "cumulativeQuantity"),
        "remaining": this.SafeString(order, "remainQuantity"),
        "fee": fee,
        "trades": nil,
        "info": order,
    }, market)
}
func  (this *MexcCore) ParseWsOrderStatus(status interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var statuses interface{} = map[string]interface{} {
        "1": "open",
        "2": "closed",
        "3": "open",
        "4": "canceled",
        "5": "closed",
        "NEW": "open",
        "CANCELED": "canceled",
        "EXECUTED": "closed",
        "FAILED": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *MexcCore) ParseWsOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "1": "limit",
        "2": "limit",
        "3": nil,
        "4": nil,
        "5": "market",
        "100": "limit",
    }
    return this.SafeString(types, typeVar)
}
func  (this *MexcCore) ParseWsTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForceIds interface{} = map[string]interface{} {
        "1": "GTC",
        "2": "PO",
        "3": "IOC",
        "4": "FOK",
        "5": "GTC",
        "100": "GTC",
    }
    return this.SafeString(timeInForceIds, timeInForce)
}
/**
 * @method
 * @name mexc#watchBalance
 * @see https://www.mexc.com/api-docs/spot-v3/websocket-user-data-streams#spot-account-update
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *MexcCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15218)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var messageHash interface{} = ccxt.Add("balance:", typeVar)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var channel interface{} = "spot@private.account.v3.api.pb"
        
                    retRes152719 :=  (<-this.WatchSpotPrivate(channel, messageHash, params))
                    ccxt.PanicOnError(retRes152719)
                    ch <- retRes152719
                    return nil
            } else {
        
                    retRes152919 :=  (<-this.WatchSwapPrivate(messageHash, params))
                    ccxt.PanicOnError(retRes152919)
                    ch <- retRes152919
                    return nil
            }
        
            }()
            return ch
        }
func  (this *MexcCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    //    {
    //        channel: "spot@private.account.v3.api.pb",
    //        createTime: "1758134605364",
    //        sendTime: "1758134605373",
    //        privateAccount: {
    //          vcoinName: "USDT",
    //          coinId: "128f589271cb4951b03e71e6323eb7be",
    //          balanceAmount: "0.006016465074677006",
    //          balanceAmountChange: "-4.4022",
    //          frozenAmount: "4.4022",
    //          frozenAmountChange: "4.4022",
    //          type: "ENTRUST_PLACE",
    //          time: "1758134605364",
    //       }
    //    }
    //
    //
    // swap balance
    //
    //     {
    //         "channel": "push.personal.asset",
    //         "data": {
    //             "availableBalance": 67.2426683348,
    //             "bonus": 0,
    //             "currency": "USDT",
    //             "frozenBalance": 0,
    //             "positionMargin": 1.36945756
    //         },
    //         "ts": 1680059188190
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(channel, "spot@private.account.v3.api.pb"))), "spot", "swap")
    var messageHash interface{} = ccxt.Add("balance:", typeVar)
    var data interface{} = this.SafeDictN(message, []interface{}{"data", "privateAccount"})
    var futuresTimestamp interface{} = this.SafeInteger2(message, "ts", "createTime")
    var timestamp interface{} = this.SafeInteger2(data, "time", futuresTimestamp)
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar))) {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "info", data)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "datetime", this.Iso8601(timestamp))
    var currencyId interface{} = this.SafeStringN(data, []interface{}{"currency", "vcoinName"})
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString2(data, "balanceAmount", "availableBalance"))
    ccxt.AddElementToObject(account, "used", this.SafeStringN(data, []interface{}{"frozenBalance", "frozenAmount"}))
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(ccxt.GetValue(this.Balance, typeVar)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), messageHash)
}
/**
 * @method
 * @name mexc#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15998)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol"))
            var url interface{} = nil
            var channel interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                channel = ccxt.Add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", ccxt.GetValue(market, "id"))
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
                ccxt.AddElementToObject(params, "unsubscribed", true)
                this.WatchSpotPublic(channel, messageHash, params)
            } else {
                channel = "unsub.ticker"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
                this.WatchSwapPublic(channel, messageHash, requestParams, params)
            }
            var client interface{} = this.Client(url)
            this.HandleUnsubscriptions(client, []interface{}{messageHash})
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16318)
            symbols = this.MarketSymbols(symbols, nil)
            var messageHashes interface{} = []interface{}{}
            var firstSymbol interface{} = this.SafeString(symbols, 0)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(firstSymbol, nil)) {
                market = this.Market(firstSymbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchTickers", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var url interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot"), ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap"))
            var request interface{} = map[string]interface{} {}
            if ccxt.IsTrue(isSpot) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchTickers does not support spot markets")))
            } else {
                ccxt.AddElementToObject(request, "method", "unsub.tickers")
                ccxt.AddElementToObject(request, "params", map[string]interface{} {})
                ccxt.AppendToArray(&messageHashes, "unsubscribe:ticker")
            }
            var client interface{} = this.Client(url)
            this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes)
            this.HandleUnsubscriptions(client, messageHashes)
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#unWatchBidsAsks
 * @description unWatches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *MexcCore) UnWatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16928)
            symbols = this.MarketSymbols(symbols, nil, true, false, true)
            var marketType interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBidsAsks required symbols argument")))
            }
            var markets interface{} = this.MarketsForSymbols(symbols)
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBidsAsks", ccxt.GetValue(markets, 0), params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var isSpot interface{} = ccxt.IsEqual(marketType, "spot")
            if !ccxt.IsTrue(isSpot) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchBidsAsks only support spot market")))
            }
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                if ccxt.IsTrue(isSpot) {
                    var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&topics, ccxt.Add("spot@public.aggre.bookTicker.v3.api.pb@100ms@", ccxt.GetValue(market, "id")))
                }
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:bidask:", ccxt.GetValue(symbols, i)))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIPTION",
                "params": topics,
            }
            var client interface{} = this.Client(url)
            this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes)
            this.HandleUnsubscriptions(client, messageHashes)
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *MexcCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes17358)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var timeframeId interface{} = this.SafeString(timeframes, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:candles:", symbol), ":"), timeframe)
            var url interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
                var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("spot@public.kline.v3.api.pb@", ccxt.GetValue(market, "id")), "@"), timeframeId)
                ccxt.AddElementToObject(params, "unsubscribed", true)
                this.WatchSpotPublic(channel, messageHash, params)
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
                var channel interface{} = "unsub.kline"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                    "interval": timeframeId,
                }
                this.WatchSwapPublic(channel, messageHash, requestParams, params)
            }
            var client interface{} = this.Client(url)
            this.HandleUnsubscriptions(client, []interface{}{messageHash})
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.frequency] the frequency of the order book updates, default is '10ms', can be '100ms' or '10ms
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *MexcCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes17718)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("unsubscribe:orderbook:", symbol)
            var url interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
                var frequency interface{} = nil
                frequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "frequency", "100ms")
                frequency = ccxt.GetValue(frequencyparamsVariable,0)
                params = ccxt.GetValue(frequencyparamsVariable,1)
                var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("spot@public.aggre.depth.v3.api.pb@", frequency), "@"), ccxt.GetValue(market, "id"))
                ccxt.AddElementToObject(params, "unsubscribed", true)
                this.WatchSpotPublic(channel, messageHash, params)
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
                var channel interface{} = "unsub.depth"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
                this.WatchSwapPublic(channel, messageHash, requestParams, params)
            }
            var client interface{} = this.Client(url)
            this.HandleUnsubscriptions(client, []interface{}{messageHash})
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#unWatchTrades
 * @description unsubscribes from the trades channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *MexcCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes18068)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("unsubscribe:trades:", symbol)
            var url interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot")
                var channel interface{} = ccxt.Add("spot@public.aggre.deals.v3.api.pb@100ms@", ccxt.GetValue(market, "id"))
                ccxt.AddElementToObject(params, "unsubscribed", true)
                this.WatchSpotPublic(channel, messageHash, params)
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "swap")
                var channel interface{} = "unsub.deal"
                var requestParams interface{} = map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                }
                this.WatchSwapPublic(channel, messageHash, requestParams, params)
            }
            var client interface{} = this.Client(url)
            this.HandleUnsubscriptions(client, []interface{}{messageHash})
        
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) HandleUnsubscriptions(client interface{}, messageHashes interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var subMessageHash interface{} = ccxt.Replace(messageHash, "unsubscribe:", "")
        this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "ticker"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:ticker:", "")
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(symbol, "unsubscribe"), 0)) {
                // unWatchTickers
                var symbols interface{} = ccxt.ObjectKeys(this.Tickers)
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(symbols)); j++ {
                    ccxt.Remove(this.Tickers, ccxt.GetValue(symbols, j))
                }
            } else if ccxt.IsTrue(ccxt.InOp(this.Tickers, symbol)) {
                ccxt.Remove(this.Tickers, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "bidask"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:bidask:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Bidsasks, symbol)) {
                ccxt.Remove(this.Bidsasks, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "candles"), 0)) {
            var splitHashes interface{} = ccxt.Split(messageHash, ":")
            var symbol interface{} = this.SafeString(splitHashes, 2)
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(splitHashes), 4)) {
                symbol = ccxt.Add(symbol, ccxt.Add(":", this.SafeString(splitHashes, 3)))
            }
            if ccxt.IsTrue(ccxt.InOp(this.Ohlcvs, symbol)) {
                ccxt.Remove(this.Ohlcvs, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "orderbook"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:orderbook:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
                ccxt.Remove(this.Orderbooks, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "trades"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:trades:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
                ccxt.Remove(this.Trades, symbol)
            }
        }
    }
}
func  (this *MexcCore) Authenticate(subscriptionHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // we only need one listenKey since ccxt shares connections
            params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            if ccxt.IsTrue(!ccxt.IsEqual(listenKey, nil)) {
        
                ch <- listenKey
                return nil
            }
        
            response:= (<-this.SpotPrivatePostUserDataStream(params))
            ccxt.PanicOnError(response)
            //
            //    {
            //        "listenKey": "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
            //    }
            //
            listenKey = this.SafeString(response, "listenKey")
            ccxt.AddElementToObject(this.Options, "listenKey", listenKey)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1200000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, listenKey, params)
        
            ch <- listenKey
            return nil
        
            }()
            return ch
        }
func  (this *MexcCore) KeepAliveListenKey(listenKey interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            var request interface{} = map[string]interface{} {
                "listenKey": listenKey,
            }
            
                {
                     func(this *MexcCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *MexcCore) interface{} {
                                    // catch block:
                                            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "spot"), "?listenKey="), listenKey)
                    var client interface{} = this.Client(url)
                    ccxt.AddElementToObject(this.Options, "listenKey", nil)
                    client.(ccxt.ClientInterface).Reject(error)
                    ccxt.Remove(this.Clients, url)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes190012 := (<-this.SpotPrivatePutUserDataStream(this.Extend(request, params)))
                    ccxt.PanicOnError(retRes190012)
                    var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1200000)
                    this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, listenKey, params)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *MexcCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *MexcCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //    {
    //        "id": 0,
    //        "code": 0,
    //        "msg": "spot@public.increase.depth.v3.api@BTCUSDT"
    //    }
    // ccxt.Set the default to an empty string if the message is empty during the test.
    var msg interface{} = this.SafeString(message, "msg", "")
    if ccxt.IsTrue(ccxt.IsEqual(msg, "PONG")) {
        this.HandlePong(client, message)
    } else if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(msg, "@"), ccxt.OpNeg(1))) {
        var parts interface{} = ccxt.Split(msg, "@")
        var channel interface{} = this.SafeString(parts, 1)
        var methods interface{} = map[string]interface{} {
            "public.increase.depth.v3.api": this.HandleOrderBookSubscription,
            "public.aggre.depth.v3.api.pb": this.HandleOrderBookSubscription,
        }
        var method interface{} = this.SafeValue(methods, channel)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *MexcCore) HandleProtobufMessage(client interface{}, message interface{}) interface{}  {
    // protobuf message decoded
    //  {
    //    "channel":"spot@public.kline.v3.api.pb@BTCUSDT@Min1",
    //    "symbol":"BTCUSDT",
    //    "symbolId":"2fb942154ef44a4ab2ef98c8afb6a4a7",
    //    "createTime":"1754737941062",
    //    "publicSpotKline":{
    //       "interval":"Min1",
    //       "windowStart":"1754737920",
    //       "openingPrice":"117317.31",
    //       "closingPrice":"117325.26",
    //       "highestPrice":"117341",
    //       "lowestPrice":"117317.3",
    //       "volume":"3.12599854",
    //       "amount":"366804.43",
    //       "windowEnd":"1754737980"
    //    }
    // }
    var channel interface{} = this.SafeString(message, "channel")
    var channelParts interface{} = ccxt.Split(channel, "@")
    var channelId interface{} = this.SafeString(channelParts, 1)
    if ccxt.IsTrue(ccxt.IsEqual(channelId, "public.kline.v3.api.pb")) {
        this.HandleOHLCV(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "public.aggre.deals.v3.api.pb")) {
        this.HandleTrades(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "public.aggre.bookTicker.v3.api.pb")) {
        this.HandleTicker(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "public.aggre.depth.v3.api.pb")) {
        this.HandleOrderBook(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "private.account.v3.api.pb")) {
        this.HandleBalance(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "private.deals.v3.api.pb")) {
        this.HandleMyTrade(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(channelId, "private.orders.v3.api.pb")) {
        this.HandleOrder(client, message)
    }
    return true
}
func  (this *MexcCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsString(message)) {
        if ccxt.IsTrue(ccxt.IsEqual(message, "Invalid listen key")) {
            error := ccxt.AuthenticationError(ccxt.Add(this.Id, " invalid listen key"))
            client.(ccxt.ClientInterface).Reject(error)
            return
        }
    }
    if ccxt.IsTrue(this.IsBinaryMessage(message)) {
        message = this.DecodeProtoMsg(message)
        this.HandleProtobufMessage(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.InOp(message, "msg")) {
        this.HandleSubscriptionStatus(client, message)
        return
    }
    var c interface{} = this.SafeString(message, "c")
    var channel interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(c, nil)) {
        channel = this.SafeString(message, "channel")
    } else {
        var parts interface{} = ccxt.Split(c, "@")
        channel = this.SafeString(parts, 1)
    }
    var methods interface{} = map[string]interface{} {
        "public.deals.v3.api": this.HandleTrades,
        "push.deal": this.HandleTrades,
        "public.kline.v3.api": this.HandleOHLCV,
        "push.kline": this.HandleOHLCV,
        "public.bookTicker.v3.api": this.HandleTicker,
        "public.miniTicker.v3.api": this.HandleTicker,
        "public.miniTickers.v3.api": this.HandleTickers,
        "push.ticker": this.HandleTicker,
        "push.tickers": this.HandleTickers,
        "public.increase.depth.v3.api": this.HandleOrderBook,
        "push.depth": this.HandleOrderBook,
        "private.orders.v3.api": this.HandleOrder,
        "push.personal.order": this.HandleOrder,
        "private.account.v3.api": this.HandleBalance,
        "push.personal.asset": this.HandleBalance,
        "private.deals.v3.api": this.HandleMyTrade,
        "push.personal.order.deal": this.HandleMyTrade,
        "pong": this.HandlePong,
    }
    if ccxt.IsTrue(ccxt.InOp(methods, channel)) {
        var method interface{} = ccxt.GetValue(methods, channel)
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *MexcCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "method": "ping",
    }
}


func (this *MexcCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
