package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DeriveCore struct {
	*ccxt.DeriveCore
	base *ccxt.DeriveCore
}

func NewDeriveCore() *DeriveCore {
    p := &DeriveCore{}
	base := &ccxt.DeriveCore{}
	p.base = base
	p.DeriveCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *DeriveCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": false,
            "watchBalance": false,
            "watchMyTrades": true,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchBidsAsks": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPositions": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.lyra.finance/ws",
            },
            "test": map[string]interface{} {
                "ws": "wss://api-demo.lyra.finance/ws",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "requestId": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {
            "keepAlive": 9000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {},
            },
        },
    })
}
func  (this *DeriveCore) RequestId(url interface{}) interface{}  {
    var options interface{} = this.SafeValue(this.Options, "requestId", map[string]interface{} {})
    var previousValue interface{} = this.SafeInteger(options, url, 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "requestId"), url, newValue)
    return newValue
}
func  (this *DeriveCore) WatchPublic(messageHash interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId(url)
            var request interface{} = this.Extend(message, map[string]interface{} {
                "id": requestId,
            })
            subscription = this.Extend(subscription, map[string]interface{} {
                "id": requestId,
                "method": "subscribe",
            })
        
                retRes6915 :=  (<-this.Watch(url, messageHash, request, messageHash, subscription))
                ccxt.PanicOnError(retRes6915)
                ch <- retRes6915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#watchOrderBook
 * @see https://docs.derive.xyz/reference/orderbook-instrument_name-group-depth
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeriveCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes838 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes838)
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 10
            }
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook.", ccxt.GetValue(market, "id")), ".10."), this.NumberToString(limit))
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
                "symbol": symbol,
                "limit": limit,
                "params": params,
            }
        
            orderbook:= (<-this.WatchPublic(topic, request, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // {
    //     method: 'subscription',
    //     params: {
    //       channel: 'orderbook.BTC-PERP.10.1',
    //       data: {
    //         timestamp: 1738331231506,
    //         instrument_name: 'BTC-PERP',
    //         publish_id: 628419,
    //         bids: [ [ '104669', '40' ] ],
    //         asks: [ [ '104736', '40' ] ]
    //       }
    //     }
    // }
    //
    var params interface{} = this.SafeDict(message, "params")
    var data interface{} = this.SafeDict(params, "data")
    var marketId interface{} = this.SafeString(data, "instrument_name")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var topic interface{} = this.SafeString(params, "channel")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
        var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), topic)
        var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    client.(ccxt.ClientInterface).Resolve(orderbook, topic)
}
/**
 * @method
 * @name derive#watchTicker
 * @see https://docs.derive.xyz/reference/ticker-instrument_name-interval
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeriveCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1528)
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add(ccxt.Add("ticker.", ccxt.GetValue(market, "id")), ".100")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
                "symbol": symbol,
                "params": params,
            }
        
                retRes16815 :=  (<-this.WatchPublic(topic, request, subscription))
                ccxt.PanicOnError(retRes16815)
                ch <- retRes16815
                return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     method: 'subscription',
    //     params: {
    //       channel: 'ticker.BTC-PERP.100',
    //       data: {
    //         timestamp: 1738485104439,
    //         instrument_ticker: {
    //           instrument_type: 'perp',
    //           instrument_name: 'BTC-PERP',
    //           scheduled_activation: 1701840228,
    //           scheduled_deactivation: '9223372036854775807',
    //           is_active: true,
    //           tick_size: '0.1',
    //           minimum_amount: '0.01',
    //           maximum_amount: '10000',
    //           amount_step: '0.001',
    //           mark_price_fee_rate_cap: '0',
    //           maker_fee_rate: '0.0001',
    //           taker_fee_rate: '0.0003',
    //           base_fee: '0.1',
    //           base_currency: 'BTC',
    //           quote_currency: 'USD',
    //           option_details: null,
    //           perp_details: {
    //             index: 'BTC-USD',
    //             max_rate_per_hour: '0.004',
    //             min_rate_per_hour: '-0.004',
    //             static_interest_rate: '0.0000125',
    //             aggregate_funding: '10581.779418721074588722',
    //             funding_rate: '0.000024792239208858'
    //           },
    //           erc20_details: null,
    //           base_asset_address: '0xDBa83C0C654DB1cd914FA2710bA743e925B53086',
    //           base_asset_sub_id: '0',
    //           pro_rata_fraction: '0',
    //           fifo_min_allocation: '0',
    //           pro_rata_amount_step: '0.1',
    //           best_ask_amount: '0.131',
    //           best_ask_price: '99898.6',
    //           best_bid_amount: '0.056',
    //           best_bid_price: '99889.1',
    //           five_percent_bid_depth: '11.817',
    //           five_percent_ask_depth: '9.116',
    //           option_pricing: null,
    //           index_price: '99883.8',
    //           mark_price: '99897.52408421244763303548098',
    //           stats: {
    //             contract_volume: '92.395',
    //             num_trades: '2924',
    //             open_interest: '33.743468027373780786',
    //             high: '102320.4',
    //             low: '99064.3',
    //             percent_change: '-0.021356',
    //             usd_change: '-2178'
    //           },
    //           timestamp: 1738485165881,
    //           min_price: '97939.1',
    //           max_price: '101895.2'
    //         }
    //       }
    //     }
    // }
    //
    var params interface{} = this.SafeDict(message, "params")
    var rawData interface{} = this.SafeDict(params, "data")
    var data interface{} = this.SafeDict(rawData, "instrument_ticker")
    var topic interface{} = this.SafeValue(params, "channel")
    var ticker interface{} = this.ParseTicker(data)
    ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(ticker, "symbol"), ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, topic)
    return message
}
/**
 * @method
 * @name derive#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeriveCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2568)
            var limit interface{} = this.SafeInteger(params, "limit")
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 10
            }
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook.", ccxt.GetValue(market, "id")), ".10."), this.NumberToString(limit))
            var messageHash interface{} = ccxt.Add("unwatch", topic)
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
            }
        
                retRes27515 :=  (<-this.UnWatchPublic(messageHash, request, subscription))
                ccxt.PanicOnError(retRes27515)
                ch <- retRes27515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#unWatchTrades
 * @description unsubscribe from the trades channel
 * @param {string} symbol unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *DeriveCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2878)
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add("trades.", ccxt.GetValue(market, "id"))
            var messageHah interface{} = ccxt.Add("unwatch", topic)
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
            }
        
                retRes30215 :=  (<-this.UnWatchPublic(messageHah, request, subscription))
                ccxt.PanicOnError(retRes30215)
                ch <- retRes30215
                return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) UnWatchPublic(messageHash interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId(url)
            var request interface{} = this.Extend(message, map[string]interface{} {
                "id": requestId,
            })
            subscription = this.Extend(subscription, map[string]interface{} {
                "id": requestId,
                "method": "unsubscribe",
            })
        
                retRes31515 :=  (<-this.Watch(url, messageHash, request, messageHash, subscription))
                ccxt.PanicOnError(retRes31515)
                ch <- retRes31515
                return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleOrderBookUnSubscription(client interface{}, topic interface{})  {
    var parsedTopic interface{} = ccxt.Split(topic, ".")
    var marketId interface{} = this.SafeString(parsedTopic, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), topic)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), topic)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " orderbook "), symbol))
    client.(ccxt.ClientInterface).Reject(error, topic)
    client.(ccxt.ClientInterface).Resolve(error, ccxt.Add("unwatch", topic))
}
func  (this *DeriveCore) HandleTradesUnSubscription(client interface{}, topic interface{})  {
    var parsedTopic interface{} = ccxt.Split(topic, ".")
    var marketId interface{} = this.SafeString(parsedTopic, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Trades, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), topic)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), topic)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " trades "), symbol))
    client.(ccxt.ClientInterface).Reject(error, topic)
    client.(ccxt.ClientInterface).Resolve(error, ccxt.Add("unwatch", topic))
}
func  (this *DeriveCore) HandleUnSubscribe(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     id: 1,
    //     result: {
    //       status: { 'orderbook.BTC-PERP.10.10': 'ok' },
    //       remaining_subscriptions: []
    //     }
    // }
    //
    var result interface{} = this.SafeDict(message, "result")
    var status interface{} = this.SafeDict(result, "status")
    if ccxt.IsTrue(!ccxt.IsEqual(status, nil)) {
        var topics interface{} = ccxt.ObjectKeys(status)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(topics)); i++ {
            var topic interface{} = ccxt.GetValue(topics, i)
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "orderbook"), 0)) {
                this.HandleOrderBookUnSubscription(client, topic)
            } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "trades"), 0)) {
                this.HandleTradesUnSubscription(client, topic)
            }
        }
    }
    return message
}
/**
 * @method
 * @name derive#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.derive.xyz/reference/trades-instrument_name
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *DeriveCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3888)
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add("trades.", ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
                "symbol": symbol,
                "params": params,
            }
        
            trades:= (<-this.WatchPublic(topic, request, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleTrade(client interface{}, message interface{})  {
    //
    //
    var params interface{} = this.SafeDict(message, "params")
    var data interface{} = this.SafeDict(params, "data")
    var topic interface{} = this.SafeValue(params, "channel")
    var parsedTopic interface{} = ccxt.Split(topic, ".")
    var marketId interface{} = this.SafeString(parsedTopic, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(data, i))
        tradesArray.(ccxt.Appender).Append(trade)
    }
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, topic)
}
func  (this *DeriveCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var requestId interface{} = this.RequestId(url)
                var now interface{} = ccxt.ToString(this.Milliseconds())
                var signature interface{} = this.SignMessage(now, this.PrivateKey)
                var deriveWalletAddress interface{} = this.SafeString(this.Options, "deriveWalletAddress")
                var request interface{} = map[string]interface{} {
                    "id": requestId,
                    "method": "public/login",
                    "params": map[string]interface{} {
                        "wallet": deriveWalletAddress,
                        "timestamp": now,
                        "signature": signature,
                    },
                }
                // const subscription: Dict = {
                //     'name': topic,
                //     'symbol': symbol,
                //     'params': params,
                // }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash, message)
            }
        
                retRes46315 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes46315)
                ch <- retRes46315
                return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) WatchPrivate(messageHash interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            retRes4678 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4678)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId(url)
            var request interface{} = this.Extend(message, map[string]interface{} {
                "id": requestId,
            })
            subscription = this.Extend(subscription, map[string]interface{} {
                "id": requestId,
                "method": "subscribe",
            })
        
                retRes47715 :=  (<-this.Watch(url, messageHash, request, messageHash, subscription))
                ccxt.PanicOnError(retRes47715)
                ch <- retRes47715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#watchOrders
 * @see https://docs.derive.xyz/reference/subaccount_id-orders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DeriveCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4938)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("watchOrders", params)
            subaccountId = ccxt.GetValue(subaccountIdparamsVariable,0)
            params = ccxt.GetValue(subaccountIdparamsVariable,1)
            var topic interface{} = ccxt.Add(this.NumberToString(subaccountId), ".orders")
            var messageHash interface{} = topic
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
                "params": params,
            }
            var message interface{} = this.Extend(request, params)
        
            orders:= (<-this.WatchPrivate(messageHash, message, subscription))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleOrder(client interface{}, message interface{})  {
    //
    // {
    //     method: 'subscription',
    //     params: {
    //         channel: '130837.orders',
    //         data: [
    //             {
    //                 subaccount_id: 130837,
    //                 order_id: '1f44c564-5658-4b69-b8c4-4019924207d5',
    //                 instrument_name: 'BTC-PERP',
    //                 direction: 'buy',
    //                 label: 'test1234',
    //                 quote_id: null,
    //                 creation_timestamp: 1738578974146,
    //                 last_update_timestamp: 1738578974146,
    //                 limit_price: '10000',
    //                 amount: '0.01',
    //                 filled_amount: '0',
    //                 average_price: '0',
    //                 order_fee: '0',
    //                 order_type: 'limit',
    //                 time_in_force: 'post_only',
    //                 order_status: 'untriggered',
    //                 max_fee: '219',
    //                 signature_expiry_sec: 1746354973,
    //                 nonce: 1738578973570,
    //                 signer: '0x30CB7B06AdD6749BbE146A6827502B8f2a79269A',
    //                 signature: '0xc6927095f74a0d3b1aeef8c0579d120056530479f806e9d2e6616df742a8934c69046361beae833b32b25c0145e318438d7d1624bb835add956f63aa37192f571c',
    //                 cancel_reason: '',
    //                 mmp: false,
    //                 is_transfer: false,
    //                 replaced_order_id: null,
    //                 trigger_type: 'stoploss',
    //                 trigger_price_type: 'mark',
    //                 trigger_price: '102800',
    //                 trigger_reject_message: null
    //             }
    //         ]
    //     }
    // }
    //
    var params interface{} = this.SafeDict(message, "params")
    var topic interface{} = this.SafeString(params, "channel")
    var rawOrders interface{} = this.SafeList(params, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var data interface{} = ccxt.GetValue(rawOrders, i)
        var parsed interface{} = this.ParseOrder(data)
        var symbol interface{} = this.SafeString(parsed, "symbol")
        var orderId interface{} = this.SafeString(parsed, "id")
        if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
            if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
                var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
                this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
            }
            var cachedOrders interface{} = this.Orders
            var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
            var order interface{} = this.SafeValue(orders, orderId)
            if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
                var fee interface{} = this.SafeValue(order, "fee")
                if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                    ccxt.AddElementToObject(parsed, "fee", fee)
                }
                var fees interface{} = this.SafeValue(order, "fees")
                if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
                    ccxt.AddElementToObject(parsed, "fees", fees)
                }
                ccxt.AddElementToObject(parsed, "trades", this.SafeValue(order, "trades"))
                ccxt.AddElementToObject(parsed, "timestamp", this.SafeInteger(order, "timestamp"))
                ccxt.AddElementToObject(parsed, "datetime", this.SafeString(order, "datetime"))
            }
            cachedOrders.(ccxt.Appender).Append(parsed)
            var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(topic, ":"), symbol)
            client.(ccxt.ClientInterface).Resolve(this.Orders, messageHashSymbol)
        }
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, topic)
}
/**
 * @method
 * @name derive#watchMyTrades
 * @see https://docs.derive.xyz/reference/subaccount_id-trades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *DeriveCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6158)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("watchMyTrades", params)
            subaccountId = ccxt.GetValue(subaccountIdparamsVariable,0)
            params = ccxt.GetValue(subaccountIdparamsVariable,1)
            var topic interface{} = ccxt.Add(this.NumberToString(subaccountId), ".trades")
            var messageHash interface{} = topic
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{topic},
                },
            }
            var subscription interface{} = map[string]interface{} {
                "name": topic,
                "params": params,
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.WatchPrivate(messageHash, message, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeriveCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //
    var myTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(myTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var params interface{} = this.SafeDict(message, "params")
    var topic interface{} = this.SafeString(params, "channel")
    var rawTrades interface{} = this.SafeList(params, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var trade interface{} = this.ParseTrade(message)
        myTrades.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(myTrades, topic)
        var messageHash interface{} = ccxt.Add(topic, ccxt.GetValue(trade, "symbol"))
        client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
    }
}
func  (this *DeriveCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     id: '690c6276-0fc6-4121-aafa-f28bf5adedcb',
    //     error: { code: -32600, message: 'Invalid Request' }
    // }
    //
    if !ccxt.IsTrue((ccxt.InOp(message, "error"))) {
        return false
    }
    var errorMessage interface{} = this.SafeDict(message, "error")
    var errorCode interface{} = this.SafeString(errorMessage, "code")
    
        {
            ret__ := func(this *DeriveCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *DeriveCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(error, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(error)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                panic(ccxt.ExchangeError(feedback))
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *DeriveCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var methods interface{} = map[string]interface{} {
        "orderbook": this.HandleOrderBook,
        "ticker": this.HandleTicker,
        "trades": this.HandleTrade,
        "orders": this.HandleOrder,
        "mytrades": this.HandleMyTrade,
    }
    var event interface{} = nil
    var params interface{} = this.SafeDict(message, "params")
    if ccxt.IsTrue(!ccxt.IsEqual(params, nil)) {
        var channel interface{} = this.SafeString(params, "channel")
        if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
            var parsedChannel interface{} = ccxt.Split(channel, ".")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, "orders"), 0))) || ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "trades"), 0))) {
                event = this.SafeString(parsedChannel, 1)
                // {subaccounr_id}.trades
                if ccxt.IsTrue(ccxt.IsEqual(event, "trades")) {
                    event = "mytrades"
                }
            } else {
                event = this.SafeString(parsedChannel, 0)
            }
        }
    }
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
        return
    }
    if ccxt.IsTrue(ccxt.InOp(message, "id")) {
        var id interface{} = this.SafeString(message, "id")
        var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
        var subscription interface{} = this.SafeValue(subscriptionsById, id, map[string]interface{} {})
        if ccxt.IsTrue(ccxt.InOp(subscription, "method")) {
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(subscription, "method"), "public/login")) {
                this.HandleAuth(client, message)
            } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(subscription, "method"), "unsubscribe")) {
                this.HandleUnSubscribe(client, message)
            }
        }
    }
}
func  (this *DeriveCore) HandleAuth(client interface{}, message interface{})  {
    //
    // {
    //     id: 1,
    //     result: [ 130837 ]
    // }
    //
    var messageHash interface{} = "authenticated"
    var ids interface{} = this.SafeList(message, "result")
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(ids), 0)) {
        // client.resolve (message, messageHash)
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        // allows further authentication attempts
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
        }
    }
}


func (this *DeriveCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
