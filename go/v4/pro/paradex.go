package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ParadexCore struct {
	*ccxt.ParadexCore
	base *ccxt.ParadexCore
}

func NewParadexCore() *ParadexCore {
    p := &ParadexCore{}
	base := &ccxt.ParadexCore{}
	p.base = base
	p.ParadexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ParadexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchOrderBook": true,
            "watchOrders": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchBalance": false,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://x.com/tradeparadex/photo",
            "api": map[string]interface{} {
                "ws": "wss://ws.api.prod.paradex.trade/v1",
            },
            "test": map[string]interface{} {
                "ws": "wss://ws.api.testnet.paradex.trade/v1",
            },
            "www": "https://www.paradex.trade/",
            "doc": "https://docs.api.testnet.paradex.trade/",
            "fees": "https://docs.paradex.trade/getting-started/trading-fees",
            "referral": "",
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
    })
}
/**
 * @method
 * @name paradex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.api.testnet.paradex.trade/#sub-trades-market_symbol-operation
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ParadexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes548)
            var messageHash interface{} = "trades."
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.GetValue(market, "id"))
            } else {
                messageHash = ccxt.Add(messageHash, "ALL")
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": messageHash,
                },
            }
        
            trades:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ParadexCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "trades.ALL",
    //             "data": {
    //                 "id": "1718179273230201709233240002",
    //                 "market": "kBONK-USD-PERP",
    //                 "side": "BUY",
    //                 "size": "34028",
    //                 "price": "0.028776",
    //                 "created_at": 1718179273230,
    //                 "trade_type": "FILL"
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeDict(params, "data", map[string]interface{} {})
    var parsedTrade interface{} = this.ParseTrade(data)
    var symbol interface{} = ccxt.GetValue(parsedTrade, "symbol")
    var messageHash interface{} = this.SafeString(params, "channel")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        stored = ccxt.NewArrayCache(this.SafeInteger(this.Options, "tradesLimit", 1000))
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(parsedTrade)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name paradex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.api.testnet.paradex.trade/#sub-order_book-market_symbol-snapshot-15-refresh_rate-operation
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ParadexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1228)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("order_book.", ccxt.GetValue(market, "id")), ".snapshot@15@100ms")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": messageHash,
                },
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ParadexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "order_book.BTC-USD-PERP.snapshot@15@50ms",
    //             "data": {
    //                 "seq_no": 14127815,
    //                 "market": "BTC-USD-PERP",
    //                 "last_updated_at": 1718267837265,
    //                 "update_type": "s",
    //                 "inserts": [
    //                     {
    //                         "side": "BUY",
    //                         "price": "67629.7",
    //                         "size": "0.992"
    //                     },
    //                     {
    //                         "side": "SELL",
    //                         "price": "69378.6",
    //                         "size": "3.137"
    //                     }
    //                 ],
    //                 "updates": [],
    //                 "deletes": []
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeDict(params, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "market")
    var market interface{} = this.SafeMarket(marketId)
    var timestamp interface{} = this.SafeInteger(data, "last_updated_at")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbookData interface{} = map[string]interface{} {
        "bids": []interface{}{},
        "asks": []interface{}{},
    }
    var inserts interface{} = this.SafeList(data, "inserts")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(inserts)); i++ {
        var insert interface{} = this.SafeDict(inserts, i)
        var side interface{} = this.SafeString(insert, "side")
        var price interface{} = this.SafeString(insert, "price")
        var size interface{} = this.SafeString(insert, "size")
        if ccxt.IsTrue(ccxt.IsEqual(side, "BUY")) {
            retRes18716 := ccxt.GetValue(orderbookData, "bids")
            ccxt.AppendToArray(&retRes18716, []interface{}{price, size})
        } else {
            retRes18916 := ccxt.GetValue(orderbookData, "asks")
            ccxt.AppendToArray(&retRes18916, []interface{}{price, size})
        }
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(orderbookData, symbol, timestamp, "bids", "asks")
    ccxt.AddElementToObject(snapshot, "nonce", this.SafeNumber(data, "seq_no"))
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = this.SafeString(params, "channel")
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name paradex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.api.testnet.paradex.trade/#sub-markets_summary-operation
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ParadexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2108)
            symbol = this.Symbol(symbol)
            var channel interface{} = "markets_summary"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": channel,
                },
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "."), symbol)
        
                retRes22215 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes22215)
                ch <- retRes22215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paradex#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.api.testnet.paradex.trade/#sub-markets_summary-operation
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ParadexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2358)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = "markets_summary"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channel": channel,
                },
            }
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsArray(symbols)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "."), ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&messageHashes, messageHash)
                }
            } else {
                ccxt.AppendToArray(&messageHashes, channel)
            }
        
            newTickers:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), messageHashes))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ParadexCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "markets_summary",
    //             "data": {
    //                 "symbol": "ORDI-USD-PERP",
    //                 "oracle_price": "49.80885481",
    //                 "mark_price": "49.80885481",
    //                 "last_traded_price": "62.038",
    //                 "bid": "49.822",
    //                 "ask": "58.167",
    //                 "volume_24h": "0",
    //                 "total_volume": "54542628.66054200416",
    //                 "created_at": 1718334307698,
    //                 "underlying_price": "47.93",
    //                 "open_interest": "6999.5",
    //                 "funding_rate": "0.03919997509811",
    //                 "price_change_rate_24h": ""
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeDict(params, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var channel interface{} = this.SafeString(params, "channel")
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "."), symbol)
    var ticker interface{} = this.ParseTicker(data, market)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, channel)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    return message
}
func  (this *ParadexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "id": 0,
    //         "error": {
    //             "code": -32600,
    //             "message": "invalid subscribe request",
    //             "data": "invalid channel"
    //         },
    //         "usIn": 1718179125962419,
    //         "usDiff": 76,
    //         "usOut": 1718179125962495
    //     }
    //
    var error interface{} = this.SafeDict(message, "error")
    if ccxt.IsTrue(ccxt.IsEqual(error, nil)) {
        return true
    } else {
        var errorCode interface{} = this.SafeString(error, "code")
        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
            var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(error))
            this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), "-32600", feedback)
            var messageString interface{} = this.SafeValue(error, "message")
            if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
            }
        }
        return false
    }
}
func  (this *ParadexCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "trades.ALL",
    //             "data": {
    //                 "id": "1718179273230201709233240002",
    //                 "market": "kBONK-USD-PERP",
    //                 "side": "BUY",
    //                 "size": "34028",
    //                 "price": "0.028776",
    //                 "created_at": 1718179273230,
    //                 "trade_type": "FILL"
    //             }
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "params")
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        var channel interface{} = this.SafeString(data, "channel")
        var parts interface{} = ccxt.Split(channel, ".")
        var name interface{} = this.SafeString(parts, 0)
        var methods interface{} = map[string]interface{} {
            "trades": this.HandleTrade,
            "order_book": this.HandleOrderBook,
            "markets_summary": this.HandleTicker,
        }
        var method interface{} = this.SafeValue(methods, name)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *ParadexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
