package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type OxfunCore struct {
	*ccxt.OxfunCore
	base *ccxt.OxfunCore
}

func NewOxfunCore() *OxfunCore {
    p := &OxfunCore{}
	base := &ccxt.OxfunCore{}
	p.base = base
	p.OxfunCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *OxfunCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrders": true,
            "watchMyTrades": false,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchBalance": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.ox.fun/v2/websocket",
                "test": "wss://stgapi.ox.fun/v2/websocket",
            },
        },
        "options": map[string]interface{} {
            "timeframes": map[string]interface{} {
                "1m": "60s",
                "3m": "180s",
                "5m": "300s",
                "15m": "900s",
                "30m": "1800s",
                "1h": "3600s",
                "2h": "7200s",
                "4h": "14400s",
                "6h": "21600s",
                "12h": "43200s",
                "1d": "86400s",
            },
            "watchOrderBook": map[string]interface{} {
                "channel": "depth",
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 50000,
        },
    })
}
func  (this *OxfunCore) SubscribeMultiple(messageHashes interface{}, argsArray interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": argsArray,
            }
        
                retRes7115 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
                ccxt.PanicOnError(retRes7115)
                ch <- retRes7115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.ox.fun/?json#trade
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *OxfunCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes8715 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes8715)
                ch <- retRes8715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.ox.fun/?json#trade
 * @param {string[]} symbols
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *OxfunCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1038)
            symbols = this.MarketSymbols(symbols, nil, false)
            var args interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var messageHash interface{} = ccxt.Add(ccxt.Add("trades", ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                var marketId interface{} = this.MarketId(symbol)
                var arg interface{} = ccxt.Add("trade:", marketId)
                ccxt.AppendToArray(&args, arg)
            }
        
            trades:= (<-this.SubscribeMultiple(messageHashes, args, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0, map[string]interface{} {})
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         table: 'trade',
    //         data: [
    //             {
    //                 side: 'SELL',
    //                 quantity: '0.074',
    //                 matchType: 'TAKER',
    //                 price: '3079.5',
    //                 marketCode: 'ETH-USD-SWAP-LIN',
    //                 tradeId: '400017157974517783',
    //                 timestamp: '1716124156643'
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.SafeDict(data, i, map[string]interface{} {})
        var parsedTrade interface{} = this.ParseWsTrade(trade)
        var symbol interface{} = this.SafeString(parsedTrade, "symbol")
        var messageHash interface{} = ccxt.Add("trades:", symbol)
        if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
            var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(tradesLimit))
        }
        var stored interface{} = ccxt.GetValue(this.Trades, symbol)
        stored.(ccxt.Appender).Append(parsedTrade)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
func  (this *OxfunCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         side: 'SELL',
    //         quantity: '0.074',
    //         matchType: 'TAKER',
    //         price: '3079.5',
    //         marketCode: 'ETH-USD-SWAP-LIN',
    //         tradeId: '400017157974517783',
    //         timestamp: '1716124156643'
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "marketCode")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": this.SafeString(trade, "tradeId"),
        "order": nil,
        "type": nil,
        "takerOrMaker": this.SafeStringLower(trade, "matchType"),
        "side": this.SafeStringLower(trade, "side"),
        "price": this.SafeNumber(trade, "price"),
        "amount": this.SafeNumber(trade, "quantity"),
        "cost": nil,
        "fee": nil,
    })
}
/**
 * @method
 * @name oxfun#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.ox.fun/?json#candles
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OxfunCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2038)
            var market interface{} = this.Market(symbol)
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var args interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles", interval), ":"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
        
            ohlcvs:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(ohlcvs)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcvs).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcvs, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.ox.fun/?json#candles
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OxfunCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT:OX\\', \\'1m\\'], [\\'OX/USDT\\', \\'5m\\']]")))
            }
        
            retRes2388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2388)
            var args interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var sym interface{} = ccxt.GetValue(symbolAndTimeframe, 0)
                var tf interface{} = ccxt.GetValue(symbolAndTimeframe, 1)
                var marketId interface{} = this.MarketId(sym)
                var interval interface{} = this.SafeString(timeframes, tf, tf)
                var arg interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles", interval), ":"), marketId)
                ccxt.AppendToArray(&args, arg)
                var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("multi:ohlcv:", sym), ":"), tf)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            symboltimeframecandlesVariable := (<-this.SubscribeMultiple(messageHashes, args, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "candles60s",
    //         "data": [
    //             {
    //                 "marketCode": "BTC-USD-SWAP-LIN",
    //                 "candle": [
    //                     "1594313762698", //timestamp
    //                     "9633.1",        //open
    //                     "9693.9",        //high
    //                     "9238.1",        //low
    //                     "9630.2",        //close
    //                     "45247",         //volume in OX
    //                     "5.3"            //volume in Contracts
    //                 ]
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var parts interface{} = ccxt.Split(table, "candles")
    var timeframeId interface{} = this.SafeString(parts, 1, "")
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var messageData interface{} = this.SafeList(message, "data", []interface{}{})
    var data interface{} = this.SafeDict(messageData, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "marketCode")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var candle interface{} = this.SafeList(data, "candle", []interface{}{})
    var parsed interface{} = this.ParseWsOHLCV(candle, market)
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframe)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    // for multiOHLCV we need special object, as opposed to other "multi"
    // methods, because ccxt.OHLCV response item does not contain symbol
    // or timeframe, thus otherwise it would be unrecognizable
    var messageHashForMulti interface{} = ccxt.Add("multi:", messageHash)
    client.(ccxt.ClientInterface).Resolve([]interface{}{symbol, timeframe, stored}, messageHashForMulti)
}
func  (this *OxfunCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1594313762698", //timestamp
    //         "9633.1",        //open
    //         "9693.9",        //high
    //         "9238.1",        //low
    //         "9630.2",        //close
    //         "45247",         //volume in OX
    //         "5.3"            //volume in Contracts
    //     ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 6)}
}
/**
 * @method
 * @name oxfun#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.ox.fun/?json#fixed-size-order-book
 * @see https://docs.ox.fun/?json#full-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *OxfunCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes34415 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes34415)
                ch <- retRes34415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.ox.fun/?json#fixed-size-order-book
 * @see https://docs.ox.fun/?json#full-order-book
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *OxfunCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3608 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3608)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = "depth"
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var defaultChannel interface{} = this.SafeString(options, "channel")
            if ccxt.IsTrue(!ccxt.IsEqual(defaultChannel, nil)) {
                channel = defaultChannel
            } else if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsLessThanOrEqual(limit, 5)) {
                    channel = "depthL5"
                } else if ccxt.IsTrue(ccxt.IsLessThanOrEqual(limit, 10)) {
                    channel = "depthL10"
                } else if ccxt.IsTrue(ccxt.IsLessThanOrEqual(limit, 25)) {
                    channel = "depthL25"
                }
            }
            var args interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var messageHash interface{} = ccxt.Add("orderbook:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                var marketId interface{} = this.MarketId(symbol)
                var arg interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
                ccxt.AppendToArray(&args, arg)
            }
        
            orderbook:= (<-this.SubscribeMultiple(messageHashes, args, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "depth",
    //         "data": {
    //             "seqNum": "100170478917895032",
    //             "asks": [
    //                 [ 0.01, 100500 ],
    //                 ...
    //             ],
    //             "bids": [
    //                 [ 69.69696, 69 ],
    //                 ...
    //             ],
    //             "checksum": 261021645,
    //             "marketCode": "OX-USDT",
    //             "timestamp": 1716204786184
    //         },
    //         "action": "partial"
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "marketCode")
    var symbol interface{} = this.SafeSymbol(marketId)
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "asks", "bids")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "seqNum"))
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name oxfun#watchTicker
 * @see https://docs.ox.fun/?json#ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OxfunCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            ticker:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(ticker)
        
            ch <- this.SafeValue(ticker, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#watchTickers
 * @see https://docs.ox.fun/?json#ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OxfunCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4538)
            var allSymbols interface{} =     (ccxt.IsEqual(symbols, nil))
            var sym interface{} = symbols
            var args interface{} = []interface{}{}
            if ccxt.IsTrue(allSymbols) {
                sym = this.Symbols
                ccxt.AppendToArray(&args, "ticker:all")
            }
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(sym)); i++ {
                var symbol interface{} = ccxt.GetValue(sym, i)
                var messageHash interface{} = ccxt.Add(ccxt.Add("tickers", ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                var marketId interface{} = this.MarketId(symbol)
                if !ccxt.IsTrue(allSymbols) {
                    ccxt.AppendToArray(&args, ccxt.Add("ticker:", marketId))
                }
            }
        
            newTicker:= (<-this.SubscribeMultiple(messageHashes, args, params))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "ticker",
    //         "data": [
    //             {
    //                 "last": "3088.6",
    //                 "open24h": "3087.2",
    //                 "high24h": "3142.0",
    //                 "low24h": "3053.9",
    //                 "volume24h": "450512672.1800",
    //                 "currencyVolume24h": "1458.579",
    //                 "openInterest": "3786.801",
    //                 "marketCode": "ETH-USD-SWAP-LIN",
    //                 "timestamp": "1716212747050",
    //                 "lastQty": "0.813",
    //                 "markPrice": "3088.6",
    //                 "lastMarkPrice": "3088.6",
    //                 "indexPrice": "3086.5"
    //             },
    //             ...
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawTicker interface{} = this.SafeDict(data, i, map[string]interface{} {})
        var ticker interface{} = this.ParseTicker(rawTicker)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        var messageHash interface{} = ccxt.Add("tickers:", symbol)
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
/**
 * @method
 * @name oxfun#watchBidsAsks
 * @see https://docs.ox.fun/?json#best-bid-ask
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OxfunCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5258)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&args, ccxt.Add("bestBidAsk:", ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(market, "symbol")))
            }
        
            newTickers:= (<-this.SubscribeMultiple(messageHashes, args, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //       "table": "bestBidAsk",
    //       "data": {
    //         "ask": [
    //           19045.0,
    //           1.0
    //         ],
    //         "checksum": 3790706311,
    //         "marketCode": "BTC-USD-SWAP-LIN",
    //         "bid": [
    //           19015.0,
    //           1.0
    //         ],
    //         "timestamp": "1665456882928"
    //       }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var parsedTicker interface{} = this.ParseWsBidAsk(data)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *OxfunCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "marketCode")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var ask interface{} = this.SafeList(ticker, "ask", []interface{}{})
    var bid interface{} = this.SafeList(ticker, "bid", []interface{}{})
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(ask, 0),
        "askVolume": this.SafeNumber(ask, 1),
        "bid": this.SafeNumber(bid, 0),
        "bidVolume": this.SafeNumber(bid, 1),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name oxfun#watchBalance
 * @see https://docs.ox.fun/?json#balance-channel
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *OxfunCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5998)
            this.Authenticate()
            var args interface{} = "balance:all"
            var messageHash interface{} = "balance"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
        
                retRes60815 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes60815)
                ch <- retRes60815
                return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "balance",
    //         "accountId": "106464",
    //         "timestamp": "1716549132780",
    //         "tradeType": "PORTFOLIO",
    //         "data": [
    //             {
    //                 "instrumentId": "xOX",
    //                 "total": "23.375591220",
    //                 "available": "23.375591220",
    //                 "reserved": "0",
    //                 "quantityLastUpdated": "1716509744262",
    //                 "locked": "0"
    //             },
    //             ...
    //         ]
    //     }
    //
    var balances interface{} = this.SafeList(message, "data")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(this.Balance, "info", message)
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
        var balance interface{} = this.SafeDict(balances, i, map[string]interface{} {})
        var currencyId interface{} = this.SafeString(balance, "instrumentId")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if !ccxt.IsTrue((ccxt.InOp(this.Balance, code))) {
            ccxt.AddElementToObject(this.Balance, code, this.Account())
        }
        var account interface{} = ccxt.GetValue(this.Balance, code)
        ccxt.AddElementToObject(account, "total", this.SafeString(balance, "total"))
        ccxt.AddElementToObject(account, "used", this.SafeString(balance, "reserved"))
        ccxt.AddElementToObject(account, "free", this.SafeString(balance, "available"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
}
/**
 * @method
 * @name oxfun#watchPositions
 * @see https://docs.ox.fun/?json#position-channel
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *OxfunCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6668)
        
            retRes6678 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6678)
            var allSymbols interface{} =     (ccxt.IsEqual(symbols, nil))
            var sym interface{} = symbols
            var args interface{} = []interface{}{}
            if ccxt.IsTrue(allSymbols) {
                sym = this.Symbols
                ccxt.AppendToArray(&args, "position:all")
            }
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(sym)); i++ {
                var symbol interface{} = ccxt.GetValue(sym, i)
                var messageHash interface{} = ccxt.Add(ccxt.Add("positions", ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                var marketId interface{} = this.MarketId(symbol)
                if !ccxt.IsTrue(allSymbols) {
                    ccxt.AppendToArray(&args, ccxt.Add("position:", marketId))
                }
            }
        
            newPositions:= (<-this.SubscribeMultiple(messageHashes, args, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "position",
    //         "accountId": "106464",
    //         "timestamp": "1716550771582",
    //         "data": [
    //             {
    //                 "instrumentId": "ETH-USD-SWAP-LIN",
    //                 "quantity": "0.01",
    //                 "lastUpdated": "1716550757299",
    //                 "contractValCurrency": "ETH",
    //                 "entryPrice": "3709.6",
    //                 "positionPnl": "-5.000",
    //                 "estLiquidationPrice": "743.4",
    //                 "margin": "0",
    //                 "leverage": "0"
    //             }
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawPosition interface{} = this.SafeDict(data, i, map[string]interface{} {})
        var position interface{} = this.ParseWsPosition(rawPosition)
        var symbol interface{} = ccxt.GetValue(position, "symbol")
        var messageHash interface{} = ccxt.Add("positions:", symbol)
        cache.(ccxt.Appender).Append(position)
        client.(ccxt.ClientInterface).Resolve(position, messageHash)
    }
}
func  (this *OxfunCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrumentId": "ETH-USD-SWAP-LIN",
    //         "quantity": "0.01",
    //         "lastUpdated": "1716550757299",
    //         "contractValCurrency": "ETH",
    //         "entryPrice": "3709.6",
    //         "positionPnl": "-5.000",
    //         "estLiquidationPrice": "743.4",
    //         "margin": "0", // Currently always reports 0
    //         "leverage": "0" // Currently always reports 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "instrumentId")
    market = this.SafeMarket(marketId, market)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": ccxt.GetValue(market, "symbol"),
        "notional": nil,
        "marginMode": "cross",
        "liquidationPrice": this.SafeNumber(position, "estLiquidationPrice"),
        "entryPrice": this.SafeNumber(position, "entryPrice"),
        "unrealizedPnl": this.SafeNumber(position, "positionPnl"),
        "realizedPnl": nil,
        "percentage": nil,
        "contracts": this.SafeNumber(position, "quantity"),
        "contractSize": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "side": nil,
        "hedged": nil,
        "timestamp": nil,
        "datetime": nil,
        "lastUpdateTimestamp": this.SafeInteger(position, "lastUpdated"),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name oxfun#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.ox.fun/?json#order-channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int|string} [params.tag] If given it will be echoed in the reply and the max size of tag is 32
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OxfunCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7898)
        
            retRes7908 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7908)
            var messageHash interface{} = "orders"
            var args interface{} = "order:"
            var market interface{} = this.SafeMarket(symbol)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                args = ccxt.Add(args, "all")
            } else {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
                args = ccxt.Add(args, ccxt.Add(":", ccxt.GetValue(market, "id")))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "order",
    //         "data": [
    //             {
    //                 "accountId": "106464",
    //                 "clientOrderId": "1716713676233",
    //                 "orderId": "1000116921319",
    //                 "price": "1000.0",
    //                 "quantity": "0.01",
    //                 "amount": "0.0",
    //                 "side": "BUY",
    //                 "status": "OPEN",
    //                 "marketCode": "ETH-USD-SWAP-LIN",
    //                 "timeInForce": "MAKER_ONLY",
    //                 "timestamp": "1716713677834",
    //                 "remainQuantity": "0.01",
    //                 "limitPrice": "1000.0",
    //                 "notice": "OrderOpened",
    //                 "orderType": "LIMIT",
    //                 "isTriggered": "false",
    //                 "displayQuantity": "0.01"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var messageHash interface{} = "orders"
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = this.SafeDict(data, i, map[string]interface{} {})
        var parsedOrder interface{} = this.ParseOrder(order)
        orders.(ccxt.Appender).Append(parsedOrder)
        messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(parsedOrder, "symbol")))
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    }
}
/**
 * @method
 * @name oxfun#createOrderWs
 * @see https://docs.ox.fun/?json#order-commands
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'STOP_LIMIT' or 'STOP_MARKET'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.clientOrderId] a unique id for the order
 * @param {int} [params.timestamp] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected.
 * @param {int} [params.recvWindow] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {float} [params.limitPrice] ccxt.Limit price for the STOP_LIMIT order
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @param {string} [params.timeInForce] GTC (default), IOC, FOK, PO, MAKER_ONLY or MAKER_ONLY_REPRICE (reprices order to the best maker only price if the specified price were to lead to a taker trade)
 * @param {string} [params.selfTradePreventionMode] NONE, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH for more info check here {@link https://docs.ox.fun/?json#self-trade-prevention-modes}
 * @param {string} [params.displayQuantity] for an iceberg order, pass both quantity and displayQuantity fields in the order request
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OxfunCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8818)
        
            retRes8828 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8828)
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var request interface{} = map[string]interface{} {
                "op": "placeorder",
                "tag": messageHash,
            }
            params = this.Omit(params, "tag")
            var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var timestamp interface{} = this.SafeInteger(orderRequest, "timestamp")
            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                ccxt.AddElementToObject(orderRequest, "timestamp", this.Milliseconds())
            }
            ccxt.AddElementToObject(request, "data", orderRequest)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes89615 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes89615)
                ch <- retRes89615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#editOrderWs
 * @description edit a trade order
 * @see https://docs.ox.fun/?json#modify-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.timestamp] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected.
 * @param {int} [params.recvWindow] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OxfunCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9168)
        
            retRes9178 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9178)
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var request interface{} = map[string]interface{} {
                "op": "modifyorder",
                "tag": messageHash,
            }
            params = this.Omit(params, "tag")
            var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            orderRequest = this.Extend(orderRequest, map[string]interface{} {
                "orderId": id,
            })
            var timestamp interface{} = this.SafeInteger(orderRequest, "timestamp")
            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                ccxt.AddElementToObject(orderRequest, "timestamp", this.Milliseconds())
            }
            ccxt.AddElementToObject(request, "data", orderRequest)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes93215 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes93215)
                ch <- retRes93215
                return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandlePlaceOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "placeorder",
    //         "submitted": true,
    //         "tag": "1716934577",
    //         "timestamp": "1716932973899",
    //         "data": {
    //             "marketCode": "ETH-USD-SWAP-LIN",
    //             "side": "BUY",
    //             "orderType": "LIMIT",
    //             "quantity": "0.010",
    //             "timeInForce": "GTC",
    //             "price": "400.0",
    //             "limitPrice": "400.0",
    //             "orderId": "1000117429736",
    //             "source": 13
    //         }
    //     }
    //
    //
    // Failure response format
    //     {
    //         "event": "placeorder",
    //         "submitted": false,
    //         "message": "JSON data format is invalid",
    //         "code": "20009",
    //         "timestamp": "1716932877381"
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "tag")
    var submitted interface{} = this.SafeBool(message, "submitted")
    // filter out partial errors
    if !ccxt.IsTrue(submitted) {
        var method interface{} = this.SafeString(message, "event")
        var stringMsg interface{} = this.Json(message)
        var code interface{} = this.SafeInteger(message, "code")
        this.HandleErrors(code, "", client.(ccxt.ClientInterface).GetUrl(), method, map[string]interface{} {}, stringMsg, message, map[string]interface{} {}, map[string]interface{} {})
    }
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var order interface{} = this.ParseOrder(data)
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name oxfun#cancelOrderWs
 * @see https://docs.ox.fun/?json#cancel-order
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OxfunCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " cancelOrderWs() requires a symbol argument")))
            }
        
            retRes9938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9938)
        
            retRes9948 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9948)
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var data interface{} = map[string]interface{} {
                "marketCode": this.MarketId(symbol),
                "orderId": id,
            }
            var request interface{} = map[string]interface{} {
                "op": "cancelorder",
                "tag": messageHash,
                "data": data,
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes100615 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes100615)
                ch <- retRes100615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oxfun#cancelOrdersWs
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-mass-cancel-order
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OxfunCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var idsLength interface{} =     ccxt.GetArrayLength(ids)
            if ccxt.IsTrue(ccxt.IsGreaterThan(idsLength, 20)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrdersWs() accepts up to 20 ids at a time")))
            }
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " cancelOrdersWs() requires a symbol argument")))
            }
        
            retRes10278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10278)
        
            retRes10288 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes10288)
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var marketId interface{} = this.MarketId(symbol)
            var dataArray interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, idsLength); i++ {
                var data interface{} = map[string]interface{} {
                    "instId": marketId,
                    "ordId": ccxt.GetValue(ids, i),
                }
                ccxt.AppendToArray(&dataArray, data)
            }
            var request interface{} = map[string]interface{} {
                "op": "cancelorders",
                "tag": messageHash,
                "dataArray": dataArray,
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes104515 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes104515)
                ch <- retRes104515
                return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
                var timestamp interface{} = this.Milliseconds()
                var payload interface{} = ccxt.Add(ccxt.ToString(timestamp), "GET/auth/self/verify")
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var request interface{} = map[string]interface{} {
                    "op": "login",
                    "data": map[string]interface{} {
                        "apiKey": this.ApiKey,
                        "timestamp": timestamp,
                        "signature": signature,
                    },
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes107015 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes107015)
                ch <- retRes107015
                return nil
        
            }()
            return ch
        }
func  (this *OxfunCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    var authenticated interface{} = this.SafeBool(message, "success", false)
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(authenticated) {
        // we resolve the future here permanently so authentication only happens once
        var future interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
func  (this *OxfunCore) Ping(client interface{}) interface{}  {
    return "ping"
}
func  (this *OxfunCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *OxfunCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var table interface{} = this.SafeString(message, "table")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(table, nil))) && ccxt.IsTrue((!ccxt.IsEqual(data, nil)))) {
        if ccxt.IsTrue(ccxt.IsEqual(table, "trade")) {
            this.HandleTrades(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(table, "ticker")) {
            this.HandleTicker(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(table, "candles"), ccxt.OpNeg(1))) {
            this.HandleOHLCV(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(table, "depth"), ccxt.OpNeg(1))) {
            this.HandleOrderBook(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(table, "balance"), ccxt.OpNeg(1))) {
            this.HandleBalance(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(table, "position"), ccxt.OpNeg(1))) {
            this.HandlePositions(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(table, "order"), ccxt.OpNeg(1))) {
            this.HandleOrders(client, message)
        }
        if ccxt.IsTrue(ccxt.IsEqual(table, "bestBidAsk")) {
            this.HandleBidAsk(client, message)
        }
    } else {
        if ccxt.IsTrue(ccxt.IsEqual(event, "login")) {
            this.HandleAuthenticationMessage(client, message)
        }
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(event, "placeorder"))) || ccxt.IsTrue((ccxt.IsEqual(event, "modifyorder")))) || ccxt.IsTrue((ccxt.IsEqual(event, "cancelorder")))) {
            this.HandlePlaceOrders(client, message)
        }
    }
}


func (this *OxfunCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
