package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type P2bCore struct {
	*ccxt.P2bCore
	base *ccxt.P2bCore
}

func NewP2bCore() *P2bCore {
    p := &P2bCore{}
	base := &ccxt.P2bCore{}
	p.base = base
	p.P2bCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *P2bCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelAllOrdersWs": false,
            "cancelOrdersWs": false,
            "cancelOrderWs": false,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchBalanceWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "fetchTradesWs": false,
            "watchBalance": false,
            "watchMyTrades": false,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": false,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://apiws.p2pb2b.com/",
            },
        },
        "options": map[string]interface{} {
            "OHLCVLimit": 1000,
            "tradesLimit": 1000,
            "timeframes": map[string]interface{} {
                "15m": 900,
                "30m": 1800,
                "1h": 3600,
                "1d": 86400,
            },
            "watchTicker": map[string]interface{} {
                "name": "state",
            },
            "watchTickers": map[string]interface{} {
                "name": "state",
            },
            "tickerSubs": this.CreateSafeDictionary(),
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
    })
}
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @param {string} name name of the channel
 * @param {string} messageHash string to look up in handler
 * @param {string[]|float[]} request endpoint parameters
 * @param {object} [params] extra parameters specific to the p2b api
 * @returns {object} data from the websocket stream
 */
func  (this *P2bCore) Subscribe(name interface{}, messageHash interface{}, request interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "method": name,
                "params": request,
                "id": this.Milliseconds(),
            }
            var query interface{} = this.Extend(subscribe, params)
        
                retRes8115 :=  (<-this.Watch(url, messageHash, query, messageHash))
                ccxt.PanicOnError(retRes8115)
                ch <- retRes8115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market. Can only subscribe to one timeframe at a time for each symbol
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#kline-candlestick
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe 15m, 30m, 1h or 1d
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *P2bCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "15m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes978 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes978)
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var channel interface{} = this.SafeInteger(timeframes, timeframe)
            if ccxt.IsTrue(ccxt.IsEqual(channel, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(this.Id, " watchOHLCV cannot take a timeframe of "), timeframe)))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = []interface{}{ccxt.GetValue(market, "id"), channel}
            var messageHash interface{} = ccxt.Add("kline::", ccxt.GetValue(market, "symbol"))
        
            ohlcv:= (<-this.Subscribe("kline.subscribe", messageHash, request, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#last-price
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#market-status
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.method] 'state' (default) or 'price'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *P2bCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1288)
            var watchTickerOptions interface{} = this.SafeDict(this.Options, "watchTicker")
            var name interface{} = this.SafeString(watchTickerOptions, "name", "state") // or price
            nameparamsVariable := this.HandleOptionAndParams(params, "method", "name", name)
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(ccxt.GetValue(this.Options, "tickerSubs"), ccxt.GetValue(market, "id"), true) // we need to re-subscribe to all tickers upon watching a new ticker
            var tickerSubs interface{} = ccxt.GetValue(this.Options, "tickerSubs")
            var request interface{} = ccxt.ObjectKeys(tickerSubs)
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, "::"), ccxt.GetValue(market, "symbol"))
        
                retRes13815 :=  (<-this.Subscribe(ccxt.Add(name, ".subscribe"), messageHash, request, params))
                ccxt.PanicOnError(retRes13815)
                ch <- retRes13815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchTickers
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#last-price
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#market-status
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.method] 'state' (default) or 'price'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *P2bCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1538)
            symbols = this.MarketSymbols(symbols, nil, false)
            var watchTickerOptions interface{} = this.SafeDict(this.Options, "watchTicker")
            var name interface{} = this.SafeString(watchTickerOptions, "name", "state") // or price
            nameparamsVariable := this.HandleOptionAndParams(params, "method", "name", name)
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, "::"), ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&args, ccxt.GetValue(market, "id"))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "method": ccxt.Add(name, ".subscribe"),
                "params": args,
                "id": this.Milliseconds(),
            }
        
            retRes1718 := (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(retRes1718)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#deals
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *P2bCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes18715 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes18715)
                ch <- retRes18715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#deals
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *P2bCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2028)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("deals::", ccxt.GetValue(symbols, i)))
                }
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "method": "deals.subscribe",
                "params": marketIds,
                "id": this.Milliseconds(),
            }
            var query interface{} = this.Extend(subscribe, params)
        
            trades:= (<-this.WatchMultiple(url, messageHashes, query, messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#depth-of-market
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] 1-100, default=100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.interval] 0, 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, interval of precision for order, default=0.001
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *P2bCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2398)
            var market interface{} = this.Market(symbol)
            var name interface{} = "depth.subscribe"
            var messageHash interface{} = ccxt.Add("orderbook::", ccxt.GetValue(market, "symbol"))
            var interval interface{} = this.SafeString(params, "interval", "0.001")
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 100
            }
            var request interface{} = []interface{}{ccxt.GetValue(market, "id"), limit, interval}
        
            orderbook:= (<-this.Subscribe(name, messageHash, request, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *P2bCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "method": "kline.update",
    //        "params": [
    //            [
    //                1657648800,             // Kline start time
    //                "0.054146",             // Kline open price
    //                "0.053938",             // Kline close price (current price)
    //                "0.054146",             // Kline high price
    //                "0.053911",             // Kline low price
    //                "596.4674",             // Volume for stock currency
    //                "32.2298758767",        // Volume for money currency
    //                "ETH_BTC"               // ccxt.Market
    //            ]
    //        ],
    //        "id": null
    //    }
    //
    var data interface{} = this.SafeList(message, "params")
    data = this.SafeList(data, 0)
    var method interface{} = this.SafeString(message, "method")
    var splitMethod interface{} = ccxt.Split(method, ".")
    var channel interface{} = this.SafeString(splitMethod, 0)
    var marketId interface{} = this.SafeString(data, 7)
    var market interface{} = this.SafeMarket(marketId)
    var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
    var timeframe interface{} = this.FindTimeframe(channel, timeframes)
    var symbol interface{} = this.SafeString(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "::"), symbol)
    var parsed interface{} = this.ParseOHLCV(data, market)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *P2bCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "method": "deals.update",
    //        "params": [
    //            "ETH_BTC",
    //            [
    //                {
    //                    "id": 4503032979,               // Order_id
    //                    "amount": "0.103",
    //                    "type": "sell",                 // Side
    //                    "time": 1657661950.8487639,     // Creation time
    //                    "price": "0.05361"
    //                },
    //                ...
    //            ]
    //        ],
    //        "id": null
    //    }
    //
    var data interface{} = this.SafeList(message, "params", []interface{}{})
    var trades interface{} = this.SafeList(data, 1)
    var marketId interface{} = this.SafeString(data, 0)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeString(market, "symbol")
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(tradesLimit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var item interface{} = ccxt.GetValue(trades, i)
        var trade interface{} = this.ParseTrade(item, market)
        tradesArray.(ccxt.Appender).Append(trade)
    }
    var messageHash interface{} = ccxt.Add("deals::", symbol)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    return message
}
func  (this *P2bCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    // state
    //
    //    {
    //        "method": "state.update",
    //        "params": [
    //            "ETH_BTC",
    //            {
    //                "high": "0.055774",         // High price for the last 24h
    //                "close": "0.053679",        // Close price for the last 24h
    //                "low": "0.053462",          // Low price for the last 24h
    //                "period": 86400,            // Period 24h
    //                "last": "0.053679",         // Last price for the last 24h
    //                "volume": "38463.6132",     // Stock volume for the last 24h
    //                "open": "0.055682",         // Open price for the last 24h
    //                "deal": "2091.0038055314"   // Money volume for the last 24h
    //            }
    //        ],
    //        "id": null
    //    }
    //
    // price
    //
    //    {
    //        "method": "price.update",
    //        "params": [
    //            "ETH_BTC",      // market
    //            "0.053836"      // last price
    //        ],
    //        "id": null
    //    }
    //
    var data interface{} = this.SafeList(message, "params", []interface{}{})
    var marketId interface{} = this.SafeString(data, 0)
    var market interface{} = this.SafeMarket(marketId)
    var method interface{} = this.SafeString(message, "method")
    var splitMethod interface{} = ccxt.Split(method, ".")
    var messageHashStart interface{} = this.SafeString(splitMethod, 0)
    var tickerData interface{} = this.SafeDict(data, 1)
    var ticker interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(method, "price.update")) {
        var lastPrice interface{} = this.SafeString(data, 1)
        ticker = this.SafeTicker(map[string]interface{} {
            "last": lastPrice,
            "close": lastPrice,
            "symbol": ccxt.GetValue(market, "symbol"),
        })
    } else {
        ticker = this.ParseTicker(tickerData, market)
    }
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add(ccxt.Add(messageHashStart, "::"), symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    return message
}
func  (this *P2bCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "method": "depth.update",
    //        "params": [
    //            false,                          // true - all records, false - new records
    //            {
    //                "asks": [                   // side
    //                    [
    //                        "19509.81",         // price
    //                        "0.277"             // amount
    //                    ]
    //                ]
    //            },
    //            "BTC_USDT"
    //        ],
    //        "id": null
    //    }
    //
    var params interface{} = this.SafeList(message, "params", []interface{}{})
    var data interface{} = this.SafeDict(params, 1)
    var asks interface{} = this.SafeList(data, "asks")
    var bids interface{} = this.SafeList(data, "bids")
    var marketId interface{} = this.SafeString(params, 2)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook::", ccxt.GetValue(market, "symbol"))
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
    var limit interface{} = this.SafeInteger(subscription, "limit")
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
    }
    if ccxt.IsTrue(!ccxt.IsEqual(bids, nil)) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bids)); i++ {
            var bid interface{} = this.SafeValue(bids, i)
            var price interface{} = this.SafeNumber(bid, 0)
            var amount interface{} = this.SafeNumber(bid, 1)
            var bookSide interface{} = ccxt.GetValue(orderbook, "bids")
            bookSide.(ccxt.IOrderBookSide).Store(price, amount)
        }
    }
    if ccxt.IsTrue(!ccxt.IsEqual(asks, nil)) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(asks)); i++ {
            var ask interface{} = this.SafeValue(asks, i)
            var price interface{} = this.SafeNumber(ask, 0)
            var amount interface{} = this.SafeNumber(ask, 1)
            var bookside interface{} = ccxt.GetValue(orderbook, "asks")
            bookside.(ccxt.IOrderBookSide).Store(price, amount)
        }
    }
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *P2bCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var result interface{} = this.SafeString(message, "result")
    if ccxt.IsTrue(ccxt.IsEqual(result, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var method interface{} = this.SafeString(message, "method")
    var methods interface{} = map[string]interface{} {
        "depth.update": this.HandleOrderBook,
        "price.update": this.HandleTicker,
        "kline.update": this.HandleOHLCV,
        "state.update": this.HandleTicker,
        "deals.update": this.HandleTrade,
    }
    var endpoint interface{} = this.SafeValue(methods, method)
    if ccxt.IsTrue(!ccxt.IsEqual(endpoint, nil)) {
        ccxt.CallDynamically(endpoint, client, message)
    }
}
func  (this *P2bCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    var error interface{} = this.SafeString(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " error: "), this.Json(error))))
    }
    return false
}
func  (this *P2bCore) Ping(client interface{}) interface{}  {
    /**
     * @see https://github.com/P2B-team/P2B-WSS-Public/blob/main/wss_documentation.md#ping
     * @param client
     */
    return map[string]interface{} {
        "method": "server.ping",
        "params": []interface{}{},
        "id": this.Milliseconds(),
    }
}
func  (this *P2bCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        error: null,
    //        result: 'pong',
    //        id: 1706539608030
    //    }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.SafeInteger(message, "id"))
    return message
}
func  (this *P2bCore) OnError(client interface{}, error interface{})  {
    ccxt.AddElementToObject(this.Options, "tickerSubs", this.CreateSafeDictionary())
    this.base.OnError(client, error)
}
func  (this *P2bCore) OnClose(client interface{}, error interface{})  {
    ccxt.AddElementToObject(this.Options, "tickerSubs", this.CreateSafeDictionary())
    this.base.OnClose(client, error)
}


func (this *P2bCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
