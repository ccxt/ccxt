package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HtxCore struct {
	*ccxt.HtxCore
	base *ccxt.HtxCore
}

func NewHtxCore() *HtxCore {
    p := &HtxCore{}
	base := &ccxt.HtxCore{}
	p.base = base
	p.HtxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *HtxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "fetchTradesWs": false,
            "fetchBalanceWs": false,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTickers": false,
            "watchTicker": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": true,
            "watchBalance": true,
            "watchOHLCV": true,
            "unwatchTicker": true,
            "unwatchOHLCV": true,
            "unwatchTrades": true,
            "unwatchOrderBook": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "api": map[string]interface{} {
                        "spot": map[string]interface{} {
                            "public": "wss://{hostname}/ws",
                            "private": "wss://{hostname}/ws/v2",
                            "feed": "wss://{hostname}/feed",
                        },
                        "future": map[string]interface{} {
                            "linear": map[string]interface{} {
                                "public": "wss://api.hbdm.com/linear-swap-ws",
                                "private": "wss://api.hbdm.com/linear-swap-notification",
                            },
                            "inverse": map[string]interface{} {
                                "public": "wss://api.hbdm.com/ws",
                                "private": "wss://api.hbdm.com/notification",
                            },
                        },
                        "swap": map[string]interface{} {
                            "inverse": map[string]interface{} {
                                "public": "wss://api.hbdm.com/swap-ws",
                                "private": "wss://api.hbdm.com/swap-notification",
                            },
                            "linear": map[string]interface{} {
                                "public": "wss://api.hbdm.com/linear-swap-ws",
                                "private": "wss://api.hbdm.com/linear-swap-notification",
                            },
                        },
                    },
                    "api-aws": map[string]interface{} {
                        "spot": map[string]interface{} {
                            "public": "wss://api-aws.huobi.pro/ws",
                            "private": "wss://api-aws.huobi.pro/ws/v2",
                            "feed": "wss://{hostname}/feed",
                        },
                        "future": map[string]interface{} {
                            "linear": map[string]interface{} {
                                "public": "wss://api.hbdm.vn/linear-swap-ws",
                                "private": "wss://api.hbdm.vn/linear-swap-notification",
                            },
                            "inverse": map[string]interface{} {
                                "public": "wss://api.hbdm.vn/ws",
                                "private": "wss://api.hbdm.vn/notification",
                            },
                        },
                        "swap": map[string]interface{} {
                            "linear": map[string]interface{} {
                                "public": "wss://api.hbdm.vn/linear-swap-ws",
                                "private": "wss://api.hbdm.vn/linear-swap-notification",
                            },
                            "inverse": map[string]interface{} {
                                "public": "wss://api.hbdm.vn/swap-ws",
                                "private": "wss://api.hbdm.vn/swap-notification",
                            },
                        },
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "api": "api",
            "watchOrderBook": map[string]interface{} {
                "maxRetries": 3,
                "checksum": true,
                "depth": 150,
            },
            "ws": map[string]interface{} {
                "gunzip": true,
            },
            "watchTicker": map[string]interface{} {
                "name": "market.{marketId}.detail",
            },
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "bad-request": ccxt.BadRequest,
                    "2002": ccxt.AuthenticationError,
                    "2021": ccxt.BadRequest,
                    "2001": ccxt.BadSymbol,
                    "2011": ccxt.BadSymbol,
                    "2040": ccxt.BadRequest,
                    "4007": ccxt.BadRequest,
                },
            },
        },
    })
}
func  (this *HtxCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return ccxt.ToString(requestId)
}
/**
 * @method
 * @name htx#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53561-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33ab2-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HtxCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1508)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var options interface{} = this.SafeDict(this.Options, "watchTicker", map[string]interface{} {})
            var topic interface{} = this.SafeString(options, "name", "market.{marketId}.detail")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(topic, "market.{marketId}.ticker")) && ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(market, "type"), "spot"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTicker() with name market.{marketId}.ticker is only allowed for spot markets, use market.{marketId}.detail instead")))
            }
            var messageHash interface{} = this.ImplodeParams(topic, map[string]interface{} {
                "marketId": ccxt.GetValue(market, "id"),
            })
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"))
        
                retRes16015 :=  (<-this.SubscribePublic(url, symbol, messageHash, nil, params))
                ccxt.PanicOnError(retRes16015)
                ch <- retRes16015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name htx#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53561-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33ab2-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HtxCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1748)
            var market interface{} = this.Market(symbol)
            var topic interface{} = "ticker"
            var options interface{} = this.SafeDict(this.Options, "watchTicker", map[string]interface{} {})
            var channel interface{} = this.SafeString(options, "name", "market.{marketId}.detail")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(channel, "market.{marketId}.ticker")) && ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(market, "type"), "spot"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTicker() with name market.{marketId}.ticker is only allowed for spot markets, use market.{marketId}.detail instead")))
            }
            var subMessageHash interface{} = this.ImplodeParams(channel, map[string]interface{} {
                "marketId": ccxt.GetValue(market, "id"),
            })
        
                retRes18315 :=  (<-this.UnsubscribePublic(market, subMessageHash, topic, params))
                ccxt.PanicOnError(retRes18315)
                ch <- retRes18315
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    // "market.btcusdt.detail"
    //     {
    //         "ch": "market.btcusdt.detail",
    //         "ts": 1583494163784,
    //         "tick": {
    //             "id": 209988464418,
    //             "low": 8988,
    //             "high": 9155.41,
    //             "open": 9078.91,
    //             "close": 9136.46,
    //             "vol": 237813910.5928412,
    //             "amount": 26184.202558551195,
    //             "version": 209988464418,
    //             "count": 265673
    //         }
    //     }
    // "market.btcusdt.bbo"
    //     {
    //         "ch": "market.btcusdt.bbo",
    //         "ts": 1671941599613,
    //         "tick": {
    //             "seqId": 161499562790,
    //             "ask": 16829.51,
    //             "askSize": 0.707776,
    //             "bid": 16829.5,
    //             "bidSize": 1.685945,
    //             "quoteTime": 1671941599612,
    //             "symbol": "btcusdt"
    //         }
    //     }
    //
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var ticker interface{} = this.ParseTicker(tick, market)
    var timestamp interface{} = this.SafeValue(message, "ts")
    ccxt.AddElementToObject(ticker, "timestamp", timestamp)
    ccxt.AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, ch)
    return message
}
/**
 * @method
 * @name htx#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53b69-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33c21-77ae-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33cfe-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *HtxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2488)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".trade.detail")
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"))
        
            trades:= (<-this.SubscribePublic(url, symbol, messageHash, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name htx#unWatchTrades
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53b69-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33c21-77ae-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33cfe-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HtxCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2728)
            var market interface{} = this.Market(symbol)
            var topic interface{} = "trades"
            var options interface{} = this.SafeDict(this.Options, "watchTrades", map[string]interface{} {})
            var channel interface{} = this.SafeString(options, "name", "market.{marketId}.trade.detail")
            var subMessageHash interface{} = this.ImplodeParams(channel, map[string]interface{} {
                "marketId": ccxt.GetValue(market, "id"),
            })
        
                retRes27815 :=  (<-this.UnsubscribePublic(market, subMessageHash, topic, params))
                ccxt.PanicOnError(retRes27815)
                ch <- retRes27815
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleTrades(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "ch": "market.btcusdt.trade.detail",
    //         "ts": 1583495834011,
    //         "tick": {
    //             "id": 105004645372,
    //             "ts": 1583495833751,
    //             "data": [
    //                 {
    //                     "id": 1.050046453727319e+22,
    //                     "ts": 1583495833751,
    //                     "tradeId": 102090727790,
    //                     "amount": 0.003893,
    //                     "price": 9150.01,
    //                     "direction": "sell"
    //                 }
    //             ]
    //         }
    //     }
    //
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var data interface{} = this.SafeValue(tick, "data", map[string]interface{} {})
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var tradesCache interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesCache, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesCache = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesCache)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(data, i), market)
        tradesCache.(ccxt.Appender).Append(trade)
    }
    client.(ccxt.ClientInterface).Resolve(tradesCache, ch)
    return message
}
/**
 * @method
 * @name htx#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53241-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c3346a-77ae-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33563-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HtxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3388)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".kline."), interval)
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"))
        
            ohlcv:= (<-this.SubscribePublic(url, symbol, messageHash, nil, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name htx#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53241-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c3346a-77ae-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c33563-77ae-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HtxCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3658)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".kline."), interval)
            var topic interface{} = "ohlcv"
            ccxt.AddElementToObject(params, "symbolsAndTimeframes", []interface{}{[]interface{}{ccxt.GetValue(market, "symbol"), timeframe}})
        
                retRes37115 :=  (<-this.UnsubscribePublic(market, subMessageHash, topic, params))
                ccxt.PanicOnError(retRes37115)
                ch <- retRes37115
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "ch": "market.btcusdt.kline.1min",
    //         "ts": 1583501786794,
    //         "tick": {
    //             "id": 1583501760,
    //             "open": 9094.5,
    //             "close": 9094.51,
    //             "low": 9094.5,
    //             "high": 9094.51,
    //             "amount": 0.44639786263800907,
    //             "vol": 4059.76919054,
    //             "count": 16
    //         }
    //     }
    //
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(parts, 3)
    var timeframe interface{} = this.FindTimeframe(interval)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var tick interface{} = this.SafeValue(message, "tick")
    var parsed interface{} = this.ParseOHLCV(tick, market)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, ch)
}
/**
 * @method
 * @name htx#watchOrderBook
 * @see https://huobiapi.github.io/docs/dm/v1/en/#subscribe-market-depth-data
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#subscribe-incremental-market-depth-data
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-subscribe-incremental-market-depth-data
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HtxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4248 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4248)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var allowedLimits interface{} = []interface{}{20, 150}
            // 2) 5-level/20-level incremental MBP is a tick by tick feed,
            // which means whenever there is an order book change at that level, it pushes an update
            // 150-levels/400-level incremental MBP feed is based on the gap
            // between two snapshots at 100ms interval.
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeInteger(options, "depth", 150)
            if !ccxt.IsTrue(this.InArray(depth, allowedLimits)) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook market accepts limits of 20 and 150 only")))
            }
            var messageHash interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".mbp."), this.NumberToString(depth))
            } else {
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".depth.size_"), this.NumberToString(depth)), ".high_freq")
            }
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"), false, true)
            var method interface{} = this.HandleOrderBookSubscription
            if !ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                params = this.Extend(params)
                ccxt.AddElementToObject(params, "data_type", "incremental")
                method = nil
            }
        
            orderbook:= (<-this.SubscribePublic(url, symbol, messageHash, method, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name htx#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://huobiapi.github.io/docs/dm/v1/en/#subscribe-market-depth-data
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#subscribe-incremental-market-depth-data
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-subscribe-incremental-market-depth-data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HtxCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4678)
            var market interface{} = this.Market(symbol)
            var topic interface{} = "orderbook"
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeInteger(options, "depth", 150)
            var subMessageHash interface{} = nil
            if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
                subMessageHash = ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".mbp."), this.NumberToString(depth))
            } else {
                subMessageHash = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("market.", ccxt.GetValue(market, "id")), ".depth.size_"), this.NumberToString(depth)), ".high_freq")
            }
            if !ccxt.IsTrue((ccxt.GetValue(market, "spot"))) {
                ccxt.AddElementToObject(params, "data_type", "incremental")
            }
        
                retRes48115 :=  (<-this.UnsubscribePublic(market, subMessageHash, topic, params))
                ccxt.PanicOnError(retRes48115)
                ch <- retRes48115
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleOrderBookSnapshot(client interface{}, message interface{}, subscription interface{})  {
    //
    //     {
    //         "id": 1583473663565,
    //         "rep": "market.btcusdt.mbp.150",
    //         "status": "ok",
    //         "ts": 1698359289261,
    //         "data": {
    //             "seqNum": 104999417756,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var messageHash interface{} = this.SafeString(subscription, "messageHash")
    var id interface{} = this.SafeString(message, "id")
    var lastTimestamp interface{} = this.SafeInteger(subscription, "lastTimestamp")
    
        {
             func(this *HtxCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *HtxCore) interface{} {
                            // catch block:
                                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            ccxt.Remove(this.Orderbooks, symbol)
            client.(ccxt.ClientInterface).Reject(e, messageHash)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            var data interface{} = this.SafeValue(message, "data")
            var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
            var firstMessage interface{} = this.SafeValue(messages, 0, map[string]interface{} {})
            var snapshot interface{} = this.ParseOrderBook(data, symbol)
            var tick interface{} = this.SafeValue(firstMessage, "tick")
            var sequence interface{} = this.SafeInteger(tick, "prevSeqNum")
            var nonce interface{} = this.SafeInteger(data, "seqNum")
            ccxt.AddElementToObject(snapshot, "nonce", nonce)
            var snapshotTimestamp interface{} = this.SafeInteger(message, "ts")
            ccxt.AddElementToObject(subscription, "lastTimestamp", snapshotTimestamp)
            var snapshotLimit interface{} = this.SafeInteger(subscription, "limit")
            var snapshotOrderBook interface{} = this.OrderBook(snapshot, snapshotLimit)
            client.(ccxt.ClientInterface).Resolve(snapshotOrderBook, id)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(sequence, nil))) || ccxt.IsTrue((ccxt.IsLessThan(nonce, sequence)))) {
                var maxAttempts interface{} = this.HandleOption("watchOrderBook", "maxRetries", 3)
                var numAttempts interface{} = this.SafeInteger(subscription, "numAttempts", 0)
                // retry to synchronize if we have not reached maxAttempts yet
                if ccxt.IsTrue(ccxt.IsLessThan(numAttempts, maxAttempts)) {
                    // safety guard
                    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                        numAttempts = this.Sum(numAttempts, 1)
                        var delayTime interface{} = this.Sum(1000, ccxt.Subtract(lastTimestamp, snapshotTimestamp))
                        ccxt.AddElementToObject(subscription, "numAttempts", numAttempts)
                        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, subscription)
                        this.Delay(delayTime, this.WatchOrderBookSnapshot, client, message, subscription)
                    }
                } else {
                    panic(ccxt.InvalidNonce(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " failed to synchronize WebSocket feed with the snapshot for symbol "), symbol), " in "), ccxt.ToString(maxAttempts)), " attempts")))
                }
            } else {
                orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
                // unroll the accumulated deltas
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
                    this.HandleOrderBookMessage(client, ccxt.GetValue(messages, i))
                }
                orderbook.(ccxt.OrderBookInterface).SetCache([]interface{}{})
                ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
                client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            }
    		    return nil
    	    }(this)
        
            }
}
func  (this *HtxCore) WatchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var messageHash interface{} = this.SafeString(subscription, "messageHash")
            var symbol interface{} = this.SafeString(subscription, "symbol")
            var limit interface{} = this.SafeInteger(subscription, "limit")
            var timestamp interface{} = this.SafeInteger(message, "ts")
            var params interface{} = this.SafeValue(subscription, "params")
            var attempts interface{} = this.SafeInteger(subscription, "numAttempts", 0)
            var market interface{} = this.Market(symbol)
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"), false, true)
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "req": messageHash,
                "id": requestId,
            }
            // this is a temporary subscription by a specific requestId
            // it has a very short lifetime until the snapshot is received over ws
            var snapshotSubscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "limit": limit,
                "params": params,
                "numAttempts": attempts,
                "lastTimestamp": timestamp,
                "method": this.HandleOrderBookSnapshot,
            }
            
                {
                     func(this *HtxCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *HtxCore) interface{} {
                                    // catch block:
                                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    orderbook:= (<-this.Watch(url, requestId, request, requestId, snapshotSubscription))
                    ccxt.PanicOnError(orderbook)
            
                    ch <- orderbook.(ccxt.OrderBookInterface).Limit()
                    return nil
            		    
            	    }(this)
                
                    }
        
            return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *HtxCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *HtxCore) HandleOrderBookMessage(client interface{}, message interface{})  {
    // spot markets
    //
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    // non-spot market update
    //
    //     {
    //         "ch":"market.BTC220218.depth.size_150.high_freq",
    //         "tick":{
    //             "asks":[],
    //             "bids":[
    //                 [43445.74,1],
    //                 [43444.48,0 ],
    //                 [40593.92,9]
    //             ],
    //             "ch":"market.BTC220218.depth.size_150.high_freq",
    //             "event":"update",
    //             "id":152727500274,
    //             "mrid":152727500274,
    //             "ts":1645023376098,
    //             "version":37536690
    //         },
    //         "ts":1645023376098
    //     }
    // non-spot market snapshot
    //
    //     {
    //         "ch":"market.BTC220218.depth.size_150.high_freq",
    //         "tick":{
    //             "asks":[
    //                 [43445.74,1],
    //                 [43444.48,0 ],
    //                 [40593.92,9]
    //             ],
    //             "bids":[
    //                 [43445.74,1],
    //                 [43444.48,0 ],
    //                 [40593.92,9]
    //             ],
    //             "ch":"market.BTC220218.depth.size_150.high_freq",
    //             "event":"snapshot",
    //             "id":152727500274,
    //             "mrid":152727500274,
    //             "ts":1645023376098,
    //             "version":37536690
    //         },
    //         "ts":1645023376098
    //     }
    //
    var ch interface{} = this.SafeValue(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var tick interface{} = this.SafeValue(message, "tick", map[string]interface{} {})
    var seqNum interface{} = this.SafeInteger(tick, "seqNum")
    var prevSeqNum interface{} = this.SafeInteger(tick, "prevSeqNum")
    var event interface{} = this.SafeString(tick, "event")
    var version interface{} = this.SafeInteger(tick, "version")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        var snapshot interface{} = this.ParseOrderBook(tick, symbol, timestamp)
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        ccxt.AddElementToObject(orderbook, "nonce", version)
    }
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(prevSeqNum, nil))) && ccxt.IsTrue(ccxt.IsGreaterThan(prevSeqNum, ccxt.GetValue(orderbook, "nonce")))) {
        var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
        if ccxt.IsTrue(checksum) {
            panic(ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol))))
        }
    }
    var spotConditon interface{} = ccxt.IsTrue(ccxt.GetValue(market, "spot")) && ccxt.IsTrue((ccxt.IsEqual(prevSeqNum, ccxt.GetValue(orderbook, "nonce"))))
    var nonSpotCondition interface{} = ccxt.IsTrue(ccxt.GetValue(market, "contract")) && ccxt.IsTrue((ccxt.IsEqual(ccxt.Subtract(version, 1), ccxt.GetValue(orderbook, "nonce"))))
    if ccxt.IsTrue(ccxt.IsTrue(spotConditon) || ccxt.IsTrue(nonSpotCondition)) {
        var asks interface{} = this.SafeValue(tick, "asks", []interface{}{})
        var bids interface{} = this.SafeValue(tick, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "nonce", ccxt.Ternary(ccxt.IsTrue(spotConditon), seqNum, version))
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
}
func  (this *HtxCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // deltas
    //
    // spot markets
    //
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    //
    // non spot markets
    //
    //     {
    //         "ch":"market.BTC220218.depth.size_150.high_freq",
    //         "tick":{
    //             "asks":[],
    //             "bids":[
    //                 [43445.74,1],
    //                 [43444.48,0 ],
    //                 [40593.92,9]
    //             ],
    //             "ch":"market.BTC220218.depth.size_150.high_freq",
    //             "event":"update",
    //             "id":152727500274,
    //             "mrid":152727500274,
    //             "ts":1645023376098,
    //             "version":37536690
    //         },
    //         "ts":1645023376098
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "ch")
    var tick interface{} = this.SafeDict(message, "tick")
    var event interface{} = this.SafeString(tick, "event")
    var ch interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(ch, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var symbol interface{} = this.SafeSymbol(marketId)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var size interface{} = this.SafeString(parts, 3)
        var sizeParts interface{} = ccxt.Split(size, "_")
        var limit interface{} = this.SafeInteger(sizeParts, 1)
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(event, nil))) && ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(orderbook, "nonce"), nil)))) {
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        this.HandleOrderBookMessage(client, message)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *HtxCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var market interface{} = this.Market(symbol)
    var limit interface{} = this.SafeInteger(subscription, "limit")
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        this.Spawn(this.WatchOrderBookSnapshot, client, message, subscription)
    }
}
/**
 * @method
 * @name htx#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53dd5-7773-11ed-9966-0242ac110003
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *HtxCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes8018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8018)
            var typeVar interface{} = nil
            var marketId interface{} = "*" // wildcard
            var market interface{} = nil
            var messageHash interface{} = nil
            var channel interface{} = nil
            var trades interface{} = nil
            var subType interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                typeVar = ccxt.GetValue(market, "type")
                subType = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "linear")), "linear", "inverse")
                marketId = ccxt.GetValue(market, "lowercaseId")
            } else {
                typeVar = this.SafeString(this.Options, "defaultType", "spot")
                typeVar = this.SafeString(params, "type", typeVar)
                subType = this.SafeString2(this.Options, "subType", "defaultSubType", "linear")
                subType = this.SafeString(params, "subType", subType)
                params = this.Omit(params, []interface{}{"type", "subType"})
            }
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var mode interface{} = nil
                if ccxt.IsTrue(ccxt.IsEqual(mode, nil)) {
                    mode = this.SafeString2(this.Options, "watchMyTrades", "mode", "0")
                    mode = this.SafeString(params, "mode", mode)
                    params = this.Omit(params, "mode")
                }
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("trade.clearing", "#"), marketId), "#"), mode)
                channel = messageHash
            } else {
                var channelAndMessageHash interface{} = this.GetOrderChannelAndMessageHash(typeVar, subType, market, params)
                channel = this.SafeString(channelAndMessageHash, 0)
                var orderMessageHash interface{} = this.SafeString(channelAndMessageHash, 1)
                // we will take advantage of the order messageHash because already handles stuff
                // like symbol/margin/subtype/type variations
                messageHash = ccxt.Add(ccxt.Add(orderMessageHash, ":"), "trade")
            }
            
            trades = (<-this.SubscribePrivate(channel, messageHash, typeVar, subType, params))
                ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HtxCore) GetOrderChannelAndMessageHash(typeVar interface{}, subType interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var messageHash interface{} = nil
    var channel interface{} = nil
    var orderType interface{} = this.SafeString(this.Options, "orderType", "orders") // orders or matchOrders
    orderType = this.SafeString(params, "orderType", orderType)
    params = this.Omit(params, "orderType")
    var marketCode interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(market, nil))), ccxt.ToLower(ccxt.GetValue(market, "lowercaseId")), nil)
    var baseId interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(market, nil))), ccxt.GetValue(market, "baseId"), nil)
    var prefix interface{} = orderType
    messageHash = prefix
    if ccxt.IsTrue(ccxt.IsEqual(subType, "linear")) {
        // USDT Margined Contracts Example: LTC/USDT:USDT
        var marginMode interface{} = this.SafeString(params, "margin", "cross")
        var marginPrefix interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marginMode, "cross"))), ccxt.Add(prefix, "_cross"), prefix)
        messageHash = marginPrefix
        if ccxt.IsTrue(!ccxt.IsEqual(marketCode, nil)) {
            messageHash = ccxt.Add(messageHash, ccxt.Add(".", marketCode))
            channel = messageHash
        } else {
            channel = ccxt.Add(ccxt.Add(marginPrefix, "."), "*")
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
        // inverse futures Example: BCH/USD:BCH-220408
        if ccxt.IsTrue(!ccxt.IsEqual(baseId, nil)) {
            channel = ccxt.Add(ccxt.Add(prefix, "."), ccxt.ToLower(baseId))
            messageHash = channel
        } else {
            channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
        }
    } else {
        // inverse swaps: Example: BTC/USD:BTC
        if ccxt.IsTrue(!ccxt.IsEqual(marketCode, nil)) {
            channel = ccxt.Add(ccxt.Add(prefix, "."), marketCode)
            messageHash = channel
        } else {
            channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
        }
    }
    return []interface{}{channel, messageHash}
}
/**
 * @method
 * @name htx#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec53c8f-7773-11ed-9966-0242ac110003
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HtxCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8998)
            var typeVar interface{} = nil
            var subType interface{} = nil
            var market interface{} = nil
            var suffix interface{} = "*" // wildcard
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                typeVar = ccxt.GetValue(market, "type")
                suffix = ccxt.GetValue(market, "lowercaseId")
                subType = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "linear")), "linear", "inverse")
            } else {
                typeVar = this.SafeString(this.Options, "defaultType", "spot")
                typeVar = this.SafeString(params, "type", typeVar)
                subType = this.SafeString2(this.Options, "subType", "defaultSubType", "linear")
                subType = this.SafeString(params, "subType", subType)
                params = this.Omit(params, []interface{}{"type", "subType"})
            }
            var messageHash interface{} = nil
            var channel interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                messageHash = ccxt.Add(ccxt.Add("orders", "#"), suffix)
                channel = messageHash
            } else {
                var channelAndMessageHash interface{} = this.GetOrderChannelAndMessageHash(typeVar, subType, market, params)
                channel = this.SafeString(channelAndMessageHash, 0)
                messageHash = this.SafeString(channelAndMessageHash, 1)
            }
        
            orders:= (<-this.SubscribePrivate(channel, messageHash, typeVar, subType, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "action":"push",
    //         "ch":"orders#btcusdt", // or "orders#*" for global subscriptions
    //         "data": {
    //             "orderSource": "spot-web",
    //             "orderCreateTime": 1645116048355,
    //             "accountId": 44234548,
    //             "orderPrice": "100",
    //             "orderSize": "0.05",
    //             "symbol": "ethusdt",
    //             "type": "buy-limit",
    //             "orderId": "478861479986886",
    //             "eventType": "creation",
    //             "clientOrderId": '',
    //             "orderStatus": "submitted"
    //         }
    //     }
    //
    // spot wrapped trade
    //
    //     {
    //         "action": "push",
    //         "ch": "orders#ltcusdt",
    //         "data": {
    //             "tradePrice": "130.01",
    //             "tradeVolume": "0.0385",
    //             "tradeTime": 1648714741525,
    //             "aggressor": true,
    //             "execAmt": "0.0385",
    //             "orderSource": "spot-web",
    //             "orderSize": "0.0385",
    //             "remainAmt": "0",
    //             "tradeId": 101541578884,
    //             "symbol": "ltcusdt",
    //             "type": "sell-market",
    //             "eventType": "trade",
    //             "clientOrderId": '',
    //             "orderStatus": "filled",
    //             "orderId": 509835753860328
    //         }
    //     }
    //
    // non spot order
    //
    // {
    //     "contract_type": "swap",
    //     "pair": "LTC-USDT",
    //     "business_type": "swap",
    //     "op": "notify",
    //     "topic": "orders_cross.ltc-usdt",
    //     "ts": 1650354508696,
    //     "symbol": "LTC",
    //     "contract_code": "LTC-USDT",
    //     "volume": 1,
    //     "price": 110.34,
    //     "order_price_type": "lightning",
    //     "direction": "sell",
    //     "offset": "close",
    //     "status": 6,
    //     "lever_rate": 1,
    //     "order_id": "966002354015051776",
    //     "order_id_str": "966002354015051776",
    //     "client_order_id": null,
    //     "order_source": "web",
    //     "order_type": 1,
    //     "created_at": 1650354508649,
    //     "trade_volume": 1,
    //     "trade_turnover": 11.072,
    //     "fee": -0.005536,
    //     "trade_avg_price": 110.72,
    //     "margin_frozen": 0,
    //     "profit": -0.045,
    //     "trade": [
    //       {
    //         "trade_fee": -0.005536,
    //         "fee_asset": "USDT",
    //         "real_profit": 0.473,
    //         "profit": -0.045,
    //         "trade_id": 86678766507,
    //         "id": "86678766507-966002354015051776-1",
    //         "trade_volume": 1,
    //         "trade_price": 110.72,
    //         "trade_turnover": 11.072,
    //         "created_at": 1650354508656,
    //         "role": "taker"
    //       }
    //     ],
    //     "canceled_at": 0,
    //     "fee_asset": "USDT",
    //     "margin_asset": "USDT",
    //     "uid": "359305390",
    //     "liquidation_type": "0",
    //     "margin_mode": "cross",
    //     "margin_account": "USDT",
    //     "is_tpsl": 0,
    //     "real_profit": 0.473,
    //     "trade_partition": "USDT",
    //     "reduce_only": 1
    //   }
    //
    //
    var messageHash interface{} = this.SafeString2(message, "ch", "topic")
    var data interface{} = this.SafeValue(message, "data")
    var marketId interface{} = this.SafeString(message, "contract_code")
    if ccxt.IsTrue(ccxt.IsEqual(marketId, nil)) {
        marketId = this.SafeString(data, "symbol")
    }
    var market interface{} = this.SafeMarket(marketId)
    var parsedOrder interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        // spot updates
        var eventType interface{} = this.SafeString(data, "eventType")
        if ccxt.IsTrue(ccxt.IsEqual(eventType, "trade")) {
            // when a spot order is filled we get an update message
            // with the trade info
            var parsedTrade interface{} = this.ParseOrderTrade(data, market)
            // inject trade in existing order by faking an order object
            var orderId interface{} = this.SafeString(parsedTrade, "order")
            var trades interface{} = []interface{}{parsedTrade}
            var status interface{} = this.ParseOrderStatus(this.SafeString2(data, "orderStatus", "status", "closed"))
            var filled interface{} = this.SafeString(data, "execAmt")
            var remaining interface{} = this.SafeString(data, "remainAmt")
            var order interface{} = map[string]interface{} {
                "id": orderId,
                "trades": trades,
                "status": status,
                "symbol": ccxt.GetValue(market, "symbol"),
                "filled": this.ParseNumber(filled),
                "remaining": this.ParseNumber(remaining),
            }
            parsedOrder = order
        } else {
            parsedOrder = this.ParseWsOrder(data, market)
        }
    } else {
        // contract branch
        parsedOrder = this.ParseWsOrder(message, market)
        var rawTrades interface{} = this.SafeValue(message, "trade", []interface{}{})
        var tradesLength interface{} =         ccxt.GetArrayLength(rawTrades)
        if ccxt.IsTrue(ccxt.IsGreaterThan(tradesLength, 0)) {
            var tradesObject interface{} = map[string]interface{} {
                "trades": rawTrades,
                "ch": messageHash,
                "symbol": marketId,
            }
            // inject order params in every trade
            var extendTradeParams interface{} = map[string]interface{} {
                "order": this.SafeString(parsedOrder, "id"),
                "type": this.SafeString(parsedOrder, "type"),
                "side": this.SafeString(parsedOrder, "side"),
            }
            // trades arrive inside an order update
            // we're forwarding them to handleMyTrade
            // so they can be properly resolved
            this.HandleMyTrade(client, tradesObject, extendTradeParams)
        }
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedOrders interface{} = this.Orders
    cachedOrders.(ccxt.Appender).Append(parsedOrder)
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    // when we make a global subscription (for contracts only) our message hash can't have a symbol/currency attached
    // so we're removing it here
    var genericMessageHash interface{} = ccxt.Replace(messageHash, ccxt.Add(".", ccxt.GetValue(market, "lowercaseId")), "")
    var lowerCaseBaseId interface{} = this.SafeStringLower(market, "baseId")
    genericMessageHash = ccxt.Replace(genericMessageHash, ccxt.Add(".", lowerCaseBaseId), "")
    client.(ccxt.ClientInterface).Resolve(this.Orders, genericMessageHash)
}
func  (this *HtxCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "orderSource": "spot-web",
    //         "orderCreateTime": 1645116048355, // creating only
    //         "accountId": 44234548,
    //         "orderPrice": "100",
    //         "orderSize": "0.05",
    //         "orderValue": "3.71676361", // market-buy only
    //         "symbol": "ethusdt",
    //         "type": "buy-limit",
    //         "orderId": "478861479986886",
    //         "eventType": "creation",
    //         "clientOrderId": '',
    //         "orderStatus": "submitted"
    //         "lastActTime":1645118621810 // except creating
    //         "execAmt":"0"
    //     }
    //
    // swap order
    //
    //     {
    //         "contract_type": "swap",
    //         "pair": "LTC-USDT",
    //         "business_type": "swap",
    //         "op": "notify",
    //         "topic": "orders_cross.ltc-usdt",
    //         "ts": 1648717911384,
    //         "symbol": "LTC",
    //         "contract_code": "LTC-USDT",
    //         "volume": 1,
    //         "price": 129.13,
    //         "order_price_type": "lightning",
    //         "direction": "sell",
    //         "offset": "close",
    //         "status": 6,
    //         "lever_rate": 5,
    //         "order_id": "959137967397068800",
    //         "order_id_str": "959137967397068800",
    //         "client_order_id": null,
    //         "order_source": "web",
    //         "order_type": 1,
    //         "created_at": 1648717911344,
    //         "trade_volume": 1,
    //         "trade_turnover": 12.952,
    //         "fee": -0.006476,
    //         "trade_avg_price": 129.52,
    //         "margin_frozen": 0,
    //         "profit": -0.005,
    //         "trade": [
    //             {
    //                 "trade_fee": -0.006476,
    //                 "fee_asset": "USDT",
    //                 "real_profit": -0.005,
    //                 "profit": -0.005,
    //                 "trade_id": 83619995370,
    //                 "id": "83619995370-959137967397068800-1",
    //                 "trade_volume": 1,
    //                 "trade_price": 129.52,
    //                 "trade_turnover": 12.952,
    //                 "created_at": 1648717911352,
    //                 "role": "taker"
    //             }
    //         ],
    //         "canceled_at": 0,
    //         "fee_asset": "USDT",
    //         "margin_asset": "USDT",
    //         "uid": "359305390",
    //         "liquidation_type": "0",
    //         "margin_mode": "cross",
    //         "margin_account": "USDT",
    //         "is_tpsl": 0,
    //         "real_profit": -0.005,
    //         "trade_partition": "USDT",
    //         "reduce_only": 1
    //     }
    //
    //     {
    //         "op":"notify",
    //         "topic":"orders.ada",
    //         "ts":1604388667226,
    //         "symbol":"ADA",
    //         "contract_type":"quarter",
    //         "contract_code":"ADA201225",
    //         "volume":1,
    //         "price":0.0905,
    //         "order_price_type":"post_only",
    //         "direction":"sell",
    //         "offset":"open",
    //         "status":6,
    //         "lever_rate":20,
    //         "order_id":773207641127878656,
    //         "order_id_str":"773207641127878656",
    //         "client_order_id":null,
    //         "order_source":"web",
    //         "order_type":1,
    //         "created_at":1604388667146,
    //         "trade_volume":1,
    //         "trade_turnover":10,
    //         "fee":-0.022099447513812154,
    //         "trade_avg_price":0.0905,
    //         "margin_frozen":0,
    //         "profit":0,
    //         "trade":[],
    //         "canceled_at":0,
    //         "fee_asset":"ADA",
    //         "uid":"123456789",
    //         "liquidation_type":"0",
    //         "is_tpsl": 0,
    //         "real_profit": 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var lastTradeTimestamp interface{} = this.SafeInteger2(order, "lastActTime", "ts")
    var created interface{} = this.SafeInteger(order, "orderCreateTime")
    var marketId interface{} = this.SafeString2(order, "contract_code", "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var amount interface{} = this.SafeString2(order, "orderSize", "volume")
    var status interface{} = this.ParseOrderStatus(this.SafeString2(order, "orderStatus", "status"))
    var id interface{} = this.SafeString2(order, "orderId", "order_id")
    var clientOrderId interface{} = this.SafeString2(order, "clientOrderId", "client_order_id")
    var price interface{} = this.SafeString2(order, "orderPrice", "price")
    var filled interface{} = this.SafeString(order, "execAmt")
    var typeSide interface{} = this.SafeString(order, "type")
    var feeCost interface{} = this.SafeString(order, "fee")
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(order, "fee_asset")
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeCurrencyCode(feeCurrencyId),
        }
    }
    var avgPrice interface{} = this.SafeString(order, "trade_avg_price")
    var rawTrades interface{} = this.SafeValue(order, "trade")
    var typeSideParts interface{} = []interface{}{}
    if ccxt.IsTrue(!ccxt.IsEqual(typeSide, nil)) {
        typeSideParts = ccxt.Split(typeSide, "-")
    }
    var typeVar interface{} = this.SafeStringLower(typeSideParts, 1)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
        typeVar = this.SafeString(order, "order_price_type")
    }
    var side interface{} = this.SafeStringLower(typeSideParts, 0)
    if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
        side = this.SafeString(order, "direction")
    }
    var cost interface{} = this.SafeString(order, "orderValue")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": created,
        "datetime": this.Iso8601(created),
        "lastTradeTimestamp": lastTradeTimestamp,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": cost,
        "fee": fee,
        "average": avgPrice,
        "trades": rawTrades,
    }, market)
}
func  (this *HtxCore) ParseOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // spot private wrapped trade
    //
    //     {
    //         "tradePrice": "130.01",
    //         "tradeVolume": "0.0385",
    //         "tradeTime": 1648714741525,
    //         "aggressor": true,
    //         "execAmt": "0.0385",
    //         "orderSource": "spot-web",
    //         "orderSize": "0.0385",
    //         "remainAmt": "0",
    //         "tradeId": 101541578884,
    //         "symbol": "ltcusdt",
    //         "type": "sell-market",
    //         "eventType": "trade",
    //         "clientOrderId": '',
    //         "orderStatus": "filled",
    //         "orderId": 509835753860328
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(nil, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var tradeId interface{} = this.SafeString(trade, "tradeId")
    var price interface{} = this.SafeString(trade, "tradePrice")
    var amount interface{} = this.SafeString(trade, "tradeVolume")
    var order interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeInteger(trade, "tradeTime")
    var typeVar interface{} = this.SafeString(trade, "type")
    var side interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(typeVar, nil)) {
        var typeParts interface{} = ccxt.Split(typeVar, "-")
        side = ccxt.GetValue(typeParts, 0)
        typeVar = ccxt.GetValue(typeParts, 1)
    }
    var aggressor interface{} = this.SafeValue(trade, "aggressor")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(aggressor, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(aggressor), "taker", "maker")
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": tradeId,
        "order": order,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name htx#watchPositions
 * @see https://www.huobi.com/en-in/opend/newApiPages/?id=8cb7de1c-77b5-11ed-9966-0242ac110003
 * @see https://www.huobi.com/en-in/opend/newApiPages/?id=8cb7df0f-77b5-11ed-9966-0242ac110003
 * @see https://www.huobi.com/en-in/opend/newApiPages/?id=28c34a7d-77ae-11ed-9966-0242ac110003
 * @see https://www.huobi.com/en-in/opend/newApiPages/?id=5d5156b5-77b6-11ed-9966-0242ac110003
 * @description watch all open positions. Note: huobi has one channel for each marginMode and type
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *HtxCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13568)
            var market interface{} = nil
            var messageHash interface{} = ""
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                market = this.GetMarketFromSymbols(symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var typeVar interface{} = nil
            var subType interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                typeVar = ccxt.GetValue(market, "type")
                subType = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "linear")), "linear", "inverse")
            } else {
                typeVarparamsVariable := this.HandleMarketTypeAndParams("watchPositions", market, params)
                typeVar = ccxt.GetValue(typeVarparamsVariable,0)
                params = ccxt.GetValue(typeVarparamsVariable,1)
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    typeVar = "future"
                }
                subTypeparamsVariable := this.HandleOptionAndParams(params, "watchPositions", "subType", subType)
                subType = ccxt.GetValue(subTypeparamsVariable,0)
                params = ccxt.GetValue(subTypeparamsVariable,1)
            }
            symbols = this.MarketSymbols(symbols)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchPositions", params, "cross")
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var isLinear interface{} =     (ccxt.IsEqual(subType, "linear"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isLinear, true)
            messageHash = ccxt.Add(ccxt.Add(marginMode, ":positions"), messageHash)
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marginMode, "cross"))), "positions_cross.*", "positions.*")
        
            newPositions:= (<-this.SubscribePrivate(channel, messageHash, typeVar, subType, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(ccxt.GetValue(ccxt.GetValue(this.Positions, url), marginMode), symbols, since, limit, false)
            return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        op: 'notify',
    //        topic: 'positions_cross',
    //        ts: 1696767149650,
    //        event: 'snapshot',
    //        data: [
    //          {
    //            contract_type: 'swap',
    //            pair: 'BTC-USDT',
    //            business_type: 'swap',
    //            liquidation_price: null,
    //            symbol: 'BTC',
    //            contract_code: 'BTC-USDT',
    //            volume: 1,
    //            available: 1,
    //            frozen: 0,
    //            cost_open: 27802.2,
    //            cost_hold: 27802.2,
    //            profit_unreal: 0.0175,
    //            profit_rate: 0.000629446590557581,
    //            profit: 0.0175,
    //            margin_asset: 'USDT',
    //            position_margin: 27.8197,
    //            lever_rate: 1,
    //            direction: 'buy',
    //            last_price: 27819.7,
    //            margin_mode: 'cross',
    //            margin_account: 'USDT',
    //            trade_partition: 'USDT',
    //            position_mode: 'dual_side'
    //          },
    //        ]
    //    }
    //
    var url interface{} = client.(ccxt.ClientInterface).GetUrl()
    var topic interface{} = this.SafeString(message, "topic", "")
    var marginMode interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(topic, "positions_cross"))), "cross", "isolated")
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    var clientPositions interface{} = this.SafeValue(this.Positions, url)
    if ccxt.IsTrue(ccxt.IsEqual(clientPositions, nil)) {
        ccxt.AddElementToObject(this.Positions, url, map[string]interface{} {})
    }
    var clientMarginModePositions interface{} = this.SafeValue(clientPositions, marginMode)
    if ccxt.IsTrue(ccxt.IsEqual(clientMarginModePositions, nil)) {
        ccxt.AddElementToObject(ccxt.GetValue(this.Positions, url), marginMode, ccxt.NewArrayCacheBySymbolBySide())
    }
    var cache interface{} = ccxt.GetValue(ccxt.GetValue(this.Positions, url), marginMode)
    var rawPositions interface{} = this.SafeValue(message, "data", []interface{}{})
    var newPositions interface{} = []interface{}{}
    var timestamp interface{} = this.SafeInteger(message, "ts")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParsePosition(rawPosition)
        ccxt.AddElementToObject(position, "timestamp", timestamp)
        ccxt.AddElementToObject(position, "datetime", this.Iso8601(timestamp))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(marginMode, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(marginMode, ":positions"))
}
/**
 * @method
 * @name htx#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec52e28-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=10000084-77b7-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=8cb7dcca-77b5-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c34995-77ae-11ed-9966-0242ac110003
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *HtxCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchBalance", nil, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isUnifiedAccount interface{} = this.SafeValue2(params, "isUnifiedAccount", "unified", false)
            params = this.Omit(params, []interface{}{"isUnifiedAccount", "unified"})
        
            retRes14838 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14838)
            var messageHash interface{} = nil
            var channel interface{} = nil
            var marginMode interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var mode interface{} = this.SafeString2(this.Options, "watchBalance", "mode", "2")
                mode = this.SafeString(params, "mode", mode)
                messageHash = ccxt.Add(ccxt.Add("accounts.update", "#"), mode)
                channel = messageHash
            } else {
                var symbol interface{} = this.SafeString(params, "symbol")
                var currency interface{} = this.SafeString(params, "currency")
                var market interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(symbol, nil))), this.Market(symbol), nil)
                var currencyCode interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(currency, nil))), this.Currency(currency), nil)
                marginMode = this.SafeString(params, "margin", "cross")
                params = this.Omit(params, []interface{}{"currency", "symbol", "margin"})
                var prefix interface{} = "accounts"
                messageHash = prefix
                if ccxt.IsTrue(ccxt.IsEqual(subType, "linear")) {
                    if ccxt.IsTrue(isUnifiedAccount) {
                        // usdt contracts account
                        prefix = "accounts_unify"
                        messageHash = prefix
                        channel = ccxt.Add(ccxt.Add(prefix, "."), "usdt")
                    } else {
                        // usdt contracts account
                        prefix = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marginMode, "cross"))), ccxt.Add(prefix, "_cross"), prefix)
                        messageHash = prefix
                        if ccxt.IsTrue(ccxt.IsEqual(marginMode, "isolated")) {
                            // isolated margin only allows filtering by symbol3
                            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                                messageHash = ccxt.Add(messageHash, ccxt.Add(".", ccxt.GetValue(market, "id")))
                                channel = messageHash
                            } else {
                                // subscribe to all
                                channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
                            }
                        } else {
                            // cross margin
                            if ccxt.IsTrue(!ccxt.IsEqual(currencyCode, nil)) {
                                channel = ccxt.Add(ccxt.Add(prefix, "."), ccxt.GetValue(currencyCode, "id"))
                                messageHash = channel
                            } else {
                                // subscribe to all
                                channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
                            }
                        }
                    }
                } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                    // inverse futures account
                    if ccxt.IsTrue(!ccxt.IsEqual(currencyCode, nil)) {
                        messageHash = ccxt.Add(messageHash, ccxt.Add(".", ccxt.GetValue(currencyCode, "id")))
                        channel = messageHash
                    } else {
                        // subscribe to all
                        channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
                    }
                } else {
                    // inverse swaps account
                    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                        messageHash = ccxt.Add(messageHash, ccxt.Add(".", ccxt.GetValue(market, "id")))
                        channel = messageHash
                    } else {
                        // subscribe to all
                        channel = ccxt.Add(ccxt.Add(prefix, "."), "*")
                    }
                }
            }
            var subscriptionParams interface{} = map[string]interface{} {
                "type": typeVar,
                "subType": subType,
                "margin": marginMode,
            }
        
                retRes156015 :=  (<-this.SubscribePrivate(channel, messageHash, typeVar, subType, params, subscriptionParams))
                ccxt.PanicOnError(retRes156015)
                    // we are differentiating the channel from the messageHash for global subscriptions (*)
            // because huobi returns a different topic than the topic sent. Example: we send
            // "accounts.*" and "accounts" is returned so we're setting channel = "accounts.*" and
            // messageHash = "accounts" allowing handleBalance to freely resolve the topic in the message
        ch <- retRes156015
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) HandleBalance(client interface{}, message interface{})  {
    // spot
    //
    //     {
    //         "action": "push",
    //         "ch": "accounts.update#0",
    //         "data": {
    //             "currency": "btc",
    //             "accountId": 123456,
    //             "balance": "23.111",
    //             "available": "2028.699426619837209087",
    //             "changeType": "transfer",
    //             "accountType":"trade",
    //             "seqNum": "86872993928",
    //             "changeTime": 1568601800000
    //         }
    //     }
    //
    // inverse future
    //
    //     {
    //         "op":"notify",
    //         "topic":"accounts.ada",
    //         "ts":1604388667226,
    //         "event":"order.match",
    //         "data":[
    //             {
    //                 "symbol":"ADA",
    //                 "margin_balance":446.417641681222726716,
    //                 "margin_static":445.554085945257745136,
    //                 "margin_position":11.049723756906077348,
    //                 "margin_frozen":0,
    //                 "margin_available":435.367917924316649368,
    //                 "profit_real":21.627049781983019459,
    //                 "profit_unreal":0.86355573596498158,
    //                 "risk_rate":40.000796572150656768,
    //                 "liquidation_price":0.018674308027108984,
    //                 "withdraw_available":423.927036163274725677,
    //                 "lever_rate":20,
    //                 "adjust_factor":0.4
    //             }
    //         ],
    //         "uid":"123456789"
    //     }
    //
    // usdt / linear future, swap
    //
    //     {
    //         "op":"notify",
    //         "topic":"accounts.btc-usdt", // or "accounts" for global subscriptions
    //         "ts":1603711370689,
    //         "event":"order.open",
    //         "data":[
    //             {
    //                 "margin_mode":"cross",
    //                 "margin_account":"USDT",
    //                 "margin_asset":"USDT",
    //                 "margin_balance":30.959342395,
    //                 "margin_static":30.959342395,
    //                 "margin_position":0,
    //                 "margin_frozen":10,
    //                 "profit_real":0,
    //                 "profit_unreal":0,
    //                 "withdraw_available":20.959342395,
    //                 "risk_rate":153.796711975,
    //                 "position_mode":"dual_side",
    //                 "contract_detail":[
    //                     {
    //                         "symbol":"LTC",
    //                         "contract_code":"LTC-USDT",
    //                         "margin_position":0,
    //                         "margin_frozen":0,
    //                         "margin_available":20.959342395,
    //                         "profit_unreal":0,
    //                         "liquidation_price":null,
    //                         "lever_rate":1,
    //                         "adjust_factor":0.01,
    //                         "contract_type":"swap",
    //                         "pair":"LTC-USDT",
    //                         "business_type":"swap",
    //                         "trade_partition":"USDT"
    //                     },
    //                 ],
    //                 "futures_contract_detail":[],
    //             }
    //         ]
    //     }
    //
    // inverse future
    //
    //     {
    //         "op":"notify",
    //         "topic":"accounts.ada",
    //         "ts":1604388667226,
    //         "event":"order.match",
    //         "data":[
    //             {
    //                 "symbol":"ADA",
    //                 "margin_balance":446.417641681222726716,
    //                 "margin_static":445.554085945257745136,
    //                 "margin_position":11.049723756906077348,
    //                 "margin_frozen":0,
    //                 "margin_available":435.367917924316649368,
    //                 "profit_real":21.627049781983019459,
    //                 "profit_unreal":0.86355573596498158,
    //                 "risk_rate":40.000796572150656768,
    //                 "liquidation_price":0.018674308027108984,
    //                 "withdraw_available":423.927036163274725677,
    //                 "lever_rate":20,
    //                 "adjust_factor":0.4
    //             }
    //         ],
    //         "uid":"123456789"
    //     }
    //
    var channel interface{} = this.SafeString(message, "ch")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var timestamp interface{} = this.SafeInteger(data, "changeTime", this.SafeInteger(message, "ts"))
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Balance, "info", data)
    if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
        // spot balance
        var currencyId interface{} = this.SafeString(data, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(data, "available"))
        ccxt.AddElementToObject(account, "total", this.SafeString(data, "balance"))
        ccxt.AddElementToObject(this.Balance, code, account)
        this.Balance = this.SafeBalance(this.Balance)
        client.(ccxt.ClientInterface).Resolve(this.Balance, channel)
    } else {
        // contract balance
        var dataLength interface{} =         ccxt.GetArrayLength(data)
        if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
            return
        }
        var first interface{} = this.SafeValue(data, 0, map[string]interface{} {})
        var topic interface{} = this.SafeString(message, "topic")
        var splitTopic interface{} = ccxt.Split(topic, ".")
        var messageHash interface{} = this.SafeString(splitTopic, 0)
        var subscription interface{} = this.SafeValue2(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, ccxt.Add(messageHash, ".*"))
        if ccxt.IsTrue(ccxt.IsEqual(subscription, nil)) {
            // if subscription not found means that we subscribed to a specific currency/symbol
            // and we use the first data entry to find it
            // Example: topic = 'accounts'
            // client.subscription hash = 'accounts.usdt'
            // we do 'accounts' + '.' + data[0]]['margin_asset'] to get it
            var currencyId interface{} = this.SafeString2(first, "margin_asset", "symbol")
            messageHash = ccxt.Add(messageHash, ccxt.Add(".", ccxt.ToLower(currencyId)))
            subscription = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
        var typeVar interface{} = this.SafeString(subscription, "type")
        var subType interface{} = this.SafeString(subscription, "subType")
        if ccxt.IsTrue(ccxt.IsEqual(topic, "accounts_unify")) {
            // {
            //     "margin_asset": "USDT",
            //     "margin_static": 10,
            //     "cross_margin_static": 10,
            //     "margin_balance": 10,
            //     "cross_profit_unreal": 0,
            //     "margin_frozen": 0,
            //     "withdraw_available": 10,
            //     "cross_risk_rate": null,
            //     "cross_swap": [],
            //     "cross_future": [],
            //     "isolated_swap": []
            // }
            var marginAsset interface{} = this.SafeString(first, "margin_asset")
            var code interface{} = this.SafeCurrencyCode(marginAsset)
            var marginFrozen interface{} = this.SafeString(first, "margin_frozen")
            var unifiedAccount interface{} = this.Account()
            ccxt.AddElementToObject(unifiedAccount, "free", this.SafeString(first, "withdraw_available"))
            ccxt.AddElementToObject(unifiedAccount, "used", marginFrozen)
            ccxt.AddElementToObject(this.Balance, code, unifiedAccount)
            this.Balance = this.SafeBalance(this.Balance)
            client.(ccxt.ClientInterface).Resolve(this.Balance, "accounts_unify")
        } else if ccxt.IsTrue(ccxt.IsEqual(subType, "linear")) {
            var margin interface{} = this.SafeString(subscription, "margin")
            if ccxt.IsTrue(ccxt.IsEqual(margin, "cross")) {
                var fieldName interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "future"))), "futures_contract_detail", "contract_detail")
                var balances interface{} = this.SafeValue(first, fieldName, []interface{}{})
                var balancesLength interface{} =                 ccxt.GetArrayLength(balances)
                if ccxt.IsTrue(ccxt.IsGreaterThan(balancesLength, 0)) {
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
                        var balance interface{} = ccxt.GetValue(balances, i)
                        var marketId interface{} = this.SafeString2(balance, "contract_code", "margin_account")
                        var market interface{} = this.SafeMarket(marketId)
                        var currencyId interface{} = this.SafeString(balance, "margin_asset")
                        var currency interface{} = this.SafeCurrency(currencyId)
                        var code interface{} = this.SafeString(market, "settle", ccxt.GetValue(currency, "code"))
                        // the exchange outputs positions for delisted markets
                        // https://www.huobi.com/support/en-us/detail/74882968522337
                        // we skip it if the market was delisted
                        if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
                            var account interface{} = this.Account()
                            ccxt.AddElementToObject(account, "free", this.SafeString2(balance, "margin_balance", "margin_available"))
                            ccxt.AddElementToObject(account, "used", this.SafeString(balance, "margin_frozen"))
                            var accountsByCode interface{} = map[string]interface{} {}
                            ccxt.AddElementToObject(accountsByCode, code, account)
                            var symbol interface{} = ccxt.GetValue(market, "symbol")
                            ccxt.AddElementToObject(this.Balance, symbol, this.SafeBalance(accountsByCode))
                        }
                    }
                }
            } else {
                // isolated margin
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
                    var isolatedBalance interface{} = ccxt.GetValue(data, i)
                    var account interface{} = this.Account()
                    ccxt.AddElementToObject(account, "free", this.SafeString(isolatedBalance, "margin_balance", "margin_available"))
                    ccxt.AddElementToObject(account, "used", this.SafeString(isolatedBalance, "margin_frozen"))
                    var currencyId interface{} = this.SafeString2(isolatedBalance, "margin_asset", "symbol")
                    var code interface{} = this.SafeCurrencyCode(currencyId)
                    ccxt.AddElementToObject(this.Balance, code, account)
                    this.Balance = this.SafeBalance(this.Balance)
                }
            }
        } else {
            // inverse branch
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
                var balance interface{} = ccxt.GetValue(data, i)
                var currencyId interface{} = this.SafeString(balance, "symbol")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = this.Account()
                ccxt.AddElementToObject(account, "free", this.SafeString(balance, "margin_available"))
                ccxt.AddElementToObject(account, "used", this.SafeString(balance, "margin_frozen"))
                ccxt.AddElementToObject(this.Balance, code, account)
                this.Balance = this.SafeBalance(this.Balance)
            }
        }
        client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
    }
}
func  (this *HtxCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "id": 1583414227,
    //         "status": "ok",
    //         "subbed": "market.btcusdt.mbp.150",
    //         "ts": 1583414229143
    //     }
    //
    // unsubscribe
    //     {
    //         "id": "2",
    //         "status": "ok",
    //         "unsubbed": "market.BTC-USDT-251003.detail",
    //         "ts": 1759329276980
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeDict(subscriptionsById, id)
    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
        var method interface{} = this.SafeValue(subscription, "method")
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message, subscription)
        }
        // clean up
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        }
    }
    if ccxt.IsTrue(ccxt.InOp(message, "unsubbed")) {
        this.HandleUnSubscription(client, subscription)
    }
}
func  (this *HtxCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, i)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    }
    this.CleanCache(subscription)
}
func  (this *HtxCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "id": "1578090234088", // connectId
    //         "type": "welcome",
    //     }
    //
    return message
}
func  (this *HtxCore) HandleSubject(client interface{}, message interface{})  {
    // spot
    //     {
    //         "ch": "market.btcusdt.mbp.150",
    //         "ts": 1583472025885,
    //         "tick": {
    //             "seqNum": 104998984994,
    //             "prevSeqNum": 104998984977,
    //             "bids": [
    //                 [9058.27, 0],
    //                 [9058.43, 0],
    //                 [9058.99, 0],
    //             ],
    //             "asks": [
    //                 [9084.27, 0.2],
    //                 [9085.69, 0],
    //                 [9085.81, 0],
    //             ]
    //         }
    //     }
    // non spot
    //
    //     {
    //         "ch":"market.BTC220218.depth.size_150.high_freq",
    //         "tick":{
    //             "asks":[],
    //             "bids":[
    //                 [43445.74,1],
    //                 [43444.48,0 ],
    //                 [40593.92,9]
    //             ],
    //             "ch":"market.BTC220218.depth.size_150.high_freq",
    //             "event":"update",
    //             "id":152727500274,
    //             "mrid":152727500274,
    //             "ts":1645023376098,
    //             "version":37536690
    //         },
    //         "ts":1645023376098
    //     }
    //
    // spot private trade
    //
    //     {
    //         "action":"push",
    //         "ch":"trade.clearing#ltcusdt#1",
    //         "data":{
    //             "eventType":"trade",
    //             "symbol":"ltcusdt",
    //             // ...
    //         },
    //     }
    //
    // spot order
    //
    //     {
    //         "action":"push",
    //         "ch":"orders#btcusdt",
    //         "data": {
    //             "orderSide":"buy",
    //             "lastActTime":1583853365586,
    //             "clientOrderId":"abc123",
    //             "orderStatus":"rejected",
    //             "symbol":"btcusdt",
    //             "eventType":"trigger",
    //             "errCode": 2002,
    //             "errMessage":"invalid.client.order.id (NT)"
    //         }
    //     }
    //
    // contract order
    //
    //     {
    //         "op":"notify",
    //         "topic":"orders.ada",
    //         "ts":1604388667226,
    //         // ?
    //     }
    //
    var ch interface{} = this.SafeValue(message, "ch", "")
    var parts interface{} = ccxt.Split(ch, ".")
    var typeVar interface{} = this.SafeString(parts, 0)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "market")) {
        var methodName interface{} = this.SafeString(parts, 2)
        var methods interface{} = map[string]interface{} {
            "depth": this.HandleOrderBook,
            "mbp": this.HandleOrderBook,
            "detail": this.HandleTicker,
            "bbo": this.HandleTicker,
            "ticker": this.HandleTicker,
            "trade": this.HandleTrades,
            "kline": this.HandleOHLCV,
        }
        var method interface{} = this.SafeValue(methods, methodName)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
            return
        }
    }
    // private spot subjects
    var privateParts interface{} = ccxt.Split(ch, "#")
    var privateType interface{} = this.SafeString(privateParts, 0, "")
    if ccxt.IsTrue(ccxt.IsEqual(privateType, "trade.clearing")) {
        this.HandleMyTrade(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(privateType, "accounts.update"), 0)) {
        this.HandleBalance(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(privateType, "orders")) {
        this.HandleOrder(client, message)
        return
    }
    // private contract subjects
    var op interface{} = this.SafeString(message, "op")
    if ccxt.IsTrue(ccxt.IsEqual(op, "notify")) {
        var topic interface{} = this.SafeString(message, "topic", "")
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "orders"), 0)) {
            this.HandleOrder(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "account"), 0)) {
            this.HandleBalance(client, message)
        }
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "positions"), 0)) {
            this.HandlePositions(client, message)
        }
    }
}
func  (this *HtxCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    
                {
                     func(this *HtxCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *HtxCore) interface{} {
                                    // catch block:
                                            error := ccxt.NetworkError(ccxt.Add(ccxt.Add(this.Id, " pong failed "), this.Json(e)))
                    client.(ccxt.ClientInterface).Reset(error)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                var ping interface{} = this.SafeInteger(message, "ping")
                    if ccxt.IsTrue(!ccxt.IsEqual(ping, nil)) {
            
                        retRes199816 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                            "pong": ping,
                        }))
                        ccxt.PanicOnError(retRes199816)
            
                        return nil
                    }
                    var action interface{} = this.SafeString(message, "action")
                    if ccxt.IsTrue(ccxt.IsEqual(action, "ping")) {
                        var data interface{} = this.SafeValue(message, "data")
                        var pingTs interface{} = this.SafeInteger(data, "ts")
            
                        retRes200516 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                            "action": "pong",
                            "data": map[string]interface{} {
                                "ts": pingTs,
                            },
                        }))
                        ccxt.PanicOnError(retRes200516)
            
                        return nil
                    }
                    var op interface{} = this.SafeString(message, "op")
                    if ccxt.IsTrue(ccxt.IsEqual(op, "ping")) {
                        var pingTs interface{} = this.SafeInteger(message, "ts")
            
                        retRes201116 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                            "op": "pong",
                            "ts": pingTs,
                        }))
                        ccxt.PanicOnError(retRes201116)
                    }
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *HtxCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *HtxCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "action": "req",
    //         "code": 200,
    //         "ch": "auth",
    //         "data": {}
    //     }
    //
    // non spot
    //
    //    {
    //        "op": "auth",
    //        "type": "api",
    //        "err-code": 0,
    //        "ts": 1645200307319,
    //        "data": { "user-id": "35930539" }
    //    }
    //
    var promise interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), "auth")
    promise.(*ccxt.Future).Resolve(ccxt.ToGetsLimit(message))
}
func  (this *HtxCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "action": "sub",
    //         "code": 2002,
    //         "ch": "accounts.update#2",
    //         "message": "invalid.auth.state"
    //      }
    //
    //     {
    //         "ts": 1586323747018,
    //         "status": "error",
    //         'err-code': "bad-request",
    //         'err-msg': "invalid mbp.150.symbol linkusdt",
    //         "id": "2"
    //     }
    //
    //     {
    //         "op": "sub",
    //         "cid": "1",
    //         "topic": "accounts_unify.USDT",
    //         "err-code": 4007,
    //         'err-msg': "Non - single account user is not available, please check through the cross and isolated account asset interface",
    //         "ts": 1698419490189
    //     }
    //     {
    //         "action":"req",
    //         "code":2002,
    //         "ch":"auth",
    //         "message":"auth.fail"
    //     }
    //
    var status interface{} = this.SafeString(message, "status")
    if ccxt.IsTrue(ccxt.IsEqual(status, "error")) {
        var id interface{} = this.SafeString(message, "id")
        var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
        var subscription interface{} = this.SafeValue(subscriptionsById, id)
        if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
            var errorCode interface{} = this.SafeString(message, "err-code")
            
                {
                     func(this *HtxCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *HtxCore) interface{} {
                                    // catch block:
                                                    var messageHash interface{} = this.SafeString(subscription, "messageHash")
                            client.(ccxt.ClientInterface).Reject(e, messageHash)
                            client.(ccxt.ClientInterface).Reject(e, id)
                            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
                                ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
                            }
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                        this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), errorCode, this.Json(message))
                            panic(ccxt.ExchangeError(this.Json(message)))
            		    
            	    }(this)
                
                    }
        }
        return false
    }
    var code interface{} = this.SafeString2(message, "code", "err-code")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(code, nil)) && ccxt.IsTrue((ccxt.IsTrue((!ccxt.IsEqual(code, "200"))) && ccxt.IsTrue((!ccxt.IsEqual(code, "0")))))) {
        var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
        
            {
                 func(this *HtxCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *HtxCore) interface{} {
                                // catch block:
                                            if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                        client.(ccxt.ClientInterface).Reject(e, "auth")
                        var method interface{} = "auth"
                        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), method)) {
                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), method)
                        }
                        return false
                    } else {
                        client.(ccxt.ClientInterface).Reject(e)
                    }
                                return nil
                            }(this)
                        }
                    }()
        		    // try block:
                                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), code, feedback)
                    panic(ccxt.ExchangeError(feedback))
        		    
        	    }(this)
            
                }
    }
    return true
}
func  (this *HtxCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        //
        //     {"id":1583414227,"status":"ok","subbed":"market.btcusdt.mbp.150","ts":1583414229143}
        //
        // first ping format
        //
        //    {"ping": 1645106821667 }
        //
        // second ping format
        //
        //    {"action":"ping","data":{"ts":1645106821667}}
        //
        // third pong format
        //
        //
        // auth spot
        //
        //     {
        //         "action": "req",
        //         "code": 200,
        //         "ch": "auth",
        //         "data": {}
        //     }
        //
        // auth non spot
        //
        //    {
        //        "op": "auth",
        //        "type": "api",
        //        "err-code": 0,
        //        "ts": 1645200307319,
        //        "data": { "user-id": "35930539" }
        //    }
        //
        // trade
        //
        //     {
        //         "action":"push",
        //         "ch":"trade.clearing#ltcusdt#1",
        //         "data":{
        //             "eventType":"trade",
        //             // ?
        //         }
        //     }
        //
        if ccxt.IsTrue(ccxt.InOp(message, "id")) {
            this.HandleSubscriptionStatus(client, message)
            return
        }
        if ccxt.IsTrue(ccxt.InOp(message, "action")) {
            var action interface{} = this.SafeString(message, "action")
            if ccxt.IsTrue(ccxt.IsEqual(action, "ping")) {
                this.HandlePing(client, message)
                return
            }
            if ccxt.IsTrue(ccxt.IsEqual(action, "sub")) {
                this.HandleSubscriptionStatus(client, message)
                return
            }
        }
        if ccxt.IsTrue(ccxt.InOp(message, "ch")) {
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(message, "ch"), "auth")) {
                this.HandleAuthenticate(client, message)
                return
            } else {
                // route by channel aka topic aka subject
                this.HandleSubject(client, message)
                return
            }
        }
        if ccxt.IsTrue(ccxt.InOp(message, "op")) {
            var op interface{} = this.SafeString(message, "op")
            if ccxt.IsTrue(ccxt.IsEqual(op, "ping")) {
                this.HandlePing(client, message)
                return
            }
            if ccxt.IsTrue(ccxt.IsEqual(op, "auth")) {
                this.HandleAuthenticate(client, message)
                return
            }
            if ccxt.IsTrue(ccxt.IsEqual(op, "sub")) {
                this.HandleSubscriptionStatus(client, message)
                return
            }
            if ccxt.IsTrue(ccxt.IsEqual(op, "notify")) {
                this.HandleSubject(client, message)
                return
            }
        }
        if ccxt.IsTrue(ccxt.InOp(message, "ping")) {
            this.HandlePing(client, message)
        }
    }
}
func  (this *HtxCore) HandleMyTrade(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    // spot
    //
    //     {
    //         "action":"push",
    //         "ch":"trade.clearing#ltcusdt#1",
    //         "data":{
    //             "eventType":"trade",
    //             "symbol":"ltcusdt",
    //             "orderId":"478862728954426",
    //             "orderSide":"buy",
    //             "orderType":"buy-market",
    //             "accountId":44234548,
    //             "source":"spot-web",
    //             "orderValue":"5.01724137",
    //             "orderCreateTime":1645124660365,
    //             "orderStatus":"filled",
    //             "feeCurrency":"ltc",
    //             "tradePrice":"118.89",
    //             "tradeVolume":"0.042200701236437042",
    //             "aggressor":true,
    //             "tradeId":101539740584,
    //             "tradeTime":1645124660368,
    //             "transactFee":"0.000041778694224073",
    //             "feeDeduct":"0",
    //             "feeDeductType":""
    //         }
    //     }
    //
    // contract
    //
    //     {
    //         "symbol": "ADA/USDT:USDT"
    //         "ch": "orders_cross.ada-usdt"
    //         "trades": [
    //             {
    //                 "trade_fee":-0.022099447513812154,
    //                 "fee_asset":"ADA",
    //                 "trade_id":113913755890,
    //                 "id":"113913755890-773207641127878656-1",
    //                 "trade_volume":1,
    //                 "trade_price":0.0905,
    //                 "trade_turnover":10,
    //                 "created_at":1604388667194,
    //                 "profit":0,
    //                 "real_profit": 0,
    //                 "role":"maker"
    //             }
    //         ],
    //     }
    //
    extendParams := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = extendParams
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedTrades interface{} = this.MyTrades
    var messageHash interface{} = this.SafeString(message, "ch")
    if ccxt.IsTrue(!ccxt.IsEqual(messageHash, nil)) {
        var data interface{} = this.SafeValue(message, "data")
        if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
            var parsed interface{} = this.ParseWsTrade(data)
            var symbol interface{} = this.SafeString(parsed, "symbol")
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                cachedTrades.(ccxt.Appender).Append(parsed)
                client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
            }
        } else {
            // this trades object is artificially created
            // in handleOrder
            var rawTrades interface{} = this.SafeValue(message, "trades", []interface{}{})
            var marketId interface{} = this.SafeValue(message, "symbol")
            var market interface{} = this.Market(marketId)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
                var trade interface{} = ccxt.GetValue(rawTrades, i)
                var parsedTrade interface{} = this.ParseTrade(trade, market)
                // add extra params (side, type, ...) coming from the order
                parsedTrade = this.Extend(parsedTrade, extendParams)
                cachedTrades.(ccxt.Appender).Append(parsedTrade)
            }
            // messageHash here is the orders one, so
            // we have to recreate the trades messageHash = orderMessageHash + ':' + 'trade'
            var tradesHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), "trade")
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, tradesHash)
            // when we make an global order sub we have to send the channel like this
            // ch = orders_cross.* and we store messageHash = 'orders_cross'
            // however it is returned with the specific order update symbol: ch = orders_cross.btc-usd
            // since this is a global sub, our messageHash does not specify any symbol (ex: orders_cross:trade)
            // so we must remove it
            var genericOrderHash interface{} = ccxt.Replace(messageHash, ccxt.Add(".", ccxt.GetValue(market, "lowercaseId")), "")
            var lowerCaseBaseId interface{} = this.SafeStringLower(market, "baseId")
            genericOrderHash = ccxt.Replace(genericOrderHash, ccxt.Add(".", lowerCaseBaseId), "")
            var genericTradesHash interface{} = ccxt.Add(ccxt.Add(genericOrderHash, ":"), "trade")
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, genericTradesHash)
        }
    }
}
func  (this *HtxCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // spot private
    //
    //     {
    //         "eventType":"trade",
    //         "symbol":"ltcusdt",
    //         "orderId":"478862728954426",
    //         "orderSide":"buy",
    //         "orderType":"buy-market",
    //         "accountId":44234548,
    //         "source":"spot-web",
    //         "orderValue":"5.01724137",
    //         "orderCreateTime":1645124660365,
    //         "orderStatus":"filled",
    //         "feeCurrency":"ltc",
    //         "tradePrice":"118.89",
    //         "tradeVolume":"0.042200701236437042",
    //         "aggressor":true,
    //         "tradeId":101539740584,
    //         "tradeTime":1645124660368,
    //         "transactFee":"0.000041778694224073",
    //         "feeDeduct":"0",
    //         "feeDeductType":""
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(this.SafeString(trade, "symbol"))
    var side interface{} = this.SafeString2(trade, "side", "orderSide")
    var tradeId interface{} = this.SafeString(trade, "tradeId")
    var price interface{} = this.SafeString(trade, "tradePrice")
    var amount interface{} = this.SafeString(trade, "tradeVolume")
    var order interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeInteger(trade, "tradeTime")
    market = this.Market(symbol)
    var orderType interface{} = this.SafeString(trade, "orderType")
    var aggressor interface{} = this.SafeValue(trade, "aggressor")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(aggressor, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(aggressor), "taker", "maker")
    }
    var typeVar interface{} = nil
    var orderTypeParts interface{} = []interface{}{}
    if ccxt.IsTrue(!ccxt.IsEqual(orderType, nil)) {
        orderTypeParts = ccxt.Split(orderType, "-")
        typeVar = this.SafeString(orderTypeParts, 1)
    }
    var fee interface{} = nil
    var feeCurrency interface{} = this.SafeCurrencyCode(this.SafeString(trade, "feeCurrency"))
    if ccxt.IsTrue(!ccxt.IsEqual(feeCurrency, nil)) {
        fee = map[string]interface{} {
            "cost": this.SafeString(trade, "transactFee"),
            "currency": feeCurrency,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": tradeId,
        "order": order,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
func  (this *HtxCore) GetUrlByMarketType(typeVar interface{}, optionalArgs ...interface{}) interface{}  {
    isLinear := ccxt.GetArg(optionalArgs, 0, true)
    _ = isLinear
    isPrivate := ccxt.GetArg(optionalArgs, 1, false)
    _ = isPrivate
    isFeed := ccxt.GetArg(optionalArgs, 2, false)
    _ = isFeed
    var api interface{} = this.SafeString(this.Options, "api", "api")
    var hostname interface{} = map[string]interface{} {
        "hostname": this.Hostname,
    }
    var hostnameURL interface{} = nil
    var url interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        if ccxt.IsTrue(isPrivate) {
            hostnameURL = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "spot"), "private")
        } else {
            if ccxt.IsTrue(isFeed) {
                hostnameURL = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "spot"), "feed")
            } else {
                hostnameURL = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), "spot"), "public")
            }
        }
        url = this.ImplodeParams(hostnameURL, hostname)
    } else {
        var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), api), typeVar)
        var subTypeUrl interface{} = ccxt.Ternary(ccxt.IsTrue(isLinear), ccxt.GetValue(baseUrl, "linear"), ccxt.GetValue(baseUrl, "inverse"))
        url = ccxt.Ternary(ccxt.IsTrue(isPrivate), ccxt.GetValue(subTypeUrl, "private"), ccxt.GetValue(subTypeUrl, "public"))
    }
    return url
}
func  (this *HtxCore) SubscribePublic(url interface{}, symbol interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    method := ccxt.GetArg(optionalArgs, 0, nil)
            _ = method
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "sub": messageHash,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "symbol": symbol,
                "params": params,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.AddElementToObject(subscription, "method", method)
            }
        
                retRes242615 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes242615)
                ch <- retRes242615
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) UnsubscribePublic(market interface{}, subMessageHash interface{}, topic interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "unsub": subMessageHash,
                "id": requestId,
            }
            var messageHash interface{} = ccxt.Add("unsubscribe::", subMessageHash)
            var isFeed interface{} =     (ccxt.IsEqual(topic, "orderbook"))
            var url interface{} = this.GetUrlByMarketType(ccxt.GetValue(market, "type"), ccxt.GetValue(market, "linear"), false, isFeed)
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": requestId,
                "subMessageHashes": []interface{}{subMessageHash},
                "messageHashes": []interface{}{messageHash},
                "symbols": []interface{}{ccxt.GetValue(market, "symbol")},
                "topic": topic,
            }
            var symbolsAndTimeframes interface{} = this.SafeList(params, "symbolsAndTimeframes")
            if ccxt.IsTrue(!ccxt.IsEqual(symbolsAndTimeframes, nil)) {
                ccxt.AddElementToObject(subscription, "symbolsAndTimeframes", symbolsAndTimeframes)
                params = this.Omit(params, "symbolsAndTimeframes")
            }
        
                retRes245115 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes245115)
                ch <- retRes245115
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) SubscribePrivate(channel interface{}, messageHash interface{}, typeVar interface{}, subtype interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscriptionParams := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = subscriptionParams
            var requestId interface{} = this.RequestId()
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "params": params,
            }
            var extendedSubsription interface{} = this.Extend(subscription, subscriptionParams)
            var request interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                request = map[string]interface{} {
                    "action": "sub",
                    "ch": channel,
                }
            } else {
                request = map[string]interface{} {
                    "op": "sub",
                    "topic": channel,
                    "cid": requestId,
                }
            }
            var isLinear interface{} = ccxt.IsEqual(subtype, "linear")
            var url interface{} = this.GetUrlByMarketType(typeVar, isLinear, true)
            var hostname interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))), ccxt.GetValue(ccxt.GetValue(this.Urls, "hostnames"), "spot"), ccxt.GetValue(ccxt.GetValue(this.Urls, "hostnames"), "contract"))
            var authParams interface{} = map[string]interface{} {
                "type": typeVar,
                "url": url,
                "hostname": hostname,
            }
        
            retRes24838 := (<-this.Authenticate(authParams))
            ccxt.PanicOnError(retRes24838)
        
                retRes248415 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), channel, extendedSubsription))
                ccxt.PanicOnError(retRes248415)
                ch <- retRes248415
                return nil
        
            }()
            return ch
        }
func  (this *HtxCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = this.SafeString(params, "url")
            var hostname interface{} = this.SafeString(params, "hostname")
            var typeVar interface{} = this.SafeString(params, "type")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(url, nil)) || ccxt.IsTrue(ccxt.IsEqual(hostname, nil))) || ccxt.IsTrue(ccxt.IsEqual(typeVar, nil))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " authenticate requires a url, hostname and type argument")))
            }
            this.CheckRequiredCredentials()
            var messageHash interface{} = "auth"
            var relativePath interface{} = ccxt.Replace(url, ccxt.Add("wss://", hostname), "")
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var timestamp interface{} = this.Ymdhms(this.Milliseconds(), "T")
                var signatureParams interface{} = nil
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    signatureParams = map[string]interface{} {
                        "accessKey": this.ApiKey,
                        "signatureMethod": "HmacSHA256",
                        "signatureVersion": "2.1",
                        "timestamp": timestamp,
                    }
                } else {
                    signatureParams = map[string]interface{} {
                        "AccessKeyId": this.ApiKey,
                        "SignatureMethod": "HmacSHA256",
                        "SignatureVersion": "2",
                        "Timestamp": timestamp,
                    }
                }
                signatureParams = this.Keysort(signatureParams)
                var auth interface{} = this.Urlencode(signatureParams, true) // true required in go
                var payload interface{} = ccxt.Join([]interface{}{"GET", hostname, relativePath, auth}, "\n") // eslint-disable-line quotes
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var request interface{} = nil
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    var newParams interface{} = map[string]interface{} {
                        "authType": "api",
                        "accessKey": this.ApiKey,
                        "signatureMethod": "HmacSHA256",
                        "signatureVersion": "2.1",
                        "timestamp": timestamp,
                        "signature": signature,
                    }
                    request = map[string]interface{} {
                        "params": newParams,
                        "action": "req",
                        "ch": "auth",
                    }
                } else {
                    request = map[string]interface{} {
                        "op": "auth",
                        "type": "api",
                        "AccessKeyId": this.ApiKey,
                        "SignatureMethod": "HmacSHA256",
                        "SignatureVersion": "2",
                        "Timestamp": timestamp,
                        "Signature": signature,
                    }
                }
                var requestId interface{} = this.RequestId()
                var subscription interface{} = map[string]interface{} {
                    "id": requestId,
                    "messageHash": messageHash,
                    "params": params,
                }
                this.Watch(url, messageHash, request, messageHash, subscription)
            }
        
                retRes255615 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes255615)
                ch <- retRes255615
                return nil
        
            }()
            return ch
        }


func (this *HtxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
