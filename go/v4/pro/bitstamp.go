package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitstampCore struct {
	*ccxt.BitstampCore
	base *ccxt.BitstampCore
}

func NewBitstampCore() *BitstampCore {
    p := &BitstampCore{}
	base := &ccxt.BitstampCore{}
	p.base = base
	p.BitstampCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitstampCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOHLCV": false,
            "watchTicker": false,
            "watchTickers": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.bitstamp.net",
            },
        },
        "options": map[string]interface{} {
            "expiresIn": "",
            "userId": "",
            "wsSessionToken": "",
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 6,
                "snapshotMaxRetries": 3,
            },
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "4009": ccxt.AuthenticationError,
            },
        },
    })
}
/**
 * @method
 * @name bitstamp#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitstampCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes598)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var channel interface{} = ccxt.Add("diff_order_book_", ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "event": "bts:subscribe",
                "data": map[string]interface{} {
                    "channel": channel,
                },
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitstampCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //     {
    //         "data": {
    //             "timestamp": "1583656800",
    //             "microtimestamp": "1583656800237527",
    //             "bids": [
    //                 ["8732.02", "0.00002478", "1207590500704256"],
    //                 ["8729.62", "0.01600000", "1207590502350849"],
    //                 ["8727.22", "0.01800000", "1207590504296448"],
    //             ],
    //             "asks": [
    //                 ["8735.67", "2.00000000", "1207590693249024"],
    //                 ["8735.67", "0.01700000", "1207590693634048"],
    //                 ["8735.68", "1.53294500", "1207590692048896"],
    //             ],
    //         },
    //         "event": "data",
    //         "channel": "diff_order_book_btcusd"
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, "_")
    var marketId interface{} = this.SafeString(parts, 3)
    var symbol interface{} = this.SafeSymbol(marketId)
    var storedOrderBook interface{} = this.SafeValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeValue(storedOrderBook, "nonce")
    var delta interface{} = this.SafeValue(message, "data")
    var deltaNonce interface{} = this.SafeInteger(delta, "microtimestamp")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        var cacheLength interface{} =         ccxt.GetArrayLength(storedOrderBook.(ccxt.OrderBookInterface).GetCache())
        // the rest API is very delayed
        // usually it takes at least 4-5 deltas to resolve
        var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 6)
        if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
            this.Spawn(this.LoadOrderBook, client, messageHash, symbol, nil, map[string]interface{} {})
        }
        ccxt.AppendToArray(storedOrderBook.(ccxt.OrderBookInterface).GetCache(), delta)
        return
    } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(nonce, deltaNonce)) {
        return
    }
    this.HandleDelta(storedOrderBook, delta)
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *BitstampCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var timestamp interface{} = this.SafeTimestamp(delta, "timestamp")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(delta, "microtimestamp"))
    var bids interface{} = this.SafeValue(delta, "bids", []interface{}{})
    var asks interface{} = this.SafeValue(delta, "asks", []interface{}{})
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    this.HandleBidAsks(storedBids, bids)
    this.HandleBidAsks(storedAsks, asks)
}
func  (this *BitstampCore) HandleBidAsks(bookSide interface{}, bidAsks interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidAsks)); i++ {
        var bidAsk interface{} = this.ParseBidAsk(ccxt.GetValue(bidAsks, i))
        bookSide.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    }
}
func  (this *BitstampCore) GetCacheIndex(orderbook interface{}, deltas interface{}) interface{}  {
    // we will consider it a fail
    var firstElement interface{} = ccxt.GetValue(deltas, 0)
    var firstElementNonce interface{} = this.SafeInteger(firstElement, "microtimestamp")
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, firstElementNonce)) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        var delta interface{} = ccxt.GetValue(deltas, i)
        var deltaNonce interface{} = this.SafeInteger(delta, "microtimestamp")
        if ccxt.IsTrue(ccxt.IsEqual(deltaNonce, nonce)) {
            return ccxt.Add(i, 1)
        }
    }
    return ccxt.GetArrayLength(deltas)
}
/**
 * @method
 * @name bitstamp#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BitstampCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1758)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var channel interface{} = ccxt.Add("live_trades_", ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "event": "bts:subscribe",
                "data": map[string]interface{} {
                    "channel": channel,
                },
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BitstampCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "buy_order_id": 1211625836466176,
    //         "amount_str": "1.08000000",
    //         "timestamp": "1584642064",
    //         "microtimestamp": "1584642064685000",
    //         "id": 108637852,
    //         "amount": 1.08,
    //         "sell_order_id": 1211625840754689,
    //         "price_str": "6294.77",
    //         "type": 1,
    //         "price": 6294.77
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var microtimestamp interface{} = this.SafeInteger(trade, "microtimestamp")
    var id interface{} = this.SafeString(trade, "id")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microtimestamp, 1000))
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "amount")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var sideRaw interface{} = this.SafeInteger(trade, "type")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideRaw, 0))), "buy", "sell")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": nil,
        "type": nil,
        "takerOrMaker": nil,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *BitstampCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "buy_order_id": 1207733769326592,
    //             "amount_str": "0.14406384",
    //             "timestamp": "1583691851",
    //             "microtimestamp": "1583691851934000",
    //             "id": 106833903,
    //             "amount": 0.14406384,
    //             "sell_order_id": 1207733765476352,
    //             "price_str": "8302.92",
    //             "type": 0,
    //             "price": 8302.92
    //         },
    //         "event": "trade",
    //         "channel": "live_trades_btcusd"
    //     }
    //
    // the trade streams push raw trade information in real-time
    // each trade has a unique buyer and seller
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, "_")
    var marketId interface{} = this.SafeString(parts, 2)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var data interface{} = this.SafeValue(message, "data")
    var trade interface{} = this.ParseWsTrade(data, market)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    }
    tradesArray.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name bitstamp#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BitstampCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrders() requires a symbol argument")))
            }
        
            retRes2888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2888)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var channel interface{} = "private-my_orders"
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "_"), ccxt.GetValue(market, "id"))
            var subscription interface{} = map[string]interface{} {
                "symbol": symbol,
                "limit": limit,
                "type": channel,
                "params": params,
            }
        
            orders:= (<-this.SubscribePrivate(subscription, messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BitstampCore) HandleOrders(client interface{}, message interface{})  {
    //
    // {
    //     "data":{
    //        "id":"1463471322288128",
    //        "id_str":"1463471322288128",
    //        "order_type":1,
    //        "datetime":"1646127778",
    //        "microtimestamp":"1646127777950000",
    //        "amount":0.05,
    //        "amount_str":"0.05000000",
    //        "price":1000,
    //        "price_str":"1000.00"
    //     },
    //     "channel":"private-my_orders_ltcusd-4848701",
    //     "event": "order_deleted" // field only present for cancelOrder
    // }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var order interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.Orders
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), channel)
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var market interface{} = this.Market(symbol)
    ccxt.AddElementToObject(order, "event", this.SafeString(message, "event"))
    var parsed interface{} = this.ParseWsOrder(order, market)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(this.Orders, channel)
}
func  (this *BitstampCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": "1894876776091648",
    //        "id_str": "1894876776091648",
    //        "order_type": 0,
    //        "order_subtype": 0,
    //        "datetime": "1751451375",
    //        "microtimestamp": "1751451375070000",
    //        "amount": 1.1,
    //        "amount_str": "1.10000000",
    //        "amount_traded": "0",
    //        "amount_at_create": "1.10000000",
    //        "price": 10.23,
    //        "price_str": "10.23",
    //        "is_liquidation": false,
    //        "trade_account_id": 0
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id_str")
    var orderTypeRaw interface{} = this.SafeStringLower(order, "order_type")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(orderTypeRaw, "1"))), "sell", "buy")
    var orderSubTypeRaw interface{} = this.SafeStringLower(order, "order_subtype") // https://www.bitstamp.net/websocket/v2/#:~:text=order_subtype
    var orderType interface{} = nil
    var timeInForce interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(orderSubTypeRaw, "0")) {
        orderType = "limit"
    } else if ccxt.IsTrue(ccxt.IsEqual(orderSubTypeRaw, "2")) {
        orderType = "market"
    } else if ccxt.IsTrue(ccxt.IsEqual(orderSubTypeRaw, "4")) {
        orderType = "limit"
        timeInForce = "IOC"
    } else if ccxt.IsTrue(ccxt.IsEqual(orderSubTypeRaw, "6")) {
        orderType = "limit"
        timeInForce = "FOK"
    } else if ccxt.IsTrue(ccxt.IsEqual(orderSubTypeRaw, "8")) {
        orderType = "limit"
        timeInForce = "GTD"
    }
    var price interface{} = this.SafeString(order, "price_str")
    var amount interface{} = this.SafeString(order, "amount_str")
    var filled interface{} = this.SafeString(order, "amount_traded")
    var event interface{} = this.SafeString(order, "event")
    var status interface{} = nil
    if ccxt.IsTrue(ccxt.Precise.StringEq(filled, amount)) {
        status = "closed"
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "order_deleted")) {
        status = "canceled"
    }
    var timestamp interface{} = this.SafeTimestamp(order, "datetime")
    market = this.SafeMarket(nil, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": orderType,
        "timeInForce": timeInForce,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *BitstampCore) HandleOrderBookSubscription(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, "_")
    var marketId interface{} = this.SafeString(parts, 3)
    var symbol interface{} = this.SafeSymbol(marketId)
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
}
func  (this *BitstampCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "bts:subscription_succeeded",
    //         "channel": "detail_order_book_btcusd",
    //         "data": {},
    //     }
    //     {
    //         "event": "bts:subscription_succeeded",
    //         "channel": "private-my_orders_ltcusd-4848701",
    //         "data": {}
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "order_book"), ccxt.OpNeg(1))) {
        this.HandleOrderBookSubscription(client, message)
    }
}
func  (this *BitstampCore) HandleSubject(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "timestamp": "1583656800",
    //             "microtimestamp": "1583656800237527",
    //             "bids": [
    //                 ["8732.02", "0.00002478", "1207590500704256"],
    //                 ["8729.62", "0.01600000", "1207590502350849"],
    //                 ["8727.22", "0.01800000", "1207590504296448"],
    //             ],
    //             "asks": [
    //                 ["8735.67", "2.00000000", "1207590693249024"],
    //                 ["8735.67", "0.01700000", "1207590693634048"],
    //                 ["8735.68", "1.53294500", "1207590692048896"],
    //             ],
    //         },
    //         "event": "data",
    //         "channel": "detail_order_book_btcusd"
    //     }
    //
    // private order
    //     {
    //         "data":{
    //         "id":"1463471322288128",
    //         "id_str":"1463471322288128",
    //         "order_type":1,
    //         "datetime":"1646127778",
    //         "microtimestamp":"1646127777950000",
    //         "amount":0.05,
    //         "amount_str":"0.05000000",
    //         "price":1000,
    //         "price_str":"1000.00"
    //         },
    //         "channel":"private-my_orders_ltcusd-4848701",
    //         "event": "order_deleted" // field only present for cancelOrder
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var methods interface{} = map[string]interface{} {
        "live_trades": this.HandleTrade,
        "diff_order_book": this.HandleOrderBook,
        "private-my_orders": this.HandleOrders,
    }
    var keys interface{} = ccxt.ObjectKeys(methods)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, key), ccxt.OpNeg(1))) {
            var method interface{} = ccxt.GetValue(methods, key)
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *BitstampCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    // {
    //     "event": "bts:error",
    //     "channel": '',
    //     "data": { code: 4009, message: "Connection is unauthorized." }
    // }
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "bts:error")) {
        var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
        var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
        var code interface{} = this.SafeNumber(data, "code")
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
    }
    return true
}
func  (this *BitstampCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     {
    //         "event": "bts:subscription_succeeded",
    //         "channel": "detail_order_book_btcusd",
    //         "data": {},
    //     }
    //
    //     {
    //         "data": {
    //             "timestamp": "1583656800",
    //             "microtimestamp": "1583656800237527",
    //             "bids": [
    //                 ["8732.02", "0.00002478", "1207590500704256"],
    //                 ["8729.62", "0.01600000", "1207590502350849"],
    //                 ["8727.22", "0.01800000", "1207590504296448"],
    //             ],
    //             "asks": [
    //                 ["8735.67", "2.00000000", "1207590693249024"],
    //                 ["8735.67", "0.01700000", "1207590693634048"],
    //                 ["8735.68", "1.53294500", "1207590692048896"],
    //             ],
    //         },
    //         "event": "data",
    //         "channel": "detail_order_book_btcusd"
    //     }
    //
    //     {
    //         "event": "bts:subscription_succeeded",
    //         "channel": "private-my_orders_ltcusd-4848701",
    //         "data": {}
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "bts:subscription_succeeded")) {
        this.HandleSubscriptionStatus(client, message)
    } else {
        this.HandleSubject(client, message)
    }
}
func  (this *BitstampCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var time interface{} = this.Milliseconds()
            var expiresIn interface{} = this.SafeInteger(this.Options, "expiresIn")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(expiresIn, nil))) || ccxt.IsTrue((ccxt.IsGreaterThan(time, expiresIn)))) {
        
                response:= (<-this.PrivatePostWebsocketsToken(params))
                ccxt.PanicOnError(response)
                //
                // {
                //     "valid_sec":60,
                //     "token":"siPaT4m6VGQCdsDCVbLBemiphHQs552e",
                //     "user_id":4848701
                // }
                //
                var sessionToken interface{} = this.SafeString(response, "token")
                if ccxt.IsTrue(!ccxt.IsEqual(sessionToken, nil)) {
                    var userId interface{} = this.SafeString(response, "user_id")
                    var validity interface{} = this.SafeIntegerProduct(response, "valid_sec", 1000)
                    ccxt.AddElementToObject(this.Options, "expiresIn", this.Sum(time, validity))
                    ccxt.AddElementToObject(this.Options, "userId", userId)
                    ccxt.AddElementToObject(this.Options, "wsSessionToken", sessionToken)
                }
            }
                return nil
            }()
            return ch
        }
func  (this *BitstampCore) SubscribePrivate(subscription interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
            retRes5858 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5858)
            messageHash = ccxt.Add(messageHash, ccxt.Add("-", ccxt.GetValue(this.Options, "userId")))
            var request interface{} = map[string]interface{} {
                "event": "bts:subscribe",
                "data": map[string]interface{} {
                    "channel": messageHash,
                    "auth": ccxt.GetValue(this.Options, "wsSessionToken"),
                },
            }
            ccxt.AddElementToObject(subscription, "messageHash", messageHash)
        
                retRes59515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes59515)
                ch <- retRes59515
                return nil
        
            }()
            return ch
        }


func (this *BitstampCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
