package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type OkxCore struct {
	*ccxt.OkxCore
	base *ccxt.OkxCore
}

func NewOkxCore() *OkxCore {
    p := &OkxCore{}
	base := &ccxt.OkxCore{}
	p.base = base
	p.OkxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *OkxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchMarkPrice": true,
            "watchMarkPrices": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchOrderBook": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBookForSymbols": true,
            "watchBalance": true,
            "watchLiquidations": "emulated",
            "watchLiquidationsForSymbols": true,
            "watchMyLiquidations": "emulated",
            "watchMyLiquidationsForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchPositions": true,
            "watchFundingRate": true,
            "watchFundingRates": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "cancelAllOrdersWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.okx.com:8443/ws/v5",
            },
            "test": map[string]interface{} {
                "ws": "wss://wspap.okx.com:8443/ws/v5",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "checksum": true,
                "depth": "books",
            },
            "watchBalance": "spot",
            "watchTicker": map[string]interface{} {
                "channel": "tickers",
            },
            "watchTickers": map[string]interface{} {
                "channel": "tickers",
            },
            "watchOrders": map[string]interface{} {
                "type": "ANY",
            },
            "watchMyTrades": map[string]interface{} {
                "type": "ANY",
            },
            "createOrderWs": map[string]interface{} {
                "op": "batch-orders",
            },
            "editOrderWs": map[string]interface{} {
                "op": "amend-order",
            },
            "ws": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 18000,
        },
    })
}
func  (this *OkxCore) GetUrl(channel interface{}, optionalArgs ...interface{}) interface{}  {
    // for context: https://www.okx.com/help-center/changes-to-v5-api-websocket-subscription-parameter-and-url
    access := ccxt.GetArg(optionalArgs, 0, "public")
    _ = access
    var isSandbox interface{} = ccxt.GetValue(this.Options, "sandboxMode")
    var sandboxSuffix interface{} = ccxt.Ternary(ccxt.IsTrue(isSandbox), "?brokerId=9999", "")
    var isBusiness interface{} =     (ccxt.IsEqual(access, "business"))
    var isPublic interface{} =     (ccxt.IsEqual(access, "public"))
    var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isBusiness) || ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "candle"), ccxt.OpNeg(1))))) || ccxt.IsTrue((ccxt.IsEqual(channel, "orders-algo")))) {
        return ccxt.Add(ccxt.Add(url, "/business"), sandboxSuffix)
    } else if ccxt.IsTrue(isPublic) {
        return ccxt.Add(ccxt.Add(url, "/public"), sandboxSuffix)
    }
    return ccxt.Add(ccxt.Add(url, "/private"), sandboxSuffix)
}
func  (this *OkxCore) SubscribeMultiple(access interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1288)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            symbols = this.MarketSymbols(symbols)
            var url interface{} = this.GetUrl(channel, access)
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var marketId interface{} = this.MarketId(ccxt.GetValue(symbols, i))
                var arg interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&args, this.Extend(arg, params))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, "::"), ccxt.GetValue(symbols, i)))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": args,
            }
        
                retRes14915 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes14915)
                ch <- retRes14915
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) Subscribe(access interface{}, messageHash interface{}, channel interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1538)
            var url interface{} = this.GetUrl(channel, access)
            var firstArgument interface{} = map[string]interface{} {
                "channel": channel,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
                ccxt.AddElementToObject(firstArgument, "instId", ccxt.GetValue(market, "id"))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{this.DeepExtend(firstArgument, params)},
            }
        
                retRes16915 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes16915)
                ch <- retRes16915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchTrades
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-trades-channel
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-all-trades-channel
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *OkxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes18515 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes18515)
                ch <- retRes18515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchTradesForSymbols
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-trades-channel
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-all-trades-channel
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbols
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, trades by default. Can be 'trades' and 'trades-all'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *OkxCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes2068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2068)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTrades", "channel", "trades")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
            var access interface{} = "public"
            if ccxt.IsTrue(ccxt.IsEqual(channel, "trades-all")) {
                access = "business"
        
                retRes22912 := (<-this.Authenticate(map[string]interface{} {
                    "access": access,
                }))
                ccxt.PanicOnError(retRes22912)
            }
            var url interface{} = this.GetUrl(channel, access)
        
            trades:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchTradesForSymbols
 * @description unWatches from the stream channel
 * @param {string[]} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, trades by default. Can be trades, trades-all
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *OkxCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2518)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTrades", "channel", "trades")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", channel), ":"), symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
            var access interface{} = "public"
            if ccxt.IsTrue(ccxt.IsEqual(channel, "trades-all")) {
                access = "business"
        
                retRes27412 := (<-this.Authenticate(map[string]interface{} {
                    "access": access,
                }))
                ccxt.PanicOnError(retRes27412)
            }
            var url interface{} = this.GetUrl(channel, access)
        
                retRes27715 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes27715)
                ch <- retRes27715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchTrades
 * @description unWatches from the stream channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *OkxCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes28915 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes28915)
                ch <- retRes28915
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "arg": { channel: "trades", instId: "BTC-USDT" },
    //         "data": [
    //             {
    //                 "instId": "BTC-USDT",
    //                 "tradeId": "216970876",
    //                 "px": "31684.5",
    //                 "sz": "0.00001186",
    //                 "side": "buy",
    //                 "ts": "1626531038288"
    //             }
    //         ]
    //     }
    //     {
    //         "arg": {
    //             "channel": "trades-all",
    //             "instId": "BTC-USDT"
    //         },
    //         "data": [
    //             {
    //                 "instId": "BTC-USDT",
    //                 "tradeId": "130639474",
    //                 "px": "42219.9",
    //                 "sz": "0.12060306",
    //                 "side": "buy",
    //                 "source": "0",
    //                 "ts": "1630048897897"
    //             }
    //         ]
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var marketId interface{} = this.SafeString(arg, "instId")
    var symbol interface{} = this.SafeSymbol(marketId)
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(data, i))
        var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            stored = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        stored.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name okx#watchFundingRate
 * @description watch the current funding rate
 * @see https://www.okx.com/docs-v5/en/#public-data-websocket-funding-rate-channel
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func  (this *OkxCore) WatchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            symbol = this.Symbol(symbol)
        
            fr:= (<-this.WatchFundingRates([]interface{}{symbol}, params))
            ccxt.PanicOnError(fr)
        
            ch <- ccxt.GetValue(fr, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchFundingRates
 * @description watch the funding rate for multiple markets
 * @see https://www.okx.com/docs-v5/en/#public-data-websocket-funding-rate-channel
 * @param {string[]} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexe by market symbols
 */
func  (this *OkxCore) WatchFundingRates(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3698)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = "funding-rate"
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl(channel, "public")
        
            fundingRate:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(fundingRate)
            if ccxt.IsTrue(this.NewUpdates) {
                var symbol interface{} = this.SafeString(fundingRate, "symbol")
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, symbol, fundingRate)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.FundingRates, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleFundingRate(client interface{}, message interface{})  {
    //
    // "data":[
    //     {
    //        "fundingRate":"0.0001875391284828",
    //        "fundingTime":"1700726400000",
    //        "instId":"BTC-USD-SWAP",
    //        "instType":"SWAP",
    //        "method": "next_period",
    //        "maxFundingRate":"0.00375",
    //        "minFundingRate":"-0.00375",
    //        "nextFundingRate":"0.0002608059239328",
    //        "nextFundingTime":"1700755200000",
    //        "premium": "0.0001233824646391",
    //        "settFundingRate":"0.0001699799259033",
    //        "settState":"settled",
    //        "ts":"1700724675402"
    //     }
    // ]
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawfr interface{} = ccxt.GetValue(data, i)
        var fundingRate interface{} = this.ParseFundingRate(rawfr)
        var symbol interface{} = ccxt.GetValue(fundingRate, "symbol")
        ccxt.AddElementToObject(this.FundingRates, symbol, fundingRate)
        client.(ccxt.ClientInterface).Resolve(fundingRate, ccxt.Add(ccxt.Add("funding-rate", ":"), ccxt.GetValue(fundingRate, "symbol")))
    }
}
/**
 * @method
 * @name okx#watchTicker
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTicker", "channel", "tickers")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            ccxt.AddElementToObject(params, "channel", channel)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            ticker:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(ticker)
        
            ch <- this.SafeValue(ticker, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchTicker
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes46015 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes46015)
                ch <- retRes46015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchTickers
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4748)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "channel", "tickers")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
            newTickers:= (<-this.SubscribeMultiple("public", channel, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchMarkPrice
 * @see https://www.okx.com/docs-v5/en/#public-data-websocket-mark-price-channel
 * @description watches a mark price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) WatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchMarkPrice", "channel", "mark-price")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            ccxt.AddElementToObject(params, "channel", channel)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            ticker:= (<-this.WatchMarkPrices([]interface{}{symbol}, params))
            ccxt.PanicOnError(ticker)
        
            ch <- ccxt.GetValue(ticker, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchMarkPrices
 * @see https://www.okx.com/docs-v5/en/#public-data-websocket-mark-price-channel
 * @description watches mark prices
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) WatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5168)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchMarkPrices", "channel", "mark-price")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
            newTickers:= (<-this.SubscribeMultiple("public", channel, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchTickers
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5388)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "channel", "tickers")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl(channel, "public")
        
                retRes55915 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes55915)
                ch <- retRes55915
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "arg": { channel: "tickers", instId: "BTC-USDT" },
    //         "data": [
    //             {
    //                 "instType": "SPOT",
    //                 "instId": "BTC-USDT",
    //                 "last": "31500.1",
    //                 "lastSz": "0.00001754",
    //                 "askPx": "31500.1",
    //                 "askSz": "0.00998144",
    //                 "bidPx": "31500",
    //                 "bidSz": "3.05652439",
    //                 "open24h": "31697",
    //                 "high24h": "32248",
    //                 "low24h": "31165.6",
    //                 "sodUtc0": "31385.5",
    //                 "sodUtc8": "32134.9",
    //                 "volCcy24h": "503403597.38138519",
    //                 "vol24h": "15937.10781721",
    //                 "ts": "1626526618762"
    //             }
    //         ]
    //     }
    //
    this.HandleBidAsk(client, message)
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var channel interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var newTickers interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.ParseTicker(ccxt.GetValue(data, i))
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        ccxt.AddElementToObject(newTickers, symbol, ticker)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "::"), symbol)
    client.(ccxt.ClientInterface).Resolve(newTickers, messageHash)
}
/**
 * @method
 * @name okx#watchBidsAsks
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-tickers-channel
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *OkxCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6158)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchBidsAsks", "channel", "tickers")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var url interface{} = this.GetUrl(channel, "public")
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var marketId interface{} = this.MarketId(ccxt.GetValue(symbols, i))
                var arg interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&args, this.Extend(arg, params))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask::", ccxt.GetValue(symbols, i)))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": args,
            }
        
            newTickers:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "arg": { channel: "tickers", instId: "BTC-USDT" },
    //         "data": [
    //             {
    //                 "instType": "SPOT",
    //                 "instId": "BTC-USDT",
    //                 "last": "31500.1",
    //                 "lastSz": "0.00001754",
    //                 "askPx": "31500.1",
    //                 "askSz": "0.00998144",
    //                 "bidPx": "31500",
    //                 "bidSz": "3.05652439",
    //                 "open24h": "31697",
    //                 "high24h": "32248",
    //                 "low24h": "31165.6",
    //                 "sodUtc0": "31385.5",
    //                 "sodUtc8": "32134.9",
    //                 "volCcy24h": "503403597.38138519",
    //                 "vol24h": "15937.10781721",
    //                 "ts": "1626526618762"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = this.SafeDict(data, 0, map[string]interface{} {})
    var parsedTicker interface{} = this.ParseWsBidAsk(ticker)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask::", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *OkxCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instId")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "ts")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "askPx"),
        "askVolume": this.SafeString(ticker, "askSz"),
        "bid": this.SafeString(ticker, "bidPx"),
        "bidVolume": this.SafeString(ticker, "bidSz"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name okx#watchLiquidationsForSymbols
 * @description watch the public liquidations of a trading pair
 * @see https://www.okx.com/docs-v5/en/#public-data-websocket-liquidation-orders-channel
 * @param {string} symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the okx api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *OkxCore) WatchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7088)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var messageHash interface{} = "liquidations"
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchliquidationsForSymbols", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var channel interface{} = "liquidation-orders"
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                typeVar = "SWAP"
            } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                typeVar = "futures"
            }
            var uppercaseType interface{} = ccxt.ToUpper(typeVar)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{map[string]interface{} {
            "channel": channel,
            "instType": uppercaseType,
        }},
            }
            var url interface{} = this.GetUrl(channel, "public")
        
            newLiquidations:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    //    {
    //        "arg": {
    //            "channel": "liquidation-orders",
    //            "instType": "SWAP"
    //        },
    //        "data": [
    //            {
    //                "details": [
    //                    {
    //                        "bkLoss": "0",
    //                        "bkPx": "0.007831",
    //                        "ccy": "",
    //                        "posSide": "short",
    //                        "side": "buy",
    //                        "sz": "13",
    //                        "ts": "1692266434010"
    //                    }
    //                ],
    //                "instFamily": "IOST-USDT",
    //                "instId": "IOST-USDT-SWAP",
    //                "instType": "SWAP",
    //                "uly": "IOST-USDT"
    //            }
    //        ]
    //    }
    //
    var rawLiquidations interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawLiquidations)); i++ {
        var rawLiquidation interface{} = ccxt.GetValue(rawLiquidations, i)
        var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation)
        var symbol interface{} = this.SafeString(liquidation, "symbol")
        var liquidations interface{} = this.SafeValue(this.Liquidations, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "liquidationsLimit", 1000)
            liquidations = ccxt.NewArrayCache(limit)
        }
        liquidations.(ccxt.Appender).Append(liquidation)
        ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "liquidations")
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("liquidations::", symbol))
    }
}
/**
 * @method
 * @name okx#watchMyLiquidationsForSymbols
 * @description watch the private liquidations of a trading pair
 * @see https://www.okx.com/docs-v5/en/#trading-account-websocket-balance-and-position-channel
 * @param {string[]} symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the okx api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *OkxCore) WatchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8048 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8048)
            var isTrigger interface{} = this.SafeValue2(params, "stop", "trigger", false)
            params = this.Omit(params, []interface{}{"stop", "trigger"})
        
            retRes8078 := (<-this.Authenticate(map[string]interface{} {
                "access": ccxt.Ternary(ccxt.IsTrue(isTrigger), "business", "private"),
            }))
            ccxt.PanicOnError(retRes8078)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var messageHash interface{} = "myLiquidations"
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            var channel interface{} = "balance_and_position"
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{map[string]interface{} {
            "channel": channel,
        }},
            }
            var url interface{} = this.GetUrl(channel, "private")
        
            newLiquidations:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), messageHashes))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleMyLiquidation(client interface{}, message interface{})  {
    //
    //    {
    //        "arg": {
    //            "channel": "balance_and_position",
    //            "uid": "77982378738415879"
    //        },
    //        "data": [{
    //            "pTime": "1597026383085",
    //            "eventType": "snapshot",
    //            "balData": [{
    //                "ccy": "BTC",
    //                "cashBal": "1",
    //                "uTime": "1597026383085"
    //            }],
    //            "posData": [{
    //                "posId": "1111111111",
    //                "tradeId": "2",
    //                "instId": "BTC-USD-191018",
    //                "instType": "FUTURES",
    //                "mgnMode": "cross",
    //                "posSide": "long",
    //                "pos": "10",
    //                "ccy": "BTC",
    //                "posCcy": "",
    //                "avgPx": "3320",
    //                "uTIme": "1597026383085"
    //            }],
    //            "trades": [{
    //                "instId": "BTC-USD-191018",
    //                "tradeId": "2",
    //            }]
    //        }]
    //    }
    //
    var rawLiquidations interface{} = this.SafeList(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawLiquidations)); i++ {
        var rawLiquidation interface{} = ccxt.GetValue(rawLiquidations, i)
        var eventType interface{} = this.SafeString(rawLiquidation, "eventType")
        if ccxt.IsTrue(!ccxt.IsEqual(eventType, "liquidation")) {
            return
        }
        var liquidation interface{} = this.ParseWsMyLiquidation(rawLiquidation)
        var symbol interface{} = this.SafeString(liquidation, "symbol")
        var liquidations interface{} = this.SafeValue(this.Liquidations, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "myLiquidationsLimit", 1000)
            liquidations = ccxt.NewArrayCache(limit)
        }
        liquidations.(ccxt.Appender).Append(liquidation)
        ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "myLiquidations")
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("myLiquidations::", symbol))
    }
}
func  (this *OkxCore) ParseWsMyLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "pTime": "1597026383085",
    //        "eventType": "snapshot",
    //        "balData": [{
    //            "ccy": "BTC",
    //            "cashBal": "1",
    //            "uTime": "1597026383085"
    //        }],
    //        "posData": [{
    //            "posId": "1111111111",
    //            "tradeId": "2",
    //            "instId": "BTC-USD-191018",
    //            "instType": "FUTURES",
    //            "mgnMode": "cross",
    //            "posSide": "long",
    //            "pos": "10",
    //            "ccy": "BTC",
    //            "posCcy": "",
    //            "avgPx": "3320",
    //            "uTIme": "1597026383085"
    //        }],
    //        "trades": [{
    //            "instId": "BTC-USD-191018",
    //            "tradeId": "2",
    //        }]
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var posData interface{} = this.SafeList(liquidation, "posData", []interface{}{})
    var firstPosData interface{} = this.SafeDict(posData, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(firstPosData, "instId")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(firstPosData, "uTIme")
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": this.SafeNumber(firstPosData, "pos"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "price": this.SafeNumber(liquidation, "avgPx"),
        "baseValue": nil,
        "quoteValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
func  (this *OkxCore) ParseWsLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public liquidation
    //    {
    //        "details": [
    //            {
    //                "bkLoss": "0",
    //                "bkPx": "0.007831",
    //                "ccy": "",
    //                "posSide": "short",
    //                "side": "buy",
    //                "sz": "13",
    //                "ts": "1692266434010"
    //            }
    //        ],
    //        "instFamily": "IOST-USDT",
    //        "instId": "IOST-USDT-SWAP",
    //        "instType": "SWAP",
    //        "uly": "IOST-USDT"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var details interface{} = this.SafeList(liquidation, "details", []interface{}{})
    var liquidationDetails interface{} = this.SafeDict(details, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(liquidation, "instId")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(liquidationDetails, "ts")
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": this.SafeNumber(liquidationDetails, "sz"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "price": this.SafeNumber(liquidationDetails, "bkPx"),
        "side": this.SafeString(liquidationDetails, "side"),
        "baseValue": nil,
        "quoteValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
/**
 * @method
 * @name okx#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OkxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9918 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9918)
            symbol = this.Symbol(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var name interface{} = ccxt.Add("candle", interval)
        
            ohlcv:= (<-this.Subscribe("public", name, name, symbol, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OkxCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10128)
        
                retRes101315 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes101315)
                ch <- retRes101315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OkxCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
        
            retRes10318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10318)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var sym interface{} = ccxt.GetValue(symbolAndTimeframe, 0)
                var tf interface{} = ccxt.GetValue(symbolAndTimeframe, 1)
                var marketId interface{} = this.MarketId(sym)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                var channel interface{} = ccxt.Add("candle", interval)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("multi:", channel), ":"), sym))
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl("candle", "public")
            symboltimeframecandlesVariable := (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OkxCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
        
            retRes10748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10748)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var sym interface{} = ccxt.GetValue(symbolAndTimeframe, 0)
                var tf interface{} = ccxt.GetValue(symbolAndTimeframe, 1)
                var marketId interface{} = this.MarketId(sym)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                var channel interface{} = ccxt.Add("candle", interval)
                var topic interface{} = map[string]interface{} {
                    "channel": channel,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:multi:", channel), ":"), sym))
            }
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl("candle", "public")
        
                retRes109615 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes109615)
                ch <- retRes109615
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "arg": { channel: "candle1m", instId: "BTC-USDT" },
    //         "data": [
    //             [
    //                 "1626690720000",
    //                 "31334",
    //                 "31334",
    //                 "31334",
    //                 "31334",
    //                 "0.0077",
    //                 "241.2718"
    //             ]
    //         ]
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = ccxt.Replace(channel, "candle", "")
    // use a reverse lookup in a static map instead
    var timeframe interface{} = this.FindTimeframe(interval)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var parsed interface{} = this.ParseOHLCV(ccxt.GetValue(data, i), market)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(market, "id"))
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        // for multiOHLCV we need special object, as opposed to other "multi"
        // methods, because ccxt.OHLCV response item does not contain symbol
        // or timeframe, thus otherwise it would be unrecognizable
        var messageHashForMulti interface{} = ccxt.Add(ccxt.Add(ccxt.Add("multi:", channel), ":"), symbol)
        client.(ccxt.ClientInterface).Resolve([]interface{}{symbol, timeframe, stored}, messageHashForMulti)
    }
}
/**
 * @method
 * @name okx#watchOrderBook
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *OkxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            // bbo-tbt
            // 1. Newly added channel that sends tick-by-tick Level 1 data
            // 2. All API users can subscribe
            // 3. Public depth channel, verification not required
            //
            // books-l2-tbt
            // 1. Only users who're VIP5 and above can subscribe
            // 2. Identity verification required before subscription
            //
            // books50-l2-tbt
            // 1. Only users who're VIP4 and above can subscribe
            // 2. Identity verification required before subscription
            //
            // books
            // 1. All API users can subscribe
            // 2. Public depth channel, verification not required
            //
            // books5
            // 1. All API users can subscribe
            // 2. Public depth channel, verification not required
            // 3. Data feeds will be delivered every 100ms (vs. every 200ms now)
            //
            limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes118015 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes118015)
        ch <- retRes118015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchOrderBookForSymbols
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] 1,5, 400, 50 (l2-tbt, vip4+) or 40000 (vip5+) the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *OkxCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11958)
            symbols = this.MarketSymbols(symbols)
            var depth interface{} = nil
            depthparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "depth", "books")
            depth = ccxt.GetValue(depthparamsVariable,0)
            params = ccxt.GetValue(depthparamsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsEqual(limit, 1)) {
                    depth = "bbo-tbt"
                } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsGreaterThan(limit, 1)) && ccxt.IsTrue(ccxt.IsLessThanOrEqual(limit, 5))) {
                    depth = "books5"
                } else if ccxt.IsTrue(ccxt.IsEqual(limit, 50)) {
                    depth = "books50-l2-tbt" // Make sure you have VIP4 and above
                } else if ccxt.IsTrue(ccxt.IsEqual(limit, 400)) {
                    depth = "books"
                }
            }
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(depth, "books-l2-tbt"))) || ccxt.IsTrue((ccxt.IsEqual(depth, "books50-l2-tbt")))) {
                if !ccxt.IsTrue(this.CheckRequiredCredentials(false)) {
                    panic(ccxt.AuthenticationError(ccxt.Add(this.Id, " watchOrderBook/watchOrderBookForSymbols requires authentication for this depth. ccxt.Add credentials or change the depth option to books or books5")))
                }
        
                retRes121412 := (<-this.Authenticate(map[string]interface{} {
                    "access": "public",
                }))
                ccxt.PanicOnError(retRes121412)
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(depth, ":"), symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": depth,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl(depth, "public")
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchOrderBookForSymbols
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] the maximum amount of order book entries to return
 * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *OkxCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12498)
            symbols = this.MarketSymbols(symbols, nil, false)
            var depth interface{} = nil
            depthparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "depth", "books")
            depth = ccxt.GetValue(depthparamsVariable,0)
            params = ccxt.GetValue(depthparamsVariable,1)
            var limit interface{} = this.SafeInteger(params, "limit")
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsEqual(limit, 1)) {
                    depth = "bbo-tbt"
                } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsGreaterThan(limit, 1)) && ccxt.IsTrue(ccxt.IsLessThanOrEqual(limit, 5))) {
                    depth = "books5"
                } else if ccxt.IsTrue(ccxt.IsEqual(limit, 50)) {
                    depth = "books50-l2-tbt" // Make sure you have VIP4 and above
                } else if ccxt.IsTrue(ccxt.IsEqual(limit, 400)) {
                    depth = "books"
                }
            }
            var topics interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add(ccxt.Add(depth, ":"), symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = map[string]interface{} {
                    "channel": depth,
                    "instId": marketId,
                }
                ccxt.AppendToArray(&topics, topic)
            }
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": topics,
            }
            var url interface{} = this.GetUrl(depth, "public")
        
                retRes128415 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
                ccxt.PanicOnError(retRes128415)
                ch <- retRes128415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#unWatchOrderBook
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-ws-order-book-channel
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] the maximum amount of order book entries to return
 * @param {string} [params.depth] okx order book depth, can be books, books5, books-l2-tbt, books50-l2-tbt, bbo-tbt
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *OkxCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes129915 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes129915)
                ch <- retRes129915
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleDelta(bookside interface{}, delta interface{})  {
    //
    //     [
    //         "31685", // price
    //         "0.78069158", // amount
    //         "0", // liquidated orders
    //         "17" // orders
    //     ]
    //
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *OkxCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *OkxCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}, messageHash interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "asks": [
    //             [ '31738.3', '0.05973179', "0", "3" ],
    //             [ '31738.5', '0.11035404', "0", "2" ],
    //             [ '31739.6', '0.01', "0", "1" ],
    //         ],
    //         "bids": [
    //             [ '31738.2', '0.67557666', "0", "9" ],
    //             [ '31738', '0.02466947', "0", "2" ],
    //             [ '31736.3', '0.01705046', "0", "2" ],
    //         ],
    //         "instId": "BTC-USDT",
    //         "ts": "1626537446491"
    //         "checksum": -855196043,
    //         "prevSeqId": 123456,
    //         "seqId": 123457
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var asks interface{} = this.SafeValue(message, "asks", []interface{}{})
    var bids interface{} = this.SafeValue(message, "bids", []interface{}{})
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    this.HandleDeltas(storedAsks, asks)
    this.HandleDeltas(storedBids, bids)
    var marketId interface{} = this.SafeString(message, "instId")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
    var seqId interface{} = this.SafeInteger(message, "seqId")
    if ccxt.IsTrue(checksum) {
        var prevSeqId interface{} = this.SafeInteger(message, "prevSeqId")
        var nonce interface{} = ccxt.GetValue(orderbook, "nonce")
        var asksLength interface{} =         ccxt.GetArrayLength(storedAsks)
        var bidsLength interface{} =         ccxt.GetArrayLength(storedBids)
        var payloadArray interface{} = []interface{}{}
        for i := 0; ccxt.IsLessThan(i, 25); i++ {
            if ccxt.IsTrue(ccxt.IsLessThan(i, bidsLength)) {
                ccxt.AppendToArray(&payloadArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(storedBids, i), 0)))
                ccxt.AppendToArray(&payloadArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(storedBids, i), 1)))
            }
            if ccxt.IsTrue(ccxt.IsLessThan(i, asksLength)) {
                ccxt.AppendToArray(&payloadArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 0)))
                ccxt.AppendToArray(&payloadArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 1)))
            }
        }
        var payload interface{} = ccxt.Join(payloadArray, ":")
        var responseChecksum interface{} = this.SafeInteger(message, "checksum")
        var localChecksum interface{} = this.Crc32(payload, true)
        var error interface{} = nil
        if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(prevSeqId, ccxt.OpNeg(1))) && ccxt.IsTrue(!ccxt.IsEqual(nonce, prevSeqId))) {
            error = ccxt.InvalidNonce(ccxt.Add(this.Id, " watchOrderBook received invalid nonce"))
        }
        if ccxt.IsTrue(!ccxt.IsEqual(responseChecksum, localChecksum)) {
            error = ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
        }
        if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                ccxt.Remove(this.Orderbooks, symbol)
            }
            client.(ccxt.ClientInterface).Reject(error, messageHash)
        }
    }
    var timestamp interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(orderbook, "nonce", seqId)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    return orderbook
}
func  (this *OkxCore) HandleOrderBook(client interface{}, message interface{}) interface{}  {
    //
    // snapshot
    //
    //     {
    //         "arg": { channel: 'books-l2-tbt', instId: "BTC-USDT" },
    //         "action": "snapshot",
    //         "data": [
    //             {
    //                 "asks": [
    //                     [ '31685', '0.78069158', "0", "17" ],
    //                     [ '31685.1', '0.0001', "0", "1" ],
    //                     [ '31685.6', '0.04543165', "0", "1" ],
    //                 ],
    //                 "bids": [
    //                     [ '31684.9', '0.01', "0", "1" ],
    //                     [ '31682.9', '0.0001', "0", "1" ],
    //                     [ '31680.7', '0.01', "0", "1" ],
    //                 ],
    //                 "ts": "1626532416403",
    //                 "checksum": -1023440116
    //             }
    //         ]
    //     }
    //
    // update
    //
    //     {
    //         "arg": { channel: 'books-l2-tbt', instId: "BTC-USDT" },
    //         "action": "update",
    //         "data": [
    //             {
    //                 "asks": [
    //                     [ '31657.7', '0', "0", "0" ],
    //                     [ '31659.7', '0.01', "0", "1" ],
    //                     [ '31987.3', '0.01', "0", "1" ]
    //                 ],
    //                 "bids": [
    //                     [ '31642.9', '0.50296385', "0", "4" ],
    //                     [ '31639.9', '0', "0", "0" ],
    //                     [ '31638.7', '0.01', "0", "1" ],
    //                 ],
    //                 "ts": "1626535709008",
    //                 "checksum": 830931827
    //             }
    //         ]
    //     }
    //
    // books5
    //
    //     {
    //         "arg": { channel: "books5", instId: "BTC-USDT" },
    //         "data": [
    //             {
    //                 "asks": [
    //                     [ '31738.3', '0.05973179', "0", "3" ],
    //                     [ '31738.5', '0.11035404', "0", "2" ],
    //                     [ '31739.6', '0.01', "0", "1" ],
    //                 ],
    //                 "bids": [
    //                     [ '31738.2', '0.67557666', "0", "9" ],
    //                     [ '31738', '0.02466947', "0", "2" ],
    //                     [ '31736.3', '0.01705046', "0", "2" ],
    //                 ],
    //                 "instId": "BTC-USDT",
    //                 "ts": "1626537446491"
    //             }
    //         ]
    //     }
    //
    // bbo-tbt
    //
    //     {
    //         "arg":{
    //             "channel":"bbo-tbt",
    //             "instId":"BTC-USDT"
    //         },
    //         "data":[
    //             {
    //                 "asks":[["36232.2","1.8826134","0","17"]],
    //                 "bids":[["36232.1","0.00572212","0","2"]],
    //                 "ts":"1651826598363"
    //             }
    //         ]
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var action interface{} = this.SafeString(message, "action")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var depths interface{} = map[string]interface{} {
        "bbo-tbt": 1,
        "books": 400,
        "books5": 5,
        "books-l2-tbt": 400,
        "books50-l2-tbt": 50,
    }
    var limit interface{} = this.SafeInteger(depths, channel)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
    if ccxt.IsTrue(ccxt.IsEqual(action, "snapshot")) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var update interface{} = ccxt.GetValue(data, i)
            var orderbook interface{} = this.OrderBook(map[string]interface{} {}, limit)
            ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
            ccxt.AddElementToObject(orderbook, "symbol", symbol)
            this.HandleOrderBookMessage(client, update, orderbook, messageHash)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(action, "update")) {
        if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
                var update interface{} = ccxt.GetValue(data, i)
                this.HandleOrderBookMessage(client, update, orderbook, messageHash, market)
                client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            }
        }
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(channel, "books5"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "bbo-tbt")))) {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var update interface{} = ccxt.GetValue(data, i)
            var timestamp interface{} = this.SafeInteger(update, "ts")
            var snapshot interface{} = this.ParseOrderBook(update, symbol, timestamp, "bids", "asks", 0, 1)
            orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    }
    return message
}
func  (this *OkxCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var access interface{} = this.SafeString(params, "access", "private")
            params = this.Omit(params, []interface{}{"access"})
            var url interface{} = this.GetUrl("users", access)
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var timestamp interface{} = ccxt.ToString(this.Seconds())
                var method interface{} = "GET"
                var path interface{} = "/users/self/verify"
                var auth interface{} = ccxt.Add(ccxt.Add(timestamp, method), path)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var operation interface{} = "login"
                var request interface{} = map[string]interface{} {
                    "op": operation,
                    "args": []interface{}{map[string]interface{} {
            "apiKey": this.ApiKey,
            "passphrase": this.Password,
            "timestamp": timestamp,
            "sign": signature,
        }},
                }
                // Only add params['access'] to prevent sending custom parameters, such as extraParams.
                if ccxt.IsTrue(ccxt.InOp(params, "access")) {
                    ccxt.AddElementToObject(request, "access", ccxt.GetValue(params, "access"))
                }
                this.Watch(url, messageHash, request, messageHash)
            }
        
                retRes156215 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes156215)
                ch <- retRes156215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *OkxCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15738)
        
            retRes15748 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes15748)
        
                retRes157515 :=  (<-this.Subscribe("private", "account", "account", nil, params))
                ccxt.PanicOnError(retRes157515)
                ch <- retRes157515
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleBalanceAndPosition(client interface{}, message interface{})  {
    this.HandleMyLiquidation(client, message)
}
func  (this *OkxCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "arg": { channel: "account" },
    //         "data": [
    //             {
    //                 "adjEq": '',
    //                 "details": [
    //                     {
    //                         "availBal": '',
    //                         "availEq": "8.21009913",
    //                         "cashBal": "8.21009913",
    //                         "ccy": "USDT",
    //                         "coinUsdPrice": "0.99994",
    //                         "crossLiab": '',
    //                         "disEq": "8.2096065240522",
    //                         "eq": "8.21009913",
    //                         "eqUsd": "8.2096065240522",
    //                         "frozenBal": "0",
    //                         "interest": '',
    //                         "isoEq": "0",
    //                         "isoLiab": '',
    //                         "liab": '',
    //                         "maxLoan": '',
    //                         "mgnRatio": '',
    //                         "notionalLever": "0",
    //                         "ordFrozen": "0",
    //                         "twap": "0",
    //                         "uTime": "1621927314996",
    //                         "upl": "0"
    //                     },
    //                 ],
    //                 "imr": '',
    //                 "isoEq": "0",
    //                 "mgnRatio": '',
    //                 "mmr": '',
    //                 "notionalUsd": '',
    //                 "ordFroz": '',
    //                 "totalEq": "22.1930992296832",
    //                 "uTime": "1626692120916"
    //             }
    //         ]
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var typeVar interface{} = "spot"
    var balance interface{} = this.ParseTradingBalance(message)
    var oldBalance interface{} = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
    var newBalance interface{} = this.DeepExtend(oldBalance, balance)
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(newBalance))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), channel)
}
func  (this *OkxCore) OrderToTrade(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var info interface{} = this.SafeValue(order, "info", map[string]interface{} {})
    var timestamp interface{} = this.SafeInteger(info, "fillTime")
    var feeMarketId interface{} = this.SafeString(info, "fillFeeCcy")
    var isTaker interface{} = ccxt.IsEqual(this.SafeString(info, "execType", ""), "T")
    return this.SafeTrade(map[string]interface{} {
        "info": info,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(order, "symbol"),
        "id": this.SafeString(info, "tradeId"),
        "order": this.SafeString(order, "id"),
        "type": this.SafeString(order, "type"),
        "takerOrMaker": ccxt.Ternary(ccxt.IsTrue((isTaker)), "taker", "maker"),
        "side": this.SafeString(order, "side"),
        "price": this.SafeNumber(info, "fillPx"),
        "amount": this.SafeNumber(info, "fillSz"),
        "cost": this.SafeNumber(order, "cost"),
        "fee": map[string]interface{} {
            "cost": this.SafeNumber(info, "fillFee"),
            "currency": this.SafeCurrencyCode(feeMarketId),
        },
    }, market)
}
/**
 * @method
 * @name okx#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-order-channel
 * @param {string} [symbol] unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if fetching trigger or conditional trades
 * @param {string} [params.type] 'spot', 'swap', 'future', 'option', 'ANY', 'SPOT', 'MARGIN', 'SWAP', 'FUTURES' or 'OPTION'
 * @param {string} [params.marginMode] 'cross' or 'isolated', for automatically setting the type to spot margin
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *OkxCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // By default, receive order updates from any instrument type
            symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleOptionAndParams(params, "watchMyTrades", "type", "ANY")
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
        
            retRes16818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16818)
        
            retRes16828 := (<-this.Authenticate(map[string]interface{} {
                "access": ccxt.Ternary(ccxt.IsTrue(isTrigger), "business", "private"),
            }))
            ccxt.PanicOnError(retRes16828)
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue(isTrigger), "orders-algo", "orders")
            var messageHash interface{} = ccxt.Add(channel, "::myTrades")
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                typeVar = ccxt.GetValue(market, "type")
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
            }
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                typeVar = "futures"
            }
            var uppercaseType interface{} = ccxt.ToUpper(typeVar)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchMyTrades", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(uppercaseType, "SPOT")) {
                if ccxt.IsTrue(!ccxt.IsEqual(marginMode, nil)) {
                    uppercaseType = "MARGIN"
                }
            }
            var request interface{} = map[string]interface{} {
                "instType": uppercaseType,
            }
        
            orders:= (<-this.Subscribe("private", messageHash, channel, nil, this.Extend(request, params)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#watchPositions
 * @see https://www.okx.com/docs-v5/en/#trading-account-websocket-positions-channel
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *OkxCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes17258)
        
            retRes17268 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes17268)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "instType": "ANY",
            }
            var channel interface{} = "positions"
            var newPositions interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                var arg interface{} = map[string]interface{} {
                    "channel": "positions",
                    "instType": "ANY",
                }
                var args interface{} = []interface{}{this.Extend(arg, params)}
                var nonSymbolRequest interface{} = map[string]interface{} {
                    "op": "subscribe",
                    "args": args,
                }
                var url interface{} = this.GetUrl(channel, "private")
                
            newPositions = (<-this.Watch(url, channel, nonSymbolRequest, channel))
                    ccxt.PanicOnError(newPositions)
            } else {
                
            newPositions = (<-this.SubscribeMultiple("private", channel, symbols, this.Extend(request, params)))
                    ccxt.PanicOnError(newPositions)
            }
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        arg: {
    //            channel: 'positions',
    //            instType: 'ANY',
    //            instId: 'XRP-USDT-SWAP',
    //            uid: '464737184507959869'
    //        },
    //        data: [{
    //            adl: '1',
    //            availPos: '',
    //            avgPx: '0.52668',
    //            baseBal: '',
    //            baseBorrowed: '',
    //            baseInterest: '',
    //            bizRefId: '',
    //            bizRefType: '',
    //            cTime: '1693151444408',
    //            ccy: 'USDT',
    //            closeOrderAlgo: [],
    //            deltaBS: '',
    //            deltaPA: '',
    //            gammaBS: '',
    //            gammaPA: '',
    //            idxPx: '0.52683',
    //            imr: '17.564000000000004',
    //            instId: 'XRP-USDT-SWAP',
    //            instType: 'SWAP',
    //            interest: '',
    //            last: '0.52691',
    //            lever: '3',
    //            liab: '',
    //            liabCcy: '',
    //            liqPx: '0.3287514731020614',
    //            margin: '',
    //            markPx: '0.52692',
    //            mgnMode: 'cross',
    //            mgnRatio: '69.00363001456147',
    //            mmr: '0.26346',
    //            notionalUsd: '52.68620388000001',
    //            optVal: '',
    //            pTime: '1693151906023',
    //            pendingCloseOrdLiabVal: '',
    //            pos: '1',
    //            posCcy: '',
    //            posId: '616057041198907393',
    //            posSide: 'net',
    //            quoteBal: '',
    //            quoteBorrowed: '',
    //            quoteInterest: '',
    //            spotInUseAmt: '',
    //            spotInUseCcy: '',
    //            thetaBS: '',
    //            thetaPA: '',
    //            tradeId: '138745402',
    //            uTime: '1693151444408',
    //            upl: '0.0240000000000018',
    //            uplLastPx: '0.0229999999999952',
    //            uplRatio: '0.0013670539986328',
    //            uplRatioLastPx: '0.001310093415356',
    //            usdPx: '',
    //            vegaBS: '',
    //            vegaPA: ''
    //        }]
    //    }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var channel interface{} = this.SafeString(arg, "channel", "")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawPosition interface{} = ccxt.GetValue(data, i)
        var position interface{} = this.ParsePosition(rawPosition)
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(position, "contracts"), 0)) {
            ccxt.AddElementToObject(position, "side", "long")
            var shortPosition interface{} = this.Clone(position)
            ccxt.AddElementToObject(shortPosition, "side", "short")
            cache.(ccxt.Appender).Append(shortPosition)
            ccxt.AppendToArray(&newPositions, shortPosition)
        }
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHash interface{} = channel
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        messageHash = ccxt.Add(ccxt.Add(channel, "::"), symbol)
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, messageHash)
}
/**
 * @method
 * @name okx#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-order-channel
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if fetching trigger or conditional orders
 * @param {string} [params.type] 'spot', 'swap', 'future', 'option', 'ANY', 'SPOT', 'MARGIN', 'SWAP', 'FUTURES' or 'OPTION'
 * @param {string} [params.marginMode] 'cross' or 'isolated', for automatically setting the type to spot margin
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            // By default, receive order updates from any instrument type
            typeVarparamsVariable := this.HandleOptionAndParams(params, "watchOrders", "type", "ANY")
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isTrigger interface{} = this.SafeValue2(params, "stop", "trigger", false)
            params = this.Omit(params, []interface{}{"stop", "trigger"})
        
            retRes18728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes18728)
        
            retRes18738 := (<-this.Authenticate(map[string]interface{} {
                "access": ccxt.Ternary(ccxt.IsTrue(isTrigger), "business", "private"),
            }))
            ccxt.PanicOnError(retRes18738)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                typeVar = ccxt.GetValue(market, "type")
            }
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                typeVar = "futures"
            }
            var uppercaseType interface{} = ccxt.ToUpper(typeVar)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchOrders", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(uppercaseType, "SPOT")) {
                if ccxt.IsTrue(!ccxt.IsEqual(marginMode, nil)) {
                    uppercaseType = "MARGIN"
                }
            }
            var request interface{} = map[string]interface{} {
                "instType": uppercaseType,
            }
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue(isTrigger), "orders-algo", "orders")
        
            orders:= (<-this.Subscribe("private", channel, channel, symbol, this.Extend(request, params)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "arg":{
    //             "channel":"orders",
    //             "instType":"SPOT"
    //         },
    //         "data":[
    //             {
    //                 "accFillSz":"0",
    //                 "amendResult":"",
    //                 "avgPx":"",
    //                 "cTime":"1634548275191",
    //                 "category":"normal",
    //                 "ccy":"",
    //                 "clOrdId":"e847386590ce4dBC330547db94a08ba0",
    //                 "code":"0",
    //                 "execType":"",
    //                 "fee":"0",
    //                 "feeCcy":"USDT",
    //                 "fillFee":"0",
    //                 "fillFeeCcy":"",
    //                 "fillNotionalUsd":"",
    //                 "fillPx":"",
    //                 "fillSz":"0",
    //                 "fillTime":"",
    //                 "instId":"ETH-USDT",
    //                 "instType":"SPOT",
    //                 "lever":"",
    //                 "msg":"",
    //                 "notionalUsd":"451.4516256",
    //                 "ordId":"370257534141235201",
    //                 "ordType":"limit",
    //                 "pnl":"0",
    //                 "posSide":"",
    //                 "px":"60000",
    //                 "rebate":"0",
    //                 "rebateCcy":"ETH",
    //                 "reqId":"",
    //                 "side":"sell",
    //                 "slOrdPx":"",
    //                 "slTriggerPx":"",
    //                 "state":"live",
    //                 "sz":"0.007526",
    //                 "tag":"",
    //                 "tdMode":"cash",
    //                 "tgtCcy":"",
    //                 "tpOrdPx":"",
    //                 "tpTriggerPx":"",
    //                 "tradeId":"",
    //                 "uTime":"1634548275191"
    //             }
    //         ]
    //     }
    //
    this.HandleMyTrades(client, message)
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var orders interface{} = this.SafeValue(message, "data", []interface{}{})
    var ordersLength interface{} =     ccxt.GetArrayLength(orders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(ordersLength, 0)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
            this.TriggerOrders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(channel, "orders-algo"))), this.TriggerOrders, this.Orders)
        var marketIds interface{} = []interface{}{}
        var parsed interface{} = this.ParseOrders(orders)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
            var order interface{} = ccxt.GetValue(parsed, i)
            stored.(ccxt.Appender).Append(order)
            var symbol interface{} = ccxt.GetValue(order, "symbol")
            var market interface{} = this.Market(symbol)
            ccxt.AppendToArray(&marketIds, ccxt.GetValue(market, "id"))
        }
        client.(ccxt.ClientInterface).Resolve(stored, channel)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(marketIds, i))
            client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        }
    }
}
func  (this *OkxCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "arg":{
    //             "channel":"orders",
    //             "instType":"SPOT"
    //         },
    //         "data":[
    //             {
    //                 "accFillSz":"0",
    //                 "amendResult":"",
    //                 "avgPx":"",
    //                 "cTime":"1634548275191",
    //                 "category":"normal",
    //                 "ccy":"",
    //                 "clOrdId":"e847386590ce4dBC330547db94a08ba0",
    //                 "code":"0",
    //                 "execType":"",
    //                 "fee":"0",
    //                 "feeCcy":"USDT",
    //                 "fillFee":"0",
    //                 "fillFeeCcy":"",
    //                 "fillNotionalUsd":"",
    //                 "fillPx":"",
    //                 "fillSz":"0",
    //                 "fillTime":"",
    //                 "instId":"ETH-USDT",
    //                 "instType":"SPOT",
    //                 "lever":"",
    //                 "msg":"",
    //                 "notionalUsd":"451.4516256",
    //                 "ordId":"370257534141235201",
    //                 "ordType":"limit",
    //                 "pnl":"0",
    //                 "posSide":"",
    //                 "px":"60000",
    //                 "rebate":"0",
    //                 "rebateCcy":"ETH",
    //                 "reqId":"",
    //                 "side":"sell",
    //                 "slOrdPx":"",
    //                 "slTriggerPx":"",
    //                 "state":"live",
    //                 "sz":"0.007526",
    //                 "tag":"",
    //                 "tdMode":"cash",
    //                 "tgtCcy":"",
    //                 "tpOrdPx":"",
    //                 "tpTriggerPx":"",
    //                 "tradeId":"",
    //                 "uTime":"1634548275191"
    //             }
    //         ]
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel")
    var rawOrders interface{} = this.SafeValue(message, "data", []interface{}{})
    var filteredOrders interface{} = []interface{}{}
    // filter orders with no last trade id
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var rawOrder interface{} = ccxt.GetValue(rawOrders, i)
        var tradeId interface{} = this.SafeString(rawOrder, "tradeId", "")
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetLength(tradeId), 0)) {
            var order interface{} = this.ParseOrder(rawOrder)
            ccxt.AppendToArray(&filteredOrders, order)
        }
    }
    var tradesLength interface{} =     ccxt.GetArrayLength(filteredOrders)
    if ccxt.IsTrue(ccxt.IsEqual(tradesLength, 0)) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var myTrades interface{} = this.MyTrades
    var symbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(filteredOrders)); i++ {
        var rawTrade interface{} = ccxt.GetValue(filteredOrders, i)
        var trade interface{} = this.OrderToTrade(rawTrade)
        myTrades.(ccxt.Appender).Append(trade)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
    }
    var messageHash interface{} = ccxt.Add(channel, "::myTrades")
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
    var tradeSymbols interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tradeSymbols)); i++ {
        var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), ccxt.GetValue(tradeSymbols, i))
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, symbolMessageHash)
    }
}
func  (this *OkxCore) RequestId() interface{}  {
    var ts interface{} = ccxt.ToString(this.Milliseconds())
    var randomNumber interface{} = this.RandNumber(4)
    var randomPart interface{} = ccxt.ToString(randomNumber)
    return ccxt.Add(ts, randomPart)
}
/**
 * @method
 * @name okx#createOrderWs
 * @see https://www.okx.com/docs-v5/en/#websocket-api-trade-place-order
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} params.test test order, default false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes21028)
        
            retRes21038 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes21038)
            var url interface{} = this.GetUrl("private", "private")
            var messageHash interface{} = this.RequestId()
            var op interface{} = nil
            opparamsVariable := this.HandleOptionAndParams(params, "createOrderWs", "op", "batch-orders")
            op = ccxt.GetValue(opparamsVariable,0)
            params = ccxt.GetValue(opparamsVariable,1)
            var args interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var market interface{} = this.Market(symbol)
            var instIdCode interface{} = this.SafeInteger(market, "instIdCode")
            if ccxt.IsTrue(!ccxt.IsEqual(instIdCode, nil)) {
                ccxt.Remove(args, "instId")
                ccxt.AddElementToObject(args, "instIdCode", instIdCode)
            }
            var ordType interface{} = this.SafeString(args, "ordType")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(ordType, "trigger"))) || ccxt.IsTrue((ccxt.IsEqual(ordType, "conditional")))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "oco")))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "move_order_stop")))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "iceberg")))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "twap")))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " createOrderWs() does not support algo trading. this.options[\"createOrderWs\"][\"op\"] must be either order or batch-order")))
            }
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(op, "order"))) && ccxt.IsTrue((!ccxt.IsEqual(op, "batch-orders")))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " createOrderWs() does not support algo trading. this.options[\"createOrderWs\"][\"op\"] must be either order or privatePostTradeOrder or privatePostTradeOrderAlgo")))
            }
            var request interface{} = map[string]interface{} {
                "id": messageHash,
                "op": op,
                "args": []interface{}{args},
            }
        
                retRes212715 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes212715)
                ch <- retRes212715
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandlePlaceOrders(client interface{}, message interface{})  {
    //
    //  batch-orders/order/cancel-order
    //    {
    //        "id": "1689281055",
    //        "op": "batch-orders",
    //        "code": "0",
    //        "msg": '',
    //        "data": [{
    //            "tag": "e847386590ce4dBC",
    //            "ordId": "599823446566084608",
    //            "clOrdId": "e847386590ce4dBCb939511604f394b0",
    //            "sCode": "0",
    //            "sMsg": "ccxt.Order successfully placed."
    //        },
    //        ...
    //        ]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var args interface{} = this.SafeValue(message, "data", []interface{}{})
    // filter out partial errors
    args = this.FilterBy(args, "sCode", "0")
    // if empty means request failed and handle error
    if ccxt.IsTrue(this.IsEmpty(args)) {
        var method interface{} = this.SafeString(message, "op")
        var stringMsg interface{} = this.Json(message)
        this.HandleErrors(1, "", client.(ccxt.ClientInterface).GetUrl(), method, map[string]interface{} {}, stringMsg, message, map[string]interface{} {}, map[string]interface{} {})
    }
    var orders interface{} = this.ParseOrders(args, nil, nil, nil)
    var first interface{} = this.SafeDict(orders, 0, map[string]interface{} {})
    client.(ccxt.ClientInterface).Resolve(first, messageHash)
}
/**
 * @method
 * @name okx#editOrderWs
 * @description edit a trade order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-amend-order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-amend-multiple-orders
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes21808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes21808)
        
            retRes21818 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes21818)
            var url interface{} = this.GetUrl("private", "private")
            var messageHash interface{} = this.RequestId()
            var op interface{} = nil
            opparamsVariable := this.HandleOptionAndParams(params, "editOrderWs", "op", "amend-order")
            op = ccxt.GetValue(opparamsVariable,0)
            params = ccxt.GetValue(opparamsVariable,1)
            var args interface{} = this.EditOrderRequest(id, symbol, typeVar, side, amount, price, params)
            var market interface{} = this.Market(symbol)
            var instIdCode interface{} = this.SafeInteger(market, "instIdCode")
            if ccxt.IsTrue(!ccxt.IsEqual(instIdCode, nil)) {
                ccxt.Remove(args, "instId")
                ccxt.AddElementToObject(args, "instIdCode", instIdCode)
            }
            var request interface{} = map[string]interface{} {
                "id": messageHash,
                "op": op,
                "args": []interface{}{args},
            }
        
                retRes219815 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes219815)
                ch <- retRes219815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#cancelOrderWs
 * @see https://okx-docs.github.io/apidocs/websocket_api/en/#cancel-order-trade
 * @description cancel multiple orders
 * @param {string} id order id
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clOrdId] client order id
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrderWs() requires a symbol argument")))
            }
        
            retRes22168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes22168)
        
            retRes22178 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes22178)
            var url interface{} = this.GetUrl("private", "private")
            var messageHash interface{} = this.RequestId()
            var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
            params = this.Omit(params, []interface{}{"clientOrderId", "clOrdId"})
            var market interface{} = this.Market(symbol)
            var instIdCode interface{} = this.SafeInteger(market, "instIdCode")
            var arg interface{} = map[string]interface{} {
                "instIdCode": instIdCode,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                ccxt.AddElementToObject(arg, "clOrdId", clientOrderId)
            } else {
                ccxt.AddElementToObject(arg, "ordId", id)
            }
            var request interface{} = map[string]interface{} {
                "id": messageHash,
                "op": "cancel-order",
                "args": []interface{}{this.Extend(arg, params)},
            }
        
                retRes223715 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes223715)
                ch <- retRes223715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#cancelOrdersWs
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-mass-cancel-order
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var idsLength interface{} =     ccxt.GetArrayLength(ids)
            if ccxt.IsTrue(ccxt.IsGreaterThan(idsLength, 20)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrdersWs() accepts up to 20 ids at a time")))
            }
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrdersWs() requires a symbol argument")))
            }
        
            retRes22588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes22588)
        
            retRes22598 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes22598)
            var url interface{} = this.GetUrl("private", "private")
            var messageHash interface{} = this.RequestId()
            var args interface{} = []interface{}{}
            var market interface{} = this.Market(symbol)
            var instIdCode interface{} = this.SafeInteger(market, "instIdCode")
            var instParams interface{} = map[string]interface{} {
                "instIdCode": instIdCode,
            }
            for i := 0; ccxt.IsLessThan(i, idsLength); i++ {
                var arg interface{} = this.Extend(instParams, map[string]interface{} {
                    "ordId": ccxt.GetValue(ids, i),
                })
                ccxt.AppendToArray(&args, arg)
            }
            var request interface{} = map[string]interface{} {
                "id": messageHash,
                "op": "batch-cancel-orders",
                "args": args,
            }
        
                retRes227915 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes227915)
                ch <- retRes227915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name okx#cancelAllOrdersWs
 * @see https://docs.okx.com/websockets/#message-cancelAll
 * @description cancel all open orders of a type. Only applicable to ccxt.Option in Portfolio Margin mode, and MMP privilege is required.
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *OkxCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelAllOrdersWs() requires a symbol argument")))
            }
        
            retRes22958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes22958)
        
            retRes22968 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes22968)
            var market interface{} = this.Market(symbol)
            if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(market, "type"), "option")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelAllOrdersWs is only applicable to ccxt.Option in Portfolio Margin mode, and MMP privilege is required.")))
            }
            var url interface{} = this.GetUrl("private", "private")
            var messageHash interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "id": messageHash,
                "op": "mass-cancel",
                "args": []interface{}{this.Extend(map[string]interface{} {
            "instType": "OPTION",
            "instFamily": ccxt.GetValue(market, "id"),
        }, params)},
            }
        
                retRes231115 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes231115)
                ch <- retRes231115
                return nil
        
            }()
            return ch
        }
func  (this *OkxCore) HandleCancelAllOrders(client interface{}, message interface{})  {
    //
    //    {
    //        "id": "1512",
    //        "op": "mass-cancel",
    //        "data": [
    //            {
    //                "result": true
    //            }
    //        ],
    //        "code": "0",
    //        "msg": ""
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    client.(ccxt.ClientInterface).Resolve(data, messageHash)
}
func  (this *OkxCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     { event: 'subscribe', arg: { channel: "tickers", instId: "BTC-USDT" } }
    //
    // const channel = this.safeString (message, "channel")
    // client.(*ccxt.WSClient).Subscriptions[channel] = message
    return message
}
func  (this *OkxCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //     { event: "login", success: true }
    //
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    future.(*ccxt.Future).Resolve(true)
}
func  (this *OkxCore) Ping(client interface{}) interface{}  {
    // OKX does not support the built-in WebSocket protocol-level ping-pong.
    // Instead, it requires a custom text-based ping-pong mechanism.
    return "ping"
}
func  (this *OkxCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *OkxCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     { event: 'error', msg: "Illegal request: {"op":"subscribe","args":["spot/ticker:BTC-USDT"]}", code: "60012" }
    //     { event: 'error", msg: "channel:ticker,instId:BTC-USDT doesn"t exist", code: "60018" }
    //     {"event":"error","msg":"Illegal request: {\\"id\\":\\"17321173472466905\\",\\"op\\":\\"amend-order\\",\\"args\\":[{\\"instId\\":\\"ETH-USDC\\",\\"ordId\\":\\"2000345622407479296\\",\\"newSz\\":\\"0.050857\\",\\"newPx\\":\\"2949.4\\",\\"postOnly\\":true}],\\"postOnly\\":true}","code":"60012","connId":"0808af6c"}
    //
    var errorCode interface{} = this.SafeString(message, "code")
    
        {
             func(this *OkxCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *OkxCore) interface{} {
                            // catch block:
                                    // if the message contains an id, it means it is a response to a request
            // so we only reject that promise, instead of deleting all futures, destroying the authentication future
            var id interface{} = this.SafeString(message, "id")
            if ccxt.IsTrue(ccxt.IsEqual(id, nil)) {
                // try to parse it from the stringified json inside msg
                var msg interface{} = this.SafeString(message, "msg")
                if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(msg, nil)) && ccxt.IsTrue(ccxt.StartsWith(msg, "Illegal request: {"))) {
                    var stringifiedJson interface{} = ccxt.Replace(msg, "Illegal request: ", "")
                    var parsedJson interface{} = this.ParseJson(stringifiedJson)
                    id = this.SafeString(parsedJson, "id")
                }
            }
            if ccxt.IsTrue(!ccxt.IsEqual(id, nil)) {
                client.(ccxt.ClientInterface).Reject(e, id)
                return false
            }
            client.(ccxt.ClientInterface).Reject(e)
            return false
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsTrue(errorCode) && ccxt.IsTrue(!ccxt.IsEqual(errorCode, "0"))) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                if ccxt.IsTrue(!ccxt.IsEqual(errorCode, "1")) {
                    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                }
                var messageString interface{} = this.SafeValue(message, "msg")
                if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                } else {
                    var data interface{} = this.SafeList(message, "data", []interface{}{})
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
                        var d interface{} = ccxt.GetValue(data, i)
                        errorCode = this.SafeString(d, "sCode")
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
                            this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                        }
                        messageString = this.SafeValue(message, "sMsg")
                        if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                            this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                        }
                    }
                }
                panic(ccxt.ExchangeError(feedback))
            }
    		    return nil
    	    }(this)
        
            }
    return true
}
func  (this *OkxCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     { event: 'subscribe', arg: { channel: "tickers", instId: "BTC-USDT" } }
    //     { event: 'login", msg: '", code: "0" }
    //
    //     {
    //         "arg": { channel: "tickers", instId: "BTC-USDT" },
    //         "data": [
    //             {
    //                 "instType": "SPOT",
    //                 "instId": "BTC-USDT",
    //                 "last": "31500.1",
    //                 "lastSz": "0.00001754",
    //                 "askPx": "31500.1",
    //                 "askSz": "0.00998144",
    //                 "bidPx": "31500",
    //                 "bidSz": "3.05652439",
    //                 "open24h": "31697",
    //                 "high24h": "32248",
    //                 "low24h": "31165.6",
    //                 "sodUtc0": "31385.5",
    //                 "sodUtc8": "32134.9",
    //                 "volCcy24h": "503403597.38138519",
    //                 "vol24h": "15937.10781721",
    //                 "ts": "1626526618762"
    //             }
    //         ]
    //     }
    //
    //     { event: 'error', msg: "Illegal request: {"op":"subscribe","args":["spot/ticker:BTC-USDT"]}", code: "60012" }
    //     { event: 'error", msg: "channel:ticker,instId:BTC-USDT doesn"t exist", code: "60018" }
    //     { event: 'error', msg: "Invalid OK_ACCESS_KEY", code: "60005" }
    //     {
    //         "event": "error",
    //         "msg": "Illegal request: {"op":"login","args":["de89b035-b233-44b2-9a13-0ccdd00bda0e","7KUcc8YzQhnxBE3K","1626691289","H57N99mBt5NvW8U19FITrPdOxycAERFMaapQWRqLaSE="]}",
    //         "code": "60012"
    //     }
    //
    //
    //
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
        return
    }
    // const table = this.safeString (message, 'table')
    // if (table === undefined) {
    var event interface{} = this.SafeString2(message, "event", "op")
    if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
        var methods interface{} = map[string]interface{} {
            "login": this.HandleAuthenticate,
            "subscribe": this.HandleSubscriptionStatus,
            "unsubscribe": this.HandleUnsubscription,
            "order": this.HandlePlaceOrders,
            "batch-orders": this.HandlePlaceOrders,
            "amend-order": this.HandlePlaceOrders,
            "batch-amend-orders": this.HandlePlaceOrders,
            "cancel-order": this.HandlePlaceOrders,
            "mass-cancel": this.HandleCancelAllOrders,
        }
        var method interface{} = this.SafeValue(methods, event)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    } else {
        var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
        var channel interface{} = this.SafeString(arg, "channel")
        var methods interface{} = map[string]interface{} {
            "bbo-tbt": this.HandleOrderBook,
            "books": this.HandleOrderBook,
            "books5": this.HandleOrderBook,
            "books50-l2-tbt": this.HandleOrderBook,
            "books-l2-tbt": this.HandleOrderBook,
            "tickers": this.HandleTicker,
            "mark-price": this.HandleTicker,
            "positions": this.HandlePositions,
            "index-tickers": this.HandleTicker,
            "sprd-tickers": this.HandleTicker,
            "block-tickers": this.HandleTicker,
            "trades": this.HandleTrades,
            "trades-all": this.HandleTrades,
            "account": this.HandleBalance,
            "funding-rate": this.HandleFundingRate,
            "orders": this.HandleOrders,
            "orders-algo": this.HandleOrders,
            "liquidation-orders": this.HandleLiquidation,
            "balance_and_position": this.HandleBalanceAndPosition,
        }
        var method interface{} = this.SafeValue(methods, channel)
        if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(channel, "candle"), 0)) {
                this.HandleOHLCV(client, message)
            }
        } else {
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *OkxCore) HandleUnSubscriptionTrades(client interface{}, symbol interface{}, channel interface{})  {
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
        ccxt.Remove(this.Trades, symbol)
    }
}
func  (this *OkxCore) HandleUnsubscriptionOrderBook(client interface{}, symbol interface{}, channel interface{})  {
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:orderbook:", symbol)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
}
func  (this *OkxCore) HandleUnsubscriptionOHLCV(client interface{}, symbol interface{}, channel interface{})  {
    var tf interface{} = ccxt.Replace(channel, "candle", "")
    var timeframe interface{} = this.FindTimeframe(tf)
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("multi:", channel), ":"), symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)) {
        ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    }
}
func  (this *OkxCore) HandleUnsubscriptionTicker(client interface{}, symbol interface{}, channel interface{})  {
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(channel, "::"), symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", symbol)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Tickers, symbol)) {
        ccxt.Remove(this.Tickers, symbol)
    }
}
func  (this *OkxCore) HandleUnsubscription(client interface{}, message interface{})  {
    //
    // {
    //     "event": "unsubscribe",
    //     "arg": {
    //       "channel": "tickers",
    //       "instId": "LTC-USD-200327"
    //     },
    //     "connId": "a4d3ae55"
    // }
    // arg might be an array or list
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString(arg, "channel", "")
    var marketId interface{} = this.SafeString(arg, "instId")
    var symbol interface{} = this.SafeSymbol(marketId)
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(channel, "trades")) || ccxt.IsTrue(ccxt.IsEqual(channel, "trades-all"))) {
        this.HandleUnSubscriptionTrades(client, symbol, channel)
    } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.StartsWith(channel, "bbo")) || ccxt.IsTrue(ccxt.StartsWith(channel, "book"))) {
        this.HandleUnsubscriptionOrderBook(client, symbol, channel)
    } else if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "tickers"), ccxt.OpNeg(1))) {
        this.HandleUnsubscriptionTicker(client, symbol, channel)
    } else if ccxt.IsTrue(ccxt.StartsWith(channel, "candle")) {
        this.HandleUnsubscriptionOHLCV(client, symbol, channel)
    }
}


func (this *OkxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
