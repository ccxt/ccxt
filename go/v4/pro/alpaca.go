package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type AlpacaCore struct {
	*ccxt.AlpacaCore
	base *ccxt.AlpacaCore
}

func NewAlpacaCore() *AlpacaCore {
    p := &AlpacaCore{}
	base := &ccxt.AlpacaCore{}
	p.base = base
	p.AlpacaCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *AlpacaCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWithTakeProfitAndStopLossWs": false,
            "createReduceOnlyOrderWs": false,
            "createStopLossOrderWs": false,
            "createTakeProfitOrderWs": false,
            "fetchPositionForSymbolWs": false,
            "fetchPositionsForSymbolWs": false,
            "fetchPositionsWs": false,
            "fetchPositionWs": false,
            "unWatchPositions": false,
            "watchBalance": false,
            "watchLiquidations": false,
            "watchLiquidationsForSymbols": false,
            "watchMarkPrice": false,
            "watchMarkPrices": false,
            "watchMyLiquidations": false,
            "watchMyLiquidationsForSymbols": false,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchPosition": false,
            "watchPositions": false,
            "watchTicker": true,
            "watchTickers": false,
            "watchTrades": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "crypto": "wss://stream.data.alpaca.markets/v1beta2/crypto",
                    "trading": "wss://api.alpaca.markets/stream",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "crypto": "wss://stream.data.alpaca.markets/v1beta2/crypto",
                    "trading": "wss://paper-api.alpaca.markets/stream",
                },
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {},
            },
        },
    })
}
/**
 * @method
 * @name alpaca#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.alpaca.markets/docs/real-time-crypto-pricing-data#quotes
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *AlpacaCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "crypto")
        
            retRes788 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes788)
        
            retRes798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes798)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "quotes": []interface{}{ccxt.GetValue(market, "id")},
            }
        
                retRes8615 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes8615)
                ch <- retRes8615
                return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //         "T": "q",
    //         "S": "BTC/USDT",
    //         "bp": 17394.44,
    //         "bs": 0.021981,
    //         "ap": 17397.99,
    //         "as": 0.02,
    //         "t": "2022-12-16T06:07:56.611063286Z"
    //    ]
    //
    var ticker interface{} = this.ParseTicker(message)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *AlpacaCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //         "T": "q",
    //         "S": "BTC/USDT",
    //         "bp": 17394.44,
    //         "bs": 0.021981,
    //         "ap": 17397.99,
    //         "as": 0.02,
    //         "t": "2022-12-16T06:07:56.611063286Z"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "S")
    var datetime interface{} = this.SafeString(ticker, "t")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "bp"),
        "bidVolume": this.SafeString(ticker, "bs"),
        "ask": this.SafeString(ticker, "ap"),
        "askVolume": this.SafeString(ticker, "as"),
        "vwap": nil,
        "open": nil,
        "close": nil,
        "last": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name alpaca#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.alpaca.markets/docs/real-time-crypto-pricing-data#bars
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AlpacaCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "crypto")
        
            retRes1608 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes1608)
        
            retRes1618 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1618)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "bars": []interface{}{ccxt.GetValue(market, "id")},
            }
            var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
        
            ohlcv:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        "T": "b",
    //        "S": "BTC/USDT",
    //        "o": 17416.39,
    //        "h": 17424.82,
    //        "l": 17416.39,
    //        "c": 17424.82,
    //        "v": 1.341054,
    //        "t": "2022-12-16T06:53:00Z",
    //        "n": 21,
    //        "vw": 17421.9529234915
    //    }
    //
    var marketId interface{} = this.SafeString(message, "S")
    var symbol interface{} = this.SafeSymbol(marketId)
    var stored interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, stored)
    }
    var parsed interface{} = this.ParseOHLCV(message)
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name alpaca#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.alpaca.markets/docs/real-time-crypto-pricing-data#orderbooks
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *AlpacaCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "crypto")
        
            retRes2178 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes2178)
        
            retRes2188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2188)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "orderbooks": []interface{}{ccxt.GetValue(market, "id")},
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // snapshot
    //    {
    //        "T": "o",
    //        "S": "BTC/USDT",
    //        "t": "2022-12-16T06:35:31.585113205Z",
    //        "b": [{
    //                "p": 17394.37,
    //                "s": 0.015499,
    //            },
    //            ...
    //        ],
    //        "a": [{
    //                "p": 17398.8,
    //                "s": 0.042919,
    //            },
    //            ...
    //        ],
    //        "r": true,
    //    }
    //
    var marketId interface{} = this.SafeString(message, "S")
    var symbol interface{} = this.SafeSymbol(marketId)
    var datetime interface{} = this.SafeString(message, "t")
    var timestamp interface{} = this.Parse8601(datetime)
    var isSnapshot interface{} = this.SafeBool(message, "r", false)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(isSnapshot) {
        var snapshot interface{} = this.ParseOrderBook(message, symbol, timestamp, "b", "a", "p", "s")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeList(message, "a", []interface{}{})
        var bids interface{} = this.SafeList(message, "b", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", datetime)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *AlpacaCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, "p", "s")
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *AlpacaCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name alpaca#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.alpaca.markets/docs/real-time-crypto-pricing-data#trades
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *AlpacaCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "crypto")
        
            retRes3018 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes3018)
        
            retRes3028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3028)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trade:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "trades": []interface{}{ccxt.GetValue(market, "id")},
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "T": "t",
    //         "S": "BTC/USDT",
    //         "p": 17408.8,
    //         "s": 0.042919,
    //         "t": "2022-12-16T06:43:18.327Z",
    //         "i": 16585162,
    //         "tks": "B"
    //     ]
    //
    var marketId interface{} = this.SafeString(message, "S")
    var symbol interface{} = this.SafeSymbol(marketId)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var parsed interface{} = this.ParseTrade(message)
    stored.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name alpaca#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://docs.alpaca.markets/docs/websocket-streaming#trade-updates
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *AlpacaCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "trading")
        
            retRes3578 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes3578)
            var messageHash interface{} = "myTrades"
        
            retRes3598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3598)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "action": "listen",
                "data": map[string]interface{} {
                    "streams": []interface{}{"trade_updates"},
                },
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *AlpacaCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "trading")
        
            retRes3898 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes3898)
        
            retRes3908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3908)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add("orders:", symbol)
            }
            var request interface{} = map[string]interface{} {
                "action": "listen",
                "data": map[string]interface{} {
                    "streams": []interface{}{"trade_updates"},
                },
            }
        
            orders:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleTradeUpdate(client interface{}, message interface{})  {
    this.HandleOrder(client, message)
    this.HandleMyTrade(client, message)
}
func  (this *AlpacaCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "trade_updates",
    //        "data": {
    //          "event": "new",
    //          "timestamp": "2022-12-16T07:28:51.67621869Z",
    //          "order": {
    //            "id": "c2470331-8993-4051-bf5d-428d5bdc9a48",
    //            "client_order_id": "0f1f3764-107a-4d09-8b9a-d75a11738f5c",
    //            "created_at": "2022-12-16T02:28:51.673531798-05:00",
    //            "updated_at": "2022-12-16T02:28:51.678736847-05:00",
    //            "submitted_at": "2022-12-16T02:28:51.673015558-05:00",
    //            "filled_at": null,
    //            "expired_at": null,
    //            "cancel_requested_at": null,
    //            "canceled_at": null,
    //            "failed_at": null,
    //            "replaced_at": null,
    //            "replaced_by": null,
    //            "replaces": null,
    //            "asset_id": "276e2673-764b-4ab6-a611-caf665ca6340",
    //            "symbol": "BTC/USD",
    //            "asset_class": "crypto",
    //            "notional": null,
    //            "qty": "0.01",
    //            "filled_qty": "0",
    //            "filled_avg_price": null,
    //            "order_class": '',
    //            "order_type": "market",
    //            "type": "market",
    //            "side": "buy",
    //            "time_in_force": "gtc",
    //            "limit_price": null,
    //            "stop_price": null,
    //            "status": "new",
    //            "extended_hours": false,
    //            "legs": null,
    //            "trail_percent": null,
    //            "trail_price": null,
    //            "hwm": null
    //          },
    //          "execution_id": "5f781a30-b9a3-4c86-b466-2175850cf340"
    //        }
    //      }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var rawOrder interface{} = this.SafeValue(data, "order", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var order interface{} = this.ParseOrder(rawOrder)
    orders.(ccxt.Appender).Append(order)
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    messageHash = ccxt.Add("orders:", ccxt.GetValue(order, "symbol"))
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
func  (this *AlpacaCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "trade_updates",
    //        "data": {
    //          "event": "new",
    //          "timestamp": "2022-12-16T07:28:51.67621869Z",
    //          "order": {
    //            "id": "c2470331-8993-4051-bf5d-428d5bdc9a48",
    //            "client_order_id": "0f1f3764-107a-4d09-8b9a-d75a11738f5c",
    //            "created_at": "2022-12-16T02:28:51.673531798-05:00",
    //            "updated_at": "2022-12-16T02:28:51.678736847-05:00",
    //            "submitted_at": "2022-12-16T02:28:51.673015558-05:00",
    //            "filled_at": null,
    //            "expired_at": null,
    //            "cancel_requested_at": null,
    //            "canceled_at": null,
    //            "failed_at": null,
    //            "replaced_at": null,
    //            "replaced_by": null,
    //            "replaces": null,
    //            "asset_id": "276e2673-764b-4ab6-a611-caf665ca6340",
    //            "symbol": "BTC/USD",
    //            "asset_class": "crypto",
    //            "notional": null,
    //            "qty": "0.01",
    //            "filled_qty": "0",
    //            "filled_avg_price": null,
    //            "order_class": '',
    //            "order_type": "market",
    //            "type": "market",
    //            "side": "buy",
    //            "time_in_force": "gtc",
    //            "limit_price": null,
    //            "stop_price": null,
    //            "status": "new",
    //            "extended_hours": false,
    //            "legs": null,
    //            "trail_percent": null,
    //            "trail_price": null,
    //            "hwm": null
    //          },
    //          "execution_id": "5f781a30-b9a3-4c86-b466-2175850cf340"
    //        }
    //      }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var event interface{} = this.SafeString(data, "event")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(event, "fill")) && ccxt.IsTrue(!ccxt.IsEqual(event, "partial_fill"))) {
        return
    }
    var rawOrder interface{} = this.SafeValue(data, "order", map[string]interface{} {})
    var myTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(myTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trade interface{} = this.ParseMyTrade(rawOrder)
    myTrades.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(trade, "symbol"))
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
    messageHash = "myTrades"
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
}
func  (this *AlpacaCore) ParseMyTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": "c2470331-8993-4051-bf5d-428d5bdc9a48",
    //        "client_order_id": "0f1f3764-107a-4d09-8b9a-d75a11738f5c",
    //        "created_at": "2022-12-16T02:28:51.673531798-05:00",
    //        "updated_at": "2022-12-16T02:28:51.678736847-05:00",
    //        "submitted_at": "2022-12-16T02:28:51.673015558-05:00",
    //        "filled_at": null,
    //        "expired_at": null,
    //        "cancel_requested_at": null,
    //        "canceled_at": null,
    //        "failed_at": null,
    //        "replaced_at": null,
    //        "replaced_by": null,
    //        "replaces": null,
    //        "asset_id": "276e2673-764b-4ab6-a611-caf665ca6340",
    //        "symbol": "BTC/USD",
    //        "asset_class": "crypto",
    //        "notional": null,
    //        "qty": "0.01",
    //        "filled_qty": "0",
    //        "filled_avg_price": null,
    //        "order_class": '',
    //        "order_type": "market",
    //        "type": "market",
    //        "side": "buy",
    //        "time_in_force": "gtc",
    //        "limit_price": null,
    //        "stop_price": null,
    //        "status": "new",
    //        "extended_hours": false,
    //        "legs": null,
    //        "trail_percent": null,
    //        "trail_price": null,
    //        "hwm": null
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var datetime interface{} = this.SafeString(trade, "filled_at")
    var typeVar interface{} = this.SafeString(trade, "type")
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(typeVar, "limit"), 0)) {
        // might be limit or stop-limit
        typeVar = "limit"
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "i"),
        "info": trade,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": this.SafeSymbol(marketId, nil, "/"),
        "order": this.SafeString(trade, "id"),
        "type": typeVar,
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "market"))), "taker", "maker"),
        "price": this.SafeString(trade, "filled_avg_price"),
        "amount": this.SafeString(trade, "filled_qty"),
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *AlpacaCore) Authenticate(url interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var request interface{} = map[string]interface{} {
                    "action": "auth",
                    "key": this.ApiKey,
                    "secret": this.Secret,
                }
                if ccxt.IsTrue(ccxt.IsEqual(url, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "trading"))) {
                    // this auth request is being deprecated in test environment
                    request = map[string]interface{} {
                        "action": "authenticate",
                        "data": map[string]interface{} {
                            "key_id": this.ApiKey,
                            "secret_key": this.Secret,
                        },
                    }
                }
                this.Watch(url, messageHash, request, messageHash, future)
            }
        
                retRes62715 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes62715)
                ch <- retRes62715
                return nil
        
            }()
            return ch
        }
func  (this *AlpacaCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "T": "error",
    //        "code": 400,
    //        "msg": "invalid syntax"
    //    }
    //
    var code interface{} = this.SafeString(message, "code")
    var msg interface{} = this.SafeValue(message, "msg", map[string]interface{} {})
    panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " code: "), code), " message: "), msg)))
}
func  (this *AlpacaCore) HandleConnected(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "T": "success",
    //        "msg": "connected"
    //    }
    //
    return message
}
func  (this *AlpacaCore) HandleCryptoMessage(client interface{}, message interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var data interface{} = ccxt.GetValue(message, i)
        var T interface{} = this.SafeString(data, "T")
        var msg interface{} = this.SafeString(data, "msg")
        if ccxt.IsTrue(ccxt.IsEqual(T, "subscription")) {
            this.HandleSubscription(client, data)
            return
        }
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(T, "success")) && ccxt.IsTrue(ccxt.IsEqual(msg, "connected"))) {
            this.HandleConnected(client, data)
            return
        }
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(T, "success")) && ccxt.IsTrue(ccxt.IsEqual(msg, "authenticated"))) {
            this.HandleAuthenticate(client, data)
            return
        }
        var methods interface{} = map[string]interface{} {
            "error": this.HandleErrorMessage,
            "b": this.HandleOHLCV,
            "q": this.HandleTicker,
            "t": this.HandleTrades,
            "o": this.HandleOrderBook,
        }
        var method interface{} = this.SafeValue(methods, T)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, data)
        }
    }
}
func  (this *AlpacaCore) HandleTradingMessage(client interface{}, message interface{})  {
    var stream interface{} = this.SafeString(message, "stream")
    var methods interface{} = map[string]interface{} {
        "authorization": this.HandleAuthenticate,
        "listening": this.HandleSubscription,
        "trade_updates": this.HandleTradeUpdate,
    }
    var method interface{} = this.SafeValue(methods, stream)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *AlpacaCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        this.HandleCryptoMessage(client, message)
        return
    }
    this.HandleTradingMessage(client, message)
}
func  (this *AlpacaCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    // crypto
    //    {
    //        "T": "success",
    //        "msg": "connected"
    //    ]
    //
    // trading
    //    {
    //        "stream": "authorization",
    //        "data": {
    //            "status": "authorized",
    //            "action": "authenticate"
    //        }
    //    }
    // error
    //    {
    //        "stream": "authorization",
    //        "data": {
    //            "action": "authenticate",
    //            "message": "access key verification failed",
    //            "status": "unauthorized"
    //        }
    //    }
    //
    var T interface{} = this.SafeString(message, "T")
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var status interface{} = this.SafeString(data, "status")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(T, "success")) || ccxt.IsTrue(ccxt.IsEqual(status, "authorized"))) {
        var promise interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
        promise.(*ccxt.Future).Resolve(ccxt.ToGetsLimit(message))
        return
    }
    panic(ccxt.AuthenticationError(ccxt.Add(this.Id, " failed to authenticate.")))
}
func  (this *AlpacaCore) HandleSubscription(client interface{}, message interface{}) interface{}  {
    //
    // crypto
    //    {
    //          "T": "subscription",
    //          "trades": [],
    //          "quotes": [ "BTC/USDT" ],
    //          "orderbooks": [],
    //          "bars": [],
    //          "updatedBars": [],
    //          "dailyBars": []
    //    }
    // trading
    //    {
    //        "stream": "listening",
    //        "data": {
    //            "streams": ["trade_updates"]
    //        }
    //    }
    //
    return message
}


func (this *AlpacaCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
