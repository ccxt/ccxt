package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type KrakenfuturesCore struct {
	*ccxt.KrakenfuturesCore
	base *ccxt.KrakenfuturesCore
}

func NewKrakenfuturesCore() *KrakenfuturesCore {
    p := &KrakenfuturesCore{}
	base := &ccxt.KrakenfuturesCore{}
	p.base = base
	p.KrakenfuturesCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *KrakenfuturesCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelAllOrdersWs": false,
            "cancelOrdersWs": false,
            "cancelOrderWs": false,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchBalanceWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "fetchTradesWs": false,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchBalance": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://futures.kraken.com/ws/v1",
            },
            "test": map[string]interface{} {
                "ws": "wss://demo-futures.kraken.com/ws/v1",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "connectionLimit": 100,
            "requestLimit": 100,
            "fetchBalance": map[string]interface{} {
                "type": nil,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 30000,
        },
    })
}
/**
 * @ignore
 * @method
 * @description authenticates the user to access private web socket channels
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-challenge
 * @returns {object} response from exchange
 */
func  (this *KrakenfuturesCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            // ccxt.Hash the challenge with the SHA-256 algorithm
            // Base64-decode your api_secret
            // Use the result of step 2 to hash the result of step 1 with the HMAC-SHA-512 algorithm
            // Base64-encode the result of step 3
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "challenge"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var request interface{} = map[string]interface{} {
                    "event": "challenge",
                    "api_key": this.ApiKey,
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes9115 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes9115)
                ch <- retRes9115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-challenge
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenfuturesCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            orderbook:= (<-this.WatchMultiHelper("orderbook", "book", symbols, map[string]interface{} {
            "limit": limit,
        }, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @param {string} name name of the channel
 * @param {string[]} symbols CCXT market symbols
 * @param {object} [params] extra parameters specific to the krakenfutures api
 * @returns {object} data from the websocket stream
 */
func  (this *KrakenfuturesCore) SubscribePublic(name interface{}, symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1198)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "feed": name,
            }
            var marketIds interface{} = []interface{}{}
            var messageHash interface{} = name
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = []interface{}{}
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&marketIds, this.MarketId(symbol))
            }
            var length interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(length, 1)) {
                var market interface{} = this.Market(ccxt.GetValue(marketIds, 0))
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(market, "symbol"))
            }
            ccxt.AddElementToObject(subscribe, "product_ids", marketIds)
            var request interface{} = this.Extend(subscribe, params)
        
                retRes14115 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes14115)
                ch <- retRes14115
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @param {string} name name of the channel
 * @param {string} messageHash unique identifier for the message
 * @param {object} [params] extra parameters specific to the krakenfutures api
 * @returns {object} data from the websocket stream
 */
func  (this *KrakenfuturesCore) SubscribePrivate(name interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1548)
        
            retRes1558 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1558)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "feed": name,
                "api_key": this.ApiKey,
                "original_challenge": ccxt.GetValue(this.Options, "challenge"),
                "signed_challenge": ccxt.GetValue(this.Options, "signedChallenge"),
            }
            var request interface{} = this.Extend(subscribe, params)
        
                retRes16515 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes16515)
                ch <- retRes16515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenfuturesCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1788)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker
 * @param {string[]} symbols unified symbols of the markets to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenfuturesCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1948)
            symbols = this.MarketSymbols(symbols, nil, false)
        
            ticker:= (<-this.WatchMultiHelper("ticker", "ticker", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchBidsAsks
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-ticker-lite
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *KrakenfuturesCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            ticker:= (<-this.WatchMultiHelper("bidask", "ticker_lite", symbols, nil, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-trade
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KrakenfuturesCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes23615 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes23615)
                ch <- retRes23615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchTradesForSymbols
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-trade
 * @description get the list of most recent trades for a list of symbols
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *KrakenfuturesCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.WatchMultiHelper("trade", "trade", symbols, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeList(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.futures.kraken.com/#websocket-api-public-feeds-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] not used by krakenfutures watchOrderBook
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *KrakenfuturesCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes27115 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes27115)
                ch <- retRes27115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchPositions
 * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-positions
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *KrakenfuturesCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2868)
            var messageHash interface{} = ""
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            messageHash = ccxt.Add("positions", messageHash)
        
            newPositions:= (<-this.SubscribePrivate("open_positions", messageHash, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *KrakenfuturesCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        feed: 'open_positions',
    //        account: '3b111acc-4fcc-45be-a622-57e611fe9f7f',
    //        positions: [
    //            {
    //                instrument: 'PF_LTCUSD',
    //                balance: 0.5,
    //                pnl: -0.8628305877699987,
    //                entry_price: 70.53,
    //                mark_price: 68.80433882446,
    //                index_price: 68.8091,
    //                liquidation_threshold: 0,
    //                effective_leverage: 0.007028866753648637,
    //                return_on_equity: -1.2233525985679834,
    //                unrealized_funding: 0.0000690610530935388,
    //                initial_margin: 0.7053,
    //                initial_margin_with_orders: 0.7053,
    //                maintenance_margin: 0.35265,
    //                pnl_currency: 'USD'
    //            }
    //        ],
    //        seq: 0,
    //        timestamp: 1698608414910
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolById()
    }
    var cache interface{} = this.Positions
    var rawPositions interface{} = this.SafeValue(message, "positions", []interface{}{})
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        var timestamp interface{} = this.SafeInteger(message, "timestamp")
        ccxt.AddElementToObject(position, "timestamp", timestamp)
        ccxt.AddElementToObject(position, "datetime", this.Iso8601(timestamp))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
func  (this *KrakenfuturesCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //        {
    //            instrument: 'PF_LTCUSD',
    //            balance: 0.5,
    //            pnl: -0.8628305877699987,
    //            entry_price: 70.53,
    //            mark_price: 68.80433882446,
    //            index_price: 68.8091,
    //            liquidation_threshold: 0,
    //            effective_leverage: 0.007028866753648637,
    //            return_on_equity: -1.2233525985679834,
    //            unrealized_funding: 0.0000690610530935388,
    //            initial_margin: 0.7053,
    //            initial_margin_with_orders: 0.7053,
    //            maintenance_margin: 0.35265,
    //            pnl_currency: 'USD'
    //        }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "instrument")
    var hedged interface{} = "both"
    var balance interface{} = this.SafeNumber(position, "balance")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsGreaterThan(balance, 0))), "long", "short")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeSymbol(marketId),
        "notional": nil,
        "marginMode": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidation_threshold"),
        "entryPrice": this.SafeNumber(position, "entry_price"),
        "unrealizedPnl": this.SafeNumber(position, "pnl"),
        "percentage": this.SafeNumber(position, "return_on_equity"),
        "contracts": this.ParseNumber(ccxt.Precise.StringAbs(this.NumberToString(balance))),
        "contractSize": nil,
        "markPrice": this.SafeNumber(position, "mark_price"),
        "side": side,
        "hedged": hedged,
        "timestamp": nil,
        "datetime": nil,
        "maintenanceMargin": this.SafeNumber(position, "maintenance_margin"),
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": this.SafeNumber(position, "initial_margin"),
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
    })
}
/**
 * @method
 * @name krakenfutures#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-orders
 * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-open-orders-verbose
 * @param {string} symbol not used by krakenfutures watchOrders
 * @param {int} [since] not used by krakenfutures watchOrders
 * @param {int} [limit] not used by krakenfutures watchOrders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *KrakenfuturesCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4198)
            var name interface{} = "open_orders"
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "symbol")))
            }
        
            orders:= (<-this.SubscribePrivate(name, messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-fills
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *KrakenfuturesCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4458 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4458)
            var name interface{} = "fills"
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "symbol")))
            }
        
            trades:= (<-this.SubscribePrivate(name, messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name krakenfutures#watchBalance
 * @description watches information on the user's account balance
 * @see https://docs.futures.kraken.com/#websocket-api-private-feeds-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.account] can be either 'futures' or 'flex_futures'
 * @returns {object} a object of wallet types each with a balance structure {@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *KrakenfuturesCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4698)
            var name interface{} = "balances"
            var messageHash interface{} = name
            var account interface{} = nil
            accountparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "account")
            account = ccxt.GetValue(accountparamsVariable,0)
            params = ccxt.GetValue(accountparamsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(account, nil)) {
                if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(account, "futures")) && ccxt.IsTrue(!ccxt.IsEqual(account, "flex_futures"))) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchBalance account must be either \\'futures\\' or \\'flex_futures\\'")))
                }
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", account))
            }
        
                retRes48015 :=  (<-this.SubscribePrivate(name, messageHash, params))
                ccxt.PanicOnError(retRes48015)
                ch <- retRes48015
                return nil
        
            }()
            return ch
        }
func  (this *KrakenfuturesCore) HandleTrade(client interface{}, message interface{})  {
    //
    // snapshot
    //
    //    {
    //        "feed": "trade_snapshot",
    //        "product_id": "PI_XBTUSD",
    //        "trades": [
    //            {
    //                "feed": "trade",
    //                "product_id": "PI_XBTUSD",
    //                "uid": "caa9c653-420b-4c24-a9f2-462a054d86f1",
    //                "side": "sell",
    //                "type": "fill",
    //                "seq": 655508,
    //                "time": 1612269657781,
    //                "qty": 440,
    //                "price": 34893
    //            },
    //            ...
    //        ]
    //    }
    //
    // update
    //
    //    {
    //        "feed": "trade",
    //        "product_id": "PI_XBTUSD",
    //        "uid": "05af78ac-a774-478c-a50c-8b9c234e071e",
    //        "side": "sell",
    //        "type": "fill",
    //        "seq": 653355,
    //        "time": 1612266317519,
    //        "qty": 15000,
    //        "price": 34969.5
    //    }
    //
    var channel interface{} = this.SafeString(message, "feed")
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var market interface{} = this.Market(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = this.GetMessageHash("trade", nil, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeList(this.Trades, symbol), nil)) {
            var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(tradesLimit))
        }
        var tradesArray interface{} = ccxt.GetValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(channel, "trade_snapshot")) {
            var trades interface{} = this.SafeList(message, "trades", []interface{}{})
            var length interface{} =             ccxt.GetArrayLength(trades)
            for i := 0; ccxt.IsLessThan(i, length); i++ {
                var index interface{} = ccxt.Subtract(ccxt.Subtract(length, 1), i) // need reverse to correct chronology
                var item interface{} = ccxt.GetValue(trades, index)
                var trade interface{} = this.ParseWsTrade(item)
                tradesArray.(ccxt.Appender).Append(trade)
            }
        } else {
            var trade interface{} = this.ParseWsTrade(message)
            tradesArray.(ccxt.Appender).Append(trade)
        }
        client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    }
}
func  (this *KrakenfuturesCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "feed": "trade",
    //        "product_id": "PI_XBTUSD",
    //        "uid": "caa9c653-420b-4c24-a9f1-462a054d86f1",
    //        "side": "sell",
    //        "type": "fill",
    //        "seq": 655508,
    //        "time": 1612269657781,
    //        "qty": 440,
    //        "price": 34893
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "product_id")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "time")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "uid"),
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": nil,
        "type": this.SafeString(trade, "type"),
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": "taker",
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "qty"),
        "cost": nil,
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": nil,
            "currency": nil,
        },
    }, market)
}
func  (this *KrakenfuturesCore) ParseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "type": "LIMIT",
    //        "quantity": "1",
    //        "orderId": "32471407854219264",
    //        "tradeFee": "0",
    //        "clientOrderId": "",
    //        "accountType": "SPOT",
    //        "feeCurrency": "",
    //        "eventType": "place",
    //        "source": "API",
    //        "side": "BUY",
    //        "filledQuantity": "0",
    //        "filledAmount": "0",
    //        "matchRole": "MAKER",
    //        "state": "NEW",
    //        "tradeTime": 0,
    //        "tradeAmount": "0",
    //        "orderAmount": "0",
    //        "createTime": 1648708186922,
    //        "price": "47112.1",
    //        "tradeQty": "0",
    //        "tradePrice": "0",
    //        "tradeId": "0",
    //        "ts": 1648708187469
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "tradeTime")
    var marketId interface{} = this.SafeString(trade, "symbol")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "tradeId"),
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": this.SafeString(trade, "orderId"),
        "type": this.SafeStringLower(trade, "type"),
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": this.SafeString(trade, "matchRole"),
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "tradeAmount"),
        "cost": nil,
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": this.SafeString(trade, "tradeFee"),
            "currency": this.SafeString(trade, "feeCurrency"),
        },
    }, market)
}
func  (this *KrakenfuturesCore) HandleOrder(client interface{}, message interface{}) interface{}  {
    //
    //  update (verbose)
    //
    //    {
    //        "feed": "open_orders_verbose",
    //        "order": {
    //            "instrument": "PI_XBTUSD",
    //            "time": 1567597581495,
    //            "last_update_time": 1567597581495,
    //            "qty": 102.0,
    //            "filled": 0.0,
    //            "limit_price": 10601.0,
    //            "stop_price": 0.0,
    //            "type": "limit",
    //            "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
    //            "direction": 0,
    //            "reduce_only": false
    //        },
    //        "is_cancel": true,
    //        "reason": "post_order_failed_because_it_would_be_filled"
    //    }
    //
    // update
    //
    //    {
    //        "feed": "open_orders",
    //        "order": {
    //          "instrument": "PI_XBTUSD",
    //          "time": 1567702877410,
    //          "last_update_time": 1567702877410,
    //          "qty": 304.0,
    //          "filled": 0.0,
    //          "limit_price": 10640.0,
    //          "stop_price": 0.0,
    //          "type": "limit",
    //          "order_id": "59302619-41d2-4f0b-941f-7e7914760ad3",
    //          "direction": 1,
    //          "reduce_only": true
    //        },
    //        "is_cancel": false,
    //        "reason": "new_placed_order_by_user"
    //    }
    //    {
    //        "feed": "open_orders",
    //        "order_id": "ea8a7144-37db-449b-bb4a-b53c814a0f43",
    //        "is_cancel": true,
    //        "reason": "cancelled_by_user"
    //    }
    //
    //     {
    //         "feed": 'open_orders',
    //         "order": {
    //         "instrument": 'PF_XBTUSD',
    //         "time": 1698159920097,
    //         "last_update_time": 1699835622988,
    //         "qty": 1.1,
    //         "filled": 0,
    //         "limit_price": 20000,
    //         "stop_price": 0,
    //         "type": 'limit',
    //         "order_id": '0eaf02b0-855d-4451-a3b7-e2b3070c1fa4',
    //         "direction": 0,
    //         "reduce_only": false
    //         },
    //         "is_cancel": false,
    //         "reason": 'edited_by_user'
    //     }
    //
    var orders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit")
        orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = orders
    }
    var order interface{} = this.SafeValue(message, "order")
    if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
        var marketId interface{} = this.SafeString(order, "instrument")
        var messageHash interface{} = "orders"
        var symbol interface{} = this.SafeSymbol(marketId)
        var orderId interface{} = this.SafeString(order, "order_id")
        var previousOrders interface{} = this.SafeValue(orders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var previousOrder interface{} = this.SafeValue(previousOrders, orderId)
        var reason interface{} = this.SafeString(message, "reason")
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(previousOrder, nil))) || ccxt.IsTrue((ccxt.IsEqual(reason, "edited_by_user")))) {
            var parsed interface{} = this.ParseWsOrder(order)
            orders.(ccxt.Appender).Append(parsed)
            client.(ccxt.ClientInterface).Resolve(orders, messageHash)
            client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
        } else {
            var trade interface{} = this.ParseWsTrade(order)
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "trades"), nil)) {
                ccxt.AddElementToObject(previousOrder, "trades", []interface{}{})
            }
            retRes73216 := ccxt.GetValue(previousOrder, "trades")
            ccxt.AppendToArray(&retRes73216, trade)
            ccxt.AddElementToObject(previousOrder, "lastTradeTimestamp", ccxt.GetValue(trade, "timestamp"))
            var totalCost interface{} = "0"
            var totalAmount interface{} = "0"
            var trades interface{} = ccxt.GetValue(previousOrder, "trades")
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
                var currentTrade interface{} = ccxt.GetValue(trades, i)
                totalCost = ccxt.Precise.StringAdd(totalCost, this.NumberToString(ccxt.GetValue(currentTrade, "cost")))
                totalAmount = ccxt.Precise.StringAdd(totalAmount, this.NumberToString(ccxt.GetValue(currentTrade, "amount")))
            }
            if ccxt.IsTrue(ccxt.Precise.StringGt(totalAmount, "0")) {
                ccxt.AddElementToObject(previousOrder, "average", ccxt.Precise.StringDiv(totalCost, totalAmount))
            }
            ccxt.AddElementToObject(previousOrder, "cost", totalCost)
            if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "filled"), nil)) {
                var stringOrderFilled interface{} = this.NumberToString(ccxt.GetValue(previousOrder, "filled"))
                ccxt.AddElementToObject(previousOrder, "filled", ccxt.Precise.StringAdd(stringOrderFilled, this.NumberToString(ccxt.GetValue(trade, "amount"))))
                if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "amount"), nil)) {
                    ccxt.AddElementToObject(previousOrder, "remaining", ccxt.Precise.StringSub(this.NumberToString(ccxt.GetValue(previousOrder, "amount")), stringOrderFilled))
                }
            }
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "fee"), nil)) {
                ccxt.AddElementToObject(previousOrder, "fee", map[string]interface{} {
    "rate": nil,
    "cost": "0",
    "currency": this.NumberToString(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "currency")),
})
            }
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"), nil))) && ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost"), nil)))) {
                var stringOrderCost interface{} = this.NumberToString(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"))
                var stringTradeCost interface{} = this.NumberToString(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost"))
                ccxt.AddElementToObject(ccxt.GetValue(previousOrder, "fee"), "cost", ccxt.Precise.StringAdd(stringOrderCost, stringTradeCost))
            }
            // update the newUpdates count
            orders.(ccxt.Appender).Append(this.SafeOrder(previousOrder))
            client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
            client.(ccxt.ClientInterface).Resolve(orders, messageHash)
        }
    } else {
        var isCancel interface{} = this.SafeValue(message, "is_cancel")
        if ccxt.IsTrue(isCancel) {
            // get order without symbol
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
                var currentOrder interface{} = ccxt.GetValue(orders, i)
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(currentOrder, "id"), ccxt.GetValue(message, "order_id"))) {
                    ccxt.AddElementToObject(orders, i, this.Extend(currentOrder, map[string]interface{} {
    "status": "canceled",
}))
                    client.(ccxt.ClientInterface).Resolve(orders, "orders")
                    client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add("orders:", ccxt.GetValue(currentOrder, "symbol")))
                    break
                }
            }
        }
    }
    return message
}
func  (this *KrakenfuturesCore) HandleOrderSnapshot(client interface{}, message interface{})  {
    //
    // verbose
    //
    //    {
    //        "feed": "open_orders_verbose_snapshot",
    //        "account": "0f9c23b8-63e2-40e4-9592-6d5aa57c12ba",
    //        "orders": [
    //            {
    //                "instrument": "PI_XBTUSD",
    //                "time": 1567428848005,
    //                "last_update_time": 1567428848005,
    //                "qty": 100.0,
    //                "filled": 0.0,
    //                "limit_price": 8500.0,
    //                "stop_price": 0.0,
    //                "type": "limit",
    //                "order_id": "566942c8-a3b5-4184-a451-622b09493129",
    //                "direction": 0,
    //                "reduce_only": false
    //            },
    //            ...
    //        ]
    //    }
    //
    // regular
    //
    //    {
    //        "feed": "open_orders_snapshot",
    //        "account": "e258dba9-4dd4-4da5-bfef-75beb91c098e",
    //        "orders": [
    //            {
    //                "instrument": "PI_XBTUSD",
    //                "time": 1612275024153,
    //                "last_update_time": 1612275024153,
    //                "qty": 1000,
    //                "filled": 0,
    //                "limit_price": 34900,
    //                "stop_price": 13789,
    //                "type": "stop",
    //                "order_id": "723ba95f-13b7-418b-8fcf-ab7ba6620555",
    //                "direction": 1,
    //                "reduce_only": false,
    //                "triggerSignal": "last"
    //            },
    //            ...
    //        ]
    //    }
    var orders interface{} = this.SafeValue(message, "orders", []interface{}{})
    var limit interface{} = this.SafeInteger(this.Options, "ordersLimit")
    this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    var symbols interface{} = map[string]interface{} {}
    var cachedOrders interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
        var order interface{} = ccxt.GetValue(orders, i)
        var parsed interface{} = this.ParseWsOrder(order)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        cachedOrders.(ccxt.Appender).Append(parsed)
    }
    var length interface{} =     ccxt.GetArrayLength(this.Orders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(length, 0)) {
        client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var symbol interface{} = ccxt.GetValue(keys, i)
            var messageHash interface{} = ccxt.Add("orders:", symbol)
            client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        }
    }
}
func  (this *KrakenfuturesCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // update
    //
    //    {
    //        "feed": "open_orders_verbose",
    //        "order": {
    //            "instrument": "PI_XBTUSD",
    //            "time": 1567597581495,
    //            "last_update_time": 1567597581495,
    //            "qty": 102.0,
    //            "filled": 0.0,
    //            "limit_price": 10601.0,
    //            "stop_price": 0.0,
    //            "type": "limit",
    //            "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
    //            "direction": 0,
    //            "reduce_only": false
    //        },
    //        "is_cancel": true,
    //        "reason": "post_order_failed_because_it_would_be_filled"
    //    }
    //
    // snapshot
    //
    //    {
    //        "instrument": "PI_XBTUSD",
    //        "time": 1567597581495,
    //        "last_update_time": 1567597581495,
    //        "qty": 102.0,
    //        "filled": 0.0,
    //        "limit_price": 10601.0,
    //        "stop_price": 0.0,
    //        "type": "limit",
    //        "order_id": "fa9806c9-cba9-4661-9f31-8c5fd045a95d",
    //        "direction": 0,
    //        "reduce_only": false
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var isCancelled interface{} = this.SafeValue(order, "is_cancel")
    var unparsedOrder interface{} = order
    var status interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(isCancelled, nil)) {
        unparsedOrder = this.SafeValue(order, "order")
        if ccxt.IsTrue(ccxt.IsEqual(isCancelled, true)) {
            status = "cancelled"
        }
    }
    var marketId interface{} = this.SafeString(unparsedOrder, "instrument")
    var timestamp interface{} = this.SafeString(unparsedOrder, "time")
    var direction interface{} = this.SafeInteger(unparsedOrder, "direction")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": this.SafeSymbol(marketId, market),
        "id": this.SafeString(unparsedOrder, "order_id"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": this.SafeString(unparsedOrder, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(direction, 0))), "buy", "sell"),
        "price": this.SafeString(unparsedOrder, "limit_price"),
        "stopPrice": this.SafeString(unparsedOrder, "stop_price"),
        "triggerPrice": this.SafeString(unparsedOrder, "stop_price"),
        "amount": this.SafeString(unparsedOrder, "qty"),
        "cost": nil,
        "average": nil,
        "filled": this.SafeString(unparsedOrder, "filled"),
        "remaining": nil,
        "status": status,
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": nil,
            "currency": nil,
        },
        "trades": nil,
    })
}
func  (this *KrakenfuturesCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "time": 1680811086487,
    //        "product_id": "PI_XBTUSD",
    //        "funding_rate": 7.792297e-12,
    //        "funding_rate_prediction": -4.2671095e-11,
    //        "relative_funding_rate": 2.18013888889e-7,
    //        "relative_funding_rate_prediction": -0.0000011974,
    //        "next_funding_rate_time": 1680811200000,
    //        "feed": "ticker",
    //        "bid": 28060,
    //        "ask": 28070,
    //        "bid_size": 2844,
    //        "ask_size": 1902,
    //        "volume": 19628180,
    //        "dtm": 0,
    //        "leverage": "50x",
    //        "index": 28062.14,
    //        "premium": 0,
    //        "last": 28053.5,
    //        "change": -0.7710945651981715,
    //        "suspended": false,
    //        "tag": "perpetual",
    //        "pair": "XBT:USD",
    //        "openInterest": 28875946,
    //        "markPrice": 28064.92082724592,
    //        "maturityTime": 0,
    //        "post_only": false,
    //        "volumeQuote": 19628180
    //    }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var ticker interface{} = this.ParseWsTicker(message)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        var messageHash interface{} = this.GetMessageHash("ticker", nil, symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *KrakenfuturesCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //    {
    //        "feed": "ticker_lite",
    //        "product_id": "FI_ETHUSD_210625",
    //        "bid": 1753.45,
    //        "ask": 1760.35,
    //        "change": 13.448175559936647,
    //        "premium": 9.1,
    //        "volume": 6899673.0,
    //        "tag": "semiannual",
    //        "pair": "ETH:USD",
    //        "dtm": 141,
    //        "maturityTime": 1624633200000,
    //        "volumeQuote": 6899673.0
    //    }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var ticker interface{} = this.ParseWsTicker(message)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
        var messageHash interface{} = this.GetMessageHash("bidask", nil, symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *KrakenfuturesCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "time": 1680811086487,
    //        "product_id": "PI_XBTUSD",
    //        "funding_rate": 7.792297e-12,
    //        "funding_rate_prediction": -4.2671095e-11,
    //        "relative_funding_rate": 2.18013888889e-7,
    //        "relative_funding_rate_prediction": -0.0000011974,
    //        "next_funding_rate_time": 1680811200000,
    //        "feed": "ticker",
    //        "bid": 28060,
    //        "ask": 28070,
    //        "bid_size": 2844,
    //        "ask_size": 1902,
    //        "volume": 19628180,
    //        "dtm": 0,
    //        "leverage": "50x",
    //        "index": 28062.14,
    //        "premium": 0,
    //        "last": 28053.5,
    //        "change": -0.7710945651981715,
    //        "suspended": false,
    //        "tag": "perpetual",
    //        "pair": "XBT:USD",
    //        "openInterest": 28875946,
    //        "markPrice": 28064.92082724592,
    //        "maturityTime": 0,
    //        "post_only": false,
    //        "volumeQuote": 19628180
    //    }
    //
    // ticker_lite
    //
    //    {
    //        "feed": "ticker_lite",
    //        "product_id": "FI_ETHUSD_210625",
    //        "bid": 1753.45,
    //        "ask": 1760.35,
    //        "change": 13.448175559936647,
    //        "premium": 9.1,
    //        "volume": 6899673.0,
    //        "tag": "semiannual",
    //        "pair": "ETH:USD",
    //        "dtm": 141,
    //        "maturityTime": 1624633200000,
    //        "volumeQuote": 6899673.0
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "product_id")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "lastTime"))
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bid_size"),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "ask_size"),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "change"),
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "volumeQuote"),
        "markPrice": this.SafeString(ticker, "markPrice"),
        "indexPrice": this.SafeString(ticker, "index"),
    })
}
func  (this *KrakenfuturesCore) HandleOrderBookSnapshot(client interface{}, message interface{})  {
    //
    //    {
    //        "feed": "book_snapshot",
    //        "product_id": "PI_XBTUSD",
    //        "timestamp": 1612269825817,
    //        "seq": 326072249,
    //        "tickSize": null,
    //        "bids": [
    //            {
    //                "price": 34892.5,
    //                "qty": 6385
    //            },
    //            {
    //                "price": 34892,
    //                "qty": 10924
    //            },
    //        ],
    //        "asks": [
    //            {
    //                "price": 34911.5,
    //                "qty": 20598
    //            },
    //            {
    //                "price": 34912,
    //                "qty": 2300
    //            },
    //        ]
    //    }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = this.GetMessageHash("orderbook", nil, symbol)
    var subscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
    var limit interface{} = this.SafeInteger(subscription, "limit")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var bids interface{} = this.SafeList(message, "bids")
    var asks interface{} = this.SafeList(message, "asks")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bids)); i++ {
        var bid interface{} = ccxt.GetValue(bids, i)
        var price interface{} = this.SafeNumber(bid, "price")
        var qty interface{} = this.SafeNumber(bid, "qty")
        var bidsSide interface{} = ccxt.GetValue(orderbook, "bids")
        bidsSide.(ccxt.IOrderBookSide).Store(price, qty)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(asks)); i++ {
        var ask interface{} = ccxt.GetValue(asks, i)
        var price interface{} = this.SafeNumber(ask, "price")
        var qty interface{} = this.SafeNumber(ask, "qty")
        var asksSide interface{} = ccxt.GetValue(orderbook, "asks")
        asksSide.(ccxt.IOrderBookSide).Store(price, qty)
    }
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *KrakenfuturesCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "feed": "book",
    //        "product_id": "PI_XBTUSD",
    //        "side": "sell",
    //        "seq": 326094134,
    //        "price": 34981,
    //        "qty": 0,
    //        "timestamp": 1612269953629
    //    }
    //
    var marketId interface{} = this.SafeString(message, "product_id")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = this.GetMessageHash("orderbook", nil, symbol)
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var side interface{} = this.SafeString(message, "side")
    var price interface{} = this.SafeNumber(message, "price")
    var qty interface{} = this.SafeNumber(message, "qty")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    if ccxt.IsTrue(ccxt.IsEqual(side, "sell")) {
        var asks interface{} = ccxt.GetValue(orderbook, "asks")
        asks.(ccxt.IOrderBookSide).Store(price, qty)
    } else {
        var bids interface{} = ccxt.GetValue(orderbook, "bids")
        bids.(ccxt.IOrderBookSide).Store(price, qty)
    }
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *KrakenfuturesCore) HandleBalance(client interface{}, message interface{})  {
    //
    // snapshot
    //
    //    {
    //        "feed": "balances_snapshot",
    //        "account": "4a012c31-df95-484a-9473-d51e4a0c4ae7",
    //        "holding": {
    //            "USDT": 4997.5012493753,
    //            "XBT": 0.1285407184,
    //            ...
    //        },
    //        "futures": {
    //            "F-ETH:EUR": {
    //                "name": "F-ETH:EUR",
    //                "pair": "ETH/EUR",
    //                "unit": "EUR",
    //                "portfolio_value": 0.0,
    //                "balance": 0.0,
    //                "maintenance_margin": 0.0,
    //                "initial_margin": 0.0,
    //                "available": 0.0,
    //                "unrealized_funding": 0.0,
    //                "pnl": 0.0
    //            },
    //            ...
    //        },
    //        "flex_futures": {
    //            "currencies": {
    //                "USDT": {
    //                    "quantity": 0.0,
    //                    "value": 0.0,
    //                    "collateral_value": 0.0,
    //                    "available": 0.0,
    //                    "haircut": 0.0,
    //                    "conversion_spread": 0.0
    //                },
    //                ...
    //            },
    //            "balance_value":0.0,
    //            "portfolio_value":0.0,
    //            "collateral_value":0.0,
    //            "initial_margin":0.0,
    //            "initial_margin_without_orders":0.0,
    //            "maintenance_margin":0.0,
    //            "pnl":0.0,
    //            "unrealized_funding":0.0,
    //            "total_unrealized":0.0,
    //            "total_unrealized_as_margin":0.0,
    //            "margin_equity":0.0,
    //            "available_margin":0.0
    //            "isolated":{
    //            },
    //            "cross":{
    //                "balance_value":9963.66,
    //                "portfolio_value":9963.66,
    //                "collateral_value":9963.66,
    //                "initial_margin":0.0,
    //                "initial_margin_without_orders":0.0,
    //                "maintenance_margin":0.0,
    //                "pnl":0.0,
    //                "unrealized_funding":0.0,
    //                "total_unrealized":0.0,
    //                "total_unrealized_as_margin":0.0,
    //                "margin_equity":9963.66,
    //                "available_margin":9963.66,
    //                "effective_leverage":0.0
    //            },
    //        },
    //        "timestamp":1640995200000,
    //        "seq":0
    //    }
    //
    // update
    //
    //    Holding Wallet
    //
    //    {
    //        "feed": "balances",
    //        "account": "7a641082-55c7-4411-a85f-930ec2e09617",
    //        "holding": {
    //            "USD": 5000.0
    //        },
    //        "futures": {},
    //        "timestamp": 1640995200000,
    //        "seq": 83
    //    }
    //
    //    Multi-Collateral
    //
    //    {
    //        "feed": "balances"
    //        "account": "7a641082-55c7-4411-a85f-930ec2e09617"
    //        "flex_futures": {
    //            "currencies": {
    //                "USDT": {
    //                    "quantity": 0.0,
    //                    "value": 0.0,
    //                    "collateral_value": 0.0,
    //                    "available": 0.0,
    //                    "haircut": 0.0,
    //                    "conversion_spread": 0.0
    //                },
    //                ...
    //            },
    //            "balance_value": 5000.0,
    //            "portfolio_value": 5000.0,
    //            "collateral_value": 5000.0,
    //            "initial_margin": 0.0,
    //            "initial_margin_without_orders": 0.0,
    //            "maintenance_margin": 0.0,
    //            "pnl": 0.0,
    //            "unrealized_funding": 0.0,
    //            "total_unrealized": 0.0,
    //            "total_unrealized_as_margin": 0.0,
    //            "margin_equity": 5000.0,
    //            "available_margin": 5000.0
    //        },
    //        "timestamp": 1640995200000,
    //        "seq": 1
    //    }
    //
    //    Sample Single-Collateral ccxt.Balance Delta
    //
    //    {
    //        "feed": "balances",
    //        "account": "7a641082-55c7-4411-a85f-930ec2e09617",
    //        "holding": {},
    //        "futures": {
    //            "F-XBT:USD": {
    //                "name": "F-XBT:USD",
    //                "pair": "XBT/USD",
    //                "unit": "XBT",
    //                "portfolio_value": 0.1219368845,
    //                "balance": 0.1219368845,
    //                "maintenance_margin": 0.0,
    //                "initial_margin": 0.0,
    //                "available": 0.1219368845,
    //                "unrealized_funding": 0.0,
    //                "pnl": 0.0
    //            }
    //        },
    //        "timestamp": 1640995200000,
    //        "seq": 2
    //    }
    //
    var holding interface{} = this.SafeValue(message, "holding")
    var futures interface{} = this.SafeValue(message, "futures")
    var flexFutures interface{} = this.SafeValue(message, "flex_futures")
    var messageHash interface{} = "balances"
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    if ccxt.IsTrue(!ccxt.IsEqual(holding, nil)) {
        var holdingKeys interface{} = ccxt.ObjectKeys(holding) // cashAccount
        var holdingResult interface{} = map[string]interface{} {
            "info": message,
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(holdingKeys)); i++ {
            var key interface{} = ccxt.GetValue(holdingKeys, i)
            var code interface{} = this.SafeCurrencyCode(key)
            var newAccount interface{} = this.Account()
            ccxt.AddElementToObject(newAccount, "total", this.SafeString(holding, key))
            ccxt.AddElementToObject(holdingResult, code, newAccount)
        }
        ccxt.AddElementToObject(this.Balance, "cash", holdingResult)
        ccxt.AddElementToObject(this.Balance, "cash", this.SafeBalance(ccxt.GetValue(this.Balance, "cash")))
        client.(ccxt.ClientInterface).Resolve(holdingResult, messageHash)
    }
    if ccxt.IsTrue(!ccxt.IsEqual(futures, nil)) {
        var futuresKeys interface{} = ccxt.ObjectKeys(futures) // marginAccount
        var futuresResult interface{} = map[string]interface{} {
            "info": message,
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(futuresKeys)); i++ {
            var key interface{} = ccxt.GetValue(futuresKeys, i)
            var symbol interface{} = this.SafeSymbol(key)
            var newAccount interface{} = this.Account()
            var future interface{} = this.SafeValue(futures, key)
            var currencyId interface{} = this.SafeString(future, "unit")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            ccxt.AddElementToObject(newAccount, "free", this.SafeString(future, "available"))
            ccxt.AddElementToObject(newAccount, "used", this.SafeString(future, "initial_margin"))
            ccxt.AddElementToObject(newAccount, "total", this.SafeString(future, "balance"))
            ccxt.AddElementToObject(futuresResult, symbol, map[string]interface{} {})
            ccxt.AddElementToObject(ccxt.GetValue(futuresResult, symbol), code, newAccount)
        }
        ccxt.AddElementToObject(this.Balance, "margin", futuresResult)
        ccxt.AddElementToObject(this.Balance, "margin", this.SafeBalance(ccxt.GetValue(this.Balance, "margin")))
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, "margin"), ccxt.Add(messageHash, "futures"))
    }
    if ccxt.IsTrue(!ccxt.IsEqual(flexFutures, nil)) {
        var flexFutureCurrencies interface{} = this.SafeValue(flexFutures, "currencies", map[string]interface{} {})
        var flexFuturesKeys interface{} = ccxt.ObjectKeys(flexFutureCurrencies) // multi-collateral margin account
        var flexFuturesResult interface{} = map[string]interface{} {
            "info": message,
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(flexFuturesKeys)); i++ {
            var key interface{} = ccxt.GetValue(flexFuturesKeys, i)
            var flexFuture interface{} = this.SafeValue(flexFutureCurrencies, key)
            var code interface{} = this.SafeCurrencyCode(key)
            var newAccount interface{} = this.Account()
            ccxt.AddElementToObject(newAccount, "free", this.SafeString(flexFuture, "available"))
            ccxt.AddElementToObject(newAccount, "used", this.SafeString(flexFuture, "collateral_value"))
            ccxt.AddElementToObject(newAccount, "total", this.SafeString(flexFuture, "quantity"))
            ccxt.AddElementToObject(flexFuturesResult, code, newAccount)
        }
        ccxt.AddElementToObject(this.Balance, "flex", flexFuturesResult)
        ccxt.AddElementToObject(this.Balance, "flex", this.SafeBalance(ccxt.GetValue(this.Balance, "flex")))
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, "flex"), ccxt.Add(messageHash, "flex_futures"))
    }
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *KrakenfuturesCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "feed": "fills_snapshot",
    //        "account": "DemoUser",
    //        "fills": [
    //            {
    //                "instrument": "FI_XBTUSD_200925",
    //                "time": 1600256910739,
    //                "price": 10937.5,
    //                "seq": 36,
    //                "buy": true,
    //                "qty": 5000.0,
    //                "order_id": "9e30258b-5a98-4002-968a-5b0e149bcfbf",
    //                "cli_ord_id": "8b58d9da-fcaf-4f60-91bc-9973a3eba48d", // only on update, not on snapshot
    //                "fill_id": "cad76f07-814e-4dc6-8478-7867407b6bff",
    //                "fill_type": "maker",
    //                "fee_paid": -0.00009142857,
    //                "fee_currency": "BTC",
    //                "taker_order_type": "ioc",
    //                "order_type": "limit"
    //            },
    //            ...
    //        ]
    //    }
    //
    var trades interface{} = this.SafeValue(message, "fills", []interface{}{})
    var stored interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = stored
    }
    var tradeSymbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = ccxt.GetValue(trades, i)
        var parsedTrade interface{} = this.ParseWsMyTrade(trade)
        ccxt.AddElementToObject(tradeSymbols, ccxt.GetValue(parsedTrade, "symbol"), true)
        stored.(ccxt.Appender).Append(parsedTrade)
    }
    var tradeSymbolKeys interface{} = ccxt.ObjectKeys(tradeSymbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tradeSymbolKeys)); i++ {
        var symbol interface{} = ccxt.GetValue(tradeSymbolKeys, i)
        var messageHash interface{} = ccxt.Add("myTrades:", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, "myTrades")
}
func  (this *KrakenfuturesCore) ParseWsMyTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "instrument": "FI_XBTUSD_200925",
    //        "time": 1600256910739,
    //        "price": 10937.5,
    //        "seq": 36,
    //        "buy": true,
    //        "qty": 5000.0,
    //        "order_id": "9e30258b-5a98-4002-968a-5b0e149bcfbf",
    //        "cli_ord_id": "8b58d9da-fcaf-4f60-91bc-9973a3eba48d", // only on update, not on snapshot
    //        "fill_id": "cad76f07-814e-4dc6-8478-7867407b6bff",
    //        "fill_type": "maker",
    //        "fee_paid": -0.00009142857,
    //        "fee_currency": "BTC",
    //        "taker_order_type": "ioc",
    //        "order_type": "limit"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var marketId interface{} = this.SafeString(trade, "instrument")
    market = this.SafeMarket(marketId, market)
    var isBuy interface{} = this.SafeValue(trade, "buy")
    var feeCurrencyId interface{} = this.SafeString(trade, "fee_currency")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "fill_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "order": this.SafeString(trade, "order_id"),
        "type": this.SafeString(trade, "type"),
        "side": ccxt.Ternary(ccxt.IsTrue(isBuy), "buy", "sell"),
        "takerOrMaker": this.SafeString(trade, "fill_type"),
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "qty"),
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": this.SafeString(trade, "fee_paid"),
            "rate": nil,
        },
    })
}
func  (this *KrakenfuturesCore) WatchMultiHelper(unifiedName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            subscriptionArgs := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscriptionArgs
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14998)
            // symbols are required
            symbols = this.MarketSymbols(symbols, nil, false, true, false)
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                ccxt.AppendToArray(&messageHashes, this.GetMessageHash(unifiedName, nil, this.Symbol(ccxt.GetValue(symbols, i))))
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "feed": channelName,
                "product_ids": marketIds,
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes151315 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscriptionArgs))
                ccxt.PanicOnError(retRes151315)
                ch <- retRes151315
                return nil
        
            }()
            return ch
        }
func  (this *KrakenfuturesCore) GetMessageHash(unifiedElementName interface{}, optionalArgs ...interface{}) interface{}  {
    // unifiedElementName can be : orderbook, trade, ticker, bidask ...
    // subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
    subChannelName := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subChannelName
    symbol := ccxt.GetArg(optionalArgs, 1, nil)
    _ = symbol
    var withSymbol interface{} = !ccxt.IsEqual(symbol, nil)
    var messageHash interface{} = unifiedElementName
    if !ccxt.IsTrue(withSymbol) {
        messageHash = ccxt.Add(messageHash, "s")
    } else {
        messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
    }
    if ccxt.IsTrue(!ccxt.IsEqual(subChannelName, nil)) {
        messageHash = ccxt.Add(messageHash, ccxt.Add("#", subChannelName))
    }
    return messageHash
}
func  (this *KrakenfuturesCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        event: 'alert',
    //        message: 'Failed to subscribe to authenticated feed'
    //    }
    //
    var errMsg interface{} = this.SafeString(message, "message")
    
        {
            ret__ := func(this *KrakenfuturesCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *KrakenfuturesCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(error)
            return false
                            
                        }(this)
                    }
                }()
    		    // try block:
                        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), errMsg)))
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *KrakenfuturesCore) HandleMessage(client interface{}, message interface{})  {
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "challenge")) {
        this.HandleAuthenticate(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "alert")) {
        this.HandleErrorMessage(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "pong")) {
        client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    } else if ccxt.IsTrue(ccxt.IsEqual(event, nil)) {
        var feed interface{} = this.SafeString(message, "feed")
        var methods interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "ticker_lite": this.HandleBidAsk,
            "trade": this.HandleTrade,
            "trade_snapshot": this.HandleTrade,
            "book": this.HandleOrderBook,
            "book_snapshot": this.HandleOrderBookSnapshot,
            "open_orders_verbose": this.HandleOrder,
            "open_orders_verbose_snapshot": this.HandleOrderSnapshot,
            "fills": this.HandleMyTrades,
            "fills_snapshot": this.HandleMyTrades,
            "open_orders": this.HandleOrder,
            "open_orders_snapshot": this.HandleOrderSnapshot,
            "balances": this.HandleBalance,
            "balances_snapshot": this.HandleBalance,
            "open_positions": this.HandlePositions,
        }
        var method interface{} = this.SafeValue(methods, feed)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *KrakenfuturesCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * @see https://docs.futures.kraken.com/#websocket-api-websocket-api-introduction-sign-challenge-challenge
     */
    //
    //    {
    //        "event": "challenge",
    //        "message": "226aee50-88fc-4618-a42a-34f7709570b2"
    //    }
    //
    var event interface{} = this.SafeValue(message, "event")
    var messageHash interface{} = "challenge"
    if ccxt.IsTrue(!ccxt.IsEqual(event, "error")) {
        var challenge interface{} = this.SafeValue(message, "message")
        var hashedChallenge interface{} = this.Hash(this.Encode(challenge), ccxt.Sha256, "binary")
        var base64Secret interface{} = this.Base64ToBinary(this.Secret)
        var signature interface{} = this.Hmac(hashedChallenge, base64Secret, ccxt.Sha512, "base64")
        ccxt.AddElementToObject(this.Options, "challenge", challenge)
        ccxt.AddElementToObject(this.Options, "signedChallenge", signature)
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
    return message
}


func (this *KrakenfuturesCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
