package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DeepcoinCore struct {
	*ccxt.DeepcoinCore
	base *ccxt.DeepcoinCore
}

func NewDeepcoinCore() *DeepcoinCore {
    p := &DeepcoinCore{}
	base := &ccxt.DeepcoinCore{}
	p.base = base
	p.DeepcoinCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *DeepcoinCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchMarkPrice": false,
            "watchMarkPrices": false,
            "watchTickers": false,
            "watchBidsAsks": false,
            "watchOrderBook": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOrderBookForSymbols": false,
            "watchBalance": false,
            "watchLiquidations": false,
            "watchLiquidationsForSymbols": false,
            "watchMyLiquidations": false,
            "watchMyLiquidationsForSymbols": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchPositions": true,
            "watchFundingRate": false,
            "watchFundingRates": false,
            "createOrderWs": false,
            "editOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "unWatchTicker": true,
            "unWatchTrades": true,
            "unWatchOHLCV": true,
            "unWatchOrderBook": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": map[string]interface{} {
                        "spot": "wss://stream.deepcoin.com/streamlet/trade/public/spot?platform=api",
                        "swap": "wss://stream.deepcoin.com/streamlet/trade/public/swap?platform=api",
                    },
                    "private": "wss://stream.deepcoin.com/v1/private",
                },
            },
        },
        "options": map[string]interface{} {
            "lastRequestId": nil,
            "listenKey": nil,
            "listenKeyExpiryTimestamp": nil,
            "authenticate": map[string]interface{} {
                "method": "privateGetDeepcoinListenkeyExtend",
            },
            "timeframes": map[string]interface{} {
                "1m": "1m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "4h": "4h",
                "12h": "12h",
                "1d": "1d",
                "1w": "1w",
                "1M": "1o",
                "1y": "1y",
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
    })
}
func  (this *DeepcoinCore) Ping(client interface{}) interface{}  {
    var url interface{} = client.(ccxt.ClientInterface).GetUrl()
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "private"), 0)) {
        client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    }
    return "ping"
}
func  (this *DeepcoinCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *DeepcoinCore) RequestId() interface{}  {
    this.LockId()
    var previousValue interface{} = this.SafeInteger(this.Options, "lastRequestId", 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(this.Options, "lastRequestId", newValue)
    this.UnlockId()
    return newValue
}
func  (this *DeepcoinCore) CreatePublicRequest(market interface{}, requestId interface{}, topicID interface{}, optionalArgs ...interface{}) interface{}  {
    suffix := ccxt.GetArg(optionalArgs, 0, "")
    _ = suffix
    unWatch := ccxt.GetArg(optionalArgs, 1, false)
    _ = unWatch
    var marketId interface{} = ccxt.GetValue(market, "symbol") // spot markets use symbol with slash
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(market, "type"), "swap")) {
        marketId = ccxt.Add(ccxt.GetValue(market, "baseId"), ccxt.GetValue(market, "quoteId")) // swap markets use symbol without slash
    }
    var action interface{} = "1" // subscribe
    if ccxt.IsTrue(unWatch) {
        action = "0" // unsubscribe
    }
    var request interface{} = map[string]interface{} {
        "sendTopicAction": map[string]interface{} {
            "Action": action,
            "FilterValue": ccxt.Add(ccxt.Add("DeepCoin_", marketId), suffix),
            "LocalNo": requestId,
            "ResumeNo": ccxt.OpNeg(1),
            "TopicID": topicID,
        },
    }
    return request
}
func  (this *DeepcoinCore) WatchPublic(market interface{}, messageHash interface{}, topicID interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            suffix := ccxt.GetArg(optionalArgs, 1, "")
            _ = suffix
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), ccxt.GetValue(market, "type"))
            var requestId interface{} = this.RequestId()
            var request interface{} = this.CreatePublicRequest(market, requestId, topicID, suffix)
            var subscription interface{} = map[string]interface{} {
                "subHash": messageHash,
                "id": requestId,
            }
        
                retRes13715 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes13715)
                ch <- retRes13715
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) UnWatchPublic(market interface{}, messageHash interface{}, topicID interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = subscription
            suffix := ccxt.GetArg(optionalArgs, 2, "")
            _ = suffix
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), ccxt.GetValue(market, "type"))
            var requestId interface{} = this.RequestId()
            var client interface{} = this.Client(url)
            var existingSubscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(existingSubscription, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(this.Id, " no subscription for "), messageHash)))
            }
            var subId interface{} = this.SafeInteger(existingSubscription, "id")
            var request interface{} = this.CreatePublicRequest(market, subId, topicID, suffix, true) // unsubscribe message uses the same id as the original subscribe message
            var unsubHash interface{} = ccxt.Add("unsubscribe::", messageHash)
            subscription = this.Extend(subscription, map[string]interface{} {
                "subHash": messageHash,
                "unsubHash": unsubHash,
                "symbols": []interface{}{ccxt.GetValue(market, "symbol")},
                "id": requestId,
            })
        
                retRes15715 :=  (<-this.Watch(url, unsubHash, this.DeepExtend(request, params), unsubHash, subscription))
                ccxt.PanicOnError(retRes15715)
                ch <- retRes15715
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) WatchPrivate(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            listenKey:= (<-this.Authenticate())
            ccxt.PanicOnError(listenKey)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "?listenKey="), listenKey)
        
                retRes16315 :=  (<-this.Watch(url, messageHash, nil, "private", params))
                ccxt.PanicOnError(retRes16315)
                ch <- retRes16315
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var time interface{} = this.Milliseconds()
            var listenKeyExpiryTimestamp interface{} = this.SafeInteger(this.Options, "listenKeyExpiryTimestamp", time)
            var expired interface{} = ccxt.IsGreaterThan((ccxt.Subtract(time, listenKeyExpiryTimestamp)), 60000) // 1 minute before expiry
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            var response interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
                
            response = (<-this.PrivateGetDeepcoinListenkeyAcquire(params))
                    ccxt.PanicOnError(response)
            } else if ccxt.IsTrue(expired) {
                var method interface{} = this.SafeString(this.Options, "method", "privateGetDeepcoinListenkeyExtend")
                var getNewKey interface{} =         (ccxt.IsEqual(method, "privateGetDeepcoinListenkeyAcquire"))
                if ccxt.IsTrue(getNewKey) {
                    
            response = (<-this.PrivateGetDeepcoinListenkeyAcquire(params))
                        ccxt.PanicOnError(response)
                } else {
                    var request interface{} = map[string]interface{} {
                        "listenkey": listenKey,
                    }
                    
            response = (<-this.PrivateGetDeepcoinListenkeyExtend(this.Extend(request, params)))
                        ccxt.PanicOnError(response)
                }
            }
            if ccxt.IsTrue(!ccxt.IsEqual(response, nil)) {
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                listenKey = this.SafeString(data, "listenkey")
                listenKeyExpiryTimestamp = this.SafeTimestamp(data, "expire_time")
                ccxt.AddElementToObject(this.Options, "listenKey", listenKey)
                ccxt.AddElementToObject(this.Options, "listenKeyExpiryTimestamp", listenKeyExpiryTimestamp)
            }
        
            ch <- listenKey
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deepcoin#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeepcoinCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2078)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", "::"), ccxt.GetValue(market, "symbol"))
        
                retRes21015 :=  (<-this.WatchPublic(market, messageHash, "7", params))
                ccxt.PanicOnError(retRes21015)
                ch <- retRes21015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deepcoin#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeepcoinCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2238 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2238)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", "::"), ccxt.GetValue(market, "symbol"))
            var subscription interface{} = map[string]interface{} {
                "topic": "ticker",
            }
        
                retRes22915 :=  (<-this.UnWatchPublic(market, messageHash, "7", params, subscription))
                ccxt.PanicOnError(retRes22915)
                ch <- retRes22915
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     a: 'PO',
    //     m: 'Success',
    //     tt: 1760913034780,
    //     mt: 1760913034780,
    //     r: [
    //         {
    //             d: {
    //                 I: 'BTC/USDT',
    //                 U: 1760913034742,
    //                 PF: 0,
    //                 E: 0,
    //                 O: 108479.9,
    //                 H: 109449.9,
    //                 L: 108238,
    //                 V: 789.3424915,
    //                 T: 43003872.3705223,
    //                 N: 109345,
    //                 M: 87294.7,
    //                 D: 0,
    //                 V2: 3086.4496105,
    //                 T2: 332811624.339836,
    //                 F: 0,
    //                 C: 0,
    //                 BP1: 109344.9,
    //                 AP1: 109345.2
    //             }
    //         }
    //     ]
    //
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var parsedTicker interface{} = this.ParseWsTicker(data, market)
    var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", "::"), symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *DeepcoinCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         I: 'BTC/USDT',
    //         U: 1760913034742,
    //         PF: 0,
    //         E: 0,
    //         O: 108479.9,
    //         H: 109449.9,
    //         L: 108238,
    //         V: 789.3424915,
    //         T: 43003872.3705223,
    //         N: 109345,
    //         M: 87294.7,
    //         D: 0,
    //         V2: 3086.4496105,
    //         T2: 332811624.339836,
    //         F: 0,
    //         C: 0,
    //         BP1: 109344.9,
    //         AP1: 109345.2
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "U")
    var high interface{} = this.SafeNumber(ticker, "H")
    var low interface{} = this.SafeNumber(ticker, "L")
    var open interface{} = this.SafeNumber(ticker, "O")
    var last interface{} = this.SafeNumber(ticker, "N")
    var bid interface{} = this.SafeNumber(ticker, "BP1")
    var ask interface{} = this.SafeNumber(ticker, "AP1")
    var baseVolume interface{} = this.SafeNumber(ticker, "V")
    var quoteVolume interface{} = this.SafeNumber(ticker, "T")
    if ccxt.IsTrue(ccxt.GetValue(market, "inverse")) {
        var temp interface{} = baseVolume
        baseVolume = quoteVolume
        quoteVolume = temp
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name deepcoin#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *DeepcoinCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3488)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("trades", "::"), ccxt.GetValue(market, "symbol"))
        
            trades:= (<-this.WatchPublic(market, messageHash, "2", params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deepcoin#unWatchTrades
 * @description unWatches the list of most recent trades for a particular symbol
 * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DeepcoinCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3688 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3688)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("trades", "::"), ccxt.GetValue(market, "symbol"))
            var subscription interface{} = map[string]interface{} {
                "topic": "trades",
            }
        
                retRes37415 :=  (<-this.UnWatchPublic(market, messageHash, "2", params, subscription))
                ccxt.PanicOnError(retRes37415)
                ch <- retRes37415
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "a": "PMT",
    //         "b": 0,
    //         "tt": 1760968672380,
    //         "mt": 1760968672380,
    //         "r": [
    //             {
    //                 "d": {
    //                     "TradeID": "1001056452325378",
    //                     "I": "BTC/USDT",
    //                     "D": "1",
    //                     "P": 111061,
    //                     "V": 0.00137,
    //                     "T": 1760968672
    //                 }
    //             }
    //         ]
    //     }
    //
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var strored interface{} = ccxt.GetValue(this.Trades, symbol)
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        var trade interface{} = this.ParseWsTrade(data, market)
        strored.(ccxt.Appender).Append(trade)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("trades", "::"), symbol)
    client.(ccxt.ClientInterface).Resolve(strored, messageHash)
}
func  (this *DeepcoinCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // watchTrades
    //     {
    //         "TradeID": "1001056452325378",
    //         "I": "BTC/USDT",
    //         "D": "1",
    //         "P": 111061,
    //         "V": 0.00137,
    //         "T": 1760968672
    //     }
    //
    // watchMyTrades
    //     {
    //         "A": "9256245",
    //         "CC": "USDT",
    //         "CP": 0,
    //         "D": "0",
    //         "F": 0.152,
    //         "I": "DOGE/USDT",
    //         "IT": 1761048103,
    //         "M": "9256245",
    //         "OS": "1001437462198486",
    //         "P": 0.19443,
    //         "T": 14.77668,
    //         "TI": "1001056459096708",
    //         "TT": 1761048103,
    //         "V": 76,
    //         "f": "DOGE",
    //         "l": 1,
    //         "m": "1",
    //         "o": "0"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var direction interface{} = this.SafeString(trade, "D")
    var timestamp interface{} = this.SafeTimestamp2(trade, "TT", "T")
    var matchRole interface{} = this.SafeString(trade, "m")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "F")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "f")),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": this.SafeString2(trade, "TradeID", "TI"),
        "order": this.SafeString(trade, "OS"),
        "type": nil,
        "takerOrMaker": this.HandleTakerOrMaker(matchRole),
        "side": this.ParseTradeSide(direction),
        "price": this.SafeString(trade, "P"),
        "amount": this.SafeString(trade, "V"),
        "cost": this.SafeString(trade, "T"),
        "fee": fee,
    }, market)
}
func  (this *DeepcoinCore) ParseTradeSide(direction interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "0": "buy",
        "1": "sell",
    }
    return this.SafeString(sides, direction, direction)
}
func  (this *DeepcoinCore) HandleTakerOrMaker(matchRole interface{}) interface{}  {
    var roles interface{} = map[string]interface{} {
        "0": "maker",
        "1": "taker",
    }
    return this.SafeString(roles, matchRole, matchRole)
}
/**
 * @method
 * @name deepcoin#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.deepcoin.com/docs/publicWS/KLines
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} [timeframe] the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DeepcoinCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5088)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("ohlcv", "::"), symbol), "::"), timeframe)
            var suffix interface{} = ccxt.Add("_", interval)
        
            ohlcv:= (<-this.WatchPublic(market, messageHash, "11", params, suffix))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deepcoin#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} [timeframe] the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DeepcoinCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5338 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5338)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("ohlcv", "::"), symbol), "::"), timeframe)
            var suffix interface{} = ccxt.Add("_", interval)
            var subscription interface{} = map[string]interface{} {
                "topic": "ohlcv",
                "symbolsAndTimeframes": []interface{}{[]interface{}{symbol, timeframe}},
            }
        
                retRes54415 :=  (<-this.UnWatchPublic(market, messageHash, "11", params, subscription, suffix))
                ccxt.PanicOnError(retRes54415)
                ch <- retRes54415
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "a": "PK",
    //         "tt": 1760972831580,
    //         "mt": 1760972831580,
    //         "r": [
    //             {
    //                 "d": {
    //                     "I": "BTC/USDT",
    //                     "P": "1m",
    //                     "B": 1760972820,
    //                     "O": 111373,
    //                     "C": 111382.9,
    //                     "H": 111382.9,
    //                     "L": 111373,
    //                     "V": 0.2414172,
    //                     "M": 26888.19693324
    //                 },
    //                 "t": "LK"
    //             }
    //         ]
    //     }
    //
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var interval interface{} = this.SafeString(data, "P")
    var timeframe interface{} = this.FindTimeframe(interval)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(!ccxt.IsEqual(data, nil)) {
        var ohlcv interface{} = this.ParseWsOHLCV(data, market)
        stored.(ccxt.Appender).Append(ohlcv)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("ohlcv", "::"), symbol), "::"), timeframe)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *DeepcoinCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "I": "BTC/USDT",
    //         "P": "1m",
    //         "B": 1760972820,
    //         "O": 111373,
    //         "C": 111382.9,
    //         "H": 111382.9,
    //         "L": 111373,
    //         "V": 0.2414172,
    //         "M": 26888.19693324
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "B"), this.SafeNumber(ohlcv, "O"), this.SafeNumber(ohlcv, "H"), this.SafeNumber(ohlcv, "L"), this.SafeNumber(ohlcv, "C"), this.SafeNumber(ohlcv, "V")}
}
/**
 * @method
 * @name deepcoin#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeepcoinCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6308 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6308)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", "::"), ccxt.GetValue(market, "symbol"))
            var suffix interface{} = "_0.1"
        
            orderbook:= (<-this.WatchPublic(market, messageHash, "25", params, suffix))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deepcoin#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeepcoinCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6488)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", "::"), ccxt.GetValue(market, "symbol"))
            var suffix interface{} = "_0.1"
            var subscription interface{} = map[string]interface{} {
                "topic": "orderbook",
            }
        
                retRes65515 :=  (<-this.UnWatchPublic(market, messageHash, "25", params, subscription, suffix))
                ccxt.PanicOnError(retRes65515)
                ch <- retRes65515
                return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "a": "PMO",
    //         "t": "i", // i - update, f - snapshot
    //         "r": [
    //             {
    //                 "d": { "I": "ETH/USDT", "D": "1", "P": 4021, "V": 54.39979 }
    //             },
    //             {
    //                 "d": { "I": "ETH/USDT", "D": "0", "P": 4021.1, "V": 49.56724 }
    //             }
    //         ],
    //         "tt": 1760975816446,
    //         "mt": 1760975816446
    //     }
    //
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var typeVar interface{} = this.SafeString(message, "t")
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderbook, "timestamp"), nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "f")) {
            // snapshot
            this.HandleOrderBookSnapshot(client, message)
        } else {
            // cache the updates until the snapshot is received
            ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
        }
    } else {
        this.HandleOrderBookMessage(client, message, orderbook)
        var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", "::"), symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *DeepcoinCore) HandleOrderBookSnapshot(client interface{}, message interface{})  {
    var entries interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(entries, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var orderedEntries interface{} = map[string]interface{} {
        "bids": []interface{}{},
        "asks": []interface{}{},
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(entries)); i++ {
        var entry interface{} = ccxt.GetValue(entries, i)
        var entryData interface{} = this.SafeDict(entry, "d", map[string]interface{} {})
        var side interface{} = this.SafeString(entryData, "D")
        var price interface{} = this.SafeNumber(entryData, "P")
        var volume interface{} = this.SafeNumber(entryData, "V")
        if ccxt.IsTrue(ccxt.IsEqual(side, "0")) {
            // bid
            retRes72116 := ccxt.GetValue(orderedEntries, "bids")
            ccxt.AppendToArray(&retRes72116, []interface{}{price, volume})
        } else if ccxt.IsTrue(ccxt.IsEqual(side, "1")) {
            // ask
            retRes72416 := ccxt.GetValue(orderedEntries, "asks")
            ccxt.AppendToArray(&retRes72416, []interface{}{price, volume})
        }
    }
    var timestamp interface{} = this.SafeInteger(message, "mt")
    var snapshot interface{} = this.ParseOrderBook(orderedEntries, symbol, timestamp)
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var cachedMessages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(cachedMessages)); j++ {
        var cachedMessage interface{} = ccxt.GetValue(cachedMessages, j)
        this.HandleOrderBookMessage(client, cachedMessage, orderbook)
    }
    orderbook.(ccxt.OrderBookInterface).SetCache([]interface{}{})
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", "::"), symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *DeepcoinCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{})  {
    //     {
    //         "a": "PMO",
    //         "t": "i", // i - update, f - snapshot
    //         "r": [
    //             {
    //                 "d": { "I": "ETH/USDT", "D": "1", "P": 4021, "V": 54.39979 }
    //             },
    //             {
    //                 "d": { "I": "ETH/USDT", "D": "0", "P": 4021.1, "V": 49.56724 }
    //             }
    //         ],
    //         "tt": 1760975816446,
    //         "mt": 1760975816446
    //     }
    //
    var timestamp interface{} = this.SafeInteger(message, "mt")
    if ccxt.IsTrue(ccxt.IsGreaterThan(timestamp, ccxt.GetValue(orderbook, "timestamp"))) {
        var response interface{} = this.SafeList(message, "r", []interface{}{})
        this.HandleDeltas(orderbook, response)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
}
func  (this *DeepcoinCore) HandleDelta(orderbook interface{}, entry interface{})  {
    var data interface{} = this.SafeDict(entry, "d", map[string]interface{} {})
    var bids interface{} = ccxt.GetValue(orderbook, "bids")
    var asks interface{} = ccxt.GetValue(orderbook, "asks")
    var side interface{} = this.SafeString(data, "D")
    var price interface{} = this.SafeNumber(data, "P")
    var volume interface{} = this.SafeNumber(data, "V")
    if ccxt.IsTrue(ccxt.IsEqual(side, "0")) {
        // bid
        bids.(ccxt.IOrderBookSide).Store(price, volume)
    } else if ccxt.IsTrue(ccxt.IsEqual(side, "1")) {
        // ask
        asks.(ccxt.IOrderBookSide).Store(price, volume)
    }
}
/**
 * @method
 * @name deepcoin#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://www.deepcoin.com/docs/privateWS/ccxt.Trade
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DeepcoinCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "myTrades"
        
            retRes7948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7948)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", symbol))
            }
        
            trades:= (<-this.WatchPrivate(messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "PushTrade",
    //         "result": [
    //             {
    //                 "table": "ccxt.Trade",
    //                 "data": {
    //                     "A": "9256245",
    //                     "CC": "USDT",
    //                     "CP": 0,
    //                     "D": "0",
    //                     "F": 0.152,
    //                     "I": "DOGE/USDT",
    //                     "IT": 1761048103,
    //                     "M": "9256245",
    //                     "OS": "1001437462198486",
    //                     "P": 0.19443,
    //                     "T": 14.77668,
    //                     "TI": "1001056459096708",
    //                     "TT": 1761048103,
    //                     "V": 76,
    //                     "f": "DOGE",
    //                     "l": 1,
    //                     "m": "1",
    //                     "o": "0"
    //                 }
    //             }
    //         ]
    //     }
    //
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var first interface{} = this.SafeDict(result, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var messageHash interface{} = "myTrades"
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) || ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), symbolMessageHash)))) {
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.MyTrades
        var parsed interface{} = this.ParseWsTrade(data, market)
        stored.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        client.(ccxt.ClientInterface).Resolve(stored, symbolMessageHash)
    }
}
/**
 * @method
 * @name deepcoin#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.deepcoin.com/docs/privateWS/order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DeepcoinCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "orders"
        
            retRes8718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8718)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", symbol))
            }
        
            orders:= (<-this.WatchPrivate(messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "PushOrder",
    //         "result": [
    //             {
    //                 "table": "ccxt.Order",
    //                 "data": {
    //                     "D": "0",
    //                     "I": "DOGE/USDT",
    //                     "IT": 1761051006,
    //                     "L": "1001437480817468",
    //                     "OPT": "4",
    //                     "OS": "1001437480817468",
    //                     "OT": "0",
    //                     "Or": "1",
    //                     "P": 0.19537,
    //                     "T": 14.84128,
    //                     "U": 1761051006,
    //                     "V": 76,
    //                     "VT": 76,
    //                     "i": 1,
    //                     "l": 1,
    //                     "o": "0",
    //                     "p": "0",
    //                     "t": 0.19528
    //                 }
    //             }
    //         ]
    //     }
    //
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var first interface{} = this.SafeDict(result, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var messageHash interface{} = "orders"
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) || ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), symbolMessageHash)))) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var parsed interface{} = this.ParseWsOrder(data, market)
        this.Orders.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        client.(ccxt.ClientInterface).Resolve(this.Orders, symbolMessageHash)
    }
}
func  (this *DeepcoinCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "D": "0",
    //         "I": "DOGE/USDT",
    //         "IT": 1761051006,
    //         "L": "1001437480817468",
    //         "OPT": "4",
    //         "OS": "1001437480817468",
    //         "OT": "0",
    //         "Or": "1",
    //         "P": 0.19537,
    //         "T": 14.84128,
    //         "U": 1761051006,
    //         "V": 76,
    //         "VT": 76,
    //         "i": 1,
    //         "l": 1,
    //         "o": "0",
    //         "p": "0",
    //         "t": 0.19528
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var state interface{} = this.SafeString(order, "Or")
    var timestamp interface{} = this.SafeTimestamp(order, "IT")
    var direction interface{} = this.SafeString(order, "D")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "OS"),
        "clientOrderId": nil,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": this.SafeTimestamp(order, "U"),
        "status": this.ParseWsOrderStatus(state),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": nil,
        "timeInForce": nil,
        "side": this.ParseTradeSide(direction),
        "price": this.SafeString(order, "P"),
        "average": this.SafeString(order, "t"),
        "amount": this.SafeString(order, "V"),
        "filled": this.SafeString(order, "VT"),
        "remaining": nil,
        "triggerPrice": nil,
        "takeProfitPrice": this.SafeString(order, "TPT"),
        "stopLossPrice": this.SafeString(order, "SLT"),
        "cost": this.SafeString(order, "T"),
        "trades": nil,
        "fee": nil,
        "reduceOnly": nil,
        "postOnly": nil,
        "info": order,
    }, market)
}
func  (this *DeepcoinCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "closed",
        "4": "open",
        "6": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name deepcoin#watchPositions
 * @description watch all open positions
 * @see https://www.deepcoin.com/docs/privateWS/ccxt.Position
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *DeepcoinCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10108)
        
            listenKey:= (<-this.Authenticate())
            ccxt.PanicOnError(listenKey)
            symbols = this.MarketSymbols(symbols)
            var messageHash interface{} = "positions"
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
                    ccxt.AppendToArray(&messageHashes, symbolMessageHash)
                }
            } else {
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "?listenKey="), listenKey)
        
            positions:= (<-this.WatchMultiple(url, messageHashes, params, []interface{}{"private"}))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) HandlePosition(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "PushPosition",
    //         "result": [
    //             {
    //                 "table": "ccxt.Position",
    //                 "data": {
    //                     "A": "9256245",
    //                     "CP": 0,
    //                     "I": "DOGE/USDT",
    //                     "M": "9256245",
    //                     "OP": 0.198845,
    //                     "Po": 151.696,
    //                     "U": 1761058213,
    //                     "i": 1,
    //                     "l": 1,
    //                     "p": "0",
    //                     "u": 0
    //                 }
    //             }
    //         ]
    //     }
    //
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var first interface{} = this.SafeDict(result, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "I")
    var market interface{} = this.SafeMarket(marketId, nil, "/")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var messageHash interface{} = "positions"
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) || ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), symbolMessageHash)))) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
        }
        var parsed interface{} = this.ParseWsPosition(data, market)
        this.Positions.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.Positions, messageHash)
        client.(ccxt.ClientInterface).Resolve(this.Positions, symbolMessageHash)
    }
}
func  (this *DeepcoinCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "A": "9256245",
    //         "CP": 0,
    //         "I": "DOGE/USDT",
    //         "M": "9256245",
    //         "OP": 0.198845,
    //         "Po": 151.696,
    //         "U": 1761058213,
    //         "i": 1,
    //         "l": 1,
    //         "p": "0",
    //         "u": 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(position, "U")
    var direction interface{} = this.SafeString(position, "p")
    var marginMode interface{} = this.SafeString(position, "i")
    return this.SafePosition(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "contracts": this.SafeString(position, "Po"),
        "contractSize": nil,
        "side": this.ParsePositionSide(direction),
        "notional": nil,
        "leverage": this.OmitZero(this.SafeString(position, "l")),
        "unrealizedPnl": nil,
        "realizedPnl": nil,
        "collateral": nil,
        "entryPrice": this.SafeString(position, "OP"),
        "markPrice": nil,
        "liquidationPrice": nil,
        "marginMode": this.ParseWsMarginMode(marginMode),
        "hedged": true,
        "maintenanceMargin": this.SafeString(position, "u"),
        "maintenanceMarginPercentage": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "marginRatio": nil,
        "lastUpdateTimestamp": nil,
        "lastPrice": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "percentage": nil,
        "info": position,
    })
}
func  (this *DeepcoinCore) ParsePositionSide(direction interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(direction, nil)) {
        return direction
    }
    var directions interface{} = map[string]interface{} {
        "0": "long",
        "1": "short",
    }
    return this.SafeString(directions, direction, direction)
}
func  (this *DeepcoinCore) ParseWsMarginMode(marginMode interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(marginMode, nil)) {
        return marginMode
    }
    var modes interface{} = map[string]interface{} {
        "0": "isolated",
        "1": "cross",
    }
    return this.SafeString(modes, marginMode, marginMode)
}
func  (this *DeepcoinCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
    } else {
        var m interface{} = this.SafeString(message, "m")
        if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(m, nil))) && ccxt.IsTrue((!ccxt.IsEqual(m, "Success")))) {
            this.HandleErrorMessage(client, message)
        }
        var action interface{} = this.SafeString2(message, "a", "action")
        if ccxt.IsTrue(ccxt.IsEqual(action, "RecvTopicAction")) {
            this.HandleSubscriptionStatus(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PO")) {
            this.HandleTicker(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PMT")) {
            this.HandleTrades(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PK")) {
            this.HandleOHLCV(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PMO")) {
            this.HandleOrderBook(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PushTrade")) {
            this.HandleMyTrade(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PushOrder")) {
            this.HandleOrder(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(action, "PushPosition")) {
            this.HandlePosition(client, message)
        }
    }
}
func  (this *DeepcoinCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "a": "RecvTopicAction",
    //         "m": "Success",
    //         "r": [
    //             {
    //                 "d": {
    //                     "A": "0",
    //                     "L": 1,
    //                     "T": "7",
    //                     "F": "DeepCoin_BTC/USDT",
    //                     "R": -1
    //                 }
    //             }
    //         ]
    //     }
    //
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var action interface{} = this.SafeString(data, "A") // 1 = subscribe, 0 = unsubscribe
    if ccxt.IsTrue(ccxt.IsEqual(action, "0")) {
        var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
        var subId interface{} = this.SafeInteger(data, "L")
        var subscription interface{} = this.SafeDict(subscriptionsById, subId, map[string]interface{} {}) // original watch subscription
        var subHash interface{} = this.SafeString(subscription, "subHash")
        var unsubHash interface{} = ccxt.Add("unsubscribe::", subHash)
        var unsubsciption interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), unsubHash, map[string]interface{} {}) // unWatch subscription
        this.HandleUnSubscription(client, unsubsciption)
    }
}
func  (this *DeepcoinCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var subHash interface{} = this.SafeString(subscription, "subHash")
    var unsubHash interface{} = this.SafeString(subscription, "unsubHash")
    this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    this.CleanCache(subscription)
}
func  (this *DeepcoinCore) HandleErrorMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "a": "RecvTopicAction",
    //         "m": "subscription cluster does not "exist": BTC/USD",
    //         "r": [
    //             {
    //                 "d": {
    //                     "A": "1",
    //                     "L": 1,
    //                     "T": "7",
    //                     "F": "DeepCoin_BTC/USD",
    //                     "R": -1
    //                 }
    //             }
    //         ]
    //     }
    //
    var messageText interface{} = this.SafeString(message, "m", "")
    var response interface{} = this.SafeList(message, "r", []interface{}{})
    var first interface{} = this.SafeDict(response, 0, map[string]interface{} {})
    var data interface{} = this.SafeDict(first, "d", map[string]interface{} {})
    var requestId interface{} = this.SafeInteger(data, "L")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeDict(subscriptionsById, requestId, map[string]interface{} {})
    var messageHash interface{} = this.SafeString(subscription, "subHash")
    var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
    
        {
             func(this *DeepcoinCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *DeepcoinCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), messageText, feedback)
            this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageText, feedback)
            panic(ccxt.ExchangeError(feedback))
    		    
    	    }(this)
        
            }
}


func (this *DeepcoinCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
