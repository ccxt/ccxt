package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoinoneCore struct {
	*ccxt.CoinoneCore
	base *ccxt.CoinoneCore
}

func NewCoinoneCore() *CoinoneCore {
    p := &CoinoneCore{}
	base := &ccxt.CoinoneCore{}
	p.base = base
	p.CoinoneCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoinoneCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchOrders": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOHLCV": false,
            "watchTicker": true,
            "watchTickers": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://stream.coinone.co.kr",
            },
        },
        "options": map[string]interface{} {
            "expiresIn": "",
            "userId": "",
            "wsSessionToken": "",
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 6,
                "snapshotMaxRetries": 3,
            },
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "4009": ccxt.AuthenticationError,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 20000,
        },
    })
}
/**
 * @method
 * @name coinone#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.coinone.co.kr/reference/public-websocket-orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinoneCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes638)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "request_type": "SUBSCRIBE",
                "channel": "ORDERBOOK",
                "topic": map[string]interface{} {
                    "quote_currency": ccxt.GetValue(market, "quote"),
                    "target_currency": ccxt.GetValue(market, "base"),
                },
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CoinoneCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "response_type": "DATA",
    //         "channel": "ORDERBOOK",
    //         "data": {
    //             "quote_currency": "KRW",
    //             "target_currency": "BTC",
    //             "timestamp": 1705288918649,
    //             "id": "1705288918649001",
    //             "asks": [
    //                 {
    //                     "price": "58412000",
    //                     "qty": "0.59919807"
    //                 }
    //             ],
    //             "bids": [
    //                 {
    //                     "price": "58292000",
    //                     "qty": "0.1045"
    //                 }
    //             ]
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var baseId interface{} = this.SafeStringUpper(data, "target_currency")
    var quoteId interface{} = this.SafeStringUpper(data, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = this.Symbol(ccxt.Add(ccxt.Add(base, "/"), quote))
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        orderbook = this.OrderBook()
    } else {
        orderbook.(ccxt.OrderBookInterface).Reset()
    }
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    var asks interface{} = this.SafeValue(data, "asks", []interface{}{})
    var bids interface{} = this.SafeValue(data, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *CoinoneCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, "price", "qty")
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
/**
 * @method
 * @name coinone#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.coinone.co.kr/reference/public-websocket-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoinoneCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1458 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1458)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "request_type": "SUBSCRIBE",
                "channel": "TICKER",
                "topic": map[string]interface{} {
                    "quote_currency": ccxt.GetValue(market, "quote"),
                    "target_currency": ccxt.GetValue(market, "base"),
                },
            }
            var message interface{} = this.Extend(request, params)
        
                retRes15815 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes15815)
                ch <- retRes15815
                return nil
        
            }()
            return ch
        }
func  (this *CoinoneCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "response_type": "DATA",
    //         "channel": "TICKER",
    //         "data": {
    //             "quote_currency": "KRW",
    //             "target_currency": "BTC",
    //             "timestamp": 1705301117198,
    //             "quote_volume": "19521465345.504",
    //             "target_volume": "334.81445168",
    //             "high": "58710000",
    //             "low": "57276000",
    //             "first": "57293000",
    //             "last": "58532000",
    //             "volume_power": "100",
    //             "ask_best_price": "58537000",
    //             "ask_best_qty": "0.1961",
    //             "bid_best_price": "58532000",
    //             "bid_best_qty": "0.00009258",
    //             "id": "1705301117198001",
    //             "yesterday_high": "59140000",
    //             "yesterday_low": "57273000",
    //             "yesterday_first": "58897000",
    //             "yesterday_last": "57301000",
    //             "yesterday_quote_volume": "12967227517.4262",
    //             "yesterday_target_volume": "220.09232233"
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var ticker interface{} = this.ParseWsTicker(data)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *CoinoneCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "quote_currency": "KRW",
    //         "target_currency": "BTC",
    //         "timestamp": 1705301117198,
    //         "quote_volume": "19521465345.504",
    //         "target_volume": "334.81445168",
    //         "high": "58710000",
    //         "low": "57276000",
    //         "first": "57293000",
    //         "last": "58532000",
    //         "volume_power": "100",
    //         "ask_best_price": "58537000",
    //         "ask_best_qty": "0.1961",
    //         "bid_best_price": "58532000",
    //         "bid_best_qty": "0.00009258",
    //         "id": "1705301117198001",
    //         "yesterday_high": "59140000",
    //         "yesterday_low": "57273000",
    //         "yesterday_first": "58897000",
    //         "yesterday_last": "57301000",
    //         "yesterday_quote_volume": "12967227517.4262",
    //         "yesterday_target_volume": "220.09232233"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    var baseId interface{} = this.SafeString(ticker, "target_currency")
    var quoteId interface{} = this.SafeString(ticker, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = this.Symbol(ccxt.Add(ccxt.Add(base, "/"), quote))
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeNumber(ticker, "bid_best_price"),
        "bidVolume": this.SafeNumber(ticker, "bid_best_qty"),
        "ask": this.SafeNumber(ticker, "ask_best_price"),
        "askVolume": this.SafeNumber(ticker, "ask_best_qty"),
        "vwap": nil,
        "open": this.SafeString(ticker, "first"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "target_volume"),
        "quoteVolume": this.SafeString(ticker, "quote_volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinone#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.coinone.co.kr/reference/public-websocket-trade
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *CoinoneCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2688 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2688)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("trade:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "request_type": "SUBSCRIBE",
                "channel": "TRADE",
                "topic": map[string]interface{} {
                    "quote_currency": ccxt.GetValue(market, "quote"),
                    "target_currency": ccxt.GetValue(market, "base"),
                },
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *CoinoneCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "response_type": "DATA",
    //         "channel": "TRADE",
    //         "data": {
    //             "quote_currency": "KRW",
    //             "target_currency": "BTC",
    //             "id": "1705303667916001",
    //             "timestamp": 1705303667916,
    //             "price": "58490000",
    //             "qty": "0.0008",
    //             "is_seller_maker": false
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var trade interface{} = this.ParseWsTrade(data)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CoinoneCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "quote_currency": "KRW",
    //         "target_currency": "BTC",
    //         "id": "1705303667916001",
    //         "timestamp": 1705303667916,
    //         "price": "58490000",
    //         "qty": "0.0008",
    //         "is_seller_maker": false
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var baseId interface{} = this.SafeStringUpper(trade, "target_currency")
    var quoteId interface{} = this.SafeStringUpper(trade, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = ccxt.Add(ccxt.Add(base, "/"), quote)
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    market = this.SafeMarket(symbol, market)
    var isSellerMaker interface{} = this.SafeValue(trade, "is_seller_maker")
    var side interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(isSellerMaker, nil)) {
        side = ccxt.Ternary(ccxt.IsTrue(isSellerMaker), "sell", "buy")
    }
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "qty")
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": nil,
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *CoinoneCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "response_type": "ERROR",
    //         "error_code": 160012,
    //         "message": "Invalid Topic"
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "response_type", "")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "ERROR")) {
        return true
    }
    return false
}
func  (this *CoinoneCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var typeVar interface{} = this.SafeString(message, "response_type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "PONG")) {
        this.HandlePong(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "DATA")) {
        var topic interface{} = this.SafeString(message, "channel", "")
        var methods interface{} = map[string]interface{} {
            "ORDERBOOK": this.HandleOrderBook,
            "TICKER": this.HandleTicker,
            "TRADE": this.HandleTrades,
        }
        var exacMethod interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(exacMethod, nil)) {
            ccxt.CallDynamically(exacMethod, client, message)
            return
        }
        var keys interface{} = ccxt.ObjectKeys(methods)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var key interface{} = ccxt.GetValue(keys, i)
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, ccxt.GetValue(keys, i)), 0)) {
                var method interface{} = ccxt.GetValue(methods, key)
                ccxt.CallDynamically(method, client, message)
                return
            }
        }
    }
}
func  (this *CoinoneCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "request_type": "PING",
    }
}
func  (this *CoinoneCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "response_type":"PONG"
    //     }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}


func (this *CoinoneCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
