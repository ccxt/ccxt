package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoincheckCore struct {
	*ccxt.CoincheckCore
	base *ccxt.CoincheckCore
}

func NewCoincheckCore() *CoincheckCore {
    p := &CoincheckCore{}
	base := &ccxt.CoincheckCore{}
	p.base = base
	p.CoincheckCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoincheckCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchOrders": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOHLCV": false,
            "watchTicker": false,
            "watchTickers": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws-api.coincheck.com/",
            },
        },
        "options": map[string]interface{} {
            "expiresIn": "",
            "userId": "",
            "wsSessionToken": "",
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 6,
                "snapshotMaxRetries": 3,
            },
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "4009": ccxt.AuthenticationError,
            },
        },
    })
}
/**
 * @method
 * @name coincheck#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coincheck.com/documents/exchange/api#websocket-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoincheckCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes598)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": ccxt.Add(ccxt.GetValue(market, "id"), "-orderbook"),
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CoincheckCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     [
    //         "btc_jpy",
    //         {
    //             "bids": [
    //                 [
    //                     "6288279.0",
    //                     "0"
    //                 ]
    //             ],
    //             "asks": [
    //                 [
    //                     "6290314.0",
    //                     "0"
    //                 ]
    //             ],
    //             "last_update_at": "1705396097"
    //         }
    //     ]
    //
    var symbol interface{} = this.Symbol(this.SafeString(message, 0))
    var data interface{} = this.SafeValue(message, 1, map[string]interface{} {})
    var timestamp interface{} = this.SafeTimestamp(data, "last_update_at")
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp)
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        orderbook = this.OrderBook(snapshot)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    } else {
        orderbook = ccxt.GetValue(this.Orderbooks, symbol)
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    }
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name coincheck#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://coincheck.com/documents/exchange/api#websocket-trades
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *CoincheckCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1218)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trade:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": ccxt.Add(ccxt.GetValue(market, "id"), "-trades"),
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *CoincheckCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     [
    //         [
    //             "1663318663", // transaction timestamp (unix time)
    //             "2357062", // transaction ID
    //             "btc_jpy", // pair
    //             "2820896.0", // transaction rate
    //             "5.0", // transaction amount
    //             "sell", // order side
    //             "1193401", // ID of the Taker
    //             "2078767" // ID of the Maker
    //         ]
    //     ]
    //
    var first interface{} = this.SafeValue(message, 0, []interface{}{})
    var symbol interface{} = this.Symbol(this.SafeString(first, 2))
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var data interface{} = this.SafeValue(message, i)
        var trade interface{} = this.ParseWsTrade(data)
        stored.(ccxt.Appender).Append(trade)
    }
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *CoincheckCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1663318663", // transaction timestamp (unix time)
    //         "2357062", // transaction ID
    //         "btc_jpy", // pair
    //         "2820896.0", // transaction rate
    //         "5.0", // transaction amount
    //         "sell", // order side
    //         "1193401", // ID of the Taker
    //         "2078767" // ID of the Maker
    //     ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.Symbol(this.SafeString(trade, 2))
    var timestamp interface{} = this.SafeTimestamp(trade, 0)
    var side interface{} = this.SafeString(trade, 5)
    var priceString interface{} = this.SafeString(trade, 3)
    var amountString interface{} = this.SafeString(trade, 4)
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, 1),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": nil,
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *CoincheckCore) HandleMessage(client interface{}, message interface{})  {
    var data interface{} = this.SafeValue(message, 0)
    if !ccxt.IsTrue(ccxt.IsArray(data)) {
        this.HandleOrderBook(client, message)
    } else {
        this.HandleTrades(client, message)
    }
}


func (this *CoincheckCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
