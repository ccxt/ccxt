package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitoproCore struct {
	*ccxt.BitoproCore
	base *ccxt.BitoproCore
}

func NewBitoproCore() *BitoproCore {
    p := &BitoproCore{}
	base := &ccxt.BitoproCore{}
	p.base = base
	p.BitoproCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitoproCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrders": false,
            "watchTicker": true,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
        },
        "urls": map[string]interface{} {
            "ws": map[string]interface{} {
                "public": "wss://stream.bitopro.com:443/ws/v1/pub",
                "private": "wss://stream.bitopro.com:443/ws/v1/pub/auth",
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "login": true,
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "ws": map[string]interface{} {
                "options": map[string]interface{} {
                    "headers": map[string]interface{} {},
                },
            },
        },
    })
}
func  (this *BitoproCore) WatchPublic(path interface{}, messageHash interface{}, marketId interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var url interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "ws"), "public"), "/"), path), "/"), marketId)
        
                retRes5315 :=  (<-this.Watch(url, messageHash, nil, messageHash))
                ccxt.PanicOnError(retRes5315)
                ch <- retRes5315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitopro#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/ws/public/order_book_stream.md
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitoproCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(limit, 5))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 10)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 20)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 50)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 100)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 500)))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 1000)))) {
                    panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000")))
                }
            }
        
            retRes728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes728)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("ORDER_BOOK", ":"), symbol)
            var endPart interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                endPart = ccxt.GetValue(market, "id")
            } else {
                endPart = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), ":"), this.NumberToString(limit))
            }
        
            orderbook:= (<-this.WatchPublic("order-books", messageHash, endPart))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitoproCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "ORDER_BOOK",
    //         "timestamp": 1650121915308,
    //         "datetime": "2022-04-16T15:11:55.308Z",
    //         "pair": "BTC_TWD",
    //         "limit": 5,
    //         "scale": 0,
    //         "bids": [
    //             { price: "1188178", amount: '0.0425', count: 1, total: "0.0425" },
    //         ],
    //         "asks": [
    //             {
    //                 "price": "1190740",
    //                 "amount": "0.40943964",
    //                 "count": 1,
    //                 "total": "0.40943964"
    //             },
    //         ]
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var market interface{} = this.SafeMarket(marketId, nil, "_")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var event interface{} = this.SafeString(message, "event")
    var messageHash interface{} = ccxt.Add(ccxt.Add(event, ":"), symbol)
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        orderbook = this.OrderBook(map[string]interface{} {})
    }
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    var snapshot interface{} = this.ParseOrderBook(message, symbol, timestamp, "bids", "asks", "price", "amount")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name bitopro#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/ws/public/trade_stream.md
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitoproCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1358)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("TRADE", ":"), symbol)
        
            trades:= (<-this.WatchPublic("trades", messageHash, ccxt.GetValue(market, "id")))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BitoproCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "TRADE",
    //         "timestamp": 1650116346665,
    //         "datetime": "2022-04-16T13:39:06.665Z",
    //         "pair": "BTC_TWD",
    //         "data": [
    //             {
    //                 "event": '',
    //                 "datetime": '',
    //                 "pair": '',
    //                 "timestamp": 1650116227,
    //                 "price": "1189429",
    //                 "amount": "0.0153127",
    //                 "isBuyer": true
    //             },
    //         ]
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var market interface{} = this.SafeMarket(marketId, nil, "_")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var event interface{} = this.SafeString(message, "event")
    var messageHash interface{} = ccxt.Add(ccxt.Add(event, ":"), symbol)
    var rawData interface{} = this.SafeValue(message, "data", []interface{}{})
    var trades interface{} = this.ParseTrades(rawData, market)
    var tradesCache interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesCache, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesCache = ccxt.NewArrayCache(limit)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        tradesCache.(ccxt.Appender).Append(ccxt.GetValue(trades, i))
    }
    ccxt.AddElementToObject(this.Trades, symbol, tradesCache)
    client.(ccxt.ClientInterface).Resolve(tradesCache, messageHash)
}
/**
 * @method
 * @name bitopro#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/ws/private/matches_stream.md
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitoproCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes1988 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1988)
            var messageHash interface{} = "USER_TRADE"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(market, "symbol"))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "ws"), "private"), "/"), "user-trades")
            this.Authenticate(url)
        
            trades:= (<-this.Watch(url, messageHash, nil, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BitoproCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "USER_TRADE",
    //         "timestamp": 1694667358782,
    //         "datetime": "2023-09-14T12:55:58.782Z",
    //         "data": {
    //             "base": "usdt",
    //             "quote": "twd",
    //             "side": "ask",
    //             "price": "32.039",
    //             "volume": "1",
    //             "fee": "6407800",
    //             "feeCurrency": "twd",
    //             "transactionTimestamp": 1694667358,
    //             "eventTimestamp": 1694667358,
    //             "orderID": 390733918,
    //             "orderType": "LIMIT",
    //             "matchID": "bd07673a-94b1-419e-b5ee-d7b723261a5d",
    //             "isMarket": false,
    //             "isMaker": false
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var baseId interface{} = this.SafeString(data, "base")
    var quoteId interface{} = this.SafeString(data, "quote")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = this.Symbol(ccxt.Add(ccxt.Add(base, "/"), quote))
    var messageHash interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trades interface{} = this.MyTrades
    var parsed interface{} = this.ParseWsTrade(data)
    trades.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    client.(ccxt.ClientInterface).Resolve(trades, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
}
func  (this *BitoproCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "base": "usdt",
    //         "quote": "twd",
    //         "side": "ask",
    //         "price": "32.039",
    //         "volume": "1",
    //         "fee": "6407800",
    //         "feeCurrency": "twd",
    //         "transactionTimestamp": 1694667358,
    //         "eventTimestamp": 1694667358,
    //         "orderID": 390733918,
    //         "orderType": "LIMIT",
    //         "matchID": "bd07673a-94b1-419e-b5ee-d7b723261a5d",
    //         "isMarket": false,
    //         "isMaker": false
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "matchID")
    var orderId interface{} = this.SafeString(trade, "orderID")
    var timestamp interface{} = this.SafeTimestamp(trade, "transactionTimestamp")
    var baseId interface{} = this.SafeString(trade, "base")
    var quoteId interface{} = this.SafeString(trade, "quote")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = this.Symbol(ccxt.Add(ccxt.Add(base, "/"), quote))
    market = this.SafeMarket(symbol, market)
    var price interface{} = this.SafeString(trade, "price")
    var typeVar interface{} = this.SafeStringLower(trade, "orderType")
    var side interface{} = this.SafeString(trade, "side")
    if ccxt.IsTrue(!ccxt.IsEqual(side, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(side, "ask")) {
            side = "sell"
        } else if ccxt.IsTrue(ccxt.IsEqual(side, "bid")) {
            side = "buy"
        }
    }
    var amount interface{} = this.SafeString(trade, "volume")
    var fee interface{} = nil
    var feeAmount interface{} = this.SafeString(trade, "fee")
    var feeSymbol interface{} = this.SafeCurrencyCode(this.SafeString(trade, "feeCurrency"))
    if ccxt.IsTrue(!ccxt.IsEqual(feeAmount, nil)) {
        fee = map[string]interface{} {
            "cost": feeAmount,
            "currency": feeSymbol,
            "rate": nil,
        }
    }
    var isMaker interface{} = this.SafeValue(trade, "isMaker")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(isMaker, nil)) {
        if ccxt.IsTrue(isMaker) {
            takerOrMaker = "maker"
        } else {
            takerOrMaker = "taker"
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "takerOrMaker": takerOrMaker,
        "type": typeVar,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitopro#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/ws/public/ticker_stream.md
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitoproCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3408)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("TICKER", ":"), symbol)
        
                retRes34415 :=  (<-this.WatchPublic("tickers", messageHash, ccxt.GetValue(market, "id")))
                ccxt.PanicOnError(retRes34415)
                ch <- retRes34415
                return nil
        
            }()
            return ch
        }
func  (this *BitoproCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "TICKER",
    //         "timestamp": 1650119165710,
    //         "datetime": "2022-04-16T14:26:05.710Z",
    //         "pair": "BTC_TWD",
    //         "lastPrice": "1189110",
    //         "lastPriceUSD": "40919.1328",
    //         "lastPriceTWD": "1189110",
    //         "isBuyer": true,
    //         "priceChange24hr": "1.23",
    //         "volume24hr": "7.2090",
    //         "volume24hrUSD": "294985.5375",
    //         "volume24hrTWD": "8572279",
    //         "high24hr": "1193656",
    //         "low24hr": "1179321"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    // market-ids are lowercase in REST API and uppercase in WS API
    var market interface{} = this.SafeMarket(ccxt.ToLower(marketId), nil, "_")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var event interface{} = this.SafeString(message, "event")
    var messageHash interface{} = ccxt.Add(ccxt.Add(event, ":"), symbol)
    var result interface{} = this.ParseTicker(message, market)
    ccxt.AddElementToObject(result, "symbol", this.SafeString(market, "symbol")) // symbol returned from REST's parseTicker is distorted for WS, so re-set it from market object
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(result, "timestamp", timestamp)
    ccxt.AddElementToObject(result, "datetime", this.Iso8601(timestamp)) // we shouldn't set "datetime" string provided by server, as those values are obviously wrong offset from UTC
    ccxt.AddElementToObject(this.Tickers, symbol, result)
    client.(ccxt.ClientInterface).Resolve(result, messageHash)
}
func  (this *BitoproCore) Authenticate(url interface{})  {
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(this.Clients, nil))) && ccxt.IsTrue((ccxt.InOp(this.Clients, url)))) {
        return
    }
    this.CheckRequiredCredentials()
    var nonce interface{} = this.Milliseconds()
    var rawData interface{} = this.Json(map[string]interface{} {
        "nonce": nonce,
        "identity": this.Login,
    })
    var payload interface{} = this.StringToBase64(rawData)
    var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha384)
    var defaultOptions interface{} = map[string]interface{} {
        "ws": map[string]interface{} {
            "options": map[string]interface{} {
                "headers": map[string]interface{} {},
            },
        },
    }
    // this.options = this.extend (defaultOptions, this.options)
    this.ExtendExchangeOptions(defaultOptions)
    var originalHeaders interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers")
    var headers interface{} = map[string]interface{} {
        "X-BITOPRO-API": "ccxt",
        "X-BITOPRO-APIKEY": this.ApiKey,
        "X-BITOPRO-PAYLOAD": payload,
        "X-BITOPRO-SIGNATURE": signature,
    }
    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers", headers)
    // instantiate client
    this.Client(url)
    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers", originalHeaders)
}
/**
 * @method
 * @name bitopro#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/bitoex/bitopro-offical-api-docs/blob/master/ws/private/user_balance_stream.md
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BitoproCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes4258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4258)
            var messageHash interface{} = "ACCOUNT_BALANCE"
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "ws"), "private"), "/"), "account-balance")
            this.Authenticate(url)
        
                retRes42915 :=  (<-this.Watch(url, messageHash, nil, messageHash))
                ccxt.PanicOnError(retRes42915)
                ch <- retRes42915
                return nil
        
            }()
            return ch
        }
func  (this *BitoproCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "ACCOUNT_BALANCE",
    //         "timestamp": 1650450505715,
    //         "datetime": "2022-04-20T10:28:25.715Z",
    //         "data": {
    //           "ADA": {
    //             "currency": "ADA",
    //             "amount": "0",
    //             "available": "0",
    //             "stake": "0",
    //             "tradable": true
    //           },
    //         }
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    var data interface{} = this.SafeValue(message, "data")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    var datetime interface{} = this.SafeString(message, "datetime")
    var currencies interface{} = ccxt.ObjectKeys(data)
    var result interface{} = map[string]interface{} {
        "info": data,
        "timestamp": timestamp,
        "datetime": datetime,
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencies)); i++ {
        var currency interface{} = this.SafeString(currencies, i)
        var balance interface{} = this.SafeValue(data, currency)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(balance, "available"))
        ccxt.AddElementToObject(account, "total", this.SafeString(balance, "amount"))
        ccxt.AddElementToObject(result, code, account)
    }
    this.Balance = this.SafeBalance(result)
    client.(ccxt.ClientInterface).Resolve(this.Balance, event)
}
func  (this *BitoproCore) HandleMessage(client interface{}, message interface{})  {
    var methods interface{} = map[string]interface{} {
        "TRADE": this.HandleTrade,
        "TICKER": this.HandleTicker,
        "ORDER_BOOK": this.HandleOrderBook,
        "ACCOUNT_BALANCE": this.HandleBalance,
        "USER_TRADE": this.HandleMyTrade,
    }
    var event interface{} = this.SafeString(message, "event")
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *BitoproCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
