package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type KucoinfuturesCore struct {
	*ccxt.KucoinfuturesCore
	base *ccxt.KucoinfuturesCore
}

func NewKucoinfuturesCore() *KucoinfuturesCore {
    p := &KucoinfuturesCore{}
	base := &ccxt.KucoinfuturesCore{}
	p.base = base
	p.KucoinfuturesCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *KucoinfuturesCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchLiquidations": false,
            "watchLiquidatinsForSymbols": false,
            "watchMyLiquidations": nil,
            "watchMyLiquidationsForSymbols": nil,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchBalance": true,
            "watchPosition": true,
            "watchPositions": false,
            "watchPositionForSymbols": false,
            "watchTradesForSymbols": true,
            "watchOrderBookForSymbols": true,
        },
        "options": map[string]interface{} {
            "timeframes": map[string]interface{} {
                "1m": "1min",
                "3m": "1min",
                "5m": "5min",
                "15m": "15min",
                "30m": "30min",
                "1h": "1hour",
                "2h": "2hour",
                "4h": "4hour",
                "8h": "8hour",
                "12h": "12hour",
                "1d": "1day",
                "1w": "1week",
                "1M": "1month",
            },
            "accountsByType": map[string]interface{} {
                "swap": "future",
                "cross": "margin",
            },
            "tradesLimit": 1000,
            "watchOrderBook": map[string]interface{} {
                "snapshotDelay": 20,
                "snapshotMaxRetries": 3,
            },
            "watchPosition": map[string]interface{} {
                "fetchPositionSnapshot": true,
                "awaitPositionSnapshot": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
    })
}
func  (this *KucoinfuturesCore) Negotiate(privateChannel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var connectId interface{} = ccxt.Ternary(ccxt.IsTrue(privateChannel), "private", "public")
            var urls interface{} = this.SafeValue(this.Options, "urls", map[string]interface{} {})
            var future interface{} = this.SafeValue(urls, connectId)
            if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        
                    retRes8619 := <- future.(*ccxt.Future).Await()
                    ccxt.PanicOnError(retRes8619)
                    ch <- retRes8619
                    return nil
            }
            // we store an awaitable to the url
            // so that multiple calls don't asynchronously
            // fetch different urls and overwrite each other
            ccxt.AddElementToObject(urls, connectId, this.Spawn(this.NegotiateHelper, privateChannel, params)) // we have to wait here otherwsie in c# will not work
            ccxt.AddElementToObject(this.Options, "urls", urls)
            future = ccxt.GetValue(urls, connectId)
        
                retRes9415 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes9415)
                ch <- retRes9415
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) NegotiateHelper(privateChannel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var response interface{} = nil
            var connectId interface{} = ccxt.Ternary(ccxt.IsTrue(privateChannel), "private", "public")
            
                {
                     func(this *KucoinfuturesCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *KucoinfuturesCore) interface{} {
                                    // catch block:
                                            var future interface{} = this.SafeValue(ccxt.GetValue(this.Options, "urls"), connectId)
                    future.(*ccxt.Future).Reject(e)
                    ccxt.Remove(ccxt.GetValue(this.Options, "urls"), connectId)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                if ccxt.IsTrue(privateChannel) {
                        
                response = (<-this.FuturesPrivatePostBulletPrivate(params))
                            ccxt.PanicOnError(response)
                    } else {
                        
                response = (<-this.FuturesPublicPostBulletPublic(params))
                            ccxt.PanicOnError(response)
                    }
                    var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                    var instanceServers interface{} = this.SafeValue(data, "instanceServers", []interface{}{})
                    var firstInstanceServer interface{} = this.SafeValue(instanceServers, 0)
                    var pingInterval interface{} = this.SafeInteger(firstInstanceServer, "pingInterval")
                    var endpoint interface{} = this.SafeString(firstInstanceServer, "endpoint")
                    var token interface{} = this.SafeString(data, "token")
                    var result interface{} = ccxt.Add(ccxt.Add(endpoint, "?"), this.Urlencode(map[string]interface{} {
                "token": token,
                "privateChannel": privateChannel,
                "connectId": connectId,
            }))
                    var client interface{} = this.Client(result)
                    client.(ccxt.ClientInterface).SetKeepAlive(pingInterval)
            
                    ch <- result
                    return nil
            		    
            	    }(this)
                
                    }
        
            return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) RequestId() interface{}  {
    this.LockId()
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    this.UnlockId()
    return requestId
}
func  (this *KucoinfuturesCore) Subscribe(url interface{}, messageHash interface{}, subscriptionHash interface{}, subscription interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": subscriptionHash,
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
            var subscriptionRequest interface{} = map[string]interface{} {
                "id": requestId,
            }
            if ccxt.IsTrue(ccxt.IsEqual(subscription, nil)) {
                subscription = subscriptionRequest
            } else {
                subscription = this.Extend(subscriptionRequest, subscription)
            }
        
                retRes17015 :=  (<-this.Watch(url, messageHash, message, subscriptionHash, subscription))
                ccxt.PanicOnError(retRes17015)
                ch <- retRes17015
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) SubscribeMultiple(url interface{}, messageHashes interface{}, topic interface{}, subscriptionHashes interface{}, subscriptionArgs interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": topic,
                "response": true,
            }
        
                retRes18115 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), subscriptionHashes, subscriptionArgs))
                ccxt.PanicOnError(retRes18115)
                ch <- retRes18115
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) UnSubscribeMultiple(url interface{}, messageHashes interface{}, topic interface{}, subscriptionHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "unsubscribe",
                "topic": topic,
                "response": true,
            }
            var message interface{} = this.Extend(request, params)
            if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                ccxt.AddElementToObject(subscription, requestId, requestId)
            }
            var client interface{} = this.Client(url)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionHashes)); i++ {
                var subscriptionHash interface{} = ccxt.GetValue(subscriptionHashes, i)
                if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash))) {
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), requestId, subscriptionHash)
                }
            }
        
                retRes20315 :=  (<-this.WatchMultiple(url, messageHashes, message, subscriptionHashes, subscription))
                ccxt.PanicOnError(retRes20315)
                ch <- retRes20315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.kucoin.com/docs/websocket/futures-trading/public-channels/get-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KucoinfuturesCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2168)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchTicker")
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KucoinfuturesCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2338 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2338)
        
            ticker:= (<-this.WatchMultiRequest("watchTickers", "/contractMarket/ticker:", symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleTicker(client interface{}, message interface{})  {
    //
    // ticker (v1)
    //
    //    {
    //     "subject": "ticker",
    //     "topic": "/contractMarket/ticker:XBTUSDM",
    //     "data": {
    //         "symbol": "XBTUSDM", //ccxt.Market of the symbol
    //         "sequence": 45, //Sequence number which is used to judge the continuity of the pushed messages
    //         "side": "sell", //ccxt.Transaction side of the last traded taker order
    //         "price": "3600.0", //Filled price
    //         "size": 16, //Filled quantity
    //         "tradeId": "5c9dcf4170744d6f5a3d32fb", //ccxt.Order ID
    //         "bestBidSize": 795, //Best bid size
    //         "bestBidPrice": "3200.0", //Best bid
    //         "bestAskPrice": "3600.0", //Best ask size
    //         "bestAskSize": 284, //Best ask
    //         "ts": 1553846081210004941 //Filled time - nanosecond
    //     }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeValue(data, "symbol")
    var market interface{} = this.SafeMarket(marketId, nil, "-")
    var ticker interface{} = this.ParseTicker(data, market)
    ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(market, "symbol"), ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, this.GetMessageHash("ticker", ccxt.GetValue(market, "symbol")))
}
/**
 * @method
 * @name kucoinfutures#watchBidsAsks
 * @see https://www.kucoin.com/docs/websocket/futures-trading/public-channels/get-ticker-v2
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *KucoinfuturesCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            ticker:= (<-this.WatchMultiRequest("watchBidsAsks", "/contractMarket/tickerV2:", symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) WatchMultiRequest(methodName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2938)
            methodNameparamsVariable := this.HandleParamString(params, "callerMethodName", methodName)
            methodName = ccxt.GetValue(methodNameparamsVariable,0)
            params = ccxt.GetValue(methodNameparamsVariable,1)
            var isBidsAsks interface{} =     (ccxt.IsEqual(methodName, "watchBidsAsks"))
            symbols = this.MarketSymbols(symbols, nil, false, true, false)
            var length interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsGreaterThan(length, 100)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() accepts a maximum of 100 symbols")))
            }
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var prefix interface{} = ccxt.Ternary(ccxt.IsTrue(isBidsAsks), "bidask", "ticker")
                ccxt.AppendToArray(&messageHashes, this.GetMessageHash(prefix, ccxt.GetValue(market, "symbol")))
            }
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var marketIds interface{} = this.MarketIds(symbols)
            var joined interface{} = ccxt.Join(marketIds, ",")
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "type": "subscribe",
                "topic": ccxt.Add(channelName, joined),
                "response": true,
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
            }
        
                retRes32115 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscription))
                ccxt.PanicOnError(retRes32115)
                ch <- retRes32115
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    // arrives one symbol dict
    //
    // {
    //   "subject": "tickerV2",
    //   "topic": "/contractMarket/tickerV2:XBTUSDM",
    //   "data": {
    //     "symbol": "XBTUSDM", //ccxt.Market of the symbol
    //     "bestBidSize": 795, // Best bid size
    //     "bestBidPrice": 3200.0, // Best bid
    //     "bestAskPrice": 3600.0, // Best ask
    //     "bestAskSize": 284, // Best ask size
    //     "ts": 1553846081210004941 // Filled time - nanosecond
    //   }
    // }
    //
    var parsedTicker interface{} = this.ParseWsBidAsk(message)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, this.GetMessageHash("bidask", symbol))
}
func  (this *KucoinfuturesCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var data interface{} = this.SafeDict(ticker, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeIntegerProduct(data, "ts", 0.000001)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(data, "bestAskPrice"),
        "askVolume": this.SafeNumber(data, "bestAskSize"),
        "bid": this.SafeNumber(data, "bestBidPrice"),
        "bidVolume": this.SafeNumber(data, "bestBidSize"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name kucoinfutures#watchPosition
 * @description watch open positions for a specific symbol
 * @see https://docs.kucoin.com/futures/#position-change-events
 * @param {string|undefined} symbol unified market symbol
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *KucoinfuturesCore) WatchPosition(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchPosition() requires a symbol argument")))
            }
        
            retRes3788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3788)
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add("/contract/position:", ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var messageHash interface{} = ccxt.Add("position:", ccxt.GetValue(market, "symbol"))
            var client interface{} = this.Client(url)
            this.SetPositionCache(client, symbol)
            var fetchPositionSnapshot interface{} = this.HandleOption("watchPosition", "fetchPositionSnapshot", true)
            var awaitPositionSnapshot interface{} = this.HandleOption("watchPosition", "awaitPositionSnapshot", true)
            var currentPosition interface{} = this.GetCurrentPosition(symbol)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionSnapshot) && ccxt.IsTrue(awaitPositionSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(currentPosition, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future(ccxt.Add("fetchPositionSnapshot:", symbol)))
                ccxt.PanicOnError(snapshot)
        
                ch <- snapshot
                return nil
            }
        
                retRes39515 :=  (<-this.Subscribe(url, messageHash, topic, nil, this.Extend(request, params)))
                ccxt.PanicOnError(retRes39515)
                ch <- retRes39515
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) GetCurrentPosition(symbol interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        return nil
    }
    var cache interface{} = this.Positions.(*ccxt.ArrayCache).Hashmap
    var symbolCache interface{} = this.SafeValue(cache, symbol, map[string]interface{} {})
    var values interface{} = ccxt.ObjectValues(symbolCache)
    return this.SafeValue(values, 0)
}
func  (this *KucoinfuturesCore) SetPositionCache(client interface{}, symbol interface{})  {
    var fetchPositionSnapshot interface{} = this.HandleOption("watchPosition", "fetchPositionSnapshot", false)
    if ccxt.IsTrue(fetchPositionSnapshot) {
        var messageHash interface{} = ccxt.Add("fetchPositionSnapshot:", symbol)
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionSnapshot, client, messageHash, symbol)
        }
    }
}
func  (this *KucoinfuturesCore) LoadPositionSnapshot(client interface{}, messageHash interface{}, symbol interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            position:= (<-this.FetchPosition(symbol))
            ccxt.PanicOnError(position)
            this.Positions = ccxt.NewArrayCacheBySymbolById()
            var cache interface{} = this.Positions
            cache.(ccxt.Appender).Append(position)
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(position, ccxt.Add("position:", symbol))
            }
                return nil
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandlePosition(client interface{}, message interface{})  {
    //
    // ccxt.Position Changes Caused Operations
    //    {
    //        "type": "message",
    //        "userId": "5c32d69203aa676ce4b543c7", // Deprecated, will detele later
    //        "channelType": "private",
    //        "topic": "/contract/position:XBTUSDM",
    //        "subject": "position.change",
    //        "data": {
    //            "realisedGrossPnl": 0E-8, //Accumulated realised profit and loss
    //            "symbol": "XBTUSDM", //Symbol
    //            "crossMode": false, //Cross mode or not
    //            "liquidationPrice": 1000000.0, //ccxt.Liquidation price
    //            "posLoss": 0E-8, //Manually added margin amount
    //            "avgEntryPrice": 7508.22, //Average entry price
    //            "unrealisedPnl": -0.00014735, //Unrealised profit and loss
    //            "markPrice": 7947.83, //Mark price
    //            "posMargin": 0.00266779, //ccxt.Position margin
    //            "autoDeposit": false, //Auto deposit margin or not
    //            "riskLimit": 100000, //Risk limit
    //            "unrealisedCost": 0.00266375, //Unrealised value
    //            "posComm": 0.00000392, //Bankruptcy cost
    //            "posMaint": 0.00001724, //Maintenance margin
    //            "posCost": 0.00266375, //ccxt.Position value
    //            "maintMarginReq": 0.005, //Maintenance margin rate
    //            "bankruptPrice": 1000000.0, //Bankruptcy price
    //            "realisedCost": 0.00000271, //Currently accumulated realised position value
    //            "markValue": 0.00251640, //Mark value
    //            "posInit": 0.00266375, //ccxt.Position margin
    //            "realisedPnl": -0.00000253, //Realised profit and losts
    //            "maintMargin": 0.00252044, //ccxt.Position margin
    //            "realLeverage": 1.06, //ccxt.Leverage of the order
    //            "changeReason": "positionChange", //changeReason:marginChange、positionChange、liquidation、autoAppendMarginStatusChange、adl
    //            "currentCost": 0.00266375, //Current position value
    //            "openingTimestamp": 1558433191000, //Open time
    //            "currentQty": -20, //Current position
    //            "delevPercentage": 0.52, //ADL ranking percentile
    //            "currentComm": 0.00000271, //Current commission
    //            "realisedGrossCost": 0E-8, //Accumulated reliased gross profit value
    //            "isOpen": true, //Opened position or not
    //            "posCross": 1.2E-7, //Manually added margin
    //            "currentTimestamp": 1558506060394, //Current timestamp
    //            "unrealisedRoePcnt": -0.0553, //Rate of return on investment
    //            "unrealisedPnlPcnt": -0.0553, //ccxt.Position profit and loss ratio
    //            "settleCurrency": "XBT" //ccxt.Currency used to clear and settle the trades
    //        }
    //    }
    // ccxt.Position Changes Caused by Mark Price
    //    {
    //        "userId": "5cd3f1a7b7ebc19ae9558591", // Deprecated, will detele later
    //        "topic": "/contract/position:XBTUSDM",
    //        "subject": "position.change",
    //          "data": {
    //              "markPrice": 7947.83,                   //Mark price
    //              "markValue": 0.00251640,                 //Mark value
    //              "maintMargin": 0.00252044,              //ccxt.Position margin
    //              "realLeverage": 10.06,                   //ccxt.Leverage of the order
    //              "unrealisedPnl": -0.00014735,           //Unrealised profit and lost
    //              "unrealisedRoePcnt": -0.0553,           //Rate of return on investment
    //              "unrealisedPnlPcnt": -0.0553,            //ccxt.Position profit and loss ratio
    //              "delevPercentage": 0.52,             //ADL ranking percentile
    //              "currentTimestamp": 1558087175068,      //Current timestamp
    //              "settleCurrency": "XBT"                 //ccxt.Currency used to clear and settle the trades
    //          }
    //    }
    //  Funding Settlement
    //    {
    //        "userId": "xbc453tg732eba53a88ggyt8c", // Deprecated, will detele later
    //        "topic": "/contract/position:XBTUSDM",
    //        "subject": "position.settlement",
    //        "data": {
    //            "fundingTime": 1551770400000,          //Funding time
    //            "qty": 100,                            //ccxt.Position siz
    //            "markPrice": 3610.85,                 //Settlement price
    //            "fundingRate": -0.002966,             //Funding rate
    //            "fundingFee": -296,                   //Funding fees
    //            "ts": 1547697294838004923,             //Current time (nanosecond)
    //            "settleCurrency": "XBT"                //ccxt.Currency used to clear and settle the trades
    //        }
    //    }
    // Adjustmet result of risk limit level
    //     {
    //         "userId": "xbc453tg732eba53a88ggyt8c",
    //         "topic": "/contract/position:ADAUSDTM",
    //         "subject": "position.adjustRiskLimit",
    //         "data": {
    //           "success": true, // Successful or not
    //           "riskLimitLevel": 1, // Current risk limit level
    //           "msg": "" // Failure reason
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic", "")
    var parts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = this.SafeString(parts, 1)
    var symbol interface{} = this.SafeSymbol(marketId, nil, "")
    var cache interface{} = this.Positions
    var currentPosition interface{} = this.GetCurrentPosition(symbol)
    var messageHash interface{} = ccxt.Add("position:", symbol)
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var newPosition interface{} = this.ParsePosition(data)
    var keys interface{} = ccxt.ObjectKeys(newPosition)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(newPosition, key), nil)) {
            ccxt.Remove(newPosition, key)
        }
    }
    var position interface{} = this.Extend(currentPosition, newPosition)
    cache.(ccxt.Appender).Append(position)
    client.(ccxt.ClientInterface).Resolve(position, messageHash)
}
/**
 * @method
 * @name kucoinfutures#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.kucoin.com/futures/#execution-data
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KucoinfuturesCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes55815 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes55815)
                ch <- retRes55815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @param {string[]} symbols
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KucoinfuturesCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes5768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5768)
            symbols = this.MarketSymbols(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var topic interface{} = ccxt.Add("/contractMarket/execution:", ccxt.Join(marketIds, ","))
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("/contractMarket/execution:", marketId))
            }
        
            trades:= (<-this.SubscribeMultiple(url, messageHashes, topic, subscriptionHashes, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#unWatchTrades
 * @description unWatches trades stream
 * @see https://docs.kucoin.com/futures/#execution-data
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KucoinfuturesCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes60915 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes60915)
                ch <- retRes60915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#unWatchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @param {string[]} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *KucoinfuturesCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6218)
            symbols = this.MarketSymbols(symbols, nil, false)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var topic interface{} = ccxt.Add("/contractMarket/execution:", ccxt.Join(marketIds, ","))
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trades:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("trades:", symbol))
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": messageHashes,
                "subMessageHashes": subscriptionHashes,
                "topic": "trades",
                "unsubscribe": true,
                "symbols": symbols,
            }
        
                retRes64115 :=  (<-this.UnSubscribeMultiple(url, messageHashes, topic, messageHashes, params, subscription))
                ccxt.PanicOnError(retRes64115)
                ch <- retRes64115
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "type": "message",
    //        "topic": "/contractMarket/execution:ADAUSDTM",
    //        "subject": "match",
    //        "data": {
    //            "makerUserId": "62286a4d720edf0001e81961",
    //            "symbol": "ADAUSDTM",
    //            "sequence": 41320766,
    //            "side": "sell",
    //            "size": 2,
    //            "price": 0.35904,
    //            "takerOrderId": "636dd9da9857ba00010cfa44",
    //            "makerOrderId": "636dd9c8df149d0001e62bc8",
    //            "takerUserId": "6180be22b6ab210001fa3371",
    //            "tradeId": "636dd9da0000d400d477eca7",
    //            "ts": 1668143578987357700
    //        }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var trade interface{} = this.ParseTrade(data)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var trades interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        trades = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, trades)
    }
    trades.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    return message
}
/**
 * @method
 * @name kucoinfutures#watchOHLCV
 * @see https://www.kucoin.com/docs/websocket/futures-trading/public-channels/klines
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *KucoinfuturesCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6938)
            symbol = this.Symbol(symbol)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var marketId interface{} = this.MarketId(symbol)
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes")
            var timeframeId interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("/contractMarket/limitCandle:", marketId), "_"), timeframeId)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "_"), timeframe)
        
            ohlcv:= (<-this.Subscribe(url, messageHash, topic, nil, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        "topic":"/contractMarket/limitCandle:LTCUSDTM_1min",
    //        "type":"message",
    //        "data":{
    //            "symbol":"LTCUSDTM",
    //            "candles":[
    //                "1715470980",
    //                "81.38",
    //                "81.38",
    //                "81.38",
    //                "81.38",
    //                "61.0",
    //                "61"
    //            ],
    //            "time":1715470994801
    //        },
    //        "subject":"candle.stick"
    //    }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, "_")
    var timeframeId interface{} = this.SafeString(parts, 1)
    var data interface{} = this.SafeDict(message, "data")
    var timeframes interface{} = this.SafeDict(this.Options, "timeframes")
    var timeframe interface{} = this.FindTimeframe(timeframeId, timeframes)
    var marketId interface{} = this.SafeString(data, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "_"), timeframe)
    var ohlcv interface{} = this.SafeList(data, "candles")
    var parsed interface{} = []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 6)}
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeDict(this.Ohlcvs, symbol, map[string]interface{} {}))
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name kucoinfutures#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 *   1. After receiving the websocket Level 2 data flow, cache the data.
 *   2. Initiate a REST request to get the snapshot data of Level 2 order book.
 *   3. Playback the cached Level 2 data flow.
 *   4. Apply the new Level 2 data flow to the local snapshot to ensure that the sequence of the new Level 2 update lines up with the sequence of the previous Level 2 data. Discard all the message prior to that sequence, and then playback the change to snapshot.
 *   5. Update the level2 full data based on sequence according to the size. If the price is 0, ignore the messages and update the sequence. If the size=0, update the sequence and remove the price of which the size is 0 out of level 2. For other cases, please update the price.
 *   6. If the sequence of the newly pushed message does not line up to the sequence of the last message, you could pull through REST Level 2 message request to get the updated messages. Please note that the difference between the start and end parameters cannot exceed 500.
 * @see https://docs.kucoin.com/futures/#level-2-market-data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinfuturesCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes77415 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes77415)
                ch <- retRes77415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kucoin.com/futures/#level-2-market-data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinfuturesCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(limit, 20))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 100)))) {
                    panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook \\'limit\\' argument must be undefined, 20 or 100")))
                }
            }
        
            retRes7978 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7978)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var topic interface{} = ccxt.Add("/contractMarket/level2:", ccxt.Join(marketIds, ","))
            var subscriptionArgs interface{} = map[string]interface{} {
                "limit": limit,
            }
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("/contractMarket/level2:", marketId))
            }
        
            orderbook:= (<-this.SubscribeMultiple(url, messageHashes, topic, subscriptionHashes, subscriptionArgs, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.kucoin.com/futures/#level-2-market-data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinfuturesCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes82715 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes82715)
                ch <- retRes82715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoinfutures#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *KucoinfuturesCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8398)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
        
            url:= (<-this.Negotiate(false))
            ccxt.PanicOnError(url)
            var topic interface{} = ccxt.Add("/contractMarket/level2:", ccxt.Join(marketIds, ","))
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("orderbook:", symbol))
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": messageHashes,
                "symbols": symbols,
                "unsubscribe": true,
                "topic": "orderbook",
                "subMessageHashes": subscriptionHashes,
            }
        
                retRes85815 :=  (<-this.UnSubscribeMultiple(url, messageHashes, topic, messageHashes, params, subscription))
                ccxt.PanicOnError(retRes85815)
                ch <- retRes85815
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleDelta(orderbook interface{}, delta interface{})  {
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(delta, "sequence"))
    var timestamp interface{} = this.SafeInteger(delta, "timestamp")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var change interface{} = this.SafeValue(delta, "change", map[string]interface{} {})
    var splitChange interface{} = ccxt.Split(change, ",")
    var price interface{} = this.SafeNumber(splitChange, 0)
    var side interface{} = this.SafeString(splitChange, 1)
    var quantity interface{} = this.SafeNumber(splitChange, 2)
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "buy"))), "bids", "asks")
    var value interface{} = []interface{}{price, quantity}
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "bids")) {
        var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
        storedBids.(ccxt.IOrderBookSide).StoreArray(value)
    } else {
        var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
        storedAsks.(ccxt.IOrderBookSide).StoreArray(value)
    }
}
func  (this *KucoinfuturesCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *KucoinfuturesCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //    {
    //        "type": "message",
    //        "topic": "/contractMarket/level2:ADAUSDTM",
    //        "subject": "level2",
    //        "data": {
    //            "sequence": 1668059586457,
    //            "change": "0.34172,sell,456", // type, side, quantity
    //            "timestamp": 1668573023223
    //        }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    var topic interface{} = this.SafeString(message, "topic")
    var topicParts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = this.SafeString(topicParts, 1)
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var subscriptionArgs interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), topic, map[string]interface{} {})
        var limit interface{} = this.SafeInteger(subscriptionArgs, "limit")
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeInteger(storedOrderBook, "nonce")
    var deltaEnd interface{} = this.SafeInteger(data, "sequence")
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        var cacheLength interface{} =         ccxt.GetArrayLength(storedOrderBook.(ccxt.OrderBookInterface).GetCache())
        var topicPartsNew interface{} = ccxt.Split(topic, ":")
        var topicSymbol interface{} = this.SafeString(topicPartsNew, 1)
        var topicChannel interface{} = this.SafeString(topicPartsNew, 0)
        var subscriptions interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
        var subscription interface{} = nil
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
            var key interface{} = ccxt.GetValue(subscriptions, i)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(key, topicSymbol), 0))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(key, topicChannel), 0)))) {
                subscription = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), key)
                break
            }
        }
        var limit interface{} = this.SafeInteger(subscription, "limit")
        var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 5)
        if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
            this.Spawn(this.LoadOrderBook, client, messageHash, symbol, limit, map[string]interface{} {})
        }
        ccxt.AppendToArray(storedOrderBook.(ccxt.OrderBookInterface).GetCache(), data)
        return
    } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(nonce, deltaEnd)) {
        return
    }
    this.HandleDelta(storedOrderBook, data)
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *KucoinfuturesCore) GetCacheIndex(orderbook interface{}, cache interface{}) interface{}  {
    var firstDelta interface{} = this.SafeValue(cache, 0)
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    var firstDeltaStart interface{} = this.SafeInteger(firstDelta, "sequence")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(firstDeltaStart, 1))) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaStart interface{} = this.SafeInteger(delta, "sequence")
        if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(deltaStart, 1))) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
func  (this *KucoinfuturesCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo: answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "id": "1578090234088", // connectId
    //         "type": "welcome",
    //     }
    //
    return message
}
/**
 * @method
 * @name kucoinfutures#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.kucoin.com/futures/#trade-orders-according-to-the-market
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *KucoinfuturesCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9898)
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var topic interface{} = "/contractMarket/tradeOrders"
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.Subscribe(url, messageHash, topic, nil, this.Extend(request, params)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "open": "open",
        "filled": "closed",
        "match": "open",
        "update": "open",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *KucoinfuturesCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //         "symbol": "XCAD-USDT",
    //     {
    //         "orderType": "limit",
    //         "side": "buy",
    //         "orderId": "6249167327218b000135e749",
    //         "type": "canceled",
    //         "orderTime": 1648957043065280224,
    //         "size": "100.452",
    //         "filledSize": "0",
    //         "price": "2.9635",
    //         "clientOid": "buy-XCAD-USDT-1648957043010159",
    //         "remainSize": "0",
    //         "status": "done",
    //         "ts": 1648957054031001037
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "orderId")
    var clientOrderId interface{} = this.SafeString(order, "clientOid")
    var orderType interface{} = this.SafeStringLower(order, "orderType")
    var price interface{} = this.SafeString(order, "price")
    var filled interface{} = this.SafeString(order, "filledSize")
    var amount interface{} = this.SafeString(order, "size")
    var rawType interface{} = this.SafeString(order, "type")
    var status interface{} = this.ParseWsOrderStatus(rawType)
    var timestamp interface{} = this.SafeIntegerProduct(order, "orderTime", 0.000001)
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var side interface{} = this.SafeStringLower(order, "side")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": orderType,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *KucoinfuturesCore) HandleOrder(client interface{}, message interface{})  {
    var messageHash interface{} = "orders"
    var data interface{} = this.SafeValue(message, "data")
    var parsed interface{} = this.ParseWsOrder(data)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cachedOrders interface{} = this.Orders
        var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var order interface{} = this.SafeValue(orders, orderId)
        if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
            // todo add others to calculate average etc
            var stopPrice interface{} = this.SafeValue(order, "stopPrice")
            if ccxt.IsTrue(!ccxt.IsEqual(stopPrice, nil)) {
                ccxt.AddElementToObject(parsed, "stopPrice", stopPrice)
            }
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(order, "status"), "closed")) {
                ccxt.AddElementToObject(parsed, "status", "closed")
            }
        }
        cachedOrders.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.Orders, symbolSpecificMessageHash)
    }
}
/**
 * @method
 * @name kucoinfutures#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.kucoin.com/futures/#account-balance-events
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *KucoinfuturesCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11158)
        
            url:= (<-this.Negotiate(true))
            ccxt.PanicOnError(url)
            var topic interface{} = "/contractAccount/wallet"
            var request interface{} = map[string]interface{} {
                "privateChannel": true,
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleBalanceSubscription,
            }
            var messageHash interface{} = "balance"
        
                retRes112515 :=  (<-this.Subscribe(url, messageHash, topic, subscription, this.Extend(request, params)))
                ccxt.PanicOnError(retRes112515)
                ch <- retRes112515
                return nil
        
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleBalance(client interface{}, message interface{})  {
    //
    //    {
    //        "id": "6375553193027a0001f6566f",
    //        "type": "message",
    //        "topic": "/contractAccount/wallet",
    //        "userId": "613a896885d8660006151f01",
    //        "channelType": "private",
    //        "subject": "availableBalance.change",
    //        "data": {
    //            "currency": "USDT",
    //            "holdBalance": "0.0000000000",
    //            "availableBalance": "14.0350281903",
    //            "timestamp": "1668633905657"
    //        }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    ccxt.AddElementToObject(this.Balance, "info", data)
    var currencyId interface{} = this.SafeString(data, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(data, "availableBalance"))
    ccxt.AddElementToObject(account, "used", this.SafeString(data, "holdBalance"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
}
func  (this *KucoinfuturesCore) HandleBalanceSubscription(client interface{}, message interface{}, subscription interface{})  {
    this.Spawn(this.FetchBalanceSnapshot, client, message)
}
func  (this *KucoinfuturesCore) FetchBalanceSnapshot(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            retRes11628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11628)
            this.CheckRequiredCredentials()
            var messageHash interface{} = "balance"
            var selectedType interface{} = this.SafeString2(this.Options, "watchBalance", "defaultType", "swap") // spot, margin, main, funding, future, mining, trade, contract, pool
            var params interface{} = map[string]interface{} {
                "type": selectedType,
            }
        
            snapshot:= (<-this.FetchBalance(params))
            ccxt.PanicOnError(snapshot)
            //
            //    {
            //        "info": {
            //            "code": "200000",
            //            "data": {
            //                "accountEquity": 0.0350281903,
            //                "unrealisedPNL": 0,
            //                "marginBalance": 0.0350281903,
            //                "positionMargin": 0,
            //                "orderMargin": 0,
            //                "frozenFunds": 0,
            //                "availableBalance": 0.0350281903,
            //                "currency": "USDT"
            //            }
            //        },
            //        "timestamp": undefined,
            //        "datetime": undefined,
            //        "USDT": {
            //            "free": 0.0350281903,
            //            "used": 0,
            //            "total": 0.0350281903
            //        },
            //        "free": {
            //            "USDT": 0.0350281903
            //        },
            //        "used": {
            //            "USDT": 0
            //        },
            //        "total": {
            //            "USDT": 0.0350281903
            //        }
            //    }
            //
            var keys interface{} = ccxt.ObjectKeys(snapshot)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
                var code interface{} = ccxt.GetValue(keys, i)
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(code, "free")) && ccxt.IsTrue(!ccxt.IsEqual(code, "used"))) && ccxt.IsTrue(!ccxt.IsEqual(code, "total"))) && ccxt.IsTrue(!ccxt.IsEqual(code, "timestamp"))) && ccxt.IsTrue(!ccxt.IsEqual(code, "datetime"))) && ccxt.IsTrue(!ccxt.IsEqual(code, "info"))) {
                    ccxt.AddElementToObject(this.Balance, code, ccxt.GetValue(snapshot, code))
                }
            }
            ccxt.AddElementToObject(this.Balance, "info", this.SafeValue(snapshot, "info", map[string]interface{} {}))
            client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
                return nil
            }()
            return ch
        }
func  (this *KucoinfuturesCore) HandleSubject(client interface{}, message interface{})  {
    //
    //    {
    //        "type": "message",
    //        "topic": "/contractMarket/level2:ADAUSDTM",
    //        "subject": "level2",
    //        "data": {
    //            "sequence": 1668059586457,
    //            "change": "0.34172,sell,456", // type, side, quantity
    //            "timestamp": 1668573023223
    //        }
    //    }
    //
    var subject interface{} = this.SafeString(message, "subject")
    var methods interface{} = map[string]interface{} {
        "level2": this.HandleOrderBook,
        "ticker": this.HandleTicker,
        "candle.stick": this.HandleOHLCV,
        "tickerV2": this.HandleBidAsk,
        "availableBalance.change": this.HandleBalance,
        "match": this.HandleTrade,
        "orderChange": this.HandleOrder,
        "orderUpdated": this.HandleOrder,
        "position.change": this.HandlePosition,
        "position.settlement": this.HandlePosition,
        "position.adjustRiskLimit": this.HandlePosition,
    }
    var method interface{} = this.SafeValue(methods, subject)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *KucoinfuturesCore) GetMessageHash(elementName interface{}, optionalArgs ...interface{}) interface{}  {
    // elementName can be 'ticker', 'bidask', ...
    symbol := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbol
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        return ccxt.Add(ccxt.Add(elementName, "@"), symbol)
    } else {
        return ccxt.Add(elementName, "s@all")
    }
}
func  (this *KucoinfuturesCore) Ping(client interface{}) interface{}  {
    // kucoin does not support built-in ws protocol-level ping-pong
    // instead it requires a custom json-based text ping-pong
    // https://docs.kucoin.com/#ping
    var id interface{} = ccxt.ToString(this.RequestId())
    return map[string]interface{} {
        "id": id,
        "type": "ping",
    }
}
func  (this *KucoinfuturesCore) HandlePong(client interface{}, message interface{}) interface{}  {
    // https://docs.kucoin.com/#ping
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *KucoinfuturesCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "id": "64d8732c856851144bded10d",
    //        "type": "error",
    //        "code": 401,
    //        "data": "token is expired"
    //    }
    //
    var data interface{} = this.SafeString(message, "data", "")
    if ccxt.IsTrue(ccxt.IsEqual(data, "token is expired")) {
        var typeVar interface{} = "public"
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "connectId=private"), 0)) {
            typeVar = "private"
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "urls"), typeVar, nil)
    }
    this.HandleErrors(1, "", client.(ccxt.ClientInterface).GetUrl(), "", map[string]interface{} {}, data, message, map[string]interface{} {}, map[string]interface{} {})
    return true
}
func  (this *KucoinfuturesCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "id": "1578090438322",
    //         "type": "ack"
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id))) {
        return
    }
    var subscriptionHash interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var method interface{} = this.SafeValue(subscription, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message, subscription)
    }
    var isUnSub interface{} = this.SafeBool(subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSub) {
        var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
        var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
            var messageHash interface{} = ccxt.GetValue(messageHashes, i)
            var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
            this.CleanUnsubscription(client.(*ccxt.Client), subHash, messageHash)
        }
        this.CleanCache(subscription)
    }
}
func  (this *KucoinfuturesCore) HandleMessage(client interface{}, message interface{})  {
    var typeVar interface{} = this.SafeString(message, "type")
    var methods interface{} = map[string]interface{} {
        "welcome": this.HandleSystemStatus,
        "message": this.HandleSubject,
        "pong": this.HandlePong,
        "error": this.HandleErrorMessage,
        "ack": this.HandleSubscriptionStatus,
    }
    var method interface{} = this.SafeValue(methods, typeVar)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *KucoinfuturesCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
