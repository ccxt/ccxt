package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DefxCore struct {
	*ccxt.DefxCore
	base *ccxt.DefxCore
}

func NewDefxCore() *DefxCore {
    p := &DefxCore{}
	base := &ccxt.DefxCore{}
	p.base = base
	p.DefxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *DefxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTrades": false,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://stream.testnet.defx.com/pricefeed",
                    "private": "wss://ws.testnet.defx.com/user",
                },
            },
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://marketfeed.api.defx.com/pricefeed",
                    "private": "wss://userfeed.api.defx.com/user",
                },
            },
        },
        "options": map[string]interface{} {
            "listenKeyRefreshRate": 3540000,
            "ws": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "1h",
                    "2h": "2h",
                    "4h": "4h",
                    "12h": "12h",
                    "1d": "1d",
                    "1w": "1w",
                    "1M": "1M",
                },
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *DefxCore) WatchPublic(topics interface{}, messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes698)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "topics": topics,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes7615 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes7615)
                ch <- retRes7615
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) UnWatchPublic(topics interface{}, messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes808)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "topics": topics,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes8715 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes8715)
                ch <- retRes8715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DefxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DefxCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes11815 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes11815)
                ch <- retRes11815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DefxCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
        
            retRes1378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1378)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(ccxt.Add("symbol:", ccxt.GetValue(market, "id")), ":ohlc:"), interval))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("candles:", interval), ":"), ccxt.GetValue(market, "symbol")))
            }
            symboltimeframecandlesVariable := (<-this.WatchPublic(topics, messageHashes, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DefxCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
        
            retRes1718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1718)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(ccxt.Add("symbol:", ccxt.GetValue(market, "id")), ":ohlc:"), interval))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("candles:", interval), ":"), ccxt.GetValue(market, "symbol")))
            }
        
                retRes18315 :=  (<-this.UnWatchPublic(topics, messageHashes, params))
                ccxt.PanicOnError(retRes18315)
                ch <- retRes18315
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // {
    //     "topic": "symbol:BTC_USDC:ohlc:3m",
    //     "event": "ohlc",
    //     "timestamp": 1730794277104,
    //     "data": {
    //         "symbol": "BTC_USDC",
    //         "window": "3m",
    //         "open": "57486.90000000",
    //         "high": "57486.90000000",
    //         "low": "57486.90000000",
    //         "close": "57486.90000000",
    //         "volume": "0.000",
    //         "quoteAssetVolume": "0.00000000",
    //         "takerBuyAssetVolume": "0.000",
    //         "takerBuyQuoteAssetVolume": "0.00000000",
    //         "numberOfTrades": 0,
    //         "start": 1730794140000,
    //         "end": 1730794320000,
    //         "isClosed": false
    //     }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timeframe interface{} = this.SafeString(data, "window")
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored := ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcv interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseOHLCV(data)
    ohlcv.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
    client.(ccxt.ClientInterface).Resolve([]interface{}{symbol, timeframe, ohlcv}, messageHash)
}
/**
 * @method
 * @name defx#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2408)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.Add("symbol:", ccxt.GetValue(market, "id")), ":24hrTicker")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
        
                retRes24515 :=  (<-this.WatchPublic([]interface{}{topic}, []interface{}{messageHash}, params))
                ccxt.PanicOnError(retRes24515)
                ch <- retRes24515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes25915 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes25915)
                ch <- retRes25915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2728)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":24hrTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
            }
        
            retRes2828 := (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(retRes2828)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2968)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":24hrTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
            }
        
                retRes30615 :=  (<-this.UnWatchPublic(topics, messageHashes, params))
                ccxt.PanicOnError(retRes30615)
                ch <- retRes30615
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleTicker(client interface{}, message interface{})  {
    //
    // {
    //     "topic": "symbol:BTC_USDC:24hrTicker",
    //     "event": "24hrTicker",
    //     "timestamp": 1730862543095,
    //     "data": {
    //         "symbol": "BTC_USDC",
    //         "priceChange": "17114.70000000",
    //         "priceChangePercent": "29.77",
    //         "weightedAvgPrice": "6853147668",
    //         "lastPrice": "74378.90000000",
    //         "lastQty": "0.107",
    //         "bestBidPrice": "61987.60000000",
    //         "bestBidQty": "0.005",
    //         "bestAskPrice": "84221.60000000",
    //         "bestAskQty": "0.015",
    //         "openPrice": "57486.90000000",
    //         "highPrice": "88942.60000000",
    //         "lowPrice": "47364.20000000",
    //         "volume": "28.980",
    //         "quoteVolume": "1986042.19424035",
    //         "openTime": 1730776080000,
    //         "closeTime": 1730862540000,
    //         "openInterestBase": "67.130",
    //         "openInterestQuote": "5008005.40800000"
    //     }
    // }
    //
    this.HandleBidAsk(client, message)
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var parsedTicker interface{} = this.ParseTicker(data)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(parsedTicker, "timestamp", timestamp)
    ccxt.AddElementToObject(parsedTicker, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
/**
 * @method
 * @name defx#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3608 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3608)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":24hrTicker"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", symbol))
            }
        
            retRes3708 := (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(retRes3708)
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleBidAsk(client interface{}, message interface{})  {
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var parsedTicker interface{} = this.ParseWsBidAsk(data)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(parsedTicker, "timestamp", timestamp)
    ccxt.AddElementToObject(parsedTicker, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *DefxCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "ask": this.SafeString(ticker, "bestAskPrice"),
        "askVolume": this.SafeString(ticker, "bestAskQty"),
        "bid": this.SafeString(ticker, "bestBidPrice"),
        "bidVolume": this.SafeString(ticker, "bestBidQty"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name defx#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes41415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes41415)
                ch <- retRes41415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchTrades
 * @description unWatches from the stream channel
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *DefxCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes42715 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes42715)
                ch <- retRes42715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchTradesForSymbols
 * @description watches information on multiple trades made in a market
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *DefxCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4428)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":trades"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", symbol))
            }
        
            trades:= (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchTradesForSymbols
 * @description unWatches from the stream channel
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *DefxCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4758)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchTradesForSymbols() requires a non-empty array of symbols")))
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":trades"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", symbol))
            }
        
                retRes48915 :=  (<-this.UnWatchPublic(topics, messageHashes, params))
                ccxt.PanicOnError(retRes48915)
                ch <- retRes48915
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     "topic": "symbol:SOL_USDC:trades",
    //     "event": "trades",
    //     "timestamp": 1730967426331,
    //     "data": {
    //         "buyerMaker": true,
    //         "price": "188.38700000",
    //         "qty": "1.00",
    //         "symbol": "SOL_USDC",
    //         "timestamp": 1730967426328
    //     }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var parsedTrade interface{} = this.ParseTrade(data)
    var symbol interface{} = ccxt.GetValue(parsedTrade, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var stored interface{} = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var trades interface{} = ccxt.GetValue(this.Trades, symbol)
    trades.(ccxt.Appender).Append(parsedTrade)
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name defx#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *DefxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes53215 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes53215)
                ch <- retRes53215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *DefxCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes54515 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes54515)
                ch <- retRes54515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *DefxCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5598)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":depth:20:0.001"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
            }
        
            orderbook:= (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name defx#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.postman.com/defxcode/defx-public-apis/collection/667939a1b5d8069c13d614e9
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *DefxCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5878)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add("symbol:", marketId), ":depth:20:0.001"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
            }
        
                retRes60115 :=  (<-this.UnWatchPublic(topics, messageHashes, params))
                ccxt.PanicOnError(retRes60115)
                ch <- retRes60115
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // {
    //     "topic": "symbol:SOL_USDC:depth:20:0.01",
    //     "event": "depth",
    //     "timestamp": 1731030695319,
    //     "data": {
    //         "symbol": "SOL_USDC",
    //         "timestamp": 1731030695319,
    //         "lastTradeTimestamp": 1731030275258,
    //         "level": "20",
    //         "slab": "0.01",
    //         "bids": [
    //             {
    //                 "price": "198.27000000",
    //                 "qty": "1.52"
    //             }
    //         ],
    //         "asks": [
    //             {
    //                 "price": "198.44000000",
    //                 "qty": "6.61"
    //             }
    //         ]
    //     }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "qty")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook(snapshot)
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *DefxCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var listenKey interface{} = this.SafeString(this.Options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            
                {
                     func(this *DefxCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *DefxCore) interface{} {
                                    // catch block:
                                            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "?listenKey="), listenKey)
                    var client interface{} = this.Client(url)
                    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
                        var messageHash interface{} = ccxt.GetValue(messageHashes, j)
                        client.(ccxt.ClientInterface).Reject(error, messageHash)
                    }
                    ccxt.AddElementToObject(this.Options, "listenKey", nil)
                    ccxt.AddElementToObject(this.Options, "lastAuthenticatedTime", 0)
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes65412 := (<-this.V1PrivatePutApiUsersSocketListenKeysListenKey(map[string]interface{} {
                        "listenKey": listenKey,
                    }))
                    ccxt.PanicOnError(retRes65412) // extend the expiry
            		    return nil
            	    }(this)
                
                    }
            // whether or not to schedule another listenKey keepAlive request
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 3540000)
            this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
                return nil
            }()
            return ch
        }
func  (this *DefxCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var time interface{} = this.Milliseconds()
            var lastAuthenticatedTime interface{} = this.SafeInteger(this.Options, "lastAuthenticatedTime", 0)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 3540000) // 1 hour
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), listenKeyRefreshRate)) {
        
                response:= (<-this.V1PrivatePostApiUsersSocketListenKeys())
                ccxt.PanicOnError(response)
                ccxt.AddElementToObject(this.Options, "listenKey", this.SafeString(response, "listenKey"))
                ccxt.AddElementToObject(this.Options, "lastAuthenticatedTime", time)
                this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name defx#watchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.postman.com/defxcode/defx-public-apis/ws-raw-request/667939b2f00f79161bb47809
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *DefxCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6938)
        
            retRes6948 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6948)
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var messageHash interface{} = "WALLET_BALANCE_UPDATE"
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
        
                retRes69815 :=  (<-this.Watch(url, messageHash, nil, messageHash))
                ccxt.PanicOnError(retRes69815)
                ch <- retRes69815
                return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleBalance(client interface{}, message interface{})  {
    //
    // {
    //     "event": "WALLET_BALANCE_UPDATE",
    //     "timestamp": 1711015961397,
    //     "data": {
    //         "asset": "USDC", "balance": "27.64712963"
    //     }
    // }
    //
    var messageHash interface{} = this.SafeString(message, "event")
    var data interface{} = this.SafeDict(message, "data", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    if ccxt.IsTrue(ccxt.IsEqual(this.Balance, nil)) {
        this.Balance = map[string]interface{} {}
    }
    ccxt.AddElementToObject(this.Balance, "info", data)
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    var currencyId interface{} = this.SafeString(data, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
    ccxt.AddElementToObject(account, "free", this.SafeString(data, "balance"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name defx#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.postman.com/defxcode/defx-public-apis/ws-raw-request/667939b2f00f79161bb47809
 * @param {string} [symbol] unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *DefxCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7418)
        
            retRes7428 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7428)
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "symbol")))
            }
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
        
            orders:= (<-this.Watch(url, messageHash, nil, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandleOrder(client interface{}, message interface{})  {
    //
    // {
    //     "event": "ORDER_UPDATE",
    //     "timestamp": 1731417961446,
    //     "data": {
    //         "orderId": "766738557656630928",
    //         "symbol": "SOL_USDC",
    //         "side": "SELL",
    //         "type": "MARKET",
    //         "status": "FILLED",
    //         "clientOrderId": "0193208d-717b-7811-a80e-c036e220ad9b",
    //         "reduceOnly": false,
    //         "postOnly": false,
    //         "timeInForce": "GTC",
    //         "isTriggered": false,
    //         "createdAt": "2024-11-12T13:26:00.829Z",
    //         "updatedAt": "2024-11-12T13:26:01.436Z",
    //         "avgPrice": "209.60000000",
    //         "cumulativeQuote": "104.80000000",
    //         "totalFee": "0.05764000",
    //         "executedQty": "0.50",
    //         "origQty": "0.50",
    //         "role": "TAKER",
    //         "pnl": "0.00000000",
    //         "lastFillPnL": "0.00000000",
    //         "lastFillPrice": "209.60000000",
    //         "lastFillQty": "0.50",
    //         "linkedOrderParentType": null,
    //         "workingType": null
    //     }
    // }
    //
    var channel interface{} = "orders"
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var parsedOrder interface{} = this.ParseOrder(data)
    orders.(ccxt.Appender).Append(parsedOrder)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(parsedOrder, "symbol"))
    client.(ccxt.ClientInterface).Resolve(orders, channel)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
/**
 * @method
 * @name defx#watchPositions
 * @description watch all open positions
 * @see https://www.postman.com/defxcode/defx-public-apis/ws-raw-request/667939b2f00f79161bb47809
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {number} [since] since timestamp
 * @param {number} [limit] limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *DefxCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8168)
        
            retRes8178 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8178)
            symbols = this.MarketSymbols(symbols)
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var channel interface{} = "positions"
            var url interface{} = ccxt.Add(ccxt.Add(baseUrl, "?listenKey="), ccxt.GetValue(this.Options, "listenKey"))
            var newPosition interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var messageHashes interface{} = []interface{}{}
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), symbol))
                }
                
            newPosition = (<-this.WatchMultiple(url, messageHashes, nil, messageHashes))
                    ccxt.PanicOnError(newPosition)
            } else {
                
            newPosition = (<-this.Watch(url, channel, nil, channel))
                    ccxt.PanicOnError(newPosition)
            }
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPosition
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DefxCore) HandlePositions(client interface{}, message interface{})  {
    //
    // {
    //     "event": "POSITION_UPDATE",
    //     "timestamp": 1731417961456,
    //     "data": {
    //         "positionId": "0193208d-735d-7fe9-90bd-8bc6d6bc1eda",
    //         "createdAt": 1289847904328,
    //         "symbol": "SOL_USDC",
    //         "positionSide": "SHORT",
    //         "entryPrice": "209.60000000",
    //         "quantity": "0.50",
    //         "status": "ACTIVE",
    //         "marginAsset": "USDC",
    //         "marginAmount": "15.17475649",
    //         "realizedPnL": "0.00000000"
    //     }
    // }
    //
    var channel interface{} = "positions"
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolById()
    }
    var cache interface{} = this.Positions
    var parsedPosition interface{} = this.ParsePosition(data)
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(parsedPosition, "timestamp", timestamp)
    ccxt.AddElementToObject(parsedPosition, "datetime", this.Iso8601(timestamp))
    cache.(ccxt.Appender).Append(parsedPosition)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(parsedPosition, "symbol"))
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, channel)
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, messageHash)
}
func  (this *DefxCore) HandleMessage(client interface{}, message interface{})  {
    var error interface{} = this.SafeString(message, "code")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        var errorMsg interface{} = this.SafeString(message, "msg")
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), errorMsg)))
    }
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
        var methods interface{} = map[string]interface{} {
            "ohlc": this.HandleOHLCV,
            "24hrTicker": this.HandleTicker,
            "trades": this.HandleTrades,
            "depth": this.HandleOrderBook,
            "WALLET_BALANCE_UPDATE": this.HandleBalance,
            "ORDER_UPDATE": this.HandleOrder,
            "POSITION_UPDATE": this.HandlePositions,
        }
        var exacMethod interface{} = this.SafeValue(methods, event)
        if ccxt.IsTrue(!ccxt.IsEqual(exacMethod, nil)) {
            ccxt.CallDynamically(exacMethod, client, message)
        }
    }
}


func (this *DefxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
