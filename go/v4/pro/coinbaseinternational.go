package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoinbaseinternationalCore struct {
	*ccxt.CoinbaseinternationalCore
	base *ccxt.CoinbaseinternationalCore
}

func NewCoinbaseinternationalCore() *CoinbaseinternationalCore {
    p := &CoinbaseinternationalCore{}
	base := &ccxt.CoinbaseinternationalCore{}
	p.base = base
	p.CoinbaseinternationalCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoinbaseinternationalCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchTicker": true,
            "watchBalance": false,
            "watchMyTrades": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrders": false,
            "watchOrdersForSymbols": false,
            "watchPositions": false,
            "watchTickers": true,
            "createOrderWs": false,
            "editOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "fetchOrderWs": false,
            "fetchOrdersWs": false,
            "fetchBalanceWs": false,
            "fetchMyTradesWs": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws-md.international.coinbase.com",
            },
            "test": map[string]interface{} {
                "ws": "wss://ws-md.n5e2.coinbase.com",
            },
        },
        "options": map[string]interface{} {
            "watchTicker": map[string]interface{} {
                "channel": "LEVEL1",
            },
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "myTradesLimit": 1000,
            "timeframes": map[string]interface{} {
                "1m": "CANDLES_ONE_MINUTE",
                "5m": "CANDLES_FIVE_MINUTES",
                "30m": "CANDLES_THIRTY_MINUTES",
                "1h": "CANDLES_ONE_HOUR",
                "2h": "CANDLES_TWO_HOURS",
                "1d": "CANDLES_ONE_DAY",
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Unable to authenticate": ccxt.AuthenticationError,
            },
        },
    })
}
/**
 * @ignore
 * @method
 * @description subscribes to a websocket channel
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-overview#subscribe
 * @param {string} name the name of the channel
 * @param {string[]} [symbols] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseinternationalCore) Subscribe(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes828)
            this.CheckRequiredCredentials()
            var market interface{} = nil
            var messageHash interface{} = name
            var productIds interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.GetActiveSymbols()
            }
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 1)) {
                var parsedSymbols interface{} = this.MarketSymbols(symbols)
                var marketIds interface{} = this.MarketIds(parsedSymbols)
                productIds = marketIds
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsedSymbols)); i++ {
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, "::"), ccxt.GetValue(parsedSymbols, i)))
                }
            } else if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 1)) {
                market = this.Market(ccxt.GetValue(symbols, 0))
                messageHash = ccxt.Add(ccxt.Add(name, "::"), ccxt.GetValue(market, "symbol"))
                productIds = []interface{}{ccxt.GetValue(market, "id")}
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            if ccxt.IsTrue(ccxt.IsEqual(url, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " is not supported in sandbox environment")))
            }
            var timestamp interface{} = ccxt.ToString(this.Nonce())
            var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(timestamp, this.ApiKey), "CBINTLMD"), this.Password)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Base64ToBinary(this.Secret), ccxt.Sha256, "base64")
            var subscribe interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "channels": []interface{}{name},
                "time": timestamp,
                "key": this.ApiKey,
                "passphrase": this.Password,
                "signature": signature,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(productIds, nil)) {
                ccxt.AddElementToObject(subscribe, "product_ids", productIds)
            }
            if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 1)) {
        
                    retRes12519 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(subscribe, params), messageHashes))
                    ccxt.PanicOnError(retRes12519)
                    ch <- retRes12519
                    return nil
            }
        
                retRes12715 :=  (<-this.Watch(url, messageHash, this.Extend(subscribe, params), messageHash))
                ccxt.PanicOnError(retRes12715)
                ch <- retRes12715
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description subscribes to a websocket channel using watchMultiple
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-overview#subscribe
 * @param {string} name the name of the channel
 * @param {string|string[]} [symbols] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseinternationalCore) SubscribeMultiple(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1418)
            this.CheckRequiredCredentials()
            if ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.Symbols
            } else {
                symbols = this.MarketSymbols(symbols)
            }
            var messageHashes interface{} = []interface{}{}
            var productIds interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var marketId interface{} = this.MarketId(ccxt.GetValue(symbols, i))
                var symbol interface{} = this.Symbol(marketId)
                ccxt.AppendToArray(&productIds, marketId)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, "::"), symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            if ccxt.IsTrue(ccxt.IsEqual(url, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " is not supported in sandbox environment")))
            }
            var timestamp interface{} = this.NumberToString(this.Seconds())
            var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(timestamp, this.ApiKey), "CBINTLMD"), this.Password)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Base64ToBinary(this.Secret), ccxt.Sha256, "base64")
            var subscribe interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "time": timestamp,
                "product_ids": productIds,
                "channels": []interface{}{name},
                "key": this.ApiKey,
                "passphrase": this.Password,
                "signature": signature,
            }
        
                retRes17215 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(subscribe, params), messageHashes))
                ccxt.PanicOnError(retRes17215)
                ch <- retRes17215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchFundingRate
 * @description watch the current funding rate
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#funding-channel
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func  (this *CoinbaseinternationalCore) WatchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1858)
        
                retRes18615 :=  (<-this.Subscribe("RISK", []interface{}{symbol}, params))
                ccxt.PanicOnError(retRes18615)
                ch <- retRes18615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchFundingRates
 * @description watch the funding rate for multiple markets
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#funding-channel
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexe by market symbols
 */
func  (this *CoinbaseinternationalCore) WatchFundingRates(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1998)
        
            fundingRate:= (<-this.SubscribeMultiple("RISK", symbols, params))
            ccxt.PanicOnError(fundingRate)
            var symbol interface{} = this.SafeString(fundingRate, "symbol")
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, symbol, fundingRate)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.FundingRates, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#instruments-channel
 * @param {string} [symbol] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to watch, 'LEVEL1' or 'INSTRUMENTS', default is 'LEVEL1'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoinbaseinternationalCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2218)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTicker", "channel", "LEVEL1")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
                retRes22415 :=  (<-this.Subscribe(channel, []interface{}{symbol}, params))
                ccxt.PanicOnError(retRes22415)
                ch <- retRes22415
                return nil
        
            }()
            return ch
        }
func  (this *CoinbaseinternationalCore) GetActiveSymbols() interface{}  {
    var symbols interface{} = this.Symbols
    var output interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        var symbol interface{} = ccxt.GetValue(symbols, i)
        var market interface{} = ccxt.GetValue(this.Markets, symbol)
        if ccxt.IsTrue(ccxt.GetValue(market, "active")) {
            ccxt.AppendToArray(&output, symbol)
        }
    }
    return output
}
/**
 * @method
 * @name coinbaseinternational#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#instruments-channel
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to watch, 'LEVEL1' or 'INSTRUMENTS', default is 'INSTLEVEL1UMENTS'
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *CoinbaseinternationalCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2518)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "channel", "LEVEL1")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
            ticker:= (<-this.Subscribe(channel, symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseinternationalCore) HandleInstrument(client interface{}, message interface{})  {
    //
    //    {
    //        "sequence": 1,
    //        "product_id": "ETH-PERP",
    //        "instrument_type": "PERP",
    //        "base_asset_name": "ETH",
    //        "quote_asset_name": "USDC",
    //        "base_increment": "0.0001",
    //        "quote_increment": "0.01",
    //        "avg_daily_quantity": "43.0",
    //        "avg_daily_volume": "80245.2",
    //        "total_30_day_quantity":"1443.0",
    //        "total_30_day_volume":"3040449.0",
    //        "total_24_hour_quantity":"48.1",
    //        "total_24_hour_volume":"101348.3",
    //        "base_imf": "0.2",
    //        "min_quantity": "0.0001",
    //        "position_size_limit": "500",
    //        "funding_interval": "60000000000",
    //        "trading_state": "trading",
    //        "last_update_time": "2023-05-04T11:16:33.016Z",
    //        "time": "2023-05-10T14:58:47.000Z",
    //        "channel":"INSTRUMENTS",
    //        "type":"SNAPSHOT"
    //    }
    var ticker interface{} = this.ParseWsInstrument(message)
    var channel interface{} = this.SafeString(message, "channel")
    client.(ccxt.ClientInterface).Resolve(ticker, channel)
    client.(ccxt.ClientInterface).Resolve(ticker, ccxt.Add(ccxt.Add(channel, "::"), ccxt.GetValue(ticker, "symbol")))
}
func  (this *CoinbaseinternationalCore) ParseWsInstrument(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "sequence": 1,
    //        "product_id": "ETH-PERP",
    //        "instrument_type": "PERP",
    //        "base_asset_name": "ETH",
    //        "quote_asset_name": "USDC",
    //        "base_increment": "0.0001",
    //        "quote_increment": "0.01",
    //        "avg_daily_quantity": "43.0",
    //        "avg_daily_volume": "80245.2",
    //        "total_30_day_quantity":"1443.0",
    //        "total_30_day_volume":"3040449.0",
    //        "total_24_hour_quantity":"48.1",
    //        "total_24_hour_volume":"101348.3",
    //        "base_imf": "0.2",
    //        "min_quantity": "0.0001",
    //        "position_size_limit": "500",
    //        "funding_interval": "60000000000",
    //        "trading_state": "trading",
    //        "last_update_time": "2023-05-04T11:16:33.016Z",
    //        "time": "2023-05-10T14:58:47.000Z",
    //        "channel":"INSTRUMENTS",
    //        "type":"SNAPSHOT"
    //    }
    // instruments
    //   {
    //       sequence: 0,
    //       instrument_type: 'PERP',
    //       instrument_mode: 'standard',
    //       base_asset_name: 'BTC',
    //       quote_asset_name: 'USDC',
    //       base_increment: '0.0001',
    //       quote_increment: '0.1',
    //       avg_daily_quantity: '502.8845',
    //       avg_daily_volume: '3.1495242961566668E7',
    //       total30_day_quantity: '15086.535',
    //       total30_day_volume: '9.44857288847E8',
    //       total24_hour_quantity: '5.0',
    //       total24_hour_volume: '337016.5',
    //       base_imf: '0.1',
    //       min_quantity: '0.0001',
    //       position_size_limit: '800',
    //       funding_interval: '3600000000000',
    //       trading_state: 'trading',
    //       last_updated_time: '2024-07-30T15:00:00Z',
    //       default_initial_margin: '0.2',
    //       base_asset_multiplier: '1.0',
    //       channel: 'INSTRUMENTS',
    //       type: 'SNAPSHOT',
    //       time: '2024-07-30T15:26:56.766Z',
    //   }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "product_id")
    var datetime interface{} = this.SafeString(ticker, "time")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(marketId, market, "-"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "high": nil,
        "low": nil,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": nil,
        "last": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "total_24_hour_quantity", "total24_hour_quantity"),
        "quoteVolume": this.SafeString2(ticker, "total_24_hour_volume", "total24_hour_volume"),
    })
}
func  (this *CoinbaseinternationalCore) HandleTicker(client interface{}, message interface{})  {
    //
    // snapshot
    //    {
    //        "sequence": 0,
    //        "product_id": "BTC-PERP",
    //        "time": "2023-05-10T14:58:47.000Z",
    //        "bid_price": "28787.8",
    //        "bid_qty": "0.466", // One side book
    //        "channel": "LEVEL1",
    //        "type": "SNAPSHOT"
    //    }
    // update
    //    {
    //       "sequence": 1,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.547Z",
    //       "bid_price": "28787.8",
    //       "bid_qty": "0.466",
    //       "ask_price": "28788.8",
    //       "ask_qty": "1.566",
    //       "channel": "LEVEL1",
    //       "type": "UPDATE"
    //    }
    //
    var ticker interface{} = this.ParseWsTicker(message)
    var channel interface{} = this.SafeString(message, "channel")
    client.(ccxt.ClientInterface).Resolve(ticker, channel)
    client.(ccxt.ClientInterface).Resolve(ticker, ccxt.Add(ccxt.Add(channel, "::"), ccxt.GetValue(ticker, "symbol")))
}
func  (this *CoinbaseinternationalCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "sequence": 1,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.547Z",
    //       "bid_price": "28787.8",
    //       "bid_qty": "0.466",
    //       "ask_price": "28788.8",
    //       "ask_qty": "1.566",
    //       "channel": "LEVEL1",
    //       "type": "UPDATE"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(ticker, "time")
    var marketId interface{} = this.SafeString(ticker, "product_id")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "bid": this.SafeNumber(ticker, "bid_price"),
        "bidVolume": this.SafeNumber(ticker, "bid_qty"),
        "ask": this.SafeNumber(ticker, "ask_price"),
        "askVolume": this.SafeNumber(ticker, "ask_qty"),
        "high": nil,
        "low": nil,
        "open": nil,
        "close": nil,
        "last": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "vwap": nil,
        "baseVolume": nil,
        "quoteVolume": nil,
        "previousClose": nil,
    })
}
/**
 * @method
 * @name coinbaseinternational#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://docs.cdp.coinbase.com/intx/docs/websocket-channels#candles-channel
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *CoinbaseinternationalCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4598)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var options interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeString(options, timeframe, timeframe)
        
            ohlcv:= (<-this.Subscribe(interval, []interface{}{symbol}, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseinternationalCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // {
    //     "sequence": 0,
    //     "product_id": "BTC-PERP",
    //     "channel": "CANDLES_ONE_MINUTE",
    //     "type": "SNAPSHOT",
    //     "candles": [
    //       {
    //           "time": "2023-05-10T14:58:47.000Z",
    //           "low": "28787.8",
    //           "high": "28788.8",
    //           "open": "28788.8",
    //           "close": "28787.8",
    //           "volume": "0.466"
    //        },
    //     ]
    //  }
    //
    var messageHash interface{} = this.SafeString(message, "channel")
    var marketId interface{} = this.SafeString(message, "product_id")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timeframe interface{} = this.FindTimeframe(messageHash)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var data interface{} = this.SafeList(message, "candles", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var tick interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseOHLCV(tick, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
}
/**
 * @method
 * @name coinbaseinternational#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#match-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *CoinbaseinternationalCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes52215 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes52215)
                ch <- retRes52215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *CoinbaseinternationalCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5368)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
        
            trades:= (<-this.SubscribeMultiple("MATCH", symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseinternationalCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //       "sequence": 0,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.002Z",
    //       "match_id": "177101110052388865",
    //       "trade_qty": "0.006",
    //       "aggressor_side": "BUY",
    //       "trade_price": "28833.1",
    //       "channel": "MATCH",
    //       "type": "UPDATE"
    //    }
    //
    var trade interface{} = this.ParseWsTrade(message)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var channel interface{} = this.SafeString(message, "channel")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArrayCache := ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArrayCache)
    }
    var tradesArray interface{} = ccxt.GetValue(this.Trades, symbol)
    tradesArray.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, channel)
    client.(ccxt.ClientInterface).Resolve(tradesArray, ccxt.Add(ccxt.Add(channel, "::"), ccxt.GetValue(trade, "symbol")))
    return message
}
func  (this *CoinbaseinternationalCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "sequence": 0,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.002Z",
    //       "match_id": "177101110052388865",
    //       "trade_qty": "0.006",
    //       "aggressor_side": "BUY",
    //       "trade_price": "28833.1",
    //       "channel": "MATCH",
    //       "type": "UPDATE"
    //    }
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(trade, "symbol", "product_id")
    var datetime interface{} = this.SafeString(trade, "time")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "match_id"),
        "order": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": this.SafeSymbol(marketId, market),
        "type": nil,
        "side": this.SafeStringLower(trade, "agressor_side"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "trade_price"),
        "amount": this.SafeString(trade, "trade_qty"),
        "cost": nil,
        "fee": nil,
    })
}
/**
 * @method
 * @name coinbaseinternational#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#level2-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseinternationalCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes62015 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes62015)
                ch <- retRes62015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseinternational#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.cloud.coinbase.com/intx/docs/websocket-channels#level2-channel
 * @param {string[]} symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseinternationalCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6348)
        
                retRes63515 :=  (<-this.SubscribeMultiple("LEVEL2", symbols, params))
                ccxt.PanicOnError(retRes63515)
                ch <- retRes63515
                return nil
        
            }()
            return ch
        }
func  (this *CoinbaseinternationalCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // snapshot
    //    {
    //       "sequence": 0,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.000Z",
    //       "bids": [
    //           ["29100", "0.02"],
    //           ["28950", "0.01"],
    //           ["28900", "0.01"]
    //       ],
    //       "asks": [
    //           ["29267.8", "18"],
    //           ["29747.6", "18"],
    //           ["30227.4", "9"]
    //       ],
    //       "channel": "LEVEL2",
    //       "type": "SNAPSHOT",
    //    }
    // update
    //    {
    //       "sequence": 1,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.375Z",
    //       "changes": [
    //           [
    //               "BUY",
    //               "28787.7",
    //               "6"
    //           ]
    //       ],
    //       "channel": "LEVEL2",
    //       "type": "UPDATE"
    //    }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var marketId interface{} = this.SafeString(message, "product_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var datetime interface{} = this.SafeString(message, "time")
    var channel interface{} = this.SafeString(message, "channel")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "SNAPSHOT")) {
        var parsedSnapshot interface{} = this.ParseOrderBook(message, symbol, nil, "bids", "asks")
        orderbook.(ccxt.OrderBookInterface).Reset(parsedSnapshot)
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
    } else {
        var changes interface{} = this.SafeList(message, "changes", []interface{}{})
        this.HandleDeltas(orderbook, changes)
    }
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(message, "sequence"))
    ccxt.AddElementToObject(orderbook, "datetime", datetime)
    ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, ccxt.Add(ccxt.Add(channel, "::"), symbol))
}
func  (this *CoinbaseinternationalCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var rawSide interface{} = this.SafeStringLower(delta, 0)
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(rawSide, "buy"))), "bids", "asks")
    var price interface{} = this.SafeFloat(delta, 1)
    var amount interface{} = this.SafeFloat(delta, 2)
    var bookside interface{} = ccxt.GetValue(orderbook, side)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *CoinbaseinternationalCore) HandleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(orderbook, ccxt.GetValue(deltas, i))
    }
}
func  (this *CoinbaseinternationalCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //       "channels": [
    //           {
    //               "name": "MATCH",
    //               "product_ids": [
    //                   "BTC-PERP",
    //                   "ETH-PERP"
    //               ]
    //           },
    //           {
    //               "name": "INSTRUMENTS",
    //               "product_ids": [
    //                   "BTC-PERP",
    //                   "ETH-PERP"
    //               ]
    //           }
    //       ],
    //       "authenticated": true,
    //       "channel": "SUBSCRIPTIONS",
    //       "type": "SNAPSHOT",
    //       "time": "2023-05-30T16:53:46.847Z"
    //    }
    //
    return message
}
func  (this *CoinbaseinternationalCore) HandleFundingRate(client interface{}, message interface{})  {
    //
    // snapshot
    //    {
    //       "sequence": 0,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T14:58:47.000Z",
    //       "funding_rate": "0.001387",
    //       "is_final": true,
    //       "channel": "FUNDING",
    //       "type": "SNAPSHOT"
    //    }
    // update
    //    {
    //       "sequence": 1,
    //       "product_id": "BTC-PERP",
    //       "time": "2023-05-10T15:00:00.000Z",
    //       "funding_rate": "0.001487",
    //       "is_final": false,
    //       "channel": "FUNDING",
    //       "type": "UPDATE"
    //    }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var fundingRate interface{} = this.ParseFundingRate(message)
    ccxt.AddElementToObject(this.FundingRates, ccxt.GetValue(fundingRate, "symbol"), fundingRate)
    client.(ccxt.ClientInterface).Resolve(fundingRate, ccxt.Add(ccxt.Add(channel, "::"), ccxt.GetValue(fundingRate, "symbol")))
}
func  (this *CoinbaseinternationalCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        message: 'Failed to subscribe',
    //        reason: 'Unable to authenticate',
    //        channel: 'SUBSCRIPTIONS',
    //        type: 'REJECT'
    //    }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "REJECT")) {
        return false
    }
    var reason interface{} = this.SafeString(message, "reason")
    var errMsg interface{} = this.SafeString(message, "message")
    
        {
             func(this *CoinbaseinternationalCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *CoinbaseinternationalCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        var feedback interface{} = ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), errMsg), reason)
            this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), reason, feedback)
            this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), reason, feedback)
            panic(ccxt.ExchangeError(feedback))
    		    
    	    }(this)
        
            }
    return true
}
func  (this *CoinbaseinternationalCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var channel interface{} = this.SafeString(message, "channel", "")
    var methods interface{} = map[string]interface{} {
        "SUBSCRIPTIONS": this.HandleSubscriptionStatus,
        "INSTRUMENTS": this.HandleInstrument,
        "LEVEL1": this.HandleTicker,
        "MATCH": this.HandleTrade,
        "LEVEL2": this.HandleOrderBook,
        "FUNDING": this.HandleFundingRate,
        "RISK": this.HandleTicker,
    }
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "error")) {
        var errorMessage interface{} = this.SafeString(message, "message")
        panic(ccxt.ExchangeError(errorMessage))
    }
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "CANDLES"), ccxt.OpNeg(1))) {
        this.HandleOHLCV(client, message)
    }
    var method interface{} = this.SafeValue(methods, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *CoinbaseinternationalCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
