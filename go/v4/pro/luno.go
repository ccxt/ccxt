package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type LunoCore struct {
	*ccxt.LunoCore
	base *ccxt.LunoCore
}

func NewLunoCore() *LunoCore {
    p := &LunoCore{}
	base := &ccxt.LunoCore{}
	p.base = base
	p.LunoCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *LunoCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": false,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": false,
            "watchOrders": nil,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.luno.com/api/1",
            },
        },
        "options": map[string]interface{} {
            "sequenceNumbers": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name luno#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.luno.com/en/developers/api#tag/Streaming-API
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of    trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *LunoCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes518)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var subscriptionHash interface{} = ccxt.Add("/stream/", ccxt.GetValue(market, "id"))
            var subscription interface{} = map[string]interface{} {
                "symbol": symbol,
            }
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subscriptionHash)
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            var subscribe interface{} = map[string]interface{} {
                "api_key_id": this.ApiKey,
                "api_key_secret": this.Secret,
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            trades:= (<-this.Watch(url, messageHash, request, subscriptionHash, subscription))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *LunoCore) HandleTrades(client interface{}, message interface{}, subscription interface{})  {
    //
    //     {
    //         "sequence": "110980825",
    //         "trade_updates": [],
    //         "create_update": {
    //             "order_id": "BXHSYXAUMH8C2RW",
    //             "type": "ASK",
    //             "price": "24081.09000000",
    //             "volume": "0.07780000"
    //         },
    //         "delete_update": null,
    //         "status_update": null,
    //         "timestamp": 1660598775360
    //     }
    //
    var rawTrades interface{} = this.SafeValue(message, "trade_updates", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(rawTrades)
    if ccxt.IsTrue(ccxt.IsEqual(length, 0)) {
        return
    }
    var symbol interface{} = ccxt.GetValue(subscription, "symbol")
    var market interface{} = this.Market(symbol)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var rawTrade interface{} = ccxt.GetValue(rawTrades, i)
        var trade interface{} = this.ParseTrade(rawTrade, market)
        stored.(ccxt.Appender).Append(trade)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *LunoCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // watchTrades (public)
    //
    //     {
    //       "base": "69.00000000",
    //       "counter": "113.6499000000000000",
    //       "maker_order_id": "BXEEU4S2BWF5WRB",
    //       "taker_order_id": "BXKNCSF7JDHXY3H",
    //       "order_id": "BXEEU4S2BWF5WRB"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "symbol": ccxt.GetValue(market, "symbol"),
        "order": nil,
        "type": nil,
        "side": nil,
        "takerOrMaker": nil,
        "price": nil,
        "amount": this.SafeString(trade, "base"),
        "cost": this.SafeString(trade, "counter"),
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name luno#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {objectConstructor} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] accepts l2 or l3 for level 2 or level 3 order book
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *LunoCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes1518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1518)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var subscriptionHash interface{} = ccxt.Add("/stream/", ccxt.GetValue(market, "id"))
            var subscription interface{} = map[string]interface{} {
                "symbol": symbol,
            }
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), subscriptionHash)
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var subscribe interface{} = map[string]interface{} {
                "api_key_id": this.ApiKey,
                "api_key_secret": this.Secret,
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, subscriptionHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *LunoCore) HandleOrderBook(client interface{}, message interface{}, subscription interface{})  {
    //
    //     {
    //         "sequence": "24352",
    //         "asks": [{
    //             "id": "BXMC2CJ7HNB88U4",
    //             "price": "1234.00",
    //             "volume": "0.93"
    //         }],
    //         "bids": [{
    //             "id": "BXMC2CJ7HNB88U5",
    //             "price": "1201.00",
    //             "volume": "1.22"
    //         }],
    //         "status": "ACTIVE",
    //         "timestamp": 1528884331021
    //     }
    //
    //  update
    //     {
    //         "sequence": "110980825",
    //         "trade_updates": [],
    //         "create_update": {
    //             "order_id": "BXHSYXAUMH8C2RW",
    //             "type": "ASK",
    //             "price": "24081.09000000",
    //             "volume": "0.07780000"
    //         },
    //         "delete_update": null,
    //         "status_update": null,
    //         "timestamp": 1660598775360
    //     }
    //
    var symbol interface{} = ccxt.GetValue(subscription, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook(map[string]interface{} {}))
    }
    var asks interface{} = this.SafeValue(message, "asks")
    if ccxt.IsTrue(!ccxt.IsEqual(asks, nil)) {
        var snapshot interface{} = this.CustomParseOrderBook(message, symbol, timestamp, "bids", "asks", "price", "volume", "id")
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook(snapshot))
    } else {
        var ob interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        this.HandleDelta(ob, message)
        ccxt.AddElementToObject(ob, "timestamp", timestamp)
        ccxt.AddElementToObject(ob, "datetime", this.Iso8601(timestamp))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeInteger(message, "sequence")
    ccxt.AddElementToObject(orderbook, "nonce", nonce)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *LunoCore) CustomParseOrderBook(orderbook interface{}, symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := ccxt.GetArg(optionalArgs, 0, nil)
    _ = timestamp
    bidsKey := ccxt.GetArg(optionalArgs, 1, "bids")
    _ = bidsKey
    asksKey := ccxt.GetArg(optionalArgs, 2, "asks")
    _ = asksKey
    priceKey := ccxt.GetArg(optionalArgs, 3, "price")
    _ = priceKey
    amountKey := ccxt.GetArg(optionalArgs, 4, "volume")
    _ = amountKey
    countOrIdKey := ccxt.GetArg(optionalArgs, 5, 2)
    _ = countOrIdKey
    var bids interface{} = this.ParseBidsAsks(this.SafeValue(orderbook, bidsKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    var asks interface{} = this.ParseBidsAsks(this.SafeValue(orderbook, asksKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    return map[string]interface{} {
        "symbol": symbol,
        "bids": this.SortBy(bids, 0, true),
        "asks": this.SortBy(asks, 0),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "nonce": nil,
    }
}
func  (this *LunoCore) ParseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := ccxt.GetArg(optionalArgs, 0, "price")
    _ = priceKey
    amountKey := ccxt.GetArg(optionalArgs, 1, "volume")
    _ = amountKey
    thirdKey := ccxt.GetArg(optionalArgs, 2, 2)
    _ = thirdKey
    bidasks = this.ToArray(bidasks)
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidasks)); i++ {
        ccxt.AppendToArray(&result, this.CustomParseBidAsk(ccxt.GetValue(bidasks, i), priceKey, amountKey, thirdKey))
    }
    return result
}
func  (this *LunoCore) CustomParseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := ccxt.GetArg(optionalArgs, 0, "price")
    _ = priceKey
    amountKey := ccxt.GetArg(optionalArgs, 1, "volume")
    _ = amountKey
    thirdKey := ccxt.GetArg(optionalArgs, 2, 2)
    _ = thirdKey
    var price interface{} = this.SafeNumber(bidask, priceKey)
    var amount interface{} = this.SafeNumber(bidask, amountKey)
    var result interface{} = []interface{}{price, amount}
    if ccxt.IsTrue(!ccxt.IsEqual(thirdKey, nil)) {
        var thirdValue interface{} = this.SafeString(bidask, thirdKey)
        ccxt.AppendToArray(&result, thirdValue)
    }
    return result
}
func  (this *LunoCore) HandleDelta(orderbook interface{}, message interface{})  {
    //
    //  create
    //     {
    //         "sequence": "110980825",
    //         "trade_updates": [],
    //         "create_update": {
    //             "order_id": "BXHSYXAUMH8C2RW",
    //             "type": "ASK",
    //             "price": "24081.09000000",
    //             "volume": "0.07780000"
    //         },
    //         "delete_update": null,
    //         "status_update": null,
    //         "timestamp": 1660598775360
    //     }
    //  delete
    //     {
    //         "sequence": "110980825",
    //         "trade_updates": [],
    //         "create_update": null,
    //         "delete_update": {
    //             "order_id": "BXMC2CJ7HNB88U4"
    //         },
    //         "status_update": null,
    //         "timestamp": 1660598775360
    //     }
    //  trade
    //     {
    //         "sequence": "110980825",
    //         "trade_updates": [
    //             {
    //                 "base": "0.1",
    //                 "counter": "5232.00",
    //                 "maker_order_id": "BXMC2CJ7HNB88U4",
    //                 "taker_order_id": "BXMC2CJ7HNB88U5"
    //             }
    //         ],
    //         "create_update": null,
    //         "delete_update": null,
    //         "status_update": null,
    //         "timestamp": 1660598775360
    //     }
    //
    var createUpdate interface{} = this.SafeValue(message, "create_update")
    var asksOrderSide interface{} = ccxt.GetValue(orderbook, "asks")
    var bidsOrderSide interface{} = ccxt.GetValue(orderbook, "bids")
    if ccxt.IsTrue(!ccxt.IsEqual(createUpdate, nil)) {
        var bidAskArray interface{} = this.CustomParseBidAsk(createUpdate, "price", "volume", "order_id")
        var typeVar interface{} = this.SafeString(createUpdate, "type")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "ASK")) {
            asksOrderSide.(ccxt.IOrderBookSide).StoreArray(bidAskArray)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "BID")) {
            bidsOrderSide.(ccxt.IOrderBookSide).StoreArray(bidAskArray)
        }
    }
    var deleteUpdate interface{} = this.SafeValue(message, "delete_update")
    if ccxt.IsTrue(!ccxt.IsEqual(deleteUpdate, nil)) {
        var orderId interface{} = this.SafeString(deleteUpdate, "order_id")
        asksOrderSide.(ccxt.IOrderBookSide).StoreArray([]interface{}{0, 0, orderId})
        bidsOrderSide.(ccxt.IOrderBookSide).StoreArray([]interface{}{0, 0, orderId})
    }
}
func  (this *LunoCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(ccxt.IsEqual(message, "")) {
        return
    }
    var subscriptions interface{} = ccxt.ObjectValues(client.(ccxt.ClientInterface).GetSubscriptions())
    var handlers interface{} = []interface{}{this.HandleOrderBook, this.HandleTrades}
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(handlers)); j++ {
        var handler interface{} = ccxt.GetValue(handlers, j)
        ccxt.CallDynamically(handler, client, message, ccxt.GetValue(subscriptions, 0))
    }
}


func (this *LunoCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
