package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type GateCore struct {
	*ccxt.GateCore
	base *ccxt.GateCore
}

func NewGateCore() *GateCore {
    p := &GateCore{}
	base := &ccxt.GateCore{}
	p.base = base
	p.GateCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *GateCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelAllOrdersWs": true,
            "cancelOrderWs": true,
            "createMarketBuyOrderWithCostWs": true,
            "createMarketOrderWs": true,
            "createMarketOrderWithCostWs": false,
            "createMarketSellOrderWithCostWs": false,
            "createOrderWs": true,
            "createOrdersWs": true,
            "createPostOnlyOrderWs": true,
            "createReduceOnlyOrderWs": true,
            "createStopLimitOrderWs": true,
            "createStopLossOrderWs": true,
            "createStopMarketOrderWs": false,
            "createStopOrderWs": true,
            "createTakeProfitOrderWs": true,
            "createTriggerOrderWs": true,
            "editOrderWs": true,
            "fetchOrderWs": true,
            "fetchOrdersWs": false,
            "fetchOpenOrdersWs": true,
            "fetchClosedOrdersWs": true,
            "watchOrderBook": true,
            "watchBidsAsks": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchBalance": true,
            "watchOrders": true,
            "watchLiquidations": false,
            "watchLiquidationsForSymbols": false,
            "watchMyLiquidations": true,
            "watchMyLiquidationsForSymbols": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.gate.io/v4",
                "spot": "wss://api.gateio.ws/ws/v4/",
                "swap": map[string]interface{} {
                    "usdt": "wss://fx-ws.gateio.ws/v4/ws/usdt",
                    "btc": "wss://fx-ws.gateio.ws/v4/ws/btc",
                },
                "future": map[string]interface{} {
                    "usdt": "wss://fx-ws.gateio.ws/v4/ws/delivery/usdt",
                    "btc": "wss://fx-ws.gateio.ws/v4/ws/delivery/btc",
                },
                "option": map[string]interface{} {
                    "usdt": "wss://op-ws.gateio.live/v4/ws/usdt",
                    "btc": "wss://op-ws.gateio.live/v4/ws/btc",
                },
            },
            "test": map[string]interface{} {
                "swap": map[string]interface{} {
                    "usdt": "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",
                    "btc": "wss://fx-ws-testnet.gateio.ws/v4/ws/btc",
                },
                "future": map[string]interface{} {
                    "usdt": "wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",
                    "btc": "wss://fx-ws-testnet.gateio.ws/v4/ws/btc",
                },
                "option": map[string]interface{} {
                    "usdt": "wss://op-ws-testnet.gateio.live/v4/ws/usdt",
                    "btc": "wss://op-ws-testnet.gateio.live/v4/ws/btc",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "watchTradesSubscriptions": map[string]interface{} {},
            "watchTickerSubscriptions": map[string]interface{} {},
            "watchOrderBookSubscriptions": map[string]interface{} {},
            "watchTicker": map[string]interface{} {
                "name": "tickers",
            },
            "watchOrderBook": map[string]interface{} {
                "interval": "100ms",
                "snapshotDelay": 10,
                "snapshotMaxRetries": 3,
                "checksum": true,
            },
            "watchBalance": map[string]interface{} {
                "settle": "usdt",
                "spot": "spot.balances",
            },
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "1": ccxt.BadRequest,
                    "2": ccxt.BadRequest,
                    "4": ccxt.AuthenticationError,
                    "6": ccxt.AuthenticationError,
                    "11": ccxt.AuthenticationError,
                },
                "broad": map[string]interface{} {},
            },
        },
    })
}
/**
 * @method
 * @name gate#createOrderWs
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-place
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-place
 * @description Create an order on the exchange
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market' *"market" is contract only*
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] *ignored in "market" orders* the price at which the order is to be fulfilled at in units of the quote currency
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {float} [params.stopPrice] The price at which a trigger order is triggered at
 * @param {string} [params.timeInForce] "GTC", "IOC", or "PO"
 * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {int} [params.iceberg] Amount to display for the iceberg order, Null or 0 for normal orders, ccxt.Set to -1 to hide the order completely
 * @param {string} [params.text] User defined information
 * @param {string} [params.account] *spot and margin only* "spot", "margin" or "cross_margin"
 * @param {bool} [params.auto_borrow] *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
 * @param {string} [params.settle] *contract only* Unified ccxt.Currency Code for settle currency
 * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
 * @param {bool} [params.close] *contract only* ccxt.Set as true to close the position, with size set to 0
 * @param {bool} [params.auto_size] *contract only* ccxt.Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
 * @param {int} [params.price_type] *contract only* 0 latest deal price, 1 mark price, 2 index price
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @returns {object|undefined} [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1568)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_place")
            var url interface{} = this.GetUrlByMarket(market)
            ccxt.AddElementToObject(params, "textIsRequired", true)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
        
            retRes1648 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes1648)
        
            rawOrder:= (<-this.RequestPrivate(url, request, channel))
            ccxt.PanicOnError(rawOrder)
            var order interface{} = this.ParseOrder(rawOrder, market)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#createOrdersWs
 * @description create a list of trade orders
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-batch-place
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) CreateOrdersWs(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1808)
            var request interface{} = this.CreateOrdersRequest(orders, params)
            var firstOrder interface{} = ccxt.GetValue(orders, 0)
            var market interface{} = this.Market(ccxt.GetValue(firstOrder, "symbol"))
            if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(market, "swap"), true)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " createOrdersWs is not supported for swap markets")))
            }
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_batch_place")
            var url interface{} = this.GetUrlByMarket(market)
        
            retRes1908 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes1908)
        
            rawOrders:= (<-this.RequestPrivate(url, request, channel))
            ccxt.PanicOnError(rawOrders)
        
            ch <- this.ParseOrders(rawOrders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#cancelAllOrdersWs
 * @description cancel all open orders
 * @see https://www.gate.io/docs/developers/futures/ws/en/#cancel-all-open-orders-matched
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-cancel-all-with-specified-currency-pair
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to use, defaults to spot.order_cancel_cp or futures.order_cancel_cp
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2078)
            var market interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(symbol, nil))), nil, this.Market(symbol))
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_cancel_cp")
            channelparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrdersWs", "channel", channel)
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var url interface{} = this.GetUrlByMarket(market)
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            typeVarqueryVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            requestrequestParamsVariable := ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))), this.MultiOrderSpotPrepareRequest(market, trigger, query), this.PrepareRequest(market, typeVar, query))
            request := ccxt.GetValue(requestrequestParamsVariable,0)
            requestParams := ccxt.GetValue(requestrequestParamsVariable,1)
        
            retRes2178 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes2178)
        
            rawOrders:= (<-this.RequestPrivate(url, this.Extend(request, requestParams), channel))
            ccxt.PanicOnError(rawOrders)
        
            ch <- this.ParseOrders(rawOrders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#cancelOrderWs
 * @description Cancels an open order
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-cancel
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-cancel
 * @param {string} id ccxt.Order id
 * @param {string} symbol Unified market symbol
 * @param {object} [params] Parameters specified by the exchange api
 * @param {bool} [params.trigger] True if the order to be cancelled is a trigger order
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2358)
            var market interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(symbol, nil))), nil, this.Market(symbol))
            var trigger interface{} = this.SafeValueN(params, []interface{}{"is_stop_order", "stop", "trigger"}, false)
            params = this.Omit(params, []interface{}{"is_stop_order", "stop", "trigger"})
            typeVarqueryVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            requestrequestParamsVariable := ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) || ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")))), this.SpotOrderPrepareRequest(market, trigger, query), this.PrepareRequest(market, typeVar, query))
            request := ccxt.GetValue(requestrequestParamsVariable,0)
            requestParams := ccxt.GetValue(requestrequestParamsVariable,1)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_cancel")
            var url interface{} = this.GetUrlByMarket(market)
        
            retRes2448 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes2448)
            ccxt.AddElementToObject(request, "order_id", ccxt.ToString(id))
        
            res:= (<-this.RequestPrivate(url, this.Extend(request, requestParams), channel))
            ccxt.PanicOnError(res)
        
            ch <- this.ParseOrder(res, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#editOrderWs
 * @description edit a trade order, gate currently only supports the modification of the price or amount fields
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-amend
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-amend
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2668)
            var market interface{} = this.Market(symbol)
            var extendedRequest interface{} = this.EditOrderRequest(id, symbol, typeVar, side, amount, price, params)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_amend")
            var url interface{} = this.GetUrlByMarket(market)
        
            retRes2728 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes2728)
        
            rawOrder:= (<-this.RequestPrivate(url, extendedRequest, channel))
            ccxt.PanicOnError(rawOrder)
        
            ch <- this.ParseOrder(rawOrder, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#fetchOrderWs
 * @description Retrieves information on an order
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-status
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-status
 * @param {string} id ccxt.Order id
 * @param {string} symbol Unified market symbol, *required for spot and margin*
 * @param {object} [params] Parameters specified by the exchange api
 * @param {bool} [params.trigger] True if the order being fetched is a trigger order
 * @param {string} [params.marginMode] 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.type] 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
 * @param {string} [params.settle] 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) FetchOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2938)
            var market interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(symbol, nil))), nil, this.Market(symbol))
            requestrequestParamsVariable := this.FetchOrderRequest(id, symbol, params)
            request := ccxt.GetValue(requestrequestParamsVariable,0)
            requestParams := ccxt.GetValue(requestrequestParamsVariable,1)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_status")
            var url interface{} = this.GetUrlByMarket(market)
        
            retRes2998 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes2998)
        
            rawOrder:= (<-this.RequestPrivate(url, this.Extend(request, requestParams), channel))
            ccxt.PanicOnError(rawOrder)
        
            ch <- this.ParseOrder(rawOrder, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#fetchOpenOrdersWs
 * @description fetch all unfilled currently open orders
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes31615 :=  (<-this.FetchOrdersByStatusWs("open", symbol, since, limit, params))
                ccxt.PanicOnError(retRes31615)
                ch <- retRes31615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#fetchClosedOrdersWs
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {ccxt.Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) FetchClosedOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes33115 :=  (<-this.FetchOrdersByStatusWs("finished", symbol, since, limit, params))
                ccxt.PanicOnError(retRes33115)
                ch <- retRes33115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#fetchOrdersWs
 * @see https://www.gate.io/docs/developers/futures/ws/en/#order-list
 * @description fetches information on multiple orders made by the user by status
 * @param {string} status requested order status
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int|undefined} [since] the earliest time in ms to fetch orders for
 * @param {int|undefined} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.orderId] order id to begin at
 * @param {int} [params.limit] the maximum number of order structures to retrieve
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) FetchOrdersByStatusWs(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3498)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(market, "swap"), true)) {
                    panic(ccxt.NotSupported(ccxt.Add(this.Id, " fetchOrdersByStatusWs is only supported by swap markets. Use rest API for other markets")))
                }
            }
            requestrequestParamsVariable := this.PrepareOrdersByStatusRequest(status, symbol, since, limit, params)
            request := ccxt.GetValue(requestrequestParamsVariable,0)
            requestParams := ccxt.GetValue(requestrequestParamsVariable,1)
            var newRequest interface{} = this.Omit(request, []interface{}{"settle"})
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_list")
            var url interface{} = this.GetUrlByMarket(market)
        
            retRes3638 := (<-this.Authenticate(url, messageType))
            ccxt.PanicOnError(retRes3638)
        
            rawOrders:= (<-this.RequestPrivate(url, this.Extend(newRequest, requestParams), channel))
            ccxt.PanicOnError(rawOrders)
            var orders interface{} = this.ParseOrders(rawOrders, market)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.gate.com/docs/developers/apiv4/ws/en/#order-book-channel
 * @see https://www.gate.com/docs/developers/apiv4/ws/en/#order-book-v2-api
 * @see https://www.gate.com/docs/developers/futures/ws/en/#order-book-api
 * @see https://www.gate.com/docs/developers/futures/ws/en/#order-book-v2-api
 * @see https://www.gate.com/docs/developers/delivery/ws/en/#order-book-api
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *GateCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3848 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3848)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            intervalqueryVariable := this.HandleOptionAndParams(params, "watchOrderBook", "interval", "100ms")
            interval := ccxt.GetValue(intervalqueryVariable,0)
            query := ccxt.GetValue(intervalqueryVariable,1)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_book_update")
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
            var url interface{} = this.GetUrlByMarket(market)
            var payload interface{} = []interface{}{marketId, interval}
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 100 // max 100 atm
            }
            if ccxt.IsTrue(ccxt.GetValue(market, "contract")) {
                var stringLimit interface{} = ccxt.ToString(limit)
                ccxt.AppendToArray(&payload, stringLimit)
            }
            var subscription interface{} = map[string]interface{} {
                "symbol": symbol,
                "limit": limit,
            }
        
            orderbook:= (<-this.SubscribePublic(url, messageHash, payload, channel, query, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *GateCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4188)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            var interval interface{} = "100ms"
            intervalparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "interval", interval)
            interval = ccxt.GetValue(intervalparamsVariable,0)
            params = ccxt.GetValue(intervalparamsVariable,1)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".order_book_update")
            var subMessageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("unsubscribe:orderbook", ":"), symbol)
            var url interface{} = this.GetUrlByMarket(market)
            var payload interface{} = []interface{}{marketId, interval}
            var limit interface{} = this.SafeInteger(params, "limit", 100)
            if ccxt.IsTrue(ccxt.GetValue(market, "contract")) {
                var stringLimit interface{} = ccxt.ToString(limit)
                ccxt.AppendToArray(&payload, stringLimit)
            }
        
                retRes43515 :=  (<-this.UnSubscribePublicMultiple(url, "orderbook", []interface{}{symbol}, []interface{}{messageHash}, []interface{}{subMessageHash}, payload, channel, params))
                ccxt.PanicOnError(retRes43515)
                ch <- retRes43515
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var limit interface{} = this.SafeInteger(subscription, "limit")
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
}
func  (this *GateCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "time": 1650189272,
    //         "channel": "spot.order_book_update",
    //         "event": "update",
    //         "result": {
    //             "t": 1650189272515,
    //             "e": "depthUpdate",
    //             "E": 1650189272,
    //             "s": "GMT_USDT",
    //             "U": 140595902,
    //             "u": 140595902,
    //             "b": [
    //                 [ '2.51518', "228.119" ],
    //                 [ '2.50587', "1510.11" ],
    //                 [ '2.49944', "67.6" ],
    //             ],
    //             "a": [
    //                 [ '2.5182', "4.199" ],
    //                 [ "2.51926", "1874" ],
    //                 [ '2.53528', "96.529" ],
    //             ]
    //         }
    //     }
    //
    // swap
    //
    //     {
    //         "id": null,
    //         "time": 1650188898,
    //         "channel": "futures.order_book_update",
    //         "event": "update",
    //         "error": null,
    //         "result": {
    //             "t": 1650188898938,
    //             "s": "GMT_USDT",
    //             "U": 1577718307,
    //             "u": 1577719254,
    //             "b": [
    //                 { p: "2.5178", s: 0 },
    //                 { p: "2.5179", s: 0 },
    //                 { p: "2.518", s: 0 },
    //             ],
    //             "a": [
    //                 { p: "2.52", s: 0 },
    //                 { p: "2.5201", s: 0 },
    //                 { p: "2.5203", s: 0 },
    //             ]
    //         }
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var channelParts interface{} = ccxt.Split(channel, ".")
    var rawMarketType interface{} = this.SafeString(channelParts, 0)
    var isSpot interface{} = ccxt.IsEqual(rawMarketType, "spot")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
    var delta interface{} = this.SafeValue(message, "result")
    var deltaStart interface{} = this.SafeInteger(delta, "U")
    var deltaEnd interface{} = this.SafeInteger(delta, "u")
    var marketId interface{} = this.SafeString(delta, "s")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_", marketType)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var storedOrderBook interface{} = this.SafeValue(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    var nonce interface{} = this.SafeInteger(storedOrderBook, "nonce")
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        var cacheLength interface{} = 0
        if ccxt.IsTrue(!ccxt.IsEqual(storedOrderBook, nil)) {
            cacheLength = ccxt.GetArrayLength(storedOrderBook.(ccxt.OrderBookInterface).GetCache())
        }
        var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 10)
        var waitAmount interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), snapshotDelay, 0)
        if ccxt.IsTrue(ccxt.IsEqual(cacheLength, waitAmount)) {
            // max limit is 100
            var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            var limit interface{} = this.SafeInteger(subscription, "limit")
            this.Spawn(this.LoadOrderBook, client, messageHash, symbol, limit, map[string]interface{} {}) // needed for c#, number of args needs to match
        }
        ccxt.AppendToArray(storedOrderBook.(ccxt.OrderBookInterface).GetCache(), delta)
        return
    } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(nonce, deltaEnd)) {
        return
    } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(nonce, ccxt.Subtract(deltaStart, 1))) {
        this.HandleDelta(storedOrderBook, delta)
    } else {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        ccxt.Remove(this.Orderbooks, symbol)
        var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
        if ccxt.IsTrue(checksum) {
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            client.(ccxt.ClientInterface).Reject(error, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *GateCore) GetCacheIndex(orderBook interface{}, cache interface{}) interface{}  {
    var nonce interface{} = this.SafeInteger(orderBook, "nonce")
    var firstDelta interface{} = ccxt.GetValue(cache, 0)
    var firstDeltaStart interface{} = this.SafeInteger(firstDelta, "U")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, firstDeltaStart)) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaStart interface{} = this.SafeInteger(delta, "U")
        var deltaEnd interface{} = this.SafeInteger(delta, "u")
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(nonce, ccxt.Subtract(deltaStart, 1)))) && ccxt.IsTrue((ccxt.IsLessThan(nonce, deltaEnd)))) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
func  (this *GateCore) HandleBidAsks(bookSide interface{}, bidAsks interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidAsks)); i++ {
        var bidAsk interface{} = ccxt.GetValue(bidAsks, i)
        if ccxt.IsTrue(ccxt.IsArray(bidAsk)) {
            bookSide.(ccxt.IOrderBookSide).StoreArray(this.ParseBidAsk(bidAsk))
        } else {
            var price interface{} = this.SafeFloat(bidAsk, "p")
            var amount interface{} = this.SafeFloat(bidAsk, "s")
            bookSide.(ccxt.IOrderBookSide).Store(price, amount)
        }
    }
}
func  (this *GateCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var timestamp interface{} = this.SafeInteger(delta, "t")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(delta, "u"))
    var bids interface{} = this.SafeValue(delta, "b", []interface{}{})
    var asks interface{} = this.SafeValue(delta, "a", []interface{}{})
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    this.HandleBidAsks(storedBids, bids)
    this.HandleBidAsks(storedAsks, asks)
}
/**
 * @method
 * @name gate#watchTicker
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *GateCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5968)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchTicker")
        
            result:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(result)
        
            ch <- this.SafeValue(result, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#watchTickers
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#tickers-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *GateCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes61415 :=  (<-this.SubscribeWatchTickersAndBidsAsks(symbols, "watchTickers", this.Extend(map[string]interface{} {
                "method": "tickers",
            }, params)))
                ccxt.PanicOnError(retRes61415)
                ch <- retRes61415
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "time": 1649326221,
    //        "channel": "spot.tickers",
    //        "event": "update",
    //        "result": {
    //          "currency_pair": "BTC_USDT",
    //          "last": "43444.82",
    //          "lowest_ask": "43444.82",
    //          "highest_bid": "43444.81",
    //          "change_percentage": "-4.0036",
    //          "base_volume": "5182.5412425462",
    //          "quote_volume": "227267634.93123952",
    //          "high_24h": "47698",
    //          "low_24h": "42721.03"
    //        }
    //    }
    //
    this.HandleTickerAndBidAsk("ticker", client, message)
}
/**
 * @method
 * @name gate#watchBidsAsks
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#best-bid-or-ask-price
 * @see https://www.gate.io/docs/developers/apiv4/ws/en/#order-book-channel
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *GateCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes65015 :=  (<-this.SubscribeWatchTickersAndBidsAsks(symbols, "watchBidsAsks", this.Extend(map[string]interface{} {
                "method": "book_ticker",
            }, params)))
                ccxt.PanicOnError(retRes65015)
                ch <- retRes65015
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //    {
    //        "time": 1671363004,
    //        "time_ms": 1671363004235,
    //        "channel": "spot.book_ticker",
    //        "event": "update",
    //        "result": {
    //          "t": 1671363004228,
    //          "u": 9793320464,
    //          "s": "BTC_USDT",
    //          "b": "16716.8",
    //          "B": "0.0134",
    //          "a": "16716.9",
    //          "A": "0.0353"
    //        }
    //    }
    //
    this.HandleTickerAndBidAsk("bidask", client, message)
}
func  (this *GateCore) SubscribeWatchTickersAndBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            callerMethodName := ccxt.GetArg(optionalArgs, 1, nil)
            _ = callerMethodName
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6758)
            callerMethodNameparamsVariable := this.HandleParamString(params, "callerMethodName", callerMethodName)
            callerMethodName = ccxt.GetValue(callerMethodNameparamsVariable,0)
            params = ccxt.GetValue(callerMethodNameparamsVariable,1)
            symbols = this.MarketSymbols(symbols, nil, false)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var messageType interface{} = this.GetTypeByMarket(market)
            var marketIds interface{} = this.MarketIds(symbols)
            var channelName interface{} = nil
            channelNameparamsVariable := this.HandleOptionAndParams(params, callerMethodName, "method")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            var url interface{} = this.GetUrlByMarket(market)
            var channel interface{} = ccxt.Add(ccxt.Add(messageType, "."), channelName)
            var isWatchTickers interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(callerMethodName, "watchTicker"), 0)
            var prefix interface{} = ccxt.Ternary(ccxt.IsTrue(isWatchTickers), "ticker", "bidask")
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(prefix, ":"), symbol))
            }
        
            tickerOrBidAsk:= (<-this.SubscribePublicMultiple(url, messageHashes, marketIds, channel, params))
            ccxt.PanicOnError(tickerOrBidAsk)
            if ccxt.IsTrue(this.NewUpdates) {
                var items interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(items, ccxt.GetValue(tickerOrBidAsk, "symbol"), tickerOrBidAsk)
        
                ch <- items
                return nil
            }
            var result interface{} = ccxt.Ternary(ccxt.IsTrue(isWatchTickers), this.Tickers, this.Bidsasks)
        
            ch <- this.FilterByArray(result, "symbol", symbols, true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleTickerAndBidAsk(objectName interface{}, client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, ".")
    var rawMarketType interface{} = this.SafeString(parts, 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(rawMarketType, "futures"))), "contract", "spot")
    var result interface{} = this.SafeValue(message, "result")
    var results interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsArray(result)) {
        results = this.SafeList(message, "result", []interface{}{})
    } else {
        var rawTicker interface{} = this.SafeDict(message, "result", map[string]interface{} {})
        results = []interface{}{rawTicker}
    }
    var isTicker interface{} =     (ccxt.IsEqual(objectName, "ticker")) // whether ticker or bid-ask
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(results)); i++ {
        var rawTicker interface{} = ccxt.GetValue(results, i)
        var marketId interface{} = this.SafeString(rawTicker, "s")
        var market interface{} = this.SafeMarket(marketId, nil, "_", marketType)
        var parsedItem interface{} = this.ParseTicker(rawTicker, market)
        var symbol interface{} = ccxt.GetValue(parsedItem, "symbol")
        if ccxt.IsTrue(isTicker) {
            ccxt.AddElementToObject(this.Tickers, symbol, parsedItem)
        } else {
            ccxt.AddElementToObject(this.Bidsasks, symbol, parsedItem)
        }
        var messageHash interface{} = ccxt.Add(ccxt.Add(objectName, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(parsedItem, messageHash)
    }
}
/**
 * @method
 * @name gate#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GateCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes74315 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes74315)
                ch <- retRes74315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GateCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7578)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".trades")
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", symbol))
            }
            var url interface{} = this.GetUrlByMarket(market)
        
            trades:= (<-this.SubscribePublicMultiple(url, messageHashes, marketIds, channel, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#unWatchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GateCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7878)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = this.MarketIds(symbols)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".trades")
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("trades:", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trades:", symbol))
            }
            var url interface{} = this.GetUrlByMarket(market)
        
                retRes80115 :=  (<-this.UnSubscribePublicMultiple(url, "trades", symbols, messageHashes, subMessageHashes, marketIds, channel, params))
                ccxt.PanicOnError(retRes80115)
                ch <- retRes80115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#unWatchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GateCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes81315 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes81315)
                ch <- retRes81315
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     "time": 1648725035,
    //     "channel": "spot.trades",
    //     "event": "update",
    //     "result": [{
    //       "id": 3130257995,
    //       "create_time": 1648725035,
    //       "create_time_ms": "1648725035923.0",
    //       "side": "sell",
    //       "currency_pair": "LTC_USDT",
    //       "amount": "0.0116",
    //       "price": "130.11"
    //     }]
    // }
    //
    var result interface{} = this.SafeValue(message, "result")
    if !ccxt.IsTrue(ccxt.IsArray(result)) {
        result = []interface{}{result}
    }
    var parsedTrades interface{} = this.ParseTrades(result)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsedTrades)); i++ {
        var trade interface{} = ccxt.GetValue(parsedTrades, i)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        var cachedTrades interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(cachedTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            cachedTrades = ccxt.NewArrayCache(limit)
            ccxt.AddElementToObject(this.Trades, symbol, cachedTrades)
        }
        cachedTrades.(ccxt.Appender).Append(trade)
        var hash interface{} = ccxt.Add("trades:", symbol)
        client.(ccxt.ClientInterface).Resolve(cachedTrades, hash)
    }
}
/**
 * @method
 * @name gate#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *GateCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8658)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageType interface{} = this.GetTypeByMarket(market)
            var channel interface{} = ccxt.Add(messageType, ".candlesticks")
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", interval), ":"), ccxt.GetValue(market, "symbol"))
            var url interface{} = this.GetUrlByMarket(market)
            var payload interface{} = []interface{}{interval, marketId}
        
            ohlcv:= (<-this.SubscribePublic(url, messageHash, payload, channel, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // {
    //     "time": 1606292600,
    //     "channel": "spot.candlesticks",
    //     "event": "update",
    //     "result": {
    //       "t": "1606292580", // total volume
    //       "v": "2362.32035", // volume
    //       "c": "19128.1", // close
    //       "h": "19128.1", // high
    //       "l": "19128.1", // low
    //       "o": "19128.1", // open
    //       "n": "1m_BTC_USDT" // sub
    //     }
    //   }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var channelParts interface{} = ccxt.Split(channel, ".")
    var rawMarketType interface{} = this.SafeString(channelParts, 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(rawMarketType, "spot"))), "spot", "contract")
    var result interface{} = this.SafeValue(message, "result")
    if !ccxt.IsTrue(ccxt.IsArray(result)) {
        result = []interface{}{result}
    }
    var marketIds interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
        var ohlcv interface{} = ccxt.GetValue(result, i)
        var subscription interface{} = this.SafeString(ohlcv, "n", "")
        var parts interface{} = ccxt.Split(subscription, "_")
        var timeframe interface{} = this.SafeString(parts, 0)
        var timeframeId interface{} = this.FindTimeframe(timeframe)
        var prefix interface{} = ccxt.Add(timeframe, "_")
        var marketId interface{} = ccxt.Replace(subscription, prefix, "")
        var symbol interface{} = this.SafeSymbol(marketId, nil, "_", marketType)
        var parsed interface{} = this.ParseOHLCV(ohlcv)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframeId, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        ccxt.AddElementToObject(marketIds, symbol, timeframe)
    }
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var symbol interface{} = ccxt.GetValue(keys, i)
        var timeframe interface{} = ccxt.GetValue(marketIds, symbol)
        var interval interface{} = this.FindTimeframe(timeframe)
        var hash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("candles", ":"), interval), ":"), symbol)
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), interval)
        client.(ccxt.ClientInterface).Resolve(stored, hash)
    }
}
/**
 * @method
 * @name gate#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *GateCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9508)
            var subType interface{} = nil
            var typeVar interface{} = nil
            var marketId interface{} = ccxt.Add("!", "all")
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                marketId = ccxt.GetValue(market, "id")
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchMyTrades", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var messageType interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "spot": "spot",
                "margin": "spot",
                "future": "futures",
                "swap": "futures",
                "option": "options",
            })
            var channel interface{} = ccxt.Add(messageType, ".usertrades")
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var isInverse interface{} =     (ccxt.IsEqual(subType, "inverse"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isInverse)
            var payload interface{} = []interface{}{marketId}
            // uid required for non spot markets
            var requiresUid interface{} =     (!ccxt.IsEqual(typeVar, "spot"))
        
            trades:= (<-this.SubscribePrivate(url, messageHash, payload, channel, params, requiresUid))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // {
    //     "time": 1543205083,
    //     "channel": "futures.usertrades",
    //     "event": "update",
    //     "error": null,
    //     "result": [
    //       {
    //         "id": "3335259",
    //         "create_time": 1628736848,
    //         "create_time_ms": 1628736848321,
    //         "contract": "BTC_USD",
    //         "order_id": "4872460",
    //         "size": 1,
    //         "price": "40000.4",
    //         "role": "maker"
    //       }
    //     ]
    // }
    //
    var result interface{} = this.SafeValue(message, "result", []interface{}{})
    var tradesLength interface{} =     ccxt.GetArrayLength(result)
    if ccxt.IsTrue(ccxt.IsEqual(tradesLength, 0)) {
        return
    }
    var cachedTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(cachedTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        cachedTrades = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = cachedTrades
    }
    var parsed interface{} = this.ParseTrades(result)
    var marketIds interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        var trade interface{} = ccxt.GetValue(parsed, i)
        cachedTrades.(ccxt.Appender).Append(trade)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        ccxt.AddElementToObject(marketIds, symbol, true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var market interface{} = ccxt.GetValue(keys, i)
        var hash interface{} = ccxt.Add("myTrades:", market)
        client.(ccxt.ClientInterface).Resolve(cachedTrades, hash)
    }
    client.(ccxt.ClientInterface).Resolve(cachedTrades, "myTrades")
}
/**
 * @method
 * @name gate#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *GateCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10428)
            var typeVar interface{} = nil
            var subType interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchBalance", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isInverse interface{} =     (ccxt.IsEqual(subType, "inverse"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isInverse)
            var requiresUid interface{} =     (!ccxt.IsEqual(typeVar, "spot"))
            var channelType interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "spot": "spot",
                "margin": "spot",
                "future": "futures",
                "swap": "futures",
                "option": "options",
            })
            var channel interface{} = ccxt.Add(channelType, ".balances")
            var messageHash interface{} = ccxt.Add(typeVar, ".balance")
        
                retRes105915 :=  (<-this.SubscribePrivate(url, messageHash, nil, channel, params, requiresUid))
                ccxt.PanicOnError(retRes105915)
                ch <- retRes105915
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot order fill
    //   {
    //       "time": 1653664351,
    //       "channel": "spot.balances",
    //       "event": "update",
    //       "result": [
    //         {
    //           "timestamp": "1653664351",
    //           "timestamp_ms": "1653664351017",
    //           "user": "10406147",
    //           "currency": "LTC",
    //           "change": "-0.0002000000000000",
    //           "total": "0.09986000000000000000",
    //           "available": "0.09986000000000000000"
    //         }
    //       ]
    //   }
    //
    // account transfer
    //
    //    {
    //        "id": null,
    //        "time": 1653665088,
    //        "channel": "futures.balances",
    //        "event": "update",
    //        "error": null,
    //        "result": [
    //          {
    //            "balance": 25.035008537,
    //            "change": 25,
    //            "text": "-",
    //            "time": 1653665088,
    //            "time_ms": 1653665088286,
    //            "type": "dnw",
    //            "user": "10406147"
    //          }
    //        ]
    //   }
    //
    // swap order fill
    //   {
    //       "id": null,
    //       "time": 1653665311,
    //       "channel": "futures.balances",
    //       "event": "update",
    //       "error": null,
    //       "result": [
    //         {
    //           "balance": 20.031873037,
    //           "change": -0.0031355,
    //           "text": "LTC_USDT:165551103273",
    //           "time": 1653665311,
    //           "time_ms": 1653665311437,
    //           "type": "fee",
    //           "user": "10406147"
    //         }
    //       ]
    //   }
    //
    var result interface{} = this.SafeValue(message, "result", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "time_ms")
    ccxt.AddElementToObject(this.Balance, "info", result)
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
        var rawBalance interface{} = ccxt.GetValue(result, i)
        var account interface{} = this.Account()
        var currencyId interface{} = this.SafeString(rawBalance, "currency", "USDT") // when not present it is USDT
        var code interface{} = this.SafeCurrencyCode(currencyId)
        ccxt.AddElementToObject(account, "free", this.SafeString(rawBalance, "available"))
        ccxt.AddElementToObject(account, "total", this.SafeString2(rawBalance, "total", "balance"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    var channel interface{} = this.SafeString(message, "channel")
    var parts interface{} = ccxt.Split(channel, ".")
    var rawType interface{} = this.SafeString(parts, 0)
    var channelType interface{} = this.GetSupportedMapping(rawType, map[string]interface{} {
        "spot": "spot",
        "futures": "swap",
        "options": "option",
    })
    var messageHash interface{} = ccxt.Add(channelType, ".balance")
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name gate#watchPositions
 * @see https://www.gate.io/docs/developers/futures/ws/en/#positions-subscription
 * @see https://www.gate.io/docs/developers/delivery/ws/en/#positions-subscription
 * @see https://www.gate.io/docs/developers/options/ws/en/#positions-channel
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *GateCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11648 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11648)
            var market interface{} = nil
            symbols = this.MarketSymbols(symbols)
            var payload interface{} = []interface{}{ccxt.Add("!", "all")}
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                market = this.GetMarketFromSymbols(symbols)
            }
            var typeVar interface{} = nil
            var query interface{} = nil
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchPositions", market, params)
            typeVar = ccxt.GetValue(typeVarqueryVariable,0)
            query = ccxt.GetValue(typeVarqueryVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                typeVar = "swap"
            }
            var typeId interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "future": "futures",
                "swap": "futures",
                "option": "options",
            })
            var messageHash interface{} = ccxt.Add(typeVar, ":positions")
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var channel interface{} = ccxt.Add(typeId, ".positions")
            var subType interface{} = nil
            subTypequeryVariable := this.HandleSubTypeAndParams("watchPositions", market, query)
            subType = ccxt.GetValue(subTypequeryVariable,0)
            query = ccxt.GetValue(subTypequeryVariable,1)
            var isInverse interface{} =     (ccxt.IsEqual(subType, "inverse"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isInverse)
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client, typeVar, symbols)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            var cache interface{} = this.SafeValue(this.Positions, typeVar)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(cache, nil))) {
        
                    retRes119719 :=  (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchPositionsSnapshot")))
                    ccxt.PanicOnError(retRes119719)
                    ch <- retRes119719
                    return nil
            }
        
            positions:= (<-this.SubscribePrivate(url, messageHash, payload, channel, query, true))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(ccxt.GetValue(this.Positions, typeVar), symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if ccxt.IsTrue(ccxt.InOp(this.Positions, typeVar)) {
        return
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchPositionsSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash, typeVar)
        }
    } else {
        ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
    }
}
func  (this *GateCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}, typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions(nil, map[string]interface{} {
            "type": typeVar,
        }))
            ccxt.PanicOnError(positions)
            ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
            var cache interface{} = ccxt.GetValue(this.Positions, typeVar)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve(cache)
            client.(ccxt.ClientInterface).Resolve(cache, ccxt.Add(typeVar, ":position"))
                return nil
            }()
            return ch
        }
func  (this *GateCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        time: 1693158497,
    //        time_ms: 1693158497204,
    //        channel: 'futures.positions',
    //        event: 'update',
    //        result: [{
    //            contract: 'XRP_USDT',
    //            cross_leverage_limit: 0,
    //            entry_price: 0.5253,
    //            history_pnl: 0,
    //            history_point: 0,
    //            last_close_pnl: 0,
    //            leverage: 0,
    //            leverage_max: 50,
    //            liq_price: 0.0361,
    //            maintenance_rate: 0.01,
    //            margin: 4.89609962852,
    //            mode: 'single',
    //            realised_pnl: -0.0026265,
    //            realised_point: 0,
    //            risk_limit: 500000,
    //            size: 1,
    //            time: 1693158497,
    //            time_ms: 1693158497195,
    //            update_id: 1,
    //            user: '10444586'
    //        }]
    //    }
    //
    var typeVar interface{} = this.GetMarketTypeByUrl(client.(ccxt.ClientInterface).GetUrl())
    var data interface{} = this.SafeValue(message, "result", []interface{}{})
    var cache interface{} = ccxt.GetValue(this.Positions, typeVar)
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawPosition interface{} = ccxt.GetValue(data, i)
        var position interface{} = this.ParsePosition(rawPosition)
        var symbol interface{} = this.SafeString(position, "symbol")
        var side interface{} = this.SafeString(position, "side")
        // Control when position is closed no side is returned
        if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
            var prevLongPosition interface{} = this.SafeDict(cache, ccxt.Add(symbol, "long"))
            if ccxt.IsTrue(!ccxt.IsEqual(prevLongPosition, nil)) {
                ccxt.AddElementToObject(position, "side", ccxt.GetValue(prevLongPosition, "side"))
                ccxt.AppendToArray(&newPositions, position)
                cache.(ccxt.Appender).Append(position)
            }
            var prevShortPosition interface{} = this.SafeDict(cache, ccxt.Add(symbol, "short"))
            if ccxt.IsTrue(!ccxt.IsEqual(prevShortPosition, nil)) {
                ccxt.AddElementToObject(position, "side", ccxt.GetValue(prevShortPosition, "side"))
                ccxt.AppendToArray(&newPositions, position)
                cache.(ccxt.Appender).Append(position)
            }
            // if no prev position is found, default to long
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(prevLongPosition, nil)) && ccxt.IsTrue(ccxt.IsEqual(prevShortPosition, nil))) {
                ccxt.AddElementToObject(position, "side", "long")
                ccxt.AppendToArray(&newPositions, position)
                cache.(ccxt.Appender).Append(position)
            }
        } else {
            ccxt.AppendToArray(&newPositions, position)
            cache.(ccxt.Appender).Append(position)
        }
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(typeVar, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(typeVar, ":positions"))
}
/**
 * @method
 * @name gate#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] spot, margin, swap, future, or option. Required if listening to all symbols.
 * @param {boolean} [params.isInverse] if future, listen to inverse or linear contracts
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GateCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13348)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var typeVar interface{} = nil
            var query interface{} = nil
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarqueryVariable,0)
            query = ccxt.GetValue(typeVarqueryVariable,1)
            var typeId interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "spot": "spot",
                "margin": "spot",
                "future": "futures",
                "swap": "futures",
                "option": "options",
            })
            var channel interface{} = ccxt.Add(typeId, ".orders")
            var messageHash interface{} = "orders"
            var payload interface{} = []interface{}{ccxt.Add("!", "all")}
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
                payload = []interface{}{ccxt.GetValue(market, "id")}
            }
            var subType interface{} = nil
            subTypequeryVariable := this.HandleSubTypeAndParams("watchOrders", market, query)
            subType = ccxt.GetValue(subTypequeryVariable,0)
            query = ccxt.GetValue(subTypequeryVariable,1)
            var isInverse interface{} =     (ccxt.IsEqual(subType, "inverse"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isInverse)
            // uid required for non spot markets
            var requiresUid interface{} =     (!ccxt.IsEqual(typeVar, "spot"))
        
            orders:= (<-this.SubscribePrivate(url, messageHash, payload, channel, query, requiresUid))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleOrder(client interface{}, message interface{})  {
    //
    // {
    //     "time": 1605175506,
    //     "channel": "spot.orders",
    //     "event": "update",
    //     "result": [
    //       {
    //         "id": "30784435",
    //         "user": 123456,
    //         "text": "t-abc",
    //         "create_time": "1605175506",
    //         "create_time_ms": "1605175506123",
    //         "update_time": "1605175506",
    //         "update_time_ms": "1605175506123",
    //         "event": "put",
    //         "currency_pair": "BTC_USDT",
    //         "type": "limit",
    //         "account": "spot",
    //         "side": "sell",
    //         "amount": "1",
    //         "price": "10001",
    //         "time_in_force": "gtc",
    //         "left": "1",
    //         "filled_total": "0",
    //         "fee": "0",
    //         "fee_currency": "USDT",
    //         "point_fee": "0",
    //         "gt_fee": "0",
    //         "gt_discount": true,
    //         "rebated_fee": "0",
    //         "rebated_fee_currency": "USDT"
    //       }
    //     ]
    // }
    //
    var orders interface{} = this.SafeValue(message, "result", []interface{}{})
    var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.Orders
    var marketIds interface{} = map[string]interface{} {}
    var parsedOrders interface{} = this.ParseOrders(orders)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsedOrders)); i++ {
        var parsed interface{} = ccxt.GetValue(parsedOrders, i)
        // inject order status
        var info interface{} = this.SafeValue(parsed, "info")
        var event interface{} = this.SafeString(info, "event")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, "put")) || ccxt.IsTrue(ccxt.IsEqual(event, "update"))) {
            ccxt.AddElementToObject(parsed, "status", "open")
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "finish")) {
            var status interface{} = this.SafeString(parsed, "status")
            if ccxt.IsTrue(ccxt.IsEqual(status, nil)) {
                var left interface{} = this.SafeInteger(info, "left")
                ccxt.AddElementToObject(parsed, "status", ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(left, 0))), "closed", "canceled"))
            }
        }
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        var market interface{} = this.Market(symbol)
        ccxt.AddElementToObject(marketIds, ccxt.GetValue(market, "id"), true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var messageHash interface{} = ccxt.Add("orders:", ccxt.GetValue(keys, i))
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
}
/**
 * @method
 * @name gate#watchMyLiquidations
 * @description watch the public liquidations of a trading pair
 * @see https://www.gate.io/docs/developers/futures/ws/en/#liquidates-api
 * @see https://www.gate.io/docs/developers/delivery/ws/en/#liquidates-api
 * @see https://www.gate.io/docs/developers/options/ws/en/#liquidates-channel
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *GateCore) WatchMyLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            ch <- this.WatchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gate#watchMyLiquidationsForSymbols
 * @description watch the private liquidations of a trading pair
 * @see https://www.gate.io/docs/developers/futures/ws/en/#liquidates-api
 * @see https://www.gate.io/docs/developers/delivery/ws/en/#liquidates-api
 * @see https://www.gate.io/docs/developers/options/ws/en/#liquidates-channel
 * @param {string[]} symbols unified CCXT market symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the gate api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *GateCore) WatchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14728)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = nil
            var query interface{} = nil
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchMyLiquidationsForSymbols", market, params)
            typeVar = ccxt.GetValue(typeVarqueryVariable,0)
            query = ccxt.GetValue(typeVarqueryVariable,1)
            var typeId interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "future": "futures",
                "swap": "futures",
                "option": "options",
            })
            var subType interface{} = nil
            subTypequeryVariable := this.HandleSubTypeAndParams("watchMyLiquidationsForSymbols", market, query)
            subType = ccxt.GetValue(subTypequeryVariable,0)
            query = ccxt.GetValue(subTypequeryVariable,1)
            var isInverse interface{} =     (ccxt.IsEqual(subType, "inverse"))
            var url interface{} = this.GetUrlByMarketType(typeVar, isInverse)
            var payload interface{} = []interface{}{}
            var messageHash interface{} = ""
            if ccxt.IsTrue(this.IsEmpty(symbols)) {
                if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeId, "futures")) && !ccxt.IsTrue(isInverse)) {
                    panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchMyLiquidationsForSymbols() does not support listening to all symbols, you must call watchMyLiquidations() instead for each symbol you wish to watch.")))
                }
                messageHash = "myLiquidations"
                ccxt.AppendToArray(&payload, "!all")
            } else {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(!ccxt.IsEqual(symbolsLength, 1)) {
                    panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchMyLiquidationsForSymbols() only allows one symbol at a time. To listen to several symbols call watchMyLiquidationsForSymbols() several times.")))
                }
                messageHash = ccxt.Add("myLiquidations::", ccxt.GetValue(symbols, 0))
                ccxt.AppendToArray(&payload, ccxt.GetValue(market, "id"))
            }
            var channel interface{} = ccxt.Add(typeId, ".liquidates")
        
            newLiquidations:= (<-this.SubscribePrivate(url, messageHash, payload, channel, query, true))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    // future / delivery
    //     {
    //         "channel":"futures.liquidates",
    //         "event":"update",
    //         "time":1541505434,
    //         "time_ms":1541505434123,
    //         "result":[
    //            {
    //               "entry_price":209,
    //               "fill_price":215.1,
    //               "left":0,
    //               "leverage":0.0,
    //               "liq_price":213,
    //               "margin":0.007816722941,
    //               "mark_price":213,
    //               "order_id":4093362,
    //               "order_price":215.1,
    //               "size":-124,
    //               "time":1541486601,
    //               "time_ms":1541486601123,
    //               "contract":"BTC_USD",
    //               "user":"1040xxxx"
    //            }
    //         ]
    //     }
    // option
    //    {
    //        "channel":"options.liquidates",
    //        "event":"update",
    //        "time":1630654851,
    //        "result":[
    //           {
    //              "user":"1xxxx",
    //              "init_margin":1190,
    //              "maint_margin":1042.5,
    //              "order_margin":0,
    //              "time":1639051907,
    //              "time_ms":1639051907000
    //           }
    //        ]
    //    }
    //
    var rawLiquidations interface{} = this.SafeList(message, "result", []interface{}{})
    var newLiquidations interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawLiquidations)); i++ {
        var rawLiquidation interface{} = ccxt.GetValue(rawLiquidations, i)
        var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation)
        var symbol interface{} = this.SafeString(liquidation, "symbol")
        var liquidations interface{} = this.SafeValue(this.Liquidations, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "liquidationsLimit", 1000)
            liquidations = ccxt.NewArrayCache(limit)
        }
        liquidations.(ccxt.Appender).Append(liquidation)
        ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
        client.(ccxt.ClientInterface).Resolve(liquidations, ccxt.Add("myLiquidations::", symbol))
    }
    client.(ccxt.ClientInterface).Resolve(newLiquidations, "myLiquidations")
}
func  (this *GateCore) ParseWsLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // future / delivery
    //    {
    //        "entry_price": 209,
    //        "fill_price": 215.1,
    //        "left": 0,
    //        "leverage": 0.0,
    //        "liq_price": 213,
    //        "margin": 0.007816722941,
    //        "mark_price": 213,
    //        "order_id": 4093362,
    //        "order_price": 215.1,
    //        "size": -124,
    //        "time": 1541486601,
    //        "time_ms": 1541486601123,
    //        "contract": "BTC_USD",
    //        "user": "1040xxxx"
    //    }
    // option
    //    {
    //        "user": "1xxxx",
    //        "init_margin": 1190,
    //        "maint_margin": 1042.5,
    //        "order_margin": 0,
    //        "time": 1639051907,
    //        "time_ms": 1639051907000
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(liquidation, "contract")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(liquidation, "time_ms")
    var originalSize interface{} = this.SafeString(liquidation, "size")
    var left interface{} = this.SafeString(liquidation, "left")
    var amount interface{} = ccxt.Precise.StringAbs(ccxt.Precise.StringSub(originalSize, left))
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": this.ParseNumber(amount),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "price": this.SafeNumber(liquidation, "fill_price"),
        "baseValue": nil,
        "quoteValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
func  (this *GateCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "time": 1647274664,
    //        "channel": "futures.orders",
    //        "event": "subscribe",
    //        "error": { code: 2, message: "unknown contract BTC_USDT_20220318" },
    //    }
    //    {
    //      "time": 1647276473,
    //      "channel": "futures.orders",
    //      "event": "subscribe",
    //      "error": {
    //        "code": 4,
    //        "message": "{"label":"INVALID_KEY","message":"Invalid key provided"}\n"
    //      },
    //      "result": null
    //    }
    //    {
    //       header: {
    //         response_time: '1718551891329',
    //         status: '400',
    //         channel: 'spot.order_place',
    //         event: 'api',
    //         client_id: '81.34.68.6-0xc16375e2c0',
    //         conn_id: '9539116e0e09678f'
    //       },
    //       data: { errs: { label: 'AUTHENTICATION_FAILED', message: 'Not login' } },
    //       request_id: '10406147'
    //     }
    //     {
    //         "time": 1739853211,
    //         "time_ms": 1739853211201,
    //         "id": 1,
    //         "conn_id": "62f2c1dabbe186d7",
    //         "trace_id": "cdb02a8c0b61086b2fe6f8fad2f98c54",
    //         "channel": "spot.trades",
    //         "event": "subscribe",
    //         "payload": [
    //             "LUNARLENS_USDT",
    //             "ETH_USDT"
    //         ],
    //         "error": {
    //             "code": 2,
    //             "message": "unknown currency pair: LUNARLENS_USDT"
    //         },
    //         "result": {
    //             "status": "fail"
    //         },
    //         "requestId": "cdb02a8c0b61086b2fe6f8fad2f98c54"
    //     }
    //
    var data interface{} = this.SafeDict(message, "data")
    var errs interface{} = this.SafeDict(data, "errs")
    var error interface{} = this.SafeDict(message, "error", errs)
    var code interface{} = this.SafeString2(error, "code", "label")
    var id interface{} = this.SafeStringN(message, []interface{}{"id", "requestId", "request_id"})
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        var messageHash interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        
            {
                 func(this *GateCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *GateCore) interface{} {
                                // catch block:
                                            client.(ccxt.ClientInterface).Reject(e, messageHash)
                    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(messageHash, nil))) && ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)))) {
                        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    }
                    // remove subscriptions for watchSymbols
                    var channel interface{} = this.SafeString(message, "channel")
                    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(channel, nil))) && ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "."), 0)))) {
                        var parsedChannel interface{} = ccxt.Split(channel, ".")
                        var payload interface{} = this.SafeList(message, "payload", []interface{}{})
                        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(payload)); i++ {
                            var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(parsedChannel, 0), "futures")), "swap", ccxt.GetValue(parsedChannel, 0))
                            var symbol interface{} = this.SafeSymbol(ccxt.GetValue(payload, i), nil, "_", marketType)
                            var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(parsedChannel, 1), ":"), symbol)
                            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(messageHashSymbol, nil))) && ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHashSymbol)))) {
                                ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHashSymbol)
                            }
                        }
                    }
                                return nil
                            }(this)
                        }
                    }()
        		    // try block:
                                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), code, this.Json(message))
                    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, this.Json(errs))
                    var errorMessage interface{} = this.SafeString(error, "message", this.SafeString(errs, "message"))
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad"), errorMessage, this.Json(message))
                    panic(ccxt.ExchangeError(this.Json(message)))
        		    
        	    }(this)
            
                }
        if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(id, nil))) && ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)))) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        }
        return true
    }
    return false
}
func  (this *GateCore) HandleBalanceSubscription(client interface{}, message interface{}, optionalArgs ...interface{})  {
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    this.Balance = map[string]interface{} {}
}
func  (this *GateCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    var methods interface{} = map[string]interface{} {
        "balance": this.HandleBalanceSubscription,
        "spot.order_book_update": this.HandleOrderBookSubscription,
        "futures.order_book_update": this.HandleOrderBookSubscription,
    }
    var id interface{} = this.SafeString(message, "id")
    if ccxt.IsTrue(ccxt.InOp(methods, channel)) {
        var subscriptionHash interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), id)
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
        var method interface{} = ccxt.GetValue(methods, channel)
        ccxt.CallDynamically(method, client, message, subscription)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), id)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    }
}
func  (this *GateCore) HandleUnSubscribe(client interface{}, message interface{})  {
    //
    // {
    //     "time":1725534679,
    //     "time_ms":1725534679786,
    //     "id":2,
    //     "conn_id":"fac539b443fd7002",
    //     "trace_id":"efe1d282b630b4aa266b84bee177791a",
    //     "channel":"spot.trades",
    //     "event":"unsubscribe",
    //     "payload":[
    //        "LTC_USDT"
    //     ],
    //     "result":{
    //        "status":"success"
    //     },
    //     "requestId":"efe1d282b630b4aa266b84bee177791a"
    // }
    //
    var id interface{} = this.SafeString(message, "id")
    var keys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var messageHash interface{} = ccxt.GetValue(keys, i)
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
            continue
        }
        if ccxt.IsTrue(ccxt.StartsWith(messageHash, "unsubscribe")) {
            var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            var subId interface{} = this.SafeString(subscription, "id")
            if ccxt.IsTrue(!ccxt.IsEqual(id, subId)) {
                continue
            }
            var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
            var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
                var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
                var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
                this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
            }
            this.CleanCache(subscription)
        }
    }
}
func  (this *GateCore) CleanCache(subscription interface{})  {
    var topic interface{} = this.SafeString(subscription, "topic", "")
    var symbols interface{} = this.SafeList(subscription, "symbols", []interface{}{})
    var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
    if ccxt.IsTrue(ccxt.IsEqual(topic, "ohlcv")) {
        var symbolsAndTimeFrames interface{} = this.SafeList(subscription, "symbolsAndTimeframes", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeFrames)); i++ {
            var symbolAndTimeFrame interface{} = ccxt.GetValue(symbolsAndTimeFrames, i)
            var symbol interface{} = this.SafeString(symbolAndTimeFrame, 0)
            var timeframe interface{} = this.SafeString(symbolAndTimeFrame, 1)
            ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        }
    } else if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 0)) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
            var symbol interface{} = ccxt.GetValue(symbols, i)
            if ccxt.IsTrue(ccxt.EndsWith(topic, "trades")) {
                ccxt.Remove(this.Trades, symbol)
            } else if ccxt.IsTrue(ccxt.IsEqual(topic, "orderbook")) {
                ccxt.Remove(this.Orderbooks, symbol)
            } else if ccxt.IsTrue(ccxt.IsEqual(topic, "ticker")) {
                ccxt.Remove(this.Tickers, symbol)
            }
        }
    } else {
        if ccxt.IsTrue(ccxt.EndsWith(topic, "trades")) {
            // don't reset this.myTrades directly here
            // because in c# we need to use a different object
            var keys interface{} = ccxt.ObjectKeys(this.Trades)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
                ccxt.Remove(this.Trades, ccxt.GetValue(keys, i))
            }
        }
    }
}
func  (this *GateCore) HandleMessage(client interface{}, message interface{})  {
    //
    // subscribe
    //    {
    //        "time": 1649062304,
    //        "id": 1649062303,
    //        "channel": "spot.candlesticks",
    //        "event": "subscribe",
    //        "result": { status: "success" }
    //    }
    //
    // candlestick
    //    {
    //        "time": 1649063328,
    //        "channel": "spot.candlesticks",
    //        "event": "update",
    //        "result": {
    //          "t": "1649063280",
    //          "v": "58932.23174896",
    //          "c": "45966.47",
    //          "h": "45997.24",
    //          "l": "45966.47",
    //          "o": "45975.18",
    //          "n": "1m_BTC_USDT",
    //          "a": "1.281699"
    //        }
    //     }
    //
    //  orders
    //   {
    //       "time": 1630654851,
    //       "channel": "options.orders", or futures.orders or spot.orders
    //       "event": "update",
    //       "result": [
    //          {
    //             "contract": "BTC_USDT-20211130-65000-C",
    //             "create_time": 1637897000,
    //               (...)
    //       ]
    //   }
    // orderbook
    //   {
    //       "time": 1649770525,
    //       "channel": "spot.order_book_update",
    //       "event": "update",
    //       "result": {
    //         "t": 1649770525653,
    //         "e": "depthUpdate",
    //         "E": 1649770525,
    //         "s": "LTC_USDT",
    //         "U": 2622525645,
    //         "u": 2622525665,
    //         "b": [
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array]
    //         ],
    //         "a": [
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array], [Array],
    //           [Array]
    //         ]
    //       }
    //     }
    //
    // balance update
    //
    //    {
    //        "time": 1653664351,
    //        "channel": "spot.balances",
    //        "event": "update",
    //        "result": [
    //          {
    //            "timestamp": "1653664351",
    //            "timestamp_ms": "1653664351017",
    //            "user": "10406147",
    //            "currency": "LTC",
    //            "change": "-0.0002000000000000",
    //            "total": "0.09986000000000000000",
    //            "available": "0.09986000000000000000"
    //          }
    //        ]
    //    }
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribe")) {
        this.HandleSubscriptionStatus(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "unsubscribe")) {
        this.HandleUnSubscribe(client, message)
        return
    }
    var channel interface{} = this.SafeString(message, "channel", "")
    var channelParts interface{} = ccxt.Split(channel, ".")
    var channelType interface{} = this.SafeValue(channelParts, 1)
    var v4Methods interface{} = map[string]interface{} {
        "usertrades": this.HandleMyTrades,
        "candlesticks": this.HandleOHLCV,
        "orders": this.HandleOrder,
        "positions": this.HandlePositions,
        "tickers": this.HandleTicker,
        "book_ticker": this.HandleBidAsk,
        "trades": this.HandleTrades,
        "order_book_update": this.HandleOrderBook,
        "balances": this.HandleBalance,
        "liquidates": this.HandleLiquidation,
    }
    var method interface{} = this.SafeValue(v4Methods, channelType)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
    var requestId interface{} = this.SafeString(message, "request_id")
    if ccxt.IsTrue(ccxt.IsEqual(requestId, "authenticated")) {
        this.HandleAuthenticationMessage(client, message)
        return
    }
    if ccxt.IsTrue(!ccxt.IsEqual(requestId, nil)) {
        var data interface{} = this.SafeDict(message, "data")
        // use safeValue as result may be Array or an Object
        var result interface{} = this.SafeValue(data, "result")
        var ack interface{} = this.SafeBool(message, "ack")
        if ccxt.IsTrue(!ccxt.IsEqual(ack, true)) {
            client.(ccxt.ClientInterface).Resolve(result, requestId)
        }
    }
}
func  (this *GateCore) GetUrlByMarket(market interface{}) interface{}  {
    var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), ccxt.GetValue(market, "type"))
    if ccxt.IsTrue(ccxt.GetValue(market, "contract")) {
        return ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "linear")), ccxt.GetValue(baseUrl, "usdt"), ccxt.GetValue(baseUrl, "btc"))
    } else {
        return baseUrl
    }
}
func  (this *GateCore) GetTypeByMarket(market interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.GetValue(market, "spot")) {
        return "spot"
    } else if ccxt.IsTrue(ccxt.GetValue(market, "option")) {
        return "options"
    } else {
        return "futures"
    }
}
func  (this *GateCore) GetUrlByMarketType(typeVar interface{}, optionalArgs ...interface{}) interface{}  {
    isInverse := ccxt.GetArg(optionalArgs, 0, false)
    _ = isInverse
    var api interface{} = ccxt.GetValue(this.Urls, "api")
    var url interface{} = ccxt.GetValue(api, typeVar)
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "swap"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "future")))) {
        return ccxt.Ternary(ccxt.IsTrue(isInverse), ccxt.GetValue(url, "btc"), ccxt.GetValue(url, "usdt"))
    } else {
        return url
    }
}
func  (this *GateCore) GetMarketTypeByUrl(url interface{}) interface{}  {
    var findBy interface{} = map[string]interface{} {
        "op-": "option",
        "delivery": "future",
        "fx": "swap",
    }
    var keys interface{} = ccxt.ObjectKeys(findBy)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        var value interface{} = ccxt.GetValue(findBy, key)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, key), 0)) {
            return value
        }
    }
    return "spot"
}
func  (this *GateCore) RequestId() interface{}  {
    // their support said that reqid must be an int32, not documented
    var reqid interface{} = this.Sum(this.SafeInteger(this.Options, "reqid", 0), 1)
    ccxt.AddElementToObject(this.Options, "reqid", reqid)
    return reqid
}
func  (this *GateCore) SubscribePublic(url interface{}, messageHash interface{}, payload interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, nil)
            _ = subscription
            var requestId interface{} = this.RequestId()
            var time interface{} = this.Seconds()
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "time": time,
                "channel": channel,
                "event": "subscribe",
                "payload": payload,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                var client interface{} = this.Client(url)
                if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
                    var tempSubscriptionHash interface{} = ccxt.ToString(requestId)
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), tempSubscriptionHash, messageHash)
                }
            }
            var message interface{} = this.Extend(request, params)
        
                retRes202515 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes202515)
                ch <- retRes202515
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) SubscribePublicMultiple(url interface{}, messageHashes interface{}, payload interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var requestId interface{} = this.RequestId()
            var time interface{} = this.Seconds()
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "time": time,
                "channel": channel,
                "event": "subscribe",
                "payload": payload,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes203915 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes203915)
                ch <- retRes203915
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) UnSubscribePublicMultiple(url interface{}, topic interface{}, symbols interface{}, messageHashes interface{}, subMessageHashes interface{}, payload interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var requestId interface{} = this.RequestId()
            var time interface{} = this.Seconds()
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "time": time,
                "channel": channel,
                "event": "unsubscribe",
                "payload": payload,
            }
            var sub interface{} = map[string]interface{} {
                "id": ccxt.ToString(requestId),
                "topic": topic,
                "unsubscribe": true,
                "messageHashes": messageHashes,
                "subMessageHashes": subMessageHashes,
                "symbols": symbols,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes206115 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes, sub))
                ccxt.PanicOnError(retRes206115)
                ch <- retRes206115
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) Authenticate(url interface{}, messageType interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var channel interface{} = ccxt.Add(messageType, ".login")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
        
                    retRes207119 :=  (<-this.RequestPrivate(url, map[string]interface{} {}, channel, messageHash))
                    ccxt.PanicOnError(retRes207119)
                    ch <- retRes207119
                    return nil
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }
func  (this *GateCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    var messageHash interface{} = "authenticated"
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
    future.(*ccxt.Future).Resolve(true)
}
func  (this *GateCore) RequestPrivate(url interface{}, reqParams interface{}, channel interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    requestId := ccxt.GetArg(optionalArgs, 0, nil)
            _ = requestId
            this.CheckRequiredCredentials()
            // uid is required for some subscriptions only so it's not a part of required credentials
            var event interface{} = "api"
            if ccxt.IsTrue(ccxt.IsEqual(requestId, nil)) {
                var reqId interface{} = this.RequestId()
                requestId = ccxt.ToString(reqId)
            }
            var messageHash interface{} = requestId
            var time interface{} = this.Seconds()
            // unfortunately, PHP demands double quotes for the escaped newline symbol
            var signatureString interface{} = ccxt.Join([]interface{}{event, channel, this.Json(reqParams), ccxt.ToString(time)}, "\n") // eslint-disable-line quotes
            var signature interface{} = this.Hmac(this.Encode(signatureString), this.Encode(this.Secret), ccxt.Sha512, "hex")
            var payload interface{} = map[string]interface{} {
                "req_id": requestId,
                "timestamp": ccxt.ToString(time),
                "api_key": this.ApiKey,
                "signature": signature,
                "req_param": reqParams,
            }
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(channel, "spot.order_place"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "futures.order_place")))) {
                ccxt.AddElementToObject(payload, "req_header", map[string]interface{} {
            "X-Gate-Channel-Id": "ccxt",
        })
            }
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "time": time,
                "channel": channel,
                "event": event,
                "payload": payload,
            }
        
                retRes211415 :=  (<-this.Watch(url, messageHash, request, messageHash, requestId))
                ccxt.PanicOnError(retRes211415)
                ch <- retRes211415
                return nil
        
            }()
            return ch
        }
func  (this *GateCore) SubscribePrivate(url interface{}, messageHash interface{}, payload interface{}, channel interface{}, params interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    requiresUid := ccxt.GetArg(optionalArgs, 0, false)
            _ = requiresUid
            this.CheckRequiredCredentials()
            // uid is required for some subscriptions only so it's not a part of required credentials
            if ccxt.IsTrue(requiresUid) {
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(this.Uid, nil)) || ccxt.IsTrue(ccxt.IsEqual(ccxt.GetLength(this.Uid), 0))) {
                    panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " requires uid to subscribe")))
                }
                var idArray interface{} = []interface{}{this.Uid}
                if ccxt.IsTrue(ccxt.IsEqual(payload, nil)) {
                    payload = idArray
                } else {
                    payload = this.ArrayConcat(idArray, payload)
                }
            }
            var time interface{} = this.Seconds()
            var event interface{} = "subscribe"
            var signaturePayload interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("channel=", channel), "&"), "event="), event), "&"), "time="), ccxt.ToString(time))
            var signature interface{} = this.Hmac(this.Encode(signaturePayload), this.Encode(this.Secret), ccxt.Sha512, "hex")
            var auth interface{} = map[string]interface{} {
                "method": "api_key",
                "KEY": this.ApiKey,
                "SIGN": signature,
            }
            var requestId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "time": time,
                "channel": channel,
                "event": event,
                "auth": auth,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(payload, nil)) {
                ccxt.AddElementToObject(request, "payload", payload)
            }
            var client interface{} = this.Client(url)
            if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
                var tempSubscriptionHash interface{} = ccxt.ToString(requestId)
                // in case of authenticationError we will throw
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), tempSubscriptionHash, messageHash)
            }
            var message interface{} = this.Extend(request, params)
        
                retRes215815 :=  (<-this.Watch(url, messageHash, message, messageHash, messageHash))
                ccxt.PanicOnError(retRes215815)
                ch <- retRes215815
                return nil
        
            }()
            return ch
        }


func (this *GateCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
