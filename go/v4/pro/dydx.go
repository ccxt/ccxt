package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DydxCore struct {
	*ccxt.DydxCore
	base *ccxt.DydxCore
}

func NewDydxCore() *DydxCore {
    p := &DydxCore{}
	base := &ccxt.DydxCore{}
	p.base = base
	p.DydxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *DydxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchTicker": false,
            "watchTickers": false,
            "watchTrades": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": "wss://indexer.v4testnet.dydx.exchange/v4/ws",
            },
            "api": map[string]interface{} {
                "ws": "wss://indexer.dydx.trade/v4/ws",
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name dydx#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.dydx.xyz/indexer-client/websockets#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#public-trades}
 */
func  (this *DydxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes498)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("trade:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": "v4_trades",
                "id": ccxt.GetValue(market, "id"),
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#unWatchTrades
 * @description unsubscribes from the trades channel
 * @see https://docs.dydx.xyz/indexer-client/websockets#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DydxCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes758)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("trade:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "unsubscribe",
                "channel": "v4_trades",
                "id": ccxt.GetValue(market, "id"),
            }
        
                retRes8415 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes8415)
                ch <- retRes8415
                return nil
        
            }()
            return ch
        }
func  (this *DydxCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     "type": "subscribed",
    //     "connection_id": "9011edff-d8f7-47fc-bbc6-0c7b5ba7dfae",
    //     "message_id": 3,
    //     "channel": "v4_trades",
    //     "id": "BTC-USD",
    //     "contents": {
    //         "trades": [
    //             {
    //                 "id": "02b6148d0000000200000005",
    //                 "side": "BUY",
    //                 "size": "0.024",
    //                 "price": "114581",
    //                 "type": "LIMIT",
    //                 "createdAt": "2025-08-04T00:42:07.119Z",
    //                 "createdAtHeight": "45487245"
    //             }
    //         ]
    //     }
    // }
    //
    var marketId interface{} = this.SafeString(message, "id")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var content interface{} = this.SafeDict(message, "contents")
    var rawTrades interface{} = this.SafeList(content, "trades", []interface{}{})
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var parsedTrades interface{} = this.ParseTrades(rawTrades, market)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsedTrades)); i++ {
        var parsed interface{} = ccxt.GetValue(parsedTrades, i)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *DydxCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "02b6148d0000000200000003",
    //     "side": "BUY",
    //     "size": "0.024",
    //     "price": "114581",
    //     "type": "LIMIT",
    //     "createdAt": "2025-08-04T00:42:07.118Z",
    //     "createdAtHeight": "45487244"
    // }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "createdAt"))
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "order": nil,
        "type": this.SafeStringLower(trade, "type"),
        "side": this.SafeStringLower(trade, "side"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "size"),
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name dydx#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.dydx.xyz/indexer-client/websockets#orders
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DydxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1718)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": "v4_orderbook",
                "id": ccxt.GetValue(market, "id"),
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.dydx.xyz/indexer-client/websockets#orders
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DydxCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1948)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "unsubscribe",
                "channel": "v4_orderbook",
                "id": ccxt.GetValue(market, "id"),
            }
        
                retRes20315 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes20315)
                ch <- retRes20315
                return nil
        
            }()
            return ch
        }
func  (this *DydxCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // {
    //     "type": "subscribed",
    //     "connection_id": "7af140fb-b33d-4f0e-8f4c-30f16337b360",
    //     "message_id": 1,
    //     "channel": "v4_orderbook",
    //     "id": "BTC-USD",
    //     "contents": {
    //         "bids": [
    //             {
    //                 "price": "114623",
    //                 "size": "0.1112"
    //             }
    //         ],
    //         "asks": [
    //             {
    //                 "price": "114624",
    //                 "size": "0.0872"
    //             }
    //         ]
    //     }
    // }
    //
    var marketId interface{} = this.SafeString(message, "id")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var content interface{} = this.SafeDict(message, "contents")
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        orderbook = this.OrderBook()
    }
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    var asks interface{} = this.SafeList(content, "asks", []interface{}{})
    var bids interface{} = this.SafeList(content, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(message, "message_id"))
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *DydxCore) HandleDelta(bookside interface{}, delta interface{})  {
    if ccxt.IsTrue(ccxt.IsArray(delta)) {
        var price interface{} = this.SafeFloat(delta, 0)
        var amount interface{} = this.SafeFloat(delta, 1)
        bookside.(ccxt.IOrderBookSide).Store(price, amount)
    } else {
        var bidAsk interface{} = this.ParseBidAsk(delta, "price", "size")
        bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    }
}
/**
 * @method
 * @name dydx#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.dydx.xyz/indexer-client/websockets#candles
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DydxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2738)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol"))
            var resolution interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": "v4_candles",
                "id": ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "/"), resolution),
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.dydx.xyz/indexer-client/websockets#candles
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DydxCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3028)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol"))
            var resolution interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "type": "unsubscribe",
                "channel": "v4_candles",
                "id": ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "/"), resolution),
            }
        
                retRes31215 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes31215)
                ch <- retRes31215
                return nil
        
            }()
            return ch
        }
func  (this *DydxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // {
    //     "type": "subscribed",
    //     "connection_id": "e00b6e27-590c-4e91-a24d-b0645289434b",
    //     "message_id": 1,
    //     "channel": "v4_candles",
    //     "id": "BTC-USD/1MIN",
    //     "contents": {
    //         "candles": [
    //             {
    //                 "startedAt": "2025-08-05T03:40:00.000Z",
    //                 "ticker": "BTC-USD",
    //                 "resolution": "1MIN",
    //                 "low": "114249",
    //                 "high": "114256",
    //                 "open": "114256",
    //                 "close": "114249",
    //                 "baseTokenVolume": "0.4726",
    //                 "usdVolume": "53996.1818",
    //                 "trades": 7,
    //                 "startingOpenInterest": "501.7424",
    //                 "orderbookMidPriceOpen": "114255.5",
    //                 "orderbookMidPriceClose": "114255.5"
    //             }
    //         ]
    //     }
    // }
    // {
    //     "type": "channel_data",
    //     "connection_id": "e00b6e27-590c-4e91-a24d-b0645289434b",
    //     "message_id": 3,
    //     "id": "BTC-USD/1MIN",
    //     "channel": "v4_candles",
    //     "version": "1.0.0",
    //     "contents": {
    //         "startedAt": "2025-08-05T03:40:00.000Z",
    //         "ticker": "BTC-USD",
    //         "resolution": "1MIN",
    //         "low": "114249",
    //         "high": "114262",
    //         "open": "114256",
    //         "close": "114261",
    //         "baseTokenVolume": "0.4753",
    //         "usdVolume": "54304.6873",
    //         "trades": 9,
    //         "startingOpenInterest": "501.7424",
    //         "orderbookMidPriceOpen": "114255.5",
    //         "orderbookMidPriceClose": "114255.5"
    //     }
    // }
    //
    var id interface{} = this.SafeString(message, "id")
    var part interface{} = ccxt.Split(id, "/")
    var interval interface{} = this.SafeString(part, 1)
    var timeframe interface{} = this.FindTimeframe(interval)
    var marketId interface{} = this.SafeString(part, 0)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var content interface{} = this.SafeDict(message, "contents")
    var candles interface{} = this.SafeList(content, "candles")
    var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
    var ohlcv interface{} = this.SafeDict(candles, 0, content)
    var parsed interface{} = this.ParseOHLCV(ohlcv, market)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *DydxCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    
        {
             func(this *DydxCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *DydxCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        var msg interface{} = this.SafeString(message, "message")
            panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), msg)))
    		    
    	    }(this)
        
            }
    return true
}
func  (this *DydxCore) HandleMessage(client interface{}, message interface{})  {
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "error")) {
        this.HandleErrorMessage(client, message)
        return
    }
    if ccxt.IsTrue(!ccxt.IsEqual(typeVar, nil)) {
        var topic interface{} = this.SafeString(message, "channel")
        var methods interface{} = map[string]interface{} {
            "v4_trades": this.HandleTrades,
            "v4_orderbook": this.HandleOrderBook,
            "v4_candles": this.HandleOHLCV,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *DydxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
