package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type LbankCore struct {
	*ccxt.LbankCore
	base *ccxt.LbankCore
}

func NewLbankCore() *LbankCore {
    p := &LbankCore{}
	base := &ccxt.LbankCore{}
	p.base = base
	p.LbankCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *LbankCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "fetchOHLCVWs": true,
            "fetchOrderBookWs": true,
            "fetchTickerWs": true,
            "fetchTradesWs": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": false,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://www.lbkex.net/ws/V2/",
            },
        },
        "options": map[string]interface{} {
            "watchOHLCV": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1min",
                    "5m": "5min",
                    "15m": "15min",
                    "30m": "30min",
                    "1h": "1hr",
                    "4h": "4hr",
                    "1d": "day",
                    "1w": "week",
                    "1M": "month",
                    "1y": "year",
                },
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *LbankCore) RequestId() interface{}  {
    var previousValue interface{} = this.SafeInteger(this.Options, "requestId", 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(this.Options, "requestId", newValue)
    return newValue
}
/**
 * @method
 * @name lbank#fetchOHLCVWs
 * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *LbankCore) FetchOHLCVWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes768)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var watchOHLCVOptions interface{} = this.SafeValue(this.Options, "watchOHLCV", map[string]interface{} {})
            var timeframes interface{} = this.SafeValue(watchOHLCVOptions, "timeframes", map[string]interface{} {})
            var timeframeId interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("fetchOHLCV:", ccxt.GetValue(market, "symbol")), ":"), timeframeId)
            var message interface{} = map[string]interface{} {
                "action": "request",
                "request": "kbar",
                "kbar": timeframeId,
                "pair": ccxt.GetValue(market, "id"),
            }
            if ccxt.IsTrue(!ccxt.IsEqual(since, nil)) {
                ccxt.AddElementToObject(message, "start", this.ParseToInt(ccxt.MathFloor(ccxt.Divide(since, 1000))))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(message, "size", limit)
            }
            var request interface{} = this.DeepExtend(message, params)
            var requestId interface{} = this.RequestId()
        
                retRes9715 :=  (<-this.Watch(url, messageHash, request, requestId, request))
                ccxt.PanicOnError(retRes9715)
                ch <- retRes9715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#watchOHLCV
 * @see https://www.lbank.com/en-US/docs/index.html#subscription-of-k-line-data
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *LbankCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1138)
            var market interface{} = this.Market(symbol)
            var watchOHLCVOptions interface{} = this.SafeValue(this.Options, "watchOHLCV", map[string]interface{} {})
            var timeframes interface{} = this.SafeValue(watchOHLCVOptions, "timeframes", map[string]interface{} {})
            var timeframeId interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol")), ":"), timeframeId)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "kbar",
                "kbar": timeframeId,
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // request
    //    {
    //        "records":[
    //           [
    //              1705364400,
    //              42614,
    //              42624.57,
    //              42532.15,
    //              42537.43,
    //              13.2615,
    //              564568.931565,
    //              433
    //           ]
    //        ],
    //        "columns":[
    //           "timestamp",
    //           "open",
    //           "high",
    //           "low",
    //           "close",
    //           "volume",
    //           "turnover",
    //           "count"
    //        ],
    //        "SERVER":"V2",
    //        "count":1,
    //        "kbar":"5min",
    //        "type":"kbar",
    //        "pair":"btc_usdt",
    //        "TS":"2024-01-16T08:29:41.718"
    //    }
    // subscribe
    //      {
    //          SERVER: 'V2',
    //          kbar: {
    //              a: 26415.891476,
    //              c: 19315.51,
    //              t: '2022-10-02T12:44:00.000',
    //              v: 1.3676,
    //              h: 19316.66,
    //              slot: '1min',
    //              l: 19315.51,
    //              n: 1,
    //              o: 19316.66
    //          },
    //          type: 'kbar',
    //          pair: 'btc_usdt',
    //          TS: '2022-10-02T12:44:15.865'
    //      }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var watchOHLCVOptions interface{} = this.SafeValue(this.Options, "watchOHLCV", map[string]interface{} {})
    var timeframes interface{} = this.SafeValue(watchOHLCVOptions, "timeframes", map[string]interface{} {})
    var records interface{} = this.SafeValue(message, "records")
    if ccxt.IsTrue(!ccxt.IsEqual(records, nil)) {
        var rawOHLCV interface{} = this.SafeValue(records, 0, []interface{}{})
        var parsed interface{} = []interface{}{this.SafeInteger(rawOHLCV, 0), this.SafeNumber(rawOHLCV, 1), this.SafeNumber(rawOHLCV, 2), this.SafeNumber(rawOHLCV, 3), this.SafeNumber(rawOHLCV, 4), this.SafeNumber(rawOHLCV, 5)}
        var timeframeId interface{} = this.SafeString(message, "kbar")
        var timeframe interface{} = this.FindTimeframe(timeframeId, timeframes)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("fetchOHLCV:", symbol), ":"), timeframeId)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    } else {
        var rawOHLCV interface{} = this.SafeValue(message, "kbar", map[string]interface{} {})
        var timeframeId interface{} = this.SafeString(rawOHLCV, "slot")
        var datetime interface{} = this.SafeString(rawOHLCV, "t")
        var parsed interface{} = []interface{}{this.Parse8601(datetime), this.SafeNumber(rawOHLCV, "o"), this.SafeNumber(rawOHLCV, "h"), this.SafeNumber(rawOHLCV, "l"), this.SafeNumber(rawOHLCV, "c"), this.SafeNumber(rawOHLCV, "v")}
        var timeframe interface{} = this.FindTimeframe(timeframeId, timeframes)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframeId)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name lbank#fetchTickerWs
 * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the cex api endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *LbankCore) FetchTickerWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2498 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2498)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("fetchTicker:", ccxt.GetValue(market, "symbol"))
            var message interface{} = map[string]interface{} {
                "action": "request",
                "request": "tick",
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(message, params)
            var requestId interface{} = this.RequestId()
        
                retRes26015 :=  (<-this.Watch(url, messageHash, request, requestId, request))
                ccxt.PanicOnError(retRes26015)
                ch <- retRes26015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#watchTicker
 * @see https://www.lbank.com/en-US/docs/index.html#market
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} params extra parameters specific to the lbank api endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *LbankCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2738)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            var message interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "tick",
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes28315 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes28315)
                ch <- retRes28315
                return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "tick":{
    //             "to_cny":76643.5,
    //             "high":0.02719761,
    //             "vol":497529.7686,
    //             "low":0.02603071,
    //             "change":2.54,
    //             "usd":299.12,
    //             "to_usd":11083.66,
    //             "dir":"sell",
    //             "turnover":13224.0186,
    //             "latest":0.02698749,
    //             "cny":2068.41
    //         },
    //         "type":"tick",
    //         "pair":"eth_btc",
    //         "SERVER":"V2",
    //         "TS":"2019-07-01T11:33:55.188"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var parsedTicker interface{} = this.ParseWsTicker(message, market)
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
    messageHash = ccxt.Add("fetchTicker:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *LbankCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "tick":{
    //             "to_cny":76643.5,
    //             "high":0.02719761,
    //             "vol":497529.7686,
    //             "low":0.02603071,
    //             "change":2.54,
    //             "usd":299.12,
    //             "to_usd":11083.66,
    //             "dir":"sell",
    //             "turnover":13224.0186,
    //             "latest":0.02698749,
    //             "cny":2068.41
    //         },
    //         "type":"tick",
    //         "pair":"eth_btc",
    //         "SERVER":"V2",
    //         "TS":"2019-07-01T11:33:55.188"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var datetime interface{} = this.SafeString(ticker, "TS")
    var tickerData interface{} = this.SafeValue(ticker, "tick")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "high": this.SafeString(tickerData, "high"),
        "low": this.SafeString(tickerData, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": nil,
        "last": this.SafeString(tickerData, "latest"),
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(tickerData, "change"),
        "average": nil,
        "baseVolume": this.SafeString(tickerData, "vol"),
        "quoteVolume": this.SafeString(tickerData, "turnover"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name lbank#fetchTradesWs
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {ccxt.Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *LbankCore) FetchTradesWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3818)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("fetchTrades:", ccxt.GetValue(market, "symbol"))
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 10
            }
            var message interface{} = map[string]interface{} {
                "action": "request",
                "request": "trade",
                "pair": ccxt.GetValue(market, "id"),
                "size": limit,
            }
            var request interface{} = this.DeepExtend(message, params)
            var requestId interface{} = this.RequestId()
        
                retRes39615 :=  (<-this.Watch(url, messageHash, request, requestId, request))
                ccxt.PanicOnError(retRes39615)
                ch <- retRes39615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#watchTrades
 * @see https://www.lbank.com/en-US/docs/index.html#trade-record
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *LbankCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4118)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("trades:", ccxt.GetValue(market, "symbol"))
            var message interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "trade",
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleTrades(client interface{}, message interface{})  {
    //
    // request
    //     {
    //         columns: [ 'timestamp', 'price', 'volume', 'direction' ],
    //         SERVER: 'V2',
    //         count: 100,
    //         trades: [],
    //         type: 'trade',
    //         pair: 'btc_usdt',
    //         TS: '2024-01-16T08:48:24.470'
    //     }
    // subscribe
    //     {
    //         "trade":{
    //             "volume":6.3607,
    //             "amount":77148.9303,
    //             "price":12129,
    //             "direction":"sell", // buy, sell, buy_market, sell_market, buy_maker, sell_maker, buy_ioc, sell_ioc, buy_fok, sell_fok
    //             "TS":"2019-06-28T19:55:49.460"
    //         },
    //         "type":"trade",
    //         "pair":"btc_usdt",
    //         "SERVER":"V2",
    //         "TS":"2019-06-28T19:55:49.466"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var rawTrade interface{} = this.SafeValue(message, "trade")
    var rawTrades interface{} = this.SafeValue(message, "trades", []interface{}{rawTrade})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var trade interface{} = this.ParseWsTrade(ccxt.GetValue(rawTrades, i), market)
        ccxt.AddElementToObject(trade, "symbol", symbol)
        stored.(ccxt.Appender).Append(trade)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
    messageHash = ccxt.Add("fetchTrades:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *LbankCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // request
    //    [ 'timestamp', 'price', 'volume', 'direction' ]
    // subscribe
    //    {
    //        "volume":6.3607,
    //        "amount":77148.9303,
    //        "price":12129,
    //        "direction":"sell", // buy, sell, buy_market, sell_market, buy_maker, sell_maker, buy_ioc, sell_ioc, buy_fok, sell_fok
    //        "TS":"2019-06-28T19:55:49.460"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, 0)
    var datetime interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(timestamp, nil))), (this.Iso8601(timestamp)), (this.SafeString(trade, "TS")))
    if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(datetime)
    }
    var rawSide interface{} = this.SafeString2(trade, "direction", 3)
    var parts interface{} = ccxt.Split(rawSide, "_")
    var firstPart interface{} = this.SafeString(parts, 0)
    var secondPart interface{} = this.SafeString(parts, 1)
    var side interface{} = firstPart
    // reverse if it was 'maker'
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(secondPart, nil)) && ccxt.IsTrue(ccxt.IsEqual(secondPart, "maker"))) {
        side = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "buy"))), "sell", "buy")
    }
    return this.SafeTrade(map[string]interface{} {
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": nil,
        "id": nil,
        "order": nil,
        "type": nil,
        "takerOrMaker": nil,
        "side": side,
        "price": this.SafeString2(trade, "price", 1),
        "amount": this.SafeString2(trade, "volume", 2),
        "cost": this.SafeString(trade, "amount"),
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name lbank#watchOrders
 * @see https://www.lbank.com/en-US/docs/index.html#update-subscribed-orders
 * @description get the list of trades associated with the user
 * @param {string} [symbol] unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} params extra parameters specific to the lbank api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *LbankCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5318)
        
            key:= (<-this.Authenticate(params))
            ccxt.PanicOnError(key)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = nil
            var pair interface{} = "all"
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                messageHash = "orders:all"
            } else {
                var market interface{} = this.Market(symbol)
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add("orders:", ccxt.GetValue(market, "symbol"))
                pair = ccxt.GetValue(market, "id")
            }
            var message interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "orderUpdate",
                "subscribeKey": key,
                "pair": pair,
            }
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "orderUpdate":{
    //             "amount":"0.003",
    //             "orderStatus":2,
    //             "price":"0.02455211",
    //             "role":"maker",
    //             "updateTime":1561704577786,
    //             "uuid":"d0db191d-xxxxx-4418-xxxxx-fbb1xxxx2ea9",
    //             "txUuid":"da88f354d5xxxxxxa12128aa5bdcb3",
    //             "volumePrice":"0.00007365633"
    //         },
    //         "pair":"eth_btc",
    //         "type":"orderUpdate",
    //         "SERVER":"V2",
    //         "TS":"2019-06-28T14:49:37.816"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var myOrders interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        myOrders = ccxt.NewArrayCacheBySymbolById(limit)
    } else {
        myOrders = this.Orders
    }
    var order interface{} = this.ParseWsOrder(message)
    myOrders.(ccxt.Appender).Append(order)
    this.Orders = myOrders
    client.(ccxt.ClientInterface).Resolve(myOrders, "orders")
    var messageHash interface{} = ccxt.Add("orders:", symbol)
    client.(ccxt.ClientInterface).Resolve(myOrders, messageHash)
}
func  (this *LbankCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "orderUpdate":{
    //             "amount":"0.003",
    //             "orderStatus":2,
    //             "price":"0.02455211",
    //             "role":"maker",
    //             "updateTime":1561704577786,
    //             "uuid":"d0db191d-xxxxx-4418-xxxxx-fbb1xxxx2ea9",
    //             "txUuid":"da88f354d5xxxxxxa12128aa5bdcb3",
    //             "volumePrice":"0.00007365633"
    //         },
    //         "pair":"eth_btc",
    //         "type":"orderUpdate",
    //         "SERVER":"V2",
    //         "TS":"2019-06-28T14:49:37.816"
    //     }
    //     {
    //         "SERVER": "V2",
    //         "orderUpdate": {
    //            "accAmt": "0",
    //            "amount": "0",
    //            "avgPrice": "0",
    //            "customerID": "",
    //            "orderAmt": "5",
    //            "orderPrice": "0.009834",
    //            "orderStatus": 0,
    //            "price": "0.009834",
    //            "remainAmt": "5",
    //            "role": "taker",
    //            "symbol": "lbk_usdt",
    //            "type": "buy_market",
    //            "updateTime": 1705676718532,
    //            "uuid": "9b94ab2d-a510-4abe-a784-44a9d9c38ec7",
    //            "volumePrice": "0"
    //         },
    //         "type": "orderUpdate",
    //         "pair": "lbk_usdt",
    //         "TS": "2024-01-19T23:05:18.548"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var orderUpdate interface{} = this.SafeValue(order, "orderUpdate", map[string]interface{} {})
    var rawType interface{} = this.SafeString(orderUpdate, "type", "")
    var typeParts interface{} = ccxt.Split(rawType, "_")
    var side interface{} = this.SafeString(typeParts, 0)
    var exchangeType interface{} = this.SafeString(typeParts, 1)
    var typeVar interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(rawType, "buy")) && ccxt.IsTrue(!ccxt.IsEqual(rawType, "sell"))) {
        typeVar = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(exchangeType, "market"))), "market", "limit")
    }
    var marketId interface{} = this.SafeString(order, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var timestamp interface{} = this.SafeInteger(orderUpdate, "updateTime")
    var status interface{} = this.SafeString(orderUpdate, "orderStatus")
    var orderAmount interface{} = this.SafeString(orderUpdate, "orderAmt")
    var cost interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "market"))) && ccxt.IsTrue((ccxt.IsEqual(side, "buy")))) {
        cost = orderAmount
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(orderUpdate, "uuid"),
        "clientOrderId": this.SafeString(orderUpdate, "customerID"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": this.SafeInteger(orderUpdate, "updateTime"),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "price": this.SafeString2(orderUpdate, "price", "orderPrice"),
        "stopPrice": nil,
        "average": this.SafeString(orderUpdate, "avgPrice"),
        "amount": this.SafeString2(orderUpdate, "amount", "orderAmt"),
        "remaining": this.SafeString(orderUpdate, "remainAmt"),
        "filled": this.SafeString(orderUpdate, "accAmt"),
        "status": this.ParseWsOrderStatus(status),
        "fee": nil,
        "cost": cost,
        "trades": nil,
    }, market)
}
func  (this *LbankCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "-1": "canceled",
        "0": "open",
        "1": "open",
        "2": "closed",
        "4": "closed",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name lbank#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.lbank.com/docs/index.html#update-subscribed-asset
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *LbankCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6958)
        
            key:= (<-this.Authenticate(params))
            ccxt.PanicOnError(key)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "balance"
            var message interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "assetUpdate",
                "subscribeKey": key,
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes70515 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes70515)
                ch <- retRes70515
                return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "asset": "114548.31881315",
    //             "assetCode": "usdt",
    //             "free": "97430.6739041",
    //             "freeze": "17117.64490905",
    //             "time": 1627300043270,
    //             "type": "ORDER_CREATE"
    //         },
    //         "SERVER": "V2",
    //         "type": "assetUpdate",
    //         "TS": "2021-07-26T19:48:03.548"
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var timestamp interface{} = this.Parse8601(this.SafeString(message, "TS"))
    var datetime interface{} = this.Iso8601(timestamp)
    ccxt.AddElementToObject(this.Balance, "info", data)
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", datetime)
    var currencyId interface{} = this.SafeString(data, "assetCode")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(data, "free"))
    ccxt.AddElementToObject(account, "used", this.SafeString(data, "freeze"))
    ccxt.AddElementToObject(account, "total", this.SafeString(data, "asset"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
}
/**
 * @method
 * @name lbank#fetchOrderBookWs
 * @see https://www.lbank.com/en-US/docs/index.html#request-amp-subscription-instruction
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int|undefined} limit the maximum amount of order book entries to return
 * @param {object} params extra parameters specific to the lbank api endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
 */
func  (this *LbankCore) FetchOrderBookWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7528)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("fetchOrderbook:", ccxt.GetValue(market, "symbol"))
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 100
            }
            var subscribe interface{} = map[string]interface{} {
                "action": "request",
                "request": "depth",
                "depth": limit,
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#watchOrderBook
 * @see https://www.lbank.com/en-US/docs/index.html#market-depth
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int|undefined} limit the maximum amount of order book entries to return
 * @param {object} params extra parameters specific to the lbank api endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
 */
func  (this *LbankCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7818)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            params = this.Omit(params, "aggregation")
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 100
            }
            var subscribe interface{} = map[string]interface{} {
                "action": "subscribe",
                "subscribe": "depth",
                "depth": limit,
                "pair": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *LbankCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // request
    //    {
    //        "SERVER":"V2",
    //        "asks":[
    //           [
    //              42585.84,
    //              1.4422
    //           ],
    //           ...
    //        ],
    //        "bids":[
    //           [
    //              42585.83,
    //              1.8054
    //           ],
    //          ,,,
    //        ],
    //        "count":100,
    //        "type":"depth",
    //        "pair":"btc_usdt",
    //        "TS":"2024-01-16T08:26:00.413"
    //    }
    // subscribe
    //     {
    //         "depth": {
    //             "asks": [
    //                 [
    //                     0.0252,
    //                     0.5833
    //                 ],
    //                 [
    //                     0.025215,
    //                     4.377
    //                 ],
    //                 ...
    //             ],
    //             "bids": [
    //                 [
    //                     0.025135,
    //                     3.962
    //                 ],
    //                 [
    //                     0.025134,
    //                     3.46
    //                 ],
    //                 ...
    //             ]
    //         },
    //         "count": 100,
    //         "type": "depth",
    //         "pair": "eth_btc",
    //         "SERVER": "V2",
    //         "TS": "2019-06-28T17:49:22.722"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "pair")
    var symbol interface{} = this.SafeSymbol(marketId)
    var orderBook interface{} = this.SafeValue(message, "depth", message)
    var datetime interface{} = this.SafeString(message, "TS")
    var timestamp interface{} = this.Parse8601(datetime)
    // let orderbook = this.safeValue (this.orderbooks, symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var snapshot interface{} = this.ParseOrderBook(orderBook, symbol, timestamp, "bids", "asks")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    messageHash = ccxt.Add("fetchOrderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *LbankCore) HandleErrorMessage(client interface{}, message interface{})  {
    //
    //    {
    //        SERVER: 'V2',
    //        message: "Missing parameter ['kbar']",
    //        status: 'error',
    //        TS: '2024-01-16T08:09:43.314'
    //    }
    //
    var errMsg interface{} = this.SafeString(message, "message", "")
    error := ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), errMsg))
    client.(ccxt.ClientInterface).Reject(error)
}
func  (this *LbankCore) HandlePing(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            //  { ping: 'a13a939c-5f25-4e06-9981-93cb3b890707', action: 'ping' }
            //
            var pingId interface{} = this.SafeString(message, "ping")
            
                {
                     func(this *LbankCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *LbankCore) interface{} {
                                    // catch block:
                                            this.OnError(client, e)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes89512 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                        "action": "pong",
                        "pong": pingId,
                    }))
                    ccxt.PanicOnError(retRes89512)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *LbankCore) HandleMessage(client interface{}, message interface{})  {
    var status interface{} = this.SafeString(message, "status")
    if ccxt.IsTrue(ccxt.IsEqual(status, "error")) {
        this.HandleErrorMessage(client, message)
        return
    }
    var typeVar interface{} = this.SafeString2(message, "type", "action")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "ping")) {
        this.Spawn(this.HandlePing, client, message)
        return
    }
    var handlers interface{} = map[string]interface{} {
        "kbar": this.HandleOHLCV,
        "depth": this.HandleOrderBook,
        "trade": this.HandleTrades,
        "tick": this.HandleTicker,
        "orderUpdate": this.HandleOrders,
        "assetUpdate": this.HandleBalance,
    }
    var handler interface{} = this.SafeValue(handlers, typeVar)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
    }
}
func  (this *LbankCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // when we implement more private streams, we need to refactor the authentication
            // to be concurent-safe and respect the same authentication token
            params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var now interface{} = this.Milliseconds()
            var messageHash interface{} = "authenticated"
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
        
                response:= (<-this.SpotPrivatePostSubscribeGetKey(params))
                ccxt.PanicOnError(response)
                //
                // {"result":true,"data":"4e9958623e6006bd7b13ff9f36c03b36132f0f8da37f70b14ff2c4eab1fe0c97","error_code":0,"ts":1705602277198}
                //
                var result interface{} = this.SafeValue(response, "result")
                if ccxt.IsTrue(!ccxt.IsEqual(result, true)) {
                    panic(ccxt.ExchangeError(ccxt.Add(this.Id, " failed to get subscribe key")))
                }
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated", map[string]interface{} {
            "key": this.SafeString(response, "data"),
            "expires": this.Sum(now, 3300000),
        })
            } else {
                var expires interface{} = this.SafeInteger(authenticated, "expires", 0)
                if ccxt.IsTrue(ccxt.IsLessThan(expires, now)) {
                    var request interface{} = map[string]interface{} {
                        "subscribeKey": ccxt.GetValue(authenticated, "key"),
                    }
        
                    response:= (<-this.SpotPrivatePostSubscribeRefreshKey(this.Extend(request, params)))
                    ccxt.PanicOnError(response)
                    //
                    //    {"result": "true"}
                    //
                    var result interface{} = this.SafeString(response, "result")
                    if ccxt.IsTrue(!ccxt.IsEqual(result, "true")) {
                        panic(ccxt.ExchangeError(ccxt.Add(this.Id, " failed to refresh the SubscribeKey")))
                    }
                    ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(client, "subscriptions"), "authenticated"), "expires", this.Sum(now, 3300000)) // SubscribeKey lasts one hour, refresh it 5 minutes before it expires
                }
            }
        
            ch <- ccxt.GetValue(ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated"), "key")
            return nil
        
            }()
            return ch
        }


func (this *LbankCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
