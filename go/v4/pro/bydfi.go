package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BydfiCore struct {
	*ccxt.BydfiCore
	base *ccxt.BydfiCore
}

func NewBydfiCore() *BydfiCore {
    p := &BydfiCore{}
	base := &ccxt.BydfiCore{}
	p.base = base
	p.BydfiCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BydfiCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchBidsAsks": false,
            "watchMyTrades": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchOrdersForSymbols": true,
            "watchPositions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": false,
            "watchTradesForSymbols": false,
            "unwatchBidsAsks": false,
            "unwatchOHLCV": true,
            "unwatchOHLCVForSymbols": true,
            "unwatchOrderBook": true,
            "unwatchOrderBookForSymbols": true,
            "unwatchTicker": true,
            "unwatchTickers": true,
            "unWatchTrades": false,
            "unWatchTradesForSymbols": false,
            "unWatchOrders": false,
            "unWatchOrdersForSymbols": false,
            "unWatchPositions": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://stream.bydfi.com/v1/public/swap",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBookForSymbols": map[string]interface{} {
                "depth": "100",
                "frequency": "1000ms",
            },
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": false,
                "awaitBalanceSnapshot": true,
            },
            "timeframes": map[string]interface{} {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "2h": "2h",
                "4h": "4h",
                "6h": "6h",
                "8h": "8h",
                "12h": "12h",
                "1d": "1d",
                "1w": "1w",
                "1M": "1M",
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 119000,
        },
    })
}
func  (this *BydfiCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "id": this.RequestId(),
        "method": "ping",
    }
}
func  (this *BydfiCore) RequestId() interface{}  {
    this.LockId()
    var reqid interface{} = this.Sum(this.SafeInteger(this.Options, "reqid", 0), 1)
    ccxt.AddElementToObject(this.Options, "reqid", reqid)
    this.UnlockId()
    return reqid
}
func  (this *BydfiCore) WatchPublic(messageHashes interface{}, channels interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subscription := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = subscription
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var id interface{} = this.RequestId()
            var subscriptionParams interface{} = map[string]interface{} {
                "id": id,
            }
            var unsubscribe interface{} = this.SafeBool(params, "unsubscribe", false)
            var method interface{} = "SUBSCRIBE"
            if ccxt.IsTrue(unsubscribe) {
                method = "UNSUBSCRIBE"
                params = this.Omit(params, "unsubscribe")
                ccxt.AddElementToObject(subscriptionParams, "unsubscribe", true)
                ccxt.AddElementToObject(subscriptionParams, "messageHashes", messageHashes)
            }
            var message interface{} = map[string]interface{} {
                "id": id,
                "method": method,
                "params": channels,
            }
        
                retRes11615 :=  (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(message, params), messageHashes, this.Extend(subscriptionParams, subscription)))
                ccxt.PanicOnError(retRes11615)
                ch <- retRes11615
                return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) WatchPrivate(messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subHash interface{} = "private"
            var client interface{} = this.Client(url)
            var privateSubscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subHash)
            var subscription interface{} = map[string]interface{} {}
            if ccxt.IsTrue(ccxt.IsEqual(privateSubscription, nil)) {
                var id interface{} = this.RequestId()
                var timestamp interface{} = ccxt.ToString(this.Milliseconds())
                var payload interface{} = ccxt.Add(this.ApiKey, timestamp)
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256, "hex")
                var request interface{} = map[string]interface{} {
                    "id": id,
                    "method": "LOGIN",
                    "params": map[string]interface{} {
                        "apiKey": this.ApiKey,
                        "timestamp": timestamp,
                        "sign": signature,
                    },
                }
                params = this.DeepExtend(request, params)
                ccxt.AddElementToObject(subscription, "id", id)
            }
        
                retRes14315 :=  (<-this.WatchMultiple(url, messageHashes, params, []interface{}{"private"}, subscription))
                ccxt.PanicOnError(retRes14315)
                ch <- retRes14315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-symbol
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BydfiCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1568)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = ccxt.GetValue(market, "id")
            var messageHash interface{} = ccxt.Add("ticker::", symbol)
            var channel interface{} = ccxt.Add(marketId, "@ticker")
        
                retRes16115 :=  (<-this.WatchPublic([]interface{}{messageHash}, []interface{}{channel}, params))
                ccxt.PanicOnError(retRes16115)
                ch <- retRes16115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-symbol
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BydfiCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes17415 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes17415)
                ch <- retRes17415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-symbol
 * @see https://developers.bydfi.com/en/swap/websocket-market#market-wide-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BydfiCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1888)
            symbols = this.MarketSymbols(symbols, nil, true)
            var messageHashes interface{} = []interface{}{}
            var messageHash interface{} = "ticker::"
            var channels interface{} = []interface{}{}
            var channel interface{} = "@ticker"
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&messageHashes, ccxt.Add(messageHash, "all"))
                ccxt.AppendToArray(&channels, "!ticker@arr")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var marketId interface{} = this.MarketId(symbol)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(messageHash, symbol))
                    ccxt.AppendToArray(&channels, ccxt.Add(marketId, channel))
                }
            }
        
            retRes2058 := (<-this.WatchPublic(messageHashes, channels, params))
            ccxt.PanicOnError(retRes2058)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-symbol
 * @see https://developers.bydfi.com/en/swap/websocket-market#market-wide-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BydfiCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            symbols = this.MarketSymbols(symbols, nil, true)
            var messageHashes interface{} = []interface{}{}
            var messageHash interface{} = "unsubscribe::ticker::"
            var channels interface{} = []interface{}{}
            var channel interface{} = "@ticker"
            var subscription interface{} = map[string]interface{} {
                "topic": "ticker",
            }
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                // all tickers and tickers for specific symbols are different channels
                // we need to unsubscribe from all ticker channels
                var subHashes interface{} = this.GetMessageHashesForTickersUnsubscription()
                ccxt.AddElementToObject(subscription, "subHashIsPrefix", true)
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subHashes)); i++ {
                    var subHash interface{} = this.SafeString(subHashes, i)
                    if ccxt.IsTrue(!ccxt.IsEqual(subHash, nil)) {
                        var parts interface{} = ccxt.Split(subHash, "::")
                        var symbol interface{} = this.SafeString(parts, 1)
                        if ccxt.IsTrue(ccxt.IsEqual(symbol, "all")) {
                            continue
                        }
                        var marketId interface{} = this.MarketId(symbol)
                        ccxt.AppendToArray(&channels, ccxt.Add(marketId, channel))
                    }
                }
                ccxt.AppendToArray(&messageHashes, messageHash)
                ccxt.AppendToArray(&channels, "!ticker@arr")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var marketId interface{} = this.MarketId(symbol)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(messageHash, symbol))
                    ccxt.AppendToArray(&channels, ccxt.Add(marketId, channel))
                }
                ccxt.AddElementToObject(subscription, "symbols", symbols)
            }
            params = this.Extend(params, map[string]interface{} {
                "unsubscribe": true,
            })
        
                retRes25715 :=  (<-this.WatchPublic(messageHashes, channels, params, subscription))
                ccxt.PanicOnError(retRes25715)
                ch <- retRes25715
                return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) GetMessageHashesForTickersUnsubscription() interface{}  {
    var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
    var client interface{} = this.Client(url)
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var messageHashes interface{} = []interface{}{}
    var keys interface{} = ccxt.ObjectKeys(subscriptions)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetIndexOf(key, "ticker::"), 0)) {
            ccxt.AppendToArray(&messageHashes, key)
        }
    }
    return messageHashes
}
func  (this *BydfiCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "s": "KAS-USDT",
    //         "c": 0.04543,
    //         "e": "24hrTicker",
    //         "E": 1766528295905,
    //         "v": 98278925,
    //         "h": 0.04685,
    //         "l": 0.04404,
    //         "o": 0.04657
    //     }
    //
    var ticker interface{} = this.ParseTicker(message)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    var messageHash interface{} = ccxt.Add("ticker::", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
    client.(ccxt.ClientInterface).Resolve(this.Tickers, "ticker::all")
}
/**
 * @method
 * @name bydfi#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BydfiCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BydfiCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes32415 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes32415)
                ch <- retRes32415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BydfiCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [\\'ETH/USDC\\', \\'1m\\']")))
            }
        
            retRes3438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3438)
            var channels interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
                var interval interface{} = this.SafeString(timeframes, tf, tf)
                ccxt.AppendToArray(&channels, ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@kline_"), interval))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), interval))
            }
            symboltimeframecandlesVariable := (<-this.WatchPublic(messageHashes, channels, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BydfiCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [\\'ETH/USDC\\', \\'1m\\']")))
            }
        
            retRes3788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3788)
            var channels interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                ccxt.AppendToArray(&channels, ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@kline_"), interval))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe::ohlcv::", ccxt.GetValue(market, "symbol")), "::"), interval))
            }
            params = this.Extend(params, map[string]interface{} {
                "unsubscribe": true,
            })
            var subscription interface{} = map[string]interface{} {
                "topic": "ohlcv",
                "symbolsAndTimeframes": symbolsAndTimeframes,
            }
        
                retRes39515 :=  (<-this.WatchPublic(messageHashes, channels, params, subscription))
                ccxt.PanicOnError(retRes39515)
                ch <- retRes39515
                return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "s": "ETH-USDC",
    //         "c": 2956.13,
    //         "t": 1766506860000,
    //         "T": 1766506920000,
    //         "e": "kline",
    //         "v": 3955,
    //         "h": 2956.41,
    //         "i": "1m",
    //         "l": 2956.05,
    //         "o": 2956.05
    //     }
    //
    var marketId interface{} = this.SafeString(message, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(message, "i")
    var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{} {})
    var timeframe interface{} = this.FindTimeframe(interval, timeframes)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored := ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcv interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(message)
    ohlcv.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    client.(ccxt.ClientInterface).Resolve([]interface{}{symbol, timeframe, ohlcv}, messageHash)
}
/**
 * @method
 * @name bydfi#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default and maxi is 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BydfiCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes44515 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes44515)
                ch <- retRes44515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BydfiCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes45815 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes45815)
                ch <- retRes45815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return (default and max is 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BydfiCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4728)
            symbols = this.MarketSymbols(symbols, nil, false)
            var depth interface{} = "100"
            depthparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "depth", depth)
            depth = ccxt.GetValue(depthparamsVariable,0)
            params = ccxt.GetValue(depthparamsVariable,1)
            var frequency interface{} = "100ms"
            frequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "frequency", frequency)
            frequency = ccxt.GetValue(frequencyparamsVariable,0)
            params = ccxt.GetValue(frequencyparamsVariable,1)
            var channelSuffix interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(frequency, "100ms")) {
                channelSuffix = "@100ms"
            }
            var channels interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&channels, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@depth"), depth), channelSuffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook::", symbol))
            }
        
            orderbook:= (<-this.WatchPublic(messageHashes, channels, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BydfiCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5058 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5058)
            symbols = this.MarketSymbols(symbols, nil, false)
            var depth interface{} = "100"
            depthparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "depth", depth)
            depth = ccxt.GetValue(depthparamsVariable,0)
            params = ccxt.GetValue(depthparamsVariable,1)
            var frequency interface{} = "100ms"
            frequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "frequency", frequency)
            frequency = ccxt.GetValue(frequencyparamsVariable,0)
            params = ccxt.GetValue(frequencyparamsVariable,1)
            var channelSuffix interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(frequency, "100ms")) {
                channelSuffix = "@100ms"
            }
            var channels interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&channels, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@depth"), depth), channelSuffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe::orderbook::", symbol))
            }
            var subscription interface{} = map[string]interface{} {
                "topic": "orderbook",
                "symbols": symbols,
            }
            params = this.Extend(params, map[string]interface{} {
                "unsubscribe": true,
            })
        
                retRes52815 :=  (<-this.WatchPublic(messageHashes, channels, params, subscription))
                ccxt.PanicOnError(retRes52815)
                ch <- retRes52815
                return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "a": [ [ 150000, 15 ], ... ],
    //         "b": [ [ 90450.7, 3615 ], ... ],
    //         "s": "BTC-USDT",
    //         "e": "depthUpdate",
    //         "E": 1766577624512
    //     }
    //
    var marketId interface{} = this.SafeString(message, "s")
    var symbol interface{} = this.SafeSymbol(marketId)
    var timestamp interface{} = this.SafeInteger(message, "E")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var parsed interface{} = this.ParseOrderBook(message, symbol, timestamp, "b", "a")
    orderbook.(ccxt.OrderBookInterface).Reset(parsed)
    var messageHash interface{} = ccxt.Add("orderbook::", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name bydfi#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://developers.bydfi.com/en/swap/websocket-account#order-trade-update-push
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BydfiCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var symbols interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbols = []interface{}{symbol}
            }
        
                retRes57115 :=  (<-this.WatchOrdersForSymbols(symbols, since, limit, params))
                ccxt.PanicOnError(retRes57115)
                ch <- retRes57115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bydfi#watchOrdersForSymbols
 * @description watches information on multiple orders made by the user
 * @see https://developers.bydfi.com/en/swap/websocket-account#order-trade-update-push
 * @param {string[]} symbols unified symbol of the market to fetch orders for
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BydfiCore) WatchOrdersForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5868)
            symbols = this.MarketSymbols(symbols, nil, true)
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&messageHashes, "orders")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("orders::", symbol))
                }
            }
        
            orders:= (<-this.WatchPrivate(messageHashes, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(orders, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(orders).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         "T": 1766588450558,
    //         "E": 1766588450685,
    //         "e": "ORDER_TRADE_UPDATE",
    //         "o": {
    //             "S": "BUY",
    //             "ap": "0",
    //             "cpt": false,
    //             "ct": "future",
    //             "ev": "0",
    //             "fee": "0",
    //             "lv": 2,
    //             "mt": "isolated",
    //             "o": "7409609004526010368",
    //             "p": "1000",
    //             "ps": "BOTH",
    //             "pt": "ONE_WAY",
    //             "ro": false,
    //             "s": "ETH-USDC",
    //             "st": "NEW",
    //             "t": "LIMIT",
    //             "tp": "0",
    //             "u": "0.001",
    //             "v": "2"
    //         }
    //     }
    //
    var rawOrder interface{} = this.SafeDict(message, "o", map[string]interface{} {})
    var marketId interface{} = this.SafeString(rawOrder, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = "orders"
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var order interface{} = this.ParseWsOrder(rawOrder, market)
    var lastUpdateTimestamp interface{} = this.SafeInteger(message, "T")
    ccxt.AddElementToObject(order, "lastUpdateTimestamp", lastUpdateTimestamp)
    orders.(ccxt.Appender).Append(order)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    client.(ccxt.ClientInterface).Resolve(orders, symbolMessageHash)
}
func  (this *BydfiCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "S": "BUY",
    //         "ap": "0",
    //         "cpt": false,
    //         "ct": "future",
    //         "ev": "0",
    //         "fee": "0",
    //         "lv": 2,
    //         "mt": "isolated",
    //         "o": "7409609004526010368",
    //         "p": "1000",
    //         "ps": "BOTH",
    //         "pt": "ONE_WAY",
    //         "ro": false,
    //         "s": "ETH-USDC",
    //         "st": "NEW",
    //         "t": "LIMIT",
    //         "tp": "0",
    //         "u": "0.001",
    //         "v": "2"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "s")
    market = this.SafeMarket(marketId, market)
    var rawStatus interface{} = this.SafeString(order, "st")
    var rawType interface{} = this.SafeString(order, "t")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "fee")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": ccxt.Precise.StringAbs(feeCost),
            "currency": ccxt.GetValue(market, "quote"),
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "o"),
        "clientOrderId": this.SafeString(order, "cid"),
        "timestamp": nil,
        "datetime": nil,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": nil,
        "status": this.ParseOrderStatus(rawStatus),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": this.ParseOrderType(rawType),
        "timeInForce": nil,
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "ro"),
        "side": this.SafeStringLower(order, "S"),
        "price": this.SafeString(order, "p"),
        "triggerPrice": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "amount": this.SafeString(order, "v"),
        "filled": this.SafeString(order, "ev"),
        "remaining": this.SafeString(order, "qty"),
        "cost": nil,
        "trades": nil,
        "fee": fee,
        "average": this.OmitZero(this.SafeString(order, "ap")),
    }, market)
}
/**
 * @method
 * @name bydfi#watchPositions
 * @description watch all open positions
 * @see https://developers.bydfi.com/en/swap/websocket-account#balance-and-position-update-push
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BydfiCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7318)
            symbols = this.MarketSymbols(symbols, nil, true)
            var messageHashes interface{} = []interface{}{}
            var messageHash interface{} = "positions"
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                ccxt.AppendToArray(&messageHashes, messageHash)
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(messageHash, "::"), symbol))
                }
            }
        
            positions:= (<-this.WatchPrivate(messageHashes, params))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         "a": {
    //             "B": [
    //                 {
    //                     "a": "USDC",
    //                     "ba": "0",
    //                     "im": "1.46282986",
    //                     "om": "0",
    //                     "tfm": "1.46282986",
    //                     "wb": "109.86879703"
    //                 }
    //             ],
    //             "m": "ORDER",
    //             "p": [
    //                 {
    //                     "S": "1",
    //                     "ap": "2925.81666667",
    //                     "c": "USDC",
    //                     "ct": "FUTURE",
    //                     "l": 2,
    //                     "lq": "1471.1840621072728637",
    //                     "lv": "0",
    //                     "ma": "0",
    //                     "mt": "ISOLATED",
    //                     "pm": "1.4628298566666665",
    //                     "pt": "ONEWAY",
    //                     "rp": "-0.00036721",
    //                     "s": "ETH-USDC",
    //                     "t": "0",
    //                     "uq": "0.001",
    //                     "v": "1"
    //                 }
    //             ]
    //         },
    //         "T": 1766592694451,
    //         "E": 1766592694554,
    //         "e": "ACCOUNT_UPDATE"
    //     }
    //
    var data interface{} = this.SafeDict(message, "a", map[string]interface{} {})
    var positionsData interface{} = this.SafeList(data, "p", []interface{}{})
    var rawPosition interface{} = this.SafeDict(positionsData, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(rawPosition, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = "positions"
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var parsedPosition interface{} = this.ParseWsPosition(rawPosition, market)
    var timestamp interface{} = this.SafeInteger(message, "T")
    ccxt.AddElementToObject(parsedPosition, "timestamp", timestamp)
    ccxt.AddElementToObject(parsedPosition, "datetime", this.Iso8601(timestamp))
    cache.(ccxt.Appender).Append(parsedPosition)
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, messageHash)
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, symbolMessageHash)
}
func  (this *BydfiCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "S": "1",
    //         "ap": "2925.81666667",
    //         "c": "USDC",
    //         "ct": "FUTURE",
    //         "l": 2,
    //         "lq": "1471.1840621072728637",
    //         "lv": "0",
    //         "ma": "0",
    //         "mt": "ISOLATED",
    //         "pm": "1.4628298566666665",
    //         "pt": "ONEWAY",
    //         "rp": "-0.00036721",
    //         "s": "ETH-USDC",
    //         "t": "0",
    //         "uq": "0.001",
    //         "v": "1"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "s")
    market = this.SafeMarket(marketId, market)
    var rawPositionSide interface{} = this.SafeString(position, "S")
    var positionMode interface{} = this.SafeString(position, "pt")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "id"),
        "symbol": ccxt.GetValue(market, "symbol"),
        "entryPrice": this.ParseNumber(this.SafeString(position, "ap")),
        "markPrice": nil,
        "lastPrice": nil,
        "notional": nil,
        "collateral": nil,
        "unrealizedPnl": nil,
        "realizedPnl": this.ParseNumber(this.SafeString(position, "rp")),
        "side": this.ParseWsPositionSide(rawPositionSide),
        "contracts": this.ParseNumber(this.SafeString(position, "v")),
        "contractSize": this.ParseNumber(this.SafeString(position, "uq")),
        "timestamp": nil,
        "datetime": nil,
        "lastUpdateTimestamp": nil,
        "hedged": (!ccxt.IsEqual(positionMode, "ONEWAY")),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "initialMargin": this.ParseNumber(this.SafeString(position, "pm")),
        "initialMarginPercentage": nil,
        "leverage": this.SafeInteger(position, "l"),
        "liquidationPrice": this.ParseNumber(this.SafeString(position, "lq")),
        "marginRatio": nil,
        "marginMode": this.SafeStringLower(position, "mt"),
        "percentage": nil,
    })
}
func  (this *BydfiCore) ParseWsPositionSide(rawPositionSide interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "1": "long",
        "2": "short",
    }
    return this.SafeString(sides, rawPositionSide, rawPositionSide)
}
/**
 * @method
 * @name bydfi#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://developers.bydfi.com/en/swap/websocket-account#balance-and-position-update-push
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BydfiCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8848 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8848)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            this.FetchBalanceSnapshot(client)
            var options interface{} = this.SafeDict(this.Options, "watchBalance")
            var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
            var awaitBalanceSnapshot interface{} = this.SafeBool(options, "awaitBalanceSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes89212 := (<-client.(ccxt.ClientInterface).Future("fetchBalanceSnapshot"))
                ccxt.PanicOnError(retRes89212)
            }
            var messageHash interface{} = "balance"
        
                retRes89515 :=  (<-this.WatchPrivate([]interface{}{messageHash}, params))
                ccxt.PanicOnError(retRes89515)
                ch <- retRes89515
                return nil
        
            }()
            return ch
        }
func  (this *BydfiCore) FetchBalanceSnapshot(client interface{})  {
    var options interface{} = this.SafeValue(this.Options, "watchBalance")
    var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
    if ccxt.IsTrue(fetchBalanceSnapshot) {
        var messageHash interface{} = "fetchBalanceSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash)
        }
    }
}
func  (this *BydfiCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": "swap",
            }
        
            response:= (<-this.FetchBalance(params))
            ccxt.PanicOnError(response)
            this.Balance = this.Extend(response, this.Balance)
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve()
            client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
                return nil
            }()
            return ch
        }
func  (this *BydfiCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "a": {
    //             "B": [
    //                 {
    //                     "a": "USDC",
    //                     "ba": "0",
    //                     "im": "1.46282986",
    //                     "om": "0",
    //                     "tfm": "1.46282986",
    //                     "wb": "109.86879703"
    //                 }
    //             ],
    //             "m": "ORDER",
    //             "p": [
    //                 {
    //                     "S": "1",
    //                     "ap": "2925.81666667",
    //                     "c": "USDC",
    //                     "ct": "FUTURE",
    //                     "l": 2,
    //                     "lq": "1471.1840621072728637",
    //                     "lv": "0",
    //                     "ma": "0",
    //                     "mt": "ISOLATED",
    //                     "pm": "1.4628298566666665",
    //                     "pt": "ONEWAY",
    //                     "rp": "-0.00036721",
    //                     "s": "ETH-USDC",
    //                     "t": "0",
    //                     "uq": "0.001",
    //                     "v": "1"
    //                 }
    //             ]
    //         },
    //         "T": 1766592694451,
    //         "E": 1766592694554,
    //         "e": "ACCOUNT_UPDATE"
    //     }
    //
    var messageHash interface{} = "balance"
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
        var data interface{} = this.SafeDict(message, "a", map[string]interface{} {})
        var balances interface{} = this.SafeList(data, "B", []interface{}{})
        var timestamp interface{} = this.SafeInteger(message, "T")
        var result interface{} = map[string]interface{} {
            "info": message,
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
            var balance interface{} = ccxt.GetValue(balances, i)
            var currencyId interface{} = this.SafeString(balance, "a")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            ccxt.AddElementToObject(account, "total", this.SafeString(balance, "wb"))
            ccxt.AddElementToObject(account, "used", this.SafeString(balance, "tfm"))
            ccxt.AddElementToObject(result, code, account)
        }
        var parsedBalance interface{} = this.SafeBalance(result)
        this.Balance = this.Extend(this.Balance, parsedBalance)
        client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
    }
}
func  (this *BydfiCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "result": true,
    //         "id": 1
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeDict(subscriptionsById, id, map[string]interface{} {})
    var isUnSubMessage interface{} = this.SafeBool(subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSubMessage) {
        this.HandleUnSubscription(client, subscription)
    }
    return message
}
func  (this *BydfiCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subHashIsPrefix interface{} = this.SafeBool(subscription, "subHashIsPrefix", false)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, i)
        var subHash interface{} = ccxt.Replace(unsubHash, "unsubscribe::", "")
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash, subHashIsPrefix)
    }
    this.CleanCache(subscription)
}
func  (this *BydfiCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "id": 1,
    //         "result": "pong"
    //     }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *BydfiCore) HandleErrorMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "msg": "Service error",
    //         "code": "-1"
    //     }
    //
    var code interface{} = this.SafeString(message, "code")
    var msg interface{} = this.SafeString(message, "msg")
    var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), msg, feedback)
    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), msg, feedback)
    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
    panic(ccxt.ExchangeError(feedback))
}
func  (this *BydfiCore) HandleMessage(client interface{}, message interface{})  {
    var code interface{} = this.SafeString(message, "code")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(code, nil)) && ccxt.IsTrue((!ccxt.IsEqual(code, "0")))) {
        this.HandleErrorMessage(client, message)
    }
    var result interface{} = this.SafeString(message, "result")
    if ccxt.IsTrue(ccxt.IsEqual(result, "pong")) {
        this.HandlePong(client, message)
    } else if ccxt.IsTrue(!ccxt.IsEqual(result, nil)) {
        this.HandleSubscriptionStatus(client, message)
    } else {
        var event interface{} = this.SafeString(message, "e")
        if ccxt.IsTrue(ccxt.IsEqual(event, "24hrTicker")) {
            this.HandleTicker(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "kline")) {
            this.HandleOHLCV(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "depthUpdate")) {
            this.HandleOrderBook(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "ORDER_TRADE_UPDATE")) {
            this.HandleOrder(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "ACCOUNT_UPDATE")) {
            var account interface{} = this.SafeDict(message, "a", map[string]interface{} {})
            var balances interface{} = this.SafeList(account, "B", []interface{}{})
            var balancesLength interface{} =             ccxt.GetArrayLength(balances)
            if ccxt.IsTrue(ccxt.IsGreaterThan(balancesLength, 0)) {
                this.HandleBalance(client, message)
            }
            var positions interface{} = this.SafeList(account, "p", []interface{}{})
            var positionsLength interface{} =             ccxt.GetArrayLength(positions)
            if ccxt.IsTrue(ccxt.IsGreaterThan(positionsLength, 0)) {
                this.HandlePositions(client, message)
            }
        }
    }
}


func (this *BydfiCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
