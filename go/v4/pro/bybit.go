package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BybitCore struct {
	*ccxt.BybitCore
	base *ccxt.BybitCore
}

func NewBybitCore() *BybitCore {
    p := &BybitCore{}
	base := &ccxt.BybitCore{}
	p.base = base
	p.BybitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BybitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": true,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "fetchTradesWs": false,
            "fetchBalanceWs": false,
            "watchBalance": true,
            "watchBidsAsks": true,
            "watchLiquidations": true,
            "watchLiquidationsForSymbols": false,
            "watchMyLiquidations": false,
            "watchMyLiquidationsForSymbols": false,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchPositions": true,
            "watchTradesForSymbols": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchOHLCV": true,
            "unWatchOHLCVForSymbols": true,
            "unWatchOrderBook": true,
            "unWatchOrderBookForSymbols": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchMyTrades": true,
            "unWatchOrders": true,
            "unWatchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": map[string]interface{} {
                        "spot": "wss://stream.{hostname}/v5/public/spot",
                        "inverse": "wss://stream.{hostname}/v5/public/inverse",
                        "option": "wss://stream.{hostname}/v5/public/option",
                        "linear": "wss://stream.{hostname}/v5/public/linear",
                    },
                    "private": map[string]interface{} {
                        "spot": map[string]interface{} {
                            "unified": "wss://stream.{hostname}/v5/private",
                            "nonUnified": "wss://stream.{hostname}/spot/private/v3",
                        },
                        "contract": "wss://stream.{hostname}/v5/private",
                        "usdc": "wss://stream.{hostname}/trade/option/usdc/private/v1",
                        "trade": "wss://stream.bybit.com/v5/trade",
                    },
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": map[string]interface{} {
                        "spot": "wss://stream-testnet.{hostname}/v5/public/spot",
                        "inverse": "wss://stream-testnet.{hostname}/v5/public/inverse",
                        "linear": "wss://stream-testnet.{hostname}/v5/public/linear",
                        "option": "wss://stream-testnet.{hostname}/v5/public/option",
                    },
                    "private": map[string]interface{} {
                        "spot": map[string]interface{} {
                            "unified": "wss://stream-testnet.{hostname}/v5/private",
                            "nonUnified": "wss://stream-testnet.{hostname}/spot/private/v3",
                        },
                        "contract": "wss://stream-testnet.{hostname}/v5/private",
                        "usdc": "wss://stream-testnet.{hostname}/trade/option/usdc/private/v1",
                        "trade": "wss://stream-testnet.bybit.com/v5/trade",
                    },
                },
            },
            "demotrading": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": map[string]interface{} {
                        "spot": "wss://stream.{hostname}/v5/public/spot",
                        "inverse": "wss://stream.{hostname}/v5/public/inverse",
                        "option": "wss://stream.{hostname}/v5/public/option",
                        "linear": "wss://stream.{hostname}/v5/public/linear",
                    },
                    "private": map[string]interface{} {
                        "spot": map[string]interface{} {
                            "unified": "wss://stream-demo.{hostname}/v5/private",
                            "nonUnified": "wss://stream-demo.{hostname}/spot/private/v3",
                        },
                        "contract": "wss://stream-demo.{hostname}/v5/private",
                        "usdc": "wss://stream-demo.{hostname}/trade/option/usdc/private/v1",
                        "trade": "wss://stream-demo.bybit.com/v5/trade",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "watchTicker": map[string]interface{} {
                "name": "tickers",
            },
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
            "watchMyTrades": map[string]interface{} {
                "filterExecTypes": []interface{}{"ccxt.Trade", "AdlTrade", "BustTrade", "Settle"},
            },
            "spot": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "1h",
                    "2h": "2h",
                    "4h": "4h",
                    "6h": "6h",
                    "12h": "12h",
                    "1d": "1d",
                    "1w": "1w",
                    "1M": "1M",
                },
            },
            "contract": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1",
                    "3m": "3",
                    "5m": "5",
                    "15m": "15",
                    "30m": "30",
                    "1h": "60",
                    "2h": "120",
                    "4h": "240",
                    "6h": "360",
                    "12h": "720",
                    "1d": "D",
                    "1w": "W",
                    "1M": "M",
                },
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 18000,
        },
    })
}
func  (this *BybitCore) RequestId() interface{}  {
    this.LockId()
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    this.UnlockId()
    return requestId
}
func  (this *BybitCore) GetUrlByMarketType(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            isPrivate := ccxt.GetArg(optionalArgs, 1, false)
            _ = isPrivate
            method := ccxt.GetArg(optionalArgs, 2, nil)
            _ = method
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var accessibility interface{} = ccxt.Ternary(ccxt.IsTrue(isPrivate), "private", "public")
            var isUsdcSettled interface{} = nil
            var isSpot interface{} = nil
            var typeVar interface{} = nil
            var market interface{} = nil
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                isUsdcSettled = ccxt.IsEqual(ccxt.GetValue(market, "settle"), "USDC")
                typeVar = ccxt.GetValue(market, "type")
            } else {
                typeVarparamsVariable := this.HandleMarketTypeAndParams(method, nil, params)
                typeVar = ccxt.GetValue(typeVarparamsVariable,0)
                params = ccxt.GetValue(typeVarparamsVariable,1)
                var defaultSettle interface{} = this.SafeString(this.Options, "defaultSettle")
                defaultSettle = this.SafeString2(params, "settle", "defaultSettle", defaultSettle)
                isUsdcSettled = (ccxt.IsEqual(defaultSettle, "USDC"))
            }
            isSpot = (ccxt.IsEqual(typeVar, "spot"))
            if ccxt.IsTrue(isPrivate) {
        
                unified:= (<-this.IsUnifiedEnabled())
                ccxt.PanicOnError(unified)
                var isUnifiedMargin interface{} = this.SafeBool(unified, 0, false)
                var isUnifiedAccount interface{} = this.SafeBool(unified, 1, false)
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isUsdcSettled) && !ccxt.IsTrue(isUnifiedMargin)) && !ccxt.IsTrue(isUnifiedAccount)) {
                    url = ccxt.GetValue(ccxt.GetValue(url, accessibility), "usdc")
                } else {
                    url = ccxt.GetValue(ccxt.GetValue(url, accessibility), "contract")
                }
            } else {
                if ccxt.IsTrue(isSpot) {
                    url = ccxt.GetValue(ccxt.GetValue(url, accessibility), "spot")
                } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "swap"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "future")))) {
                    var subType interface{} = nil
                    subTypeparamsVariable := this.HandleSubTypeAndParams(method, market, params, "linear")
                    subType = ccxt.GetValue(subTypeparamsVariable,0)
                    params = ccxt.GetValue(subTypeparamsVariable,1)
                    url = ccxt.GetValue(ccxt.GetValue(url, accessibility), subType)
                } else {
                    // option
                    url = ccxt.GetValue(ccxt.GetValue(url, accessibility), "option")
                }
            }
            url = this.ImplodeHostname(url)
        
            ch <- url
            return nil
        
            }()
            return ch
        }
func  (this *BybitCore) CleanParams(params interface{}) interface{}  {
    params = this.Omit(params, []interface{}{"type", "subType", "settle", "defaultSettle", "unifiedMargin"})
    return params
}
/**
 * @method
 * @name bybit#createOrderWs
 * @description create a trade order
 * @see https://bybit-exchange.github.io/docs/v5/order/create-order
 * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK"
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {string} [params.positionIdx] *contracts only*  0 for one-way mode, 1 buy side  of hedged mode, 2 sell side of hedged mode
 * @param {boolean} [params.isLeverage] *unified spot only* false then spot trading true then margin trading
 * @param {string} [params.tpslMode] *contract only* 'full' or 'partial'
 * @param {string} [params.mmp] *option only* market maker protection
 * @param {string} [params.triggerDirection] *contract only* the direction for trigger orders, 'above' or 'below'
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
 * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2588)
            var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params, true)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "trade")
        
            retRes2618 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes2618)
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "op": "order.create",
                "reqId": requestId,
                "args": []interface{}{orderRequest},
                "header": map[string]interface{} {
                    "X-BAPI-TIMESTAMP": ccxt.ToString(this.Milliseconds()),
                    "X-BAPI-RECV-WINDOW": ccxt.ToString(ccxt.GetValue(this.Options, "recvWindow")),
                },
            }
        
                retRes27415 :=  (<-this.Watch(url, requestId, request, requestId, true))
                ccxt.PanicOnError(retRes27415)
                ch <- retRes27415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#editOrderWs
 * @description edit a trade order
 * @see https://bybit-exchange.github.io/docs/v5/order/amend-order
 * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price that a trigger order is triggered at
 * @param {float} [params.stopLossPrice] The price that a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price that a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice that the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice that the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {string} [params.triggerBy] 'IndexPrice', 'MarkPrice' or 'ccxt.LastPrice', default is 'ccxt.LastPrice', required if no initial value for triggerPrice
 * @param {string} [params.slTriggerBy] 'IndexPrice', 'MarkPrice' or 'ccxt.LastPrice', default is 'ccxt.LastPrice', required if no initial value for stopLoss
 * @param {string} [params.tpTriggerby] 'IndexPrice', 'MarkPrice' or 'ccxt.LastPrice', default is 'ccxt.LastPrice', required if no initial value for takeProfit
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3038)
            var orderRequest interface{} = this.EditOrderRequest(id, symbol, typeVar, side, amount, price, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "trade")
        
            retRes3068 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes3068)
            var requestId interface{} = ccxt.ToString(this.RequestId())
            var request interface{} = map[string]interface{} {
                "op": "order.amend",
                "reqId": requestId,
                "args": []interface{}{orderRequest},
                "header": map[string]interface{} {
                    "X-BAPI-TIMESTAMP": ccxt.ToString(this.Milliseconds()),
                    "X-BAPI-RECV-WINDOW": ccxt.ToString(ccxt.GetValue(this.Options, "recvWindow")),
                },
            }
        
                retRes31915 :=  (<-this.Watch(url, requestId, request, requestId, true))
                ccxt.PanicOnError(retRes31915)
                ch <- retRes31915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#cancelOrderWs
 * @description cancels an open order
 * @see https://bybit-exchange.github.io/docs/v5/order/cancel-order
 * @see https://bybit-exchange.github.io/docs/v5/websocket/trade/guideline#createamendcancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] *spot only* whether the order is a trigger order
 * @param {string} [params.orderFilter] *spot only* 'ccxt.Order' or 'StopOrder' or 'tpslOrder'
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3368)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " cancelOrderWs() requires a symbol argument")))
            }
            var orderRequest interface{} = this.CancelOrderRequest(id, symbol, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "trade")
        
            retRes3428 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes3428)
            var requestId interface{} = ccxt.ToString(this.RequestId())
            if ccxt.IsTrue(ccxt.InOp(orderRequest, "orderFilter")) {
                ccxt.Remove(orderRequest, "orderFilter")
            }
            var request interface{} = map[string]interface{} {
                "op": "order.cancel",
                "reqId": requestId,
                "args": []interface{}{orderRequest},
                "header": map[string]interface{} {
                    "X-BAPI-TIMESTAMP": ccxt.ToString(this.Milliseconds()),
                    "X-BAPI-RECV-WINDOW": ccxt.ToString(ccxt.GetValue(this.Options, "recvWindow")),
                },
            }
        
                retRes35815 :=  (<-this.Watch(url, requestId, request, requestId, true))
                ccxt.PanicOnError(retRes35815)
                ch <- retRes35815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BybitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3728)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
        
            url:= (<-this.GetUrlByMarketType(symbol, false, "watchTicker", params))
            ccxt.PanicOnError(url)
            params = this.CleanParams(params)
            var options interface{} = this.SafeValue(this.Options, "watchTicker", map[string]interface{} {})
            var topic interface{} = this.SafeString(options, "name", "tickers")
            if ccxt.IsTrue(!ccxt.IsTrue(ccxt.GetValue(market, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(topic, "tickers"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTicker() only supports name tickers for contract markets")))
            }
            topic = ccxt.Add(topic, ccxt.Add(".", ccxt.GetValue(market, "id")))
            var topics interface{} = []interface{}{topic}
        
                retRes38515 :=  (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
                ccxt.PanicOnError(retRes38515)
                ch <- retRes38515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BybitCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3998)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchTickers", params))
            ccxt.PanicOnError(url)
            params = this.CleanParams(params)
            var options interface{} = this.SafeValue(this.Options, "watchTickers", map[string]interface{} {})
            var topic interface{} = this.SafeString(options, "name", "tickers")
            var marketIds interface{} = this.MarketIds(symbols)
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(topic, "."), marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(symbols, i)))
            }
        
            ticker:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchTickers
 * @description unWatches a price ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BybitCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4338 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4338)
            symbols = this.MarketSymbols(symbols, nil, false)
            var options interface{} = this.SafeValue(this.Options, "watchTickers", map[string]interface{} {})
            var topic interface{} = this.SafeString(options, "name", "tickers")
            var messageHashes interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var marketIds interface{} = this.MarketIds(symbols)
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(topic, "."), marketId))
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("ticker:", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", symbol))
            }
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchTickers", params))
            ccxt.PanicOnError(url)
        
                retRes44915 :=  (<-this.UnWatchTopics(url, "ticker", symbols, messageHashes, subMessageHashes, topics, params))
                ccxt.PanicOnError(retRes44915)
                ch <- retRes44915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchTicker
 * @description unWatches a price ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
 * @param {string[]} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BybitCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4638)
        
                retRes46415 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes46415)
                ch <- retRes46415
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleTicker(client interface{}, message interface{})  {
    //
    // linear
    //     {
    //         "topic": "tickers.BTCUSDT",
    //         "type": "snapshot",
    //         "data": {
    //             "symbol": "BTCUSDT",
    //             "tickDirection": "PlusTick",
    //             "price24hPcnt": "0.017103",
    //             "lastPrice": "17216.00",
    //             "prevPrice24h": "16926.50",
    //             "highPrice24h": "17281.50",
    //             "lowPrice24h": "16915.00",
    //             "prevPrice1h": "17238.00",
    //             "markPrice": "17217.33",
    //             "indexPrice": "17227.36",
    //             "openInterest": "68744.761",
    //             "openInterestValue": "1183601235.91",
    //             "turnover24h": "1570383121.943499",
    //             "volume24h": "91705.276",
    //             "nextFundingTime": "1673280000000",
    //             "fundingRate": "-0.000212",
    //             "bid1Price": "17215.50",
    //             "bid1Size": "84.489",
    //             "ask1Price": "17216.00",
    //             "ask1Size": "83.020"
    //         },
    //         "cs": 24987956059,
    //         "ts": 1673272861686
    //     }
    //
    // option
    //     {
    //         "id": "tickers.BTC-6JAN23-17500-C-2480334983-1672917511074",
    //         "topic": "tickers.BTC-6JAN23-17500-C",
    //         "ts": 1672917511074,
    //         "data": {
    //             "symbol": "BTC-6JAN23-17500-C",
    //             "bidPrice": "0",
    //             "bidSize": "0",
    //             "bidIv": "0",
    //             "askPrice": "10",
    //             "askSize": "5.1",
    //             "askIv": "0.514",
    //             "lastPrice": "10",
    //             "highPrice24h": "25",
    //             "lowPrice24h": "5",
    //             "markPrice": "7.86976724",
    //             "indexPrice": "16823.73",
    //             "markPriceIv": "0.4896",
    //             "underlyingPrice": "16815.1",
    //             "openInterest": "49.85",
    //             "turnover24h": "446802.8473",
    //             "volume24h": "26.55",
    //             "totalVolume": "86",
    //             "totalTurnover": "1437431",
    //             "delta": "0.047831",
    //             "gamma": "0.00021453",
    //             "vega": "0.81351067",
    //             "theta": "-19.9115368",
    //             "predictedDeliveryPrice": "0",
    //             "change24h": "-0.33333334"
    //         },
    //         "type": "snapshot"
    //     }
    //
    // spot
    //     {
    //         "topic": "tickers.BTCUSDT",
    //         "ts": 1673853746002,
    //         "type": "snapshot",
    //         "cs": 2588407389,
    //         "data": {
    //             "symbol": "BTCUSDT",
    //             "lastPrice": "21109.77",
    //             "highPrice24h": "21426.99",
    //             "lowPrice24h": "20575",
    //             "prevPrice24h": "20704.93",
    //             "volume24h": "6780.866843",
    //             "turnover24h": "141946527.22907118",
    //             "price24hPcnt": "0.0196",
    //             "usdIndexPrice": "21120.2400136"
    //         }
    //     }
    //
    // lt ticker
    //     {
    //         "topic": "tickers_lt.EOS3LUSDT",
    //         "ts": 1672325446847,
    //         "type": "snapshot",
    //         "data": {
    //             "symbol": "EOS3LUSDT",
    //             "lastPrice": "0.41477848043290448",
    //             "highPrice24h": "0.435285472510871305",
    //             "lowPrice24h": "0.394601507960931382",
    //             "prevPrice24h": "0.431502290172376349",
    //             "price24hPcnt": "-0.0388"
    //         }
    //     }
    // swap delta
    //     {
    //         "topic":"tickers.AAVEUSDT",
    //         "type":"delta",
    //         "data":{
    //            "symbol":"AAVEUSDT",
    //            "bid1Price":"112.89",
    //            "bid1Size":"2.12",
    //            "ask1Price":"112.90",
    //            "ask1Size":"5.02"
    //         },
    //         "cs":78039939929,
    //         "ts":1709210212704
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic", "")
    var updateType interface{} = this.SafeString(message, "type", "")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var isSpot interface{} = !ccxt.IsEqual(this.SafeString(data, "usdIndexPrice"), nil)
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
    var symbol interface{} = nil
    var parsed interface{} = nil
    if ccxt.IsTrue((ccxt.IsEqual(updateType, "snapshot"))) {
        parsed = this.ParseTicker(data)
        symbol = ccxt.GetValue(parsed, "symbol")
    } else if ccxt.IsTrue(ccxt.IsEqual(updateType, "delta")) {
        var topicParts interface{} = ccxt.Split(topic, ".")
        var topicLength interface{} =         ccxt.GetArrayLength(topicParts)
        var marketId interface{} = this.SafeString(topicParts, ccxt.Subtract(topicLength, 1))
        var market interface{} = this.SafeMarket(marketId, nil, nil, typeVar)
        symbol = ccxt.GetValue(market, "symbol")
        // update the info in place
        var ticker interface{} = this.SafeDict(this.Tickers, symbol, map[string]interface{} {})
        var rawTicker interface{} = this.SafeDict(ticker, "info", map[string]interface{} {})
        var merged interface{} = this.Extend(rawTicker, data)
        parsed = this.ParseTicker(merged)
    }
    var timestamp interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(parsed, "timestamp", timestamp)
    ccxt.AddElementToObject(parsed, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
/**
 * @method
 * @name bybit#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BybitCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6228)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchBidsAsks", params))
            ccxt.PanicOnError(url)
            params = this.CleanParams(params)
            var marketIds interface{} = this.MarketIds(symbols)
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var topic interface{} = ccxt.Add("orderbook.1.", marketId)
                ccxt.AppendToArray(&topics, topic)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(symbols, i)))
            }
        
            ticker:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- ticker
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BybitCore) ParseWsBidAsk(orderbook interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
    var bids interface{} = this.SortBy(this.Aggregate(ccxt.GetValue(orderbook, "bids")), 0)
    var asks interface{} = this.SortBy(this.Aggregate(ccxt.GetValue(orderbook, "asks")), 0)
    var bestBid interface{} = this.SafeList(bids, 0, []interface{}{})
    var bestAsk interface{} = this.SafeList(asks, 0, []interface{}{})
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(bestAsk, 0),
        "askVolume": this.SafeNumber(bestAsk, 1),
        "bid": this.SafeNumber(bestBid, 0),
        "bidVolume": this.SafeNumber(bestBid, 1),
        "info": orderbook,
    }, market)
}
/**
 * @method
 * @name bybit#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BybitCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BybitCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6928)
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstSymbol interface{} = ccxt.GetValue(marketSymbols, 0)
        
            url:= (<-this.GetUrlByMarketType(firstSymbol, false, "watchOHLCVForSymbols", params))
            ccxt.PanicOnError(url)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add("kline.", timeframeId), "."), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbolString), "::"), unfiedTimeframe))
            }
            symboltimeframestoredVariable := (<-this.WatchTopics(url, messageHashes, rawHashes, params))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BybitCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7288)
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, true, true)
            var firstSymbol interface{} = ccxt.GetValue(marketSymbols, 0)
        
            url:= (<-this.GetUrlByMarketType(firstSymbol, false, "watchOHLCVForSymbols", params))
            ccxt.PanicOnError(url)
            var rawHashes interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "symbol")
                var unfiedTimeframe interface{} = this.SafeString(data, 1)
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add("kline.", timeframeId), "."), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbolString), "::"), unfiedTimeframe))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe::ohlcv::", symbolString), "::"), unfiedTimeframe))
            }
            var subExtension interface{} = map[string]interface{} {
                "symbolsAndTimeframes": symbolsAndTimeframes,
            }
        
                retRes75015 :=  (<-this.UnWatchTopics(url, "ohlcv", symbols, messageHashes, subMessageHashes, rawHashes, params, subExtension))
                ccxt.PanicOnError(retRes75015)
                ch <- retRes75015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BybitCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
                retRes76615 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes76615)
                ch <- retRes76615
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "kline.5.BTCUSDT",
    //         "data": [
    //             {
    //                 "start": 1672324800000,
    //                 "end": 1672325099999,
    //                 "interval": "5",
    //                 "open": "16649.5",
    //                 "close": "16677",
    //                 "high": "16677",
    //                 "low": "16608",
    //                 "volume": "2.081",
    //                 "turnover": "34666.4005",
    //                 "confirm": false,
    //                 "timestamp": 1672324988882
    //             }
    //         ],
    //         "ts": 1672324988882,
    //         "type": "snapshot"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var topicParts interface{} = ccxt.Split(topic, ".")
    var topicLength interface{} =     ccxt.GetArrayLength(topicParts)
    var timeframeId interface{} = this.SafeString(topicParts, 1)
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var marketId interface{} = this.SafeString(topicParts, ccxt.Subtract(topicLength, 1))
    var isSpot interface{} = ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), ccxt.OpNeg(1))
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ohlcvsByTimeframe interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ohlcvsByTimeframe, nil)) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ohlcvsByTimeframe, timeframe), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var parsed interface{} = this.ParseWsOHLCV(ccxt.GetValue(data, i), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *BybitCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "start": 1670363160000,
    //         "end": 1670363219999,
    //         "interval": "1",
    //         "open": "16987.5",
    //         "close": "16987.5",
    //         "high": "16988",
    //         "low": "16987.5",
    //         "volume": "23.511",
    //         "turnover": "399396.344",
    //         "confirm": false,
    //         "timestamp": 1670363219614
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var volumeIndex interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.GetValue(market, "inverse"))), "turnover", "volume")
    return []interface{}{this.SafeInteger(ohlcv, "start"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, volumeIndex)}
}
/**
 * @method
 * @name bybit#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BybitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes85915 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes85915)
                ch <- retRes85915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BybitCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8738)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            symbols = this.MarketSymbols(symbols)
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchOrderBook", params))
            ccxt.PanicOnError(url)
            params = this.CleanParams(params)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 50
                if ccxt.IsTrue(ccxt.GetValue(market, "option")) {
                    limit = 100
                }
            } else {
                var limits interface{} = map[string]interface{} {
                    "spot": []interface{}{1, 50, 200, 1000},
                    "option": []interface{}{25, 100},
                    "default": []interface{}{1, 50, 200, 1000},
                }
                var selectedLimits interface{} = this.SafeList2(limits, ccxt.GetValue(market, "type"), "default")
                if !ccxt.IsTrue(this.InArray(limit, selectedLimits)) {
                    panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchOrderBookForSymbols(): for "), ccxt.GetValue(market, "type")), " markets limit can be one of: "), this.Json(selectedLimits))))
                }
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook.", ccxt.ToString(limit)), "."), marketId)
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("orderbook:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
        
            orderbook:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchOrderBookForSymbols
 * @description unsubscribe from the orderbook channel
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 * @param {string[]} symbols unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BybitCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9238 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9238)
            symbols = this.MarketSymbols(symbols, nil, false)
            var channel interface{} = "orderbook."
            var limit interface{} = this.SafeInteger(params, "limit")
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                params = this.Omit(params, "limit")
            } else {
                var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
                limit = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "spot")), 50, 500)
            }
            channel = ccxt.Add(channel, ccxt.ToString(limit))
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var topic interface{} = ccxt.Add(ccxt.Add(channel, "."), marketId)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("orderbook:", symbol))
                ccxt.AppendToArray(&topics, topic)
            }
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchOrderBook", params))
            ccxt.PanicOnError(url)
        
                retRes94715 :=  (<-this.UnWatchTopics(url, "orderbook", symbols, messageHashes, subMessageHashes, topics, params))
                ccxt.PanicOnError(retRes94715)
                ch <- retRes94715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 * @param {string} symbol symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BybitCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9618 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9618)
        
                retRes96215 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes96215)
                ch <- retRes96215
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "orderbook.50.BTCUSDT",
    //         "type": "snapshot",
    //         "ts": 1672304484978,
    //         "data": {
    //             "s": "BTCUSDT",
    //             "b": [
    //                 ...,
    //                 [
    //                     "16493.50",
    //                     "0.006"
    //                 ],
    //                 [
    //                     "16493.00",
    //                     "0.100"
    //                 ]
    //             ],
    //             "a": [
    //                 [
    //                     "16611.00",
    //                     "0.029"
    //                 ],
    //                 [
    //                     "16612.00",
    //                     "0.213"
    //                 ],
    //             ],
    //             "u": 18521288,
    //             "seq": 7961638724
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var limit interface{} = ccxt.GetValue(ccxt.Split(topic, "."), 1)
    var isSpot interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), 0)
    var typeVar interface{} = this.SafeString(message, "type")
    var isSnapshot interface{} =     (ccxt.IsEqual(typeVar, "snapshot"))
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    if ccxt.IsTrue(isSnapshot) {
        var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "b", "a")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeList(data, "a", []interface{}{})
        var bids interface{} = this.SafeList(data, "b", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    if ccxt.IsTrue(ccxt.IsEqual(limit, "1")) {
        var bidask interface{} = this.ParseWsBidAsk(ccxt.UnWrapType(ccxt.GetValue(this.Orderbooks, symbol)), market)
        var newBidsAsks interface{} = map[string]interface{} {}
        ccxt.AddElementToObject(newBidsAsks, symbol, bidask)
        ccxt.AddElementToObject(this.Bidsasks, symbol, bidask)
        client.(ccxt.ClientInterface).Resolve(newBidsAsks, ccxt.Add("bidask:", symbol))
    }
}
func  (this *BybitCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *BybitCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name bybit#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *BybitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes106115 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes106115)
                ch <- retRes106115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BybitCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes10768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10768)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
            params = this.CleanParams(params)
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "watchTrades", params))
            ccxt.PanicOnError(url)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add("publicTrade.", ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("trade:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
        
            trades:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchTradesForSymbols
 * @description unsubscribe from the trades channel
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
 * @param {string[]} symbols unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *BybitCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11138)
            symbols = this.MarketSymbols(symbols, nil, false, true)
        
            url:= (<-this.GetUrlByMarketType(ccxt.GetValue(symbols, 0), false, "unWatchTradesForSymbols", params))
            ccxt.PanicOnError(url)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add("publicTrade.", ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("unsubscribe:trade:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("trade:", symbol))
            }
        
                retRes112815 :=  (<-this.UnWatchTopics(url, "trades", symbols, messageHashes, subMessageHashes, topics, params))
                ccxt.PanicOnError(retRes112815)
                ch <- retRes112815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchTrades
 * @description unsubscribe from the trades channel
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
 * @param {string} symbol unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *BybitCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11418)
        
                retRes114215 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes114215)
                ch <- retRes114215
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "publicTrade.BTCUSDT",
    //         "type": "snapshot",
    //         "ts": 1672304486868,
    //         "data": [
    //             {
    //                 "T": 1672304486865,
    //                 "s": "BTCUSDT",
    //                 "S": "Buy",
    //                 "v": "0.001",
    //                 "p": "16578.50",
    //                 "L": "PlusTick",
    //                 "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
    //                 "BT": false
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var trades interface{} = data
    var parts interface{} = ccxt.Split(topic, ".")
    var isSpot interface{} = ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), 0)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var marketId interface{} = this.SafeString(parts, 1)
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        var parsed interface{} = this.ParseWsTrade(ccxt.GetValue(trades, j), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *BybitCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public
    //    {
    //         "T": 1672304486865,
    //         "s": "BTCUSDT",
    //         "S": "Buy",
    //         "v": "0.001",
    //         "p": "16578.50",
    //         "L": "PlusTick",
    //         "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
    //         "BT": false
    //     }
    //
    // spot private
    //     {
    //         "e": "ticketInfo",
    //         "E": "1662348310386",
    //         "s": "BTCUSDT",
    //         "q": "0.001007",
    //         "t": "1662348310373",
    //         "p": "19842.02",
    //         "T": "2100000000002220938",
    //         "o": "1238261807653647872",
    //         "c": "spotx008",
    //         "O": "1238225004531834368",
    //         "a": "533287",
    //         "A": "642908",
    //         "m": false,
    //         "S": "BUY"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeStringN(trade, []interface{}{"i", "T", "v"})
    var isContract interface{} =     (ccxt.InOp(trade, "BT"))
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isContract), "contract", "spot")
    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
        marketType = ccxt.GetValue(market, "type")
    }
    var marketId interface{} = this.SafeString(trade, "s")
    market = this.SafeMarket(marketId, market, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger2(trade, "t", "T")
    var side interface{} = this.SafeStringLower(trade, "S")
    var takerOrMaker interface{} = nil
    var m interface{} = this.SafeValue(trade, "m")
    if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
        side = ccxt.Ternary(ccxt.IsTrue(m), "buy", "sell")
    } else {
        // spot private
        takerOrMaker = m
    }
    var price interface{} = this.SafeString(trade, "p")
    var amount interface{} = this.SafeString2(trade, "q", "v")
    var orderId interface{} = this.SafeString(trade, "o")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *BybitCore) GetPrivateType(url interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "spot"), 0)) {
        return "spot"
    } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "v5/private"), 0)) {
        return "unified"
    } else {
        return "usdc"
    }
}
/**
 * @method
 * @name bybit#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/execution
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/fast-execution
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @param {boolean} [params.executionFast] use fast execution
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var method interface{} = "watchMyTrades"
            var messageHash interface{} = "myTrades"
        
            retRes12868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12868)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            url:= (<-this.GetUrlByMarketType(symbol, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes12928 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes12928)
            var topicByMarket interface{} = map[string]interface{} {
                "spot": "ticketInfo",
                "unified": "execution",
                "usdc": "user.openapi.perp.trade",
            }
            var topic interface{} = this.SafeValue(topicByMarket, this.GetPrivateType(url))
            var executionFast interface{} = false
            executionFastparamsVariable := this.HandleOptionAndParams(params, "watchMyTrades", "executionFast", false)
            executionFast = ccxt.GetValue(executionFastparamsVariable,0)
            params = ccxt.GetValue(executionFastparamsVariable,1)
            if ccxt.IsTrue(executionFast) {
                topic = "execution.fast"
            }
        
            trades:= (<-this.WatchTopics(url, []interface{}{messageHash}, []interface{}{topic}, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchMyTrades
 * @description unWatches information on multiple trades made by the user
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/execution
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/fast-execution
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @param {boolean} [params.executionFast] use fast execution
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) UnWatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var method interface{} = "watchMyTrades"
            var messageHash interface{} = "unsubscribe:myTrades"
            var subHash interface{} = "myTrades"
        
            retRes13278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13278)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchMyTrades() does not support a symbol parameter, you must unwatch all my trades")))
            }
        
            url:= (<-this.GetUrlByMarketType(symbol, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes13328 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes13328)
            var topicByMarket interface{} = map[string]interface{} {
                "spot": "ticketInfo",
                "unified": "execution",
                "usdc": "user.openapi.perp.trade",
            }
            var topic interface{} = this.SafeValue(topicByMarket, this.GetPrivateType(url))
            var executionFast interface{} = false
            executionFastparamsVariable := this.HandleOptionAndParams(params, "watchMyTrades", "executionFast", false)
            executionFast = ccxt.GetValue(executionFastparamsVariable,0)
            params = ccxt.GetValue(executionFastparamsVariable,1)
            if ccxt.IsTrue(executionFast) {
                topic = "execution.fast"
            }
        
                retRes134415 :=  (<-this.UnWatchTopics(url, "myTrades", []interface{}{}, []interface{}{messageHash}, []interface{}{subHash}, []interface{}{topic}, params))
                ccxt.PanicOnError(retRes134415)
                ch <- retRes134415
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "type": "snapshot",
    //        "topic": "ticketInfo",
    //        "ts": "1662348310388",
    //        "data": [
    //            {
    //                "e": "ticketInfo",
    //                "E": "1662348310386",
    //                "s": "BTCUSDT",
    //                "q": "0.001007",
    //                "t": "1662348310373",
    //                "p": "19842.02",
    //                "T": "2100000000002220938",
    //                "o": "1238261807653647872",
    //                "c": "spotx008",
    //                "O": "1238225004531834368",
    //                "a": "533287",
    //                "A": "642908",
    //                "m": false,
    //                "S": "BUY"
    //            }
    //        ]
    //    }
    // unified
    //     {
    //         "id": "592324803b2785-26fa-4214-9963-bdd4727f07be",
    //         "topic": "execution",
    //         "creationTime": 1672364174455,
    //         "data": [
    //             {
    //                 "category": "linear",
    //                 "symbol": "XRPUSDT",
    //                 "execFee": "0.005061",
    //                 "execId": "7e2ae69c-4edf-5800-a352-893d52b446aa",
    //                 "execPrice": "0.3374",
    //                 "execQty": "25",
    //                 "execType": "ccxt.Trade",
    //                 "execValue": "8.435",
    //                 "isMaker": false,
    //                 "feeRate": "0.0006",
    //                 "tradeIv": "",
    //                 "markIv": "",
    //                 "blockTradeId": "",
    //                 "markPrice": "0.3391",
    //                 "indexPrice": "",
    //                 "underlyingPrice": "",
    //                 "leavesQty": "0",
    //                 "orderId": "f6e324ff-99c2-4e89-9739-3086e47f9381",
    //                 "orderLinkId": "",
    //                 "orderPrice": "0.3207",
    //                 "orderQty": "25",
    //                 "orderType": "ccxt.Market",
    //                 "stopOrderType": "UNKNOWN",
    //                 "side": "Sell",
    //                 "execTime": "1672364174443",
    //                 "isLeverage": "0"
    //             }
    //         ]
    //     }
    //
    // execution.fast
    //
    //     {
    //         "topic": "execution.fast",
    //         "creationTime": 1757405601981,
    //         "data": [
    //             {
    //                 "category": "linear",
    //                 "symbol": "BTCUSDT",
    //                 "execId": "ffcac6ac-7571-536d-a28a-847dd7d08a0f",
    //                 "execPrice": "112529.6",
    //                 "execQty": "0.001",
    //                 "orderId": "6e25ab73-7a55-4ae7-adc2-8ea95f167c85",
    //                 "isMaker": false,
    //                 "orderLinkId": "test-00001",
    //                 "side": "Buy",
    //                 "execTime": "1757405601977",
    //                 "seq": 9515624038
    //             }
    //         ]
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var spot interface{} = ccxt.IsEqual(topic, "ticketInfo")
    var executionFast interface{} = ccxt.IsEqual(topic, "execution.fast")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    if !ccxt.IsTrue(ccxt.IsArray(data)) {
        data = this.SafeValue(data, "result", []interface{}{})
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trades interface{} = this.MyTrades
    var symbols interface{} = map[string]interface{} {}
    var filterExecTypes interface{} = this.HandleOption("watchMyTrades", "filterExecTypes", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawTrade interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = nil
        if ccxt.IsTrue(ccxt.IsTrue(spot) && !ccxt.IsTrue(executionFast)) {
            parsed = this.ParseWsTrade(rawTrade)
        } else {
            // filter unified trades
            var execType interface{} = this.SafeString(rawTrade, "execType", "")
            if ccxt.IsTrue(executionFast) {
                execType = "ccxt.Trade"
            }
            if !ccxt.IsTrue(this.InArray(execType, filterExecTypes)) {
                continue
            }
            parsed = this.ParseTrade(rawTrade)
        }
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        trades.(ccxt.Appender).Append(parsed)
    }
    var keys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var currentMessageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(keys, i))
        client.(ccxt.ClientInterface).Resolve(trades, currentMessageHash)
    }
    // non-symbol specific
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name bybit#watchPositions
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/position
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BybitCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14888)
            var method interface{} = "watchPositions"
            var messageHash interface{} = ""
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.MarketSymbols(symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var firstSymbol interface{} = this.SafeString(symbols, 0)
        
            url:= (<-this.GetUrlByMarketType(firstSymbol, true, method, params))
            ccxt.PanicOnError(url)
            messageHash = ccxt.Add("positions", messageHash)
            var client interface{} = this.Client(url)
        
            retRes14998 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes14998)
            this.SetPositionsCache(client, symbols)
            var cache interface{} = this.Positions
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(cache, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
            var topics interface{} = []interface{}{"position"}
        
            newPositions:= (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BybitCore) SetPositionsCache(client interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    if ccxt.IsTrue(!ccxt.IsEqual(this.Positions, nil)) {
        return
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    } else {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
}
func  (this *BybitCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // as only one ws channel gives positions for all types, for snapshot must load all positions
            var fetchFunctions interface{} = []interface{}{this.FetchPositions(nil, map[string]interface{} {
            "type": "swap",
            "subType": "linear",
        }), this.FetchPositions(nil, map[string]interface{} {
            "type": "swap",
            "subType": "inverse",
        })}
        
            promises:= (<-ccxt.PromiseAll(fetchFunctions))
            ccxt.PanicOnError(promises)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(promises)); i++ {
                var positions interface{} = ccxt.GetValue(promises, i)
                for ii := 0; ccxt.IsLessThan(ii, ccxt.GetArrayLength(positions)); ii++ {
                    var position interface{} = ccxt.GetValue(positions, ii)
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "position")
            }
                return nil
            }()
            return ch
        }
func  (this *BybitCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        topic: 'position',
    //        id: '504b2671629b08e3c4f6960382a59363:3bc4028023786545:0:01',
    //        creationTime: 1694566055295,
    //        data: [{
    //            bustPrice: '15.00',
    //            category: 'inverse',
    //            createdTime: '1670083436351',
    //            cumRealisedPnl: '0.00011988',
    //            entryPrice: '19358.58553268',
    //            leverage: '10',
    //            liqPrice: '15.00',
    //            markPrice: '25924.00',
    //            positionBalance: '0.0000156',
    //            positionIdx: 0,
    //            positionMM: '0.001',
    //            positionIM: '0.0000015497',
    //            positionStatus: 'Normal',
    //            positionValue: '0.00015497',
    //            riskId: 1,
    //            riskLimitValue: '150',
    //            side: 'Buy',
    //            size: '3',
    //            stopLoss: '0.00',
    //            symbol: 'BTCUSD',
    //            takeProfit: '0.00',
    //            tpslMode: 'Full',
    //            tradeMode: 0,
    //            autoAddMargin: 1,
    //            trailingStop: '0.00',
    //            unrealisedPnl: '0.00003925',
    //            updatedTime: '1694566055293',
    //            adlRankIndicator: 3
    //        }]
    //    }
    //
    // each account is connected to a different endpoint
    // and has exactly one subscriptionhash which is the account type
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    var rawPositions interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParsePosition(rawPosition)
        var side interface{} = this.SafeString(position, "side")
        // hacky solution to handle closing positions
        // without crashing, we should handle this properly later
        ccxt.AppendToArray(&newPositions, position)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(side, nil)) || ccxt.IsTrue(ccxt.IsEqual(side, ""))) {
            // closing update, adding both sides to "reset" both sides
            // since we don't know which side is being closed
            ccxt.AddElementToObject(position, "side", "long")
            cache.(ccxt.Appender).Append(position)
            ccxt.AddElementToObject(position, "side", "short")
            cache.(ccxt.Appender).Append(position)
            ccxt.AddElementToObject(position, "side", nil)
        } else {
            // regular update
            cache.(ccxt.Appender).Append(position)
        }
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
/**
 * @method
 * @name bybit#unWatchPositions
 * @description unWatches all open positions
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/position
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} status of the unwatch request
 */
func  (this *BybitCore) UnWatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16468 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16468)
            var method interface{} = "watchPositions"
            var messageHash interface{} = "unsubscribe:positions"
            var subHash interface{} = "positions"
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchPositions() does not support a symbol parameter, you must unwatch all orders")))
            }
        
            url:= (<-this.GetUrlByMarketType(nil, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes16548 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes16548)
            var topics interface{} = []interface{}{"position"}
        
                retRes165615 :=  (<-this.UnWatchTopics(url, "positions", symbols, []interface{}{messageHash}, []interface{}{subHash}, topics, params))
                ccxt.PanicOnError(retRes165615)
                ch <- retRes165615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#watchLiquidations
 * @description watch the public liquidations of a trading pair
 * @see https://bybit-exchange.github.io/docs/v5/websocket/public/liquidation
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @param {string} [params.method] exchange specific method, supported: liquidation, allLiquidation
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BybitCore) WatchLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes16728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16728)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            url:= (<-this.GetUrlByMarketType(symbol, false, "watchLiquidations", params))
            ccxt.PanicOnError(url)
            params = this.CleanParams(params)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchLiquidations", "method", "liquidation")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var messageHash interface{} = ccxt.Add("liquidations::", symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(method, "."), ccxt.GetValue(market, "id"))
        
            newLiquidation:= (<-this.WatchTopics(url, []interface{}{messageHash}, []interface{}{topic}, params))
            ccxt.PanicOnError(newLiquidation)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidation
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, []interface{}{symbol}, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    //     {
    //         "data": {
    //             "price": "0.03803",
    //             "side": "Buy",
    //             "size": "1637",
    //             "symbol": "GALAUSDT",
    //             "updatedTime": 1673251091822
    //         },
    //         "topic": "liquidation.GALAUSDT",
    //         "ts": 1673251091822,
    //         "type": "snapshot"
    //     }
    //
    //     {
    //         "topic": "allLiquidation.ROSEUSDT",
    //         "type": "snapshot",
    //         "ts": 1739502303204,
    //         "data": [
    //             {
    //                 "T": 1739502302929,
    //                 "s": "ROSEUSDT",
    //                 "S": "Sell",
    //                 "v": "20000",
    //                 "p": "0.04499"
    //             }
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(message, "data"))) {
        var rawLiquidations interface{} = this.SafeList(message, "data", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawLiquidations)); i++ {
            var rawLiquidation interface{} = ccxt.GetValue(rawLiquidations, i)
            var marketId interface{} = this.SafeString(rawLiquidation, "s")
            var market interface{} = this.SafeMarket(marketId, nil, "", "contract")
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation, market)
            if ccxt.IsTrue(ccxt.IsEqual(this.Liquidations, nil)) {
                this.Liquidations = ccxt.NewArrayCacheBySymbolBySide()
            }
            var cache interface{} = this.Liquidations
            cache.(ccxt.Appender).Append(liquidation)
            client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "liquidations")
            client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("liquidations::", symbol))
        }
    } else {
        var rawLiquidation interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        var marketId interface{} = this.SafeString(rawLiquidation, "symbol")
        var market interface{} = this.SafeMarket(marketId, nil, "", "contract")
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation, market)
        if ccxt.IsTrue(ccxt.IsEqual(this.Liquidations, nil)) {
            this.Liquidations = ccxt.NewArrayCacheBySymbolBySide()
        }
        var cache interface{} = this.Liquidations
        cache.(ccxt.Appender).Append(liquidation)
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "liquidations")
        client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("liquidations::", symbol))
    }
}
func  (this *BybitCore) ParseWsLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "price": "0.03803",
    //         "side": "Buy",
    //         "size": "1637",
    //         "symbol": "GALAUSDT",
    //         "updatedTime": 1673251091822
    //     }
    //
    //     {
    //         "T": 1739502302929,
    //         "s": "ROSEUSDT",
    //         "S": "Sell",
    //         "v": "20000",
    //         "p": "0.04499"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(liquidation, "symbol", "s")
    market = this.SafeMarket(marketId, market, "", "contract")
    var timestamp interface{} = this.SafeInteger2(liquidation, "updatedTime", "T")
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": ccxt.GetValue(market, "symbol"),
        "contracts": this.SafeNumber2(liquidation, "size", "v"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "price": this.SafeNumber2(liquidation, "price", "p"),
        "side": this.SafeStringLower(liquidation, "side", "S"),
        "baseValue": nil,
        "quoteValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
/**
 * @method
 * @name bybit#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17978 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes17978)
            var method interface{} = "watchOrders"
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            url:= (<-this.GetUrlByMarketType(symbol, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes18058 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes18058)
            var topicsByMarket interface{} = map[string]interface{} {
                "spot": []interface{}{"order", "stopOrder"},
                "unified": []interface{}{"order"},
                "usdc": []interface{}{"user.openapi.perp.order"},
            }
            var topics interface{} = this.SafeValue(topicsByMarket, this.GetPrivateType(url))
        
            orders:= (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bybit#unWatchOrders
 * @description unWatches information on multiple orders made by the user
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BybitCore) UnWatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18308 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes18308)
            var method interface{} = "watchOrders"
            var messageHash interface{} = "unsubscribe:orders"
            var subHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchOrders() does not support a symbol parameter, you must unwatch all orders")))
            }
        
            url:= (<-this.GetUrlByMarketType(symbol, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes18388 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes18388)
            var topicsByMarket interface{} = map[string]interface{} {
                "spot": []interface{}{"order", "stopOrder"},
                "unified": []interface{}{"order"},
                "usdc": []interface{}{"user.openapi.perp.order"},
            }
            var topics interface{} = this.SafeValue(topicsByMarket, this.GetPrivateType(url))
        
                retRes184515 :=  (<-this.UnWatchTopics(url, "orders", []interface{}{}, []interface{}{messageHash}, []interface{}{subHash}, topics, params))
                ccxt.PanicOnError(retRes184515)
                ch <- retRes184515
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleOrderWs(client interface{}, message interface{})  {
    //
    //    {
    //        "reqId":"1",
    //        "retCode":0,
    //        "retMsg":"OK",
    //        "op":"order.create",
    //        "data":{
    //            "orderId":"1673523595617593600",
    //            "orderLinkId":"1673523595617593601"
    //        },
    //        "header":{
    //            "X-Bapi-Limit":"20",
    //            "X-Bapi-Limit-Status":"19",
    //            "X-Bapi-Limit-Reset-Timestamp":"1714235558880",
    //            "Traceid":"584a06d373f2fdcb3a4dfdd81d27df11",
    //            "Timenow":"1714235558881"
    //        },
    //        "connId":"cojidqec0hv9fgvhtbt0-40e"
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "reqId")
    var data interface{} = this.SafeDict(message, "data")
    var order interface{} = this.ParseOrder(data)
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
func  (this *BybitCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     spot
    //     {
    //         "type": "snapshot",
    //         "topic": "order",
    //         "ts": "1662348310441",
    //         "data": [
    //             {
    //                 "e": "order",
    //                 "E": "1662348310441",
    //                 "s": "BTCUSDT",
    //                 "c": "spotx008",
    //                 "S": "BUY",
    //                 "o": "MARKET_OF_QUOTE",
    //                 "f": "GTC",
    //                 "q": "20",
    //                 "p": "0",
    //                 "X": "CANCELED",
    //                 "i": "1238261807653647872",
    //                 "M": "1238225004531834368",
    //                 "l": "0.001007",
    //                 "z": "0.001007",
    //                 "L": "19842.02",
    //                 "n": "0",
    //                 "N": "BTC",
    //                 "u": true,
    //                 "w": true,
    //                 "m": false,
    //                 "O": "1662348310368",
    //                 "Z": "19.98091414",
    //                 "A": "0",
    //                 "C": false,
    //                 "v": "0",
    //                 "d": "NO_LIQ",
    //                 "t": "2100000000002220938"
    //             }
    //         ]
    //     }
    // unified
    //     {
    //         "id": "5923240c6880ab-c59f-420b-9adb-3639adc9dd90",
    //         "topic": "order",
    //         "creationTime": 1672364262474,
    //         "data": [
    //             {
    //                 "symbol": "ETH-30DEC22-1400-C",
    //                 "orderId": "5cf98598-39a7-459e-97bf-76ca765ee020",
    //                 "side": "Sell",
    //                 "orderType": "ccxt.Market",
    //                 "cancelType": "UNKNOWN",
    //                 "price": "72.5",
    //                 "qty": "1",
    //                 "orderIv": "",
    //                 "timeInForce": "IOC",
    //                 "orderStatus": "Filled",
    //                 "orderLinkId": "",
    //                 "lastPriceOnCreated": "",
    //                 "reduceOnly": false,
    //                 "leavesQty": "",
    //                 "leavesValue": "",
    //                 "cumExecQty": "1",
    //                 "cumExecValue": "75",
    //                 "avgPrice": "75",
    //                 "blockTradeId": "",
    //                 "positionIdx": 0,
    //                 "cumExecFee": "0.358635",
    //                 "createdTime": "1672364262444",
    //                 "updatedTime": "1672364262457",
    //                 "rejectReason": "EC_NoError",
    //                 "stopOrderType": "",
    //                 "triggerPrice": "",
    //                 "takeProfit": "",
    //                 "stopLoss": "",
    //                 "tpTriggerBy": "",
    //                 "slTriggerBy": "",
    //                 "triggerDirection": 0,
    //                 "triggerBy": "",
    //                 "closeOnTrigger": false,
    //                 "category": "option"
    //             }
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var rawOrders interface{} = this.SafeValue(message, "data", []interface{}{})
    var first interface{} = this.SafeValue(rawOrders, 0, map[string]interface{} {})
    var category interface{} = this.SafeString(first, "category")
    var isSpot interface{} = ccxt.IsEqual(category, "spot")
    if !ccxt.IsTrue(isSpot) {
        rawOrders = this.SafeValue(rawOrders, "result", rawOrders)
    }
    var symbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var parsed interface{} = this.ParseOrder(ccxt.GetValue(rawOrders, i))
        // if (isSpot) {
        //     parsed = this.parseWsSpotOrder (rawOrders[i])
        // } else {
        //     parsed = this.parseOrder (rawOrders[i])
        // }
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        orders.(ccxt.Appender).Append(parsed)
    }
    var symbolsArray interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsArray)); i++ {
        var currentMessageHash interface{} = ccxt.Add("orders:", ccxt.GetValue(symbolsArray, i))
        client.(ccxt.ClientInterface).Resolve(orders, currentMessageHash)
    }
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
/**
 * @method
 * @name bybit#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://bybit-exchange.github.io/docs/v5/websocket/private/wallet
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BybitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes20018)
            var method interface{} = "watchBalance"
            var messageHash interface{} = "balances"
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchBalance", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
        
            unified:= (<-this.IsUnifiedEnabled())
            ccxt.PanicOnError(unified)
            var isUnifiedMargin interface{} = this.SafeBool(unified, 0, false)
            var isUnifiedAccount interface{} = this.SafeBool(unified, 1, false)
        
            url:= (<-this.GetUrlByMarketType(nil, true, method, params))
            ccxt.PanicOnError(url)
        
            retRes20128 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes20128)
            var topicByMarket interface{} = map[string]interface{} {
                "spot": "outboundAccountInfo",
                "unified": "wallet",
            }
            if ccxt.IsTrue(isUnifiedAccount) {
                // unified account
                if ccxt.IsTrue(ccxt.IsEqual(subType, "inverse")) {
                    messageHash = ccxt.Add(messageHash, ":contract")
                } else {
                    messageHash = ccxt.Add(messageHash, ":unified")
                }
            }
            if ccxt.IsTrue(!ccxt.IsTrue(isUnifiedMargin) && !ccxt.IsTrue(isUnifiedAccount)) {
                // normal account using v5
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    messageHash = ccxt.Add(messageHash, ":spot")
                } else {
                    messageHash = ccxt.Add(messageHash, ":contract")
                }
            }
            if ccxt.IsTrue(isUnifiedMargin) {
                // unified margin account using v5
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    messageHash = ccxt.Add(messageHash, ":spot")
                } else {
                    if ccxt.IsTrue(ccxt.IsEqual(subType, "linear")) {
                        messageHash = ccxt.Add(messageHash, ":unified")
                    } else {
                        messageHash = ccxt.Add(messageHash, ":contract")
                    }
                }
            }
            var topics interface{} = []interface{}{this.SafeValue(topicByMarket, this.GetPrivateType(url))}
        
                retRes204615 :=  (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
                ccxt.PanicOnError(retRes204615)
                ch <- retRes204615
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "type": "snapshot",
    //        "topic": "outboundAccountInfo",
    //        "ts": "1662107217641",
    //        "data": [
    //            {
    //                "e": "outboundAccountInfo",
    //                "E": "1662107217640",
    //                "T": true,
    //                "W": true,
    //                "D": true,
    //                "B": [
    //                    {
    //                        "a": "USDT",
    //                        "f": "176.81254174",
    //                        "l": "201.575"
    //                    }
    //                ]
    //            }
    //        ]
    //    }
    // unified
    //     {
    //         "id": "5923242c464be9-25ca-483d-a743-c60101fc656f",
    //         "topic": "wallet",
    //         "creationTime": 1672364262482,
    //         "data": [
    //             {
    //                 "accountIMRate": "0.016",
    //                 "accountMMRate": "0.003",
    //                 "totalEquity": "12837.78330098",
    //                 "totalWalletBalance": "12840.4045924",
    //                 "totalMarginBalance": "12837.78330188",
    //                 "totalAvailableBalance": "12632.05767702",
    //                 "totalPerpUPL": "-2.62129051",
    //                 "totalInitialMargin": "205.72562486",
    //                 "totalMaintenanceMargin": "39.42876721",
    //                 "coin": [
    //                     {
    //                         "coin": "USDC",
    //                         "equity": "200.62572554",
    //                         "usdValue": "200.62572554",
    //                         "walletBalance": "201.34882644",
    //                         "availableToWithdraw": "0",
    //                         "availableToBorrow": "1500000",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "0",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "202.99874213",
    //                         "totalPositionMM": "39.14289747",
    //                         "unrealisedPnl": "74.2768991",
    //                         "cumRealisedPnl": "-209.1544627",
    //                         "bonus": "0"
    //                     },
    //                     {
    //                         "coin": "BTC",
    //                         "equity": "0.06488393",
    //                         "usdValue": "1023.08402268",
    //                         "walletBalance": "0.06488393",
    //                         "availableToWithdraw": "0.06488393",
    //                         "availableToBorrow": "2.5",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "0",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "0",
    //                         "totalPositionMM": "0",
    //                         "unrealisedPnl": "0",
    //                         "cumRealisedPnl": "0",
    //                         "bonus": "0"
    //                     },
    //                     {
    //                         "coin": "ETH",
    //                         "equity": "0",
    //                         "usdValue": "0",
    //                         "walletBalance": "0",
    //                         "availableToWithdraw": "0",
    //                         "availableToBorrow": "26",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "0",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "0",
    //                         "totalPositionMM": "0",
    //                         "unrealisedPnl": "0",
    //                         "cumRealisedPnl": "0",
    //                         "bonus": "0"
    //                     },
    //                     {
    //                         "coin": "USDT",
    //                         "equity": "11726.64664904",
    //                         "usdValue": "11613.58597018",
    //                         "walletBalance": "11728.54414904",
    //                         "availableToWithdraw": "11723.92075829",
    //                         "availableToBorrow": "2500000",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "0",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "2.72589075",
    //                         "totalPositionMM": "0.28576575",
    //                         "unrealisedPnl": "-1.8975",
    //                         "cumRealisedPnl": "0.64782276",
    //                         "bonus": "0"
    //                     },
    //                     {
    //                         "coin": "EOS3L",
    //                         "equity": "215.0570412",
    //                         "usdValue": "0",
    //                         "walletBalance": "215.0570412",
    //                         "availableToWithdraw": "215.0570412",
    //                         "availableToBorrow": "0",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "0",
    //                         "totalPositionMM": "0",
    //                         "unrealisedPnl": "0",
    //                         "cumRealisedPnl": "0",
    //                         "bonus": "0"
    //                     },
    //                     {
    //                         "coin": "BIT",
    //                         "equity": "1.82",
    //                         "usdValue": "0.48758257",
    //                         "walletBalance": "1.82",
    //                         "availableToWithdraw": "1.82",
    //                         "availableToBorrow": "0",
    //                         "borrowAmount": "0",
    //                         "accruedInterest": "",
    //                         "totalOrderIM": "0",
    //                         "totalPositionIM": "0",
    //                         "totalPositionMM": "0",
    //                         "unrealisedPnl": "0",
    //                         "cumRealisedPnl": "0",
    //                         "bonus": "0"
    //                     }
    //                 ],
    //                 "accountType": "UNIFIED"
    //             }
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Balance, nil)) {
        this.Balance = map[string]interface{} {}
    }
    var messageHash interface{} = "balance"
    var topic interface{} = this.SafeValue(message, "topic")
    var info interface{} = nil
    var rawBalances interface{} = []interface{}{}
    var account interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(topic, "outboundAccountInfo")) {
        account = "spot"
        var data interface{} = this.SafeValue(message, "data", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var B interface{} = this.SafeValue(ccxt.GetValue(data, i), "B", []interface{}{})
            rawBalances = this.ArrayConcat(rawBalances, B)
        }
        info = rawBalances
    }
    if ccxt.IsTrue(ccxt.IsEqual(topic, "wallet")) {
        var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var result interface{} = this.SafeValue(data, 0, map[string]interface{} {})
            account = this.SafeStringLower(result, "accountType")
            rawBalances = this.ArrayConcat(rawBalances, this.SafeValue(result, "coin", []interface{}{}))
        }
        info = data
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawBalances)); i++ {
        this.ParseWsBalance(ccxt.GetValue(rawBalances, i), account)
    }
    if ccxt.IsTrue(!ccxt.IsEqual(account, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Balance, account), nil)) {
            ccxt.AddElementToObject(this.Balance, account, map[string]interface{} {})
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, account), "info", info)
        var timestamp interface{} = this.SafeInteger(message, "ts")
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, account), "timestamp", timestamp)
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, account), "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(this.Balance, account, this.SafeBalance(ccxt.GetValue(this.Balance, account)))
        messageHash = ccxt.Add("balances:", account)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, account), messageHash)
    } else {
        ccxt.AddElementToObject(this.Balance, "info", info)
        var timestamp interface{} = this.SafeInteger(message, "ts")
        ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
        ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
        this.Balance = this.SafeBalance(this.Balance)
        messageHash = "balances"
        client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
    }
}
func  (this *BybitCore) ParseWsBalance(balance interface{}, optionalArgs ...interface{})  {
    //
    // spot
    //    {
    //        "a": "USDT",
    //        "f": "176.81254174",
    //        "l": "201.575"
    //    }
    // unified
    //     {
    //         "coin": "BTC",
    //         "equity": "0.06488393",
    //         "usdValue": "1023.08402268",
    //         "walletBalance": "0.06488393",
    //         "availableToWithdraw": "0.06488393",
    //         "availableToBorrow": "2.5",
    //         "borrowAmount": "0",
    //         "accruedInterest": "0",
    //         "totalOrderIM": "0",
    //         "totalPositionIM": "0",
    //         "totalPositionMM": "0",
    //         "unrealisedPnl": "0",
    //         "cumRealisedPnl": "0",
    //         "bonus": "0"
    //     }
    //
    accountType := ccxt.GetArg(optionalArgs, 0, nil)
    _ = accountType
    var account interface{} = this.Account()
    var currencyId interface{} = this.SafeString2(balance, "a", "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    ccxt.AddElementToObject(account, "free", this.SafeStringN(balance, []interface{}{"availableToWithdraw", "f", "free", "availableToWithdraw"}))
    ccxt.AddElementToObject(account, "used", this.SafeString2(balance, "l", "locked"))
    ccxt.AddElementToObject(account, "total", this.SafeString(balance, "walletBalance"))
    if ccxt.IsTrue(!ccxt.IsEqual(accountType, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Balance, accountType), nil)) {
            ccxt.AddElementToObject(this.Balance, accountType, map[string]interface{} {})
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
    } else {
        ccxt.AddElementToObject(this.Balance, code, account)
    }
}
func  (this *BybitCore) WatchTopics(url interface{}, messageHashes interface{}, topics interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "req_id": this.RequestId(),
                "args": topics,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes229215 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes229215)
                ch <- retRes229215
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) UnWatchTopics(url interface{}, topic interface{}, symbols interface{}, messageHashes interface{}, subMessageHashes interface{}, topics interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subExtension := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = subExtension
            var reqId interface{} = this.RequestId()
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "req_id": reqId,
                "args": topics,
            }
            var subscription interface{} = map[string]interface{} {
                "id": reqId,
                "topic": topic,
                "messageHashes": messageHashes,
                "subMessageHashes": subMessageHashes,
                "symbols": symbols,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes231015 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes, this.Extend(subscription, subExtension)))
                ccxt.PanicOnError(retRes231015)
                ch <- retRes231015
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) Authenticate(url interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var expiresInt interface{} = ccxt.Add(this.Milliseconds(), 10000)
                var expires interface{} = this.NumberToString(expiresInt)
                var path interface{} = "GET/realtime"
                var auth interface{} = ccxt.Add(path, expires)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256, "hex")
                var request interface{} = map[string]interface{} {
                    "op": "auth",
                    "args": []interface{}{this.ApiKey, expires, signature},
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes233415 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes233415)
                ch <- retRes233415
                return nil
        
            }()
            return ch
        }
func  (this *BybitCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "success": false,
    //       "ret_msg": "error:invalid op",
    //       "conn_id": "5e079fdd-9c7f-404d-9dbf-969d650838b5",
    //       "request": { op: '', args: null }
    //   }
    //
    // auth error
    //
    //   {
    //       "success": false,
    //       "ret_msg": "error:USVC1111",
    //       "conn_id": "e73770fb-a0dc-45bd-8028-140e20958090",
    //       "request": {
    //         "op": "auth",
    //         "args": [
    //           "9rFT6uR4uz9Imkw4Wx",
    //           "1653405853543",
    //           "542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889"
    //         ]
    //   }
    //
    //   { code: '-10009', desc: "Invalid period!" }
    //
    //   {
    //       "reqId":"1",
    //       "retCode":170131,
    //       "retMsg":"Insufficient balance.",
    //       "op":"order.create",
    //       "data":{
    //
    //       },
    //       "header":{
    //           "X-Bapi-Limit":"20",
    //           "X-Bapi-Limit-Status":"19",
    //           "X-Bapi-Limit-Reset-Timestamp":"1714236608944",
    //           "Traceid":"3d7168a137bf32a947b7e5e6a575ac7f",
    //           "Timenow":"1714236608946"
    //       },
    //       "connId":"cojifin88smerbj9t560-406"
    //   }
    //
    var code interface{} = this.SafeStringN(message, []interface{}{"code", "ret_code", "retCode"})
    
        {
            ret__ := func(this *BybitCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *BybitCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(error, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                var messageHash interface{} = this.SafeString(message, "reqId")
                client.(ccxt.ClientInterface).Reject(error, messageHash)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(code, nil)) && ccxt.IsTrue(!ccxt.IsEqual(code, "0"))) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
                var msg interface{} = this.SafeString2(message, "retMsg", "ret_msg")
                this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), msg, feedback)
                panic(ccxt.ExchangeError(feedback))
            }
            var success interface{} = this.SafeValue(message, "success")
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(success, nil)) && !ccxt.IsTrue(success)) {
                var ret_msg interface{} = this.SafeString(message, "ret_msg")
                var request interface{} = this.SafeValue(message, "request", map[string]interface{} {})
                var op interface{} = this.SafeString(request, "op")
                if ccxt.IsTrue(ccxt.IsEqual(op, "auth")) {
                    panic(ccxt.AuthenticationError(ccxt.Add("Authentication failed: ", ret_msg)))
                } else {
                    panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), ret_msg)))
                }
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *BybitCore) HandleMessage(client interface{}, message interface{})  {
    var topic interface{} = this.SafeString2(message, "topic", "op", "")
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    // contract pong
    var ret_msg interface{} = this.SafeString(message, "ret_msg")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(ret_msg, "pong"))) || ccxt.IsTrue((ccxt.IsEqual(topic, "pong")))) {
        this.HandlePong(client, message)
        return
    }
    // spot pong
    var pong interface{} = this.SafeInteger(message, "pong")
    if ccxt.IsTrue(!ccxt.IsEqual(pong, nil)) {
        this.HandlePong(client, message)
        return
    }
    // pong
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, "sub")) || ccxt.IsTrue((ccxt.IsEqual(topic, "subscribe")))) {
        this.HandleSubscriptionStatus(client, message)
        return
    }
    var methods interface{} = map[string]interface{} {
        "orderbook": this.HandleOrderBook,
        "kline": this.HandleOHLCV,
        "order": this.HandleOrder,
        "stopOrder": this.HandleOrder,
        "ticker": this.HandleTicker,
        "trade": this.HandleTrades,
        "publicTrade": this.HandleTrades,
        "depth": this.HandleOrderBook,
        "wallet": this.HandleBalance,
        "outboundAccountInfo": this.HandleBalance,
        "execution": this.HandleMyTrades,
        "execution.fast": this.HandleMyTrades,
        "ticketInfo": this.HandleMyTrades,
        "user.openapi.perp.trade": this.HandleMyTrades,
        "position": this.HandlePositions,
        "liquidation": this.HandleLiquidation,
        "allLiquidation": this.HandleLiquidation,
        "pong": this.HandlePong,
        "order.create": this.HandleOrderWs,
        "order.amend": this.HandleOrderWs,
        "order.cancel": this.HandleOrderWs,
        "auth": this.HandleAuthenticate,
        "unsubscribe": this.HandleUnSubscribe,
    }
    var exacMethod interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(exacMethod, nil)) {
        ccxt.CallDynamically(exacMethod, client, message)
        return
    }
    var keys interface{} = ccxt.ObjectKeys(methods)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, ccxt.GetValue(keys, i)), 0)) {
            var method interface{} = ccxt.GetValue(methods, key)
            ccxt.CallDynamically(method, client, message)
            return
        }
    }
    // unified auth acknowledgement
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "AUTH_RESP")) {
        this.HandleAuthenticate(client, message)
    }
}
func  (this *BybitCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "req_id": this.RequestId(),
        "op": "ping",
    }
}
func  (this *BybitCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "success": true,
    //       "ret_msg": "pong",
    //       "conn_id": "db3158a0-8960-44b9-a9de-ac350ee13158",
    //       "request": { op: "ping", args: null }
    //   }
    //
    //   { pong: 1653296711335 }
    //
    //
    //   {
    //       "req_id": "2",
    //       "op": "pong",
    //       "args": [ "1757405570352" ],
    //       "conn_id": "d266o6hqo29sqmnq4vk0-1yus1"
    //   }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.SafeInteger(message, "pong", this.Milliseconds()))
    return message
}
func  (this *BybitCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "success": true,
    //        "ret_msg": '',
    //        "op": "auth",
    //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
    //    }
    //
    //    {
    //        "retCode":0,
    //        "retMsg":"OK",
    //        "op":"auth",
    //        "connId":"cojifin88smerbj9t560-404"
    //    }
    //
    //    {
    //        "success": true,
    //        "ret_msg": "",
    //        "op": "auth",
    //        "conn_id": "d266o6hqo29sqmnq4vk0-1yus1"
    //    }
    //
    var success interface{} = this.SafeValue(message, "success")
    var code interface{} = this.SafeInteger(message, "retCode")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(ccxt.IsTrue(success) || ccxt.IsTrue(ccxt.IsEqual(code, 0))) {
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
    return message
}
func  (this *BybitCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "topic": "kline",
    //        "event": "sub",
    //        "params": {
    //          "symbol": "LTCUSDT",
    //          "binary": "false",
    //          "klineType": "1m",
    //          "symbolName": "LTCUSDT"
    //        },
    //        "code": "0",
    //        "msg": "Success"
    //    }
    //
    return message
}
func  (this *BybitCore) HandleUnSubscribe(client interface{}, message interface{}) interface{}  {
    //
    // {"success":true,"ret_msg":"","conn_id":"7188110e-6908-41e9-b863-6365127e92ad","req_id":"3","op":"unsubscribe"}
    //
    // client.subscription will be something like:
    // {
    //     "publicTrade.LTCUSDT":true,
    //     "publicTrade.ADAUSDT":true,
    //     "unsubscribe:trade:LTC/USDT:USDT": {
    //        "id":4,
    //         "subHash": "trade:LTC/USDT"
    //     },
    // }
    var reqId interface{} = this.SafeString(message, "req_id")
    var keys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var messageHash interface{} = ccxt.GetValue(keys, i)
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
            continue
        }
        if ccxt.IsTrue(ccxt.StartsWith(messageHash, "unsubscribe")) {
            var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            var subId interface{} = this.SafeString(subscription, "id")
            if ccxt.IsTrue(!ccxt.IsEqual(reqId, subId)) {
                continue
            }
            var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
            var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
                var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
                var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
                var usePrefix interface{} = ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subHash, "orders"))) || ccxt.IsTrue((ccxt.IsEqual(subHash, "myTrades")))) || ccxt.IsTrue((ccxt.IsEqual(subHash, "positions")))
                this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash, usePrefix)
            }
            this.CleanCache(subscription)
        }
    }
    return message
}


func (this *BybitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
