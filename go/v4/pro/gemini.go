package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type GeminiCore struct {
	*ccxt.GeminiCore
	base *ccxt.GeminiCore
}

func NewGeminiCore() *GeminiCore {
    p := &GeminiCore{}
	base := &ccxt.GeminiCore{}
	p.base = base
	p.GeminiCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *GeminiCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchTicker": false,
            "watchTickers": false,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTrades": false,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
        },
        "hostname": "api.gemini.com",
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.gemini.com",
            },
            "test": map[string]interface{} {
                "ws": "wss://api.sandbox.gemini.com",
            },
        },
    })
}
/**
 * @method
 * @name gemini#watchTrades
 * @description watch the list of most recent trades for a particular symbol
 * @see https://docs.gemini.com/websocket-api/#market-data-version-2
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GeminiCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes528)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("trades:", ccxt.GetValue(market, "symbol"))
            var marketId interface{} = ccxt.GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "subscriptions": []interface{}{map[string]interface{} {
            "name": "l2",
            "symbols": []interface{}{ccxt.ToUpper(marketId)},
        }},
            }
            var subscribeHash interface{} = ccxt.Add("l2:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/v2/marketdata")
        
            trades:= (<-this.Watch(url, messageHash, request, subscribeHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gemini#watchTradesForSymbols
 * @see https://docs.gemini.com/websocket-api/#multi-market-data
 * @description get the list of most recent trades for a list of symbols
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GeminiCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.HelperForWatchMultipleConstruct("trades", symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeList(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // regular v2 trade
    //
    //     {
    //         "type": "trade",
    //         "symbol": "BTCUSD",
    //         "event_id": 122258166738,
    //         "timestamp": 1655330221424,
    //         "price": "22269.14",
    //         "quantity": "0.00004473",
    //         "side": "buy"
    //     }
    //
    // multi data trade
    //
    //    {
    //        "type": "trade",
    //        "symbol": "ETHUSD",
    //        "tid": "1683002242170204", // this is not TS, but somewhat ID
    //        "price": "2299.24",
    //        "amount": "0.002662",
    //        "makerSide": "bid"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var id interface{} = this.SafeString2(trade, "event_id", "tid")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString2(trade, "quantity", "amount")
    var side interface{} = this.SafeStringLower(trade, "side")
    if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
        var marketSide interface{} = this.SafeStringLower(trade, "makerSide")
        if ccxt.IsTrue(ccxt.IsEqual(marketSide, "bid")) {
            side = "sell"
        } else if ccxt.IsTrue(ccxt.IsEqual(marketSide, "ask")) {
            side = "buy"
        }
    }
    var marketId interface{} = this.SafeStringLower(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": nil,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "cost": nil,
        "amount": amountString,
        "fee": nil,
    }, market)
}
func  (this *GeminiCore) HandleTrade(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "trade",
    //         "symbol": "BTCUSD",
    //         "event_id": 122278173770,
    //         "timestamp": 1655335880981,
    //         "price": "22530.80",
    //         "quantity": "0.04",
    //         "side": "buy"
    //     }
    //
    var trade interface{} = this.ParseWsTrade(message)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        stored = ccxt.NewArrayCache(tradesLimit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    stored.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *GeminiCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "l2_updates",
    //         "symbol": "BTCUSD",
    //         "changes": [
    //             [ "buy", '22252.37', "0.02" ],
    //             [ "buy", '22251.61', "0.04" ],
    //             [ "buy", '22251.60', "0.04" ],
    //             // some asks as well
    //         ],
    //         "trades": [
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258166738, timestamp: 1655330221424, price: '22269.14', quantity: "0.00004473", side: "buy" },
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258141090, timestamp: 1655330213216, price: '22250.00', quantity: "0.00704098", side: "buy" },
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258118291, timestamp: 1655330206753, price: '22250.00', quantity: "0.03", side: "buy" },
    //         ],
    //         "auction_events": [
    //             {
    //                 "type": "auction_result",
    //                 "symbol": "BTCUSD",
    //                 "time_ms": 1655323200000,
    //                 "result": "failure",
    //                 "highest_bid_price": "21590.88",
    //                 "lowest_ask_price": "21602.30",
    //                 "collar_price": "21634.73"
    //             },
    //             {
    //                 "type": "auction_indicative",
    //                 "symbol": "BTCUSD",
    //                 "time_ms": 1655323185000,
    //                 "result": "failure",
    //                 "highest_bid_price": "21661.90",
    //                 "lowest_ask_price": "21663.78",
    //                 "collar_price": "21662.845"
    //             },
    //         ]
    //     }
    //
    var marketId interface{} = this.SafeStringLower(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var trades interface{} = this.SafeValue(message, "trades")
    if ccxt.IsTrue(!ccxt.IsEqual(trades, nil)) {
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            stored = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
            var trade interface{} = this.ParseWsTrade(ccxt.GetValue(trades, i), market)
            stored.(ccxt.Appender).Append(trade)
        }
        var messageHash interface{} = ccxt.Add("trades:", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
func  (this *GeminiCore) HandleTradesForMultidata(client interface{}, trades interface{}, timestamp interface{})  {
    if ccxt.IsTrue(!ccxt.IsEqual(trades, nil)) {
        var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var storesForSymbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
            var marketId interface{} = ccxt.GetValue(ccxt.GetValue(trades, i), "symbol")
            var market interface{} = this.SafeMarket(ccxt.ToLower(marketId))
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var trade interface{} = this.ParseWsTrade(ccxt.GetValue(trades, i), market)
            ccxt.AddElementToObject(trade, "timestamp", timestamp)
            ccxt.AddElementToObject(trade, "datetime", this.Iso8601(timestamp))
            var stored interface{} = this.SafeValue(this.Trades, symbol)
            if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
                stored = ccxt.NewArrayCache(tradesLimit)
                ccxt.AddElementToObject(this.Trades, symbol, stored)
            }
            stored.(ccxt.Appender).Append(trade)
            ccxt.AddElementToObject(storesForSymbols, symbol, stored)
        }
        var symbols interface{} = ccxt.ObjectKeys(storesForSymbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
            var symbol interface{} = ccxt.GetValue(symbols, i)
            var stored interface{} = ccxt.GetValue(storesForSymbols, symbol)
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        }
    }
}
/**
 * @method
 * @name gemini#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.gemini.com/websocket-api/#candles-data-feed
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *GeminiCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2798)
            var market interface{} = this.Market(symbol)
            var timeframeId interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "subscriptions": []interface{}{map[string]interface{} {
            "name": ccxt.Add("candles_", timeframeId),
            "symbols": []interface{}{ccxt.ToUpper(ccxt.GetValue(market, "id"))},
        }},
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", ccxt.GetValue(market, "symbol")), ":"), timeframeId)
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/v2/marketdata")
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "candles_15m_updates",
    //         "symbol": "BTCUSD",
    //         "changes": [
    //             [
    //                 1561054500000,
    //                 9350.18,
    //                 9358.35,
    //                 9350.18,
    //                 9355.51,
    //                 2.07
    //             ],
    //             [
    //                 1561053600000,
    //                 9357.33,
    //                 9357.33,
    //                 9350.18,
    //                 9350.18,
    //                 1.5900161
    //             ]
    //             ...
    //         ]
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type", "")
    var timeframeId interface{} = ccxt.Slice(typeVar, 8, nil)
    var timeframeEndIndex interface{} = ccxt.GetIndexOf(timeframeId, "_")
    timeframeId = ccxt.Slice(timeframeId, 0, timeframeEndIndex)
    var marketId interface{} = ccxt.ToLower(this.SafeString(message, "symbol", ""))
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var changes interface{} = this.SafeValue(message, "changes", []interface{}{})
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var ohlcvsBySymbol interface{} = this.SafeValue(this.Ohlcvs, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ohlcvsBySymbol, nil)) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var changesLength interface{} =     ccxt.GetArrayLength(changes)
    // reverse order of array to store candles in ascending order
    for i := 0; ccxt.IsLessThan(i, changesLength); i++ {
        var index interface{} = ccxt.Subtract(ccxt.Subtract(changesLength, i), 1)
        var parsed interface{} = this.ParseOHLCV(ccxt.GetValue(changes, index), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv:", symbol), ":"), timeframeId)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name gemini#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.gemini.com/websocket-api/#market-data-version-2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *GeminiCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3708)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
            var marketId interface{} = ccxt.GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "subscriptions": []interface{}{map[string]interface{} {
            "name": "l2",
            "symbols": []interface{}{ccxt.ToUpper(marketId)},
        }},
            }
            var subscribeHash interface{} = ccxt.Add("l2:", ccxt.GetValue(market, "symbol"))
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/v2/marketdata")
        
            orderbook:= (<-this.Watch(url, messageHash, request, subscribeHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) HandleOrderBook(client interface{}, message interface{})  {
    var changes interface{} = this.SafeValue(message, "changes", []interface{}{})
    var marketId interface{} = this.SafeStringLower(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    // let orderbook = this.safeValue (this.orderbooks, symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(changes)); i++ {
        var delta interface{} = ccxt.GetValue(changes, i)
        var price interface{} = this.SafeNumber(delta, 1)
        var size interface{} = this.SafeNumber(delta, 2)
        var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(delta, 0), "buy"))), "bids", "asks")
        var bookside interface{} = ccxt.GetValue(orderbook, side)
        bookside.(ccxt.IOrderBookSide).Store(price, size)
        ccxt.AddElementToObject(orderbook, side, bookside)
    }
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name gemini#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.gemini.com/websocket-api/#multi-market-data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *GeminiCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            orderbook:= (<-this.HelperForWatchMultipleConstruct("orderbook", symbols, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name gemini#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.gemini.com/websocket-api/#multi-market-data
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *GeminiCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes44115 :=  (<-this.HelperForWatchMultipleConstruct("bidsasks", symbols, params))
                ccxt.PanicOnError(retRes44115)
                ch <- retRes44115
                return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) HandleBidsAsksForMultidata(client interface{}, rawBidAskChanges interface{}, timestamp interface{}, nonce interface{})  {
    //
    // {
    //     eventId: '1683002916916153',
    //     events: [
    //       {
    //         price: '50945.37',
    //         reason: 'top-of-book',
    //         remaining: '0.0',
    //         side: 'bid',
    //         symbol: 'BTCUSDT',
    //         type: 'change'
    //       },
    //       {
    //         price: '50947.75',
    //         reason: 'top-of-book',
    //         remaining: '0.11725',
    //         side: 'bid',
    //         symbol: 'BTCUSDT',
    //         type: 'change'
    //       }
    //     ],
    //     socket_sequence: 322,
    //     timestamp: 1708674495,
    //     timestampms: 1708674495174,
    //     type: 'update'
    // }
    //
    var marketId interface{} = ccxt.GetValue(ccxt.GetValue(rawBidAskChanges, 0), "symbol")
    var market interface{} = this.SafeMarket(ccxt.ToLower(marketId))
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Bidsasks, symbol))) {
        ccxt.AddElementToObject(this.Bidsasks, symbol, this.ParseTicker(map[string]interface{} {}))
        ccxt.AddElementToObject(ccxt.GetValue(this.Bidsasks, symbol), "symbol", symbol)
    }
    var currentBidAsk interface{} = ccxt.GetValue(this.Bidsasks, symbol)
    var messageHash interface{} = ccxt.Add("bidsasks:", symbol)
    // last update always overwrites the previous state and is the latest state
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawBidAskChanges)); i++ {
        var entry interface{} = ccxt.GetValue(rawBidAskChanges, i)
        var rawSide interface{} = this.SafeString(entry, "side")
        var price interface{} = this.SafeNumber(entry, "price")
        var sizeString interface{} = this.SafeString(entry, "remaining")
        if ccxt.IsTrue(ccxt.Precise.StringEq(sizeString, "0")) {
            continue
        }
        var size interface{} = this.ParseNumber(sizeString)
        if ccxt.IsTrue(ccxt.IsEqual(rawSide, "bid")) {
            ccxt.AddElementToObject(currentBidAsk, "bid", price)
            ccxt.AddElementToObject(currentBidAsk, "bidVolume", size)
        } else {
            ccxt.AddElementToObject(currentBidAsk, "ask", price)
            ccxt.AddElementToObject(currentBidAsk, "askVolume", size)
        }
    }
    ccxt.AddElementToObject(currentBidAsk, "timestamp", timestamp)
    ccxt.AddElementToObject(currentBidAsk, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(currentBidAsk, "info", rawBidAskChanges)
    var bidsAsksDict interface{} = map[string]interface{} {}
    ccxt.AddElementToObject(bidsAsksDict, symbol, currentBidAsk)
    ccxt.AddElementToObject(this.Bidsasks, symbol, currentBidAsk)
    client.(ccxt.ClientInterface).Resolve(bidsAsksDict, messageHash)
}
func  (this *GeminiCore) HelperForWatchMultipleConstruct(itemHashName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5098)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchMultiple requires at least one symbol")))
            }
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            if ccxt.IsTrue(!ccxt.IsTrue(ccxt.GetValue(firstMarket, "spot")) && !ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear"))) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchMultiple supports only spot or linear-swap symbols")))
            }
            var messageHashes interface{} = []interface{}{}
            var marketIds interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var messageHash interface{} = ccxt.Add(ccxt.Add(itemHashName, ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&marketIds, ccxt.GetValue(market, "id"))
            }
            var queryStr interface{} = ccxt.Join(marketIds, ",")
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/v1/multimarketdata?symbols="), queryStr), "&heartbeat=true&")
            if ccxt.IsTrue(ccxt.IsEqual(itemHashName, "orderbook")) {
                url = ccxt.Add(url, "trades=false&bids=true&offers=true")
            } else if ccxt.IsTrue(ccxt.IsEqual(itemHashName, "bidsasks")) {
                url = ccxt.Add(url, "trades=false&bids=true&offers=true&top_of_book=true")
            } else if ccxt.IsTrue(ccxt.IsEqual(itemHashName, "trades")) {
                url = ccxt.Add(url, "trades=true&bids=false&offers=false")
            }
        
                retRes53615 :=  (<-this.WatchMultiple(url, messageHashes, nil))
                ccxt.PanicOnError(retRes53615)
                ch <- retRes53615
                return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) HandleOrderBookForMultidata(client interface{}, rawOrderBookChanges interface{}, timestamp interface{}, nonce interface{})  {
    //
    // rawOrderBookChanges
    //
    // [
    //   {
    //     delta: "4105123935484.817624",
    //     price: "0.000000001",
    //     reason: "initial", // initial|cancel|place
    //     remaining: "4105123935484.817624",
    //     side: "bid", // bid|ask
    //     symbol: "SHIBUSD",
    //     type: "change", // seems always change
    //   },
    //   ...
    //
    var marketId interface{} = ccxt.GetValue(ccxt.GetValue(rawOrderBookChanges, 0), "symbol")
    var market interface{} = this.SafeMarket(ccxt.ToLower(marketId))
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook()
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var bids interface{} = ccxt.GetValue(orderbook, "bids")
    var asks interface{} = ccxt.GetValue(orderbook, "asks")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrderBookChanges)); i++ {
        var entry interface{} = ccxt.GetValue(rawOrderBookChanges, i)
        var price interface{} = this.SafeNumber(entry, "price")
        var size interface{} = this.SafeNumber(entry, "remaining")
        var rawSide interface{} = this.SafeString(entry, "side")
        if ccxt.IsTrue(ccxt.IsEqual(rawSide, "bid")) {
            bids.(ccxt.IOrderBookSide).Store(price, size)
        } else {
            asks.(ccxt.IOrderBookSide).Store(price, size)
        }
    }
    ccxt.AddElementToObject(orderbook, "bids", bids)
    ccxt.AddElementToObject(orderbook, "asks", asks)
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    ccxt.AddElementToObject(orderbook, "nonce", nonce)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *GeminiCore) HandleL2Updates(client interface{}, message interface{})  {
    //
    //     {
    //         "type": "l2_updates",
    //         "symbol": "BTCUSD",
    //         "changes": [
    //             [ "buy", '22252.37', "0.02" ],
    //             [ "buy", '22251.61', "0.04" ],
    //             [ "buy", '22251.60', "0.04" ],
    //             // some asks as well
    //         ],
    //         "trades": [
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258166738, timestamp: 1655330221424, price: '22269.14', quantity: "0.00004473", side: "buy" },
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258141090, timestamp: 1655330213216, price: '22250.00', quantity: "0.00704098", side: "buy" },
    //             { type: 'trade', symbol: 'BTCUSD', event_id: 122258118291, timestamp: 1655330206753, price: '22250.00', quantity: "0.03", side: "buy" },
    //         ],
    //         "auction_events": [
    //             {
    //                 "type": "auction_result",
    //                 "symbol": "BTCUSD",
    //                 "time_ms": 1655323200000,
    //                 "result": "failure",
    //                 "highest_bid_price": "21590.88",
    //                 "lowest_ask_price": "21602.30",
    //                 "collar_price": "21634.73"
    //             },
    //             {
    //                 "type": "auction_indicative",
    //                 "symbol": "BTCUSD",
    //                 "time_ms": 1655323185000,
    //                 "result": "failure",
    //                 "highest_bid_price": "21661.90",
    //                 "lowest_ask_price": "21663.79",
    //                 "collar_price": "21662.845"
    //             },
    //         ]
    //     }
    //
    this.HandleOrderBook(client, message)
    this.HandleTrades(client, message)
}
/**
 * @method
 * @name gemini#fetchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.gemini.com/websocket-api/#order-events
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GeminiCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "/v1/order/events?eventTypeFilter=initial&eventTypeFilter=accepted&eventTypeFilter=rejected&eventTypeFilter=fill&eventTypeFilter=cancelled&eventTypeFilter=booked")
        
            retRes6428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6428)
            var authParams interface{} = map[string]interface{} {
                "url": url,
            }
        
            retRes6468 := (<-this.Authenticate(authParams))
            ccxt.PanicOnError(retRes6468)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var messageHash interface{} = "orders"
        
            orders:= (<-this.Watch(url, messageHash, nil, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GeminiCore) HandleHeartbeat(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "heartbeat",
    //         "timestampms": 1659740268958,
    //         "sequence": 7,
    //         "trace_id": "25b3d92476dd3a9a5c03c9bd9e0a0dba",
    //         "socket_sequence": 7
    //     }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *GeminiCore) HandleSubscription(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "subscription_ack",
    //         "accountId": 19433282,
    //         "subscriptionId": "orderevents-websocket-25b3d92476dd3a9a5c03c9bd9e0a0dba",
    //         "symbolFilter": [],
    //         "apiSessionFilter": [],
    //         "eventTypeFilter": []
    //     }
    //
    return message
}
func  (this *GeminiCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     [
    //         {
    //             "type": "accepted",
    //             "order_id": "134150423884",
    //             "event_id": "134150423886",
    //             "account_name": "primary",
    //             "client_order_id": "1659739406916",
    //             "api_session": "account-pnBFSS0XKGvDamX4uEIt",
    //             "symbol": "batbtc",
    //             "side": "sell",
    //             "order_type": "exchange limit",
    //             "timestamp": "1659739407",
    //             "timestampms": 1659739407576,
    //             "is_live": true,
    //             "is_cancelled": false,
    //             "is_hidden": false,
    //             "original_amount": "1",
    //             "price": "1",
    //             "socket_sequence": 139
    //         }
    //     ]
    //
    var messageHash interface{} = "orders"
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(message)); i++ {
        var order interface{} = this.ParseWsOrder(ccxt.GetValue(message, i))
        orders.(ccxt.Appender).Append(order)
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *GeminiCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "type": "accepted",
    //         "order_id": "134150423884",
    //         "event_id": "134150423886",
    //         "account_name": "primary",
    //         "client_order_id": "1659739406916",
    //         "api_session": "account-pnBFSS0XKGvDamX4uEIt",
    //         "symbol": "batbtc",
    //         "side": "sell",
    //         "order_type": "exchange limit",
    //         "timestamp": "1659739407",
    //         "timestampms": 1659739407576,
    //         "is_live": true,
    //         "is_cancelled": false,
    //         "is_hidden": false,
    //         "original_amount": "1",
    //         "price": "1",
    //         "socket_sequence": 139
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "timestampms")
    var status interface{} = this.SafeString(order, "type")
    var marketId interface{} = this.SafeString(order, "symbol")
    var typeId interface{} = this.SafeString(order, "order_type")
    var behavior interface{} = this.SafeString(order, "behavior")
    var timeInForce interface{} = "GTC"
    var postOnly interface{} = false
    if ccxt.IsTrue(ccxt.IsEqual(behavior, "immediate-or-cancel")) {
        timeInForce = "IOC"
    } else if ccxt.IsTrue(ccxt.IsEqual(behavior, "fill-or-kill")) {
        timeInForce = "FOK"
    } else if ccxt.IsTrue(ccxt.IsEqual(behavior, "maker-or-cancel")) {
        timeInForce = "PO"
        postOnly = true
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": this.ParseWsOrderStatus(status),
        "symbol": this.SafeSymbol(marketId, market),
        "type": this.ParseWsOrderType(typeId),
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": this.SafeString(order, "side"),
        "price": this.SafeNumber(order, "price"),
        "stopPrice": nil,
        "average": this.SafeNumber(order, "avg_execution_price"),
        "cost": nil,
        "amount": this.SafeNumber(order, "original_amount"),
        "filled": this.SafeNumber(order, "executed_amount"),
        "remaining": this.SafeNumber(order, "remaining_amount"),
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *GeminiCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "accepted": "open",
        "booked": "open",
        "fill": "closed",
        "cancelled": "canceled",
        "cancel_rejected": "rejected",
        "rejected": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *GeminiCore) ParseWsOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "exchange limit": "limit",
        "market buy": "market",
        "market sell": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *GeminiCore) HandleError(client interface{}, message interface{})  {
    panic(ccxt.ExchangeError(this.Json(message)))
}
func  (this *GeminiCore) HandleMessage(client interface{}, message interface{})  {
    //
    //  public
    //     {
    //         "type": "trade",
    //         "symbol": "BTCUSD",
    //         "event_id": 122278173770,
    //         "timestamp": 1655335880981,
    //         "price": "22530.80",
    //         "quantity": "0.04",
    //         "side": "buy"
    //     }
    //
    //  private
    //     [
    //         {
    //             "type": "accepted",
    //             "order_id": "134150423884",
    //             "event_id": "134150423886",
    //             "account_name": "primary",
    //             "client_order_id": "1659739406916",
    //             "api_session": "account-pnBFSS0XKGvDamX4uEIt",
    //             "symbol": "batbtc",
    //             "side": "sell",
    //             "order_type": "exchange limit",
    //             "timestamp": "1659739407",
    //             "timestampms": 1659739407576,
    //             "is_live": true,
    //             "is_cancelled": false,
    //             "is_hidden": false,
    //             "original_amount": "1",
    //             "price": "1",
    //             "socket_sequence": 139
    //         }
    //     ]
    //
    var isArray interface{} = ccxt.IsArray(message)
    if ccxt.IsTrue(isArray) {
        this.HandleOrder(client, message)
        return
    }
    var reason interface{} = this.SafeString(message, "reason")
    if ccxt.IsTrue(ccxt.IsEqual(reason, "error")) {
        this.HandleError(client, message)
    }
    var methods interface{} = map[string]interface{} {
        "l2_updates": this.HandleL2Updates,
        "trade": this.HandleTrade,
        "subscription_ack": this.HandleSubscription,
        "heartbeat": this.HandleHeartbeat,
    }
    var typeVar interface{} = this.SafeString(message, "type", "")
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(typeVar, "candles"), 0)) {
        this.HandleOHLCV(client, message)
        return
    }
    var method interface{} = this.SafeValue(methods, typeVar)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
    // handle multimarketdata
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        var ts interface{} = this.SafeInteger(message, "timestampms", this.Milliseconds())
        var eventId interface{} = this.SafeInteger(message, "eventId")
        var events interface{} = this.SafeList(message, "events")
        var orderBookItems interface{} = []interface{}{}
        var bidaskItems interface{} = []interface{}{}
        var collectedEventsOfTrades interface{} = []interface{}{}
        var eventsLength interface{} =         ccxt.GetArrayLength(events)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(events)); i++ {
            var event interface{} = ccxt.GetValue(events, i)
            var eventType interface{} = this.SafeString(event, "type")
            var isOrderBook interface{} = ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(eventType, "change"))) && ccxt.IsTrue((ccxt.InOp(event, "side")))) && ccxt.IsTrue(this.InArray(ccxt.GetValue(event, "side"), []interface{}{"ask", "bid"}))
            var eventReason interface{} = this.SafeString(event, "reason")
            var isBidAsk interface{} = ccxt.IsTrue((ccxt.IsEqual(eventReason, "top-of-book"))) || ccxt.IsTrue((ccxt.IsTrue(ccxt.IsTrue(isOrderBook) && ccxt.IsTrue((ccxt.IsEqual(eventReason, "initial")))) && ccxt.IsTrue(ccxt.IsEqual(eventsLength, 2))))
            if ccxt.IsTrue(isBidAsk) {
                ccxt.AppendToArray(&bidaskItems, event)
            } else if ccxt.IsTrue(isOrderBook) {
                ccxt.AppendToArray(&orderBookItems, event)
            } else if ccxt.IsTrue(ccxt.IsEqual(eventType, "trade")) {
                ccxt.AppendToArray(&collectedEventsOfTrades, ccxt.GetValue(events, i))
            }
        }
        var lengthBa interface{} =         ccxt.GetArrayLength(bidaskItems)
        if ccxt.IsTrue(ccxt.IsGreaterThan(lengthBa, 0)) {
            this.HandleBidsAsksForMultidata(client, bidaskItems, ts, eventId)
        }
        var lengthOb interface{} =         ccxt.GetArrayLength(orderBookItems)
        if ccxt.IsTrue(ccxt.IsGreaterThan(lengthOb, 0)) {
            this.HandleOrderBookForMultidata(client, orderBookItems, ts, eventId)
        }
        var lengthTrades interface{} =         ccxt.GetArrayLength(collectedEventsOfTrades)
        if ccxt.IsTrue(ccxt.IsGreaterThan(lengthTrades, 0)) {
            this.HandleTradesForMultidata(client, collectedEventsOfTrades, ts)
        }
    }
}
func  (this *GeminiCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = this.SafeString(params, "url")
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(this.Clients, nil))) && ccxt.IsTrue((ccxt.InOp(this.Clients, url)))) {
        
                return nil
            }
            this.CheckRequiredCredentials()
            var startIndex interface{} =     ccxt.GetArrayLength(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"))
            var urlParamsIndex interface{} = ccxt.GetIndexOf(url, "?")
            var urlLength interface{} =     ccxt.GetLength(url)
            var endIndex interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(urlParamsIndex, 0))), urlParamsIndex, urlLength)
            var request interface{} = ccxt.Slice(url, startIndex, endIndex)
            var payload interface{} = map[string]interface{} {
                "request": request,
                "nonce": this.Nonce(),
            }
            var b64 interface{} = this.StringToBase64(this.Json(payload))
            var signature interface{} = this.Hmac(this.Encode(b64), this.Encode(this.Secret), ccxt.Sha384, "hex")
            var defaultOptions interface{} = map[string]interface{} {
                "ws": map[string]interface{} {
                    "options": map[string]interface{} {
                        "headers": map[string]interface{} {},
                    },
                },
            }
            // this.options = this.extend (defaultOptions, this.options)
            this.ExtendExchangeOptions(defaultOptions)
            var originalHeaders interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers")
            var headers interface{} = map[string]interface{} {
                "X-GEMINI-APIKEY": this.ApiKey,
                "X-GEMINI-PAYLOAD": b64,
                "X-GEMINI-SIGNATURE": signature,
            }
            ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers", headers)
            this.Client(url)
            ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(this.Options, "ws"), "options"), "headers", originalHeaders)
                return nil
            }()
            return ch
        }


func (this *GeminiCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
