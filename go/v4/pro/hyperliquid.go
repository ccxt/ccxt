package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HyperliquidCore struct {
	*ccxt.HyperliquidCore
	base *ccxt.HyperliquidCore
}

func NewHyperliquidCore() *HyperliquidCore {
    p := &HyperliquidCore{}
	base := &ccxt.HyperliquidCore{}
	p.base = base
	p.HyperliquidCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *HyperliquidCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "createOrderWs": true,
            "createOrdersWs": true,
            "editOrderWs": true,
            "watchBalance": false,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPosition": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.hyperliquid.xyz/ws",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api.hyperliquid-testnet.xyz/ws",
                },
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 20000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {},
            },
        },
    })
}
/**
 * @method
 * @name hyperliquid#createOrdersWs
 * @description create a list of trade orders using WebSocket post request
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) CreateOrdersWs(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes678)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var ordersRequest interface{} = this.CreateOrdersRequest(orders, params)
            var wrapped interface{} = this.WrapAsPostAction(ordersRequest)
            var request interface{} = this.SafeDict(wrapped, "request", map[string]interface{} {})
            var requestId interface{} = this.SafeString(wrapped, "requestId")
        
            response:= (<-this.Watch(url, requestId, request, requestId))
            ccxt.PanicOnError(response)
            var responseOjb interface{} = this.SafeDict(response, "response", map[string]interface{} {})
            var data interface{} = this.SafeDict(responseOjb, "data", map[string]interface{} {})
            var statuses interface{} = this.SafeList(data, "statuses", []interface{}{})
        
            ch <- this.ParseOrders(statuses, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#createOrderWs
 * @description create a trade order using WebSocket post request
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.slippage] the slippage for market order
 * @param {string} [params.vaultAddress] the vault address for order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1018 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1018)
            orderglobalParamsVariable := this.ParseCreateEditOrderArgs(nil, symbol, typeVar, side, amount, price, params)
            order := ccxt.GetValue(orderglobalParamsVariable,0)
            globalParams := ccxt.GetValue(orderglobalParamsVariable,1)
        
            orders:= (<-this.CreateOrdersWs([]interface{}{order}, globalParams))
            ccxt.PanicOnError(orders)
            var ordersLength interface{} =     ccxt.GetArrayLength(orders)
            if ccxt.IsTrue(ccxt.IsEqual(ordersLength, 0)) {
        
                        // not sure why but it is happening sometimes
        ch <- this.SafeOrder(map[string]interface{} {})
                return nil
            }
            var parsedOrder interface{} = ccxt.GetValue(orders, 0)
        
            ch <- parsedOrder
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#editOrderWs
 * @description edit a trade order
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.vaultAddress] the vault address for order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1348)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            orderglobalParamsVariable := this.ParseCreateEditOrderArgs(id, symbol, typeVar, side, amount, price, params)
            order := ccxt.GetValue(orderglobalParamsVariable,0)
            globalParams := ccxt.GetValue(orderglobalParamsVariable,1)
            var postRequest interface{} = this.EditOrdersRequest([]interface{}{order}, globalParams)
            var wrapped interface{} = this.WrapAsPostAction(postRequest)
            var request interface{} = this.SafeDict(wrapped, "request", map[string]interface{} {})
            var requestId interface{} = this.SafeString(wrapped, "requestId")
        
            response:= (<-this.Watch(url, requestId, request, requestId))
            ccxt.PanicOnError(response)
            // response is the same as in this.editOrder
            var responseObject interface{} = this.SafeDict(response, "response", map[string]interface{} {})
            var dataObject interface{} = this.SafeDict(responseObject, "data", map[string]interface{} {})
            var statuses interface{} = this.SafeList(dataObject, "statuses", []interface{}{})
            var first interface{} = this.SafeDict(statuses, 0, map[string]interface{} {})
            var parsedOrder interface{} = this.ParseOrder(first, market)
        
            ch <- parsedOrder
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#cancelOrdersWs
 * @description cancel multiple orders using WebSocket post request
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/post-requests
 * @param {string[]} ids list of order ids to cancel
 * @param {string} symbol unified symbol of the market the orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderId] list of client order ids to cancel instead of order ids
 * @param {string} [params.vaultAddress] the vault address for order cancellation
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes1668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1668)
            var request interface{} = this.CancelOrdersRequest(ids, symbol, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var wrapped interface{} = this.WrapAsPostAction(request)
            var wsRequest interface{} = this.SafeDict(wrapped, "request", map[string]interface{} {})
            var requestId interface{} = this.SafeString(wrapped, "requestId")
        
            response:= (<-this.Watch(url, requestId, wsRequest, requestId))
            ccxt.PanicOnError(response)
            var responseObj interface{} = this.SafeDict(response, "response", map[string]interface{} {})
            var data interface{} = this.SafeDict(responseObj, "data", map[string]interface{} {})
            var statuses interface{} = this.SafeList(data, "statuses", []interface{}{})
            var orders interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(statuses)); i++ {
                var status interface{} = ccxt.GetValue(statuses, i)
                ccxt.AppendToArray(&orders, this.SafeOrder(map[string]interface{} {
                    "info": status,
                    "status": status,
                }))
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#cancelOrderWs
 * @description cancel a single order using WebSocket post request
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/post-requests
 * @param {string} id order id to cancel
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id to cancel instead of order id
 * @param {string} [params.vaultAddress] the vault address for order cancellation
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            orders:= (<-this.CancelOrdersWs([]interface{}{id}, symbol, params))
            ccxt.PanicOnError(orders)
        
            ch <- this.SafeDict(orders, 0)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HyperliquidCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2158)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "l2Book",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                },
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *HyperliquidCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2428)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var subMessageHash interface{} = ccxt.Add("orderbook:", symbol)
            var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = ccxt.ToString(this.Nonce())
            var request interface{} = map[string]interface{} {
                "id": id,
                "method": "unsubscribe",
                "subscription": map[string]interface{} {
                    "type": "l2Book",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                },
            }
            var message interface{} = this.Extend(request, params)
        
                retRes25815 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes25815)
                ch <- retRes25815
                return nil
        
            }()
            return ch
        }
func  (this *HyperliquidCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "l2Book",
    //         "data": {
    //             "coin": "BTC",
    //             "time": 1710131872708,
    //             "levels": [
    //                 [
    //                     {
    //                         "px": "68674.0",
    //                         "sz": "0.97139",
    //                         "n": 4
    //                     }
    //                 ],
    //                 [
    //                     {
    //                         "px": "68675.0",
    //                         "sz": "0.04396",
    //                         "n": 1
    //                     }
    //                 ]
    //             ]
    //         }
    //     }
    //
    var entry interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var coin interface{} = this.SafeString(entry, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var rawData interface{} = this.SafeList(entry, "levels", []interface{}{})
    var data interface{} = map[string]interface{} {
        "bids": this.SafeList(rawData, 0, []interface{}{}),
        "asks": this.SafeList(rawData, 1, []interface{}{}),
    }
    var timestamp interface{} = this.SafeInteger(entry, "time")
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "px", "sz")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook(snapshot)
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name hyperliquid#watchTicker
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HyperliquidCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HyperliquidCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3358)
            symbols = this.MarketSymbols(symbols, nil, true)
            var messageHash interface{} = "tickers"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "webData2",
                    "user": "0x0000000000000000000000000000000000000000",
                },
            }
        
            tickers:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
                return nil
            }
        
            ch <- this.Tickers
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *HyperliquidCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3638)
            symbols = this.MarketSymbols(symbols, nil, true)
            var subMessageHash interface{} = "tickers"
            var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "subscription": map[string]interface{} {
                    "type": "webData2",
                    "user": "0x0000000000000000000000000000000000000000",
                },
            }
        
                retRes37515 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes37515)
                ch <- retRes37515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("watchMyTrades", params)
            userAddress = ccxt.GetValue(userAddressparamsVariable,0)
            params = ccxt.GetValue(userAddressparamsVariable,1)
        
            retRes3938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3938)
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "userFills",
                    "user": userAddress,
                },
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HyperliquidCore) HandleWsTickers(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "webData2",
    //         "data": {
    //             "meta": {
    //                 "universe": [
    //                     {
    //                         "szDecimals": 5,
    //                         "name": "BTC",
    //                         "maxLeverage": 50,
    //                         "onlyIsolated": false
    //                     },
    //                     ...
    //                 ],
    //             },
    //             "assetCtxs": [
    //                 {
    //                     "funding": "0.00003005",
    //                     "openInterest": "2311.50778",
    //                     "prevDayPx": "63475.0",
    //                     "dayNtlVlm": "468043329.64289033",
    //                     "premium": "0.00094264",
    //                     "oraclePx": "64712.0",
    //                     "markPx": "64774.0",
    //                     "midPx": "64773.5",
    //                     "impactPxs": [
    //                         "64773.0",
    //                         "64774.0"
    //                     ]
    //                 },
    //                 ...
    //             ],
    //             "spotAssetCtxs": [
    //                 {
    //                     "prevDayPx": "0.20937",
    //                     "dayNtlVlm": "11188888.61984999",
    //                     "markPx": "0.19722",
    //                     "midPx": "0.197145",
    //                     "circulatingSupply": "598760557.12072003",
    //                     "coin": "PURR/USDC"
    //                 },
    //                 ...
    //             ],
    //         }
    //     }
    //
    // spot
    var rawData interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var spotAssets interface{} = this.SafeList(rawData, "spotAssetCtxs", []interface{}{})
    var parsedTickers interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(spotAssets)); i++ {
        var assetObject interface{} = ccxt.GetValue(spotAssets, i)
        var marketId interface{} = this.SafeString(assetObject, "coin")
        var market interface{} = this.SafeMarket(marketId, nil, nil, "spot")
        var ticker interface{} = this.ParseWsTicker(assetObject, market)
        ccxt.AppendToArray(&parsedTickers, ticker)
    }
    // perpetuals
    var meta interface{} = this.SafeDict(rawData, "meta", map[string]interface{} {})
    var universe interface{} = this.SafeList(meta, "universe", []interface{}{})
    var assetCtxs interface{} = this.SafeList(rawData, "assetCtxs", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(universe)); i++ {
        var data interface{} = this.Extend(this.SafeDict(universe, i, map[string]interface{} {}), this.SafeDict(assetCtxs, i, map[string]interface{} {}))
        var id interface{} = ccxt.Add(ccxt.GetValue(data, "name"), "/USDC:USDC")
        var market interface{} = this.SafeMarket(id, nil, nil, "swap")
        var ticker interface{} = this.ParseWsTicker(data, market)
        ccxt.AppendToArray(&parsedTickers, ticker)
    }
    var tickers interface{} = this.IndexBy(parsedTickers, "symbol")
    client.(ccxt.ClientInterface).Resolve(tickers, "tickers")
}
func  (this *HyperliquidCore) ParseWsTicker(rawTicker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTicker(rawTicker, market)
}
func  (this *HyperliquidCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "userFills",
    //         "data": {
    //             "isSnapshot": true,
    //             "user": "0x15f43d1f2dee81424afd891943262aa90f22cc2a",
    //             "fills": [
    //                 {
    //                     "coin": "BTC",
    //                     "px": "72528.0",
    //                     "sz": "0.11693",
    //                     "side": "A",
    //                     "time": 1710208712815,
    //                     "startPosition": "0.11693",
    //                     "dir": "Close Long",
    //                     "closedPnl": "-0.81851",
    //                     "hash": "0xc5adaf35f8402750c218040b0a7bc301130051521273b6f398b3caad3e1f3f5f",
    //                     "oid": 7484888874,
    //                     "crossed": true,
    //                     "fee": "2.968244",
    //                     "liquidationMarkPx": null,
    //                     "tid": 567547935839686,
    //                     "cloid": null
    //                 }
    //             ]
    //         }
    //     }
    //
    var entry interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trades interface{} = this.MyTrades
    var symbols interface{} = map[string]interface{} {}
    var data interface{} = this.SafeList(entry, "fills", []interface{}{})
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawTrade interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseWsTrade(rawTrade)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        trades.(ccxt.Appender).Append(parsed)
    }
    var keys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var currentMessageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(keys, i))
        client.(ccxt.ClientInterface).Resolve(trades, currentMessageHash)
    }
    // non-symbol specific
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
func  (this *HyperliquidCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // s
            // @method
            // @name hyperliquid#watchTrades
            // @description watches information on multiple trades made in a market
            // @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
            // @param {string} symbol unified market symbol of the market trades were made in
            // @param {int} [since] the earliest time in ms to fetch trades for
            // @param {int} [limit] the maximum number of trade structures to retrieve
            // @param {object} [params] extra parameters specific to the exchange API endpoint
            // @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
            //
            since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5658)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trade:", symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "trades",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                },
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#unWatchTrades
 * @description unWatches information on multiple trades made in a market
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *HyperliquidCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5958)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var subMessageHash interface{} = ccxt.Add("trade:", symbol)
            var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "subscription": map[string]interface{} {
                    "type": "trades",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                },
            }
            var message interface{} = this.Extend(request, params)
        
                retRes60915 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes60915)
                ch <- retRes60915
                return nil
        
            }()
            return ch
        }
func  (this *HyperliquidCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "trades",
    //         "data": [
    //             {
    //                 "coin": "BTC",
    //                 "side": "A",
    //                 "px": "68517.0",
    //                 "sz": "0.005",
    //                 "time": 1710125266669,
    //                 "hash": "0xc872699f116e012186620407fc08a802015e0097c5cce74710697f7272e6e959",
    //                 "tid": 981894269203506
    //             }
    //         ]
    //     }
    //
    var entry interface{} = this.SafeList(message, "data", []interface{}{})
    var first interface{} = this.SafeDict(entry, 0, map[string]interface{} {})
    var coin interface{} = this.SafeString(first, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var stored interface{} = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var trades interface{} = ccxt.GetValue(this.Trades, symbol)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(entry)); i++ {
        var data interface{} = this.SafeDict(entry, i)
        var trade interface{} = this.ParseWsTrade(data)
        trades.(ccxt.Appender).Append(trade)
    }
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
func  (this *HyperliquidCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchMyTrades
    //
    //     {
    //         "coin": "BTC",
    //         "px": "72528.0",
    //         "sz": "0.11693",
    //         "side": "A",
    //         "time": 1710208712815,
    //         "startPosition": "0.11693",
    //         "dir": "Close Long",
    //         "closedPnl": "-0.81851",
    //         "hash": "0xc5adaf35f8402750c218040b0a7bc301130051521273b6f398b3caad3e1f3f5f",
    //         "oid": 7484888874,
    //         "crossed": true,
    //         "fee": "2.968244",
    //         "liquidationMarkPx": null,
    //         "tid": 567547935839686,
    //         "cloid": null
    //     }
    //
    // fetchTrades
    //
    //     {
    //         "coin": "BTC",
    //         "side": "A",
    //         "px": "68517.0",
    //         "sz": "0.005",
    //         "time": 1710125266669,
    //         "hash": "0xc872699f116e012186620407fc08a802015e0097c5cce74710697f7272e6e959",
    //         "tid": 981894269203506
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var price interface{} = this.SafeString(trade, "px")
    var amount interface{} = this.SafeString(trade, "sz")
    var coin interface{} = this.SafeString(trade, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    market = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var id interface{} = this.SafeString(trade, "tid")
    var side interface{} = this.SafeString(trade, "side")
    if ccxt.IsTrue(!ccxt.IsEqual(side, nil)) {
        side = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "A"))), "sell", "buy")
    }
    var fee interface{} = this.SafeString(trade, "fee")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": this.SafeString(trade, "oid"),
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": map[string]interface{} {
            "cost": fee,
            "currency": "USDC",
        },
    }, market)
}
/**
 * @method
 * @name hyperliquid#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HyperliquidCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7278)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "candle",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                    "interval": timeframe,
                },
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
            var message interface{} = this.Extend(request, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hyperliquid#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *HyperliquidCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7598)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "subscription": map[string]interface{} {
                    "type": "candle",
                    "coin": ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "swap")), ccxt.GetValue(market, "baseName"), ccxt.GetValue(market, "id")),
                    "interval": timeframe,
                },
            }
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
            var messagehash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
            var message interface{} = this.Extend(request, params)
        
                retRes77415 :=  (<-this.Watch(url, messagehash, message, messagehash))
                ccxt.PanicOnError(retRes77415)
                ch <- retRes77415
                return nil
        
            }()
            return ch
        }
func  (this *HyperliquidCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         channel: 'candle',
    //         data: {
    //             t: 1710146280000,
    //             T: 1710146339999,
    //             s: 'BTC',
    //             i: '1m',
    //             o: '71400.0',
    //             c: '71411.0',
    //             h: '71422.0',
    //             l: '71389.0',
    //             v: '1.20407',
    //             n: 20
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var base interface{} = this.SafeString(data, "s")
    var marketId interface{} = this.CoinToMarketId(base)
    var symbol interface{} = this.SafeSymbol(marketId)
    var timeframe interface{} = this.SafeString(data, "i")
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored := ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcv interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseOHLCV(data)
    ohlcv.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(ohlcv, messageHash)
}
func  (this *HyperliquidCore) HandleWsPost(client interface{}, message interface{})  {
    //    {
    //         channel: "post",
    //         data: {
    //             id: <number>,
    //             response: {
    //                  type: "info" | "action" | "error",
    //                  payload: { ... }
    //         }
    //    }
    var data interface{} = this.SafeDict(message, "data")
    var id interface{} = this.SafeString(data, "id")
    var response interface{} = this.SafeDict(data, "response")
    var payload interface{} = this.SafeDict(response, "payload")
    client.(ccxt.ClientInterface).Resolve(payload, id)
}
/**
 * @method
 * @name hyperliquid#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/websocket/subscriptions
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *HyperliquidCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8458 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8458)
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("watchOrders", params)
            userAddress = ccxt.GetValue(userAddressparamsVariable,0)
            params = ccxt.GetValue(userAddressparamsVariable,1)
            var market interface{} = nil
            var messageHash interface{} = "order"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "subscription": map[string]interface{} {
                    "type": "orderUpdates",
                    "user": userAddress,
                },
            }
            var message interface{} = this.Extend(request, params)
        
            orders:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *HyperliquidCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         channel: 'orderUpdates',
    //         data: [
    //             {
    //                 order: {
    //                     coin: 'BTC',
    //                     side: 'B',
    //                     limitPx: '30000.0',
    //                     sz: '0.001',
    //                     oid: 7456484275,
    //                     timestamp: 1710163596492,
    //                     origSz: '0.001'
    //                 },
    //                 status: 'open',
    //                 statusTimestamp: 1710163596492
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    var stored interface{} = this.Orders
    var messageHash interface{} = "order"
    var marketSymbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawOrder interface{} = ccxt.GetValue(data, i)
        var order interface{} = this.ParseOrder(rawOrder)
        stored.(ccxt.Appender).Append(order)
        var symbol interface{} = this.SafeString(order, "symbol")
        ccxt.AddElementToObject(marketSymbols, symbol, true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketSymbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var symbol interface{} = ccxt.GetValue(keys, i)
        var innerMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(stored, innerMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *HyperliquidCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //      "channel": "post",
    //      "data": {
    //        "id": 1,
    //        "response": {
    //          "type": "action",
    //          "payload": {
    //            "status": "ok",
    //            "response": {
    //              "type": "order",
    //              "data": {
    //                "statuses": [
    //                  {
    //                    "error": "ccxt.Order price cannot be more than 80% away from the reference price"
    //                  }
    //                ]
    //              }
    //            }
    //          }
    //        }
    //      }
    //    }
    //
    //    {
    //         "channel": "error",
    //         "data": "ccxt.Error parsing JSON into valid websocket request: { \"type\": \"allMids\" }"
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel", "")
    if ccxt.IsTrue(ccxt.IsEqual(channel, "error")) {
        var ret_msg interface{} = this.SafeString(message, "data", "")
        var errorMsg interface{} = ccxt.Add(ccxt.Add(this.Id, " "), ret_msg)
        client.(ccxt.ClientInterface).Reject(errorMsg)
        return true
    }
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var id interface{} = this.SafeString(message, "id")
    if ccxt.IsTrue(ccxt.IsEqual(id, nil)) {
        id = this.SafeString(data, "id")
    }
    var response interface{} = this.SafeDict(data, "response", map[string]interface{} {})
    var payload interface{} = this.SafeDict(response, "payload", map[string]interface{} {})
    var status interface{} = this.SafeString(payload, "status")
    if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(status, nil)) && ccxt.IsTrue(!ccxt.IsEqual(status, "ok"))) {
        var errorMsg interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(payload))
        client.(ccxt.ClientInterface).Reject(errorMsg, id)
        return true
    }
    var typeVar interface{} = this.SafeString(payload, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "error")) {
        var error interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(payload))
        client.(ccxt.ClientInterface).Reject(error, id)
        return true
    }
    
        {
             func(this *HyperliquidCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *HyperliquidCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e, id)
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        this.HandleErrors(0, "", "", "", map[string]interface{} {}, this.Json(payload), payload, map[string]interface{} {}, map[string]interface{} {})
    		    return nil
    	    }(this)
        
            }
    return false
}
func  (this *HyperliquidCore) HandleOrderBookUnsubscription(client interface{}, subscription interface{})  {
    //
    //        "subscription":{
    //           "type":"l2Book",
    //           "coin":"BTC",
    //           "nSigFigs":5,
    //           "mantissa":null
    //        }
    //
    var coin interface{} = this.SafeString(subscription, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    var symbol interface{} = this.SafeSymbol(marketId)
    var subMessageHash interface{} = ccxt.Add("orderbook:", symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
}
func  (this *HyperliquidCore) HandleTradesUnsubscription(client interface{}, subscription interface{})  {
    //
    var coin interface{} = this.SafeString(subscription, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    var symbol interface{} = this.SafeSymbol(marketId)
    var subMessageHash interface{} = ccxt.Add("trade:", symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
        ccxt.Remove(this.Trades, symbol)
    }
}
func  (this *HyperliquidCore) HandleTickersUnsubscription(client interface{}, subscription interface{})  {
    //
    var subMessageHash interface{} = "tickers"
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    var symbols interface{} = ccxt.ObjectKeys(this.Tickers)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        ccxt.Remove(this.Tickers, ccxt.GetValue(symbols, i))
    }
}
func  (this *HyperliquidCore) HandleOHLCVUnsubscription(client interface{}, subscription interface{})  {
    var coin interface{} = this.SafeString(subscription, "coin")
    var marketId interface{} = this.CoinToMarketId(coin)
    var symbol interface{} = this.SafeSymbol(marketId)
    var interval interface{} = this.SafeString(subscription, "interval")
    var timeframe interface{} = this.FindTimeframe(interval)
    var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
    var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
    if ccxt.IsTrue(ccxt.InOp(this.Ohlcvs, symbol)) {
        if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)) {
            ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        }
    }
}
func  (this *HyperliquidCore) HandleSubscriptionResponse(client interface{}, message interface{})  {
    // {
    //     "channel":"subscriptionResponse",
    //     "data":{
    //        "method":"unsubscribe",
    //        "subscription":{
    //           "type":"l2Book",
    //           "coin":"BTC",
    //           "nSigFigs":5,
    //           "mantissa":null
    //        }
    //     }
    // }
    //
    //  {
    //      "channel":"subscriptionResponse",
    //      "data":{
    //         "method":"unsubscribe",
    //         "subscription":{
    //            "type":"trades",
    //            "coin":"PURR/USDC"
    //         }
    //      }
    //  }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var method interface{} = this.SafeString(data, "method")
    if ccxt.IsTrue(ccxt.IsEqual(method, "unsubscribe")) {
        var subscription interface{} = this.SafeDict(data, "subscription", map[string]interface{} {})
        var typeVar interface{} = this.SafeString(subscription, "type")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "l2Book")) {
            this.HandleOrderBookUnsubscription(client, subscription)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "trades")) {
            this.HandleTradesUnsubscription(client, subscription)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "webData2")) {
            this.HandleTickersUnsubscription(client, subscription)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "candle")) {
            this.HandleOHLCVUnsubscription(client, subscription)
        }
    }
}
func  (this *HyperliquidCore) HandleMessage(client interface{}, message interface{})  {
    //
    // {
    //     "channel":"subscriptionResponse",
    //     "data":{
    //        "method":"unsubscribe",
    //        "subscription":{
    //           "type":"l2Book",
    //           "coin":"BTC",
    //           "nSigFigs":5,
    //           "mantissa":null
    //        }
    //     }
    // }
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var topic interface{} = this.SafeString(message, "channel", "")
    var methods interface{} = map[string]interface{} {
        "pong": this.HandlePong,
        "trades": this.HandleTrades,
        "l2Book": this.HandleOrderBook,
        "candle": this.HandleOHLCV,
        "orderUpdates": this.HandleOrder,
        "userFills": this.HandleMyTrades,
        "webData2": this.HandleWsTickers,
        "post": this.HandleWsPost,
        "subscriptionResponse": this.HandleSubscriptionResponse,
    }
    var exacMethod interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(exacMethod, nil)) {
        ccxt.CallDynamically(exacMethod, client, message)
        return
    }
    var keys interface{} = ccxt.ObjectKeys(methods)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, ccxt.GetValue(keys, i)), 0)) {
            var method interface{} = ccxt.GetValue(methods, key)
            ccxt.CallDynamically(method, client, message)
            return
        }
    }
}
func  (this *HyperliquidCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "method": "ping",
    }
}
func  (this *HyperliquidCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "channel": "pong"
    //   }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.SafeInteger(message, "pong"))
    return message
}
func  (this *HyperliquidCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
func  (this *HyperliquidCore) WrapAsPostAction(request interface{}) interface{}  {
    var requestId interface{} = this.RequestId()
    return map[string]interface{} {
        "requestId": requestId,
        "request": map[string]interface{} {
            "method": "post",
            "id": requestId,
            "request": map[string]interface{} {
                "type": "action",
                "payload": request,
            },
        },
    }
}


func (this *HyperliquidCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
