package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type NdaxCore struct {
	*ccxt.NdaxCore
	base *ccxt.NdaxCore
}

func NewNdaxCore() *NdaxCore {
    p := &NdaxCore{}
	base := &ccxt.NdaxCore{}
	p.base = base
	p.NdaxCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *NdaxCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOrderBook": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchTicker": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": "wss://ndaxmarginstaging.cdnhop.net:10456/WSAdminGatewa/",
            },
            "api": map[string]interface{} {
                "ws": "wss://api.ndax.io/WSGateway",
            },
        },
    })
}
func  (this *NdaxCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
/**
 * @method
 * @name ndax#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidoc.ndax.io/#subscribelevel1
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *NdaxCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes548)
            var market interface{} = this.Market(symbol)
            var name interface{} = "SubscribeLevel1"
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var payload interface{} = map[string]interface{} {
                "OMSId": omsId,
                "InstrumentId": ccxt.ParseInt(ccxt.GetValue(market, "id")),
            }
            var request interface{} = map[string]interface{} {
                "m": 0,
                "i": requestId,
                "n": name,
                "o": this.Json(payload),
            }
            var message interface{} = this.Extend(request, params)
        
                retRes7215 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes7215)
                ch <- retRes7215
                return nil
        
            }()
            return ch
        }
func  (this *NdaxCore) HandleTicker(client interface{}, message interface{})  {
    var payload interface{} = this.SafeValue(message, "o", map[string]interface{} {})
    //
    //     {
    //         "OMSId": 1,
    //         "InstrumentId": 1,
    //         "BestBid": 6423.57,
    //         "BestOffer": 6436.53,
    //         "LastTradedPx": 6423.57,
    //         "LastTradedQty": 0.96183964,
    //         "LastTradeTime": 1534862990343,
    //         "SessionOpen": 6249.64,
    //         "SessionHigh": 11111,
    //         "SessionLow": 4433,
    //         "SessionClose": 6249.64,
    //         "Volume": 0.96183964,
    //         "CurrentDayVolume": 3516.31668185,
    //         "CurrentDayNumTrades": 8529,
    //         "CurrentDayPxChange": 173.93,
    //         "CurrentNotional": 0.0,
    //         "Rolling24HrNotional": 0.0,
    //         "Rolling24HrVolume": 4319.63870783,
    //         "Rolling24NumTrades": 10585,
    //         "Rolling24HrPxChange": -0.4165607307408487,
    //         "TimeStamp": "1534862990358"
    //     }
    //
    var ticker interface{} = this.ParseTicker(payload)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    var market interface{} = this.Market(symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var name interface{} = "SubscribeLevel1"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
/**
 * @method
 * @name ndax#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidoc.ndax.io/#subscribetrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *NdaxCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes1248 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1248)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var name interface{} = "SubscribeTrades"
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var payload interface{} = map[string]interface{} {
                "OMSId": omsId,
                "InstrumentId": ccxt.ParseInt(ccxt.GetValue(market, "id")),
                "IncludeLastCount": 100,
            }
            var request interface{} = map[string]interface{} {
                "m": 0,
                "i": requestId,
                "n": name,
                "o": this.Json(payload),
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *NdaxCore) HandleTrades(client interface{}, message interface{})  {
    var payload interface{} = this.SafeValue(message, "o", []interface{}{})
    //
    // initial snapshot
    //
    //     [
    //         [
    //             6913253,       //  0 TradeId
    //             8,             //  1 ProductPairCode
    //             0.03340802,    //  2 Quantity
    //             19116.08,      //  3 Price
    //             2543425077,    //  4 Order1
    //             2543425482,    //  5 Order2
    //             1606935922416, //  6 Tradetime
    //             0,             //  7 Direction
    //             1,             //  8 TakerSide
    //             0,             //  9 BlockTrade
    //             0,             // 10 Either Order1ClientId or Order2ClientId
    //         ]
    //     ]
    //
    var name interface{} = "SubscribeTrades"
    var updates interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(payload)); i++ {
        var trade interface{} = this.ParseTrade(ccxt.GetValue(payload, i))
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            tradesArray = ccxt.NewArrayCache(limit)
        }
        tradesArray.(ccxt.Appender).Append(trade)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
        ccxt.AddElementToObject(updates, symbol, true)
    }
    var symbols interface{} = ccxt.ObjectKeys(updates)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        var symbol interface{} = ccxt.GetValue(symbols, i)
        var market interface{} = this.Market(symbol)
        var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
        var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
        client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    }
}
/**
 * @method
 * @name ndax#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://apidoc.ndax.io/#subscribeticker
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *NdaxCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes2098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2098)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var name interface{} = "SubscribeTicker"
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, ":"), timeframe), ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            var payload interface{} = map[string]interface{} {
                "OMSId": omsId,
                "InstrumentId": ccxt.ParseInt(ccxt.GetValue(market, "id")),
                "Interval": ccxt.ParseInt(this.SafeString(this.Timeframes, timeframe, timeframe)),
                "IncludeLastCount": 100,
            }
            var request interface{} = map[string]interface{} {
                "m": 0,
                "i": requestId,
                "n": name,
                "o": this.Json(payload),
            }
            var message interface{} = this.Extend(request, params)
        
            ohlcv:= (<-this.Watch(url, messageHash, message, messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *NdaxCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "m": 1,
    //         "i": 1,
    //         "n": "SubscribeTicker",
    //         "o": [[1608284160000,23113.52,23070.88,23075.76,23075.39,162.44964300,23075.38,23075.39,8,1608284100000]],
    //     }
    //
    var payload interface{} = this.SafeValue(message, "o", []interface{}{})
    //
    //     [
    //         [
    //             1501603632000,      // 0 DateTime
    //             2700.33,            // 1 High
    //             2687.01,            // 2 Low
    //             2687.01,            // 3 Open
    //             2687.01,            // 4 Close
    //             24.86100992,        // 5 Volume
    //             0,                  // 6 Inside Bid Price
    //             2870.95,            // 7 Inside Ask Price
    //             1                   // 8 InstrumentId
    //             1608290188062.7678, // 9 candle timestamp
    //         ]
    //     ]
    //
    var updates interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(payload)); i++ {
        var ohlcv interface{} = ccxt.GetValue(payload, i)
        var marketId interface{} = this.SafeString(ohlcv, 8)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        ccxt.AddElementToObject(updates, marketId, map[string]interface{} {})
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var keys interface{} = ccxt.ObjectKeys(this.Timeframes)
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(keys)); j++ {
            var timeframe interface{} = ccxt.GetValue(keys, j)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var duration interface{} = ccxt.Multiply(ccxt.ParseInt(interval), 1000)
            var timestamp interface{} = this.SafeInteger(ohlcv, 0)
            var parsed interface{} = []interface{}{this.ParseToInt(ccxt.Multiply((ccxt.Divide(timestamp, duration)), duration)), this.SafeFloat(ohlcv, 3), this.SafeFloat(ohlcv, 1), this.SafeFloat(ohlcv, 2), this.SafeFloat(ohlcv, 4), this.SafeFloat(ohlcv, 5)}
            var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, []interface{}{})
            var length interface{} =             ccxt.GetArrayLength(stored)
            if ccxt.IsTrue(ccxt.IsTrue(length) && ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(parsed, 0), ccxt.GetValue(ccxt.GetValue(stored, ccxt.Subtract(length, 1)), 0))))) {
                var previous interface{} = ccxt.GetValue(stored, ccxt.Subtract(length, 1))
                ccxt.AddElementToObject(stored, ccxt.Subtract(length, 1), []interface{}{ccxt.GetValue(parsed, 0), ccxt.GetValue(previous, 1), ccxt.MathMax(ccxt.GetValue(parsed, 1), ccxt.GetValue(previous, 1)), ccxt.MathMin(ccxt.GetValue(parsed, 2), ccxt.GetValue(previous, 2)), ccxt.GetValue(parsed, 4), this.Sum(ccxt.GetValue(parsed, 5), ccxt.GetValue(previous, 5))})
                ccxt.AddElementToObject(ccxt.GetValue(updates, marketId), timeframe, true)
            } else {
                if ccxt.IsTrue(ccxt.IsTrue(length) && ccxt.IsTrue((ccxt.IsLessThan(ccxt.GetValue(parsed, 0), ccxt.GetValue(ccxt.GetValue(stored, ccxt.Subtract(length, 1)), 0))))) {
                    continue
                } else {
                    ccxt.AppendToArray(&stored, parsed)
                    var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
                    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(length, limit)) {
                        ccxt.Shift(stored)
                    }
                    ccxt.AddElementToObject(ccxt.GetValue(updates, marketId), timeframe, true)
                }
            }
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
    }
    var name interface{} = "SubscribeTicker"
    var marketIds interface{} = ccxt.ObjectKeys(updates)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var timeframes interface{} = ccxt.ObjectKeys(ccxt.GetValue(updates, marketId))
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(timeframes)); j++ {
            var timeframe interface{} = ccxt.GetValue(timeframes, j)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(name, ":"), timeframe), ":"), marketId)
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, []interface{}{})
            client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        }
    }
}
/**
 * @method
 * @name ndax#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apidoc.ndax.io/#subscribelevel2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *NdaxCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes3408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3408)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var name interface{} = "SubscribeLevel2"
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var requestId interface{} = this.RequestId()
            limit = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(limit, nil))), 100, limit)
            var payload interface{} = map[string]interface{} {
                "OMSId": omsId,
                "InstrumentId": ccxt.ParseInt(ccxt.GetValue(market, "id")),
                "Depth": limit,
            }
            var request interface{} = map[string]interface{} {
                "m": 0,
                "i": requestId,
                "n": name,
                "o": this.Json(payload),
            }
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
                "messageHash": messageHash,
                "name": name,
                "symbol": symbol,
                "marketId": ccxt.GetValue(market, "id"),
                "method": this.HandleOrderBookSubscription,
                "limit": limit,
                "params": params,
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *NdaxCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "m": 3,
    //         "i": 2,
    //         "n": "Level2UpdateEvent",
    //         "o": [[2,1,1608208308265,0,20782.49,1,25000,8,1,1]]
    //     }
    //
    var payload interface{} = this.SafeValue(message, "o", []interface{}{})
    //
    //     [
    //         0,   // 0 MDUpdateId
    //         1,   // 1 Number of ccxt.Unique Accounts
    //         123, // 2 ActionDateTime in Posix format X 1000
    //         0,   // 3 ActionType 0 (New), 1 (Update), 2(Delete)
    //         0.0, // 4 LastTradePrice
    //         0,   // 5 Number of Orders
    //         0.0, // 6 Price
    //         0,   // 7 ProductPairCode
    //         0.0, // 8 Quantity
    //         0,   // 9 Side
    //     ],
    //
    var firstBidAsk interface{} = this.SafeValue(payload, 0, []interface{}{})
    var marketId interface{} = this.SafeString(firstBidAsk, 7)
    if ccxt.IsTrue(ccxt.IsEqual(marketId, nil)) {
        return
    }
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        return
    }
    var timestamp interface{} = nil
    var nonce interface{} = nil
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(payload)); i++ {
        var bidask interface{} = ccxt.GetValue(payload, i)
        if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
            timestamp = this.SafeInteger(bidask, 2)
        } else {
            var newTimestamp interface{} = this.SafeInteger(bidask, 2)
            timestamp = ccxt.MathMax(timestamp, newTimestamp)
        }
        if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
            nonce = this.SafeInteger(bidask, 0)
        } else {
            var newNonce interface{} = this.SafeInteger(bidask, 0)
            nonce = ccxt.MathMax(nonce, newNonce)
        }
        // 0 new, 1 update, 2 remove
        var typeVar interface{} = this.SafeInteger(bidask, 3)
        var price interface{} = this.SafeFloat(bidask, 6)
        var amount interface{} = this.SafeFloat(bidask, 8)
        var side interface{} = this.SafeInteger(bidask, 9)
        // 0 buy, 1 sell, 2 short reserved for future use, 3 unknown
        var orderbookSide interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, 0))), ccxt.GetValue(orderbook, "bids"), ccxt.GetValue(orderbook, "asks"))
        // 0 new, 1 update, 2 remove
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, 0)) {
            orderbookSide.(ccxt.IOrderBookSide).Store(price, amount)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, 1)) {
            orderbookSide.(ccxt.IOrderBookSide).Store(price, amount)
        } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, 2)) {
            orderbookSide.(ccxt.IOrderBookSide).Store(price, 0)
        }
    }
    ccxt.AddElementToObject(orderbook, "nonce", nonce)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var name interface{} = "SubscribeLevel2"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), marketId)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *NdaxCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    //
    //     {
    //         "m": 1,
    //         "i": 1,
    //         "n": "SubscribeLevel2",
    //         "o": [[1,1,1608204295901,0,20782.49,1,18200,8,1,0]]
    //     }
    //
    var payload interface{} = this.SafeValue(message, "o", []interface{}{})
    //
    //     [
    //         [
    //             0,   // 0 MDUpdateId
    //             1,   // 1 Number of ccxt.Unique Accounts
    //             123, // 2 ActionDateTime in Posix format X 1000
    //             0,   // 3 ActionType 0 (New), 1 (Update), 2(Delete)
    //             0.0, // 4 LastTradePrice
    //             0,   // 5 Number of Orders
    //             0.0, // 6 Price
    //             0,   // 7 ProductPairCode
    //             0.0, // 8 Quantity
    //             0,   // 9 Side
    //         ],
    //     ]
    //
    var symbol interface{} = this.SafeString(subscription, "symbol")
    var snapshot interface{} = this.ParseOrderBook(payload, symbol)
    var limit interface{} = this.SafeInteger(subscription, "limit")
    var orderbook interface{} = this.OrderBook(snapshot, limit)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    var messageHash interface{} = this.SafeString(subscription, "messageHash")
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *NdaxCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    //
    //     {
    //         "m": 1,
    //         "i": 1,
    //         "n": "SubscribeLevel2",
    //         "o": "[[1,1,1608204295901,0,20782.49,1,18200,8,1,0]]"
    //     }
    //
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var id interface{} = this.SafeInteger(message, "i")
    var subscription interface{} = this.SafeValue(subscriptionsById, id)
    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
        var method interface{} = this.SafeValue(subscription, "method")
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message, subscription)
        }
    }
}
func  (this *NdaxCore) HandleMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "m": 0, // message type, 0 request, 1 reply, 2 subscribe, 3 event, unsubscribe, 5 error
    //         "i": 0, // sequence number identifies an individual request or request-and-response pair, to your application
    //         "n":"function name", // function name is the name of the function being called or that the server is responding to, the server echoes your call
    //         "o":"payload", // JSON-formatted string containing the data being sent with the message
    //     }
    //
    //     {
    //         "m": 1,
    //         "i": 1,
    //         "n": "SubscribeLevel2",
    //         "o": "[[1,1,1608204295901,0,20782.49,1,18200,8,1,0]]"
    //     }
    //
    //     {
    //         "m": 3,
    //         "i": 2,
    //         "n": "Level2UpdateEvent",
    //         "o": "[[2,1,1608208308265,0,20782.49,1,25000,8,1,1]]"
    //     }
    //
    var payload interface{} = this.SafeString(message, "o")
    if ccxt.IsTrue(ccxt.IsEqual(payload, nil)) {
        return
    }
    ccxt.AddElementToObject(message, "o", ccxt.JsonParse(payload))
    var methods interface{} = map[string]interface{} {
        "SubscribeLevel2": this.HandleSubscriptionStatus,
        "SubscribeLevel1": this.HandleTicker,
        "Level2UpdateEvent": this.HandleOrderBook,
        "Level1UpdateEvent": this.HandleTicker,
        "SubscribeTrades": this.HandleTrades,
        "TradeDataUpdateEvent": this.HandleTrades,
        "SubscribeTicker": this.HandleOHLCV,
        "TickerDataUpdateEvent": this.HandleOHLCV,
    }
    var event interface{} = this.SafeString(message, "n")
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *NdaxCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
