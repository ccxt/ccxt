package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitfinexCore struct {
	*ccxt.BitfinexCore
	base *ccxt.BitfinexCore
}

func NewBitfinexCore() *BitfinexCore {
    p := &BitfinexCore{}
	base := &ccxt.BitfinexCore{}
	p.base = base
	p.BitfinexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitfinexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchOrderBook": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": true,
            "watchBalance": true,
            "watchOHLCV": true,
            "watchOrders": true,
            "unWatchTicker": true,
            "unWatchTrades": true,
            "unWatchOHLCV": true,
            "unWatchOrderBook": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api-pub.bitfinex.com/ws/2",
                    "private": "wss://api.bitfinex.com/ws/2",
                },
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "prec": "P0",
                "freq": "F0",
                "checksum": true,
            },
            "ordersLimit": 1000,
        },
    })
}
func  (this *BitfinexCore) Subscribe(channel interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes528)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = ccxt.GetValue(market, "id")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var client interface{} = this.Client(url)
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "channel": channel,
                "symbol": marketId,
            }
        
            result:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash, map[string]interface{} {
            "checksum": false,
        }))
            ccxt.PanicOnError(result)
            var checksum interface{} = this.SafeBool(this.Options, "checksum", true)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(checksum) && !ccxt.IsTrue(ccxt.GetValue(ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash), "checksum"))) && ccxt.IsTrue((ccxt.IsEqual(channel, "book")))) {
                ccxt.AddElementToObject(ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash), "checksum", true)
        
                retRes6712 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                    "event": "conf",
                    "flags": 131072,
                }))
                ccxt.PanicOnError(retRes6712)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) UnSubscribe(channel interface{}, topic interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes768)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = ccxt.GetValue(market, "id")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var client interface{} = this.Client(url)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", channel), ":"), marketId)
            var unSubTopic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe", ":"), topic), ":"), symbol)
            var channelId interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), unSubTopic)
            var request interface{} = map[string]interface{} {
                "event": "unsubscribe",
                "chanId": channelId,
            }
            var unSubChanMsg interface{} = ccxt.Add("unsubscribe:", channelId)
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), unSubChanMsg, subMessageHash)
            var subscription interface{} = map[string]interface{} {
                "messageHashes": []interface{}{messageHash},
                "subMessageHashes": []interface{}{subMessageHash},
                "topic": topic,
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
            }
        
                retRes9815 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes9815)
                ch <- retRes9815
                return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) SubscribePrivate(messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            retRes1028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1028)
        
            retRes1038 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes1038)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
        
                retRes10515 :=  (<-this.Watch(url, messageHash, nil, 1))
                ccxt.PanicOnError(retRes10515)
                ch <- retRes10515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitfinexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1208)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var channel interface{} = "candles"
            var key interface{} = ccxt.Add(ccxt.Add(ccxt.Add("trade:", interval), ":"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channel, ":"), interval), ":"), ccxt.GetValue(market, "id"))
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "channel": channel,
                "key": key,
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            // not using subscribe here because this message has a different format
        
            ohlcv:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {bool} true if successfully unsubscribed, false otherwise
 */
func  (this *BitfinexCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1518)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var channel interface{} = "candles"
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channel, ":"), interval), ":"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("unsubscribe:", subMessageHash)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var client interface{} = this.Client(url)
            var subId interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:trade:", interval), ":"), ccxt.GetValue(market, "id")) // trade here because we use the key
            var channelId interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), subId)
            var request interface{} = map[string]interface{} {
                "event": "unsubscribe",
                "chanId": channelId,
            }
            var unSubChanMsg interface{} = ccxt.Add("unsubscribe:", channelId)
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), unSubChanMsg, subMessageHash)
            var subscription interface{} = map[string]interface{} {
                "messageHashes": []interface{}{messageHash},
                "subMessageHashes": []interface{}{subMessageHash},
                "topic": "ohlcv",
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
            }
        
                retRes17515 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash, subscription))
                ccxt.PanicOnError(retRes17515)
                ch <- retRes17515
                return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleOHLCV(client interface{}, message interface{}, subscription interface{})  {
    //
    // initial snapshot
    //   [
    //       341527, // channel id
    //       [
    //          [
    //             1654705860000, // timestamp
    //             1802.6, // open
    //             1800.3, // close
    //             1802.8, // high
    //             1800.3, // low
    //             86.49588236 // volume
    //          ],
    //          [
    //             1654705800000,
    //             1803.6,
    //             1802.6,
    //             1804.9,
    //             1802.3,
    //             74.6348086
    //          ],
    //          [
    //             1654705740000,
    //             1802.5,
    //             1803.2,
    //             1804.4,
    //             1802.4,
    //             23.61801085
    //          ]
    //       ]
    //   ]
    //
    // update
    //   [
    //       211171,
    //       [
    //          1654705680000,
    //          1801,
    //          1802.4,
    //          1802.9,
    //          1800.4,
    //          23.91911091
    //       ]
    //   ]
    //
    var data interface{} = this.SafeValue(message, 1, []interface{}{})
    var ohlcvs interface{} = nil
    var first interface{} = this.SafeValue(data, 0)
    if ccxt.IsTrue(ccxt.IsArray(first)) {
        // snapshot
        ohlcvs = data
    } else {
        // update
        ohlcvs = []interface{}{data}
    }
    var channel interface{} = this.SafeValue(subscription, "channel")
    var key interface{} = this.SafeString(subscription, "key")
    var keyParts interface{} = ccxt.Split(key, ":")
    var interval interface{} = this.SafeString(keyParts, 1)
    var marketId interface{} = key
    marketId = ccxt.Replace(marketId, "trade:", "")
    marketId = ccxt.Replace(marketId, ccxt.Add(interval, ":"), "")
    var market interface{} = this.SafeMarket(marketId)
    var timeframe interface{} = this.FindTimeframe(interval)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channel, ":"), interval), ":"), marketId)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcvsLength interface{} =     ccxt.GetArrayLength(ohlcvs)
    for i := 0; ccxt.IsLessThan(i, ohlcvsLength); i++ {
        var ohlcv interface{} = ccxt.GetValue(ohlcvs, ccxt.Subtract(ccxt.Subtract(ohlcvsLength, i), 1))
        var parsed interface{} = this.ParseOHLCV(ohlcv, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name bitfinex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitfinexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            trades:= (<-this.Subscribe("trades", symbol, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#unWatchTrades
 * @description unWatches the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitfinexCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes28815 :=  (<-this.UnSubscribe("trades", "trades", symbol, params))
                ccxt.PanicOnError(retRes28815)
                ch <- retRes28815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitfinexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3028)
            var messageHash interface{} = "myTrade"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
            }
        
            trades:= (<-this.SubscribePrivate(messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitfinexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes32415 :=  (<-this.Subscribe("ticker", symbol, params))
                ccxt.PanicOnError(retRes32415)
                ch <- retRes32415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitfinex#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitfinexCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes33615 :=  (<-this.UnSubscribe("ticker", "ticker", symbol, params))
                ccxt.PanicOnError(retRes33615)
                ch <- retRes33615
                return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleMyTrade(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    // trade execution
    // [
    //     0,
    //     "te", // or tu
    //     [
    //        1133411090,
    //        "tLTCUST",
    //        1655110144598,
    //        97084883506,
    //        0.1,
    //        42.821,
    //        "EXCHANGE MARKET",
    //        42.799,
    //        -1,
    //        null,
    //        null,
    //        1655110144596
    //     ]
    // ]
    //
    subscription := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = subscription
    var name interface{} = "myTrade"
    var data interface{} = this.SafeValue(message, 2)
    var trade interface{} = this.ParseWsTrade(data)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var market interface{} = this.Market(symbol)
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var tradesArray interface{} = this.MyTrades
    tradesArray.(ccxt.Appender).Append(trade)
    this.MyTrades = tradesArray
    // generic subscription
    client.(ccxt.ClientInterface).Resolve(tradesArray, name)
    // specific subscription
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
func  (this *BitfinexCore) HandleTrades(client interface{}, message interface{}, subscription interface{})  {
    //
    // initial snapshot
    //
    //    [
    //        188687, // channel id
    //        [
    //          [ 1128060675, 1654701572690, 0.00217533, 1815.3 ], // id, mts, amount, price
    //          [ 1128060665, 1654701551231, -0.00280472, 1814.1 ],
    //          [ 1128060664, 1654701550996, -0.00364444, 1814.1 ],
    //          [ 1128060656, 1654701527730, -0.00265203, 1814.2 ],
    //          [ 1128060647, 1654701505193, 0.00262395, 1815.2 ],
    //          [ 1128060642, 1654701484656, -0.13411443, 1816 ],
    //          [ 1128060641, 1654701484656, -0.00088557, 1816 ],
    //          [ 1128060639, 1654701478326, -0.002, 1816 ],
    //        ]
    //    ]
    // update
    //
    //    [
    //        360141,
    //        "te",
    //        [
    //            1128060969, // id
    //            1654702500098, // mts
    //            0.00325131, // amount positive buy, negative sell
    //            1818.5, // price
    //        ],
    //    ]
    //
    //
    var channel interface{} = this.SafeValue(subscription, "channel")
    var marketId interface{} = this.SafeString(subscription, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        stored = ccxt.NewArrayCache(tradesLimit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var messageLength interface{} =     ccxt.GetArrayLength(message)
    if ccxt.IsTrue(ccxt.IsEqual(messageLength, 2)) {
        // initial snapshot
        var trades interface{} = this.SafeList(message, 1, []interface{}{})
        // needs to be reversed to make chronological order
        var length interface{} =         ccxt.GetArrayLength(trades)
        for i := 0; ccxt.IsLessThan(i, length); i++ {
            var index interface{} = ccxt.Subtract(ccxt.Subtract(length, i), 1)
            var parsed interface{} = this.ParseWsTrade(ccxt.GetValue(trades, index), market)
            stored.(ccxt.Appender).Append(parsed)
        }
    } else {
        // update
        var typeVar interface{} = this.SafeString(message, 1)
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "tu")) {
            // don't resolve for a duplicate update
            // since te and tu updates are duplicated on the public stream
            return
        }
        var trade interface{} = this.SafeValue(message, 2, []interface{}{})
        var parsed interface{} = this.ParseWsTrade(trade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *BitfinexCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [
    //        1128060969, // id
    //        1654702500098, // mts
    //        0.00325131, // amount positive buy, negative sell
    //        1818.5, // price
    //    ]
    //
    // trade execution
    //
    //    [
    //        1133411090, // id
    //        "tLTCUST", // symbol
    //        1655110144598, // create ms
    //        97084883506, // order id
    //        0.1, // amount
    //        42.821, // price
    //        "EXCHANGE MARKET", // order type
    //        42.799, // order price
    //        -1, // maker
    //        null, // fee
    //        null, // fee currency
    //        1655110144596 // cid
    //    ]
    //
    // trade update
    //
    //    [
    //       1133411090,
    //       "tLTCUST",
    //       1655110144598,
    //       97084883506,
    //       0.1,
    //       42.821,
    //       "EXCHANGE MARKET",
    //       42.799,
    //       -1,
    //       -0.0002,
    //       "LTC",
    //       1655110144596
    //    ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var numFields interface{} =     ccxt.GetArrayLength(trade)
    var isPublic interface{} = ccxt.IsLessThanOrEqual(numFields, 8)
    var marketId interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsTrue(isPublic))), this.SafeString(trade, 1), nil)
    market = this.SafeMarket(marketId, market)
    var createdKey interface{} = ccxt.Ternary(ccxt.IsTrue(isPublic), 1, 2)
    var priceKey interface{} = ccxt.Ternary(ccxt.IsTrue(isPublic), 3, 5)
    var amountKey interface{} = ccxt.Ternary(ccxt.IsTrue(isPublic), 2, 4)
    marketId = ccxt.GetValue(market, "id")
    var typeVar interface{} = this.SafeString(trade, 6)
    if ccxt.IsTrue(!ccxt.IsEqual(typeVar, nil)) {
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(typeVar, "LIMIT"), ccxt.OpNeg(1))) {
            typeVar = "limit"
        } else if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(typeVar, "MARKET"), ccxt.OpNeg(1))) {
            typeVar = "market"
        }
    }
    var orderId interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsTrue(isPublic))), this.SafeString(trade, 3), nil)
    var id interface{} = this.SafeString(trade, 0)
    var timestamp interface{} = this.SafeInteger(trade, createdKey)
    var price interface{} = this.SafeString(trade, priceKey)
    var amountString interface{} = this.SafeString(trade, amountKey)
    var amount interface{} = this.ParseNumber(ccxt.Precise.StringAbs(amountString))
    var side interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(amount, nil)) {
        side = ccxt.Ternary(ccxt.IsTrue(ccxt.Precise.StringGt(amountString, "0")), "buy", "sell")
    }
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var feeValue interface{} = this.SafeString(trade, 9)
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeValue, nil)) {
        var currencyId interface{} = this.SafeString(trade, 10)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        fee = map[string]interface{} {
            "cost": feeValue,
            "currency": code,
        }
    }
    var maker interface{} = this.SafeInteger(trade, 8)
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(maker, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(maker, ccxt.OpNeg(1)))), "taker", "maker")
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
func  (this *BitfinexCore) HandleTicker(client interface{}, message interface{}, subscription interface{})  {
    //
    // [
    //    340432, // channel ID
    //     [
    //         236.62,        // 1 BID float Price of last highest bid
    //         9.0029,        // 2 BID_SIZE float Size of the last highest bid
    //         236.88,        // 3 ASK float Price of last lowest ask
    //         7.1138,        // 4 ASK_SIZE float Size of the last lowest ask
    //         -1.02,         // 5 DAILY_CHANGE float Amount that the last price has changed since yesterday
    //         0,             // 6 DAILY_CHANGE_PERC float Amount that the price has changed expressed in percentage terms
    //         236.52,        // 7 LAST_PRICE float Price of the last trade.
    //         5191.36754297, // 8 VOLUME float Daily volume
    //         250.01,        // 9 HIGH float Daily high
    //         220.05,        // 10 LOW float Daily low
    //     ]
    //  ]
    //
    var ticker interface{} = this.SafeValue(message, 1)
    var marketId interface{} = this.SafeString(subscription, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId)
    var parsed interface{} = this.ParseWsTicker(ticker, market)
    var channel interface{} = "ticker"
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
}
func  (this *BitfinexCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         236.62,        // 1 BID float Price of last highest bid
    //         9.0029,        // 2 BID_SIZE float Size of the last highest bid
    //         236.88,        // 3 ASK float Price of last lowest ask
    //         7.1138,        // 4 ASK_SIZE float Size of the last lowest ask
    //         -1.02,         // 5 DAILY_CHANGE float Amount that the last price has changed since yesterday
    //         0,             // 6 DAILY_CHANGE_PERC float Amount that the price has changed expressed in percentage terms
    //         236.52,        // 7 LAST_PRICE float Price of the last trade.
    //         5191.36754297, // 8 VOLUME float Daily volume
    //         250.01,        // 9 HIGH float Daily high
    //         220.05,        // 10 LOW float Daily low
    //     ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(nil, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var last interface{} = this.SafeString(ticker, 6)
    var change interface{} = this.SafeString(ticker, 4)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, 8),
        "low": this.SafeString(ticker, 9),
        "bid": this.SafeString(ticker, 0),
        "bidVolume": this.SafeString(ticker, 1),
        "ask": this.SafeString(ticker, 2),
        "askVolume": this.SafeString(ticker, 3),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": this.SafeString(ticker, 5),
        "average": nil,
        "baseVolume": this.SafeString(ticker, 7),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitfinex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitfinexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(limit, 25))) && ccxt.IsTrue((!ccxt.IsEqual(limit, 100)))) {
                    panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBook limit argument must be undefined, 25 or 100")))
                }
            }
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var prec interface{} = this.SafeString(options, "prec", "P0")
            var freq interface{} = this.SafeString(options, "freq", "F0")
            var request interface{} = map[string]interface{} {
                "prec": prec,
                "freq": freq,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(request, "len", limit) // string, number of price points, '25', '100', default = '25'
            }
        
            orderbook:= (<-this.Subscribe("book", symbol, this.DeepExtend(request, params)))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleOrderBook(client interface{}, message interface{}, subscription interface{})  {
    //
    // first message (snapshot)
    //
    //     [
    //         18691, // channel id
    //         [
    //             [ 7364.8, 10, 4.354802 ], // price, count, size > 0 = bid
    //             [ 7364.7, 1, 0.00288831 ],
    //             [ 7364.3, 12, 0.048 ],
    //             [ 7364.9, 3, -0.42028976 ], // price, count, size < 0 = ask
    //             [ 7365, 1, -0.25 ],
    //             [ 7365.5, 1, -0.00371937 ],
    //         ]
    //     ]
    //
    // subsequent updates
    //
    //     [
    //         358169, // channel id
    //         [
    //            1807.1, // price
    //            0, // cound
    //            1 // size
    //         ]
    //     ]
    //
    var marketId interface{} = this.SafeString(subscription, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var channel interface{} = "book"
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    var prec interface{} = this.SafeString(subscription, "prec", "P0")
    var isRaw interface{} =     (ccxt.IsEqual(prec, "R0"))
    // if it is an initial snapshot
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var limit interface{} = this.SafeInteger(subscription, "len")
        if ccxt.IsTrue(isRaw) {
            // raw order books
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook(map[string]interface{} {}, limit))
        } else {
            // P0, P1, P2, P3, P4
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.CountedOrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        if ccxt.IsTrue(isRaw) {
            var deltas interface{} = ccxt.GetValue(message, 1)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
                var delta interface{} = ccxt.GetValue(deltas, i)
                var delta2 interface{} = ccxt.GetValue(delta, 2)
                var size interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(delta2, 0))), ccxt.OpNeg(delta2), delta2)
                var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(delta2, 0))), "asks", "bids")
                var bookside interface{} = ccxt.GetValue(orderbook, side)
                var idString interface{} = this.SafeString(delta, 0)
                var price interface{} = this.SafeFloat(delta, 1)
                bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, size, idString})
            }
        } else {
            var deltas interface{} = ccxt.GetValue(message, 1)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
                var delta interface{} = ccxt.GetValue(deltas, i)
                var amount interface{} = this.SafeNumber(delta, 2)
                var counter interface{} = this.SafeNumber(delta, 1)
                var price interface{} = this.SafeNumber(delta, 0)
                var size interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(amount, 0))), ccxt.OpNeg(amount), amount)
                var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(amount, 0))), "asks", "bids")
                var bookside interface{} = ccxt.GetValue(orderbook, side)
                bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, size, counter})
            }
        }
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    } else {
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var deltas interface{} = ccxt.GetValue(message, 1)
        var orderbookItem interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        if ccxt.IsTrue(isRaw) {
            var price interface{} = this.SafeString(deltas, 1)
            var deltas2 interface{} = ccxt.GetValue(deltas, 2)
            var size interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(deltas2, 0))), ccxt.OpNeg(deltas2), deltas2)
            var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsLessThan(deltas2, 0))), "asks", "bids")
            var bookside interface{} = ccxt.GetValue(orderbookItem, side)
            // price = 0 means that you have to remove the order from your book
            var amount interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.Precise.StringGt(price, "0")), size, "0")
            var idString interface{} = this.SafeString(deltas, 0)
            bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{this.ParseNumber(price), this.ParseNumber(amount), idString})
        } else {
            var amount interface{} = this.SafeString(deltas, 2)
            var counter interface{} = this.SafeString(deltas, 1)
            var price interface{} = this.SafeString(deltas, 0)
            var size interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.Precise.StringLt(amount, "0")), ccxt.Precise.StringNeg(amount), amount)
            var side interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.Precise.StringLt(amount, "0")), "asks", "bids")
            var bookside interface{} = ccxt.GetValue(orderbookItem, side)
            bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{this.ParseNumber(price), this.ParseNumber(size), this.ParseNumber(counter)})
        }
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *BitfinexCore) HandleChecksum(client interface{}, message interface{}, subscription interface{})  {
    //
    // [ 173904, "cs", -890884919 ]
    //
    var marketId interface{} = this.SafeString(subscription, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var channel interface{} = "book"
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    var book interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(book, nil)) {
        return
    }
    var depth interface{} = 25 // covers the first 25 bids and asks
    var stringArray interface{} = []interface{}{}
    var bids interface{} = ccxt.GetValue(book, "bids")
    var asks interface{} = ccxt.GetValue(book, "asks")
    var prec interface{} = this.SafeString(subscription, "prec", "P0")
    var isRaw interface{} =     (ccxt.IsEqual(prec, "R0"))
    var idToCheck interface{} = ccxt.Ternary(ccxt.IsTrue(isRaw), 2, 0)
    // pepperoni pizza from bitfinex
    for i := 0; ccxt.IsLessThan(i, depth); i++ {
        var bid interface{} = this.SafeValue(bids, i)
        var ask interface{} = this.SafeValue(asks, i)
        if ccxt.IsTrue(!ccxt.IsEqual(bid, nil)) {
            ccxt.AppendToArray(&stringArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(bids, i), idToCheck)))
            ccxt.AppendToArray(&stringArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(bids, i), 1)))
        }
        if ccxt.IsTrue(!ccxt.IsEqual(ask, nil)) {
            ccxt.AppendToArray(&stringArray, this.NumberToString(ccxt.GetValue(ccxt.GetValue(asks, i), idToCheck)))
            var aski1 interface{} = ccxt.GetValue(ccxt.GetValue(asks, i), 1)
            ccxt.AppendToArray(&stringArray, this.NumberToString(ccxt.OpNeg(aski1)))
        }
    }
    var payload interface{} = ccxt.Join(stringArray, ":")
    var localChecksum interface{} = this.Crc32(payload, true)
    var responseChecksum interface{} = this.SafeInteger(message, 2)
    if ccxt.IsTrue(!ccxt.IsEqual(responseChecksum, localChecksum)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        ccxt.Remove(this.Orderbooks, symbol)
        var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
        if ccxt.IsTrue(checksum) {
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            client.(ccxt.ClientInterface).Reject(error, messageHash)
        }
    }
}
/**
 * @method
 * @name bitfinex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BitfinexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8058 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8058)
            var balanceType interface{} = this.SafeString(params, "wallet", "exchange") // exchange, margin
            params = this.Omit(params, "wallet")
            var messageHash interface{} = ccxt.Add("balance:", balanceType)
        
                retRes80915 :=  (<-this.SubscribePrivate(messageHash))
                ccxt.PanicOnError(retRes80915)
                ch <- retRes80915
                return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleBalance(client interface{}, message interface{}, subscription interface{})  {
    //
    // snapshot (exchange + margin together)
    //   [
    //       0,
    //       "ws",
    //       [
    //           [
    //               "exchange",
    //               "LTC",
    //               0.05479727,
    //               0,
    //               null,
    //               "Trading fees for 0.05 LTC (LTCUST) @ 51.872 on BFX (0.2%)",
    //               null,
    //           ]
    //           [
    //               "margin",
    //               "USTF0",
    //               11.960650700086292,
    //               0,
    //               null,
    //               "Trading fees for 0.1 LTCF0 (LTCF0:USTF0) @ 51.844 on BFX (0.065%)",
    //               null,
    //           ],
    //       ],
    //   ]
    //
    // spot
    //   [
    //       0,
    //       "wu",
    //       [
    //         "exchange",
    //         "LTC", // currency
    //         0.06729727, // wallet balance
    //         0, // unsettled balance
    //         0.06729727, // available balance might be null
    //         "ccxt.Exchange 0.4 LTC for UST @ 65.075",
    //         {
    //           "reason": "TRADE",
    //           "order_id": 96596397973,
    //           "order_id_oppo": 96596632735,
    //           "trade_price": "65.075",
    //           "trade_amount": "-0.4",
    //           "order_cid": 1654636218766,
    //           "order_gid": null
    //         }
    //       ]
    //   ]
    //
    // margin
    //
    //   [
    //       "margin",
    //       "USTF0",
    //       11.960650700086292, // total
    //       0,
    //       6.776250700086292, // available
    //       "Trading fees for 0.1 LTCF0 (LTCF0:USTF0) @ 51.844 on BFX (0.065%)",
    //       null
    //   ]
    //
    var updateType interface{} = this.SafeValue(message, 1)
    var data interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(updateType, "ws")) {
        data = this.SafeValue(message, 2)
    } else {
        data = []interface{}{this.SafeValue(message, 2)}
    }
    var updatedTypes interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawBalance interface{} = ccxt.GetValue(data, i)
        var currencyId interface{} = this.SafeString(rawBalance, 1)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var balance interface{} = this.ParseWsBalance(rawBalance)
        var balanceType interface{} = this.SafeString(rawBalance, 0)
        var oldBalance interface{} = this.SafeValue(this.Balance, balanceType, map[string]interface{} {})
        ccxt.AddElementToObject(oldBalance, code, balance)
        ccxt.AddElementToObject(oldBalance, "info", message)
        ccxt.AddElementToObject(this.Balance, balanceType, this.SafeBalance(oldBalance))
        ccxt.AddElementToObject(updatedTypes, balanceType, true)
    }
    var updatesKeys interface{} = ccxt.ObjectKeys(updatedTypes)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(updatesKeys)); i++ {
        var typeVar interface{} = ccxt.GetValue(updatesKeys, i)
        var messageHash interface{} = ccxt.Add("balance:", typeVar)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), messageHash)
    }
}
func  (this *BitfinexCore) ParseWsBalance(balance interface{}) interface{}  {
    //
    //     [
    //         "exchange",
    //         "LTC",
    //         0.05479727, // balance
    //         0,
    //         null, // available null if not calculated yet
    //         "Trading fees for 0.05 LTC (LTCUST) @ 51.872 on BFX (0.2%)",
    //         null,
    //     ]
    //
    var totalBalance interface{} = this.SafeString(balance, 2)
    var availableBalance interface{} = this.SafeString(balance, 4)
    var account interface{} = this.Account()
    if ccxt.IsTrue(!ccxt.IsEqual(availableBalance, nil)) {
        ccxt.AddElementToObject(account, "free", availableBalance)
    }
    ccxt.AddElementToObject(account, "total", totalBalance)
    return account
}
func  (this *BitfinexCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "event": "info",
    //         "version": 2,
    //         "serverId": "e293377e-7bb7-427e-b28c-5db045b2c1d1",
    //         "platform": { status: 1 }, // 1 for operative, 0 for maintenance
    //     }
    //
    return message
}
func  (this *BitfinexCore) HandleUnsubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "event": "unsubscribed",
    //     "status": "OK",
    //     "chanId": CHANNEL_ID
    // }
    //
    var channelId interface{} = this.SafeString(message, "chanId")
    var unSubChannel interface{} = ccxt.Add("unsubscribe:", channelId)
    var subMessageHash interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), unSubChannel)
    var subscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), ccxt.Add("unsubscribe:", subMessageHash))
    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), unSubChannel)
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, messageHash)
    }
    this.CleanCache(subscription)
    return true
}
func  (this *BitfinexCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "event": "subscribed",
    //         "channel": "book",
    //         "chanId": 67473,
    //         "symbol": "tBTCUSD",
    //         "prec": "P0",
    //         "freq": "F0",
    //         "len": "25",
    //         "pair": "BTCUSD"
    //     }
    //
    //   {
    //       event: 'subscribed',
    //       channel: 'candles',
    //       chanId: 128306,
    //       key: 'trade:1m:tBTCUST'
    //  }
    //
    var channelId interface{} = this.SafeString(message, "chanId")
    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), channelId, message)
    // store the opposite direction too for unWatch
    var mappings interface{} = map[string]interface{} {
        "book": "orderbook",
        "candles": "ohlcv",
        "ticker": "ticker",
        "trades": "trades",
    }
    var unifiedChannel interface{} = this.SafeString(mappings, this.SafeString(message, "channel"))
    if ccxt.IsTrue(ccxt.InOp(message, "key")) {
        // handle ohlcv differently because the message is different
        var key interface{} = this.SafeString(message, "key")
        var subKeyId interface{} = ccxt.Add("unsubscribe:", key)
        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subKeyId, channelId)
    } else {
        var marketId interface{} = this.SafeString(message, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId)
        if ccxt.IsTrue(!ccxt.IsEqual(unifiedChannel, nil)) {
            var subId interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", unifiedChannel), ":"), symbol)
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subId, channelId)
        }
    }
    return message
}
func  (this *BitfinexCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var nonce interface{} = this.Milliseconds()
                var payload interface{} = ccxt.Add("AUTH", ccxt.ToString(nonce))
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha384, "hex")
                var event interface{} = "auth"
                var request interface{} = map[string]interface{} {
                    "apiKey": this.ApiKey,
                    "authSig": signature,
                    "authNonce": nonce,
                    "authPayload": payload,
                    "event": event,
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes102815 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes102815)
                ch <- retRes102815
                return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    var messageHash interface{} = "authenticated"
    var status interface{} = this.SafeString(message, "status")
    if ccxt.IsTrue(ccxt.IsEqual(status, "OK")) {
        // we resolve the future here permanently so authentication only happens once
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        // allows further authentication attempts
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
/**
 * @method
 * @name bitfinex#watchOrders
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitfinexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10598)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", ccxt.GetValue(market, "id")))
            }
        
            orders:= (<-this.SubscribePrivate(messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitfinexCore) HandleOrders(client interface{}, message interface{}, subscription interface{})  {
    //
    // limit order
    //    [
    //        0,
    //        "on", // ou or oc
    //        [
    //           96923856256, // order id
    //           null, // gid
    //           1655029337026, // cid
    //           "tLTCUST", // symbol
    //           1655029337027, // created timestamp
    //           1655029337029, // updated timestamp
    //           0.1, // amount
    //           0.1, // amount_orig
    //           "EXCHANGE LIMIT", // order type
    //           null, // type_prev
    //           null, // mts_tif
    //           null, // placeholder
    //           0, // flags
    //           "ACTIVE", // status
    //           null,
    //           null,
    //           30, // price
    //           0, // price average
    //           0, // price_trailling
    //           0, // price_aux_limit
    //           null,
    //           null,
    //           null,
    //           0, // notify
    //           0,
    //           null,
    //           null,
    //           null,
    //           "BFX",
    //           null,
    //           null,
    //        ]
    //    ]
    //
    var data interface{} = this.SafeValue(message, 2, []interface{}{})
    var messageType interface{} = this.SafeString(message, 1)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var symbolIds interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsEqual(messageType, "os")) {
        var snapshotLength interface{} =         ccxt.GetArrayLength(data)
        if ccxt.IsTrue(ccxt.IsEqual(snapshotLength, 0)) {
            return
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var value interface{} = ccxt.GetValue(data, i)
            var parsed interface{} = this.ParseWsOrder(value)
            var symbol interface{} = ccxt.GetValue(parsed, "symbol")
            ccxt.AddElementToObject(symbolIds, symbol, true)
            orders.(ccxt.Appender).Append(parsed)
        }
    } else {
        var parsed interface{} = this.ParseWsOrder(data)
        orders.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbolIds, symbol, true)
    }
    var name interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(this.Orders, name)
    var keys interface{} = ccxt.ObjectKeys(symbolIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var symbol interface{} = ccxt.GetValue(keys, i)
        var market interface{} = this.Market(symbol)
        var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
    }
}
func  (this *BitfinexCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ACTIVE": "open",
        "CANCELED": "canceled",
        "EXECUTED": "closed",
        "PARTIALLY": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *BitfinexCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   [
    //       97084883506, // order id
    //       null,
    //       1655110144596, // clientOrderId
    //       "tLTCUST", // symbol
    //       1655110144596, // created timestamp
    //       1655110144598, // updated timestamp
    //       0, // amount
    //       0.1, // amount_orig negative if sell order
    //       "EXCHANGE MARKET", // type
    //       null,
    //       null,
    //       null,
    //       0,
    //       "EXECUTED @ 42.821(0.1)", // status
    //       null,
    //       null,
    //       42.799, // price
    //       42.821, // price average
    //       0, // price trailling
    //       0, // price_aux_limit
    //       null,
    //       null,
    //       null,
    //       0,
    //       0,
    //       null,
    //       null,
    //       null,
    //       "BFX",
    //       null,
    //       null,
    //       {}
    //   ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, 0)
    var clientOrderId interface{} = this.SafeString(order, 1)
    var marketId interface{} = this.SafeString(order, 3)
    var symbol interface{} = this.SafeSymbol(marketId)
    market = this.SafeMarket(symbol)
    var amount interface{} = this.SafeString(order, 7)
    var side interface{} = "buy"
    if ccxt.IsTrue(ccxt.Precise.StringLt(amount, "0")) {
        amount = ccxt.Precise.StringAbs(amount)
        side = "sell"
    }
    var remaining interface{} = ccxt.Precise.StringAbs(this.SafeString(order, 6))
    var typeVar interface{} = this.SafeString(order, 8)
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(typeVar, "LIMIT"), ccxt.OpNeg(1))) {
        typeVar = "limit"
    } else if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(typeVar, "MARKET"), ccxt.OpNeg(1))) {
        typeVar = "market"
    }
    var rawState interface{} = this.SafeString(order, 13)
    var stateParts interface{} = ccxt.Split(rawState, " ")
    var trimmedStatus interface{} = this.SafeString(stateParts, 0)
    var status interface{} = this.ParseWsOrderStatus(trimmedStatus)
    var price interface{} = this.SafeString(order, 16)
    var timestamp interface{} = this.SafeInteger2(order, 5, 4)
    var average interface{} = this.SafeString(order, 17)
    var stopPrice interface{} = this.OmitZero(this.SafeString(order, 18))
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "average": average,
        "amount": amount,
        "remaining": remaining,
        "filled": nil,
        "status": status,
        "fee": nil,
        "cost": nil,
        "trades": nil,
    }, market)
}
func  (this *BitfinexCore) HandleMessage(client interface{}, message interface{})  {
    var channelId interface{} = this.SafeString(message, 0)
    //
    //     [
    //         1231,
    //         "hb",
    //     ]
    //
    // auth message
    //    {
    //        "event": "auth",
    //        "status": "OK",
    //        "chanId": 0,
    //        "userId": 3159883,
    //        "auth_id": "ac7108e7-2f26-424d-9982-c24700dc02ca",
    //        "caps": {
    //          "orders": { read: 1, write: 1 },
    //          "account": { read: 1, write: 1 },
    //          "funding": { read: 1, write: 1 },
    //          "history": { read: 1, write: 0 },
    //          "wallets": { read: 1, write: 1 },
    //          "withdraw": { read: 0, write: 1 },
    //          "positions": { read: 1, write: 1 },
    //          "ui_withdraw": { read: 0, write: 0 }
    //        }
    //    }
    //
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(message, 1), "hb")) {
            return  // skip heartbeats within subscription channels for now
        }
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), channelId, map[string]interface{} {})
        var channel interface{} = this.SafeString(subscription, "channel")
        var name interface{} = this.SafeString(message, 1)
        var publicMethods interface{} = map[string]interface{} {
            "book": this.HandleOrderBook,
            "cs": this.HandleChecksum,
            "candles": this.HandleOHLCV,
            "ticker": this.HandleTicker,
            "trades": this.HandleTrades,
        }
        var privateMethods interface{} = map[string]interface{} {
            "os": this.HandleOrders,
            "ou": this.HandleOrders,
            "on": this.HandleOrders,
            "oc": this.HandleOrders,
            "wu": this.HandleBalance,
            "ws": this.HandleBalance,
            "tu": this.HandleMyTrade,
        }
        var method interface{} = nil
        if ccxt.IsTrue(ccxt.IsEqual(channelId, "0")) {
            method = this.SafeValue(privateMethods, name)
        } else {
            method = this.SafeValue2(publicMethods, name, channel)
        }
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message, subscription)
        }
    } else {
        var event interface{} = this.SafeString(message, "event")
        if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
            var methods interface{} = map[string]interface{} {
                "info": this.HandleSystemStatus,
                "subscribed": this.HandleSubscriptionStatus,
                "unsubscribed": this.HandleUnsubscriptionStatus,
                "auth": this.HandleAuthenticationMessage,
            }
            var method interface{} = this.SafeValue(methods, event)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
            }
        }
    }
}


func (this *BitfinexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
