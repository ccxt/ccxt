package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CryptocomCore struct {
	*ccxt.CryptocomCore
	base *ccxt.CryptocomCore
}

func NewCryptocomCore() *CryptocomCore {
    p := &CryptocomCore{}
	base := &ccxt.CryptocomCore{}
	p.base = base
	p.CryptocomCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CryptocomCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchMyTrades": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchOHLCV": true,
            "watchPositions": true,
            "createOrderWs": true,
            "cancelOrderWs": true,
            "cancelAllOrders": true,
            "editOrderWs": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://stream.crypto.com/exchange/v1/market",
                    "private": "wss://stream.crypto.com/exchange/v1/user",
                },
            },
            "test": map[string]interface{} {
                "public": "wss://uat-stream.3ona.co/exchange/v1/market",
                "private": "wss://uat-stream.3ona.co/exchange/v1/user",
            },
        },
        "options": map[string]interface{} {
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
            "watchOrderBook": map[string]interface{} {
                "checksum": true,
            },
        },
        "streaming": map[string]interface{} {},
    })
}
func  (this *CryptocomCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    
                {
                     func(this *CryptocomCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *CryptocomCore) interface{} {
                                    // catch block:
                                            error := ccxt.NetworkError(ccxt.Add(ccxt.Add(this.Id, " pong failed with error "), this.Json(e)))
                    client.(ccxt.ClientInterface).Reset(error)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes6712 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                        "id": this.SafeInteger(message, "id"),
                        "method": "public/respond-heartbeat",
                    }))
                    ccxt.PanicOnError(retRes6712)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#book-instrument_name
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.bookSubscriptionType] The subscription type. Allowed values: SNAPSHOT full snapshot. This is the default if not specified. SNAPSHOT_AND_UPDATE delta updates
 * @param {int} [params.bookUpdateFrequency] Book update interval in ms. Allowed values: 100 for snapshot subscription 10 for delta subscription
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CryptocomCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes8715 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes8715)
                ch <- retRes8715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#book-instrument_name
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.bookSubscriptionType] The subscription type. Allowed values: SNAPSHOT full snapshot. This is the default if not specified. SNAPSHOT_AND_UPDATE delta updates
 * @param {int} [params.bookUpdateFrequency] Book update interval in ms. Allowed values: 100 for snapshot subscription 10 for delta subscription
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CryptocomCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes10215 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes10215)
                ch <- retRes10215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#book-instrument_name
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.bookSubscriptionType] The subscription type. Allowed values: SNAPSHOT full snapshot. This is the default if not specified. SNAPSHOT_AND_UPDATE delta updates
 * @param {int} [params.bookUpdateFrequency] Book update interval in ms. Allowed values: 100 for snapshot subscription 10 for delta subscription
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CryptocomCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1188)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            if !ccxt.IsTrue(limit) {
                limit = 50
            }
            var topicParams interface{} = this.SafeValue(params, "params")
            if ccxt.IsTrue(ccxt.IsEqual(topicParams, nil)) {
                ccxt.AddElementToObject(params, "params", map[string]interface{} {})
            }
            var bookSubscriptionType interface{} = nil
            var bookSubscriptionType2 interface{} = nil
            bookSubscriptionTypeparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "bookSubscriptionType", "SNAPSHOT_AND_UPDATE")
            bookSubscriptionType = ccxt.GetValue(bookSubscriptionTypeparamsVariable,0)
            params = ccxt.GetValue(bookSubscriptionTypeparamsVariable,1)
            bookSubscriptionType2paramsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "bookSubscriptionType", bookSubscriptionType)
            bookSubscriptionType2 = ccxt.GetValue(bookSubscriptionType2paramsVariable,0)
            params = ccxt.GetValue(bookSubscriptionType2paramsVariable,1)
            ccxt.AddElementToObject(ccxt.GetValue(params, "params"), "bookSubscriptionType", bookSubscriptionType2)
            var bookUpdateFrequency interface{} = nil
            var bookUpdateFrequency2 interface{} = nil
            bookUpdateFrequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "bookUpdateFrequency")
            bookUpdateFrequency = ccxt.GetValue(bookUpdateFrequencyparamsVariable,0)
            params = ccxt.GetValue(bookUpdateFrequencyparamsVariable,1)
            bookUpdateFrequency2paramsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "bookUpdateFrequency", bookUpdateFrequency)
            bookUpdateFrequency2 = ccxt.GetValue(bookUpdateFrequency2paramsVariable,0)
            params = ccxt.GetValue(bookUpdateFrequency2paramsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(bookUpdateFrequency2, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(params, "params"), "bookSubscriptionType", bookUpdateFrequency2)
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var currentTopic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("book", "."), ccxt.GetValue(market, "id")), "."), ccxt.ToString(limit))
                var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
                ccxt.AppendToArray(&messageHashes, messageHash)
                ccxt.AppendToArray(&topics, currentTopic)
            }
        
            orderbook:= (<-this.WatchPublicMultiple(messageHashes, topics, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#book-instrument_name
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is 50
 * @param {string} [params.bookSubscriptionType] The subscription type. Allowed values: SNAPSHOT full snapshot. This is the default if not specified. SNAPSHOT_AND_UPDATE delta updates
 * @param {int} [params.bookUpdateFrequency] Book update interval in ms. Allowed values: 100 for snapshot subscription 10 for delta subscription
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CryptocomCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1668)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var limit interface{} = this.SafeInteger(params, "limit", 50)
            var topicParams interface{} = this.SafeValue(params, "params")
            if ccxt.IsTrue(ccxt.IsEqual(topicParams, nil)) {
                ccxt.AddElementToObject(params, "params", map[string]interface{} {})
            }
            var bookSubscriptionType interface{} = nil
            var bookSubscriptionType2 interface{} = nil
            bookSubscriptionTypeparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "bookSubscriptionType", "SNAPSHOT_AND_UPDATE")
            bookSubscriptionType = ccxt.GetValue(bookSubscriptionTypeparamsVariable,0)
            params = ccxt.GetValue(bookSubscriptionTypeparamsVariable,1)
            bookSubscriptionType2paramsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "bookSubscriptionType", bookSubscriptionType)
            bookSubscriptionType2 = ccxt.GetValue(bookSubscriptionType2paramsVariable,0)
            params = ccxt.GetValue(bookSubscriptionType2paramsVariable,1)
            ccxt.AddElementToObject(ccxt.GetValue(params, "params"), "bookSubscriptionType", bookSubscriptionType2)
            var bookUpdateFrequency interface{} = nil
            var bookUpdateFrequency2 interface{} = nil
            bookUpdateFrequencyparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "bookUpdateFrequency")
            bookUpdateFrequency = ccxt.GetValue(bookUpdateFrequencyparamsVariable,0)
            params = ccxt.GetValue(bookUpdateFrequencyparamsVariable,1)
            bookUpdateFrequency2paramsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "bookUpdateFrequency", bookUpdateFrequency)
            bookUpdateFrequency2 = ccxt.GetValue(bookUpdateFrequency2paramsVariable,0)
            params = ccxt.GetValue(bookUpdateFrequency2paramsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(bookUpdateFrequency2, nil)) {
                ccxt.AddElementToObject(ccxt.GetValue(params, "params"), "bookSubscriptionType", bookUpdateFrequency2)
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var currentTopic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("book", "."), ccxt.GetValue(market, "id")), "."), ccxt.ToString(limit))
                var messageHash interface{} = ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol"))
                ccxt.AppendToArray(&subMessageHashes, messageHash)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:", messageHash))
                ccxt.AppendToArray(&topics, currentTopic)
            }
        
                retRes19715 :=  (<-this.UnWatchPublicMultiple("orderbook", symbols, messageHashes, subMessageHashes, topics, params))
                ccxt.PanicOnError(retRes19715)
                ch <- retRes19715
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    var count interface{} = this.SafeInteger(delta, 2)
    bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, amount, count})
}
func  (this *CryptocomCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *CryptocomCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // snapshot
    //    {
    //        "instrument_name":"LTC_USDT",
    //        "subscription":"book.LTC_USDT.150",
    //        "channel":"book",
    //        "depth":150,
    //        "data": [
    //             {
    //                 "bids": [
    //                     [122.21, 0.74041, 4]
    //                 ],
    //                 "asks": [
    //                     [122.29, 0.00002, 1]
    //                 ]
    //                 "t": 1648123943803,
    //                 "s":754560122
    //             }
    //         ]
    //    }
    //  update
    //    {
    //        "instrument_name":"BTC_USDT",
    //        "subscription":"book.BTC_USDT.50",
    //        "channel":"book.update",
    //        "depth":50,
    //        "data":[
    //           {
    //              "update":{
    //                 "asks":[
    //                    [
    //                       "43755.46",
    //                       "0.10000",
    //                       "1"
    //                    ],
    //                    ...
    //                 ],
    //                 "bids":[
    //                    [
    //                       "43737.46",
    //                       "0.14096",
    //                       "1"
    //                    ],
    //                    ...
    //                 ]
    //              },
    //              "t":1704484068898,
    //              "tt":1704484068892,
    //              "u":78795598253024,
    //              "pu":78795598162080,
    //              "cs":-781431132
    //           }
    //        ]
    //    }
    //
    var marketId interface{} = this.SafeString(message, "instrument_name")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var data interface{} = this.SafeValue(message, "data")
    data = this.SafeValue(data, 0)
    var timestamp interface{} = this.SafeInteger(data, "t")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var limit interface{} = this.SafeInteger(message, "depth")
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.CountedOrderBook(map[string]interface{} {}, limit))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var channel interface{} = this.SafeString(message, "channel")
    var nonce interface{} = this.SafeInteger2(data, "u", "s")
    var books interface{} = data
    if ccxt.IsTrue(ccxt.IsEqual(channel, "book")) {
        orderbook.(ccxt.OrderBookInterface).Reset(map[string]interface{} {})
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(orderbook, "nonce", nonce)
    } else {
        books = this.SafeValue(data, "update", map[string]interface{} {})
        var previousNonce interface{} = this.SafeInteger(data, "pu")
        var currentNonce interface{} = ccxt.GetValue(orderbook, "nonce")
        if ccxt.IsTrue(!ccxt.IsEqual(currentNonce, previousNonce)) {
            var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
            if ccxt.IsTrue(checksum) {
                panic(ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol))))
            }
        }
    }
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), this.SafeValue(books, "asks", []interface{}{}))
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), this.SafeValue(books, "bids", []interface{}{}))
    ccxt.AddElementToObject(orderbook, "nonce", nonce)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name cryptocom#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#trade-instrument_name
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CryptocomCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes32015 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes32015)
                ch <- retRes32015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#trade-instrument_name
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CryptocomCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes33315 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes33315)
                ch <- retRes33315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#trade-instrument_name
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CryptocomCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3488)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var currentTopic interface{} = ccxt.Add(ccxt.Add("trade", "."), ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, currentTopic)
            }
        
            trades:= (<-this.WatchPublicMultiple(topics, topics, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#trade-instrument_name
 * @param {string[]} [symbols] list of unified market symbols to unwatch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CryptocomCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3768)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var currentTopic interface{} = ccxt.Add(ccxt.Add("trade", "."), ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trades:", ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&topics, currentTopic)
            }
        
                retRes38715 :=  (<-this.UnWatchPublicMultiple("trades", symbols, messageHashes, topics, topics, params))
                ccxt.PanicOnError(retRes38715)
                ch <- retRes38715
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     "code": 0,
    //     "method": "subscribe",
    //     "result": {
    //       "instrument_name": "BTC_USDT",
    //       "subscription": "trade.BTC_USDT",
    //       "channel": "trade",
    //       "data": [
    //             {
    //                 "dataTime":1648122434405,
    //                 "d":"2358394540212355488",
    //                 "s":"SELL",
    //                 "p":42980.85,
    //                 "q":0.002325,
    //                 "t":1648122434404,
    //                 "i":"BTC_USDT"
    //              }
    //              (...)
    //       ]
    // }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var marketId interface{} = this.SafeString(message, "instrument_name")
    var symbolSpecificMessageHash interface{} = this.SafeString(message, "subscription")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsEqual(dataLength, 0)) {
        return
    }
    var parsedTrades interface{} = this.ParseTrades(data, market)
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(parsedTrades)); j++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsedTrades, j))
    }
    var channelReplaced interface{} = ccxt.Replace(channel, ccxt.Add(".", marketId), "")
    client.(ccxt.ClientInterface).Resolve(stored, symbolSpecificMessageHash)
    client.(ccxt.ClientInterface).Resolve(stored, channelReplaced)
}
/**
 * @method
 * @name cryptocom#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#user-trade-instrument_name
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *CryptocomCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4508)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var messageHash interface{} = "user.trade"
            messageHash = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(market, nil))), (ccxt.Add(ccxt.Add(messageHash, "."), ccxt.GetValue(market, "id"))), messageHash)
        
            trades:= (<-this.WatchPrivateSubscribe(messageHash, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#ticker-instrument_name
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CryptocomCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4758)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", "."), ccxt.GetValue(market, "id"))
        
                retRes47815 :=  (<-this.WatchPublic(messageHash, params))
                ccxt.PanicOnError(retRes47815)
                ch <- retRes47815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#ticker-instrument_name
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CryptocomCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4918 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4918)
            var market interface{} = this.Market(symbol)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add("ticker", "."), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol"))
        
                retRes49515 :=  (<-this.UnWatchPublicMultiple("ticker", []interface{}{ccxt.GetValue(market, "symbol")}, []interface{}{messageHash}, []interface{}{subMessageHash}, []interface{}{subMessageHash}, params))
                ccxt.PanicOnError(retRes49515)
                ch <- retRes49515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#ticker-instrument_name
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CryptocomCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5088)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var marketIds interface{} = this.MarketIds(symbols)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker.", marketId))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": messageHashes,
                },
                "nonce": id,
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchTickers
 * @description unWatches a price ticker
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#ticker-instrument_name
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CryptocomCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5448 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5448)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var marketIds interface{} = this.MarketIds(symbols)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("ticker.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", symbol))
            }
        
                retRes55515 :=  (<-this.UnWatchPublicMultiple("ticker", symbols, messageHashes, subMessageHashes, subMessageHashes, params))
                ccxt.PanicOnError(retRes55515)
                ch <- retRes55515
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //       "instrument_name": "ETHUSD-PERP",
    //       "subscription": "ticker.ETHUSD-PERP",
    //       "channel": "ticker",
    //       "data": [
    //         {
    //           "h": "2400.20",
    //           "l": "2277.10",
    //           "a": "2335.25",
    //           "c": "-0.0022",
    //           "b": "2335.10",
    //           "bs": "5.4000",
    //           "k": "2335.16",
    //           "ks": "1.9970",
    //           "i": "ETHUSD-PERP",
    //           "v": "1305697.6462",
    //           "vv": "3058704939.17",
    //           "oi": "161646.3614",
    //           "t": 1726069647560
    //         }
    //       ]
    //     }
    //
    this.HandleBidAsk(client, message)
    var messageHash interface{} = this.SafeString(message, "subscription")
    var marketId interface{} = this.SafeString(message, "instrument_name")
    var market interface{} = this.SafeMarket(marketId)
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseWsTicker(ticker, market)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, parsed)
        client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
    }
}
func  (this *CryptocomCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //       "h": "2400.20",
    //       "l": "2277.10",
    //       "a": "2335.25",
    //       "c": "-0.0022",
    //       "b": "2335.10",
    //       "bs": "5.4000",
    //       "k": "2335.16",
    //       "ks": "1.9970",
    //       "i": "ETHUSD-PERP",
    //       "v": "1305697.6462",
    //       "vv": "3058704939.17",
    //       "oi": "161646.3614",
    //       "t": 1726069647560
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    var marketId interface{} = this.SafeString(ticker, "i")
    market = this.SafeMarket(marketId, market, "_")
    var quote interface{} = this.SafeString(market, "quote")
    var last interface{} = this.SafeString(ticker, "a")
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "h"),
        "low": this.SafeNumber(ticker, "l"),
        "bid": this.SafeNumber(ticker, "b"),
        "bidVolume": this.SafeNumber(ticker, "bs"),
        "ask": this.SafeNumber(ticker, "k"),
        "askVolume": this.SafeNumber(ticker, "ks"),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "c"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(quote, "USD"))), this.SafeString(ticker, "vv"), nil),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name cryptocom#watchBidsAsks
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#ticker-instrument_name
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CryptocomCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6548)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            var marketIds interface{} = this.MarketIds(symbols)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask.", ccxt.GetValue(symbols, i)))
                ccxt.AppendToArray(&topics, ccxt.Add("ticker.", marketId))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": topics,
                },
                "nonce": id,
            }
        
            newTickers:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleBidAsk(client interface{}, message interface{})  {
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var ticker interface{} = this.SafeDict(data, 0, map[string]interface{} {})
    var parsedTicker interface{} = this.ParseWsBidAsk(ticker)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidask.", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *CryptocomCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "i")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "t")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "k"),
        "askVolume": this.SafeString(ticker, "ks"),
        "bid": this.SafeString(ticker, "b"),
        "bidVolume": this.SafeString(ticker, "bs"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name cryptocom#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#candlestick-time_frame-instrument_name
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *CryptocomCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7228)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("candlestick", "."), interval), "."), ccxt.GetValue(market, "id"))
        
            ohlcv:= (<-this.WatchPublic(messageHash, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#candlestick-time_frame-instrument_name
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *CryptocomCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7458 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7458)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("candlestick", "."), interval), "."), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:ohlcv:", ccxt.GetValue(market, "symbol")), ":"), timeframe)
            var subExtend interface{} = map[string]interface{} {
                "symbolsAndTimeframes": []interface{}{[]interface{}{ccxt.GetValue(market, "symbol"), timeframe}},
            }
        
                retRes75415 :=  (<-this.UnWatchPublicMultiple("ohlcv", []interface{}{ccxt.GetValue(market, "symbol")}, []interface{}{messageHash}, []interface{}{subMessageHash}, []interface{}{subMessageHash}, params, subExtend))
                ccxt.PanicOnError(retRes75415)
                ch <- retRes75415
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //  {
    //       "instrument_name": "BTC_USDT",
    //       "subscription": "candlestick.1m.BTC_USDT",
    //       "channel": "candlestick",
    //       "depth": 300,
    //       "interval": "1m",
    //       "data": [ [Object] ]
    //   }
    //
    var messageHash interface{} = this.SafeString(message, "subscription")
    var marketId interface{} = this.SafeString(message, "instrument_name")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(message, "interval")
    var timeframe interface{} = this.FindTimeframe(interval)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var data interface{} = this.SafeValue(message, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var tick interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseOHLCV(tick, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name cryptocom#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#user-order-instrument_name
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CryptocomCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8028)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var messageHash interface{} = "user.order"
            messageHash = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(market, nil))), (ccxt.Add(ccxt.Add(messageHash, "."), ccxt.GetValue(market, "id"))), messageHash)
        
            orders:= (<-this.WatchPrivateSubscribe(messageHash, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleOrders(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //    {
    //        "method": "subscribe",
    //        "result": {
    //          "instrument_name": "ETH_CRO",
    //          "subscription": "user.order.ETH_CRO",
    //          "channel": "user.order",
    //          "data": [
    //            {
    //              "status": "ACTIVE",
    //              "side": "BUY",
    //              "price": 1,
    //              "quantity": 1,
    //              "order_id": "366455245775097673",
    //              "client_oid": "my_order_0002",
    //              "create_time": 1588758017375,
    //              "update_time": 1588758017411,
    //              "type": "LIMIT",
    //              "instrument_name": "ETH_CRO",
    //              "cumulative_quantity": 0,
    //              "cumulative_value": 0,
    //              "avg_price": 0,
    //              "fee_currency": "CRO",
    //              "time_in_force":"GOOD_TILL_CANCEL"
    //            }
    //          ],
    //          "channel": "user.order.ETH_CRO"
    //        }
    //    }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var channel interface{} = this.SafeString(message, "channel")
    var symbolSpecificMessageHash interface{} = this.SafeString(message, "subscription")
    var orders interface{} = this.SafeValue(message, "data", []interface{}{})
    var ordersLength interface{} =     ccxt.GetArrayLength(orders)
    if ccxt.IsTrue(ccxt.IsGreaterThan(ordersLength, 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        var parsed interface{} = this.ParseOrders(orders)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
            stored.(ccxt.Appender).Append(ccxt.GetValue(parsed, i))
        }
        client.(ccxt.ClientInterface).Resolve(stored, symbolSpecificMessageHash)
        // non-symbol specific
        client.(ccxt.ClientInterface).Resolve(stored, channel) // channel might have a symbol-specific suffix
        client.(ccxt.ClientInterface).Resolve(stored, "user.order")
    }
}
/**
 * @method
 * @name cryptocom#watchPositions
 * @description watch all open positions
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#user-position_balance
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *CryptocomCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8818)
        
            retRes8828 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8828)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{"user.position_balance"},
                },
                "nonce": id,
            }
            var messageHash interface{} = "positions"
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client, symbols)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
        
            newPositions:= (<-this.Watch(url, messageHash, this.Extend(request, params)))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    } else {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
}
func  (this *CryptocomCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions())
            ccxt.PanicOnError(positions)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve(cache)
            client.(ccxt.ClientInterface).Resolve(cache, "positions")
                return nil
            }()
            return ch
        }
func  (this *CryptocomCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        "subscription": "user.position_balance",
    //        "channel": "user.position_balance",
    //        "data": [{
    //            "balances": [{
    //                "instrument_name": "USD",
    //                "quantity": "8.9979961950886",
    //                "update_timestamp_ms": 1695598760597,
    //            }],
    //            "positions": [{
    //                "account_id": "96a0edb1-afb5-4c7c-af89-5cb610319e2c",
    //                "instrument_name": "LTCUSD-PERP",
    //                "type": "PERPETUAL_SWAP",
    //                "quantity": "1.8",
    //                "cost": "114.766",
    //                "open_position_pnl": "-0.0216206",
    //                "session_pnl": "0.00962994",
    //                "update_timestamp_ms": 1695598760597,
    //                "open_pos_cost": "114.766",
    //            }],
    //        }],
    //    }
    //
    // each account is connected to a different endpoint
    // and has exactly one subscriptionhash which is the account type
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var firstData interface{} = this.SafeValue(data, 0, map[string]interface{} {})
    var rawPositions interface{} = this.SafeValue(firstData, "positions", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParsePosition(rawPosition)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
/**
 * @method
 * @name cryptocom#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#user-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *CryptocomCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "user.balance"
        
                retRes100715 :=  (<-this.WatchPrivateSubscribe(messageHash, params))
                ccxt.PanicOnError(retRes100715)
                ch <- retRes100715
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "id": 1,
    //         "method": "subscribe",
    //         "code": 0,
    //         "result": {
    //             "subscription": "user.balance",
    //             "channel": "user.balance",
    //             "data": [
    //                 {
    //                     "total_available_balance": "5.84684368",
    //                     "total_margin_balance": "5.84684368",
    //                     "total_initial_margin": "0",
    //                     "total_maintenance_margin": "0",
    //                     "total_position_cost": "0",
    //                     "total_cash_balance": "6.44412101",
    //                     "total_collateral_value": "5.846843685",
    //                     "total_session_unrealized_pnl": "0",
    //                     "instrument_name": "USD",
    //                     "total_session_realized_pnl": "0",
    //                     "position_balances": [
    //                         {
    //                             "quantity": "0.0002119875",
    //                             "reserved_qty": "0",
    //                             "collateral_weight": "0.9",
    //                             "collateral_amount": "5.37549592",
    //                             "market_value": "5.97277325",
    //                             "max_withdrawal_balance": "0.00021198",
    //                             "instrument_name": "BTC",
    //                             "hourly_interest_rate": "0"
    //                         },
    //                     ],
    //                     "total_effective_leverage": "0",
    //                     "position_limit": "3000000",
    //                     "used_position_limit": "0",
    //                     "total_borrow": "0",
    //                     "margin_score": "0",
    //                     "is_liquidating": false,
    //                     "has_risk": false,
    //                     "terminatable": true
    //                 }
    //             ]
    //         }
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "subscription")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var positionBalances interface{} = this.SafeValue(ccxt.GetValue(data, 0), "position_balances", []interface{}{})
    ccxt.AddElementToObject(this.Balance, "info", data)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positionBalances)); i++ {
        var balance interface{} = ccxt.GetValue(positionBalances, i)
        var currencyId interface{} = this.SafeString(balance, "instrument_name")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "total", this.SafeString(balance, "quantity"))
        ccxt.AddElementToObject(account, "used", this.SafeString(balance, "reserved_qty"))
        ccxt.AddElementToObject(this.Balance, code, account)
        this.Balance = this.SafeBalance(this.Balance)
    }
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
    var messageHashRequest interface{} = this.SafeString(message, "id")
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHashRequest)
}
/**
 * @method
 * @name cryptocom#createOrderWs
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-create-order
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CryptocomCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10898)
            params = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var request interface{} = map[string]interface{} {
                "method": "private/create-order",
                "params": params,
            }
            var messageHash interface{} = this.Nonce()
        
                retRes109615 :=  (<-this.WatchPrivateRequest(messageHash, request))
                ccxt.PanicOnError(retRes109615)
                ch <- retRes109615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#editOrderWs
 * @description edit a trade order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-amend-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol of the order to edit
 * @param {string} [type] not used by cryptocom editOrder
 * @param {string} [side] not used by cryptocom editOrder
 * @param {float} amount (mandatory) how much of the currency you want to trade in units of the base currency
 * @param {float} price (mandatory) the price for the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] the original client order id of the order to edit, required if id is not provided
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CryptocomCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes11158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11158)
            params = this.EditOrderRequest(id, symbol, amount, price, params)
            var request interface{} = map[string]interface{} {
                "method": "private/amend-order",
                "params": params,
            }
            var messageHash interface{} = this.Nonce()
        
                retRes112215 :=  (<-this.WatchPrivateRequest(messageHash, request))
                ccxt.PanicOnError(retRes112215)
                ch <- retRes112215
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "id": 1,
    //        "method": "private/create-order",
    //        "code": 0,
    //        "result": {
    //            "client_oid": "c5f682ed-7108-4f1c-b755-972fcdca0f02",
    //            "order_id": "18342311"
    //        }
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var rawOrder interface{} = this.SafeValue(message, "result", map[string]interface{} {})
    var order interface{} = this.ParseOrder(rawOrder)
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name cryptocom#cancelOrderWs
 * @description cancels an open order
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-order
 * @param {string} id the order id of the order to cancel
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CryptocomCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11548)
            params = this.Extend(map[string]interface{} {
                "order_id": id,
            }, params)
            var request interface{} = map[string]interface{} {
                "method": "private/cancel-order",
                "params": params,
            }
            var messageHash interface{} = this.Nonce()
        
                retRes116315 :=  (<-this.WatchPrivateRequest(messageHash, request))
                ccxt.PanicOnError(retRes116315)
                ch <- retRes116315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name cryptocom#cancelAllOrdersWs
 * @description cancel all open orders
 * @see https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html#private-cancel-all-orders
 * @param {string} symbol unified market symbol of the orders to cancel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} Returns exchange raw message {@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CryptocomCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11768)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "method": "private/cancel-all-orders",
                "params": this.Extend(map[string]interface{} {}, params),
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                ccxt.AddElementToObject(ccxt.GetValue(request, "params"), "instrument_name", ccxt.GetValue(market, "id"))
            }
            var messageHash interface{} = this.Nonce()
        
                retRes118715 :=  (<-this.WatchPrivateRequest(messageHash, request))
                ccxt.PanicOnError(retRes118715)
                ch <- retRes118715
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleCancelAllOrders(client interface{}, message interface{})  {
    //
    //    {
    //        "id": 1688914586647,
    //        "method": "private/cancel-all-orders",
    //        "code": 0
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
}
func  (this *CryptocomCore) WatchPublic(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{messageHash},
                },
                "nonce": id,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes121315 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes121315)
                ch <- retRes121315
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) WatchPublicMultiple(messageHashes interface{}, topics interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": topics,
                },
                "nonce": id,
            }
            var message interface{} = this.DeepExtend(request, params)
        
                retRes122715 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes122715)
                ch <- retRes122715
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) UnWatchPublicMultiple(topic interface{}, symbols interface{}, messageHashes interface{}, subMessageHashes interface{}, topics interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            subExtend := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = subExtend
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "unsubscribe",
                "params": map[string]interface{} {
                    "channels": topics,
                },
                "nonce": id,
                "id": ccxt.ToString(id),
            }
            var subscription interface{} = map[string]interface{} {
                "id": ccxt.ToString(id),
                "topic": topic,
                "symbols": symbols,
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
            }
            var message interface{} = this.DeepExtend(request, params)
        
                retRes124915 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes, this.Extend(subscription, subExtend)))
                ccxt.PanicOnError(retRes124915)
                ch <- retRes124915
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) WatchPrivateRequest(nonce interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12538 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes12538)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var request interface{} = map[string]interface{} {
                "id": nonce,
                "nonce": nonce,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes126015 :=  (<-this.Watch(url, ccxt.ToString(nonce), message, true))
                ccxt.PanicOnError(retRes126015)
                ch <- retRes126015
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) WatchPrivateSubscribe(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12648 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes12648)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "method": "subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{messageHash},
                },
                "nonce": id,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes127515 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes127515)
                ch <- retRes127515
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "id": 0,
    //        "code": 10004,
    //        "method": "subscribe",
    //        "message": "invalid channel {"channels":["trade.BTCUSD-PERP"]}"
    //    }
    //
    var id interface{} = this.SafeString(message, "id")
    var errorCode interface{} = this.SafeString(message, "code")
    
        {
            ret__ := func(this *CryptocomCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *CryptocomCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(e, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(e, id)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsTrue(errorCode) && ccxt.IsTrue(!ccxt.IsEqual(errorCode, "0"))) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                var messageString interface{} = this.SafeValue(message, "message")
                if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                }
                panic(ccxt.ExchangeError(feedback))
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *CryptocomCore) HandleSubscribe(client interface{}, message interface{})  {
    var methods interface{} = map[string]interface{} {
        "candlestick": this.HandleOHLCV,
        "ticker": this.HandleTicker,
        "trade": this.HandleTrades,
        "book": this.HandleOrderBook,
        "book.update": this.HandleOrderBook,
        "user.order": this.HandleOrders,
        "user.trade": this.HandleTrades,
        "user.balance": this.HandleBalance,
        "user.position_balance": this.HandlePositions,
    }
    var result interface{} = this.SafeValue2(message, "result", "info")
    var channel interface{} = this.SafeString(result, "channel")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(channel, nil))) && ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "user.trade"), ccxt.OpNeg(1)))) {
        // channel might be user.trade.BTC_USDT
        this.HandleTrades(client, result)
    }
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(channel, nil))) && ccxt.IsTrue(ccxt.StartsWith(channel, "user.order"))) {
        // channel might be user.order.BTC_USDT
        this.HandleOrders(client, result)
    }
    var method interface{} = this.SafeValue(methods, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, result)
    }
}
func  (this *CryptocomCore) HandleMessage(client interface{}, message interface{})  {
    //
    // ping
    //    {
    //        "id": 1587523073344,
    //        "method": "public/heartbeat",
    //        "code": 0
    //    }
    // auth
    //     { id: 1648132625434, method: "public/auth", code: 0 }
    // ohlcv
    //    {
    //        "code": 0,
    //        "method": "subscribe",
    //        "result": {
    //          "instrument_name": "BTC_USDT",
    //          "subscription": "candlestick.1m.BTC_USDT",
    //          "channel": "candlestick",
    //          "depth": 300,
    //          "interval": "1m",
    //          "data": [ [Object] ]
    //        }
    //      }
    // ticker
    //    {
    //        "info":{
    //           "instrument_name":"BTC_USDT",
    //           "subscription":"ticker.BTC_USDT",
    //           "channel":"ticker",
    //           "data":[ { } ]
    //
    // handle unsubscribe
    // {"id":1725448572836,"method":"unsubscribe","code":0}
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var method interface{} = this.SafeString(message, "method")
    var methods interface{} = map[string]interface{} {
        "": this.HandlePing,
        "public/heartbeat": this.HandlePing,
        "public/auth": this.HandleAuthenticate,
        "private/create-order": this.HandleOrder,
        "private/amend-order": this.HandleOrder,
        "private/cancel-order": this.HandleOrder,
        "private/cancel-all-orders": this.HandleCancelAllOrders,
        "private/close-position": this.HandleOrder,
        "subscribe": this.HandleSubscribe,
        "unsubscribe": this.HandleUnsubscribe,
    }
    var callMethod interface{} = this.SafeValue(methods, method)
    if ccxt.IsTrue(!ccxt.IsEqual(callMethod, nil)) {
        ccxt.CallDynamically(callMethod, client, message)
    }
}
func  (this *CryptocomCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var method interface{} = "public/auth"
                var nonce interface{} = ccxt.ToString(this.Nonce())
                var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(method, nonce), this.ApiKey), nonce)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = map[string]interface{} {
                    "id": nonce,
                    "nonce": nonce,
                    "method": method,
                    "api_key": this.ApiKey,
                    "sig": signature,
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes142015 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes142015)
                ch <- retRes142015
                return nil
        
            }()
            return ch
        }
func  (this *CryptocomCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *CryptocomCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //  { id: 1648132625434, method: "public/auth", code: 0 }
    //
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    future.(*ccxt.Future).Resolve(true)
}
func  (this *CryptocomCore) HandleUnsubscribe(client interface{}, message interface{})  {
    var id interface{} = this.SafeString(message, "id")
    var keys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var messageHash interface{} = ccxt.GetValue(keys, i)
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash))) {
            continue
        }
        if ccxt.IsTrue(ccxt.StartsWith(messageHash, "unsubscribe")) {
            var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            var subId interface{} = this.SafeString(subscription, "id")
            if ccxt.IsTrue(!ccxt.IsEqual(id, subId)) {
                continue
            }
            var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
            var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
                var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
                var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
                this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
            }
            this.CleanCache(subscription)
        }
    }
}


func (this *CryptocomCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
