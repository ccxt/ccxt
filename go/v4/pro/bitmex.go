package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitmexCore struct {
	*ccxt.BitmexCore
	base *ccxt.BitmexCore
}

func NewBitmexCore() *BitmexCore {
    p := &BitmexCore{}
	base := &ccxt.BitmexCore{}
	p.base = base
	p.BitmexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitmexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchLiquidations": true,
            "watchLiquidationsForSymbols": true,
            "watchMyLiquidations": nil,
            "watchMyLiquidationsForSymbols": nil,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchPostions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": "wss://ws.testnet.bitmex.com/realtime",
            },
            "api": map[string]interface{} {
                "ws": "wss://ws.bitmex.com/realtime",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBookLevel": "orderBookL2",
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {},
                "broad": map[string]interface{} {
                    "Rate limit exceeded": ccxt.RateLimitExceeded,
                },
            },
        },
    })
}
/**
 * @method
 * @name bitmex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitmexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes718 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes718)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmex#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitmexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes878)
            symbols = this.MarketSymbols(symbols, nil, true)
            var name interface{} = "instrument"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHashes interface{} = []interface{}{}
            var rawSubscriptions interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    var subscription interface{} = ccxt.Add(ccxt.Add(name, ":"), ccxt.GetValue(market, "id"))
                    ccxt.AppendToArray(&rawSubscriptions, subscription)
                    var messageHash interface{} = ccxt.Add("ticker:", symbol)
                    ccxt.AppendToArray(&messageHashes, messageHash)
                }
            } else {
                ccxt.AppendToArray(&rawSubscriptions, name)
                ccxt.AppendToArray(&messageHashes, "alltickers")
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": rawSubscriptions,
            }
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), rawSubscriptions))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "table": "instrument",
    //         "action": "partial",
    //         "keys": [ "symbol" ],
    //         "types": {
    //             "symbol": "symbol",
    //             "rootSymbol": "symbol",
    //             "state": "symbol",
    //             "typ": "symbol",
    //             "listing": "timestamp",
    //             "front": "timestamp",
    //             "expiry": "timestamp",
    //             "settle": "timestamp",
    //             "relistInterval": "timespan",
    //             "inverseLeg": "symbol",
    //             "sellLeg": "symbol",
    //             "buyLeg": "symbol",
    //             "optionStrikePcnt": "float",
    //             "optionStrikeRound": "float",
    //             "optionStrikePrice": "float",
    //             "optionMultiplier": "float",
    //             "positionCurrency": "symbol",
    //             "underlying": "symbol",
    //             "quoteCurrency": "symbol",
    //             "underlyingSymbol": "symbol",
    //             "reference": "symbol",
    //             "referenceSymbol": "symbol",
    //             "calcInterval": "timespan",
    //             "publishInterval": "timespan",
    //             "publishTime": "timespan",
    //             "maxOrderQty": "long",
    //             "maxPrice": "float",
    //             "lotSize": "long",
    //             "tickSize": "float",
    //             "multiplier": "long",
    //             "settlCurrency": "symbol",
    //             "underlyingToPositionMultiplier": "long",
    //             "underlyingToSettleMultiplier": "long",
    //             "quoteToSettleMultiplier": "long",
    //             "isQuanto": "boolean",
    //             "isInverse": "boolean",
    //             "initMargin": "float",
    //             "maintMargin": "float",
    //             "riskLimit": "long",
    //             "riskStep": "long",
    //             "limit": "float",
    //             "capped": "boolean",
    //             "taxed": "boolean",
    //             "deleverage": "boolean",
    //             "makerFee": "float",
    //             "takerFee": "float",
    //             "settlementFee": "float",
    //             "insuranceFee": "float",
    //             "fundingBaseSymbol": "symbol",
    //             "fundingQuoteSymbol": "symbol",
    //             "fundingPremiumSymbol": "symbol",
    //             "fundingTimestamp": "timestamp",
    //             "fundingInterval": "timespan",
    //             "fundingRate": "float",
    //             "indicativeFundingRate": "float",
    //             "rebalanceTimestamp": "timestamp",
    //             "rebalanceInterval": "timespan",
    //             "openingTimestamp": "timestamp",
    //             "closingTimestamp": "timestamp",
    //             "sessionInterval": "timespan",
    //             "prevClosePrice": "float",
    //             "limitDownPrice": "float",
    //             "limitUpPrice": "float",
    //             "bankruptLimitDownPrice": "float",
    //             "bankruptLimitUpPrice": "float",
    //             "prevTotalVolume": "long",
    //             "totalVolume": "long",
    //             "volume": "long",
    //             "volume24h": "long",
    //             "prevTotalTurnover": "long",
    //             "totalTurnover": "long",
    //             "turnover": "long",
    //             "turnover24h": "long",
    //             "homeNotional24h": "float",
    //             "foreignNotional24h": "float",
    //             "prevPrice24h": "float",
    //             "vwap": "float",
    //             "highPrice": "float",
    //             "lowPrice": "float",
    //             "lastPrice": "float",
    //             "lastPriceProtected": "float",
    //             "lastTickDirection": "symbol",
    //             "lastChangePcnt": "float",
    //             "bidPrice": "float",
    //             "midPrice": "float",
    //             "askPrice": "float",
    //             "impactBidPrice": "float",
    //             "impactMidPrice": "float",
    //             "impactAskPrice": "float",
    //             "hasLiquidity": "boolean",
    //             "openInterest": "long",
    //             "openValue": "long",
    //             "fairMethod": "symbol",
    //             "fairBasisRate": "float",
    //             "fairBasis": "float",
    //             "fairPrice": "float",
    //             "markMethod": "symbol",
    //             "markPrice": "float",
    //             "indicativeTaxRate": "float",
    //             "indicativeSettlePrice": "float",
    //             "optionUnderlyingPrice": "float",
    //             "settledPrice": "float",
    //             "timestamp": "timestamp"
    //         },
    //         "foreignKeys": {
    //             "inverseLeg": "instrument",
    //             "sellLeg": "instrument",
    //             "buyLeg": "instrument"
    //         },
    //         "attributes": { symbol: "unique" },
    //         "filter": { symbol: "XBTUSD" },
    //         "data": [
    //             {
    //                 "symbol": "XBTUSD",
    //                 "rootSymbol": "XBT",
    //                 "state": "Open",
    //                 "typ": "FFWCSX",
    //                 "listing": "2016-05-13T12:00:00.000Z",
    //                 "front": "2016-05-13T12:00:00.000Z",
    //                 "expiry": null,
    //                 "settle": null,
    //                 "relistInterval": null,
    //                 "inverseLeg": '',
    //                 "sellLeg": '',
    //                 "buyLeg": '',
    //                 "optionStrikePcnt": null,
    //                 "optionStrikeRound": null,
    //                 "optionStrikePrice": null,
    //                 "optionMultiplier": null,
    //                 "positionCurrency": "USD",
    //                 "underlying": "XBT",
    //                 "quoteCurrency": "USD",
    //                 "underlyingSymbol": "XBT=",
    //                 "reference": "BMEX",
    //                 "referenceSymbol": ".BXBT",
    //                 "calcInterval": null,
    //                 "publishInterval": null,
    //                 "publishTime": null,
    //                 "maxOrderQty": 10000000,
    //                 "maxPrice": 1000000,
    //                 "lotSize": 1,
    //                 "tickSize": 0.5,
    //                 "multiplier": -100000000,
    //                 "settlCurrency": "XBt",
    //                 "underlyingToPositionMultiplier": null,
    //                 "underlyingToSettleMultiplier": -100000000,
    //                 "quoteToSettleMultiplier": null,
    //                 "isQuanto": false,
    //                 "isInverse": true,
    //                 "initMargin": 0.01,
    //                 "maintMargin": 0.005,
    //                 "riskLimit": 20000000000,
    //                 "riskStep": 10000000000,
    //                 "limit": null,
    //                 "capped": false,
    //                 "taxed": true,
    //                 "deleverage": true,
    //                 "makerFee": -0.00025,
    //                 "takerFee": 0.00075,
    //                 "settlementFee": 0,
    //                 "insuranceFee": 0,
    //                 "fundingBaseSymbol": ".XBTBON8H",
    //                 "fundingQuoteSymbol": ".USDBON8H",
    //                 "fundingPremiumSymbol": ".XBTUSDPI8H",
    //                 "fundingTimestamp": "2020-01-29T12:00:00.000Z",
    //                 "fundingInterval": "2000-01-01T08:00:00.000Z",
    //                 "fundingRate": 0.000597,
    //                 "indicativeFundingRate": 0.000652,
    //                 "rebalanceTimestamp": null,
    //                 "rebalanceInterval": null,
    //                 "openingTimestamp": "2020-01-29T11:00:00.000Z",
    //                 "closingTimestamp": "2020-01-29T12:00:00.000Z",
    //                 "sessionInterval": "2000-01-01T01:00:00.000Z",
    //                 "prevClosePrice": 9063.96,
    //                 "limitDownPrice": null,
    //                 "limitUpPrice": null,
    //                 "bankruptLimitDownPrice": null,
    //                 "bankruptLimitUpPrice": null,
    //                 "prevTotalVolume": 1989881049026,
    //                 "totalVolume": 1990196740950,
    //                 "volume": 315691924,
    //                 "volume24h": 4491824765,
    //                 "prevTotalTurnover": 27865497128425564,
    //                 "totalTurnover": 27868891594857150,
    //                 "turnover": 3394466431587,
    //                 "turnover24h": 48863390064843,
    //                 "homeNotional24h": 488633.9006484273,
    //                 "foreignNotional24h": 4491824765,
    //                 "prevPrice24h": 9091,
    //                 "vwap": 9192.8663,
    //                 "highPrice": 9440,
    //                 "lowPrice": 8886,
    //                 "lastPrice": 9287,
    //                 "lastPriceProtected": 9287,
    //                 "lastTickDirection": "PlusTick",
    //                 "lastChangePcnt": 0.0216,
    //                 "bidPrice": 9286,
    //                 "midPrice": 9286.25,
    //                 "askPrice": 9286.5,
    //                 "impactBidPrice": 9285.9133,
    //                 "impactMidPrice": 9286.75,
    //                 "impactAskPrice": 9287.6382,
    //                 "hasLiquidity": true,
    //                 "openInterest": 967826984,
    //                 "openValue": 10432207060536,
    //                 "fairMethod": "ccxt.FundingRate",
    //                 "fairBasisRate": 0.6537149999999999,
    //                 "fairBasis": 0.33,
    //                 "fairPrice": 9277.2,
    //                 "markMethod": "FairPrice",
    //                 "markPrice": 9277.2,
    //                 "indicativeTaxRate": 0,
    //                 "indicativeSettlePrice": 9276.87,
    //                 "optionUnderlyingPrice": null,
    //                 "settledPrice": null,
    //                 "timestamp": "2020-01-29T11:31:37.114Z"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var tickers interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var update interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(update, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId)
        if !ccxt.IsTrue((ccxt.InOp(this.Tickers, symbol))) {
            ccxt.AddElementToObject(this.Tickers, symbol, this.ParseTicker(map[string]interface{} {}))
        }
        var updatedTicker interface{} = this.ParseTicker(update)
        var fullParsedTicker interface{} = this.DeepExtend(ccxt.GetValue(this.Tickers, symbol), updatedTicker)
        ccxt.AddElementToObject(tickers, symbol, fullParsedTicker)
        ccxt.AddElementToObject(this.Tickers, symbol, fullParsedTicker)
        var messageHash interface{} = ccxt.Add("ticker:", symbol)
        client.(ccxt.ClientInterface).Resolve(fullParsedTicker, messageHash)
        client.(ccxt.ClientInterface).Resolve(fullParsedTicker, "alltickers")
    }
    return message
}
/**
 * @method
 * @name bitmex#watchLiquidations
 * @description watch the public liquidations of a trading pair
 * @see https://www.bitmex.com/app/wsAPI#ccxt.Liquidation
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BitmexCore) WatchLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            ch <- this.WatchLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmex#watchLiquidationsForSymbols
 * @description watch the public liquidations of a trading pair
 * @see https://www.bitmex.com/app/wsAPI#ccxt.Liquidation
 * @param {string[]} symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BitmexCore) WatchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3938)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var messageHashes interface{} = []interface{}{}
            var subscriptionHashes interface{} = []interface{}{}
            if ccxt.IsTrue(this.IsEmpty(symbols)) {
                ccxt.AppendToArray(&subscriptionHashes, "liquidation")
                ccxt.AppendToArray(&messageHashes, "liquidations")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("liquidation:", ccxt.GetValue(market, "id")))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("liquidations::", symbol))
                }
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": subscriptionHashes,
            }
        
            newLiquidations:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), subscriptionHashes))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    //    {
    //        "table":"liquidation",
    //        "action":"partial",
    //        "keys":[
    //           "orderID"
    //        ],
    //        "types":{
    //           "orderID":"guid",
    //           "symbol":"symbol",
    //           "side":"symbol",
    //           "price":"float",
    //           "leavesQty":"long"
    //        },
    //        "filter":{},
    //        "data":[
    //           {
    //              "orderID":"e0a568ee-7830-4428-92c3-73e82b9576ce",
    //              "symbol":"XPLAUSDT",
    //              "side":"Sell",
    //              "price":0.206,
    //              "leavesQty":340
    //           }
    //        ]
    //    }
    //
    var rawLiquidations interface{} = this.SafeValue(message, "data", []interface{}{})
    var newLiquidations interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawLiquidations)); i++ {
        var rawLiquidation interface{} = ccxt.GetValue(rawLiquidations, i)
        var liquidation interface{} = this.ParseLiquidation(rawLiquidation)
        var symbol interface{} = ccxt.GetValue(liquidation, "symbol")
        var liquidations interface{} = this.SafeValue(this.Liquidations, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "liquidationsLimit", 1000)
            liquidations = ccxt.NewArrayCache(limit)
        }
        liquidations.(ccxt.Appender).Append(liquidation)
        ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
        ccxt.AppendToArray(&newLiquidations, liquidation)
    }
    client.(ccxt.ClientInterface).Resolve(newLiquidations, "liquidations")
    var liquidationsBySymbol interface{} = this.IndexBy(newLiquidations, "symbol")
    var symbols interface{} = ccxt.ObjectKeys(liquidationsBySymbol)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        var symbol interface{} = ccxt.GetValue(symbols, i)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(liquidationsBySymbol, symbol), ccxt.Add("liquidations::", symbol))
    }
}
/**
 * @method
 * @name bitmex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BitmexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4808)
        
            retRes4818 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4818)
            var messageHash interface{} = "margin"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{messageHash},
            }
        
                retRes49015 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes49015)
                ch <- retRes49015
                return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "margin",
    //         "action": "partial",
    //         "keys": [ "account" ],
    //         "types": {
    //             "account": "long",
    //             "currency": "symbol",
    //             "riskLimit": "long",
    //             "prevState": "symbol",
    //             "state": "symbol",
    //             "action": "symbol",
    //             "amount": "long",
    //             "pendingCredit": "long",
    //             "pendingDebit": "long",
    //             "confirmedDebit": "long",
    //             "prevRealisedPnl": "long",
    //             "prevUnrealisedPnl": "long",
    //             "grossComm": "long",
    //             "grossOpenCost": "long",
    //             "grossOpenPremium": "long",
    //             "grossExecCost": "long",
    //             "grossMarkValue": "long",
    //             "riskValue": "long",
    //             "taxableMargin": "long",
    //             "initMargin": "long",
    //             "maintMargin": "long",
    //             "sessionMargin": "long",
    //             "targetExcessMargin": "long",
    //             "varMargin": "long",
    //             "realisedPnl": "long",
    //             "unrealisedPnl": "long",
    //             "indicativeTax": "long",
    //             "unrealisedProfit": "long",
    //             "syntheticMargin": "long",
    //             "walletBalance": "long",
    //             "marginBalance": "long",
    //             "marginBalancePcnt": "float",
    //             "marginLeverage": "float",
    //             "marginUsedPcnt": "float",
    //             "excessMargin": "long",
    //             "excessMarginPcnt": "float",
    //             "availableMargin": "long",
    //             "withdrawableMargin": "long",
    //             "timestamp": "timestamp",
    //             "grossLastValue": "long",
    //             "commission": "float"
    //         },
    //         "foreignKeys": {},
    //         "attributes": { account: "sorted" },
    //         "filter": { account: 1455728 },
    //         "data": [
    //             {
    //                 "account": 1455728,
    //                 "currency": "XBt",
    //                 "riskLimit": 1000000000000,
    //                 "prevState": '',
    //                 "state": '',
    //                 "action": '',
    //                 "amount": 263542,
    //                 "pendingCredit": 0,
    //                 "pendingDebit": 0,
    //                 "confirmedDebit": 0,
    //                 "prevRealisedPnl": 0,
    //                 "prevUnrealisedPnl": 0,
    //                 "grossComm": 0,
    //                 "grossOpenCost": 0,
    //                 "grossOpenPremium": 0,
    //                 "grossExecCost": 0,
    //                 "grossMarkValue": 0,
    //                 "riskValue": 0,
    //                 "taxableMargin": 0,
    //                 "initMargin": 0,
    //                 "maintMargin": 0,
    //                 "sessionMargin": 0,
    //                 "targetExcessMargin": 0,
    //                 "varMargin": 0,
    //                 "realisedPnl": 0,
    //                 "unrealisedPnl": 0,
    //                 "indicativeTax": 0,
    //                 "unrealisedProfit": 0,
    //                 "syntheticMargin": null,
    //                 "walletBalance": 263542,
    //                 "marginBalance": 263542,
    //                 "marginBalancePcnt": 1,
    //                 "marginLeverage": 0,
    //                 "marginUsedPcnt": 0,
    //                 "excessMargin": 263542,
    //                 "excessMarginPcnt": 1,
    //                 "availableMargin": 263542,
    //                 "withdrawableMargin": 263542,
    //                 "timestamp": "2020-08-03T12:01:01.246Z",
    //                 "grossLastValue": 0,
    //                 "commission": null
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeValue(message, "data")
    var balance interface{} = this.ParseBalance(data)
    this.Balance = this.Extend(this.Balance, balance)
    var messageHash interface{} = this.SafeString(message, "table")
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *BitmexCore) HandleTrades(client interface{}, message interface{})  {
    //
    // initial snapshot
    //
    //     {
    //         "table": "trade",
    //         "action": "partial",
    //         "keys": [],
    //         "types": {
    //             "timestamp": "timestamp",
    //             "symbol": "symbol",
    //             "side": "symbol",
    //             "size": "long",
    //             "price": "float",
    //             "tickDirection": "symbol",
    //             "trdMatchID": "guid",
    //             "grossValue": "long",
    //             "homeNotional": "float",
    //             "foreignNotional": "float"
    //         },
    //         "foreignKeys": { symbol: "instrument", side: "side" },
    //         "attributes": { timestamp: "sorted", symbol: "grouped" },
    //         "filter": { symbol: "XBTUSD" },
    //         "data": [
    //             {
    //                 "timestamp": "2020-01-30T17:03:07.854Z",
    //                 "symbol": "XBTUSD",
    //                 "side": "Buy",
    //                 "size": 15000,
    //                 "price": 9378,
    //                 "tickDirection": "ZeroPlusTick",
    //                 "trdMatchID": "5b426e7f-83d1-2c80-295d-ee995b8ceb4a",
    //                 "grossValue": 159945000,
    //                 "homeNotional": 1.59945,
    //                 "foreignNotional": 15000
    //             }
    //         ]
    //     }
    //
    // updates
    //
    //     {
    //         "table": "trade",
    //         "action": "insert",
    //         "data": [
    //             {
    //                 "timestamp": "2020-01-30T17:31:40.160Z",
    //                 "symbol": "XBTUSD",
    //                 "side": "Sell",
    //                 "size": 37412,
    //                 "price": 9521.5,
    //                 "tickDirection": "ZeroMinusTick",
    //                 "trdMatchID": "a4bfc6bc-6cf1-1a11-622e-270eef8ca5c7",
    //                 "grossValue": 392938236,
    //                 "homeNotional": 3.92938236,
    //                 "foreignNotional": 37412
    //             }
    //         ]
    //     }
    //
    var table interface{} = "trade"
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var dataByMarketIds interface{} = this.GroupBy(data, "symbol")
    var marketIds interface{} = ccxt.ObjectKeys(dataByMarketIds)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), symbol)
        var trades interface{} = this.ParseTrades(ccxt.GetValue(dataByMarketIds, marketId), market)
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            stored = ccxt.NewArrayCache(limit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
            stored.(ccxt.Appender).Append(ccxt.GetValue(trades, j))
        }
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
/**
 * @method
 * @name bitmex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitmexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes69415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes69415)
                ch <- retRes69415
                return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
                var timestamp interface{} = this.Milliseconds()
                var payload interface{} = ccxt.Add(ccxt.Add("GET", "/realtime"), ccxt.ToString(timestamp))
                var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = map[string]interface{} {
                    "op": "authKeyExpires",
                    "args": []interface{}{this.ApiKey, timestamp, signature},
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes71915 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes71915)
                ch <- retRes71915
                return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    var authenticated interface{} = this.SafeBool(message, "success", false)
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(authenticated) {
        // we resolve the future here permanently so authentication only happens once
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
/**
 * @method
 * @name bitmex#watchPositions
 * @description watch all open positions
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to watch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BitmexCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7508)
        
            retRes7518 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7518)
            var subscriptionHash interface{} = "position"
            var messageHash interface{} = "positions"
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{subscriptionHash},
            }
        
            newPositions:= (<-this.Watch(url, messageHash, request, subscriptionHash))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandlePositions(client interface{}, message interface{})  {
    //
    // partial
    //    {
    //        table: 'position',
    //        action: 'partial',
    //        keys: [ 'account', 'symbol' ],
    //        types: {
    //            account: 'long',
    //            symbol: 'symbol',
    //            currency: 'symbol',
    //            underlying: 'symbol',
    //            quoteCurrency: 'symbol',
    //            commission: 'float',
    //            initMarginReq: 'float',
    //            maintMarginReq: 'float',
    //            riskLimit: 'long',
    //            leverage: 'float',
    //            crossMargin: 'boolean',
    //            deleveragePercentile: 'float',
    //            rebalancedPnl: 'long',
    //            prevRealisedPnl: 'long',
    //            prevUnrealisedPnl: 'long',
    //            openingQty: 'long',
    //            openOrderBuyQty: 'long',
    //            openOrderBuyCost: 'long',
    //            openOrderBuyPremium: 'long',
    //            openOrderSellQty: 'long',
    //            openOrderSellCost: 'long',
    //            openOrderSellPremium: 'long',
    //            currentQty: 'long',
    //            currentCost: 'long',
    //            currentComm: 'long',
    //            realisedCost: 'long',
    //            unrealisedCost: 'long',
    //            grossOpenPremium: 'long',
    //            isOpen: 'boolean',
    //            markPrice: 'float',
    //            markValue: 'long',
    //            riskValue: 'long',
    //            homeNotional: 'float',
    //            foreignNotional: 'float',
    //            posState: 'symbol',
    //            posCost: 'long',
    //            posCross: 'long',
    //            posComm: 'long',
    //            posLoss: 'long',
    //            posMargin: 'long',
    //            posMaint: 'long',
    //            initMargin: 'long',
    //            maintMargin: 'long',
    //            realisedPnl: 'long',
    //            unrealisedPnl: 'long',
    //            unrealisedPnlPcnt: 'float',
    //            unrealisedRoePcnt: 'float',
    //            avgCostPrice: 'float',
    //            avgEntryPrice: 'float',
    //            breakEvenPrice: 'float',
    //            marginCallPrice: 'float',
    //            liquidationPrice: 'float',
    //            bankruptPrice: 'float',
    //            timestamp: 'timestamp'
    //        },
    //        filter: { account: 412475 },
    //        data: [
    //            {
    //                account: 412475,
    //                symbol: 'XBTUSD',
    //                currency: 'XBt',
    //                underlying: 'XBT',
    //                quoteCurrency: 'USD',
    //                commission: 0.00075,
    //                initMarginReq: 0.01,
    //                maintMarginReq: 0.0035,
    //                riskLimit: 20000000000,
    //                leverage: 100,
    //                crossMargin: true,
    //                deleveragePercentile: 1,
    //                rebalancedPnl: 0,
    //                prevRealisedPnl: 0,
    //                prevUnrealisedPnl: 0,
    //                openingQty: 400,
    //                openOrderBuyQty: 0,
    //                openOrderBuyCost: 0,
    //                openOrderBuyPremium: 0,
    //                openOrderSellQty: 0,
    //                openOrderSellCost: 0,
    //                openOrderSellPremium: 0,
    //                currentQty: 400,
    //                currentCost: -912269,
    //                currentComm: 684,
    //                realisedCost: 0,
    //                unrealisedCost: -912269,
    //                grossOpenPremium: 0,
    //                isOpen: true,
    //                markPrice: 43772,
    //                markValue: -913828,
    //                riskValue: 913828,
    //                homeNotional: 0.00913828,
    //                foreignNotional: -400,
    //                posCost: -912269,
    //                posCross: 1559,
    //                posComm: 694,
    //                posLoss: 0,
    //                posMargin: 11376,
    //                posMaint: 3887,
    //                initMargin: 0,
    //                maintMargin: 9817,
    //                realisedPnl: -684,
    //                unrealisedPnl: -1559,
    //                unrealisedPnlPcnt: -0.0017,
    //                unrealisedRoePcnt: -0.1709,
    //                avgCostPrice: 43846.7643,
    //                avgEntryPrice: 43846.7643,
    //                breakEvenPrice: 43880,
    //                marginCallPrice: 20976,
    //                liquidationPrice: 20976,
    //                bankruptPrice: 20941,
    //                timestamp: '2023-12-07T00:09:00.709Z'
    //            }
    //        ]
    //    }
    // update
    //    {
    //        table: 'position',
    //        action: 'update',
    //        data: [
    //            {
    //                account: 412475,
    //                symbol: 'XBTUSD',
    //                currency: 'XBt',
    //                currentQty: 400,
    //                markPrice: 43772.75,
    //                markValue: -913812,
    //                riskValue: 913812,
    //                homeNotional: 0.00913812,
    //                posCross: 1543,
    //                posComm: 693,
    //                posMargin: 11359,
    //                posMaint: 3886,
    //                maintMargin: 9816,
    //                unrealisedPnl: -1543,
    //                unrealisedRoePcnt: -0.1691,
    //                liquidationPrice: 20976,
    //                timestamp: '2023-12-07T00:09:10.760Z'
    //            }
    //        ]
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var rawPositions interface{} = this.SafeValue(message, "data", []interface{}{})
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParsePosition(rawPosition)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
/**
 * @method
 * @name bitmex#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitmexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9588)
        
            retRes9598 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes9598)
            var name interface{} = "order"
            var subscriptionHash interface{} = name
            var messageHash interface{} = name
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{subscriptionHash},
            }
        
            orders:= (<-this.Watch(url, messageHash, request, subscriptionHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "order",
    //         "action": "partial",
    //         "keys": [ "orderID" ],
    //         "types": {
    //             "orderID": "guid",
    //             "clOrdID": "string",
    //             "clOrdLinkID": "symbol",
    //             "account": "long",
    //             "symbol": "symbol",
    //             "side": "symbol",
    //             "simpleOrderQty": "float",
    //             "orderQty": "long",
    //             "price": "float",
    //             "displayQty": "long",
    //             "stopPx": "float",
    //             "pegOffsetValue": "float",
    //             "pegPriceType": "symbol",
    //             "currency": "symbol",
    //             "settlCurrency": "symbol",
    //             "ordType": "symbol",
    //             "timeInForce": "symbol",
    //             "execInst": "symbol",
    //             "contingencyType": "symbol",
    //             "exDestination": "symbol",
    //             "ordStatus": "symbol",
    //             "triggered": "symbol",
    //             "workingIndicator": "boolean",
    //             "ordRejReason": "symbol",
    //             "simpleLeavesQty": "float",
    //             "leavesQty": "long",
    //             "simpleCumQty": "float",
    //             "cumQty": "long",
    //             "avgPx": "float",
    //             "multiLegReportingType": "symbol",
    //             "text": "string",
    //             "transactTime": "timestamp",
    //             "timestamp": "timestamp"
    //         },
    //         "foreignKeys": { symbol: 'instrument', side: "side", ordStatus: "ordStatus" },
    //         "attributes": {
    //             "orderID": "grouped",
    //             "account": "grouped",
    //             "ordStatus": "grouped",
    //             "workingIndicator": "grouped"
    //         },
    //         "filter": { account: 1455728 },
    //         "data": [
    //             {
    //                 "orderID": "56222c7a-9956-413a-82cf-99f4812c214b",
    //                 "clOrdID": '',
    //                 "clOrdLinkID": '',
    //                 "account": 1455728,
    //                 "symbol": "XBTUSD",
    //                 "side": "Sell",
    //                 "simpleOrderQty": null,
    //                 "orderQty": 1,
    //                 "price": 40000,
    //                 "displayQty": null,
    //                 "stopPx": null,
    //                 "pegOffsetValue": null,
    //                 "pegPriceType": '',
    //                 "currency": "USD",
    //                 "settlCurrency": "XBt",
    //                 "ordType": "ccxt.Limit",
    //                 "timeInForce": "GoodTillCancel",
    //                 "execInst": '',
    //                 "contingencyType": '',
    //                 "exDestination": "XBME",
    //                 "ordStatus": "New",
    //                 "triggered": '',
    //                 "workingIndicator": true,
    //                 "ordRejReason": '',
    //                 "simpleLeavesQty": null,
    //                 "leavesQty": 1,
    //                 "simpleCumQty": null,
    //                 "cumQty": 0,
    //                 "avgPx": null,
    //                 "multiLegReportingType": "SingleSecurity",
    //                 "text": "Submitted via API.",
    //                 "transactTime": "2021-01-02T21:38:49.246Z",
    //                 "timestamp": "2021-01-02T21:38:49.246Z"
    //             }
    //         ]
    //     }
    //
    //     {
    //         "table": "order",
    //         "action": "insert",
    //         "data": [
    //             {
    //                 "orderID": "fa993d8e-f7e4-46ed-8097-04f8e9393585",
    //                 "clOrdID": '',
    //                 "clOrdLinkID": '',
    //                 "account": 1455728,
    //                 "symbol": "XBTUSD",
    //                 "side": "Sell",
    //                 "simpleOrderQty": null,
    //                 "orderQty": 1,
    //                 "price": 40000,
    //                 "displayQty": null,
    //                 "stopPx": null,
    //                 "pegOffsetValue": null,
    //                 "pegPriceType": '',
    //                 "currency": "USD",
    //                 "settlCurrency": "XBt",
    //                 "ordType": "ccxt.Limit",
    //                 "timeInForce": "GoodTillCancel",
    //                 "execInst": '',
    //                 "contingencyType": '',
    //                 "exDestination": "XBME",
    //                 "ordStatus": "New",
    //                 "triggered": '',
    //                 "workingIndicator": true,
    //                 "ordRejReason": '',
    //                 "simpleLeavesQty": null,
    //                 "leavesQty": 1,
    //                 "simpleCumQty": null,
    //                 "cumQty": 0,
    //                 "avgPx": null,
    //                 "multiLegReportingType": "SingleSecurity",
    //                 "text": "Submitted via API.",
    //                 "transactTime": "2021-01-02T23:49:02.286Z",
    //                 "timestamp": "2021-01-02T23:49:02.286Z"
    //             }
    //         ]
    //     }
    //
    //
    //
    //     {
    //         "table": "order",
    //         "action": "update",
    //         "data": [
    //             {
    //                 "orderID": "fa993d8e-f7e4-46ed-8097-04f8e9393585",
    //                 "ordStatus": "Canceled",
    //                 "workingIndicator": false,
    //                 "leavesQty": 0,
    //                 "text": "Canceled: Canceled via API.\nSubmitted via API.",
    //                 "timestamp": "2021-01-02T23:50:51.272Z",
    //                 "clOrdID": '',
    //                 "account": 1455728,
    //                 "symbol": "XBTUSD"
    //             }
    //         ]
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var messageHash interface{} = "order"
    // initial subscription response with multiple orders
    var dataLength interface{} =     ccxt.GetArrayLength(data)
    if ccxt.IsTrue(ccxt.IsGreaterThan(dataLength, 0)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        var symbols interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, dataLength); i++ {
            var currentOrder interface{} = ccxt.GetValue(data, i)
            var orderId interface{} = this.SafeString(currentOrder, "orderID")
            var previousOrder interface{} = this.SafeValue(stored.(*ccxt.ArrayCache).Hashmap, orderId)
            var rawOrder interface{} = currentOrder
            if ccxt.IsTrue(!ccxt.IsEqual(previousOrder, nil)) {
                rawOrder = this.Extend(ccxt.GetValue(previousOrder, "info"), currentOrder)
            }
            var order interface{} = this.ParseOrder(rawOrder)
            stored.(ccxt.Appender).Append(order)
            var symbol interface{} = ccxt.GetValue(order, "symbol")
            ccxt.AddElementToObject(symbols, symbol, true)
        }
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        var keys interface{} = ccxt.ObjectKeys(symbols)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var symbol interface{} = ccxt.GetValue(keys, i)
            client.(ccxt.ClientInterface).Resolve(this.Orders, ccxt.Add(ccxt.Add(messageHash, ":"), symbol))
        }
    }
}
/**
 * @method
 * @name bitmex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitmexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11768)
        
            retRes11778 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes11778)
            var name interface{} = "execution"
            var subscriptionHash interface{} = name
            var messageHash interface{} = name
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{subscriptionHash},
            }
        
            trades:= (<-this.Watch(url, messageHash, request, subscriptionHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "table":"execution",
    //         "action":"insert",
    //         "data":[
    //             {
    //                 "execID":"0193e879-cb6f-2891-d099-2c4eb40fee21",
    //                 "orderID":"00000000-0000-0000-0000-000000000000",
    //                 "clOrdID":"",
    //                 "clOrdLinkID":"",
    //                 "account":2,
    //                 "symbol":"XBTUSD",
    //                 "side":"Sell",
    //                 "lastQty":1,
    //                 "lastPx":1134.37,
    //                 "underlyingLastPx":null,
    //                 "lastMkt":"XBME",
    //                 "lastLiquidityInd":"RemovedLiquidity",
    //                 "simpleOrderQty":null,
    //                 "orderQty":1,
    //                 "price":1134.37,
    //                 "displayQty":null,
    //                 "stopPx":null,
    //                 "pegOffsetValue":null,
    //                 "pegPriceType":"",
    //                 "currency":"USD",
    //                 "settlCurrency":"XBt",
    //                 "execType":"ccxt.Trade",
    //                 "ordType":"ccxt.Limit",
    //                 "timeInForce":"ImmediateOrCancel",
    //                 "execInst":"",
    //                 "contingencyType":"",
    //                 "exDestination":"XBME",
    //                 "ordStatus":"Filled",
    //                 "triggered":"",
    //                 "workingIndicator":false,
    //                 "ordRejReason":"",
    //                 "simpleLeavesQty":0,
    //                 "leavesQty":0,
    //                 "simpleCumQty":0.001,
    //                 "cumQty":1,
    //                 "avgPx":1134.37,
    //                 "commission":0.00075,
    //                 "tradePublishIndicator":"DoNotPublishTrade",
    //                 "multiLegReportingType":"SingleSecurity",
    //                 "text":"ccxt.Liquidation",
    //                 "trdMatchID":"7f4ab7f6-0006-3234-76f4-ae1385aad00f",
    //                 "execCost":88155,
    //                 "execComm":66,
    //                 "homeNotional":-0.00088155,
    //                 "foreignNotional":1,
    //                 "transactTime":"2017-04-04T22:07:46.035Z",
    //                 "timestamp":"2017-04-04T22:07:46.035Z"
    //             }
    //         ]
    //     }
    //
    var messageHash interface{} = this.SafeString(message, "table")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var dataByExecType interface{} = this.GroupBy(data, "execType")
    var rawTrades interface{} = this.SafeValue(dataByExecType, "ccxt.Trade", []interface{}{})
    var trades interface{} = this.ParseTrades(rawTrades)
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.MyTrades
    var symbols interface{} = map[string]interface{} {}
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        var trade interface{} = ccxt.GetValue(trades, j)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        stored.(ccxt.Appender).Append(trade)
        ccxt.AddElementToObject(symbols, symbol, trade)
    }
    var numTrades interface{} =     ccxt.GetArrayLength(trades)
    if ccxt.IsTrue(ccxt.IsGreaterThan(numTrades, 0)) {
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    var keys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(keys, i)))
    }
}
/**
 * @method
 * @name bitmex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitmex.com/app/wsAPI#OrderBookL2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitmexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes129515 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes129515)
                ch <- retRes129515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmex#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitmex.com/app/wsAPI#OrderBookL2
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitmexCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var table interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                table = this.SafeString(this.Options, "watchOrderBookLevel", "orderBookL2")
            } else if ccxt.IsTrue(ccxt.IsEqual(limit, 25)) {
                table = "orderBookL2_25"
            } else if ccxt.IsTrue(ccxt.IsEqual(limit, 10)) {
                table = "orderBookL10"
            } else {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOrderBookForSymbols limit argument must be undefined (L2), 25 (L2) or 10 (L3)")))
            }
        
            retRes13198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13198)
            symbols = this.MarketSymbols(symbols)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add(ccxt.Add(table, ":"), ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), topics))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmex#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitmexCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes13528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13528)
            symbols = this.MarketSymbols(symbols, nil, false)
            var table interface{} = "trade"
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add(ccxt.Add(table, ":"), ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), topics))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmex#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.bitmex.com/app/wsAPI#Subscriptions
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitmexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13928)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var table interface{} = ccxt.Add("tradeBin", this.SafeString(this.Timeframes, timeframe, timeframe))
            var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), ccxt.GetValue(market, "id"))
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{messageHash},
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "table": "tradeBin1m",
    //         "action": "partial",
    //         "keys": [],
    //         "types": {
    //             "timestamp": "timestamp",
    //             "symbol": "symbol",
    //             "open": "float",
    //             "high": "float",
    //             "low": "float",
    //             "close": "float",
    //             "trades": "long",
    //             "volume": "long",
    //             "vwap": "float",
    //             "lastSize": "long",
    //             "turnover": "long",
    //             "homeNotional": "float",
    //             "foreignNotional": "float"
    //         },
    //         "foreignKeys": { symbol: "instrument" },
    //         "attributes": { timestamp: "sorted", symbol: "grouped" },
    //         "filter": { symbol: "XBTUSD" },
    //         "data": [
    //             {
    //                 "timestamp": "2020-02-03T01:13:00.000Z",
    //                 "symbol": "XBTUSD",
    //                 "open": 9395,
    //                 "high": 9395.5,
    //                 "low": 9394.5,
    //                 "close": 9395,
    //                 "trades": 221,
    //                 "volume": 839204,
    //                 "vwap": 9394.9643,
    //                 "lastSize": 1874,
    //                 "turnover": 8932641535,
    //                 "homeNotional": 89.32641534999999,
    //                 "foreignNotional": 839204
    //             }
    //         ]
    //     }
    //
    //
    //     {
    //         "table": "tradeBin1m",
    //         "action": "insert",
    //         "data": [
    //             {
    //                 "timestamp": "2020-02-03T18:28:00.000Z",
    //                 "symbol": "XBTUSD",
    //                 "open": 9256,
    //                 "high": 9256.5,
    //                 "low": 9256,
    //                 "close": 9256,
    //                 "trades": 29,
    //                 "volume": 79057,
    //                 "vwap": 9256.688,
    //                 "lastSize": 100,
    //                 "turnover": 854077082,
    //                 "homeNotional": 8.540770820000002,
    //                 "foreignNotional": 79057
    //             }
    //         ]
    //     }
    //
    var table interface{} = this.SafeString(message, "table")
    var interval interface{} = ccxt.Replace(table, "tradeBin", "")
    var timeframe interface{} = this.FindTimeframe(interval)
    var duration interface{} = this.ParseTimeframe(timeframe)
    var candles interface{} = this.SafeValue(message, "data", []interface{}{})
    var results interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(candles)); i++ {
        var candle interface{} = ccxt.GetValue(candles, i)
        var marketId interface{} = this.SafeString(candle, "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), ccxt.GetValue(market, "id"))
        var result interface{} = []interface{}{ccxt.Subtract(this.Parse8601(this.SafeString(candle, "timestamp")), ccxt.Multiply(duration, 1000)), nil, this.SafeFloat(candle, "high"), this.SafeFloat(candle, "low"), this.SafeFloat(candle, "close"), this.SafeFloat(candle, "volume")}
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(result)
        ccxt.AddElementToObject(results, messageHash, stored)
    }
    var messageHashes interface{} = ccxt.ObjectKeys(results)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(results, messageHash), messageHash)
    }
}
func  (this *BitmexCore) WatchHeartbeat(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15158 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15158)
            var event interface{} = "heartbeat"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
                retRes151815 :=  (<-this.Watch(url, event))
                ccxt.PanicOnError(retRes151815)
                ch <- retRes151815
                return nil
        
            }()
            return ch
        }
func  (this *BitmexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // first snapshot
    //
    //     {
    //         "table": "orderBookL2",
    //         "action": "partial",
    //         "keys": [ 'symbol', "id", "side" ],
    //         "types": {
    //             "symbol": "symbol",
    //             "id": "long",
    //             "side": "symbol",
    //             "size": "long",
    //             "price": "float"
    //         },
    //         "foreignKeys": { symbol: "instrument", side: "side" },
    //         "attributes": { symbol: "parted", id: "sorted" },
    //         "filter": { symbol: "XBTUSD" },
    //         "data": [
    //             { symbol: "XBTUSD", id: 8700000100, side: "Sell", size: 1, price: 999999 },
    //             { symbol: "XBTUSD", id: 8700000200, side: "Sell", size: 3, price: 999998 },
    //             { symbol: "XBTUSD", id: 8716991250, side: "Sell", size: 26, price: 830087.5 },
    //             { symbol: "XBTUSD", id: 8728701950, side: "Sell", size: 1720, price: 712980.5 },
    //         ]
    //     }
    //
    // subsequent updates
    //
    //     {
    //         "table": "orderBookL2",
    //         "action": "update",
    //         "data": [
    //             {
    //               "table": "orderBookL2",
    //               "action": "insert",
    //               "data": [
    //                 {
    //                   "symbol": "ETH_USDT",
    //                   "id": 85499965912,
    //                   "side": "Buy",
    //                   "size": 83000000,
    //                   "price": 1704.4,
    //                   "timestamp": "2023-03-26T22:29:00.299Z"
    //                 }
    //               ]
    //             }
    //             ...
    //         ]
    //     }
    //
    var action interface{} = this.SafeString(message, "action")
    var table interface{} = this.SafeString(message, "table")
    if ccxt.IsTrue(ccxt.IsEqual(table, nil)) {
        return  // protecting from weird updates
    }
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    // if it's an initial snapshot
    if ccxt.IsTrue(ccxt.IsEqual(action, "partial")) {
        var filter interface{} = this.SafeDict(message, "filter", map[string]interface{} {})
        var marketId interface{} = this.SafeValue(filter, "symbol")
        if ccxt.IsTrue(ccxt.IsEqual(marketId, nil)) {
            return  // protecting from weird update
        }
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        if ccxt.IsTrue(ccxt.IsEqual(table, "orderBookL2")) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook())
        } else if ccxt.IsTrue(ccxt.IsEqual(table, "orderBookL2_25")) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook(map[string]interface{} {}, 25))
        } else if ccxt.IsTrue(ccxt.IsEqual(table, "orderBook10")) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.IndexedOrderBook(map[string]interface{} {}, 10))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var price interface{} = this.SafeFloat(ccxt.GetValue(data, i), "price")
            var size interface{} = this.ConvertFromRawQuantity(symbol, this.SafeString(ccxt.GetValue(data, i), "size"))
            var id interface{} = this.SafeString(ccxt.GetValue(data, i), "id")
            var side interface{} = this.SafeString(ccxt.GetValue(data, i), "side")
            side = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "Buy"))), "bids", "asks")
            var bookside interface{} = ccxt.GetValue(orderbook, side)
            bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, size, id})
            var datetime interface{} = this.SafeString(ccxt.GetValue(data, i), "timestamp")
            ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
            ccxt.AddElementToObject(orderbook, "datetime", datetime)
        }
        var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    } else {
        var numUpdatesByMarketId interface{} = map[string]interface{} {}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var marketId interface{} = this.SafeValue(ccxt.GetValue(data, i), "symbol")
            if ccxt.IsTrue(ccxt.IsEqual(marketId, nil)) {
                return  // protecting from weird update
            }
            if !ccxt.IsTrue((ccxt.InOp(numUpdatesByMarketId, marketId))) {
                ccxt.AddElementToObject(numUpdatesByMarketId, marketId, 0)
            }
            ccxt.AddElementToObject(numUpdatesByMarketId, marketId, this.Sum(numUpdatesByMarketId, 1))
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            var price interface{} = this.SafeNumber(ccxt.GetValue(data, i), "price")
            var size interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(action, "delete"))), 0, this.ConvertFromRawQuantity(symbol, this.SafeString(ccxt.GetValue(data, i), "size", "0")))
            var id interface{} = this.SafeString(ccxt.GetValue(data, i), "id")
            var side interface{} = this.SafeString(ccxt.GetValue(data, i), "side")
            side = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "Buy"))), "bids", "asks")
            var bookside interface{} = ccxt.GetValue(orderbook, side)
            bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, size, id})
            var datetime interface{} = this.SafeString(ccxt.GetValue(data, i), "timestamp")
            ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
            ccxt.AddElementToObject(orderbook, "datetime", datetime)
        }
        var marketIds interface{} = ccxt.ObjectKeys(numUpdatesByMarketId)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
            var marketId interface{} = ccxt.GetValue(marketIds, i)
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add(table, ":"), symbol)
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    }
}
func  (this *BitmexCore) HandleSystemStatus(client interface{}, message interface{}) interface{}  {
    //
    // todo answer the question whether handleSystemStatus should be renamed
    // and unified as handleStatus for any usage pattern that
    // involves system status and maintenance updates
    //
    //     {
    //         "info": "Welcome to the BitMEX Realtime API.",
    //         "version": "2019-11-22T00:24:37.000Z",
    //         "timestamp": "2019-11-23T09:02:27.771Z",
    //         "docs": "https://www.bitmex.com/app/wsAPI",
    //         "limit": { remaining: 39 }
    //     }
    //
    return message
}
func  (this *BitmexCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "success": true,
    //         "subscribe": "orderBookL2:XBTUSD",
    //         "request": { op: "subscribe", args: [ "orderBookL2:XBTUSD" ] }
    //     }
    //
    return message
}
func  (this *BitmexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // generic error format
    //
    //     { "error": errorMessage }
    //
    // examples
    //
    //     {
    //         "status": 429,
    //         "error": "Rate limit exceeded, retry in 1 seconds.",
    //         "meta": { "retryAfter": 1 },
    //         "request": { "op": "subscribe", "args": "orderBook" },
    //     }
    //
    //     { "error": "Rate limit exceeded, retry in 29 seconds." }
    //
    var error interface{} = this.SafeString(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        var request interface{} = this.SafeValue(message, "request", map[string]interface{} {})
        var args interface{} = this.SafeValue(request, "args", []interface{}{})
        var numArgs interface{} =         ccxt.GetArrayLength(args)
        if ccxt.IsTrue(ccxt.IsGreaterThan(numArgs, 0)) {
            var messageHash interface{} = ccxt.GetValue(args, 0)
            var broad interface{} = ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad")
            var broadKey interface{} = this.FindBroadlyMatchedKey(broad, error)
            var exception interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(broadKey, nil)) {
                exception = ccxt.ExchangeError(                error) // c# requirement for now
            } else {
                exception = ccxt.CallDynamically(ccxt.GetValue(broad, broadKey), error)
            }
            client.(ccxt.ClientInterface).Reject(exception, messageHash)
            return false
        }
    }
    return true
}
func  (this *BitmexCore) HandleMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "info": "Welcome to the BitMEX Realtime API.",
    //         "version": "2019-11-22T00:24:37.000Z",
    //         "timestamp": "2019-11-23T09:04:42.569Z",
    //         "docs": "https://www.bitmex.com/app/wsAPI",
    //         "limit": { remaining: 38 }
    //     }
    //
    //     {
    //         "success": true,
    //         "subscribe": "orderBookL2:XBTUSD",
    //         "request": { op: "subscribe", args: [ "orderBookL2:XBTUSD" ] }
    //     }
    //
    //     {
    //         "table": "orderBookL2",
    //         "action": "update",
    //         "data": [
    //             { symbol: "XBTUSD", id: 8799284800, side: "Sell", size: 721000 },
    //             { symbol: "XBTUSD", id: 8799285100, side: "Sell", size: 70590 },
    //             { symbol: "XBTUSD", id: 8799285550, side: "Sell", size: 217652 },
    //             { symbol: "XBTUSD", id: 8799285850, side: "Sell", size: 105578 },
    //             { symbol: "XBTUSD", id: 8799286350, side: "Sell", size: 172093 },
    //             { symbol: "XBTUSD", id: 8799286650, side: "Sell", size: 201125 },
    //             { symbol: "XBTUSD", id: 8799288950, side: "Buy", size: 47552 },
    //             { symbol: "XBTUSD", id: 8799289250, side: "Buy", size: 78217 },
    //             { symbol: "XBTUSD", id: 8799289700, side: "Buy", size: 193677 },
    //             { symbol: "XBTUSD", id: 8799290000, side: "Buy", size: 818161 },
    //             { symbol: "XBTUSD", id: 8799290500, side: "Buy", size: 218806 },
    //             { symbol: "XBTUSD", id: 8799290800, side: "Buy", size: 102946 }
    //         ]
    //     }
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        var table interface{} = this.SafeString(message, "table")
        var methods interface{} = map[string]interface{} {
            "orderBookL2": this.HandleOrderBook,
            "orderBookL2_25": this.HandleOrderBook,
            "orderBook10": this.HandleOrderBook,
            "instrument": this.HandleTicker,
            "trade": this.HandleTrades,
            "tradeBin1m": this.HandleOHLCV,
            "tradeBin5m": this.HandleOHLCV,
            "tradeBin1h": this.HandleOHLCV,
            "tradeBin1d": this.HandleOHLCV,
            "order": this.HandleOrders,
            "execution": this.HandleMyTrades,
            "margin": this.HandleBalance,
            "liquidation": this.HandleLiquidation,
            "position": this.HandlePositions,
        }
        var method interface{} = this.SafeValue(methods, table)
        if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
            var request interface{} = this.SafeValue(message, "request", map[string]interface{} {})
            var op interface{} = this.SafeValue(request, "op")
            if ccxt.IsTrue(ccxt.IsEqual(op, "authKeyExpires")) {
                this.HandleAuthenticationMessage(client, message)
            }
        } else {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *BitmexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
