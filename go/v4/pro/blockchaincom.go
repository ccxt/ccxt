package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BlockchaincomCore struct {
	*ccxt.BlockchaincomCore
	base *ccxt.BlockchaincomCore
}

func NewBlockchaincomCore() *BlockchaincomCore {
    p := &BlockchaincomCore{}
	base := &ccxt.BlockchaincomCore{}
	p.base = base
	p.BlockchaincomCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BlockchaincomCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": false,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://ws.blockchain.info/mercury-gateway/v1/ws",
            },
        },
        "options": map[string]interface{} {
            "ws": map[string]interface{} {
                "options": map[string]interface{} {
                    "headers": map[string]interface{} {
                        "Origin": "https://exchange.blockchain.com",
                    },
                },
                "noOriginHeader": false,
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
        "timeframes": map[string]interface{} {
            "1m": "60",
            "5m": "300",
            "15m": "900",
            "1h": "3600",
            "6h": "21600",
            "1d": "86400",
        },
    })
}
/**
 * @method
 * @name blockchaincom#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://exchange.blockchain.com/api/#balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BlockchaincomCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes648 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes648)
            var messageHash interface{} = "balance"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": "balances",
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes7215 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes7215)
                ch <- retRes7215
                return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleBalance(client interface{}, message interface{})  {
    //
    //  subscribed
    //     {
    //         "seqnum": 1,
    //         "event": "subscribed",
    //         "channel": "balances",
    //         "local_currency": "USD",
    //         "batching": false
    //     }
    //  snapshot
    //     {
    //         "seqnum": 2,
    //         "event": "snapshot",
    //         "channel": "balances",
    //         "balances": [
    //           {
    //             "currency": "BTC",
    //             "balance": 0.00366963,
    //             "available": 0.00266963,
    //             "balance_local": 38.746779155,
    //             "available_local": 28.188009155,
    //             "rate": 10558.77
    //           },
    //            ...
    //         ],
    //         "total_available_local": 65.477864168,
    //         "total_balance_local": 87.696634168
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribed")) {
        return
    }
    var result interface{} = map[string]interface{} {
        "info": message,
    }
    var balances interface{} = this.SafeValue(message, "balances", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
        var entry interface{} = ccxt.GetValue(balances, i)
        var currencyId interface{} = this.SafeString(entry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(entry, "available"))
        ccxt.AddElementToObject(account, "total", this.SafeString(entry, "balance"))
        ccxt.AddElementToObject(result, code, account)
    }
    var messageHash interface{} = "balance"
    this.Balance = this.SafeBalance(result)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name blockchaincom#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market.
 * @see https://exchange.blockchain.com/api/#prices
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents. Allows '1m', '5m', '15m', '1h', '6h' '1d'. Can only watch one timeframe per symbol.
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BlockchaincomCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1388)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": "prices",
                "symbol": ccxt.GetValue(market, "id"),
                "granularity": this.ParseNumber(interval),
            }
            request = this.DeepExtend(request, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
            ohlcv:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //  subscribed
    //     {
    //         "seqnum": 0,
    //         "event": "subscribed",
    //         "channel": "prices",
    //         "symbol": "BTC-USDT",
    //         "granularity": 60
    //     }
    //
    //  updated
    //     {
    //         "seqnum": 1,
    //         "event": "updated",
    //         "channel": "prices",
    //         "symbol": "BTC-USD",
    //         "price": [ 1660085580000, 23185.215, 23185.935, 23164.79, 23169.97, 0 ]
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "rejected")) {
        var jsonMessage interface{} = this.Json(message)
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), jsonMessage)))
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "updated")) {
        var marketId interface{} = this.SafeString(message, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
        var messageHash interface{} = ccxt.Add("ohlcv:", symbol)
        var request interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        var timeframeId interface{} = this.SafeNumber(request, "granularity")
        var timeframe interface{} = this.FindTimeframe(timeframeId)
        var ohlcv interface{} = this.SafeValue(message, "price", []interface{}{})
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(ohlcv)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    } else if ccxt.IsTrue(!ccxt.IsEqual(event, "subscribed")) {
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))))
    }
}
/**
 * @method
 * @name blockchaincom#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://exchange.blockchain.com/api/#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BlockchaincomCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2148 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2148)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": "ticker",
                "symbol": ccxt.GetValue(market, "id"),
            }
            request = this.DeepExtend(request, params)
        
                retRes22515 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes22515)
                ch <- retRes22515
                return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleTicker(client interface{}, message interface{})  {
    //
    //  subscribed
    //     {
    //         "seqnum": 0,
    //         "event": "subscribed",
    //         "channel": "ticker",
    //         "symbol": "BTC-USD"
    //     }
    //  snapshot
    //     {
    //         "seqnum": 1,
    //         "event": "snapshot",
    //         "channel": "ticker",
    //         "symbol": "BTC-USD",
    //         "price_24h": 23071.4,
    //         "volume_24h": 236.28398636,
    //         "last_trade_price": 23936.4,
    //         "mark_price": 23935.335240262
    //     }
    // update
    //     {
    //         "seqnum": 2,
    //         "event": "updated",
    //         "channel": "ticker",
    //         "symbol": "BTC-USD",
    //         "mark_price": 23935.242443617
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ticker interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribed")) {
        return
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        ticker = this.ParseTicker(message, market)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "updated")) {
        var lastTicker interface{} = this.SafeValue(this.Tickers, symbol)
        ticker = this.ParseWsUpdatedTicker(message, lastTicker, market)
    }
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *BlockchaincomCore) ParseWsUpdatedTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "seqnum": 2,
    //         "event": "updated",
    //         "channel": "ticker",
    //         "symbol": "BTC-USD",
    //         "mark_price": 23935.242443617
    //     }
    //
    lastTicker := ccxt.GetArg(optionalArgs, 0, nil)
    _ = lastTicker
    market := ccxt.GetArg(optionalArgs, 1, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
    var last interface{} = this.SafeString(ticker, "mark_price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(lastTicker, "open"),
        "close": nil,
        "last": last,
        "previousClose": this.SafeString(lastTicker, "close"),
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(lastTicker, "baseVolume"),
        "quoteVolume": nil,
        "info": this.Extend(this.SafeValue(lastTicker, "info", map[string]interface{} {}), ticker),
    }, market)
}
/**
 * @method
 * @name blockchaincom#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://exchange.blockchain.com/api/#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of    trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BlockchaincomCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3248 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3248)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": "trades",
                "symbol": ccxt.GetValue(market, "id"),
            }
            request = this.DeepExtend(request, params)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleTrades(client interface{}, message interface{})  {
    //
    //  subscribed
    //     {
    //         "seqnum": 0,
    //         "event": "subscribed",
    //         "channel": "trades",
    //         "symbol": "BTC-USDT"
    //     }
    //  updates
    //     {
    //         "seqnum": 1,
    //         "event": "updated",
    //         "channel": "trades",
    //         "symbol": "BTC-USDT",
    //         "timestamp": "2022-08-08T17:23:48.163096Z",
    //         "side": "sell",
    //         "qty": 0.083523,
    //         "price": 23940.67,
    //         "trade_id": "563078810223444"
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(!ccxt.IsEqual(event, "updated")) {
        return
    }
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var parsed interface{} = this.ParseWsTrade(message, market)
    stored.(ccxt.Appender).Append(parsed)
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *BlockchaincomCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "seqnum": 1,
    //         "event": "updated",
    //         "channel": "trades",
    //         "symbol": "BTC-USDT",
    //         "timestamp": "2022-08-08T17:23:48.163096Z",
    //         "side": "sell",
    //         "qty": 0.083523,
    //         "price": 23940.67,
    //         "trade_id": "563078810223444"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var datetime interface{} = this.SafeString(trade, "timestamp")
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "trade_id"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "symbol": this.SafeSymbol(marketId, market, "-"),
        "order": nil,
        "type": nil,
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "qty"),
        "cost": nil,
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name blockchaincom#fetchOrders
 * @description watches information on multiple orders made by the user
 * @see https://exchange.blockchain.com/api/#mass-order-status-request-ordermassstatusrequest
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BlockchaincomCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4268)
        
            retRes4278 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4278)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var message interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": "trading",
            }
            var messageHash interface{} = "orders"
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "seqnum": 1,
    //         "event": "rejected",
    //         "channel": "trading",
    //         "text": "Not subscribed to channel"
    //     }
    //  snapshot
    //     {
    //         "seqnum": 2,
    //         "event": "snapshot",
    //         "channel": "trading",
    //         "orders": [
    //           {
    //             "orderID": "562965341621940",
    //             "gwOrderId": 181011136260,
    //             "clOrdID": "016caf67f7a94508webd",
    //             "symbol": "BTC-USD",
    //             "side": "sell",
    //             "ordType": "limit",
    //             "orderQty": 0.000675,
    //             "leavesQty": 0.000675,
    //             "cumQty": 0,
    //             "avgPx": 0,
    //             "ordStatus": "open",
    //             "timeInForce": "GTC",
    //             "text": "New order",
    //             "execType": "0",
    //             "execID": "21415965325",
    //             "transactTime": "2022-08-08T23:31:00.550795Z",
    //             "msgType": 8,
    //             "lastPx": 0,
    //             "lastShares": 0,
    //             "tradeId": "0",
    //             "fee": 0,
    //             "price": 30000,
    //             "marginOrder": false,
    //             "closePositionOrder": false
    //           }
    //         ],
    //         "positions": []
    //     }
    //  update
    //     {
    //         "seqnum": 3,
    //         "event": "updated",
    //         "channel": "trading",
    //         "orderID": "562965341621940",
    //         "gwOrderId": 181011136260,
    //         "clOrdID": "016caf67f7a94508webd",
    //         "symbol": "BTC-USD",
    //         "side": "sell",
    //         "ordType": "limit",
    //         "orderQty": 0.000675,
    //         "leavesQty": 0.000675,
    //         "cumQty": 0,
    //         "avgPx": 0,
    //         "ordStatus": "cancelled",
    //         "timeInForce": "GTC",
    //         "text": "Canceled by User",
    //         "execType": "4",
    //         "execID": "21416034921",
    //         "transactTime": "2022-08-08T23:33:25.727785Z",
    //         "msgType": 8,
    //         "lastPx": 0,
    //         "lastShares": 0,
    //         "tradeId": "0",
    //         "fee": 0,
    //         "price": 30000,
    //         "marginOrder": false,
    //         "closePositionOrder": false
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    var messageHash interface{} = "orders"
    var cachedOrders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(cachedOrders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribed")) {
        return
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "rejected")) {
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))))
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        var orders interface{} = this.SafeValue(message, "orders", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
            var order interface{} = ccxt.GetValue(orders, i)
            var parsedOrder interface{} = this.ParseWsOrder(order)
            cachedOrders.(ccxt.Appender).Append(parsedOrder)
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "updated")) {
        var parsedOrder interface{} = this.ParseWsOrder(message)
        cachedOrders.(ccxt.Appender).Append(parsedOrder)
    }
    this.Orders = cachedOrders
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *BlockchaincomCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "seqnum": 3,
    //         "event": "updated",
    //         "channel": "trading",
    //         "orderID": "562965341621940",
    //         "gwOrderId": 181011136260,
    //         "clOrdID": "016caf67f7a94508webd",
    //         "symbol": "BTC-USD",
    //         "side": "sell",
    //         "ordType": "limit",
    //         "orderQty": 0.000675,
    //         "leavesQty": 0.000675,
    //         "cumQty": 0,
    //         "avgPx": 0,
    //         "ordStatus": "cancelled",
    //         "timeInForce": "GTC",
    //         "text": "Canceled by User",
    //         "execType": "4",
    //         "execID": "21416034921",
    //         "transactTime": "2022-08-08T23:33:25.727785Z",
    //         "msgType": 8,
    //         "lastPx": 0,
    //         "lastShares": 0,
    //         "tradeId": "0",
    //         "fee": 0,
    //         "price": 30000,
    //         "marginOrder": false,
    //         "closePositionOrder": false
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(order, "transactTime")
    var status interface{} = this.SafeString(order, "ordStatus")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var tradeId interface{} = this.SafeString(order, "tradeId")
    var trades interface{} = []interface{}{}
    if ccxt.IsTrue(!ccxt.IsEqual(tradeId, "0")) {
        ccxt.AppendToArray(&trades, map[string]interface{} {
            "id": tradeId,
        })
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "orderID"),
        "clientOrderId": this.SafeString(order, "clOrdID"),
        "datetime": datetime,
        "timestamp": this.Parse8601(datetime),
        "status": this.ParseWsOrderStatus(status),
        "symbol": this.SafeSymbol(marketId, market),
        "type": this.SafeString(order, "ordType"),
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": ccxt.IsEqual(this.SafeString(order, "execInst"), "ALO"),
        "side": this.SafeString(order, "side"),
        "price": this.SafeString(order, "price"),
        "stopPrice": this.SafeString(order, "stopPx"),
        "cost": nil,
        "amount": this.SafeString(order, "orderQty"),
        "filled": this.SafeString(order, "cumQty"),
        "remaining": this.SafeString(order, "leavesQty"),
        "trades": trades,
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": this.SafeNumber(order, "fee"),
            "currency": this.SafeString(market, "quote"),
        },
        "info": order,
        "lastTradeTimestamp": nil,
        "average": this.SafeString(order, "avgPx"),
    }, market)
}
func  (this *BlockchaincomCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "open",
        "open": "open",
        "rejected": "rejected",
        "cancelled": "canceled",
        "filled": "closed",
        "partial": "open",
        "expired": "expired",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name blockchaincom#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://exchange.blockchain.com/api/#l2-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {objectConstructor} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] accepts l2 or l3 for level 2 or level 3 order book
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BlockchaincomCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6418)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var typeVar interface{} = this.SafeString(params, "type", "l2")
            params = this.Omit(params, "type")
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook:", symbol), ":"), typeVar)
            var subscribe interface{} = map[string]interface{} {
                "action": "subscribe",
                "channel": typeVar,
                "symbol": ccxt.GetValue(market, "id"),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BlockchaincomCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //  subscribe
    //     {
    //         "seqnum": 0,
    //         "event": "subscribed",
    //         "channel": "l2",
    //         "symbol": "BTC-USDT",
    //         "batching": false
    //     }
    //  snapshot
    //     {
    //         "seqnum": 1,
    //         "event": "snapshot",
    //         "channel": "l2",
    //         "symbol": "BTC-USDT",
    //         "bids": [
    //           { num: 1, px: 0.01, qty: 22 },
    //         ],
    //         "asks": [
    //           { num: 1, px: 23840.26, qty: 0.25 },
    //         ],
    //         "timestamp": "2022-08-08T22:03:19.071870Z"
    //     }
    //  update
    //     {
    //         "seqnum": 2,
    //         "event": "updated",
    //         "channel": "l2",
    //         "symbol": "BTC-USDT",
    //         "bids": [],
    //         "asks": [ { num: 1, px: 23855.06, qty: 1.04786347 } ],
    //         "timestamp": "2022-08-08T22:03:19.014680Z"
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribed")) {
        return
    }
    var typeVar interface{} = this.SafeString(message, "channel")
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderbook:", symbol), ":"), typeVar)
    var datetime interface{} = this.SafeString(message, "timestamp")
    var timestamp interface{} = this.Parse8601(datetime)
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Orderbooks, symbol), nil)) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.CountedOrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        var snapshot interface{} = this.ParseOrderBook(message, symbol, timestamp, "bids", "asks", "px", "qty", "num")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "updated")) {
        var asks interface{} = this.SafeList(message, "asks", []interface{}{})
        var bids interface{} = this.SafeList(message, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", datetime)
    } else {
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " watchOrderBook() does not support "), event), " yet")))
    }
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BlockchaincomCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bookArray interface{} = this.ParseBidAsk(delta, "px", "qty", "num")
    bookside.(ccxt.IOrderBookSide).StoreArray(bookArray)
}
func  (this *BlockchaincomCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BlockchaincomCore) HandleMessage(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    var handlers interface{} = map[string]interface{} {
        "ticker": this.HandleTicker,
        "trades": this.HandleTrades,
        "prices": this.HandleOHLCV,
        "l2": this.HandleOrderBook,
        "l3": this.HandleOrderBook,
        "auth": this.HandleAuthenticationMessage,
        "balances": this.HandleBalance,
        "trading": this.HandleOrders,
    }
    var handler interface{} = this.SafeValue(handlers, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
        return
    }
    panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " received an unsupported message: "), this.Json(message))))
}
func  (this *BlockchaincomCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "seqnum": 0,
    //         "event": "subscribed",
    //         "channel": "auth",
    //         "readOnly": false
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(!ccxt.IsEqual(event, "subscribed")) {
        panic(ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " received an authentication error: "), this.Json(message))))
    }
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        future.(*ccxt.Future).Resolve(true)
    }
}
func  (this *BlockchaincomCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var isAuthenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(isAuthenticated, nil)) {
                this.CheckRequiredCredentials()
                var request interface{} = map[string]interface{} {
                    "action": "subscribe",
                    "channel": "auth",
                    "token": this.Secret,
                }
        
                ch <- this.Watch(url, messageHash, this.Extend(request, params), messageHash)
                return nil
            }
        
                retRes78715 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes78715)
                ch <- retRes78715
                return nil
        
            }()
            return ch
        }


func (this *BlockchaincomCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
