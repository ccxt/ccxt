package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type AscendexCore struct {
	*ccxt.AscendexCore
	base *ccxt.AscendexCore
}

func NewAscendexCore() *AscendexCore {
    p := &AscendexCore{}
	base := &ccxt.AscendexCore{}
	p.base = base
	p.AscendexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *AscendexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": false,
            "watchTrades": true,
            "watchTradesForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ascendex.com:443/api/pro/v2/stream",
                    "private": "wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream",
                    "private": "wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "categoriesAccount": map[string]interface{} {
                "cash": "spot",
                "futures": "swap",
                "margin": "margin",
            },
        },
    })
}
func  (this *AscendexCore) WatchPublic(messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "id": ccxt.ToString(id),
                "op": "sub",
            }
            var message interface{} = this.Extend(request, params)
        
                retRes6015 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes6015)
                ch <- retRes6015
                return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) WatchPublicMultiple(messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "id": ccxt.ToString(id),
                "op": "sub",
            }
            var message interface{} = this.Extend(request, params)
        
                retRes7115 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes7115)
                ch <- retRes7115
                return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) WatchPrivate(channel interface{}, messageHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes758 := (<-this.LoadAccounts())
            ccxt.PanicOnError(retRes758)
            var accountGroup interface{} = this.SafeString(this.Options, "account-group")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            url = this.ImplodeParams(url, map[string]interface{} {
                "accountGroup": accountGroup,
            })
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "id": ccxt.ToString(id),
                "op": "sub",
                "ch": channel,
            }
            var message interface{} = this.Extend(request, params)
        
            retRes868 := (<-this.Authenticate(url, params))
            ccxt.PanicOnError(retRes868)
        
                retRes8715 :=  (<-this.Watch(url, messageHash, message, channel))
                ccxt.PanicOnError(retRes8715)
                ch <- retRes8715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-bar-data
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *AscendexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1038)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, nil))) || ccxt.IsTrue((ccxt.IsGreaterThan(limit, 1440)))) {
                limit = 100
            }
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("bar", ":"), interval), ":"), ccxt.GetValue(market, "id"))
            params = map[string]interface{} {
                "ch": channel,
            }
        
            ohlcv:= (<-this.WatchPublic(channel, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "m": "bar",
    //     "s": "ASD/USDT",
    //     "data": {
    //         "i":  "1",
    //         "ts": 1575398940000,
    //         "o":  "0.04993",
    //         "c":  "0.04970",
    //         "h":  "0.04993",
    //         "l":  "0.04970",
    //         "v":  "8052"
    //     }
    // }
    //
    var marketId interface{} = this.SafeString(message, "s")
    var symbol interface{} = this.SafeSymbol(marketId)
    var channel interface{} = this.SafeString(message, "m")
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var interval interface{} = this.SafeString(data, "i")
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channel, ":"), interval), ":"), marketId)
    var timeframe interface{} = this.FindTimeframe(interval)
    var market interface{} = this.Market(symbol)
    var parsed interface{} = this.ParseOHLCV(message, market)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
/**
 * @method
 * @name ascendex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-market-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *AscendexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes17015 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes17015)
                ch <- retRes17015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-market-trades
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *AscendexCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1868)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var marketIds interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&marketIds, ccxt.GetValue(market, "id"))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", ccxt.GetValue(market, "id")))
                }
            }
            var channel interface{} = ccxt.Add("trades:", ccxt.Join(marketIds, ","))
            params = this.Extend(params, map[string]interface{} {
                "ch": channel,
            })
        
            trades:= (<-this.WatchPublicMultiple(messageHashes, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     "m": "trades",
    //     "symbol": "BTC/USDT",
    //     "data": [
    //       {
    //         "p": "40744.28",
    //         "q": "0.00150",
    //         "ts": 1647514330758,
    //         "bm": true,
    //         "seqnum": 72057633465800320
    //       }
    //     ]
    // }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var channel interface{} = this.SafeString(message, "m")
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    var market interface{} = this.Market(symbol)
    var rawData interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(rawData, nil)) {
        rawData = []interface{}{}
    }
    var trades interface{} = this.ParseTrades(rawData, market)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        tradesArray.(ccxt.Appender).Append(ccxt.GetValue(trades, i))
    }
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name ascendex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-level-2-order-book-updates
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *AscendexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2598)
            var market interface{} = this.Market(symbol)
            var channel interface{} = ccxt.Add(ccxt.Add("depth", ":"), ccxt.GetValue(market, "id"))
            params = this.Extend(params, map[string]interface{} {
                "ch": channel,
            })
        
            orderbook:= (<-this.WatchPublic(channel, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) WatchOrderBookSnapshot(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2708)
            var market interface{} = this.Market(symbol)
            var action interface{} = "depth-snapshot"
            var channel interface{} = ccxt.Add(ccxt.Add(action, ":"), ccxt.GetValue(market, "id"))
            params = this.Extend(params, map[string]interface{} {
                "action": action,
                "args": map[string]interface{} {
                    "symbol": ccxt.GetValue(market, "id"),
                },
                "op": "req",
            })
        
            orderbook:= (<-this.WatchPublic(channel, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) FetchOrderBookSnapshotCustom(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            restOrderBook:= (<-this.FetchRestOrderBookSafe(symbol, limit, params))
            ccxt.PanicOnError(restOrderBook)
            if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
                ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
            }
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            orderbook.(ccxt.OrderBookInterface).Reset(restOrderBook)
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) HandleOrderBookSnapshot(client interface{}, message interface{})  {
    //
    // {
    //     "m": "depth",
    //     "symbol": "BTC/USDT",
    //     "data": {
    //       "ts": 1647520500149,
    //       "seqnum": 28590487626,
    //       "asks": [
    //         [Array], [Array], [Array],
    //         [Array], [Array], [Array],
    //       ],
    //       "bids": [
    //         [Array], [Array], [Array],
    //         [Array], [Array], [Array],
    //       ]
    //     }
    //   }
    //
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var channel interface{} = this.SafeString(message, "m")
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var data interface{} = this.SafeValue(message, "data")
    var snapshot interface{} = this.ParseOrderBook(data, symbol)
    ccxt.AddElementToObject(snapshot, "nonce", this.SafeInteger(data, "seqnum"))
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    // unroll the accumulated deltas
    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
        var messageItem interface{} = ccxt.GetValue(messages, i)
        this.HandleOrderBookMessage(client, messageItem, orderbook)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *AscendexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //   {
    //       "m": "depth",
    //       "symbol": "BTC/USDT",
    //       "data": {
    //         "ts": 1647515136144,
    //         "seqnum": 28590470736,
    //         "asks": [ [Array], [Array] ],
    //         "bids": [ [Array], [Array], [Array], [Array], [Array], [Array] ]
    //       }
    //   }
    //
    var channel interface{} = this.SafeString(message, "m")
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderbook, "nonce"), nil)) {
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        this.HandleOrderBookMessage(client, message, orderbook)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *AscendexCore) HandleDelta(bookside interface{}, delta interface{})  {
    //
    // ["40990.47","0.01619"],
    //
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *AscendexCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *AscendexCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    //
    // {
    //     "m":"depth",
    //     "symbol":"BTC/USDT",
    //     "data":{
    //        "ts":1647527417715,
    //        "seqnum":28590257013,
    //        "asks":[
    //           ["40990.47","0.01619"],
    //           ["41021.21","0"],
    //           ["41031.59","0.06096"]
    //        ],
    //        "bids":[
    //           ["40990.46","0.76114"],
    //           ["40985.18","0"]
    //        ]
    //     }
    //  }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var seqNum interface{} = this.SafeInteger(data, "seqnum")
    if ccxt.IsTrue(ccxt.IsGreaterThan(seqNum, ccxt.GetValue(orderbook, "nonce"))) {
        var asks interface{} = this.SafeValue(data, "asks", []interface{}{})
        var bids interface{} = this.SafeValue(data, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "nonce", seqNum)
        var timestamp interface{} = this.SafeInteger(data, "ts")
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    return orderbook
}
/**
 * @method
 * @name ascendex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-order-and-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *AscendexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4218)
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var channel interface{} = nil
            var messageHash interface{} = nil
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin")))) {
                var accountCategories interface{} = this.SafeValue(this.Options, "accountCategories", map[string]interface{} {})
                var accountCategory interface{} = this.SafeString(accountCategories, typeVar, "cash") // cash, margin,
                accountCategory = ccxt.ToUpper(accountCategory)
                channel = ccxt.Add("order:", accountCategory) // order and balance share the same channel
                messageHash = ccxt.Add("balance:", typeVar)
            } else {
                channel = "futures-account-update"
                messageHash = "balance:swap"
            }
        
                retRes43515 :=  (<-this.WatchPrivate(channel, messageHash, query))
                ccxt.PanicOnError(retRes43515)
                ch <- retRes43515
                return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) HandleBalance(client interface{}, message interface{})  {
    //
    // cash account
    //
    // {
    //     "m": "balance",
    //     "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqEo",
    //     "ac": "CASH",
    //     "data": {
    //         "a" : "USDT",
    //         "sn": 8159798,
    //         "tb": "600",
    //         "ab": "600"
    //     }
    // }
    //
    // margin account
    //
    // {
    //     "m": "balance",
    //     "accountId": "marOxpKJV83dxTRx0Eyxpa0gxc4Txt0P",
    //     "ac": "MARGIN",
    //     "data": {
    //         "a"  : "USDT",
    //         "sn" : 8159802,
    //         "tb" : "400", // total ccxt.Balance
    //         "ab" : "400", // available balance
    //         "brw": "0", // borrowws
    //         "int": "0" // interest
    //     }
    // }
    //
    // futures
    // {
    //     "m"     : "futures-account-update",            // message
    //     "e"     : "ExecutionReport",                   // event type
    //     "t"     : 1612508562129,                       // time
    //     "acc"   : "futures-account-id",         // account ID
    //     "at"    : "FUTURES",                           // account type
    //     "sn"    : 23128,                               // sequence number,
    //     "id"    : "r177710001cbU3813942147C5kbFGOan",
    //     "col": [
    //       {
    //         "a": "USDT",               // asset code
    //         "b": "1000000",            // balance
    //         "f": "1"                   // discount factor
    //       }
    //     ],
    //     (...)
    //
    var channel interface{} = this.SafeString(message, "m")
    var result interface{} = nil
    var typeVar interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(channel, "order"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "futures-order")))) {
        var data interface{} = this.SafeValue(message, "data")
        var marketId interface{} = this.SafeString(data, "s")
        var market interface{} = this.SafeMarket(marketId)
        var baseAccount interface{} = this.Account()
        ccxt.AddElementToObject(baseAccount, "free", this.SafeString(data, "bab"))
        ccxt.AddElementToObject(baseAccount, "total", this.SafeString(data, "btb"))
        var quoteAccount interface{} = this.Account()
        ccxt.AddElementToObject(quoteAccount, "free", this.SafeString(data, "qab"))
        ccxt.AddElementToObject(quoteAccount, "total", this.SafeString(data, "qtb"))
        if ccxt.IsTrue(ccxt.GetValue(market, "contract")) {
            typeVar = "swap"
            result = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
        } else {
            typeVar = ccxt.GetValue(market, "type")
            result = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
        }
        ccxt.AddElementToObject(result, ccxt.GetValue(market, "base"), baseAccount)
        ccxt.AddElementToObject(result, ccxt.GetValue(market, "quote"), quoteAccount)
    } else {
        var accountType interface{} = this.SafeStringLower2(message, "ac", "at")
        var categoriesAccounts interface{} = this.SafeValue(this.Options, "categoriesAccount")
        typeVar = this.SafeString(categoriesAccounts, accountType, "spot")
        result = this.SafeValue(this.Balance, typeVar, map[string]interface{} {})
        var data interface{} = this.SafeValue(message, "data")
        var balances interface{} = nil
        if ccxt.IsTrue(ccxt.IsEqual(data, nil)) {
            balances = this.SafeValue(message, "col")
        } else {
            balances = []interface{}{data}
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
            var balance interface{} = ccxt.GetValue(balances, i)
            var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "a"))
            var account interface{} = this.Account()
            ccxt.AddElementToObject(account, "free", this.SafeString(balance, "ab"))
            ccxt.AddElementToObject(account, "total", this.SafeString2(balance, "tb", "b"))
            ccxt.AddElementToObject(result, code, account)
        }
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("balance", ":"), typeVar)
    client.(ccxt.ClientInterface).Resolve(this.SafeBalance(result), messageHash)
}
/**
 * @method
 * @name ascendex#watchOrders
 * @see https://ascendex.github.io/ascendex-pro-api/#channel-order-and-balance
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *AscendexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5478 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5478)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var messageHash interface{} = nil
            var channel interface{} = nil
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "margin"))) {
                channel = "futures-order"
                messageHash = "order:FUTURES"
            } else {
                var accountCategories interface{} = this.SafeValue(this.Options, "accountCategories", map[string]interface{} {})
                var accountCategory interface{} = this.SafeString(accountCategories, typeVar, "cash") // cash, margin
                accountCategory = ccxt.ToUpper(accountCategory)
                messageHash = ccxt.Add(ccxt.Add("order", ":"), accountCategory)
                channel = messageHash
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.WatchPrivate(channel, messageHash, query))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *AscendexCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot order
    // {
    //   "m": "order",
    //   "accountId": "cshF5SlR9ukAXoDOuXbND4dVpBMw9gzH",
    //   "ac": "CASH",
    //   "data": {
    //     "sn": 19399016185,
    //     "orderId": "r17f9d7983faU7223046196CMlrj3bfC",
    //     "s": "LTC/USDT",
    //     "ot": "Limit",
    //     "t": 1647614461160,
    //     "p": "50",
    //     "q": "0.1",
    //     "sd": "Buy",
    //     "st": "New",
    //     "ap": "0",
    //     "cfq": "0",
    //     "sp": '',
    //     "err": '',
    //     "btb": "0",
    //     "bab": "0",
    //     "qtb": "8",
    //     "qab": "2.995",
    //     "cf": "0",
    //     "fa": "USDT",
    //     "ei": "NULL_VAL"
    //   }
    // }
    //
    //  futures order
    // {
    //     "m": "futures-order",
    //     "sn": 19399927636,
    //     "e": "ExecutionReport",
    //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH", // account id
    //     "ac": "FUTURES",
    //     "t": 1647622515434, // last execution time
    //      (...)
    // }
    //
    var accountType interface{} = this.SafeString(message, "ac")
    var messageHash interface{} = ccxt.Add("order:", accountType)
    var data interface{} = this.SafeValue(message, "data", message)
    var order interface{} = this.ParseWsOrder(data)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(order)
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(order, "symbol"))
    client.(ccxt.ClientInterface).Resolve(orders, symbolMessageHash)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
func  (this *AscendexCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot order
    //    {
    //          "sn": 19399016185, //sequence number
    //          "orderId": "r17f9d7983faU7223046196CMlrj3bfC",
    //          "s": "LTC/USDT",
    //          "ot": "Limit", // order type
    //          "t": 1647614461160, // last execution timestamp
    //          "p": "50", // price
    //          "q": "0.1", // quantity
    //          "sd": "Buy", // side
    //          "st": "New", // status
    //          "ap": "0", // average fill price
    //          "cfq": "0", // cumulated fill quantity
    //          "sp": '', // stop price
    //          "err": '',
    //          "btb": "0", // base asset total balance
    //          "bab": "0", // base asset available balance
    //          "qtb": "8", // quote asset total balance
    //          "qab": "2.995", // quote asset available balance
    //          "cf": "0", // cumulated commission
    //          "fa": "USDT", // fee asset
    //          "ei": "NULL_VAL"
    //        }
    //
    //  futures order
    // {
    //     "m": "futures-order",
    //     "sn": 19399927636,
    //     "e": "ExecutionReport",
    //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH", // account id
    //     "ac": "FUTURES",
    //     "t": 1647622515434, // last execution time
    //     "ct": 1647622515413, // order creation time
    //     "orderId": "r17f9df469b1U7223046196Okf5Kbmd",
    //     "sd": "Buy", // side
    //     "ot": "Limit", // order type
    //     "ei": "NULL_VAL",
    //     "q": "1", // quantity
    //     "p": "50", //price
    //     "sp": "0", // stopPrice
    //     "spb": '',  // stopTrigger
    //     "s": "LTC-PERP", // symbol
    //     "st": "New", // state
    //     "err": '',
    //     "lp": "0", // last filled price
    //     "lq": "0", // last filled quantity (base asset)
    //     "ap": "0",  // average filled price
    //     "cfq": "0", // cummulative filled quantity (base asset)
    //     "f": "0", // commission fee of the current execution
    //     "cf": "0", // cumulative commission fee
    //     "fa": "USDT", // fee asset
    //     "psl": "0",
    //     "pslt": "market",
    //     "ptp": "0",
    //     "ptpt": "market"
    //   }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "st"))
    var marketId interface{} = this.SafeString(order, "s")
    var timestamp interface{} = this.SafeInteger(order, "t")
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var lastTradeTimestamp interface{} = this.SafeInteger(order, "t")
    var price interface{} = this.SafeString(order, "p")
    var amount interface{} = this.SafeString(order, "q")
    var average interface{} = this.SafeString(order, "ap")
    var filled interface{} = this.SafeString(order, "cfq")
    var id interface{} = this.SafeString(order, "orderId")
    var typeVar interface{} = this.SafeStringLower(order, "ot")
    var side interface{} = this.SafeStringLower(order, "sd")
    var feeCost interface{} = this.SafeNumber(order, "cf")
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(order, "fa")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var stopPrice interface{} = this.ParseNumber(this.OmitZero(this.SafeString(order, "sp")))
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": amount,
        "cost": nil,
        "average": average,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
func  (this *AscendexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "m": "disconnected",
    //     "code": 100005,
    //     "reason": "INVALID_WS_REQUEST_DATA",
    //     "info": "Session is disconnected due to missing pong message from the client"
    //   }
    //
    var errorCode interface{} = this.SafeInteger(message, "code")
    
        {
            ret__ := func(this *AscendexCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *AscendexCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(e, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(e)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                var messageString interface{} = this.SafeValue(message, "message")
                if ccxt.IsTrue(!ccxt.IsEqual(messageString, nil)) {
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                }
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *AscendexCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //     { m: "auth", id: "1647605234", code: 0 }
    //
    var messageHash interface{} = "authenticated"
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
}
func  (this *AscendexCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     { m: "ping", hp: 3 }
    //
    //     { m: "sub", ch: "bar:BTC/USDT", code: 0 }
    //
    //     { m: 'sub', id: "1647515701", ch: "depth:BTC/USDT", code: 0 }
    //
    //     { m: "connected", type: "unauth" }
    //
    //     { m: "auth", id: "1647605234", code: 0 }
    //
    // order or balance sub
    // {
    //     "m": "sub",
    //     "id": "1647605952",
    //     "ch": "order:cshF5SlR9ukAXoDOuXbND4dVpBMw9gzH", or futures-order
    //     "code": 0
    //   }
    //
    // ohlcv
    //  {
    //     "m": "bar",
    //     "s": "BTC/USDT",
    //     "data": {
    //       "i": "1",
    //       "ts": 1647510060000,
    //       "o": "40813.93",
    //       "c": "40804.57",
    //       "h": "40814.21",
    //       "l": "40804.56",
    //       "v": "0.01537"
    //     }
    //   }
    //
    // trades
    //
    //    {
    //        "m": "trades",
    //        "symbol": "BTC/USDT",
    //        "data": [
    //          {
    //            "p": "40762.26",
    //            "q": "0.01500",
    //            "ts": 1647514306759,
    //            "bm": true,
    //            "seqnum": 72057633465795180
    //          }
    //        ]
    //    }
    //
    // orderbook deltas
    //
    // {
    //     "m":"depth",
    //     "symbol":"BTC/USDT",
    //     "data":{
    //        "ts":1647527417715,
    //        "seqnum":28590257013,
    //        "asks":[
    //           ["40990.47","0.01619"],
    //           ["41021.21","0"],
    //           ["41031.59","0.06096"]
    //        ],
    //        "bids":[
    //           ["40990.46","0.76114"],
    //           ["40985.18","0"]
    //        ]
    //     }
    //  }
    //
    // orderbook snapshot
    //  {
    //     "m": "depth-snapshot",
    //     "symbol": "BTC/USDT",
    //     "data": {
    //       "ts": 1647525938513,
    //       "seqnum": 28590504772,
    //       "asks": [
    //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
    //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
    //         [Array], [Array], [Array], [Array], [Array], [Array], [Array],
    //          (...)
    //       ]
    //  }
    //
    // spot order update
    //  {
    //      "m": "order",
    //      "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
    //      "ac": "CASH",
    //      "data": {
    //          "s":       "BTC/USDT",
    //          "sn":       8159711,
    //          "sd":      "Buy",
    //          "ap":      "0",
    //          "bab":     "2006.5974027",
    //          "btb":     "2006.5974027",
    //          "cf":      "0",
    //          "cfq":     "0",
    //          (...)
    //      }
    //  }
    // future order update
    // {
    //     "m": "futures-order",
    //     "sn": 19404258063,
    //     "e": "ExecutionReport",
    //     "a": "futF5SlR9ukAXoDOuXbND4dVpBMw9gzH",
    //     "ac": "FUTURES",
    //     "t": 1647681792543,
    //     "ct": 1647622515413,
    //     "orderId": "r17f9df469b1U7223046196Okf5KbmdL",
    //         (...)
    //     "ptpt": "None"
    //   }
    //
    // balance update cash
    // {
    //     "m": "balance",
    //     "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
    //     "ac": "CASH",
    //     "data": {
    //         "a" : "USDT",
    //         "sn": 8159798,
    //         "tb": "600",
    //         "ab": "600"
    //     }
    // }
    //
    // balance update margin
    // {
    //     "m": "balance",
    //     "accountId": "marOxpKJV83dxTRx0Eyxpa0gxc4Txt0P",
    //     "ac": "MARGIN",
    //     "data": {
    //         "a"  : "USDT",
    //         "sn" : 8159802,
    //         "tb" : "400",
    //         "ab" : "400",
    //         "brw": "0",
    //         "int": "0"
    //     }
    // }
    //
    var subject interface{} = this.SafeString(message, "m")
    var methods interface{} = map[string]interface{} {
        "ping": this.HandlePing,
        "auth": this.HandleAuthenticate,
        "sub": this.HandleSubscriptionStatus,
        "depth": this.HandleOrderBook,
        "depth-snapshot": this.HandleOrderBookSnapshot,
        "trades": this.HandleTrades,
        "bar": this.HandleOHLCV,
        "balance": this.HandleBalance,
        "futures-account-update": this.HandleBalance,
    }
    var method interface{} = this.SafeValue(methods, subject)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subject, "order"))) || ccxt.IsTrue((ccxt.IsEqual(subject, "futures-order")))) {
        // this.handleOrder (client, message)
        // balance updates may be in the order structure
        // they may also be standalone balance updates related to account transfers
        this.HandleOrder(client, message)
        if ccxt.IsTrue(ccxt.IsEqual(subject, "order")) {
            this.HandleBalance(client, message)
        }
    }
}
func  (this *AscendexCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     { m: "sub", ch: "bar:BTC/USDT", code: 0 }
    //
    //     { m: 'sub', id: "1647515701", ch: "depth:BTC/USDT", code: 0 }
    //
    var channel interface{} = this.SafeString(message, "ch", "")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "depth"), ccxt.OpNeg(1))) && !ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(channel, "depth-snapshot"), ccxt.OpNeg(1))))) {
        this.HandleOrderBookSubscription(client, message)
    }
    return message
}
func  (this *AscendexCore) HandleOrderBookSubscription(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "ch")
    var parts interface{} = ccxt.Split(channel, ":")
    var marketId interface{} = ccxt.GetValue(parts, 1)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(this.Options, "defaultType"), "swap")) || ccxt.IsTrue(ccxt.GetValue(market, "contract"))) {
        this.Spawn(this.FetchOrderBookSnapshotCustom, symbol)
    } else {
        this.Spawn(this.WatchOrderBookSnapshot, symbol)
    }
}
func  (this *AscendexCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    
                {
                     func(this *AscendexCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *AscendexCore) interface{} {
                                    // catch block:
                                            error := ccxt.NetworkError(ccxt.Add(ccxt.Add(this.Id, " handlePing failed with error "), this.Json(e)))
                    client.(ccxt.ClientInterface).Reset(error)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes99312 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                        "op": "pong",
                        "hp": this.SafeInteger(message, "hp"),
                    }))
                    ccxt.PanicOnError(retRes99312)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *AscendexCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *AscendexCore) Authenticate(url interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                var timestamp interface{} = ccxt.ToString(this.Milliseconds())
                var urlParts interface{} = ccxt.Split(url, "/")
                var partsLength interface{} =         ccxt.GetArrayLength(urlParts)
                var path interface{} = this.SafeString(urlParts, ccxt.Subtract(partsLength, 1))
                var version interface{} = this.SafeString(urlParts, ccxt.Subtract(partsLength, 2))
                var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(timestamp, "+"), version), "/"), path)
                var secret interface{} = this.Base64ToBinary(this.Secret)
                var signature interface{} = this.Hmac(this.Encode(auth), secret, ccxt.Sha256, "base64")
                var request interface{} = map[string]interface{} {
                    "op": "auth",
                    "id": ccxt.ToString(this.Nonce()),
                    "t": timestamp,
                    "key": this.ApiKey,
                    "sig": signature,
                }
                
            future = (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }


func (this *AscendexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
