package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ExmoCore struct {
	*ccxt.ExmoCore
	base *ccxt.ExmoCore
}

func NewExmoCore() *ExmoCore {
    p := &ExmoCore{}
	base := &ccxt.ExmoCore{}
	p.base = base
	p.ExmoCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ExmoCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws-api.exmo.com:443/v1/public",
                    "spot": "wss://ws-api.exmo.com:443/v1/private",
                    "margin": "wss://ws-api.exmo.com:443/v1/margin/private",
                },
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *ExmoCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
/**
 * @method
 * @name exmo#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ExmoCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes588 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes588)
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var messageHash interface{} = ccxt.Add("balance:", typeVar)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": []interface{}{ccxt.Add(typeVar, "/wallet")},
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(subscribe, query)
        
                retRes6815 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes6815)
                ch <- retRes6815
                return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleBalance(client interface{}, message interface{})  {
    //
    //  spot
    //     {
    //         "ts": 1654208766007,
    //         "event": "snapshot",
    //         "topic": "spot/wallet",
    //         "data": {
    //             "balances": {
    //                 "ADA": "0",
    //                 "ALGO": "0",
    //                 ...
    //             },
    //             "reserved": {
    //                 "ADA": "0",
    //                 "ALGO": "0",
    //                 ...
    //             }
    //         }
    //     }
    //
    //  margin
    //     {
    //         "ts": 1624370076651,
    //         "event": "snapshot",
    //         "topic": "margin/wallets",
    //         "data": {
    //             "RUB": {
    //                 "balance": "1000000",
    //                 "used": "0",
    //                 "free": "1000000"
    //             },
    //             "USD": {
    //                 "balance": "1000000",
    //                 "used": "1831.925",
    //                 "free": "998168.075"
    //             }
    //         }
    //     }
    //     {
    //         "ts": 1624370185720,
    //         "event": "update",
    //         "topic": "margin/wallets",
    //         "data": {
    //             "USD": {
    //                 "balance": "1000123",
    //                 "used": "1831.925",
    //                 "free": "998291.075"
    //             }
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, "/")
    var typeVar interface{} = this.SafeString(parts, 0)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        this.ParseSpotBalance(message)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) {
        this.ParseMarginBalance(message)
    }
    var messageHash interface{} = ccxt.Add("balance:", typeVar)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *ExmoCore) ParseSpotBalance(message interface{})  {
    //
    //     {
    //         "balances": {
    //             "BTC": "3",
    //             "USD": "1000",
    //             "RUB": "0"
    //         },
    //         "reserved": {
    //             "BTC": "0.5",
    //             "DASH": "0",
    //             "RUB": "0"
    //         }
    //     }
    //
    var event interface{} = this.SafeString(message, "event")
    var data interface{} = this.SafeValue(message, "data")
    ccxt.AddElementToObject(this.Balance, "info", data)
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        var balances interface{} = this.SafeValue(data, "balances", map[string]interface{} {})
        var reserved interface{} = this.SafeValue(data, "reserved", map[string]interface{} {})
        var currencies interface{} = ccxt.ObjectKeys(balances)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencies)); i++ {
            var currencyId interface{} = ccxt.GetValue(currencies, i)
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            ccxt.AddElementToObject(account, "free", this.SafeString(balances, currencyId))
            ccxt.AddElementToObject(account, "used", this.SafeString(reserved, currencyId))
            ccxt.AddElementToObject(this.Balance, code, account)
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "update")) {
        var currencyId interface{} = this.SafeString(data, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(data, "balance"))
        ccxt.AddElementToObject(account, "used", this.SafeString(data, "reserved"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
}
func  (this *ExmoCore) ParseMarginBalance(message interface{})  {
    //
    //     {
    //         "RUB": {
    //             "balance": "1000000",
    //             "used": "0",
    //             "free": "1000000"
    //         },
    //         "USD": {
    //             "balance": "1000000",
    //             "used": "1831.925",
    //             "free": "998168.075"
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data")
    ccxt.AddElementToObject(this.Balance, "info", data)
    var currencies interface{} = ccxt.ObjectKeys(data)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencies)); i++ {
        var currencyId interface{} = ccxt.GetValue(currencies, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var wallet interface{} = this.SafeValue(data, currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(wallet, "free"))
        ccxt.AddElementToObject(account, "used", this.SafeString(wallet, "used"))
        ccxt.AddElementToObject(account, "total", this.SafeString(wallet, "balance"))
        ccxt.AddElementToObject(this.Balance, code, account)
        this.Balance = this.SafeBalance(this.Balance)
    }
}
/**
 * @method
 * @name exmo#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#fd8f47bc-8517-43c0-bb60-1d61a86d4471
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ExmoCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2178)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var message interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": []interface{}{ccxt.Add("spot/ticker:", ccxt.GetValue(market, "id"))},
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes23015 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes23015)
                ch <- retRes23015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name exmo#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#fd8f47bc-8517-43c0-bb60-1d61a86d4471
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ExmoCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2438)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&args, ccxt.Add("spot/ticker:", ccxt.GetValue(market, "id")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var message interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": args,
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            retRes2598 := (<-this.WatchMultiple(url, messageHashes, request, messageHashes, request))
            ccxt.PanicOnError(retRes2598)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleTicker(client interface{}, message interface{})  {
    //
    //  spot
    //      {
    //          "ts": 1654205085473,
    //          "event": "update",
    //          "topic": "spot/ticker:BTC_USDT",
    //          "data": {
    //              "buy_price": "30285.84",
    //              "sell_price": "30299.97",
    //              "last_trade": "30295.01",
    //              "high": "30386.7",
    //              "low": "29542.76",
    //              "avg": "29974.16178449",
    //              "vol": "118.79538518",
    //              "vol_curr": "3598907.38200826",
    //              "updated": 1654205084
    //          }
    //      }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var topicParts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = this.SafeString(topicParts, 1)
    var symbol interface{} = this.SafeSymbol(marketId)
    var ticker interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var market interface{} = this.SafeMarket(marketId)
    var parsedTicker interface{} = this.ParseTicker(ticker, market)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
/**
 * @method
 * @name exmo#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ExmoCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3068)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var messageHash interface{} = ccxt.Add("trades:", symbol)
            var message interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": []interface{}{ccxt.Add("spot/trades:", ccxt.GetValue(market, "id"))},
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleTrades(client interface{}, message interface{})  {
    //
    //      {
    //          "ts": 1654206084001,
    //          "event": "update",
    //          "topic": "spot/trades:BTC_USDT",
    //          "data": [{
    //              "trade_id": 389704729,
    //              "type": "sell",
    //              "price": "30310.95",
    //              "quantity": "0.0197",
    //              "amount": "597.125715",
    //              "date": 1654206083
    //          }]
    //      }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = this.SafeString(parts, 1)
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var trades interface{} = this.SafeValue(message, "data", []interface{}{})
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = ccxt.GetValue(trades, i)
        var parsed interface{} = this.ParseTrade(trade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
/**
 * @method
 * @name exmo#watchMyTrades
 * @description get the list of trades associated with the user
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ExmoCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3728)
        
            retRes3738 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes3738)
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchMyTrades", nil, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var messageHash interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add("myTrades:", typeVar)
            } else {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add("myTrades:", ccxt.GetValue(market, "symbol"))
            }
            var message interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": []interface{}{ccxt.Add(typeVar, "/user_trades")},
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, query)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //  spot
    //     {
    //         "ts": 1654210290219,
    //         "event": "update",
    //         "topic": "spot/user_trades",
    //         "data": {
    //             "trade_id": 389715807,
    //             "type": "buy",
    //             "price": "30527.77",
    //             "quantity": "0.0001",
    //             "amount": "3.052777",
    //             "date": 1654210290,
    //             "order_id": 27352777112,
    //             "client_id": 0,
    //             "pair": "BTC_USDT",
    //             "exec_type": "taker",
    //             "commission_amount": "0.0000001",
    //             "commission_currency": "BTC",
    //             "commission_percent": "0.1"
    //         }
    //     }
    //
    //  margin
    //     {
    //         "ts":1624369720168,
    //         "event":"snapshot",
    //         "topic":"margin/user_trades",
    //         "data":[
    //            {
    //               "trade_id":"692844278081167054",
    //               "trade_dt":"1624369773990729200",
    //               "type":"buy",
    //               "order_id":"692844278081167033",
    //               "pair":"BTC_USD",
    //               "quantity":"0.1",
    //               "price":"36638.5",
    //               "is_maker":false
    //            }
    //         ]
    //     }
    //     {
    //         "ts":1624370368612,
    //         "event":"update",
    //         "topic":"margin/user_trades",
    //         "data":{
    //            "trade_id":"692844278081167693",
    //            "trade_dt":"1624370368569092500",
    //            "type":"buy",
    //            "order_id":"692844278081167674",
    //            "pair":"BTC_USD",
    //            "quantity":"0.1",
    //            "price":"36638.5",
    //            "is_maker":false
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, "/")
    var typeVar interface{} = this.SafeString(parts, 0)
    var messageHash interface{} = ccxt.Add("myTrades:", typeVar)
    var event interface{} = this.SafeString(message, "event")
    var rawTrades interface{} = []interface{}{}
    var myTrades interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = myTrades
    } else {
        myTrades = this.MyTrades
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        rawTrades = this.SafeValue(message, "data", []interface{}{})
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "update")) {
        var rawTrade interface{} = this.SafeValue(message, "data", map[string]interface{} {})
        rawTrades = []interface{}{rawTrade}
    }
    var trades interface{} = this.ParseTrades(rawTrades)
    var symbols interface{} = map[string]interface{} {}
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        var trade interface{} = ccxt.GetValue(trades, j)
        myTrades.(ccxt.Appender).Append(trade)
        ccxt.AddElementToObject(symbols, ccxt.GetValue(trade, "symbol"), true)
    }
    var symbolKeys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolKeys)); i++ {
        var symbol interface{} = ccxt.GetValue(symbolKeys, i)
        var symbolSpecificMessageHash interface{} = ccxt.Add("myTrades:", symbol)
        client.(ccxt.ClientInterface).Resolve(myTrades, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
}
/**
 * @method
 * @name exmo#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ExmoCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5008 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5008)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var messageHash interface{} = ccxt.Add("orderbook:", symbol)
            params = this.Omit(params, "aggregation")
            var subscribe interface{} = map[string]interface{} {
                "method": "subscribe",
                "id": this.RequestId(),
                "topics": []interface{}{ccxt.Add("spot/order_book_updates:", ccxt.GetValue(market, "id"))},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orderbook:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "ts": 1574427585174,
    //         "event": "snapshot",
    //         "topic": "spot/order_book_updates:BTC_USD",
    //         "data": {
    //             "ask": [
    //                 ["100", "3", "300"],
    //                 ["200", "4", "800"]
    //             ],
    //             "bid": [
    //                 ["99", "2", "198"],
    //                 ["98", "1", "98"]
    //             ]
    //         }
    //     }
    //
    //     {
    //         "ts": 1574427585174,
    //         "event": "update",
    //         "topic": "spot/order_book_updates:BTC_USD",
    //         "data": {
    //             "ask": [
    //                 ["100", "1", "100"],
    //                 ["200", "2", "400"]
    //             ],
    //             "bid": [
    //                 ["99", "1", "99"],
    //                 ["98", "0", "0"]
    //             ]
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, ":")
    var marketId interface{} = this.SafeString(parts, 1)
    var symbol interface{} = this.SafeSymbol(marketId)
    var orderBook interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var timestamp interface{} = this.SafeInteger(message, "ts")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        var snapshot interface{} = this.ParseOrderBook(orderBook, symbol, timestamp, "bid", "ask")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeList(orderBook, "ask", []interface{}{})
        var bids interface{} = this.SafeList(orderBook, "bid", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *ExmoCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *ExmoCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name exmo#watchOrders
 * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#85f7bc03-b1c9-4cd2-bd22-8fd422272825
 * @see https://documenter.getpostman.com/view/10287440/SzYXWKPi#95e4ed18-1791-4e6d-83ad-cbfe9be1051c
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ExmoCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6028)
        
            retRes6038 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes6038)
            typeVarqueryVariable := this.HandleMarketTypeAndParams("watchOrders", nil, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var messageHash interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add("orders:", typeVar)
            } else {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add("orders:", ccxt.GetValue(market, "symbol"))
            }
            var message interface{} = map[string]interface{} {
                "method": "subscribe",
                "topics": []interface{}{ccxt.Add(typeVar, "/orders")},
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, query)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ExmoCore) HandleOrders(client interface{}, message interface{})  {
    //
    //  spot
    // {
    //     "ts": 1574427585174,
    //     "event": "snapshot",
    //     "topic": "spot/orders",
    //     "data": [
    //       {
    //         "order_id": "14",
    //         "client_id":"100500",
    //         "created": "1574427585",
    //         "pair": "BTC_USD",
    //         "price": "7750",
    //         "quantity": "0.1",
    //         "amount": "775",
    //         "original_quantity": "0.1",
    //         "original_amount": "775",
    //         "type": "sell",
    //         "status": "open"
    //       }
    //     ]
    // }
    //
    //  margin
    // {
    //     "ts":1624371281773,
    //     "event":"snapshot",
    //     "topic":"margin/orders",
    //     "data":[
    //        {
    //           "order_id":"692844278081168665",
    //           "created":"1624371250919761600",
    //           "type":"limit_buy",
    //           "previous_type":"limit_buy",
    //           "pair":"BTC_USD",
    //           "leverage":"2",
    //           "price":"10000",
    //           "stop_price":"0",
    //           "distance":"0",
    //           "trigger_price":"10000",
    //           "init_quantity":"0.1",
    //           "quantity":"0.1",
    //           "funding_currency":"USD",
    //           "funding_quantity":"1000",
    //           "funding_rate":"0",
    //           "client_id":"111111",
    //           "expire":0,
    //           "src":1,
    //           "comment":"comment1",
    //           "updated":1624371250938136600,
    //           "status":"active"
    //        }
    //     ]
    // }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var parts interface{} = ccxt.Split(topic, "/")
    var typeVar interface{} = this.SafeString(parts, 0)
    var messageHash interface{} = ccxt.Add("orders:", typeVar)
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedOrders interface{} = this.Orders
    var rawOrders interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(event, "snapshot")) {
        rawOrders = this.SafeValue(message, "data", []interface{}{})
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "update")) {
        var rawOrder interface{} = this.SafeDict(message, "data", map[string]interface{} {})
        ccxt.AppendToArray(&rawOrders, rawOrder)
    }
    var symbols interface{} = map[string]interface{} {}
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(rawOrders)); j++ {
        var order interface{} = this.ParseWsOrder(ccxt.GetValue(rawOrders, j))
        cachedOrders.(ccxt.Appender).Append(order)
        ccxt.AddElementToObject(symbols, ccxt.GetValue(order, "symbol"), true)
    }
    var symbolKeys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolKeys)); i++ {
        var symbol interface{} = ccxt.GetValue(symbolKeys, i)
        var symbolSpecificMessageHash interface{} = ccxt.Add("orders:", symbol)
        client.(ccxt.ClientInterface).Resolve(cachedOrders, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(cachedOrders, messageHash)
}
func  (this *ExmoCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     order_id: '43226756791',
    //     client_id: 0,
    //     created: '1730371416',
    //     type: 'market_buy',
    //     pair: 'TRX_USD',
    //     quantity: '0',
    //     original_quantity: '30',
    //     status: 'cancelled',
    //     last_trade_id: '726480870',
    //     last_trade_price: '0.17',
    //     last_trade_quantity: '30'
    // }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var timestamp interface{} = this.SafeTimestamp(order, "created")
    var orderType interface{} = this.SafeString(order, "type")
    var side interface{} = this.ParseSide(orderType)
    var marketId interface{} = this.SafeString(order, "pair")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var amount interface{} = this.SafeString(order, "quantity")
    if ccxt.IsTrue(ccxt.IsEqual(amount, nil)) {
        var amountField interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "buy"))), "in_amount", "out_amount")
        amount = this.SafeString(order, amountField)
    }
    var price interface{} = this.SafeString(order, "price")
    var clientOrderId interface{} = this.OmitZero(this.SafeString(order, "client_id"))
    var triggerPrice interface{} = this.OmitZero(this.SafeString(order, "stop_price"))
    var typeVar interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(orderType, "buy"))) && ccxt.IsTrue((!ccxt.IsEqual(orderType, "sell")))) {
        typeVar = orderType
    }
    var trades interface{} = nil
    if ccxt.IsTrue(ccxt.InOp(order, "last_trade_id")) {
        var trade interface{} = this.ParseWsTrade(order, market)
        trades = []interface{}{trade}
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "status": this.ParseStatus(this.SafeString(order, "status")),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "cost": nil,
        "amount": this.SafeString(order, "original_quantity"),
        "filled": nil,
        "remaining": this.SafeString(order, "quantity"),
        "average": nil,
        "trades": trades,
        "fee": nil,
        "info": order,
    }, market)
}
func  (this *ExmoCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "order_id")
    var orderType interface{} = this.SafeString(trade, "type")
    var side interface{} = this.ParseSide(orderType)
    var marketId interface{} = this.SafeString(trade, "pair")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var typeVar interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(orderType, "buy"))) && ccxt.IsTrue((!ccxt.IsEqual(orderType, "sell")))) {
        typeVar = orderType
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "last_trade_id"),
        "symbol": symbol,
        "order": id,
        "type": typeVar,
        "side": side,
        "price": this.SafeString(trade, "last_trade_price"),
        "amount": this.SafeString(trade, "last_trade_quantity"),
        "cost": nil,
        "fee": nil,
    }, market)
}
func  (this *ExmoCore) HandleMessage(client interface{}, message interface{})  {
    //
    // {
    //     "ts": 1654206362552,
    //     "event": "info",
    //     "code": 1,
    //     "message": "connection established",
    //     "session_id": "7548931b-c2a4-45dd-8d71-877881a7251a"
    // }
    //
    // {
    //     "ts": 1654206491399,
    //     "event": "subscribed",
    //     "id": 1,
    //     "topic": "spot/ticker:BTC_USDT"
    // }
    var event interface{} = this.SafeString(message, "event")
    var events interface{} = map[string]interface{} {
        "logged_in": this.HandleAuthenticationMessage,
        "info": this.HandleInfo,
        "subscribed": this.HandleSubscribed,
    }
    var eventHandler interface{} = this.SafeValue(events, event)
    if ccxt.IsTrue(!ccxt.IsEqual(eventHandler, nil)) {
        ccxt.CallDynamically(eventHandler, client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(event, "update"))) || ccxt.IsTrue((ccxt.IsEqual(event, "snapshot")))) {
        var topic interface{} = this.SafeString(message, "topic")
        if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
            var parts interface{} = ccxt.Split(topic, ":")
            var channel interface{} = this.SafeString(parts, 0)
            var handlers interface{} = map[string]interface{} {
                "spot/ticker": this.HandleTicker,
                "spot/wallet": this.HandleBalance,
                "margin/wallet": this.HandleBalance,
                "margin/wallets": this.HandleBalance,
                "spot/trades": this.HandleTrades,
                "margin/trades": this.HandleTrades,
                "spot/order_book_updates": this.HandleOrderBook,
                "spot/orders": this.HandleOrders,
                "margin/orders": this.HandleOrders,
                "spot/user_trades": this.HandleMyTrades,
                "margin/user_trades": this.HandleMyTrades,
            }
            var handler interface{} = this.SafeValue(handlers, channel)
            if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
                ccxt.CallDynamically(handler, client, message)
                return
            }
        }
    }
    panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " received an unsupported message: "), this.Json(message))))
}
func  (this *ExmoCore) HandleSubscribed(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "method": "subscribe",
    //     "id": 2,
    //     "topics": ["spot/orders"]
    // }
    //
    return message
}
func  (this *ExmoCore) HandleInfo(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "ts": 1654215731659,
    //     "event": "info",
    //     "code": 1,
    //     "message": "connection established",
    //     "session_id": "4c496262-e259-4c27-b805-f20b46209c17"
    // }
    //
    return message
}
func  (this *ExmoCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "login",
    //         "id": 1,
    //         "api_key": "K-************************",
    //         "sign": "******************************************************************",
    //         "nonce": 1654215729887
    //     }
    //
    var messageHash interface{} = "authenticated"
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
}
func  (this *ExmoCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "authenticated"
            typeVarqueryVariable := this.HandleMarketTypeAndParams("authenticate", nil, params)
            typeVar := ccxt.GetValue(typeVarqueryVariable,0)
            query := ccxt.GetValue(typeVarqueryVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var client interface{} = this.Client(url)
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                var time interface{} = this.Milliseconds()
                this.CheckRequiredCredentials()
                var requestId interface{} = this.RequestId()
                var signData interface{} = ccxt.Add(this.ApiKey, ccxt.ToString(time))
                var sign interface{} = this.Hmac(this.Encode(signData), this.Encode(this.Secret), ccxt.Sha512, "base64")
                var request interface{} = map[string]interface{} {
                    "method": "login",
                    "id": requestId,
                    "api_key": this.ApiKey,
                    "sign": sign,
                    "nonce": time,
                }
                var message interface{} = this.Extend(request, query)
                
            future = (<-this.Watch(url, messageHash, message, messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }


func (this *ExmoCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
