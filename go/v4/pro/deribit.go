package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DeribitCore struct {
	*ccxt.DeribitCore
	base *ccxt.DeribitCore
}

func NewDeribitCore() *DeribitCore {
    p := &DeribitCore{}
	base := &ccxt.DeribitCore{}
	p.base = base
	p.DeribitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *DeribitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": "wss://test.deribit.com/ws/api/v2",
            },
            "api": map[string]interface{} {
                "ws": "wss://www.deribit.com/ws/api/v2",
            },
        },
        "options": map[string]interface{} {
            "ws": map[string]interface{} {
                "timeframes": map[string]interface{} {
                    "1m": "1",
                    "3m": "3",
                    "5m": "5",
                    "15m": "15",
                    "30m": "30",
                    "1h": "60",
                    "2h": "120",
                    "4h": "180",
                    "6h": "360",
                    "12h": "720",
                    "1d": "1D",
                },
                "watchTradesForSymbols": map[string]interface{} {
                    "interval": "100ms",
                },
                "watchOrderBookForSymbols": map[string]interface{} {
                    "interval": "100ms",
                    "useDepthEndpoint": false,
                    "depth": "20",
                    "group": "none",
                },
            },
            "currencies": []interface{}{"BTC", "ETH", "SOL", "USDC"},
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
func  (this *DeribitCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
/**
 * @method
 * @name deribit#watchBalance
 * @see https://docs.deribit.com/#user-portfolio-currency
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *DeribitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes888 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes888)
            var messageHash interface{} = "balance"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var currencies interface{} = this.SafeValue(this.Options, "currencies", []interface{}{})
            var channels interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencies)); i++ {
                var currencyCode interface{} = ccxt.GetValue(currencies, i)
                ccxt.AppendToArray(&channels, ccxt.Add("user.portfolio.", currencyCode))
            }
            var subscribe interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "private/subscribe",
                "params": map[string]interface{} {
                    "channels": channels,
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes10615 :=  (<-this.Watch(url, messageHash, request, messageHash, request))
                ccxt.PanicOnError(retRes10615)
                ch <- retRes10615
                return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleBalance(client interface{}, message interface{})  {
    //
    // subscription
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "user.portfolio.btc",
    //             "data": {
    //                 "total_pl": 0,
    //                 "session_upl": 0,
    //                 "session_rpl": 0,
    //                 "projected_maintenance_margin": 0,
    //                 "projected_initial_margin": 0,
    //                 "projected_delta_total": 0,
    //                 "portfolio_margining_enabled": false,
    //                 "options_vega": 0,
    //                 "options_value": 0,
    //                 "options_theta": 0,
    //                 "options_session_upl": 0,
    //                 "options_session_rpl": 0,
    //                 "options_pl": 0,
    //                 "options_gamma": 0,
    //                 "options_delta": 0,
    //                 "margin_balance": 0.0015,
    //                 "maintenance_margin": 0,
    //                 "initial_margin": 0,
    //                 "futures_session_upl": 0,
    //                 "futures_session_rpl": 0,
    //                 "futures_pl": 0,
    //                 "fee_balance": 0,
    //                 "estimated_liquidation_ratio_map": {},
    //                 "estimated_liquidation_ratio": 0,
    //                 "equity": 0.0015,
    //                 "delta_total_map": {},
    //                 "delta_total": 0,
    //                 "currency": "BTC",
    //                 "balance": 0.0015,
    //                 "available_withdrawal_funds": 0.0015,
    //                 "available_funds": 0.0015
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeValue(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeValue(params, "data", map[string]interface{} {})
    ccxt.AddElementToObject(this.Balance, "info", data)
    var currencyId interface{} = this.SafeString(data, "currency")
    var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
    var balance interface{} = this.ParseBalance(data)
    ccxt.AddElementToObject(this.Balance, currencyCode, balance)
    var messageHash interface{} = "balance"
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name deribit#watchTicker
 * @see https://docs.deribit.com/#ticker-instrument_name-interval
 * @description watches a price ticker, a statistical calculation with the information for a specific market.
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeribitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1758)
            var market interface{} = this.Market(symbol)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var interval interface{} = this.SafeString(params, "interval", "100ms")
            params = this.Omit(params, "interval")
        
            retRes1808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1808)
            if ccxt.IsTrue(ccxt.IsEqual(interval, "raw")) {
        
                retRes18212 := (<-this.Authenticate())
                ccxt.PanicOnError(retRes18212)
            }
            var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ticker.", ccxt.GetValue(market, "id")), "."), interval)
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "public/subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{ccxt.Add(ccxt.Add(ccxt.Add("ticker.", ccxt.GetValue(market, "id")), "."), interval)},
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
                retRes19415 :=  (<-this.Watch(url, channel, request, channel, request))
                ccxt.PanicOnError(retRes19415)
                ch <- retRes19415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deribit#watchTickers
 * @see https://docs.deribit.com/#ticker-instrument_name-interval
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeribitCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2088)
            symbols = this.MarketSymbols(symbols, nil, false)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var interval interface{} = this.SafeString(params, "interval", "100ms")
            params = this.Omit(params, "interval")
        
            retRes2138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2138)
            if ccxt.IsTrue(ccxt.IsEqual(interval, "raw")) {
        
                retRes21512 := (<-this.Authenticate())
                ccxt.PanicOnError(retRes21512)
            }
            var channels interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&channels, ccxt.Add(ccxt.Add(ccxt.Add("ticker.", ccxt.GetValue(market, "id")), "."), interval))
            }
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "public/subscribe",
                "params": map[string]interface{} {
                    "channels": channels,
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            newTickers:= (<-this.WatchMultiple(url, channels, request, channels, request))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "ticker.BTC_USDC-PERPETUAL.raw",
    //             "data": {
    //                 "timestamp": 1655393725040,
    //                 "stats": [Object],
    //                 "state": "open",
    //                 "settlement_price": 21729.5891,
    //                 "open_interest": 164.501,
    //                 "min_price": 20792.9376,
    //                 "max_price": 21426.225,
    //                 "mark_price": 21109.555,
    //                 "last_price": 21132,
    //                 "instrument_name": "BTC_USDC-PERPETUAL",
    //                 "index_price": 21122.3937,
    //                 "funding_8h": -0.00022427,
    //                 "estimated_delivery_price": 21122.3937,
    //                 "current_funding": -0.00010782,
    //                 "best_bid_price": 21106,
    //                 "best_bid_amount": 1.143,
    //                 "best_ask_price": 21113,
    //                 "best_ask_amount": 0.327
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeValue(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeValue(params, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId)
    var ticker interface{} = this.ParseTicker(data)
    var messageHash interface{} = this.SafeString(params, "channel")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
/**
 * @method
 * @name deribit#watchBidsAsks
 * @see https://docs.deribit.com/#quote-instrument_name
 * @description watches best bid & ask for symbols
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *DeribitCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2908)
            symbols = this.MarketSymbols(symbols, nil, false)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var channels interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&channels, ccxt.Add("quote.", ccxt.GetValue(market, "id")))
            }
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "public/subscribe",
                "params": map[string]interface{} {
                    "channels": channels,
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            newTickers:= (<-this.WatchMultiple(url, channels, request, channels, request))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "quote.BTC_USDT",
    //             "data": {
    //                 "best_bid_amount": 0.026,
    //                 "best_ask_amount": 0.026,
    //                 "best_bid_price": 63908,
    //                 "best_ask_price": 63940,
    //                 "instrument_name": "BTC_USDT",
    //                 "timestamp": 1727765131750
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeDict(params, "data", map[string]interface{} {})
    var ticker interface{} = this.ParseWsBidAsk(data)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
    var messageHash interface{} = this.SafeString(params, "channel")
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *DeribitCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instrument_name")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "best_ask_price"),
        "askVolume": this.SafeString(ticker, "best_ask_amount"),
        "bid": this.SafeString(ticker, "best_bid_price"),
        "bidVolume": this.SafeString(ticker, "best_bid_amount"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name deribit#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.deribit.com/#trades-instrument_name-interval
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DeribitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes37415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes37415)
                ch <- retRes37415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deribit#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://docs.deribit.com/#trades-instrument_name-interval
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DeribitCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var interval interface{} = nil
            intervalparamsVariable := this.HandleOptionAndParams(params, "watchTradesForSymbols", "interval", "100ms")
            interval = ccxt.GetValue(intervalparamsVariable,0)
            params = ccxt.GetValue(intervalparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(interval, "raw")) {
        
                retRes39212 := (<-this.Authenticate())
                ccxt.PanicOnError(retRes39212)
            }
        
            trades:= (<-this.WatchMultipleWrapper("trades", interval, symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "trades.BTC_USDC-PERPETUAL.100ms",
    //             "data": [{
    //                 "trade_seq": 501899,
    //                 "trade_id": "USDC-2436803",
    //                 "timestamp": 1655397355998,
    //                 "tick_direction": 2,
    //                 "price": 21026,
    //                 "mark_price": 21019.9719,
    //                 "instrument_name": "BTC_USDC-PERPETUAL",
    //                 "index_price": 21031.7847,
    //                 "direction": "buy",
    //                 "amount": 0.049
    //             }]
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var channel interface{} = this.SafeString(params, "channel", "")
    var parts interface{} = ccxt.Split(channel, ".")
    var marketId interface{} = this.SafeString(parts, 1)
    var interval interface{} = this.SafeString(parts, 2)
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var trades interface{} = this.SafeList(params, "data", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Trades, symbol), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = ccxt.GetValue(trades, i)
        var parsed interface{} = this.ParseTrade(trade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("trades|", symbol), "|"), interval)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
/**
 * @method
 * @name deribit#watchMyTrades
 * @description get the list of trades associated with the user
 * @see https://docs.deribit.com/#user-trades-instrument_name-interval
 * @param {string} symbol unified symbol of the market to fetch trades for. Use 'any' to watch all trades
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.interval] specify aggregation and frequency of notifications. Possible values: 100ms, raw
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DeribitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4618 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes4618)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        
                retRes46312 := (<-this.LoadMarkets())
                ccxt.PanicOnError(retRes46312)
                symbol = this.Symbol(symbol)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var interval interface{} = this.SafeString(params, "interval", "raw")
            params = this.Omit(params, "interval")
            var channel interface{} = ccxt.Add("user.trades.any.any.", interval)
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "private/subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{channel},
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            trades:= (<-this.Watch(url, channel, request, channel, request))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "user.trades.any.any.raw",
    //             "data": [{
    //                 "trade_seq": 149546319,
    //                 "trade_id": "219381310",
    //                 "timestamp": 1655421193564,
    //                 "tick_direction": 0,
    //                 "state": "filled",
    //                 "self_trade": false,
    //                 "reduce_only": false,
    //                 "profit_loss": 0,
    //                 "price": 20236.5,
    //                 "post_only": false,
    //                 "order_type": "market",
    //                 "order_id": "46108941243",
    //                 "matching_id": null,
    //                 "mark_price": 20233.96,
    //                 "liquidity": "T",
    //                 "instrument_name": "BTC-PERPETUAL",
    //                 "index_price": 20253.31,
    //                 "fee_currency": "BTC",
    //                 "fee": 2.5e-7,
    //                 "direction": "buy",
    //                 "amount": 10
    //             }]
    //         }
    //     }
    //
    var params interface{} = this.SafeValue(message, "params", map[string]interface{} {})
    var channel interface{} = this.SafeString(params, "channel", "")
    var trades interface{} = this.SafeValue(params, "data", []interface{}{})
    var cachedTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(cachedTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        cachedTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var parsed interface{} = this.ParseTrades(trades)
    var marketIds interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(parsed)); i++ {
        var trade interface{} = ccxt.GetValue(parsed, i)
        cachedTrades.(ccxt.Appender).Append(trade)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        ccxt.AddElementToObject(marketIds, symbol, true)
    }
    client.(ccxt.ClientInterface).Resolve(cachedTrades, channel)
}
/**
 * @method
 * @name deribit#watchOrderBook
 * @see https://docs.deribit.com/#book-instrument_name-group-depth-interval
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.interval] Frequency of notifications. Events will be aggregated over this interval. Possible values: 100ms, raw
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeribitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrderBook")
        
                retRes54815 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes54815)
                ch <- retRes54815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deribit#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.deribit.com/#book-instrument_name-group-depth-interval
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DeribitCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var interval interface{} = nil
            intervalparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "interval", "100ms")
            interval = ccxt.GetValue(intervalparamsVariable,0)
            params = ccxt.GetValue(intervalparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(interval, "raw")) {
        
                retRes56512 := (<-this.Authenticate())
                ccxt.PanicOnError(retRes56512)
            }
            var descriptor interface{} = ""
            var useDepthEndpoint interface{} = nil // for more info, see comment in .options
            useDepthEndpointparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "useDepthEndpoint", false)
            useDepthEndpoint = ccxt.GetValue(useDepthEndpointparamsVariable,0)
            params = ccxt.GetValue(useDepthEndpointparamsVariable,1)
            if ccxt.IsTrue(useDepthEndpoint) {
                var depth interface{} = nil
                depthparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "depth", "20")
                depth = ccxt.GetValue(depthparamsVariable,0)
                params = ccxt.GetValue(depthparamsVariable,1)
                var group interface{} = nil
                groupparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "group", "none")
                group = ccxt.GetValue(groupparamsVariable,0)
                params = ccxt.GetValue(groupparamsVariable,1)
                descriptor = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(group, "."), depth), "."), interval)
            } else {
                descriptor = interval
            }
        
            orderbook:= (<-this.WatchMultipleWrapper("book", descriptor, symbols, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //  snapshot
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "book.BTC_USDC-PERPETUAL.raw",
    //             "data": {
    //                 "type": "snapshot",
    //                 "timestamp": 1655395057025,
    //                 "instrument_name": "BTC_USDC-PERPETUAL",
    //                 "change_id": 1550694837,
    //                 "bids": [
    //                     ["new", 20987, 0.487],
    //                     ["new", 20986, 0.238],
    //                 ],
    //                 "asks": [
    //                     ["new", 20999, 0.092],
    //                     ["new", 21000, 1.238],
    //                 ]
    //             }
    //         }
    //     }
    //
    //  change
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "book.BTC_USDC-PERPETUAL.raw",
    //             "data": {
    //                 "type": "change",
    //                 "timestamp": 1655395168086,
    //                 "prev_change_id": 1550724481,
    //                 "instrument_name": "BTC_USDC-PERPETUAL",
    //                 "change_id": 1550724483,
    //                 "bids": [
    //                     ["new", 20977, 0.109],
    //                     ["delete", 20975, 0]
    //                 ],
    //                 "asks": []
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeValue(message, "params", map[string]interface{} {})
    var data interface{} = this.SafeValue(params, "data", map[string]interface{} {})
    var channel interface{} = this.SafeString(params, "channel")
    var parts interface{} = ccxt.Split(channel, ".")
    var descriptor interface{} = ""
    var partsLength interface{} =     ccxt.GetArrayLength(parts)
    var isDetailed interface{} = ccxt.IsEqual(partsLength, 5)
    if ccxt.IsTrue(isDetailed) {
        var group interface{} = this.SafeString(parts, 2)
        var depth interface{} = this.SafeString(parts, 3)
        var interval interface{} = this.SafeString(parts, 4)
        descriptor = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(group, "."), depth), "."), interval)
    } else {
        var interval interface{} = this.SafeString(parts, 2)
        descriptor = interval
    }
    var marketId interface{} = this.SafeString(data, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId)
    var timestamp interface{} = this.SafeInteger(data, "timestamp")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.CountedOrderBook())
    }
    var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var asks interface{} = this.SafeList(data, "asks", []interface{}{})
    var bids interface{} = this.SafeList(data, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(storedOrderBook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(storedOrderBook, "bids"), bids)
    ccxt.AddElementToObject(storedOrderBook, "nonce", timestamp)
    ccxt.AddElementToObject(storedOrderBook, "timestamp", timestamp)
    ccxt.AddElementToObject(storedOrderBook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(storedOrderBook, "symbol", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, storedOrderBook)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("book|", symbol), "|"), descriptor)
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *DeribitCore) CleanOrderBook(data interface{}) interface{}  {
    var bids interface{} = this.SafeList(data, "bids", []interface{}{})
    var asks interface{} = this.SafeList(data, "asks", []interface{}{})
    var cleanedBids interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bids)); i++ {
        ccxt.AppendToArray(&cleanedBids, []interface{}{ccxt.GetValue(ccxt.GetValue(bids, i), 1), ccxt.GetValue(ccxt.GetValue(bids, i), 2)})
    }
    var cleanedAsks interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(asks)); i++ {
        ccxt.AppendToArray(&cleanedAsks, []interface{}{ccxt.GetValue(ccxt.GetValue(asks, i), 1), ccxt.GetValue(ccxt.GetValue(asks, i), 2)})
    }
    ccxt.AddElementToObject(data, "bids", cleanedBids)
    ccxt.AddElementToObject(data, "asks", cleanedAsks)
    return data
}
func  (this *DeribitCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = ccxt.GetValue(delta, 1)
    var amount interface{} = ccxt.GetValue(delta, 2)
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(delta, 0), "new")) || ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(delta, 0), "change"))) {
        bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, amount, 1})
    } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(delta, 0), "delete")) {
        bookside.(ccxt.IOrderBookSide).StoreArray([]interface{}{price, amount, 0})
    }
}
func  (this *DeribitCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name deribit#watchOrders
 * @see https://docs.deribit.com/#user-orders-instrument_name-raw
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DeribitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7098)
        
            retRes7108 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes7108)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var currency interface{} = this.SafeString(params, "currency", "any")
            var interval interface{} = this.SafeString(params, "interval", "raw")
            var kind interface{} = this.SafeString(params, "kind", "any")
            params = this.Omit(params, "interval", "currency", "kind")
            var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("user.orders.", kind), "."), currency), "."), interval)
            var message interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "private/subscribe",
                "params": map[string]interface{} {
                    "channels": []interface{}{channel},
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, channel, request, channel, request))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleOrders(client interface{}, message interface{})  {
    // Does not return a snapshot of current orders
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "user.orders.any.any.raw",
    //             "data": {
    //                 "web": true,
    //                 "time_in_force": "good_til_cancelled",
    //                 "replaced": false,
    //                 "reduce_only": false,
    //                 "profit_loss": 0,
    //                 "price": 50000,
    //                 "post_only": false,
    //                 "order_type": "limit",
    //                 "order_state": "open",
    //                 "order_id": "46094375191",
    //                 "max_show": 10,
    //                 "last_update_timestamp": 1655401625037,
    //                 "label": '',
    //                 "is_liquidation": false,
    //                 "instrument_name": "BTC-PERPETUAL",
    //                 "filled_amount": 0,
    //                 "direction": "sell",
    //                 "creation_timestamp": 1655401625037,
    //                 "commission": 0,
    //                 "average_price": 0,
    //                 "api": false,
    //                 "amount": 10
    //             }
    //         }
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var params interface{} = this.SafeValue(message, "params", map[string]interface{} {})
    var channel interface{} = this.SafeString(params, "channel", "")
    var data interface{} = this.SafeValue(params, "data", map[string]interface{} {})
    var orders interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsArray(data)) {
        orders = this.ParseOrders(data)
    } else {
        var order interface{} = this.ParseOrder(data)
        orders = []interface{}{order}
    }
    var cachedOrders interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
        cachedOrders.(ccxt.Appender).Append(ccxt.GetValue(orders, i))
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, channel)
}
/**
 * @method
 * @name deribit#watchOHLCV
 * @see https://docs.deribit.com/#chart-trades-instrument_name-resolution
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DeribitCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8058 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8058)
            symbol = this.Symbol(symbol)
        
            ohlcvs:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(ohlcvs)
        
            ch <- ccxt.GetValue(ccxt.GetValue(ohlcvs, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name deribit#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.deribit.com/#chart-trades-instrument_name-resolution
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DeribitCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
            symboltimeframecandlesVariable := (<-this.WatchMultipleWrapper("chart.trades", nil, symbolsAndTimeframes, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "chart.trades.BTC_USDC-PERPETUAL.1",
    //             "data": {
    //                 "volume": 0,
    //                 "tick": 1655403420000,
    //                 "open": 20951,
    //                 "low": 20951,
    //                 "high": 20951,
    //                 "cost": 0,
    //                 "close": 20951
    //             }
    //         }
    //     }
    //
    var params interface{} = this.SafeDict(message, "params", map[string]interface{} {})
    var channel interface{} = this.SafeString(params, "channel", "")
    var parts interface{} = ccxt.Split(channel, ".")
    var marketId interface{} = this.SafeString(parts, 2)
    var rawTimeframe interface{} = this.SafeString(parts, 3)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var wsOptions interface{} = this.SafeDict(this.Options, "ws", map[string]interface{} {})
    var timeframes interface{} = this.SafeDict(wsOptions, "timeframes", map[string]interface{} {})
    var unifiedTimeframe interface{} = this.FindTimeframe(rawTimeframe, timeframes)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeDict(this.Ohlcvs, symbol, map[string]interface{} {}))
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe), nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe)
    var ohlcv interface{} = this.SafeDict(params, "data", map[string]interface{} {})
    // data contains a single ccxt.OHLCV candle
    var parsed interface{} = this.ParseWsOHLCV(ohlcv, market)
    stored.(ccxt.Appender).Append(parsed)
    ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, stored)
    var resolveData interface{} = []interface{}{symbol, unifiedTimeframe, stored}
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("chart.trades|", symbol), "|"), rawTimeframe)
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *DeribitCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "c": "28909.0",
    //        "o": "28915.4",
    //        "h": "28915.4",
    //        "l": "28896.1",
    //        "v": "27.6919",
    //        "T": 1696687499999,
    //        "t": 1696687440000
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "tick"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
func  (this *DeribitCore) WatchMultipleWrapper(channelName interface{}, channelDescriptor interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbolsArray := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbolsArray
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9038 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9038)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var rawSubscriptions interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var isOHLCV interface{} =     (ccxt.IsEqual(channelName, "chart.trades"))
            var symbols interface{} = ccxt.Ternary(ccxt.IsTrue(isOHLCV), this.GetListFromObjectValues(symbolsArray, 0), symbolsArray)
            this.MarketSymbols(symbols, nil, false)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsArray)); i++ {
                var current interface{} = ccxt.GetValue(symbolsArray, i)
                var market interface{} = nil
                if ccxt.IsTrue(isOHLCV) {
                    market = this.Market(ccxt.GetValue(current, 0))
                    var unifiedTf interface{} = ccxt.GetValue(current, 1)
                    var rawTf interface{} = this.SafeString(this.Timeframes, unifiedTf, unifiedTf)
                    channelDescriptor = rawTf
                } else {
                    market = this.Market(current)
                }
                var message interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channelName, "."), ccxt.GetValue(market, "id")), "."), channelDescriptor)
                ccxt.AppendToArray(&rawSubscriptions, message)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channelName, "|"), ccxt.GetValue(market, "symbol")), "|"), channelDescriptor))
            }
            var request interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "public/subscribe",
                "params": map[string]interface{} {
                    "channels": rawSubscriptions,
                },
                "id": this.RequestId(),
            }
            var extendedRequest interface{} = this.DeepExtend(request, params)
            var maxMessageByteLimit interface{} = ccxt.Subtract(32768, 1) // 'Message Too Big: limit 32768B'
            var jsonedText interface{} = this.Json(extendedRequest)
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetLength(jsonedText), maxMessageByteLimit)) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " requested subscription length over limit, try to reduce symbols amount")))
            }
        
                retRes93915 :=  (<-this.WatchMultiple(url, messageHashes, extendedRequest, rawSubscriptions))
                ccxt.PanicOnError(retRes93915)
                ch <- retRes93915
                return nil
        
            }()
            return ch
        }
func  (this *DeribitCore) HandleMessage(client interface{}, message interface{})  {
    //
    // error
    //     {
    //         "jsonrpc": "2.0",
    //         "id": 1,
    //         "error": {
    //             "message": "Invalid params",
    //             "data": {
    //                 "reason": "invalid format",
    //                 "param": "nonce"
    //             },
    //             "code": -32602
    //         },
    //         "usIn": "1655391709417993",
    //         "usOut": "1655391709418049",
    //         "usDiff": 56,
    //         "testnet": false
    //     }
    //
    // subscribe
    //     {
    //         "jsonrpc": "2.0",
    //         "id": 2,
    //         "result": ["ticker.BTC_USDC-PERPETUAL.raw"],
    //         "usIn": "1655393625889396",
    //         "usOut": "1655393625889518",
    //         "usDiff": 122,
    //         "testnet": false
    //     }
    //
    // notification
    //     {
    //         "jsonrpc": "2.0",
    //         "method": "subscription",
    //         "params": {
    //             "channel": "ticker.BTC_USDC-PERPETUAL.raw",
    //             "data": {
    //                 "timestamp": 1655393724752,
    //                 "stats": [Object],
    //                 "state": "open",
    //                 "settlement_price": 21729.5891,
    //                 "open_interest": 164.501,
    //                 "min_price": 20792.9001,
    //                 "max_price": 21426.1864,
    //                 "mark_price": 21109.4757,
    //                 "last_price": 21132,
    //                 "instrument_name": "BTC_USDC-PERPETUAL",
    //                 "index_price": 21122.3937,
    //                 "funding_8h": -0.00022427,
    //                 "estimated_delivery_price": 21122.3937,
    //                 "current_funding": -0.00011158,
    //                 "best_bid_price": 21106,
    //                 "best_bid_amount": 1.143,
    //                 "best_ask_price": 21113,
    //                 "best_ask_amount": 0.402
    //             }
    //         }
    //     }
    //
    var error interface{} = this.SafeValue(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(error))))
    }
    var params interface{} = this.SafeValue(message, "params")
    var channel interface{} = this.SafeString(params, "channel")
    if ccxt.IsTrue(!ccxt.IsEqual(channel, nil)) {
        var parts interface{} = ccxt.Split(channel, ".")
        var channelId interface{} = this.SafeString(parts, 0)
        var userHandlers interface{} = map[string]interface{} {
            "trades": this.HandleMyTrades,
            "portfolio": this.HandleBalance,
            "orders": this.HandleOrders,
        }
        var handlers interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "quote": this.HandleBidAsk,
            "book": this.HandleOrderBook,
            "trades": this.HandleTrades,
            "chart": this.HandleOHLCV,
            "user": this.SafeValue(userHandlers, this.SafeString(parts, 1)),
        }
        var handler interface{} = this.SafeValue(handlers, channelId)
        if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
            ccxt.CallDynamically(handler, client, message)
            return
        }
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " no handler found for this message "), this.Json(message))))
    }
    var result interface{} = this.SafeValue(message, "result", map[string]interface{} {})
    var accessToken interface{} = this.SafeString(result, "access_token")
    if ccxt.IsTrue(!ccxt.IsEqual(accessToken, nil)) {
        this.HandleAuthenticationMessage(client, message)
    }
}
func  (this *DeribitCore) HandleAuthenticationMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "jsonrpc": "2.0",
    //         "id": 1,
    //         "result": {
    //             "token_type": "bearer",
    //             "scope": "account:read_write block_trade:read_write connection custody:read_write mainaccount name:ccxt trade:read_write wallet:read_write",
    //             "refresh_token": "1686927372328.1EzFBRmt.logRQWXkPA1oE_Tk0gRsls9Hau7YN6a321XUBnxvR4x6cryhbkKcniUJU-czA8_zKXrqQGpQmfoDwhLIjIsWCvRuu6otbg-LKWlrtTX1GQqLcPaTTHAdZGTMV-HM8HiS03QBd9MIXWRfF53sKj2hdR9nZPZ6MH1XrkpAZPB_peuEEB9wlcc3elzWEZFtCmiy1fnQ8TPHwAJMt3nuUmEcMLt_-F554qrsg_-I66D9xMiifJj4dBemdPfV_PkGPRIwIoKlxDjyv2-xfCw-4eKyo6Hu1m2h6gT1DPOTxSXcBgfBQjpi-_uY3iAIj7U6xjC46PHthEdquhEuCTZl7UfCRZSAWwZA",
    //             "expires_in": 31536000,
    //             "access_token": "1686923272328.1CkwEx-u.qHradpIulmuoeboKMEi8PkQ1_4DF8yFE2zywBTtkD32sruVC53b1HwL5OWRuh2nYAndXff4xuXIMRkkEfMAFCeq24prihxxinoS8DDVkKBxedGx4CUPJFeXjmh7wuRGqQOLg1plXOpbF3fwF2KPEkAuETwcpcVY6K9HUVjutNRfxFe2TR7CvuS9x8TATvoPeu7H1ezYl-LkKSaRifdTXuwituXgp4oDbPRyQLniEBWuYF9rY7qbABxuOJlXI1VZ63u7Bh0mGWei-KeVeqHGNpy6OgrFRPXPxa9_U7vaxCyHW3zZ9959TQ1QUMLWtUX-NLBEv3BT5eCieW9HORYIOKfsgkpd3"
    //         },
    //         "usIn": "1655391872327712",
    //         "usOut": "1655391872328515",
    //         "usDiff": 803,
    //         "testnet": false
    //     }
    //
    var messageHash interface{} = "authenticated"
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
    return message
}
func  (this *DeribitCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var time interface{} = this.Milliseconds()
            var timeString interface{} = this.NumberToString(time)
            var nonce interface{} = timeString
            var messageHash interface{} = "authenticated"
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                this.CheckRequiredCredentials()
                var requestId interface{} = this.RequestId()
                var lineBreak interface{} = "\n" // eslint-disable-line quotes
                var signature interface{} = this.Hmac(this.Encode(ccxt.Add(ccxt.Add(ccxt.Add(timeString, lineBreak), nonce), lineBreak)), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = map[string]interface{} {
                    "jsonrpc": "2.0",
                    "id": requestId,
                    "method": "public/auth",
                    "params": map[string]interface{} {
                        "grant_type": "client_signature",
                        "client_id": this.ApiKey,
                        "timestamp": time,
                        "signature": signature,
                        "nonce": nonce,
                        "data": "",
                    },
                }
                
            future = (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }


func (this *DeribitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
