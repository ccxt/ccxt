package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"
import binance_sbe "github.com/ccxt/ccxt/go/v4/sbe/binance_spot_3_2"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BinanceCore struct {
	*ccxt.BinanceCore
	base *ccxt.BinanceCore
}

func NewBinanceCore() *BinanceCore {
    p := &BinanceCore{}
	base := &ccxt.BinanceCore{}
	p.base = base
	p.BinanceCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BinanceCore) Describe() interface{}  {
    var superDescribe interface{} = this.base.Describe()
    return callDynamically("deepExtend", superDescribe, this.DescribeData())
}
func  (this *BinanceCore) DescribeData() interface{}  {
    return map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchLiquidations": true,
            "watchLiquidationsForSymbols": true,
            "watchMyLiquidations": true,
            "watchMyLiquidationsForSymbols": true,
            "watchBidsAsks": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchOrdersForSymbols": true,
            "watchPositions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchMarkPrices": true,
            "watchMarkPrice": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": true,
            "fetchBalanceWs": true,
            "fetchDepositsWs": false,
            "fetchMarketsWs": false,
            "fetchMyTradesWs": true,
            "fetchOHLCVWs": true,
            "fetchOrderBookWs": true,
            "fetchOpenOrdersWs": true,
            "fetchOrderWs": true,
            "fetchOrdersWs": true,
            "fetchPositionWs": true,
            "fetchPositionForSymbolWs": true,
            "fetchPositionsWs": true,
            "fetchTickerWs": true,
            "fetchTradesWs": true,
            "fetchTradingFeesWs": false,
            "fetchWithdrawalsWs": false,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchOHLCV": true,
            "unWatchOHLCVForSymbols": true,
            "unWatchOrderBook": true,
            "unWatchOrderBookForSymbols": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchMyTrades": false,
            "unWatchOrders": false,
            "unWatchPositions": false,
            "unWatchMarkPrices": true,
            "unWatchMarkPrice": true,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://stream.testnet.binance.vision/ws",
                    "margin": "wss://stream.testnet.binance.vision/ws",
                    "future": "wss://fstream.binancefuture.com/ws",
                    "delivery": "wss://dstream.binancefuture.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://ws-api.testnet.binance.vision/ws-api/v3",
                        "future": "wss://testnet.binancefuture.com/ws-fapi/v1",
                        "delivery": "wss://testnet.binancefuture.com/ws-dapi/v1",
                    },
                },
            },
            "demo": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://demo-stream.binance.com/ws",
                    "margin": "wss://demo-stream.binance.com/ws",
                    "future": "wss://fstream.binancefuture.com/ws",
                    "delivery": "wss://dstream.binancefuture.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://demo-ws-api.binance.com/ws-api/v3",
                        "future": "wss://testnet.binancefuture.com/ws-fapi/v1",
                        "delivery": "wss://testnet.binancefuture.com/ws-dapi/v1",
                    },
                },
            },
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://stream.binance.com:9443/ws",
                    "margin": "wss://stream.binance.com:9443/ws",
                    "future": "wss://fstream.binance.com/ws",
                    "delivery": "wss://dstream.binance.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://ws-api.binance.com:443/ws-api/v3",
                        "future": "wss://ws-fapi.binance.com/ws-fapi/v1",
                        "delivery": "wss://ws-dapi.binance.com/ws-dapi/v1",
                    },
                    "papi": "wss://fstream.binance.com/pm/ws",
                },
            },
            "doc": "https://developers.binance.com/en",
        },
        "streaming": map[string]interface{} {
            "keepAlive": 180000,
        },
        "options": map[string]interface{} {
            "returnRateLimits": false,
            "streamLimits": map[string]interface{} {
                "spot": 50,
                "margin": 50,
                "future": 50,
                "delivery": 50,
            },
            "subscriptionLimitByStream": map[string]interface{} {
                "spot": 200,
                "margin": 200,
                "future": 200,
                "delivery": 200,
            },
            "streamBySubscriptionsHash": callDynamically("createSafeDictionary", ),
            "streamIndex": ccxt.OpNeg(1),
            "watchOrderBookRate": 100,
            "liquidationsLimit": 1000,
            "myLiquidationsLimit": 1000,
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "requestId": callDynamically("createSafeDictionary", ),
            "watchOrderBookLimit": 1000,
            "watchTrades": map[string]interface{} {
                "name": "trade",
            },
            "watchTicker": map[string]interface{} {
                "name": "ticker",
            },
            "watchTickers": map[string]interface{} {
                "name": "ticker",
            },
            "watchOHLCV": map[string]interface{} {
                "name": "kline",
            },
            "watchOrderBook": map[string]interface{} {
                "maxRetries": 3,
                "checksum": true,
            },
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": false,
                "awaitBalanceSnapshot": true,
            },
            "watchLiquidationsForSymbols": map[string]interface{} {
                "defaultType": "swap",
            },
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
            "wallet": "wb",
            "listenKeyRefreshRate": 1200000,
            "ws": map[string]interface{} {
                "cost": 5,
            },
            "tickerChannelsMap": map[string]interface{} {
                "24hrTicker": "ticker",
                "24hrMiniTicker": "miniTicker",
                "markPriceUpdate": "markPrice",
                "1hTicker": "ticker_1h",
                "4hTicker": "ticker_4h",
                "1dTicker": "ticker_1d",
                "bookTicker": "bookTicker",
            },
        },
    }
}
func  (this *BinanceCore) RequestId(url interface{}) interface{}  {
    var options interface{} = callDynamically("safeDict", this.Options, "requestId", callDynamically("createSafeDictionary", ))
    var previousValue interface{} = callDynamically("safeInteger", options, url, 0)
    var newValue interface{} = callDynamically("sum", previousValue, 1)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "requestId"), url, newValue)
    return newValue
}
/**
 * Appends SBE parameters to WebSocket API URL if SBE is enabled
 * @param {string} url - The base WebSocket URL
 * @returns {string} The URL with SBE parameters appended if enabled
 */
func  (this *BinanceCore) GetSbeWebSocketUrl(url interface{}) interface{}  {
    var useSbe interface{} = callDynamically("safeBool", this.Options, "useSbe", false)
    if ccxt.IsTrue(useSbe) {
        var sbeSchemaId interface{} = callDynamically("safeInteger", this.Options, "sbeSchemaId", 3)
        var sbeSchemaVersion interface{} = callDynamically("safeInteger", this.Options, "sbeSchemaVersion", 1)
        // ccxt.Add SBE parameters to the WebSocket URL
        var separator interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(url, "?"), 0)), "&", "?")
        return ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(url, separator), "responseFormat=sbe&sbeSchemaId="), ccxt.ToString(sbeSchemaId)), "&sbeSchemaVersion="), ccxt.ToString(sbeSchemaVersion))
    }
    return url
}
/**
 * Decodes SBE-encoded WebSocket messages
 * @param {ArrayBuffer} buffer - The binary SBE message
 * @returns {object} Decoded message as JSON-compatible object
 */
func  (this *BinanceCore) DecodeSbeWebSocketMessage(buffer interface{}) interface{}  {
    
        {
            ret__ := func(this *BinanceCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BinanceCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(this.Verbose) {
                callDynamically("log", "decodeSbeWebSocketMessage error:", e)
            }
            panic(e)
                            
                        }(this)
                    }
                }()
    		    // try block:
                        // Use new generated WebSocketResponseDecoder
            var decoder interface{} =  // @go-sbe-usage: new WebSocketResponseDecoder()
            var decoded interface{} = decoder.Decode(buffer, 0)
            if ccxt.IsTrue(this.Verbose) {
                callDynamically("log", "decodeSbeWebSocketMessage: decoded WebSocketResponse, status:", decoded.Status)
            }
            // The WebSocketResponse envelope contains: id, status, rateLimits, result
            // The result field is of type messageData (Uint8Array) and contains another nested SBE message
            // Decode nested result based on message template ID from the nested message header
            var decodedResult interface{} = decoded.Result
            if ccxt.IsTrue(ccxt.IsTrue(decoded.Result) && ccxt.IsTrue(ccxt.IsGreaterThan(decoded.Result.ByteLength, 0))) {
                // Result is binary data that needs to be decoded based on template ID
                decodedResult = callDynamically("decodeSbeNestedMessage", decoded.Result)
                if ccxt.IsTrue(this.Verbose) {
                    var resultType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(decodedResult) && ccxt.IsTrue(decodedResult.Constructor))), decodedResult.Constructor.Name, "unknown")
                    callDynamically("log", "decodeSbeWebSocketMessage: decoded nested result type:", resultType)
                }
            }
            // Convert Uint8Array ID to string
            var idString interface{} = callDynamically("decode", decoded.Id)
            // Clean up the decoded structure to match expected JSON format
            var cleanMessage interface{} = map[string]interface{} {
                "id": idString,
                "status": decoded.Status,
                "result": decodedResult,
                "rateLimits": decoded.RateLimits,
            }
            return cleanMessage
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *BinanceCore) Client(url interface{}) interface{}  {
    var client interface{} = this.base.Client(url)
    // Setup binary decoder for SBE WebSocket connections
    callDynamically("setupSbeBinaryDecoder", client, url, this.DecodeSbeWebSocketMessage.Bind(this))
    return client
}
func  (this *BinanceCore) IsSpotUrl(client interface{}) interface{}  {
    return ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "/stream"), ccxt.OpNeg(1)))) || ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "demo-stream"), ccxt.OpNeg(1))))
}
func  (this *BinanceCore) Stream(typeVar interface{}, subscriptionHash interface{}, optionalArgs ...interface{}) interface{}  {
    numSubscriptions := ccxt.GetArg(optionalArgs, 0, 1)
    _ = numSubscriptions
    var streamBySubscriptionsHash interface{} = callDynamically("safeDict", this.Options, "streamBySubscriptionsHash", callDynamically("createSafeDictionary", ))
    var stream interface{} = callDynamically("safeString", streamBySubscriptionsHash, subscriptionHash)
    if ccxt.IsTrue(ccxt.IsEqual(stream, nil)) {
        var streamIndex interface{} = callDynamically("safeInteger", this.Options, "streamIndex", ccxt.OpNeg(1))
        var streamLimits interface{} = callDynamically("safeValue", this.Options, "streamLimits")
        var streamLimit interface{} = callDynamically("safeInteger", streamLimits, typeVar)
        streamIndex = ccxt.Add(streamIndex, 1)
        var normalizedIndex interface{} = ccxt.Mod(streamIndex, streamLimit)
        ccxt.AddElementToObject(this.Options, "streamIndex", streamIndex)
        stream = callDynamically("numberToString", normalizedIndex)
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "streamBySubscriptionsHash"), subscriptionHash, stream)
        var subscriptionsByStreams interface{} = callDynamically("safeValue", this.Options, "numSubscriptionsByStream")
        if ccxt.IsTrue(ccxt.IsEqual(subscriptionsByStreams, nil)) {
            ccxt.AddElementToObject(this.Options, "numSubscriptionsByStream", callDynamically("createSafeDictionary", ))
        }
        var subscriptionsByStream interface{} = callDynamically("safeInteger", ccxt.GetValue(this.Options, "numSubscriptionsByStream"), stream, 0)
        var newNumSubscriptions interface{} = ccxt.Add(subscriptionsByStream, numSubscriptions)
        var subscriptionLimitByStream interface{} = callDynamically("safeInteger", ccxt.GetValue(this.Options, "subscriptionLimitByStream"), typeVar, 200)
        if ccxt.IsTrue(ccxt.IsGreaterThan(newNumSubscriptions, subscriptionLimitByStream)) {
            ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " reached the limit of subscriptions by stream. Increase the number of streams, or increase the stream limit or subscription limit by stream if the exchange allows."));return nil
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "numSubscriptionsByStream"), stream, ccxt.Add(subscriptionsByStream, numSubscriptions))
    }
    return stream
}
/**
 * @method
 * @name binance#watchLiquidations
 * @description watch the public liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/ccxt.Liquidation-ccxt.Order-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/ccxt.Liquidation-ccxt.Order-Streams
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes32015 :=  (<-this.WatchLiquidationsForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes32015)
                ch <- retRes32015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchLiquidationsForSymbols
 * @description watch the public liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-ccxt.Liquidation-ccxt.Order-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-ccxt.Liquidation-ccxt.Order-Streams
 * @param {string[]} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3368 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes3368)
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var streamHash interface{} = "liquidations"
            symbols = callDynamically("marketSymbols", symbols, nil, true, true)
            if ccxt.IsTrue(callDynamically("isEmpty", symbols)) {
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("!", "forceOrder@arr"))
                ccxt.AppendToArray(&messageHashes, "liquidations")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var market interface{} = callDynamically("market", ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&subscriptionHashes, ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@forceOrder"))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("liquidations::", ccxt.GetValue(symbols, i)))
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var firstMarket interface{} = callDynamically("getMarketFromSymbols", symbols)
            var typeVar interface{} = nil
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "watchLiquidationsForSymbols", firstMarket, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " watchLiquidationsForSymbols is not supported for spot symbols"));return nil
            }
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchLiquidationsForSymbols", firstMarket, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            var numSubscriptions interface{} =     ccxt.GetArrayLength(subscriptionHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, numSubscriptions))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
        
            newLiquidations:= (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, params), subscriptionHashes, subscribe))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- callDynamically("filterBySymbolsSinceLimit", this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    // future
    //    {
    //        "e":"forceOrder",
    //        "E":1698871323061,
    //        "o":{
    //           "s":"BTCUSDT",
    //           "S":"BUY",
    //           "o":"LIMIT",
    //           "f":"IOC",
    //           "q":"1.437",
    //           "p":"35100.81",
    //           "ap":"34959.70",
    //           "X":"FILLED",
    //           "l":"1.437",
    //           "z":"1.437",
    //           "T":1698871323059
    //        }
    //    }
    // delivery
    //    {
    //        "e":"forceOrder",              // Event Type
    //        "E": 1591154240950,            // Event Time
    //        "o":{
    //            "s":"BTCUSD_200925",       // Symbol
    //            "ps": "BTCUSD",            // Pair
    //            "S":"SELL",                // Side
    //            "o":"LIMIT",               // ccxt.Order Type
    //            "f":"IOC",                 // Time in Force
    //            "q":"1",                   // Original Quantity
    //            "p":"9425.5",              // Price
    //            "ap":"9496.5",             // Average Price
    //            "X":"FILLED",              // ccxt.Order Status
    //            "l":"1",                   // ccxt.Order Last Filled Quantity
    //            "z":"1",                   // ccxt.Order Filled Accumulated Quantity
    //            "T": 1591154240949,        // ccxt.Order ccxt.Trade Time
    //        }
    //    }
    //
    var rawLiquidation interface{} = callDynamically("safeValue", message, "o", map[string]interface{} {})
    var marketId interface{} = callDynamically("safeString", rawLiquidation, "s")
    var market interface{} = callDynamically("safeMarket", marketId, nil, "", "contract")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation, market)
    var liquidations interface{} = callDynamically("safeValue", this.Liquidations, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
        var limit interface{} = callDynamically("safeInteger", this.Options, "liquidationsLimit", 1000)
        liquidations = ccxt.NewArrayCache(limit)
    }
    liquidations.(ccxt.Appender).Append(liquidation)
    ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "liquidations")
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("liquidations::", symbol))
}
func  (this *BinanceCore) ParseWsLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // future
    //    {
    //        "s":"BTCUSDT",
    //        "S":"BUY",
    //        "o":"LIMIT",
    //        "f":"IOC",
    //        "q":"1.437",
    //        "p":"35100.81",
    //        "ap":"34959.70",
    //        "X":"FILLED",
    //        "l":"1.437",
    //        "z":"1.437",
    //        "T":1698871323059
    //    }
    // delivery
    //    {
    //        "s":"BTCUSD_200925",       // Symbol
    //        "ps": "BTCUSD",            // Pair
    //        "S":"SELL",                // Side
    //        "o":"LIMIT",               // ccxt.Order Type
    //        "f":"IOC",                 // Time in Force
    //        "q":"1",                   // Original Quantity
    //        "p":"9425.5",              // Price
    //        "ap":"9496.5",             // Average Price
    //        "X":"FILLED",              // ccxt.Order Status
    //        "l":"1",                   // ccxt.Order Last Filled Quantity
    //        "z":"1",                   // ccxt.Order Filled Accumulated Quantity
    //        "T": 1591154240949,        // ccxt.Order ccxt.Trade Time
    //    }
    // myLiquidation
    //    {
    //        "s":"BTCUSDT",              // Symbol
    //        "c":"TEST",                 // ccxt.Client ccxt.Order Id
    //          // special client order id:
    //          // starts with "autoclose-": liquidation order
    //          // "adl_autoclose": ADL auto close order
    //          // "settlement_autoclose-": settlement order for delisting or delivery
    //        "S":"SELL",                 // Side
    //        "o":"TRAILING_STOP_MARKET", // ccxt.Order Type
    //        "f":"GTC",                  // Time in Force
    //        "q":"0.001",                // Original Quantity
    //        "p":"0",                    // Original Price
    //        "ap":"0",                   // Average Price
    //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //        "x":"NEW",                  // Execution Type
    //        "X":"NEW",                  // ccxt.Order Status
    //        "i":8886774,                // ccxt.Order Id
    //        "l":"0",                    // ccxt.Order Last Filled Quantity
    //        "z":"0",                    // ccxt.Order Filled Accumulated Quantity
    //        "L":"0",                    // Last Filled Price
    //        "N":"USDT",                 // Commission Asset, will not push if no commission
    //        "n":"0",                    // Commission, will not push if no commission
    //        "T":1568879465650,          // ccxt.Order ccxt.Trade Time
    //        "t":0,                      // ccxt.Trade Id
    //        "b":"0",                    // ccxt.Bids Notional
    //        "a":"9.91",                 // Ask Notional
    //        "m":false,                  // Is this trade the maker side?
    //        "R":false,                  // Is this reduce only
    //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
    //        "ot":"TRAILING_STOP_MARKET",// Original ccxt.Order Type
    //        "ps":"LONG",                // ccxt.Position Side
    //        "cp":false,                 // If Close-All, pushed with conditional order
    //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //        "pP": false,                // If price protection is turned on
    //        "si": 0,                    // ignore
    //        "ss": 0,                    // ignore
    //        "rp":"0",                   // Realized Profit of the trade
    //        "V":"EXPIRE_TAKER",         // STP mode
    //        "pm":"OPPONENT",            // Price match mode
    //        "gtd":0                     // TIF GTD order auto cancel time
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = callDynamically("safeString", liquidation, "s")
    market = callDynamically("safeMarket", marketId, market, nil, "swap")
    var timestamp interface{} = callDynamically("safeInteger", liquidation, "T")
    return callDynamically("safeLiquidation", map[string]interface{} {
    "info": liquidation,
    "symbol": callDynamically("safeSymbol", marketId, market),
    "contracts": callDynamically("safeNumber", liquidation, "l"),
    "contractSize": callDynamically("safeNumber", market, "contractSize"),
    "price": callDynamically("safeNumber", liquidation, "ap"),
    "side": callDynamically("safeStringLower", liquidation, "S"),
    "baseValue": nil,
    "quoteValue": nil,
    "timestamp": timestamp,
    "datetime": callDynamically("iso8601", timestamp),
})
}
/**
 * @method
 * @name binance#watchMyLiquidations
 * @description watch the private liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchMyLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            ch <- this.WatchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMyLiquidationsForSymbols
 * @description watch the private liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @param {string[]} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5608 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes5608)
            symbols = callDynamically("marketSymbols", symbols, nil, true, true, true)
            var market interface{} = callDynamically("getMarketFromSymbols", symbols)
            var messageHashes interface{} = []interface{}{"myLiquidations"}
            if !ccxt.IsTrue(callDynamically("isEmpty", symbols)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("myLiquidations::", symbol))
                }
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "watchMyLiquidationsForSymbols", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchMyLiquidationsForSymbols", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
        
            retRes5798 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes5798)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            var message interface{} = nil
        
            newLiquidations:= (<-callDynamically("watchMultiple", url, messageHashes, message, []interface{}{typeVar}))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- callDynamically("filterBySymbolsSinceLimit", this.Liquidations, symbols, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleMyLiquidation(client interface{}, message interface{})  {
    //
    //    {
    //        "s":"BTCUSDT",              // Symbol
    //        "c":"TEST",                 // ccxt.Client ccxt.Order Id
    //          // special client order id:
    //          // starts with "autoclose-": liquidation order
    //          // "adl_autoclose": ADL auto close order
    //          // "settlement_autoclose-": settlement order for delisting or delivery
    //        "S":"SELL",                 // Side
    //        "o":"TRAILING_STOP_MARKET", // ccxt.Order Type
    //        "f":"GTC",                  // Time in Force
    //        "q":"0.001",                // Original Quantity
    //        "p":"0",                    // Original Price
    //        "ap":"0",                   // Average Price
    //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //        "x":"NEW",                  // Execution Type
    //        "X":"NEW",                  // ccxt.Order Status
    //        "i":8886774,                // ccxt.Order Id
    //        "l":"0",                    // ccxt.Order Last Filled Quantity
    //        "z":"0",                    // ccxt.Order Filled Accumulated Quantity
    //        "L":"0",                    // Last Filled Price
    //        "N":"USDT",                 // Commission Asset, will not push if no commission
    //        "n":"0",                    // Commission, will not push if no commission
    //        "T":1568879465650,          // ccxt.Order ccxt.Trade Time
    //        "t":0,                      // ccxt.Trade Id
    //        "b":"0",                    // ccxt.Bids Notional
    //        "a":"9.91",                 // Ask Notional
    //        "m":false,                  // Is this trade the maker side?
    //        "R":false,                  // Is this reduce only
    //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
    //        "ot":"TRAILING_STOP_MARKET",// Original ccxt.Order Type
    //        "ps":"LONG",                // ccxt.Position Side
    //        "cp":false,                 // If Close-All, pushed with conditional order
    //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //        "pP": false,                // If price protection is turned on
    //        "si": 0,                    // ignore
    //        "ss": 0,                    // ignore
    //        "rp":"0",                   // Realized Profit of the trade
    //        "V":"EXPIRE_TAKER",         // STP mode
    //        "pm":"OPPONENT",            // Price match mode
    //        "gtd":0                     // TIF GTD order auto cancel time
    //    }
    //
    var orderType interface{} = callDynamically("safeString", message, "o")
    if ccxt.IsTrue(!ccxt.IsEqual(orderType, "LIQUIDATION")) {
        return
    }
    var marketId interface{} = callDynamically("safeString", message, "s")
    var market interface{} = callDynamically("safeMarket", marketId, nil, nil, "swap")
    var symbol interface{} = callDynamically("safeSymbol", marketId, market)
    var liquidation interface{} = this.ParseWsLiquidation(message, market)
    var myLiquidations interface{} = callDynamically("safeValue", this.MyLiquidations, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(myLiquidations, nil)) {
        var limit interface{} = callDynamically("safeInteger", this.Options, "myLiquidationsLimit", 1000)
        myLiquidations = ccxt.NewArrayCache(limit)
    }
    myLiquidations.(ccxt.Appender).Append(liquidation)
    ccxt.AddElementToObject(this.MyLiquidations, symbol, myLiquidations)
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "myLiquidations")
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("myLiquidations::", symbol))
}
/**
 * @method
 * @name binance#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams-RPI
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            // todo add support for <levels>-snapshots (depth)
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams        // <symbol>@depth<levels>@100ms or <symbol>@depth<levels> (1000ms)
            // valid <levels> are 5, 10, or 20
            //
            // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            //
            // notice the differences between trading futures and spot trading
            // the algorithms use different urls in step 1
            // delta caching and merging also differs in steps 4, 5, 6
            //
            // spot/margin
            // https://binance-docs.github.io/apidocs/spot/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
            // 2. Buffer the events you receive from the stream.
            // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
            // 4. Drop any event where u is <= lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            // futures
            // https://binance-docs.github.io/apidocs/futures/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://fstream.binance.com/stream?streams=btcusdt@depth.
            // 2. Buffer the events you receive from the stream. For same price, latest received update covers the previous one.
            // 3. Get a depth snapshot from https://fapi.binance.com/fapi/v1/depth?symbol=BTCUSDT&limit=1000 .
            // 4. Drop any event where u is < lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
            // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes70715 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes70715)
        ch <- retRes70715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams-RPI
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.rpi] *future only* set to true to use the RPI endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7288 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes7288)
            symbols = callDynamically("marketSymbols", symbols, nil, false, true, true)
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var name interface{} = "depth"
            var streamHash interface{} = "multipleOrderbook"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " watchOrderBookForSymbols() accepts 200 symbols at most. To watch more symbols call watchOrderBookForSymbols() multiple times"));return nil
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var watchOrderBookRate interface{} = nil
            watchOrderBookRateparamsVariable := callDynamically("handleOptionAndParams", params, "watchOrderBookForSymbols", "watchOrderBookRate", "100")
            watchOrderBookRate = ccxt.GetValue(watchOrderBookRateparamsVariable,0)
            params = ccxt.GetValue(watchOrderBookRateparamsVariable,1)
            var rpi interface{} = nil
            rpiparamsVariable := callDynamically("handleOptionAndParams", params, "watchOrderBookForSymbols", "rpi", false)
            rpi = ccxt.GetValue(rpiparamsVariable,0)
            params = ccxt.GetValue(rpiparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(rpi) && ccxt.IsTrue(ccxt.IsEqual(typeVar, "future"))) {
                name = "rpiDepth"
                watchOrderBookRate = "500"
            }
            var subParams interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = callDynamically("market", symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook::", symbol))
                var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                var symbolHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(subscriptionHash, "@"), ccxt.ToString(watchOrderBookRate)), "ms")
                ccxt.AppendToArray(&subParams, symbolHash)
            }
            var messageHashesLength interface{} =     ccxt.GetArrayLength(messageHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, messageHashesLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": ccxt.ToString(requestId),
                "name": name,
                "symbols": symbols,
                "method": this.HandleOrderBookSubscription,
                "limit": limit,
                "type": typeVar,
                "params": params,
            }
        
            orderbook:= (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, params), messageHashes, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7988 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes7988)
            symbols = callDynamically("marketSymbols", symbols, nil, false, true, true)
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var name interface{} = "depth"
            var streamHash interface{} = "multipleOrderbook"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var watchOrderBookRate interface{} = callDynamically("safeString", this.Options, "watchOrderBookRate", "100")
            var subParams interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = callDynamically("market", symbol)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("orderbook::", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                var symbolHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(subscriptionHash, "@"), watchOrderBookRate), "ms")
                ccxt.AppendToArray(&subParams, symbolHash)
            }
            var messageHashesLength interface{} =     ccxt.GetArrayLength(subMessageHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, messageHashesLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "symbols": symbols,
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "topic": "orderbook",
            }
        
                retRes83915 :=  (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, params), messageHashes, subscription))
                ccxt.PanicOnError(retRes83915)
                ch <- retRes83915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes85715 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes85715)
                ch <- retRes85715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrderBookWs
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#order-book
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/ccxt.Order-Book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) FetchOrderBookWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8728 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes8728)
            var market interface{} = callDynamically("market", symbol)
            var payload interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var marketType interface{} = this.GetMarketType("fetchOrderBookWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(marketType, "future")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOrderBookWs only supports swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "createOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            params = callDynamically("omit", params, "test")
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "depth",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleFetchOrderBook,
            }
        
            orderbook:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orderbook)
            ccxt.AddElementToObject(orderbook, "symbol", ccxt.GetValue(market, "symbol"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleFetchOrderBook(client interface{}, message interface{})  {
    //
    // JSON format:
    //    {
    //        "id":"51e2affb-0aba-4821-ba75-f2625006eb43",
    //        "status":200,
    //        "result":{
    //            "lastUpdateId":1027024,
    //            "E":1589436922972,
    //            "T":1589436922959,
    //            "bids":[
    //               [
    //                  "4.00000000",
    //                  "431.00000000"
    //               ]
    //            ],
    //            "asks":[
    //               [
    //                  "4.00000200",
    //                  "12.00000000"
    //               ]
    //            ]
    //        }
    //    }
    //
    // SBE format (DepthResponse):
    //    {
    //        "id":"...",
    //        "status":200,
    //        "result":{
    //            "lastUpdateId":1027024,
    //            "priceExponent": -8,
    //            "qtyExponent": -8,
    //            "bids":[
    //                {
    //                    "price": 400000000,    // mantissa
    //                    "qty": 43100000000     // mantissa
    //                }
    //            ],
    //            "asks":[
    //                {
    //                    "price": 400000200,
    //                    "qty": 1200000000
    //                }
    //            ]
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeDict", message, "result")
    // Check if SBE format (has exponent fields)
    var priceExponent interface{} = callDynamically("safeInteger", result, "priceExponent")
    if ccxt.IsTrue(!ccxt.IsEqual(priceExponent, nil)) {
        // SBE format - normalize to JSON format
        var qtyExponent interface{} = callDynamically("safeInteger", result, "qtyExponent", 0)
        var normalized interface{} = map[string]interface{} {
            "lastUpdateId": callDynamically("safeInteger", result, "lastUpdateId"),
            "E": callDynamically("safeInteger", result, "E"),
            "T": callDynamically("safeInteger", result, "T"),
            "bids": []interface{}{},
            "asks": []interface{}{},
        }
        // Convert bids
        var bidsArray interface{} = callDynamically("safeList", result, "bids", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidsArray)); i++ {
            var bid interface{} = ccxt.GetValue(bidsArray, i)
            var price interface{} = callDynamically("applyExponent", callDynamically("safeInteger", bid, "price", 0), priceExponent)
            var qty interface{} = callDynamically("applyExponent", callDynamically("safeInteger", bid, "qty", 0), qtyExponent)
            retRes97316 := ccxt.GetValue(normalized, "bids")
            ccxt.AppendToArray(&retRes97316, []interface{}{ccxt.String(price), ccxt.String(qty)})
        }
        // Convert asks
        var asksArray interface{} = callDynamically("safeList", result, "asks", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(asksArray)); i++ {
            var ask interface{} = ccxt.GetValue(asksArray, i)
            var price interface{} = callDynamically("applyExponent", callDynamically("safeInteger", ask, "price", 0), priceExponent)
            var qty interface{} = callDynamically("applyExponent", callDynamically("safeInteger", ask, "qty", 0), qtyExponent)
            retRes98116 := ccxt.GetValue(normalized, "asks")
            ccxt.AppendToArray(&retRes98116, []interface{}{ccxt.String(price), ccxt.String(qty)})
        }
        result = normalized
    }
    var timestamp interface{} = callDynamically("safeInteger", result, "T")
    var orderbook interface{} = callDynamically("parseOrderBook", result, nil, timestamp)
    ccxt.AddElementToObject(orderbook, "nonce", callDynamically("safeInteger2", result, "lastUpdateId", "u"))
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BinanceCore) FetchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var symbol interface{} = callDynamically("safeString", subscription, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook::", symbol)
            
                {
                     func(this *BinanceCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *BinanceCore) interface{} {
                                    // catch block:
                                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                var defaultLimit interface{} = callDynamically("safeInteger", this.Options, "watchOrderBookLimit", 1000)
                    var typeVar interface{} = callDynamically("safeValue", subscription, "type")
                    var limit interface{} = callDynamically("safeInteger", subscription, "limit", defaultLimit)
                    var params interface{} = callDynamically("safeValue", subscription, "params")
                    // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
                    // todo: this is a synch blocking call - make it async
                    // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            
                    snapshot:= (<-callDynamically("fetchRestOrderBookSafe", symbol, limit, params))
                    ccxt.PanicOnError(snapshot)
                    if ccxt.IsTrue(ccxt.IsEqual(callDynamically("safeValue", this.Orderbooks, symbol), nil)) {
            
                        return nil
                    }
                    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
                    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
                    // unroll the accumulated deltas
                    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
                    orderbook.(ccxt.OrderBookInterface).SetCache([]interface{}{})
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
                        var messageItem interface{} = ccxt.GetValue(messages, i)
                        var U interface{} = callDynamically("safeInteger", messageItem, "U")
                        var u interface{} = callDynamically("safeInteger", messageItem, "u")
                        var pu interface{} = callDynamically("safeInteger", messageItem, "pu")
                        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                            // 4. Drop any event where u is < lastUpdateId in the snapshot
                            if ccxt.IsTrue(ccxt.IsLessThan(u, ccxt.GetValue(orderbook, "nonce"))) {
                                continue
                            }
                            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual(U, ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))))) || ccxt.IsTrue((ccxt.IsEqual(pu, ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, messageItem, orderbook)
                            }
                        } else {
                            // 4. Drop any event where u is <= lastUpdateId in the snapshot
                            if ccxt.IsTrue(ccxt.IsLessThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))) {
                                continue
                            }
                            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual((ccxt.Subtract(u, 1)), ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, messageItem, orderbook)
                            }
                        }
                    }
                    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = callDynamically("safeFloat", delta, 0)
    var amount interface{} = callDynamically("safeFloat", delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BinanceCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BinanceCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    var u interface{} = callDynamically("safeInteger", message, "u")
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), callDynamically("safeValue", message, "a", []interface{}{}))
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), callDynamically("safeValue", message, "b", []interface{}{}))
    ccxt.AddElementToObject(orderbook, "nonce", u)
    var timestamp interface{} = callDynamically("safeInteger", message, "E")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", callDynamically("iso8601", timestamp))
    return orderbook
}
func  (this *BinanceCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //     {
    //         "e": "depthUpdate", // Event type
    //         "E": 1577554482280, // Event time
    //         "s": "BNBBTC", // Symbol
    //         "U": 157, // First update ID in event
    //         "u": 160, // Final update ID in event
    //         "b": [ // bids
    //             [ "0.0024", "10" ], // price, size
    //         ],
    //         "a": [ // asks
    //             [ "0.0026", "100" ], // price, size
    //         ]
    //     }
    //
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "swap")
    var marketId interface{} = callDynamically("safeString", message, "s")
    var market interface{} = callDynamically("safeMarket", marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook::", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        //
        // https://github.com/ccxt/ccxt/issues/6672
        //
        // Sometimes Binance sends the first delta before the subscription
        // confirmation arrives. At that point the orderbook is not
        // initialized yet and the snapshot has not been requested yet
        // therefore it is safe to drop these premature messages.
        //
        return
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = callDynamically("safeInteger", orderbook, "nonce")
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        // 2. Buffer the events you receive from the stream.
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        
            {
                 func(this *BinanceCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *BinanceCore) interface{} {
                                // catch block:
                                            ccxt.Remove(this.Orderbooks, symbol)
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                return nil
                            }(this)
                        }
                    }()
        		    // try block:
                                var U interface{} = callDynamically("safeInteger", message, "U")
                    var u interface{} = callDynamically("safeInteger", message, "u")
                    var pu interface{} = callDynamically("safeInteger", message, "pu")
                    if ccxt.IsTrue(ccxt.IsEqual(pu, nil)) {
                        // spot
                        // 4. Drop any event where u is <= lastUpdateId in the snapshot
                        if ccxt.IsTrue(ccxt.IsGreaterThan(u, ccxt.GetValue(orderbook, "nonce"))) {
                            var timestamp interface{} = callDynamically("safeInteger", orderbook, "timestamp")
                            var conditional interface{} = nil
                            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                                // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                                conditional = ccxt.IsTrue((ccxt.IsLessThanOrEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual((ccxt.Subtract(u, 1)), ccxt.GetValue(orderbook, "nonce"))))
                            } else {
                                // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
                                conditional = (ccxt.IsEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))
                            }
                            if ccxt.IsTrue(conditional) {
                                this.HandleOrderBookMessage(client, message, orderbook)
                                if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.GetValue(orderbook, "nonce"))) {
                                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
                                }
                            } else {
                                var checksum interface{} = callDynamically("handleOption", "watchOrderBook", "checksum", true)
                                if ccxt.IsTrue(checksum) {
                                    ccxt.ThrowDynamicException(ccxt.ChecksumError, ccxt.Add(ccxt.Add(this.Id, " "), callDynamically("orderbookChecksumMessage", symbol)));return nil
                                }
                            }
                        }
                    } else {
                        // future
                        // 4. Drop any event where u is < lastUpdateId in the snapshot
                        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))) {
                            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                            // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3
                            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual(U, ccxt.GetValue(orderbook, "nonce")))) || ccxt.IsTrue((ccxt.IsEqual(pu, ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, message, orderbook)
                                if ccxt.IsTrue(ccxt.IsLessThanOrEqual(nonce, ccxt.GetValue(orderbook, "nonce"))) {
                                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
                                }
                            } else {
                                var checksum interface{} = callDynamically("handleOption", "watchOrderBook", "checksum", true)
                                if ccxt.IsTrue(checksum) {
                                    ccxt.ThrowDynamicException(ccxt.ChecksumError, ccxt.Add(ccxt.Add(this.Id, " "), callDynamically("orderbookChecksumMessage", symbol)));return nil
                                }
                            }
                        }
                    }
        		    return nil
        	    }(this)
            
                }
    }
}
func  (this *BinanceCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var defaultLimit interface{} = callDynamically("safeInteger", this.Options, "watchOrderBookLimit", 1000)
    // const messageHash = this.safeString (subscription, 'messageHash')
    var symbolOfSubscription interface{} = callDynamically("safeString", subscription, "symbol") // watchOrderBook
    var symbols interface{} = callDynamically("safeValue", subscription, "symbols", []interface{}{symbolOfSubscription}) // watchOrderBookForSymbols
    var limit interface{} = callDynamically("safeInteger", subscription, "limit", defaultLimit)
    // handle list of symbols
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        var symbol interface{} = ccxt.GetValue(symbols, i)
        if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
            ccxt.Remove(this.Orderbooks, symbol)
        }
        ccxt.AddElementToObject(this.Orderbooks, symbol, callDynamically("orderBook", map[string]interface{} {}, limit))
        subscription = callDynamically("extend", subscription, map[string]interface{} {
    "symbol": symbol,
})
        // fetch the snapshot in a separate async call
        callDynamically("spawn", this.FetchOrderBookSnapshot, client, message, subscription)
    }
}
func  (this *BinanceCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "result": null,
    //         "id": 1574649734450
    //     }
    //
    var id interface{} = callDynamically("safeString", message, "id")
    var subscriptionsById interface{} = callDynamically("indexBy", client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = callDynamically("safeValue", subscriptionsById, id, map[string]interface{} {})
    var method interface{} = callDynamically("safeValue", subscription, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message, subscription)
    }
    var isUnSubMessage interface{} = callDynamically("safeBool", subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSubMessage) {
        this.HandleUnSubscription(client, subscription)
    }
    return message
}
func  (this *BinanceCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = callDynamically("safeList", subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = callDynamically("safeList", subscription, "subMessageHashes", []interface{}{})
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
        callDynamically("cleanUnsubscription", client, subHash, unsubHash)
    }
    callDynamically("cleanCache", subscription)
}
/**
 * @method
 * @name binance#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BinanceCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12358 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes12358)
            symbols = callDynamically("marketSymbols", symbols, nil, false, true, true)
            var streamHash interface{} = "multipleTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times"));return nil
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var name interface{} = nil
            nameparamsVariable := callDynamically("handleOptionAndParams", params, "watchTradesForSymbols", "name", "trade")
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            params = callDynamically("omit", params, "callerMethodName")
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var messageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = callDynamically("market", symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade::", symbol))
                var rawHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var query interface{} = callDynamically("omit", params, "type")
            var subParamsLength interface{} =     ccxt.GetArrayLength(subParams)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, subParamsLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
        
            trades:= (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, query), messageHashes, subscribe))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = callDynamically("safeValue", trades, 0)
                var tradeSymbol interface{} = callDynamically("safeString", first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- callDynamically("filterBySinceLimit", trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTradesForSymbols
 * @description unsubscribes from the trades channel
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BinanceCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12978 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes12978)
            symbols = callDynamically("marketSymbols", symbols, nil, false, true, true)
            var streamHash interface{} = "multipleTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times"));return nil
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var name interface{} = nil
            nameparamsVariable := callDynamically("handleOptionAndParams", params, "watchTradesForSymbols", "name", "trade")
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            params = callDynamically("omit", params, "callerMethodName")
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var subMessageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = callDynamically("market", symbol)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("trade::", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trade:", symbol))
                var rawHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var query interface{} = callDynamically("omit", params, "type")
            var subParamsLength interface{} =     ccxt.GetArrayLength(subParams)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, subParamsLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "symbols": symbols,
                "topic": "trades",
            }
        
                retRes134315 :=  (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, query), messageHashes, subscription))
                ccxt.PanicOnError(retRes134315)
                ch <- retRes134315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTrades
 * @description unsubscribes from the trades channel
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BinanceCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13608 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes13608)
        
                retRes136115 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes136115)
                ch <- retRes136115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BinanceCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes138115 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes138115)
                ch <- retRes138115
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public watchTrades
    //
    //     {
    //         "e": "trade",       // event type
    //         "E": 1579481530911, // event time
    //         "s": "ETHBTC",      // symbol
    //         "t": 158410082,     // trade id
    //         "p": "0.01914100",  // price
    //         "q": "0.00700000",  // quantity
    //         "b": 586187049,     // buyer order id
    //         "a": 586186710,     // seller order id
    //         "T": 1579481530910, // trade time
    //         "m": false,         // is the buyer the market maker
    //         "M": true           // binance docs say it should be ignored
    //     }
    //
    //     {
    //        "e": "aggTrade",  // Event type
    //        "E": 123456789,   // Event time
    //        "s": "BNBBTC",    // Symbol
    //        "a": 12345,       // Aggregate trade ID
    //        "p": "0.001",     // Price
    //        "q": "100",       // Quantity
    //        "f": 100,         // First trade ID
    //        "l": 105,         // Last trade ID
    //        "T": 123456785,   // ccxt.Trade time
    //        "m": true,        // Is the buyer the market maker?
    //        "M": true         // Ignore
    //     }
    //
    // private watchMyTrades spot
    //
    //     {
    //         "e": "executionReport",
    //         "E": 1611063861489,
    //         "s": "BNBUSDT",
    //         "c": "m4M6AD5MF3b1ERe65l4SPq",
    //         "S": "BUY",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "2.00000000",
    //         "p": "0.00000000",
    //         "P": "0.00000000",
    //         "F": "0.00000000",
    //         "g": -1,
    //         "C": '',
    //         "x": "TRADE",
    //         "X": "PARTIALLY_FILLED",
    //         "r": "NONE",
    //         "i": 1296882607,
    //         "l": "0.33200000",
    //         "z": "0.33200000",
    //         "L": "46.86600000",
    //         "n": "0.00033200",
    //         "N": "BNB",
    //         "T": 1611063861488,
    //         "t": 109747654,
    //         "I": 2696953381,
    //         "w": false,
    //         "m": false,
    //         "M": true,
    //         "O": 1611063861488,
    //         "Z": "15.55951200",
    //         "Y": "15.55951200",
    //         "Q": "0.00000000"
    //     }
    //
    // private watchMyTrades future/delivery
    //
    //     {
    //         "s": "BTCUSDT",
    //         "c": "pb2jD6ZQHpfzSdUac8VqMK",
    //         "S": "SELL",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "0.001",
    //         "p": "0",
    //         "ap": "33468.46000",
    //         "sp": "0",
    //         "x": "TRADE",
    //         "X": "FILLED",
    //         "i": 13351197194,
    //         "l": "0.001",
    //         "z": "0.001",
    //         "L": "33468.46",
    //         "n": "0.00027086",
    //         "N": "BNB",
    //         "T": 1612095165362,
    //         "t": 458032604,
    //         "b": "0",
    //         "a": "0",
    //         "m": false,
    //         "R": false,
    //         "wt": "CONTRACT_PRICE",
    //         "ot": "MARKET",
    //         "ps": "BOTH",
    //         "cp": false,
    //         "rp": "0.00335000",
    //         "pP": false,
    //         "si": 0,
    //         "ss": 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var executionType interface{} = callDynamically("safeString", trade, "x")
    var isTradeExecution interface{} =     (ccxt.IsEqual(executionType, "TRADE"))
    if !ccxt.IsTrue(isTradeExecution) {
        return callDynamically("parseTrade", trade, market)
    }
    var id interface{} = callDynamically("safeString2", trade, "t", "a")
    var timestamp interface{} = callDynamically("safeInteger", trade, "T")
    var price interface{} = callDynamically("safeString2", trade, "L", "p")
    var amount interface{} = callDynamically("safeString", trade, "q")
    if ccxt.IsTrue(isTradeExecution) {
        amount = callDynamically("safeString", trade, "l", amount)
    }
    var cost interface{} = callDynamically("safeString", trade, "Y")
    if ccxt.IsTrue(ccxt.IsEqual(cost, nil)) {
        if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(price, nil))) && ccxt.IsTrue((!ccxt.IsEqual(amount, nil)))) {
            cost = ccxt.Precise.StringMul(price, amount)
        }
    }
    var marketId interface{} = callDynamically("safeString", trade, "s")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(trade, "ps"))), "contract", "spot")
    var symbol interface{} = callDynamically("safeSymbol", marketId, nil, nil, marketType)
    var side interface{} = callDynamically("safeStringLower", trade, "S")
    var takerOrMaker interface{} = nil
    var orderId interface{} = callDynamically("safeString", trade, "i")
    if ccxt.IsTrue(ccxt.InOp(trade, "m")) {
        if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
            side = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "sell", "buy") // this is reversed intentionally
        }
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "maker", "taker")
    }
    var fee interface{} = nil
    var feeCost interface{} = callDynamically("safeString", trade, "n")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = callDynamically("safeString", trade, "N")
        var feeCurrencyCode interface{} = callDynamically("safeCurrencyCode", feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var typeVar interface{} = callDynamically("safeStringLower", trade, "o")
    return callDynamically("safeTrade", map[string]interface{} {
    "info": trade,
    "timestamp": timestamp,
    "datetime": callDynamically("iso8601", timestamp),
    "symbol": symbol,
    "id": id,
    "order": orderId,
    "type": typeVar,
    "takerOrMaker": takerOrMaker,
    "side": side,
    "price": price,
    "amount": amount,
    "cost": cost,
    "fee": fee,
})
}
func  (this *BinanceCore) HandleTrade(client interface{}, message interface{})  {
    // the trade streams push raw trade information in real-time
    // each trade has a unique buyer and seller
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var marketId interface{} = callDynamically("safeString", message, "s")
    var market interface{} = callDynamically("safeMarket", marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trade::", symbol)
    var trade interface{} = this.ParseWsTrade(message, market)
    var tradesArray interface{} = callDynamically("safeValue", this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = callDynamically("safeInteger", this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    tradesArray.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name binance#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15838 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes15838)
            var market interface{} = callDynamically("market", symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes16068 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes16068)
            var klineType interface{} = nil
            klineTypeparamsVariable := callDynamically("handleParamString2", params, "channel", "name", "kline")
            klineType = ccxt.GetValue(klineTypeparamsVariable,0)
            params = ccxt.GetValue(klineTypeparamsVariable,1)
            var symbols interface{} = callDynamically("getListFromObjectValues", symbolsAndTimeframes, 0)
            var marketSymbols interface{} = callDynamically("marketSymbols", symbols, nil, false, false, true)
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var timezone interface{} = nil
            timezoneparamsVariable := callDynamically("handleParamString", params, "timezone", nil)
            timezone = ccxt.GetValue(timezoneparamsVariable,0)
            params = ccxt.GetValue(timezoneparamsVariable,1)
            var isUtc8 interface{} = ccxt.IsTrue((!ccxt.IsEqual(timezone, nil))) && ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(timezone, "+08:00"))) || ccxt.IsTrue(ccxt.Precise.StringEq(timezone, "8"))))
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symAndTf interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = ccxt.GetValue(symAndTf, 0)
                var timeframeString interface{} = ccxt.GetValue(symAndTf, 1)
                var interval interface{} = callDynamically("safeString", this.Timeframes, timeframeString, timeframeString)
                var market interface{} = callDynamically("market", symbolString)
                var marketId interface{} = ccxt.GetValue(market, "lowercaseId")
                if ccxt.IsTrue(ccxt.IsEqual(klineType, "indexPriceKline")) {
                    // weird behavior for index price kline we can't use the perp suffix
                    marketId = ccxt.Replace(marketId, "_perp", "")
                }
                var shouldUseUTC8 interface{} =         (ccxt.IsTrue(isUtc8) && ccxt.IsTrue(isSpot))
                var suffix interface{} = "@+08:00"
                var utcSuffix interface{} = ccxt.Ternary(ccxt.IsTrue(shouldUseUTC8), suffix, "")
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(marketId, "@"), klineType), "_"), interval), utcSuffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, "multipleOHLCV"))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": rawHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            params = callDynamically("omit", params, "callerMethodName")
        
            res:= (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, params), messageHashes, subscribe))
            ccxt.PanicOnError(res)
            symboltimeframecandlesVariable := res
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = callDynamically("filterBySinceLimit", candles, since, limit, 0, true)
        
            ch <- callDynamically("createOHLCVObject", symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16728 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes16728)
            var klineType interface{} = nil
            klineTypeparamsVariable := callDynamically("handleParamString2", params, "channel", "name", "kline")
            klineType = ccxt.GetValue(klineTypeparamsVariable,0)
            params = ccxt.GetValue(klineTypeparamsVariable,1)
            var symbols interface{} = callDynamically("getListFromObjectValues", symbolsAndTimeframes, 0)
            var marketSymbols interface{} = callDynamically("marketSymbols", symbols, nil, false, false, true)
            var firstMarket interface{} = callDynamically("market", ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var timezone interface{} = nil
            timezoneparamsVariable := callDynamically("handleParamString", params, "timezone", nil)
            timezone = ccxt.GetValue(timezoneparamsVariable,0)
            params = ccxt.GetValue(timezoneparamsVariable,1)
            var isUtc8 interface{} = ccxt.IsTrue((!ccxt.IsEqual(timezone, nil))) && ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(timezone, "+08:00"))) || ccxt.IsTrue(ccxt.Precise.StringEq(timezone, "8"))))
            var rawHashes interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symAndTf interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = ccxt.GetValue(symAndTf, 0)
                var timeframeString interface{} = ccxt.GetValue(symAndTf, 1)
                var interval interface{} = callDynamically("safeString", this.Timeframes, timeframeString, timeframeString)
                var market interface{} = callDynamically("market", symbolString)
                var marketId interface{} = ccxt.GetValue(market, "lowercaseId")
                if ccxt.IsTrue(ccxt.IsEqual(klineType, "indexPriceKline")) {
                    // weird behavior for index price kline we can't use the perp suffix
                    marketId = ccxt.Replace(marketId, "_perp", "")
                }
                var shouldUseUTC8 interface{} =         (ccxt.IsTrue(isUtc8) && ccxt.IsTrue(isSpot))
                var suffix interface{} = "@+08:00"
                var utcSuffix interface{} = ccxt.Ternary(ccxt.IsTrue(shouldUseUTC8), suffix, "")
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(marketId, "@"), klineType), "_"), interval), utcSuffix))
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe::ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, "multipleOHLCV"))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": rawHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "symbols": symbols,
                "symbolsAndTimeframes": symbolsAndTimeframes,
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "topic": "ohlcv",
            }
            params = callDynamically("omit", params, "callerMethodName")
        
                retRes172415 :=  (<-callDynamically("watchMultiple", url, messageHashes, callDynamically("extend", request, params), messageHashes, subscribe))
                ccxt.PanicOnError(retRes172415)
                ch <- retRes172415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17418 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes17418)
            var market interface{} = callDynamically("market", symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
                retRes174515 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes174515)
                ch <- retRes174515
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "kline",
    //         "E": 1579482921215,
    //         "s": "ETHBTC",
    //         "k": {
    //             "t": 1579482900000,
    //             "T": 1579482959999,
    //             "s": "ETHBTC",
    //             "i": "1m",
    //             "f": 158411535,
    //             "L": 158411550,
    //             "o": "0.01913200",
    //             "c": "0.01913500",
    //             "h": "0.01913700",
    //             "l": "0.01913200",
    //             "v": "5.08400000",
    //             "n": 16,
    //             "x": false,
    //             "q": "0.09728060",
    //             "V": "3.30200000",
    //             "Q": "0.06318500",
    //             "B": "0"
    //         }
    //     }
    //
    var event interface{} = callDynamically("safeString", message, "e")
    var eventMap interface{} = map[string]interface{} {
        "indexPrice_kline": "indexPriceKline",
        "markPrice_kline": "markPriceKline",
    }
    event = callDynamically("safeString", eventMap, event, event)
    var kline interface{} = callDynamically("safeValue", message, "k")
    var marketId interface{} = callDynamically("safeString2", kline, "s", "ps")
    if ccxt.IsTrue(ccxt.IsEqual(event, "indexPriceKline")) {
        // indexPriceKline doesn't have the _PERP suffix
        marketId = callDynamically("safeString", message, "ps")
    }
    var interval interface{} = callDynamically("safeString", kline, "i")
    // use a reverse lookup in a static map instead
    var unifiedTimeframe interface{} = callDynamically("findTimeframe", interval)
    var parsed interface{} = []interface{}{callDynamically("safeInteger", kline, "t"), callDynamically("safeFloat", kline, "o"), callDynamically("safeFloat", kline, "h"), callDynamically("safeFloat", kline, "l"), callDynamically("safeFloat", kline, "c"), callDynamically("safeFloat", kline, "v")}
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var symbol interface{} = callDynamically("safeSymbol", marketId, nil, nil, marketType)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), unifiedTimeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, callDynamically("safeValue", this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = callDynamically("safeValue", ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = callDynamically("safeInteger", this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    var resolveData interface{} = []interface{}{symbol, unifiedTimeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
/**
 * @method
 * @name binance#fetchTickerWs
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] method to use can be ticker.price or ticker.book
 * @param {boolean} [params.returnRateLimits] return the rate limits for the exchange
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) FetchTickerWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18258 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes18258)
            var market interface{} = callDynamically("market", symbol)
            var payload interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            var typeVar interface{} = this.GetMarketType("fetchTickerWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchTickerWs only supports swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTickerWs,
            }
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchTickerWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            params = callDynamically("omit", params, "test")
            var method interface{} = nil
            methodparamsVariable := callDynamically("handleOptionAndParams", params, "fetchTickerWs", "method", "ticker.book")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
        
            ticker:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(ticker)
        
            ch <- ticker
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOHLCVWs
 * @description query historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @param {string} symbol unified symbol of the market to query ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} since timestamp in ms of the earliest candle to fetch
 * @param {int} limit the maximum amount of candles to fetch
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {int} params.until timestamp in ms of the earliest candle to fetch
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} params.timeZone default=0 (UTC)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) FetchOHLCVWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18738 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes18738)
            var market interface{} = callDynamically("market", symbol)
            var marketType interface{} = this.GetMarketType("fetchOHLCVWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOHLCVWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchOHLCVWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
                "interval": ccxt.GetValue(this.Timeframes, timeframe),
            }
            var until interface{} = callDynamically("safeInteger", params, "until")
            params = callDynamically("omit", params, "until")
            if ccxt.IsTrue(!ccxt.IsEqual(since, nil)) {
                ccxt.AddElementToObject(payload, "startTime", since)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(until, nil)) {
                ccxt.AddElementToObject(payload, "endTime", until)
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "klines",
                "params": callDynamically("extend", payload, params),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleFetchOHLCV,
            }
        
                retRes190915 :=  (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes190915)
                ch <- retRes190915
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleFetchOHLCV(client interface{}, message interface{})  {
    //
    // JSON format:
    //    {
    //        "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
    //        "status": 200,
    //        "result": [
    //            [
    //                1655971200000,      // Kline open time
    //                "0.01086000",       // Open price
    //                "0.01086600",       // High price
    //                "0.01083600",       // Low price
    //                "0.01083800",       // Close price
    //                "2290.53800000",    // Volume
    //                1655974799999,      // Kline close time
    //                "24.85074442",      // Quote asset volume
    //                2283,               // ccxt.Number of trades
    //                "1171.64000000",    // Taker buy base asset volume
    //                "12.71225884",      // Taker buy quote asset volume
    //                "0"                 // Unused field, ignore
    //            ]
    //        ],
    //        "rateLimits": [...]
    //    }
    //
    // SBE format (decoded):
    //    {
    //        "id": "...",
    //        "status": 200,
    //        "result": {
    //            "priceExponent": -8,
    //            "qtyExponent": -8,
    //            "klines": [
    //                {
    //                    "openTime": 1655971200000000,    // microseconds
    //                    "openPrice": 1086000,            // mantissa
    //                    "highPrice": 1086600,
    //                    "lowPrice": 1083600,
    //                    "closePrice": 1083800,
    //                    "volume": [...],                 // mantissa128 as byte array
    //                    "closeTime": 1655974799999000,
    //                    "quoteVolume": [...],
    //                    "numTrades": 2283,
    //                    "takerBuyBaseVolume": [...],
    //                    "takerBuyQuoteVolume": [...]
    //                }
    //            ]
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeValue", message, "result")
    var parsed interface{} = []interface{}{}
    // Check if result is already decoded (SBE format) or needs parsing (JSON format)
    if ccxt.IsTrue(!ccxt.IsEqual(result, nil)) {
        if ccxt.IsTrue(ccxt.IsArray(result)) {
            // JSON format - result is directly the array of klines (array of arrays)
            parsed = callDynamically("parseOHLCVs", result)
        } else if ccxt.IsTrue(ccxt.IsObject(result)) {
            // SBE format - result is an object with klines array and exponents
            var klinesArray interface{} = callDynamically("safeList", result, "klines", []interface{}{})
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(klinesArray), 0)) {
                // Get exponents for converting mantissa values
                var priceExponent interface{} = callDynamically("safeInteger", result, "priceExponent", 0)
                var qtyExponent interface{} = callDynamically("safeInteger", result, "qtyExponent", 0)
                // Convert mantissa values to standard ccxt.OHLCV format
                var normalizedKlines interface{} = []interface{}{}
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(klinesArray)); i++ {
                    var kline interface{} = ccxt.GetValue(klinesArray, i)
                    // Convert mantissa128 byte arrays to numbers
                    var volume interface{} = callDynamically("mantissa128ToNumber", kline.Volume)
                    var openTime interface{} = ccxt.MathFloor(ccxt.Divide(kline.OpenTime, 1000)) // microseconds to milliseconds
                    var openPrice interface{} = callDynamically("applyExponent", kline.OpenPrice, priceExponent)
                    var highPrice interface{} = callDynamically("applyExponent", kline.HighPrice, priceExponent)
                    var lowPrice interface{} = callDynamically("applyExponent", kline.LowPrice, priceExponent)
                    var closePrice interface{} = callDynamically("applyExponent", kline.ClosePrice, priceExponent)
                    var vol interface{} = callDynamically("applyExponent", volume, qtyExponent)
                    var closeTime interface{} = ccxt.MathFloor(ccxt.Divide(kline.CloseTime, 1000))
                    var quoteVolume interface{} = callDynamically("mantissa128ToNumber", kline.QuoteVolume)
                    var quoteVol interface{} = callDynamically("applyExponent", quoteVolume, priceExponent)
                    var numTrades interface{} = kline.NumTrades
                    var takerBuyBaseVolume interface{} = callDynamically("mantissa128ToNumber", kline.TakerBuyBaseVolume)
                    var takerBuyBase interface{} = callDynamically("applyExponent", takerBuyBaseVolume, qtyExponent)
                    var takerBuyQuoteVolume interface{} = callDynamically("mantissa128ToNumber", kline.TakerBuyQuoteVolume)
                    var takerBuyQuote interface{} = callDynamically("applyExponent", takerBuyQuoteVolume, priceExponent)
                    ccxt.AppendToArray(&normalizedKlines, []interface{}{openTime, ccxt.String(openPrice), ccxt.String(highPrice), ccxt.String(lowPrice), ccxt.String(closePrice), ccxt.String(vol), closeTime, ccxt.String(quoteVol), numTrades, ccxt.String(takerBuyBase), ccxt.String(takerBuyQuote), "0"})
                }
                parsed = callDynamically("parseOHLCVs", normalizedKlines)
            }
        }
    }
    client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
}
/**
 * @method
 * @name binance#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] stream to use can be ticker or miniTicker
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20358 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes20358)
            symbol = callDynamically("symbol", symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, callDynamically("extend", params, map[string]interface{} {
            "callerMethodName": "watchTicker",
        })))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMarkPrice
 * @description watches a mark price for a specific market
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20528 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes20528)
            symbol = callDynamically("symbol", symbol)
        
            tickers:= (<-this.WatchMarkPrices([]interface{}{symbol}, callDynamically("extend", params, map[string]interface{} {
            "callerMethodName": "watchMarkPrice",
        })))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMarkPrices
 * @description watches the mark price for all markets
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream-for-All-market
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            // for now watchmarkPrice uses the same messageHash as watchTicker
            // so it's impossible to watch both at the same time
            // refactor this to use different messageHashes
            channelNameparamsVariable := callDynamically("handleOptionAndParams", params, "watchMarkPrices", "name", "markPrice")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
        
            newTickers:= (<-this.WatchMultiTickerHelper("watchMarkPrices", channelName, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- callDynamically("filterByArray", this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            channelNameparamsVariable := callDynamically("handleOptionAndParams", params, "watchTickers", "name", "ticker")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(channelName, "bookTicker")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead"));return nil
            }
        
            newTickers:= (<-this.WatchMultiTickerHelper("watchTickers", channelName, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- callDynamically("filterByArray", this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            channelNameparamsVariable := callDynamically("handleOptionAndParams", params, "watchTickers", "name", "ticker")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(channelName, "bookTicker")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead"));return nil
            }
        
                retRes212815 :=  (<-this.WatchMultiTickerHelper("unWatchTickers", channelName, symbols, params, true))
                ccxt.PanicOnError(retRes212815)
                ch <- retRes212815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchMarkPrices
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            channelNameparamsVariable := callDynamically("handleOptionAndParams", params, "watchMarkPrices", "name", "markPrice")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
        
            retRes21438 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes21438)
        
                retRes214415 :=  (<-this.WatchMultiTickerHelper("unWatchMarkPrices", channelName, symbols, params, true))
                ccxt.PanicOnError(retRes214415)
                ch <- retRes214415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchMarkPrice
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes215715 :=  (<-this.UnWatchMarkPrices([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes215715)
                ch <- retRes215715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes217515 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes217515)
                ch <- retRes217515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#symbol-order-book-ticker
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Book-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Book-ccxt.Tickers-Stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21908 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes21908)
            symbols = callDynamically("marketSymbols", symbols, nil, true, false, true)
        
            result:= (<-this.WatchMultiTickerHelper("watchBidsAsks", "bookTicker", symbols, params))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- result
                return nil
            }
        
            ch <- callDynamically("filterByArray", this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) WatchMultiTickerHelper(methodName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            isUnsubscribe := ccxt.GetArg(optionalArgs, 2, false)
            _ = isUnsubscribe
        
            retRes22008 := (<-callDynamically("loadMarkets", ))
            ccxt.PanicOnError(retRes22008)
            symbols = callDynamically("marketSymbols", symbols, nil, true, false, true)
            var isBidAsk interface{} =     (ccxt.IsEqual(channelName, "bookTicker"))
            var isMarkPrice interface{} =     (ccxt.IsEqual(channelName, "markPrice"))
            var use1sFreq interface{} = callDynamically("safeBool", params, "use1sFreq", true)
            var firstMarket interface{} = nil
            var marketType interface{} = nil
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                firstMarket = callDynamically("market", ccxt.GetValue(symbols, 0))
            }
            var defaultMarket interface{} = ccxt.Ternary(ccxt.IsTrue((isMarkPrice)), "swap", nil)
            marketTypeparamsVariable := callDynamically("handleMarketTypeAndParams", methodName, firstMarket, params, defaultMarket)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", methodName, firstMarket, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var rawMarketType interface{} = nil
            if ccxt.IsTrue(callDynamically("isLinear", marketType, subType)) {
                rawMarketType = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", marketType, subType)) {
                rawMarketType = "delivery"
            } else if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                rawMarketType = marketType
            } else {
                ccxt.ThrowDynamicException(ccxt.NotSupported, ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() does not support options markets"));return nil
            }
            if ccxt.IsTrue(ccxt.IsTrue(isMarkPrice) && !ccxt.IsTrue(callDynamically("inArray", marketType, []interface{}{"swap", "future"}))) {
                ccxt.ThrowDynamicException(ccxt.NotSupported, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() does not support "), marketType), " markets yet"));return nil
            }
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var unsubscribeMessageHashes interface{} = []interface{}{}
            var suffix interface{} = ""
            if ccxt.IsTrue(isMarkPrice) {
                suffix = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
            }
            var unifiedPrefix interface{} = nil
            if ccxt.IsTrue(isBidAsk) {
                unifiedPrefix = "bidask"
            } else if ccxt.IsTrue(isMarkPrice) {
                unifiedPrefix = "markPrice"
            } else {
                unifiedPrefix = "ticker"
            }
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = callDynamically("market", symbol)
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), channelName), suffix))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(unifiedPrefix, ":"), channelName), "@"), symbol))
                    if ccxt.IsTrue(isUnsubscribe) {
                        ccxt.AppendToArray(&unsubscribeMessageHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe::", unifiedPrefix), ":"), channelName), "@"), symbol))
                    }
                }
            } else {
                if ccxt.IsTrue(isBidAsk) {
                    if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                        ccxt.ThrowDynamicException(ccxt.ArgumentsRequired, ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires symbols for this channel for spot markets"));return nil
                    }
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add("!", channelName))
                } else if ccxt.IsTrue(isMarkPrice) {
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(ccxt.Add("!", channelName), "@arr"), suffix))
                } else {
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add("!", channelName), "@arr"))
                }
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(unifiedPrefix, "s:"), channelName))
                ccxt.AppendToArray(&unsubscribeMessageHashes, ccxt.Add("unsubscribe::", channelName))
            }
            var streamHash interface{} = channelName
            if ccxt.IsTrue(symbolsDefined) {
                streamHash = ccxt.Add(ccxt.Add(channelName, "::"), ccxt.Join(symbols, ","))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), rawMarketType), "/"), this.Stream(rawMarketType, streamHash))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": ccxt.Ternary(ccxt.IsTrue(isUnsubscribe), "UNSUBSCRIBE", "SUBSCRIBE"),
                "params": subscriptionArgs,
                "id": requestId,
            }
            var hashes interface{} = messageHashes
            var subscription interface{} = map[string]interface{} {
                "id": requestId,
            }
            if ccxt.IsTrue(isUnsubscribe) {
                subscription = map[string]interface{} {
                    "unsubscribe": true,
                    "id": ccxt.ToString(requestId),
                    "subMessageHashes": messageHashes,
                    "messageHashes": unsubscribeMessageHashes,
                    "symbols": symbols,
                    "topic": "ticker",
                }
                hashes = unsubscribeMessageHashes
            }
        
            result:= (<-callDynamically("watchMultiple", url, hashes, callDynamically("deepExtend", request, params), hashes, subscription))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(isUnsubscribe) {
        
                ch <- result
                return nil
            }
            // for efficiency, we have two type of returned structure here - if symbols array was provided, then individual
            // ticker dict comes in, otherwise all-tickers dict comes in
            if !ccxt.IsTrue(symbolsDefined) {
        
                ch <- result
                return nil
            } else {
                var newDict interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(newDict, ccxt.GetValue(result, "symbol"), result)
        
                ch <- newDict
                return nil
            }
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsTicker(message interface{}, marketType interface{}) interface{}  {
    // markPrice
    //   {
    //       "e": "markPriceUpdate",   // Event type
    //       "E": 1562305380000,       // Event time
    //       "s": "BTCUSDT",           // Symbol
    //       "p": "11794.15000000",    // Mark price
    //       "i": "11784.62659091",    // Index price
    //       "P": "11784.25641265",    // Estimated Settle Price, only useful in the last hour before the settlement starts
    //       "r": "0.00038167",        // Funding rate
    //       "T": 1562306400000        // Next funding time
    //   }
    //
    // ticker
    //     {
    //         "e": "24hrTicker",      // event type
    //         "E": 1579485598569,     // event time
    //         "s": "ETHBTC",          // symbol
    //         "p": "-0.00004000",     // price change
    //         "P": "-0.209",          // price change percent
    //         "w": "0.01920495",      // weighted average price
    //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
    //         "c": "0.01912500",      // last (closing) price
    //         "Q": "0.10400000",      // last quantity
    //         "b": "0.01912200",      // best bid
    //         "B": "4.10400000",      // best bid quantity
    //         "a": "0.01912500",      // best ask
    //         "A": "0.00100000",      // best ask quantity
    //         "o": "0.01916500",      // open price
    //         "h": "0.01956500",      // high price
    //         "l": "0.01887700",      // low price
    //         "v": "173518.11900000", // base volume
    //         "q": "3332.40703994",   // quote volume
    //         "O": 1579399197842,     // open time
    //         "C": 1579485597842,     // close time
    //         "F": 158251292,         // first trade id
    //         "L": 158414513,         // last trade id
    //         "n": 163222,            // total number of trades
    //     }
    //
    // miniTicker
    //     {
    //         "e": "24hrMiniTicker",
    //         "E": 1671617114585,
    //         "s": "MOBBUSD",
    //         "c": "0.95900000",
    //         "o": "0.91200000",
    //         "h": "1.04000000",
    //         "l": "0.89400000",
    //         "v": "2109995.32000000",
    //         "q": "2019254.05788000"
    //     }
    // fetchTickerWs
    //     {
    //         "symbol":"BTCUSDT",
    //         "price":"72606.70",
    //         "time":1712526204284
    //     }
    // fetchTickerWs - ticker.book
    //     {
    //         "lastUpdateId":1027024,
    //         "symbol":"BTCUSDT",
    //         "bidPrice":"4.00000000",
    //         "bidQty":"431.00000000",
    //         "askPrice":"4.00000200",
    //         "askQty":"9.00000000",
    //         "time":1589437530011,
    //      }
    //
    var marketId interface{} = callDynamically("safeString2", message, "s", "symbol")
    var symbol interface{} = callDynamically("safeSymbol", marketId, nil, nil, marketType)
    var event interface{} = callDynamically("safeString", message, "e", "bookTicker")
    if ccxt.IsTrue(ccxt.IsEqual(event, "24hrTicker")) {
        event = "ticker"
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "markPriceUpdate")) {
        // handle this separately because some fields clash with the ticker fields
        return callDynamically("safeTicker", map[string]interface{} {
    "symbol": symbol,
    "timestamp": callDynamically("safeInteger", message, "E"),
    "datetime": callDynamically("iso8601", callDynamically("safeInteger", message, "E")),
    "info": message,
    "markPrice": callDynamically("safeString", message, "p"),
    "indexPrice": callDynamically("safeString", message, "i"),
})
    }
    var timestamp interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(event, "bookTicker")) {
        // take the event timestamp, if available, for spot tickers it is not
        timestamp = callDynamically("safeInteger2", message, "E", "time")
    } else {
        // take the timestamp of the closing price for candlestick streams
        timestamp = callDynamically("safeIntegerN", message, []interface{}{"C", "E", "time"})
    }
    var market interface{} = callDynamically("safeMarket", marketId, nil, nil, marketType)
    var last interface{} = callDynamically("safeString2", message, "c", "price")
    return callDynamically("safeTicker", map[string]interface{} {
    "symbol": symbol,
    "timestamp": timestamp,
    "datetime": callDynamically("iso8601", timestamp),
    "high": callDynamically("safeString", message, "h"),
    "low": callDynamically("safeString", message, "l"),
    "bid": callDynamically("safeString2", message, "b", "bidPrice"),
    "bidVolume": callDynamically("safeString2", message, "B", "bidQty"),
    "ask": callDynamically("safeString2", message, "a", "askPrice"),
    "askVolume": callDynamically("safeString2", message, "A", "askQty"),
    "vwap": callDynamically("safeString", message, "w"),
    "open": callDynamically("safeString", message, "o"),
    "close": last,
    "last": last,
    "previousClose": callDynamically("safeString", message, "x"),
    "change": callDynamically("safeString", message, "p"),
    "percentage": callDynamically("safeString", message, "P"),
    "average": nil,
    "baseVolume": callDynamically("safeString", message, "v"),
    "quoteVolume": callDynamically("safeString", message, "q"),
    "info": message,
}, market)
}
func  (this *BinanceCore) HandleTickerWs(client interface{}, message interface{})  {
    //
    // JSON format - ticker.price
    //    {
    //        "id":"1",
    //        "status":200,
    //        "result":{
    //            "symbol":"BTCUSDT",
    //            "price":"73178.50",
    //            "time":1712527052374
    //        }
    //    }
    // JSON format - ticker.book
    //    {
    //        "id":"9d32157c-a556-4d27-9866-66760a174b57",
    //        "status":200,
    //        "result":{
    //            "lastUpdateId":1027024,
    //            "symbol":"BTCUSDT",
    //            "bidPrice":"4.00000000",
    //            "bidQty":"431.00000000",
    //            "askPrice":"4.00000200",
    //            "askQty":"9.00000000",
    //            "time":1589437530011   // ccxt.Transaction time
    //        }
    //    }
    //
    // SBE format - PriceTickerSymbolResponse
    //    {
    //        "id":"1",
    //        "status":200,
    //        "result":{
    //            "priceExponent": -8,
    //            "price": 7317850000000,  // mantissa
    //            "symbol":"BTCUSDT"
    //        }
    //    }
    // SBE format - BookTickerSymbolResponse
    //    {
    //        "id":"...",
    //        "status":200,
    //        "result":{
    //            "priceExponent": -8,
    //            "qtyExponent": -8,
    //            "bidPrice": 400000000,    // mantissa
    //            "bidQty": 43100000000,
    //            "askPrice": 400000200,
    //            "askQty": 900000000,
    //            "symbol":"BTCUSDT"
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeValue", message, "result", map[string]interface{} {})
    // Check if SBE format (has exponent fields)
    var priceExponent interface{} = callDynamically("safeInteger", result, "priceExponent")
    if ccxt.IsTrue(!ccxt.IsEqual(priceExponent, nil)) {
        // SBE format - normalize to JSON format
        var qtyExponent interface{} = callDynamically("safeInteger", result, "qtyExponent", 0)
        var normalized interface{} = map[string]interface{} {
            "symbol": callDynamically("safeString", result, "symbol"),
        }
        // Handle price field (for ticker.price)
        var priceMantissa interface{} = callDynamically("safeInteger", result, "price")
        if ccxt.IsTrue(!ccxt.IsEqual(priceMantissa, nil)) {
            ccxt.AddElementToObject(normalized, "price", ccxt.String(callDynamically("applyExponent", priceMantissa, priceExponent)))
        }
        // Handle bid/ask fields (for ticker.book)
        var bidPriceMantissa interface{} = callDynamically("safeInteger", result, "bidPrice")
        if ccxt.IsTrue(!ccxt.IsEqual(bidPriceMantissa, nil)) {
            ccxt.AddElementToObject(normalized, "bidPrice", ccxt.String(callDynamically("applyExponent", bidPriceMantissa, priceExponent)))
        }
        var bidQtyMantissa interface{} = callDynamically("safeInteger", result, "bidQty")
        if ccxt.IsTrue(!ccxt.IsEqual(bidQtyMantissa, nil)) {
            ccxt.AddElementToObject(normalized, "bidQty", ccxt.String(callDynamically("applyExponent", bidQtyMantissa, qtyExponent)))
        }
        var askPriceMantissa interface{} = callDynamically("safeInteger", result, "askPrice")
        if ccxt.IsTrue(!ccxt.IsEqual(askPriceMantissa, nil)) {
            ccxt.AddElementToObject(normalized, "askPrice", ccxt.String(callDynamically("applyExponent", askPriceMantissa, priceExponent)))
        }
        var askQtyMantissa interface{} = callDynamically("safeInteger", result, "askQty")
        if ccxt.IsTrue(!ccxt.IsEqual(askQtyMantissa, nil)) {
            ccxt.AddElementToObject(normalized, "askQty", ccxt.String(callDynamically("applyExponent", askQtyMantissa, qtyExponent)))
        }
        // Copy other fields
        var lastUpdateId interface{} = callDynamically("safeInteger", result, "lastUpdateId")
        if ccxt.IsTrue(!ccxt.IsEqual(lastUpdateId, nil)) {
            ccxt.AddElementToObject(normalized, "lastUpdateId", lastUpdateId)
        }
        result = normalized
    }
    var ticker interface{} = this.ParseWsTicker(result, "future")
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *BinanceCore) HandleBidsAsks(client interface{}, message interface{})  {
    //
    // arrives one symbol dict or array of symbol dicts
    //
    //     {
    //         "u": 7488717758,
    //         "s": "BTCUSDT",
    //         "b": "28621.74000000",
    //         "B": "1.43278800",
    //         "a": "28621.75000000",
    //         "A": "2.52500800"
    //     }
    //
    this.HandleTickersAndBidsAsks(client, message, "bidasks")
}
func  (this *BinanceCore) HandleTickers(client interface{}, message interface{})  {
    //
    // arrives one symbol dict or array of symbol dicts
    //
    //     {
    //         "e": "24hrTicker",      // event type
    //         "E": 1579485598569,     // event time
    //         "s": "ETHBTC",          // symbol
    //         "p": "-0.00004000",     // price change
    //         "P": "-0.209",          // price change percent
    //         "w": "0.01920495",      // weighted average price
    //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
    //         "c": "0.01912500",      // last (closing) price
    //         "Q": "0.10400000",      // last quantity
    //         "b": "0.01912200",      // best bid
    //         "B": "4.10400000",      // best bid quantity
    //         "a": "0.01912500",      // best ask
    //         "A": "0.00100000",      // best ask quantity
    //         "o": "0.01916500",      // open price
    //         "h": "0.01956500",      // high price
    //         "l": "0.01887700",      // low price
    //         "v": "173518.11900000", // base volume
    //         "q": "3332.40703994",   // quote volume
    //         "O": 1579399197842,     // open time
    //         "C": 1579485597842,     // close time
    //         "F": 158251292,         // first trade id
    //         "L": 158414513,         // last trade id
    //         "n": 163222,            // total number of trades
    //     }
    //
    this.HandleTickersAndBidsAsks(client, message, "tickers")
}
func  (this *BinanceCore) HandleMarkPrices(client interface{}, message interface{})  {
    this.HandleTickersAndBidsAsks(client, message, "markPrices")
}
func  (this *BinanceCore) HandleTickersAndBidsAsks(client interface{}, message interface{}, methodType interface{})  {
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var isBidAsk interface{} =     (ccxt.IsEqual(methodType, "bidasks"))
    var isMarkPrice interface{} =     (ccxt.IsEqual(methodType, "markPrices"))
    var unifiedPrefix interface{} = nil
    if ccxt.IsTrue(isBidAsk) {
        unifiedPrefix = "bidask"
    } else if ccxt.IsTrue(isMarkPrice) {
        unifiedPrefix = "markPrice"
    } else {
        unifiedPrefix = "ticker"
    }
    var channelName interface{} = nil
    var resolvedMessageHashes interface{} = []interface{}{}
    var rawTickers interface{} = []interface{}{}
    var newTickers interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        rawTickers = message
    } else {
        ccxt.AppendToArray(&rawTickers, message)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTickers)); i++ {
        var ticker interface{} = ccxt.GetValue(rawTickers, i)
        var event interface{} = callDynamically("safeString", ticker, "e")
        if ccxt.IsTrue(isBidAsk) {
            event = "bookTicker" // as noted in `handleMessage`, bookTicker doesn't have identifier, so manually set here
        }
        channelName = callDynamically("safeString", ccxt.GetValue(this.Options, "tickerChannelsMap"), event, event)
        if ccxt.IsTrue(ccxt.IsEqual(channelName, nil)) {
            continue
        }
        var parsedTicker interface{} = this.ParseWsTicker(ticker, marketType)
        var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
        ccxt.AddElementToObject(newTickers, symbol, parsedTicker)
        if ccxt.IsTrue(isBidAsk) {
            ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
        } else {
            ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
        }
        var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(unifiedPrefix, ":"), channelName), "@"), symbol)
        ccxt.AppendToArray(&resolvedMessageHashes, messageHash)
        client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
    }
    // resolve batch endpoint
    var length interface{} =     ccxt.GetArrayLength(resolvedMessageHashes)
    if ccxt.IsTrue(ccxt.IsGreaterThan(length, 0)) {
        var batchMessageHash interface{} = ccxt.Add(ccxt.Add(unifiedPrefix, "s:"), channelName)
        client.(ccxt.ClientInterface).Resolve(newTickers, batchMessageHash)
    }
}
func  (this *BinanceCore) SignParams(optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    callDynamically("checkRequiredCredentials", )
    var defaultRecvWindow interface{} = callDynamically("safeInteger", this.Options, "recvWindow")
    if ccxt.IsTrue(!ccxt.IsEqual(defaultRecvWindow, nil)) {
        ccxt.AddElementToObject(params, "recvWindow", defaultRecvWindow)
    }
    var recvWindow interface{} = callDynamically("safeInteger", params, "recvWindow")
    if ccxt.IsTrue(!ccxt.IsEqual(recvWindow, nil)) {
        ccxt.AddElementToObject(params, "recvWindow", recvWindow)
    }
    var extendedParams interface{} = callDynamically("extend", map[string]interface{} {
    "timestamp": callDynamically("nonce", ),
    "apiKey": this.ApiKey,
}, params)
    extendedParams = callDynamically("keysort", extendedParams)
    var query interface{} = callDynamically("rawencode", extendedParams)
    var signature interface{} = nil
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(this.Secret, "PRIVATE KEY"), ccxt.OpNeg(1))) {
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(this.Secret), 120)) {
            signature = ccxt.Rsa(query, this.Secret, ccxt.Sha256)
        } else {
            signature = ccxt.Eddsa(callDynamically("encode", query), this.Secret, ccxt.Ed25519)
        }
    } else {
        signature = callDynamically("hmac", callDynamically("encode", query), callDynamically("encode", this.Secret), ccxt.Sha256)
    }
    ccxt.AddElementToObject(extendedParams, "signature", signature)
    return extendedParams
}
/**
 * @name binance#ensureUserDataStreamWsSubscribeSignature
 * @description watches best bid & ask for symbols
 * @param marketType {string} only support on 'spot'
 * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/user-data-stream-requests#subscribe-to-user-data-stream-through-signature-subscription-user_data Binance User Data Stream Documentation}
 * @returns Promise<number> The subscription ID for the user data stream
 */
func  (this *BinanceCore) EnsureUserDataStreamWsSubscribeSignature(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    marketType := ccxt.GetArg(optionalArgs, 0, "spot")
            _ = marketType
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var client interface{} = this.Client(url)
            var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
            var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
            var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
            if ccxt.IsTrue(ccxt.IsEqual(accountType, marketType)) {
        
                return nil
            }
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), marketType, true)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "userDataStream.subscribe.signature",
                "params": this.SignParams(map[string]interface{} {}),
            }
            var subscription interface{} = map[string]interface{} {
                "id": messageHash,
                "method": this.HandleUserDataStreamSubscribe,
                "subscription": marketType,
            }
        
            retRes26888 := (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(retRes26888)
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandleUserDataStreamSubscribe(client interface{}, message interface{})  {
    //
    //   {
    //     "id": 1,
    //     "status": 200,
    //     "result": {
    //         "subscriptionId": 0
    //     }
    //   }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var result interface{} = callDynamically("safeDict", message, "result", map[string]interface{} {})
    var subscriptionId interface{} = callDynamically("safeInteger", result, "subscriptionId")
    if ccxt.IsTrue(ccxt.IsEqual(subscriptionId, nil)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), accountType)
        client.(ccxt.ClientInterface).Reject(message, accountType)
    }
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
}
func  (this *BinanceCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var time interface{} = callDynamically("milliseconds", )
            var typeVar interface{} = nil
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "authenticate", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "authenticate", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "authenticate", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            // For spot use WebSocket API signature subscription
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        
                retRes272912 := (<-this.EnsureUserDataStreamWsSubscribeSignature("spot"))
                ccxt.PanicOnError(retRes272912)
        
                return nil
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := callDynamically("handleMarginModeAndParams", "authenticate", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var isIsolatedMargin interface{} =     (ccxt.IsEqual(marginMode, "isolated"))
            var isCrossMargin interface{} = ccxt.IsTrue((ccxt.IsEqual(marginMode, "cross"))) || ccxt.IsTrue((ccxt.IsEqual(marginMode, nil)))
            var symbol interface{} = callDynamically("safeString", params, "symbol")
            params = callDynamically("omit", params, "symbol")
            var options interface{} = callDynamically("safeValue", this.Options, typeVar, map[string]interface{} {})
            var lastAuthenticatedTime interface{} = callDynamically("safeInteger", options, "lastAuthenticatedTime", 0)
            var listenKeyRefreshRate interface{} = callDynamically("safeInteger", this.Options, "listenKeyRefreshRate", 1200000)
            var delay interface{} = callDynamically("sum", listenKeyRefreshRate, 10000)
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), delay)) {
                var response interface{} = nil
                if ccxt.IsTrue(isPortfolioMargin) {
                    
            response = (<-callDynamically("papiPostListenKey", params))
                        ccxt.PanicOnError(response)
                    params = callDynamically("extend", params, map[string]interface{} {
            "portfolioMargin": true,
        })
                } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                    
            response = (<-callDynamically("fapiPrivatePostListenKey", params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "delivery")) {
                    
            response = (<-callDynamically("dapiPrivatePostListenKey", params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) && ccxt.IsTrue(isCrossMargin)) {
                    
            response = (<-callDynamically("sapiPostUserDataStream", params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(isIsolatedMargin) {
                    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                        ccxt.ThrowDynamicException(ccxt.ArgumentsRequired, ccxt.Add(this.Id, " authenticate() requires a symbol argument for isolated margin mode"));return nil
                    }
                    var marketId interface{} = callDynamically("marketId", symbol)
                    params = callDynamically("extend", params, map[string]interface{} {
            "symbol": marketId,
        })
                    
            response = (<-callDynamically("sapiPostUserDataStreamIsolated", params))
                        ccxt.PanicOnError(response)
                } else {
                    
            response = (<-callDynamically("publicPostUserDataStream", params))
                        ccxt.PanicOnError(response)
                }
                ccxt.AddElementToObject(this.Options, typeVar, callDynamically("extend", options, map[string]interface{} {
            "listenKey": callDynamically("safeString", response, "listenKey"),
            "lastAuthenticatedTime": time,
        }))
                callDynamically("delay", listenKeyRefreshRate, this.KeepAliveListenKey, params)
            }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
            params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = callDynamically("safeString2", this.Options, "defaultType", "authenticate", "spot")
            typeVar = callDynamically("safeString", params, "type", typeVar)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "keepAliveListenKey", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var subTypeInfo interface{} = callDynamically("handleSubTypeAndParams", "keepAliveListenKey", nil, params)
            var subType interface{} = ccxt.GetValue(subTypeInfo, 0)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            var options interface{} = callDynamically("safeValue", this.Options, typeVar, map[string]interface{} {})
            var listenKey interface{} = callDynamically("safeString", options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            var request interface{} = map[string]interface{} {}
            var symbol interface{} = callDynamically("safeString", params, "symbol")
            params = callDynamically("omit", params, []interface{}{"type", "symbol"})
            var time interface{} = callDynamically("milliseconds", )
            
                {
                     func(this *BinanceCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *BinanceCore) interface{} {
                                    // catch block:
                                            var urlType interface{} = typeVar
                    if ccxt.IsTrue(isPortfolioMargin) {
                        urlType = "papi"
                    }
                    var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
                    var client interface{} = this.Client(url)
                    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
                        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
                        client.(ccxt.ClientInterface).Reject(error, messageHash)
                    }
                    ccxt.AddElementToObject(this.Options, typeVar, callDynamically("extend", options, map[string]interface{} {
                "listenKey": nil,
                "lastAuthenticatedTime": 0,
            }))
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                                if ccxt.IsTrue(isPortfolioMargin) {
            
                        retRes279616 := (<-callDynamically("papiPutListenKey", callDynamically("extend", request, params)))
                        ccxt.PanicOnError(retRes279616)
                        params = callDynamically("extend", params, map[string]interface{} {
                "portfolioMargin": true,
            })
                    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
            
                        retRes279916 := (<-callDynamically("fapiPrivatePutListenKey", callDynamically("extend", request, params)))
                        ccxt.PanicOnError(retRes279916)
                    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "delivery")) {
            
                        retRes280116 := (<-callDynamically("dapiPrivatePutListenKey", callDynamically("extend", request, params)))
                        ccxt.PanicOnError(retRes280116)
                    } else {
                        ccxt.AddElementToObject(request, "listenKey", listenKey)
                        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) {
                            ccxt.AddElementToObject(request, "symbol", symbol)
            
                            retRes280620 := (<-callDynamically("sapiPutUserDataStream", callDynamically("extend", request, params)))
                            ccxt.PanicOnError(retRes280620)
                        } else {
            
                            retRes280820 := (<-callDynamically("publicPutUserDataStream", callDynamically("extend", request, params)))
                            ccxt.PanicOnError(retRes280820)
                        }
                    }
            		    return nil
            	    }(this)
                
                    }
            ccxt.AddElementToObject(this.Options, typeVar, callDynamically("extend", options, map[string]interface{} {
            "listenKey": listenKey,
            "lastAuthenticatedTime": time,
        }))
            // whether or not to schedule another listenKey keepAlive request
            var clients interface{} = ccxt.ObjectValues(this.Clients)
            var listenKeyRefreshRate interface{} = callDynamically("safeInteger", this.Options, "listenKeyRefreshRate", 1200000)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(clients)); i++ {
                var client interface{} = ccxt.GetValue(clients, i)
                var subscriptionKeys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(subscriptionKeys)); j++ {
                    var subscribeType interface{} = ccxt.GetValue(subscriptionKeys, j)
                    if ccxt.IsTrue(ccxt.IsEqual(subscribeType, typeVar)) {
                        callDynamically("delay", listenKeyRefreshRate, this.KeepAliveListenKey, params)
        
                        return nil
                    }
                }
            }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) SetBalanceCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    isPortfolioMargin := ccxt.GetArg(optionalArgs, 0, false)
    _ = isPortfolioMargin
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), typeVar))) && ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar)))) {
        return
    }
    var options interface{} = callDynamically("safeValue", this.Options, "watchBalance")
    var fetchBalanceSnapshot interface{} = callDynamically("safeBool", options, "fetchBalanceSnapshot", false)
    if ccxt.IsTrue(fetchBalanceSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            callDynamically("spawn", this.LoadBalanceSnapshot, client, messageHash, typeVar, isPortfolioMargin)
        }
    } else {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
}
func  (this *BinanceCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}, isPortfolioMargin interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
            if ccxt.IsTrue(isPortfolioMargin) {
                ccxt.AddElementToObject(params, "portfolioMargin", true)
            }
        
            response:= (<-callDynamically("fetchBalance", params))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, callDynamically("extend", response, callDynamically("safeValue", this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve()
                client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchBalanceWs
 * @description fetch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/websocket-api/Futures-ccxt.Account-ccxt.Balance
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-information-user_data
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/websocket-api
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot'
 * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
 * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
 * @param {string|undefined} [params.method] method to use. Can be account.balance, account.status, v2/account.balance or v2/account.status
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BinanceCore) FetchBalanceWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes26418)
            var typeVar interface{} = this.GetMarketType("fetchBalanceWs", nil, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchBalanceWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchBalanceWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "returnRateLimits": returnRateLimits,
            }
            var method interface{} = nil
            methodparamsVariable := callDynamically("handleOptionAndParams", params, "fetchBalanceWs", "method", "account.status")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(method, "account.status"))), this.HandleAccountStatusWs, this.HandleBalanceWs),
            }
        
                retRes266415 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes266415)
                ch <- retRes266415
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleBalanceWs(client interface{}, message interface{})  {
    //
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var rawBalance interface{} = nil
    if ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(message, "result"))) {
        // account.balance
        rawBalance = callDynamically("safeList", message, "result", []interface{}{})
    } else {
        // account.status
        var result interface{} = callDynamically("safeDict", message, "result", map[string]interface{} {})
        rawBalance = callDynamically("safeList", result, "assets", []interface{}{})
    }
    var parsedBalances interface{} = callDynamically("parseBalanceCustom", rawBalance)
    client.(ccxt.ClientInterface).Resolve(parsedBalances, messageHash)
}
func  (this *BinanceCore) HandleAccountStatusWs(client interface{}, message interface{})  {
    //
    // JSON format - spot
    //    {
    //        "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
    //        "status": 200,
    //        "result": {
    //            "makerCommission": 15,
    //            "takerCommission": 15,
    //            "buyerCommission": 0,
    //            "sellerCommission": 0,
    //            "canTrade": true,
    //            "canWithdraw": true,
    //            "canDeposit": true,
    //            "commissionRates": {
    //                "maker": "0.00150000",
    //                "taker": "0.00150000",
    //                "buyer": "0.00000000",
    //                "seller": "0.00000000"
    //            },
    //            "brokered": false,
    //            "requireSelfTradePrevention": false,
    //            "updateTime": 1660801833000,
    //            "accountType": "SPOT",
    //            "balances": [{
    //                    "asset": "BNB",
    //                    "free": "0.00000000",
    //                    "locked": "0.00000000"
    //                },
    //                {
    //                    "asset": "BTC",
    //                    "free": "1.3447112",
    //                    "locked": "0.08600000"
    //                },
    //                {
    //                    "asset": "USDT",
    //                    "free": "1021.21000000",
    //                    "locked": "0.00000000"
    //                }
    //            ],
    //            "permissions": [
    //                "SPOT"
    //            ]
    //        }
    //    }
    //
    // SBE format (AccountResponse):
    //    {
    //        "id": "...",
    //        "status": 200,
    //        "result": {
    //            "commissionExponent": -8,
    //            "commissionRateMaker": 150000,      // mantissa
    //            "commissionRateTaker": 150000,
    //            "commissionRateBuyer": 0,
    //            "commissionRateSeller": 0,
    //            "canTrade": 1,                       // boolEnum
    //            "canWithdraw": 1,
    //            "canDeposit": 1,
    //            "brokered": 0,
    //            "requireSelfTradePrevention": 0,
    //            "preventSor": 0,
    //            "updateTime": 1660801833000000,      // microseconds
    //            "accountType": 0,                    // enum
    //            "uid": 12345,
    //            "balances": [{
    //                "exponent": -8,
    //                "free": 0,                       // mantissa
    //                "locked": 0,
    //                "asset": "BNB"
    //            }],
    //            "permissions": ["SPOT"],
    //            "reduceOnlyAssets": []
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeDict", message, "result", map[string]interface{} {})
    // Check if SBE format (has commissionExponent)
    var commissionExponent interface{} = callDynamically("safeInteger", result, "commissionExponent")
    if ccxt.IsTrue(!ccxt.IsEqual(commissionExponent, nil)) {
        // SBE format - normalize to JSON format
        var normalized interface{} = map[string]interface{} {}
        // Convert commission rates from mantissa
        var makerMantissa interface{} = callDynamically("safeInteger", result, "commissionRateMaker")
        var takerMantissa interface{} = callDynamically("safeInteger", result, "commissionRateTaker")
        var buyerMantissa interface{} = callDynamically("safeInteger", result, "commissionRateBuyer")
        var sellerMantissa interface{} = callDynamically("safeInteger", result, "commissionRateSeller")
        ccxt.AddElementToObject(normalized, "commissionRates", map[string]interface{} {
    "maker": ccxt.String(callDynamically("applyExponent", makerMantissa, commissionExponent)),
    "taker": ccxt.String(callDynamically("applyExponent", takerMantissa, commissionExponent)),
    "buyer": ccxt.String(callDynamically("applyExponent", buyerMantissa, commissionExponent)),
    "seller": ccxt.String(callDynamically("applyExponent", sellerMantissa, commissionExponent)),
})
        // Note: makerCommission, takerCommission, buyerCommission, sellerCommission
        // are NOT present in SBE format (as documented in the schema)
        // Copy boolean fields
        ccxt.AddElementToObject(normalized, "canTrade", callDynamically("safeValue", result, "canTrade"))
        ccxt.AddElementToObject(normalized, "canWithdraw", callDynamically("safeValue", result, "canWithdraw"))
        ccxt.AddElementToObject(normalized, "canDeposit", callDynamically("safeValue", result, "canDeposit"))
        ccxt.AddElementToObject(normalized, "brokered", callDynamically("safeValue", result, "brokered"))
        ccxt.AddElementToObject(normalized, "requireSelfTradePrevention", callDynamically("safeValue", result, "requireSelfTradePrevention"))
        ccxt.AddElementToObject(normalized, "preventSor", callDynamically("safeValue", result, "preventSor"))
        // Convert updateTime from microseconds to milliseconds
        var updateTime interface{} = callDynamically("safeInteger", result, "updateTime")
        if ccxt.IsTrue(!ccxt.IsEqual(updateTime, nil)) {
            ccxt.AddElementToObject(normalized, "updateTime", ccxt.MathFloor(ccxt.Divide(updateTime, 1000)))
        }
        // Copy other fields
        ccxt.AddElementToObject(normalized, "accountType", callDynamically("safeValue", result, "accountType"))
        ccxt.AddElementToObject(normalized, "tradeGroupId", callDynamically("safeInteger", result, "tradeGroupId"))
        ccxt.AddElementToObject(normalized, "uid", callDynamically("safeInteger", result, "uid"))
        // Convert balances array
        var balances interface{} = callDynamically("safeList", result, "balances", []interface{}{})
        ccxt.AddElementToObject(normalized, "balances", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
            var balance interface{} = ccxt.GetValue(balances, i)
            var exponent interface{} = callDynamically("safeInteger", balance, "exponent", 0)
            var freeMantissa interface{} = callDynamically("safeInteger", balance, "free", 0)
            var lockedMantissa interface{} = callDynamically("safeInteger", balance, "locked", 0)
            retRes306016 := ccxt.GetValue(normalized, "balances")
            ccxt.AppendToArray(&retRes306016, map[string]interface{} {
                "asset": callDynamically("safeString", balance, "asset"),
                "free": ccxt.String(callDynamically("applyExponent", freeMantissa, exponent)),
                "locked": ccxt.String(callDynamically("applyExponent", lockedMantissa, exponent)),
            })
        }
        // Copy permissions and reduceOnlyAssets arrays as-is
        ccxt.AddElementToObject(normalized, "permissions", callDynamically("safeList", result, "permissions", []interface{}{}))
        ccxt.AddElementToObject(normalized, "reduceOnlyAssets", callDynamically("safeList", result, "reduceOnlyAssets", []interface{}{}))
        result = normalized
    }
    var parsedBalances interface{} = callDynamically("parseBalanceCustom", result)
    client.(ccxt.ClientInterface).Resolve(parsedBalances, messageHash)
}
/**
 * @method
 * @name binance#fetchPositionWs
 * @description fetch data on an open position
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func  (this *BinanceCore) FetchPositionWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes274715 :=  (<-this.FetchPositionsWs([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes274715)
                ch <- retRes274715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchPositionsWs
 * @description fetch all open positions
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.returnRateLimits] set to true to return rate limit informations, defaults to false.
 * @param {string|undefined} [params.method] method to use. Can be account.position or v2/account.position
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func  (this *BinanceCore) FetchPositionsWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes27638)
            var payload interface{} = map[string]interface{} {}
            var market interface{} = nil
            symbols = callDynamically("marketSymbols", symbols, "swap", true, true, true)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 1)) {
                    market = callDynamically("market", ccxt.GetValue(symbols, 0))
                    ccxt.AddElementToObject(payload, "symbol", ccxt.GetValue(market, "id"))
                }
            }
            var typeVar interface{} = this.GetMarketType("fetchPositionsWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) && ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot")))) {
                // when symbols aren't provide
                // we shouldn't rely on the defaultType
                typeVar = "future"
            }
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchPositionsWs only supports swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchPositionsWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var method interface{} = nil
            methodparamsVariable := callDynamically("handleOptionAndParams", params, "fetchPositionsWs", "method", "account.position")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandlePositionsWs,
            }
        
            result:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(result)
        
            ch <- callDynamically("filterByArrayPositions", result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandlePositionsWs(client interface{}, message interface{})  {
    //
    //    {
    //        id: '1',
    //        status: 200,
    //        result: [
    //            {
    //                symbol: 'BTCUSDT',
    //                positionAmt: '-0.014',
    //                entryPrice: '42901.1',
    //                breakEvenPrice: '30138.83333142',
    //                markPrice: '71055.98470333',
    //                unRealizedProfit: '-394.16838584',
    //                liquidationPrice: '137032.02272908',
    //                leverage: '123',
    //                maxNotionalValue: '50000',
    //                marginType: 'cross',
    //                isolatedMargin: '0.00000000',
    //                isAutoAddMargin: 'false',
    //                positionSide: 'BOTH',
    //                notional: '-994.78378584',
    //                isolatedWallet: '0',
    //                updateTime: 1708906343111,
    //                isolated: false,
    //                adlQuantile: 2
    //            },
    //            ...
    //        ]
    //    }
    //
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeList", message, "result", []interface{}{})
    var positions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
        var parsed interface{} = callDynamically("parsePositionRisk", ccxt.GetValue(result, i))
        var entryPrice interface{} = callDynamically("safeString", parsed, "entryPrice")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0"))) && ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0.0")))) && ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0.00000000")))) {
            ccxt.AppendToArray(&positions, parsed)
        }
    }
    client.(ccxt.ClientInterface).Resolve(positions, messageHash)
}
/**
 * @method
 * @name binance#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BinanceCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes28568)
        
            retRes28578 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes28578)
            var defaultType interface{} = this.SafeString(this.Options, "defaultType", "spot")
            var typeVar interface{} = this.SafeString(params, "type", defaultType)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchBalance", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "watchBalance", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            var url interface{} = ""
            var urlType interface{} = typeVar
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                // route to WebSocket API connection where the user data stream is subscribed
                var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
                url = this.GetSbeWebSocketUrl(baseUrl)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var options interface{} = callDynamically("safeDict", this.Options, "watchBalance")
            var fetchBalanceSnapshot interface{} = callDynamically("safeBool", options, "fetchBalanceSnapshot", false)
            var awaitBalanceSnapshot interface{} = callDynamically("safeBool", options, "awaitBalanceSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes288712 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes288712)
            }
            var messageHash interface{} = ccxt.Add(typeVar, ":balance")
            var message interface{} = nil
        
                retRes289115 :=  (<-this.Watch(url, messageHash, message, typeVar))
                ccxt.PanicOnError(retRes289115)
                ch <- retRes289115
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleBalance(client interface{}, message interface{})  {
    //
    // sent upon a balance update not related to orders
    //
    //     {
    //         "e": "balanceUpdate",
    //         "E": 1629352505586,
    //         "a": "IOTX",
    //         "d": "0.43750000",
    //         "T": 1629352505585
    //     }
    //
    // sent upon creating or filling an order
    //
    //     {
    //         "e": "outboundAccountPosition", // Event type
    //         "E": 1564034571105,             // Event Time
    //         "u": 1564034571073,             // Time of last account update
    //         "B": [                          // ccxt.Balances Array
    //             {
    //                 "a": "ETH",                 // Asset
    //                 "f": "10000.000000",        // Free
    //                 "l": "0.000000"             // Locked
    //             }
    //         ]
    //     }
    //
    // future/delivery
    //
    //     {
    //         "e": "ACCOUNT_UPDATE",            // Event Type
    //         "E": 1564745798939,               // Event Time
    //         "T": 1564745798938 ,              // ccxt.Transaction
    //         "i": "SfsR",                      // ccxt.Account Alias
    //         "a": {                            // Update Data
    //             "m":"ORDER",                  // Event reason type
    //             "B":[                         // ccxt.Balances
    //                 {
    //                     "a":"BTC",                // Asset
    //                     "wb":"122624.12345678",   // Wallet ccxt.Balance
    //                     "cw":"100.12345678"       // Cross Wallet ccxt.Balance
    //                 },
    //             ],
    //             "P":[
    //                 {
    //                     "s":"BTCUSD_200925",      // Symbol
    //                     "pa":"0",                 // ccxt.Position Amount
    //                     "ep":"0.0",               // Entry Price
    //                     "cr":"200",               // (Pre-fee) Accumulated Realized
    //                     "up":"0",                 // Unrealized PnL
    //                     "mt":"isolated",          // Margin Type
    //                     "iw":"0.00000000",        // Isolated Wallet (if isolated position)
    //                     "ps":"BOTH"               // ccxt.Position Side
    //                 },
    //             ]
    //         }
    //     }
    // externalLockUpdate
    //    {
    //        "e": "externalLockUpdate",  // Event Type
    //        "E": 1581557507324,         // Event Time
    //        "a": "NEO",                 // Asset
    //        "d": "10.00000000",         // Delta
    //        "T": 1581557507268          // ccxt.Transaction Time
    //    }
    //
    var wallet interface{} = callDynamically("safeString", this.Options, "wallet", "wb") // cw for cross wallet
    // each account is connected to a different endpoint
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var messageHash interface{} = ccxt.Add(accountType, ":balance")
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(this.Balance, accountType), nil)) {
        ccxt.AddElementToObject(this.Balance, accountType, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "info", message)
    var event interface{} = callDynamically("safeString", message, "e")
    if ccxt.IsTrue(ccxt.IsEqual(event, "balanceUpdate")) {
        var currencyId interface{} = callDynamically("safeString", message, "a")
        var code interface{} = callDynamically("safeCurrencyCode", currencyId)
        var account interface{} = callDynamically("account", )
        var delta interface{} = callDynamically("safeString", message, "d")
        if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Balance, accountType), code)) {
            var previousValue interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Balance, accountType), code), "free")
            if ccxt.IsTrue(!ccxt.IsString(previousValue)) {
                previousValue = callDynamically("numberToString", previousValue)
            }
            ccxt.AddElementToObject(account, "free", ccxt.Precise.StringAdd(previousValue, delta))
        } else {
            ccxt.AddElementToObject(account, "free", delta)
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
    } else {
        message = callDynamically("safeDict", message, "a", message)
        var B interface{} = callDynamically("safeList", message, "B")
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(B)); i++ {
            var entry interface{} = ccxt.GetValue(B, i)
            var currencyId interface{} = callDynamically("safeString", entry, "a")
            var code interface{} = callDynamically("safeCurrencyCode", currencyId)
            var account interface{} = callDynamically("account", )
            ccxt.AddElementToObject(account, "free", callDynamically("safeString", entry, "f"))
            ccxt.AddElementToObject(account, "used", callDynamically("safeString", entry, "l"))
            ccxt.AddElementToObject(account, "total", callDynamically("safeString", entry, wallet))
            ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
        }
    }
    var timestamp interface{} = callDynamically("safeInteger", message, "E")
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "datetime", callDynamically("iso8601", timestamp))
    ccxt.AddElementToObject(this.Balance, accountType, callDynamically("safeBalance", ccxt.GetValue(this.Balance, accountType)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, accountType), messageHash)
}
func  (this *BinanceCore) GetAccountTypeFromSubscriptions(subscriptions interface{}) interface{}  {
    var accountType interface{} = ""
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
        var subscription interface{} = ccxt.GetValue(subscriptions, i)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, "spot"))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "margin")))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "future")))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "delivery")))) {
            accountType = subscription
            break
        }
    }
    return accountType
}
func  (this *BinanceCore) GetMarketType(method interface{}, market interface{}, optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var typeVar interface{} = nil
    typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", method, market, params)
    typeVar = ccxt.GetValue(typeVarparamsVariable,0)
    params = ccxt.GetValue(typeVarparamsVariable,1)
    var subType interface{} = nil
    subTypeparamsVariable := callDynamically("handleSubTypeAndParams", method, market, params)
    subType = ccxt.GetValue(subTypeparamsVariable,0)
    params = ccxt.GetValue(subTypeparamsVariable,1)
    if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
        typeVar = "future"
    } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
        typeVar = "delivery"
    }
    return typeVar
}
/**
 * @method
 * @name binance#createOrderWs
 * @description create a trade order
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/New-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/New-Algo-ccxt.Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} params.test test order, default false
 * @param {boolean} params.returnRateLimits set to true to return rate limit information, default false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes30518)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = this.GetMarketType("createOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "delivery"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " createOrderWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var sor interface{} = callDynamically("safeBool2", params, "sor", "SOR", false)
            params = callDynamically("omit", params, "sor", "SOR")
            var triggerPrice interface{} = callDynamically("safeString2", params, "triggerPrice", "stopPrice")
            var stopLossPrice interface{} = callDynamically("safeString", params, "stopLossPrice", triggerPrice)
            var takeProfitPrice interface{} = callDynamically("safeString", params, "takeProfitPrice")
            var trailingDelta interface{} = callDynamically("safeString", params, "trailingDelta")
            var trailingPercent interface{} = callDynamically("safeStringN", params, []interface{}{"trailingPercent", "callbackRate", "trailingDelta"})
            var isTrailingPercentOrder interface{} = !ccxt.IsEqual(trailingPercent, nil)
            var isStopLoss interface{} = ccxt.IsTrue(!ccxt.IsEqual(stopLossPrice, nil)) || ccxt.IsTrue(!ccxt.IsEqual(trailingDelta, nil))
            var isTakeProfit interface{} = !ccxt.IsEqual(takeProfitPrice, nil)
            var isTriggerOrder interface{} = !ccxt.IsEqual(triggerPrice, nil)
            var isConditional interface{} = ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(isTriggerOrder) || ccxt.IsTrue(isTrailingPercentOrder)) || ccxt.IsTrue(isStopLoss)) || ccxt.IsTrue(isTakeProfit)
            var payload interface{} = callDynamically("createOrderRequest", symbol, typeVar, side, amount, price, params)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "createOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var test interface{} = callDynamically("safeBool", params, "test", false)
            params = callDynamically("omit", params, "test")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.GetValue(market, "linear")) && ccxt.IsTrue(ccxt.GetValue(market, "swap"))) && ccxt.IsTrue(isConditional)) {
                ccxt.AddElementToObject(payload, "algoType", "CONDITIONAL")
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.place",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            if ccxt.IsTrue(test) {
                if ccxt.IsTrue(sor) {
                    ccxt.AddElementToObject(message, "method", "sor.order.test")
                } else {
                    ccxt.AddElementToObject(message, "method", "order.test")
                }
            }
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.GetValue(market, "linear")) && ccxt.IsTrue(ccxt.GetValue(market, "swap"))) && ccxt.IsTrue(isConditional)) {
                ccxt.AddElementToObject(message, "method", "algoOrder.place")
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes309915 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes309915)
                ch <- retRes309915
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) NormalizeSbeOrder(order interface{}) interface{}  {
    // Check if this is SBE format (has exponent fields)
    var priceExponent interface{} = callDynamically("safeInteger", order, "priceExponent")
    if ccxt.IsTrue(ccxt.IsEqual(priceExponent, nil)) {
        // Already in JSON format
        return order
    }
    // SBE format - normalize to JSON format
    var qtyExponent interface{} = callDynamically("safeInteger", order, "qtyExponent", 0)
    var normalized interface{} = map[string]interface{} {}
    // Copy non-price/qty fields directly
    ccxt.AddElementToObject(normalized, "orderId", callDynamically("safeInteger", order, "orderId"))
    ccxt.AddElementToObject(normalized, "orderListId", callDynamically("safeInteger", order, "orderListId"))
    ccxt.AddElementToObject(normalized, "symbol", callDynamically("safeString", order, "symbol"))
    ccxt.AddElementToObject(normalized, "clientOrderId", callDynamically("safeString", order, "clientOrderId"))
    ccxt.AddElementToObject(normalized, "origClientOrderId", callDynamically("safeString", order, "origClientOrderId"))
    // Convert timestamps from microseconds to milliseconds
    var transactTime interface{} = callDynamically("safeInteger", order, "transactTime")
    if ccxt.IsTrue(!ccxt.IsEqual(transactTime, nil)) {
        ccxt.AddElementToObject(normalized, "transactTime", ccxt.MathFloor(ccxt.Divide(transactTime, 1000)))
    }
    var workingTime interface{} = callDynamically("safeInteger", order, "workingTime")
    if ccxt.IsTrue(!ccxt.IsEqual(workingTime, nil)) {
        ccxt.AddElementToObject(normalized, "workingTime", ccxt.MathFloor(ccxt.Divide(workingTime, 1000)))
    }
    var time interface{} = callDynamically("safeInteger", order, "time")
    if ccxt.IsTrue(!ccxt.IsEqual(time, nil)) {
        ccxt.AddElementToObject(normalized, "time", ccxt.MathFloor(ccxt.Divide(time, 1000)))
    }
    var updateTime interface{} = callDynamically("safeInteger", order, "updateTime")
    if ccxt.IsTrue(!ccxt.IsEqual(updateTime, nil)) {
        ccxt.AddElementToObject(normalized, "updateTime", ccxt.MathFloor(ccxt.Divide(updateTime, 1000)))
    }
    var trailingTime interface{} = callDynamically("safeInteger", order, "trailingTime")
    if ccxt.IsTrue(!ccxt.IsEqual(trailingTime, nil)) {
        ccxt.AddElementToObject(normalized, "trailingTime", ccxt.MathFloor(ccxt.Divide(trailingTime, 1000)))
    }
    // Convert mantissa values to decimal strings
    var priceMantissa interface{} = callDynamically("safeInteger", order, "price")
    if ccxt.IsTrue(!ccxt.IsEqual(priceMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "price", ccxt.String(callDynamically("applyExponent", priceMantissa, priceExponent)))
    }
    var origQtyMantissa interface{} = callDynamically("safeInteger", order, "origQty")
    if ccxt.IsTrue(!ccxt.IsEqual(origQtyMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "origQty", ccxt.String(callDynamically("applyExponent", origQtyMantissa, qtyExponent)))
    }
    var executedQtyMantissa interface{} = callDynamically("safeInteger", order, "executedQty")
    if ccxt.IsTrue(!ccxt.IsEqual(executedQtyMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "executedQty", ccxt.String(callDynamically("applyExponent", executedQtyMantissa, qtyExponent)))
    }
    var cummulativeQuoteQtyMantissa interface{} = callDynamically("safeInteger", order, "cummulativeQuoteQty")
    if ccxt.IsTrue(!ccxt.IsEqual(cummulativeQuoteQtyMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "cummulativeQuoteQty", ccxt.String(callDynamically("applyExponent", cummulativeQuoteQtyMantissa, priceExponent)))
    }
    var stopPriceMantissa interface{} = callDynamically("safeInteger", order, "stopPrice")
    if ccxt.IsTrue(!ccxt.IsEqual(stopPriceMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "stopPrice", ccxt.String(callDynamically("applyExponent", stopPriceMantissa, priceExponent)))
    }
    var icebergQtyMantissa interface{} = callDynamically("safeInteger", order, "icebergQty")
    if ccxt.IsTrue(!ccxt.IsEqual(icebergQtyMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "icebergQty", ccxt.String(callDynamically("applyExponent", icebergQtyMantissa, qtyExponent)))
    }
    var preventedQuantityMantissa interface{} = callDynamically("safeInteger", order, "preventedQuantity")
    if ccxt.IsTrue(!ccxt.IsEqual(preventedQuantityMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "preventedQuantity", ccxt.String(callDynamically("applyExponent", preventedQuantityMantissa, qtyExponent)))
    }
    var origQuoteOrderQtyMantissa interface{} = callDynamically("safeInteger", order, "origQuoteOrderQty")
    if ccxt.IsTrue(!ccxt.IsEqual(origQuoteOrderQtyMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "origQuoteOrderQty", ccxt.String(callDynamically("applyExponent", origQuoteOrderQtyMantissa, priceExponent)))
    }
    var peggedPriceMantissa interface{} = callDynamically("safeInteger", order, "peggedPrice")
    if ccxt.IsTrue(!ccxt.IsEqual(peggedPriceMantissa, nil)) {
        ccxt.AddElementToObject(normalized, "peggedPrice", ccxt.String(callDynamically("applyExponent", peggedPriceMantissa, priceExponent)))
    }
    // Copy enum fields - they need to be mapped to their string equivalents
    // The parseOrder method handles this mapping
    ccxt.AddElementToObject(normalized, "status", callDynamically("safeValue", order, "status"))
    ccxt.AddElementToObject(normalized, "timeInForce", callDynamically("safeValue", order, "timeInForce"))
    ccxt.AddElementToObject(normalized, "type", callDynamically("safeValue", order, "orderType")) // Note: orderType maps to 'type' in JSON
    ccxt.AddElementToObject(normalized, "side", callDynamically("safeValue", order, "side"))
    ccxt.AddElementToObject(normalized, "orderCapacity", callDynamically("safeValue", order, "orderCapacity"))
    ccxt.AddElementToObject(normalized, "workingFloor", callDynamically("safeValue", order, "workingFloor"))
    ccxt.AddElementToObject(normalized, "selfTradePreventionMode", callDynamically("safeValue", order, "selfTradePreventionMode"))
    ccxt.AddElementToObject(normalized, "usedSor", callDynamically("safeValue", order, "usedSor"))
    ccxt.AddElementToObject(normalized, "isWorking", callDynamically("safeValue", order, "isWorking"))
    ccxt.AddElementToObject(normalized, "pegPriceType", callDynamically("safeValue", order, "pegPriceType"))
    ccxt.AddElementToObject(normalized, "pegOffsetType", callDynamically("safeValue", order, "pegOffsetType"))
    ccxt.AddElementToObject(normalized, "pegOffsetValue", callDynamically("safeValue", order, "pegOffsetValue"))
    // Copy other fields
    ccxt.AddElementToObject(normalized, "trailingDelta", callDynamically("safeInteger", order, "trailingDelta"))
    ccxt.AddElementToObject(normalized, "strategyId", callDynamically("safeInteger", order, "strategyId"))
    ccxt.AddElementToObject(normalized, "strategyType", callDynamically("safeInteger", order, "strategyType"))
    ccxt.AddElementToObject(normalized, "tradeGroupId", callDynamically("safeInteger", order, "tradeGroupId"))
    // Handle fills array
    var fills interface{} = callDynamically("safeList", order, "fills", []interface{}{})
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(fills), 0)) {
        ccxt.AddElementToObject(normalized, "fills", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(fills)); i++ {
            var fill interface{} = ccxt.GetValue(fills, i)
            var commissionExponent interface{} = callDynamically("safeInteger", fill, "commissionExponent", 0)
            var fillPriceMantissa interface{} = callDynamically("safeInteger", fill, "price")
            var qtyMantissa interface{} = callDynamically("safeInteger", fill, "qty")
            var commissionMantissa interface{} = callDynamically("safeInteger", fill, "commission")
            retRes354116 := ccxt.GetValue(normalized, "fills")
            ccxt.AppendToArray(&retRes354116, map[string]interface{} {
                "price": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(fillPriceMantissa, nil)), ccxt.String(callDynamically("applyExponent", fillPriceMantissa, priceExponent)), nil),
                "qty": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(qtyMantissa, nil)), ccxt.String(callDynamically("applyExponent", qtyMantissa, qtyExponent)), nil),
                "commission": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(commissionMantissa, nil)), ccxt.String(callDynamically("applyExponent", commissionMantissa, commissionExponent)), nil),
                "commissionAsset": callDynamically("safeString", fill, "commissionAsset"),
                "tradeId": callDynamically("safeInteger", fill, "tradeId"),
                "allocId": callDynamically("safeInteger", fill, "allocId"),
                "matchType": callDynamically("safeValue", fill, "matchType"),
            })
        }
    } else {
        ccxt.AddElementToObject(normalized, "fills", []interface{}{})
    }
    // Handle preventedMatches array
    var preventedMatches interface{} = callDynamically("safeList", order, "preventedMatches", []interface{}{})
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(preventedMatches), 0)) {
        ccxt.AddElementToObject(normalized, "preventedMatches", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(preventedMatches)); i++ {
            var match interface{} = ccxt.GetValue(preventedMatches, i)
            var matchPriceMantissa interface{} = callDynamically("safeInteger", match, "price")
            var takerPreventedQtyMantissa interface{} = callDynamically("safeInteger", match, "takerPreventedQuantity")
            var makerPreventedQtyMantissa interface{} = callDynamically("safeInteger", match, "makerPreventedQuantity")
            retRes356316 := ccxt.GetValue(normalized, "preventedMatches")
            ccxt.AppendToArray(&retRes356316, map[string]interface{} {
                "preventedMatchId": callDynamically("safeInteger", match, "preventedMatchId"),
                "makerOrderId": callDynamically("safeInteger", match, "makerOrderId"),
                "price": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(matchPriceMantissa, nil)), ccxt.String(callDynamically("applyExponent", matchPriceMantissa, priceExponent)), nil),
                "takerPreventedQuantity": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(takerPreventedQtyMantissa, nil)), ccxt.String(callDynamically("applyExponent", takerPreventedQtyMantissa, qtyExponent)), nil),
                "makerPreventedQuantity": ccxt.Ternary(ccxt.IsTrue(!ccxt.IsEqual(makerPreventedQtyMantissa, nil)), ccxt.String(callDynamically("applyExponent", makerPreventedQtyMantissa, qtyExponent)), nil),
                "makerSymbol": callDynamically("safeString", match, "makerSymbol"),
            })
        }
    }
    return normalized
}
func  (this *BinanceCore) HandleOrderWs(client interface{}, message interface{})  {
    //
    // JSON format:
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //          "symbol": "BTCUSDT",
    //          "orderId": 7663053,
    //          "orderListId": -1,
    //          "clientOrderId": "x-R4BD3S82d8959d0f5114499487a614",
    //          "transactTime": 1687642291434,
    //          "price": "25000.00000000",
    //          "origQty": "0.00100000",
    //          "executedQty": "0.00000000",
    //          "cummulativeQuoteQty": "0.00000000",
    //          "status": "NEW",
    //          "timeInForce": "GTC",
    //          "type": "LIMIT",
    //          "side": "BUY",
    //          "workingTime": 1687642291434,
    //          "fills": [],
    //          "selfTradePreventionMode": "NONE"
    //        },
    //        "rateLimits": [...]
    //    }
    //
    // SBE format (NewOrderResultResponse/NewOrderFullResponse/NewOrderAckResponse):
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //          "priceExponent": -8,
    //          "qtyExponent": -8,
    //          "orderId": 7663053,
    //          "orderListId": -1,
    //          "transactTime": 1687642291434000, // microseconds
    //          "price": 2500000000000,            // mantissa
    //          "origQty": 100000,                 // mantissa
    //          "executedQty": 0,
    //          "cummulativeQuoteQty": 0,
    //          "status": 0,                       // enum
    //          "timeInForce": 0,                  // enum
    //          "orderType": 1,                    // enum
    //          "side": 1,                         // enum
    //          "workingTime": 1687642291434000,
    //          "fills": [...],                    // array of objects with mantissa values
    //          "symbol": "BTCUSDT",
    //          "clientOrderId": "..."
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeDict", message, "result", map[string]interface{} {})
    // Normalize SBE format to JSON format if needed
    result = this.NormalizeSbeOrder(result)
    var order interface{} = callDynamically("parseOrder", result)
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
func  (this *BinanceCore) HandleOrdersWs(client interface{}, message interface{})  {
    //
    // JSON format:
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": [{
    //            "symbol": "BTCUSDT",
    //            "orderId": 7665584,
    //            "orderListId": -1,
    //            "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
    //            "price": "26000.00000000",
    //            "origQty": "0.00100000",
    //            "executedQty": "0.00000000",
    //            "cummulativeQuoteQty": "0.00000000",
    //            "status": "NEW",
    //            "timeInForce": "GTC",
    //            "type": "LIMIT",
    //            "side": "BUY",
    //            "stopPrice": "0.00000000",
    //            "icebergQty": "0.00000000",
    //            "time": 1687642884646,
    //            "updateTime": 1687642884646,
    //            "isWorking": true,
    //            "workingTime": 1687642884646,
    //            "origQuoteOrderQty": "0.00000000",
    //            "selfTradePreventionMode": "NONE"
    //        },
    //        ...
    //        ],
    //        "rateLimits": [...]
    //    }
    //
    // SBE format (OrdersResponse) - array in result.orders:
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //            "orders": [{
    //                "priceExponent": -8,
    //                "qtyExponent": -8,
    //                "orderId": 7665584,
    //                ...
    //            }]
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeValue", message, "result")
    var orders interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsArray(result)) {
        // JSON format - result is directly an array
        orders = []interface{}{}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
            ccxt.AppendToArray(&orders, this.NormalizeSbeOrder(ccxt.GetValue(result, i)))
        }
    } else if ccxt.IsTrue(ccxt.IsObject(result)) {
        // SBE format - result has an orders array
        var ordersArray interface{} = callDynamically("safeList", result, "orders", []interface{}{})
        orders = []interface{}{}
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(ordersArray)); i++ {
            ccxt.AppendToArray(&orders, this.NormalizeSbeOrder(ccxt.GetValue(ordersArray, i)))
        }
    }
    var parsedOrders interface{} = callDynamically("parseOrders", orders)
    client.(ccxt.ClientInterface).Resolve(parsedOrders, messageHash)
}
/**
 * @method
 * @name binance#editOrderWs
 * @description edit a trade order
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-and-replace-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Modify-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Modify-ccxt.Order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes32178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes32178)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = this.GetMarketType("editOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "delivery"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " editOrderWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var isSwap interface{} =     (ccxt.IsTrue(ccxt.IsEqual(marketType, "future")) || ccxt.IsTrue(ccxt.IsEqual(marketType, "delivery")))
            var payload interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                payload = callDynamically("editSpotOrderRequest", id, symbol, typeVar, side, amount, price, params)
            } else if ccxt.IsTrue(isSwap) {
                payload = callDynamically("editContractOrderRequest", id, symbol, typeVar, side, amount, price, params)
            }
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "editOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": ccxt.Ternary(ccxt.IsTrue((isSwap)), "order.modify", "order.cancelReplace"),
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleEditOrderWs,
            }
        
                retRes324415 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes324415)
                ch <- retRes324415
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleEditOrderWs(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //            "cancelResult": "SUCCESS",
    //            "newOrderResult": "SUCCESS",
    //            "cancelResponse": {
    //                "symbol": "BTCUSDT",
    //                "origClientOrderId": "x-R4BD3S82813c5d7ffa594104917de2",
    //                "orderId": 7665177,
    //                "orderListId": -1,
    //                "clientOrderId": "mbrnbQsQhtCXCLY45d5q7S",
    //                "price": "26000.00000000",
    //                "origQty": "0.00100000",
    //                "executedQty": "0.00000000",
    //                "cummulativeQuoteQty": "0.00000000",
    //                "status": "CANCELED",
    //                "timeInForce": "GTC",
    //                "type": "LIMIT",
    //                "side": "BUY",
    //                "selfTradePreventionMode": "NONE"
    //            },
    //            "newOrderResponse": {
    //                "symbol": "BTCUSDT",
    //                "orderId": 7665584,
    //                "orderListId": -1,
    //                "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
    //                "transactTime": 1687642884646,
    //                "price": "26000.00000000",
    //                "origQty": "0.00100000",
    //                "executedQty": "0.00000000",
    //                "cummulativeQuoteQty": "0.00000000",
    //                "status": "NEW",
    //                "timeInForce": "GTC",
    //                "type": "LIMIT",
    //                "side": "BUY",
    //                "workingTime": 1687642884646,
    //                "fills": [],
    //                "selfTradePreventionMode": "NONE"
    //            }
    //        },
    //        "rateLimits": [{
    //                "rateLimitType": "ORDERS",
    //                "interval": "SECOND",
    //                "intervalNum": 10,
    //                "limit": 50,
    //                "count": 1
    //            },
    //            {
    //                "rateLimitType": "ORDERS",
    //                "interval": "DAY",
    //                "intervalNum": 1,
    //                "limit": 160000,
    //                "count": 3
    //            },
    //            {
    //                "rateLimitType": "REQUEST_WEIGHT",
    //                "interval": "MINUTE",
    //                "intervalNum": 1,
    //                "limit": 1200,
    //                "count": 12
    //            }
    //        ]
    //    }
    // swap
    //    {
    //        "id":"1",
    //        "status":200,
    //        "result":{
    //            "orderId":667061487,
    //            "symbol":"LTCUSDT",
    //            "status":"NEW",
    //            "clientOrderId":"x-xcKtGhcu91a74c818749ee42c0f70",
    //            "price":"82.00",
    //            "avgPrice":"0.00",
    //            "origQty":"1.000",
    //            "executedQty":"0.000",
    //            "cumQty":"0.000",
    //            "cumQuote":"0.00000",
    //            "timeInForce":"GTC",
    //            "type":"LIMIT",
    //            "reduceOnly":false,
    //            "closePosition":false,
    //            "side":"BUY",
    //            "positionSide":"BOTH",
    //            "stopPrice":"0.00",
    //            "workingType":"CONTRACT_PRICE",
    //            "priceProtect":false,
    //            "origType":"LIMIT",
    //            "priceMatch":"NONE",
    //            "selfTradePreventionMode":"NONE",
    //            "goodTillDate":0,
    //            "updateTime":1712918927511
    //        }
    //    }
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeDict", message, "result", map[string]interface{} {})
    var newSpotOrder interface{} = callDynamically("safeDict", result, "newOrderResponse")
    var order interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(newSpotOrder, nil)) {
        order = callDynamically("parseOrder", newSpotOrder)
    } else {
        order = callDynamically("parseOrder", result)
    }
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name binance#cancelOrderWs
 * @description cancel multiple orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Cancel-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Cancel-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Cancel-Algo-ccxt.Order
 * @param {string} id order id
 * @param {string} [symbol] unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.cancelRestrictions] Supported values: ONLY_NEW - ccxt.Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - ccxt.Cancel will succeed if order status is PARTIALLY_FILLED.
 * @param {boolean} [params.trigger] set to true if you would like to cancel a conditional order
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes33748)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " cancelOrderWs requires a symbol"));return nil
            }
            var market interface{} = callDynamically("market", symbol)
            var typeVar interface{} = this.GetMarketType("cancelOrderWs", market, params)
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "cancelOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            var isConditional interface{} = callDynamically("safeBoolN", params, []interface{}{"stop", "trigger", "conditional"})
            var clientOrderId interface{} = callDynamically("safeStringN", params, []interface{}{"clientAlgoId", "origClientOrderId", "clientOrderId"})
            var shouldUseAlgoOrder interface{} = ccxt.IsTrue(ccxt.IsTrue(ccxt.GetValue(market, "linear")) && ccxt.IsTrue(ccxt.GetValue(market, "swap"))) && ccxt.IsTrue(isConditional)
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                if ccxt.IsTrue(shouldUseAlgoOrder) {
                    ccxt.AddElementToObject(payload, "clientAlgoId", clientOrderId)
                } else {
                    ccxt.AddElementToObject(payload, "origClientOrderId", clientOrderId)
                }
            } else {
                if ccxt.IsTrue(shouldUseAlgoOrder) {
                    ccxt.AddElementToObject(payload, "algoId", callDynamically("numberToString", id))
                } else {
                    ccxt.AddElementToObject(payload, "orderId", callDynamically("numberToString", id))
                }
            }
            params = callDynamically("omit", params, []interface{}{"origClientOrderId", "clientOrderId", "stop", "trigger", "conditional"})
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.cancel",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            if ccxt.IsTrue(shouldUseAlgoOrder) {
                ccxt.AddElementToObject(message, "method", "algoOrder.cancel")
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes341715 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes341715)
                ch <- retRes341715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#cancelAllOrdersWs
 * @description cancel all open orders in a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-open-orders-trade
 * @param {string} [symbol] unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34308 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes34308)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("cancelAllOrdersWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " cancelAllOrdersWs only supports spot markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "cancelAllOrdersWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "openOrders.cancelAll",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
                retRes345315 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes345315)
                ch <- retRes345315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrderWs
 * @description fetches information on an order made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#query-order-user_data
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Query-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Query-ccxt.Order
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) FetchOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes34698)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " cancelOrderWs requires a symbol"));return nil
            }
            var market interface{} = callDynamically("market", symbol)
            var typeVar interface{} = this.GetMarketType("fetchOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOrderWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            var clientOrderId interface{} = callDynamically("safeString2", params, "origClientOrderId", "clientOrderId")
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                ccxt.AddElementToObject(payload, "origClientOrderId", clientOrderId)
            } else {
                ccxt.AddElementToObject(payload, "orderId", callDynamically("numberToString", id))
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.status",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes350115 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes350115)
                ch <- retRes350115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrdersWs
 * @description fetches information on multiple orders made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int|undefined} [since] the earliest time in ms to fetch orders for
 * @param {int|undefined} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.orderId] order id to begin at
 * @param {int} [params.startTime] earliest time in ms to retrieve orders for
 * @param {int} [params.endTime] latest time in ms to retrieve orders for
 * @param {int} [params.limit] the maximum number of order structures to retrieve
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) FetchOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes35208)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOrdersWs requires a symbol"));return nil
            }
            var market interface{} = callDynamically("market", symbol)
            var typeVar interface{} = this.GetMarketType("fetchOrdersWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOrdersWs only supports spot markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "allOrders",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
            orders:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orders)
        
            ch <- callDynamically("filterBySymbolSinceLimit", orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchClosedOrdersWs
 * @description fetch closed orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) FetchClosedOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            orders:= (<-this.FetchOrdersWs(symbol, since, limit, params))
            ccxt.PanicOnError(orders)
            var closedOrders interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
                var order interface{} = ccxt.GetValue(orders, i)
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(order, "status"), "closed")) {
                    ccxt.AppendToArray(&closedOrders, order)
                }
            }
        
            ch <- closedOrders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOpenOrdersWs
 * @description fetch all unfilled currently open orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#current-open-orders-user_data
 * @param {string} symbol unified market symbol
 * @param {int|undefined} [since] the earliest time in ms to fetch open orders for
 * @param {int|undefined} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes35858)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchOpenOrdersWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchOpenOrdersWs only supports spot or swap markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                ccxt.AddElementToObject(payload, "symbol", callDynamically("marketId", symbol))
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "openOrders.status",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
            orders:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orders)
        
            ch <- callDynamically("filterBySymbolSinceLimit", orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/user-data-stream#order-update
 * @see https://developers.binance.com/docs/margin_trading/trade-data-stream/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-Algo-ccxt.Order-Update
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for spot margin
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch portfolio margin account orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BinanceCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes36318 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes36318)
            var messageHash interface{} = "orders"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = callDynamically("market", symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchOrders", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            params = callDynamically("extend", params, map[string]interface{} {
            "type": typeVar,
            "symbol": symbol,
            "subType": subType,
        }) // needed inside authenticate for isolated margin
        
            retRes36498 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes36498)
            var marginMode interface{} = nil
            marginModeparamsVariable := callDynamically("handleMarginModeAndParams", "watchOrders", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var urlType interface{} = typeVar
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin"))) || ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))) && ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))))) {
                urlType = "spot" // spot-margin shares the same stream as regular spot
            }
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "watchOrders", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var url interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                // route orders to ws-api user data stream
                var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
                url = this.GetSbeWebSocketUrl(baseUrl)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var message interface{} = nil
        
            orders:= (<-callDynamically("watch", url, messageHash, message, typeVar))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- callDynamically("filterBySymbolSinceLimit", orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "e": "executionReport",        // Event type
    //         "E": 1499405658658,            // Event time
    //         "s": "ETHBTC",                 // Symbol
    //         "c": "mUvoqJxFIILMdfAW5iGSOW", // ccxt.Client order ID
    //         "S": "BUY",                    // Side
    //         "o": "LIMIT",                  // ccxt.Order type
    //         "f": "GTC",                    // Time in force
    //         "q": "1.00000000",             // ccxt.Order quantity
    //         "p": "0.10264410",             // ccxt.Order price
    //         "P": "0.00000000",             // Stop price
    //         "F": "0.00000000",             // Iceberg quantity
    //         "g": -1,                       // OrderListId
    //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
    //         "x": "NEW",                    // Current execution type
    //         "X": "NEW",                    // Current order status
    //         "r": "NONE",                   // ccxt.Order reject reason; will be an error code.
    //         "i": 4293153,                  // ccxt.Order ID
    //         "l": "0.00000000",             // Last executed quantity
    //         "z": "0.00000000",             // Cumulative filled quantity
    //         "L": "0.00000000",             // Last executed price
    //         "n": "0",                      // Commission amount
    //         "N": null,                     // Commission asset
    //         "T": 1499405658657,            // ccxt.Transaction time
    //         "t": -1,                       // ccxt.Trade ID
    //         "I": 8641984,                  // Ignore
    //         "w": true,                     // Is the order on the book?
    //         "m": false,                    // Is this trade the maker side?
    //         "M": false,                    // Ignore
    //         "O": 1499405658657,            // ccxt.Order creation time
    //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
    //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
    //         "Q": "0.00000000"              // Quote ccxt.Order Qty
    //     }
    //
    // future
    //
    //     {
    //         "s":"BTCUSDT",                 // Symbol
    //         "c":"TEST",                    // ccxt.Client ccxt.Order Id
    //                                        // special client order id:
    //                                        // starts with "autoclose-": liquidation order
    //                                        // "adl_autoclose": ADL auto close order
    //         "S":"SELL",                    // Side
    //         "o":"TRAILING_STOP_MARKET",    // ccxt.Order Type
    //         "f":"GTC",                     // Time in Force
    //         "q":"0.001",                   // Original Quantity
    //         "p":"0",                       // Original Price
    //         "ap":"0",                      // Average Price
    //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //         "x":"NEW",                     // Execution Type
    //         "X":"NEW",                     // ccxt.Order Status
    //         "i":8886774,                   // ccxt.Order Id
    //         "l":"0",                       // ccxt.Order Last Filled Quantity
    //         "z":"0",                       // ccxt.Order Filled Accumulated Quantity
    //         "L":"0",                       // Last Filled Price
    //         "N":"USDT",                    // Commission Asset, will not push if no commission
    //         "n":"0",                       // Commission, will not push if no commission
    //         "T":1568879465651,             // ccxt.Order ccxt.Trade Time
    //         "t":0,                         // ccxt.Trade Id
    //         "b":"0",                       // ccxt.Bids Notional
    //         "a":"9.91",                    // Ask Notional
    //         "m":false,                     // Is this trade the maker side?
    //         "R":false,                     // Is this reduce only
    //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
    //         "ot":"TRAILING_STOP_MARKET",   // Original ccxt.Order Type
    //         "ps":"LONG",                   // ccxt.Position Side
    //         "cp":false,                    // If Close-All, pushed with conditional order
    //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //         "rp":"0"                       // Realized Profit of the trade
    //     }
    //
    // watchOrders: linear swap trigger order
    //
    //     {
    //         "caid":"Q5xaq5EGKgXXa0fD7fs0Ip",     // ccxt.Client Algo Id
    //         "aid":2148719,                       // Algo Id
    //         "at":"CONDITIONAL",                  // Algo Type
    //         "o":"TAKE_PROFIT",                   // ccxt.Order Type
    //         "s":"BNBUSDT",                       // Symbol
    //         "S":"SELL",                          // Side
    //         "ps":"BOTH",                         // ccxt.Position Side
    //         "f":"GTC",                           // Time in force
    //         "q":"0.01",                          // quantity
    //         "X":"CANCELED",                      // Algo status
    //         "ai":"",                             // order id
    //         "ap": "0.00000",                     // avg fill price in matching engine, only display when order is triggered and placed in matching engine
    //         "aq": "0.00000",                     // execuated quantity in matching engine, only display when order is triggered and placed in matching engine
    //         "act": "0",                          // actual order type in matching engine, only display when order is triggered and placed in matching engine
    //         "tp":"750",                          // Trigger price
    //         "p":"750",                           // ccxt.Order Price
    //         "V":"EXPIRE_MAKER",                  // STP mode
    //         "wt":"CONTRACT_PRICE",               // Working type
    //         "pm":"NONE",                         // Price match mode
    //         "cp":false,                          // If Close-All
    //         "pP":false,                          // If price protection is turned on
    //         "R":false,                           // Is this reduce only
    //         "tt":0,                              // Trigger time
    //         "gtd":0,                             // good till time for GTD time in force
    //         "rm": "Reduce Only reject"           // algo order failed reason
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var executionType interface{} = callDynamically("safeString", order, "x")
    var marketId interface{} = callDynamically("safeString", order, "s")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(order, "ps"))), "contract", "spot")
    var symbol interface{} = callDynamically("safeSymbol", marketId, nil, nil, marketType)
    var timestamp interface{} = callDynamically("safeInteger", order, "O")
    var T interface{} = callDynamically("safeInteger", order, "T")
    var lastTradeTimestamp interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(executionType, "NEW")) || ccxt.IsTrue(ccxt.IsEqual(executionType, "AMENDMENT"))) || ccxt.IsTrue(ccxt.IsEqual(executionType, "CANCELED"))) {
        if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
            timestamp = T
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        lastTradeTimestamp = T
    }
    var lastUpdateTimestamp interface{} = T
    var fee interface{} = nil
    var feeCost interface{} = callDynamically("safeString", order, "n")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(feeCost, nil))) && ccxt.IsTrue((ccxt.Precise.StringGt(feeCost, "0")))) {
        var feeCurrencyId interface{} = callDynamically("safeString", order, "N")
        var feeCurrency interface{} = callDynamically("safeCurrencyCode", feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    var rawStatus interface{} = callDynamically("safeString", order, "X")
    var status interface{} = callDynamically("parseOrderStatus", rawStatus)
    var clientOrderId interface{} = callDynamically("safeString2", order, "C", "caid")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(clientOrderId, nil))) || ccxt.IsTrue((ccxt.IsEqual(ccxt.GetArrayLength(clientOrderId), 0)))) {
        clientOrderId = callDynamically("safeString", order, "c")
    }
    var stopPrice interface{} = callDynamically("safeStringN", order, []interface{}{"P", "sp", "tp"})
    var timeInForce interface{} = callDynamically("safeString", order, "f")
    if ccxt.IsTrue(ccxt.IsEqual(timeInForce, "GTX")) {
        // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
        timeInForce = "PO"
    }
    return callDynamically("safeOrder", map[string]interface{} {
    "info": order,
    "symbol": symbol,
    "id": callDynamically("safeString2", order, "i", "aid"),
    "clientOrderId": clientOrderId,
    "timestamp": timestamp,
    "datetime": callDynamically("iso8601", timestamp),
    "lastTradeTimestamp": lastTradeTimestamp,
    "lastUpdateTimestamp": lastUpdateTimestamp,
    "type": callDynamically("parseOrderType", callDynamically("safeStringLower", order, "o")),
    "timeInForce": timeInForce,
    "postOnly": nil,
    "reduceOnly": callDynamically("safeBool", order, "R"),
    "side": callDynamically("safeStringLower", order, "S"),
    "price": callDynamically("safeString", order, "p"),
    "stopPrice": stopPrice,
    "triggerPrice": stopPrice,
    "amount": callDynamically("safeString", order, "q"),
    "cost": callDynamically("safeString", order, "Z"),
    "average": callDynamically("safeString", order, "ap"),
    "filled": callDynamically("safeString", order, "z"),
    "remaining": nil,
    "status": status,
    "fee": fee,
    "trades": nil,
})
}
func  (this *BinanceCore) HandleOrderUpdate(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "e": "executionReport",        // Event type
    //         "E": 1499405658658,            // Event time
    //         "s": "ETHBTC",                 // Symbol
    //         "c": "mUvoqJxFIILMdfAW5iGSOW", // ccxt.Client order ID
    //         "S": "BUY",                    // Side
    //         "o": "LIMIT",                  // ccxt.Order type
    //         "f": "GTC",                    // Time in force
    //         "q": "1.00000000",             // ccxt.Order quantity
    //         "p": "0.10264410",             // ccxt.Order price
    //         "P": "0.00000000",             // Stop price
    //         "F": "0.00000000",             // Iceberg quantity
    //         "g": -1,                       // OrderListId
    //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
    //         "x": "NEW",                    // Current execution type
    //         "X": "NEW",                    // Current order status
    //         "r": "NONE",                   // ccxt.Order reject reason; will be an error code.
    //         "i": 4293153,                  // ccxt.Order ID
    //         "l": "0.00000000",             // Last executed quantity
    //         "z": "0.00000000",             // Cumulative filled quantity
    //         "L": "0.00000000",             // Last executed price
    //         "n": "0",                      // Commission amount
    //         "N": null,                     // Commission asset
    //         "T": 1499405658657,            // ccxt.Transaction time
    //         "t": -1,                       // ccxt.Trade ID
    //         "I": 8641984,                  // Ignore
    //         "w": true,                     // Is the order on the book?
    //         "m": false,                    // Is this trade the maker side?
    //         "M": false,                    // Ignore
    //         "O": 1499405658657,            // ccxt.Order creation time
    //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
    //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
    //         "Q": "0.00000000"              // Quote ccxt.Order Qty
    //     }
    //
    // future
    //
    //     {
    //         "e":"ORDER_TRADE_UPDATE",           // Event Type
    //         "E":1568879465651,                  // Event Time
    //         "T":1568879465650,                  // Trasaction Time
    //         "o": {
    //             "s":"BTCUSDT",                  // Symbol
    //             "c":"TEST",                     // ccxt.Client ccxt.Order Id
    //                                             // special client order id:
    //                                             // starts with "autoclose-": liquidation order
    //                                             // "adl_autoclose": ADL auto close order
    //             "S":"SELL",                     // Side
    //             "o":"TRAILING_STOP_MARKET",     // ccxt.Order Type
    //             "f":"GTC",                      // Time in Force
    //             "q":"0.001",                    // Original Quantity
    //             "p":"0",                        // Original Price
    //             "ap":"0",                       // Average Price
    //             "sp":"7103.04",                 // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //             "x":"NEW",                      // Execution Type
    //             "X":"NEW",                      // ccxt.Order Status
    //             "i":8886774,                    // ccxt.Order Id
    //             "l":"0",                        // ccxt.Order Last Filled Quantity
    //             "z":"0",                        // ccxt.Order Filled Accumulated Quantity
    //             "L":"0",                        // Last Filled Price
    //             "N":"USDT",                     // Commission Asset, will not push if no commission
    //             "n":"0",                        // Commission, will not push if no commission
    //             "T":1568879465651,              // ccxt.Order ccxt.Trade Time
    //             "t":0,                          // ccxt.Trade Id
    //             "b":"0",                        // ccxt.Bids Notional
    //             "a":"9.91",                     // Ask Notional
    //             "m":false,                      // Is this trade the maker side?
    //             "R":false,                      // Is this reduce only
    //             "wt":"CONTRACT_PRICE",          // Stop Price Working Type
    //             "ot":"TRAILING_STOP_MARKET",    // Original ccxt.Order Type
    //             "ps":"LONG",                    // ccxt.Position Side
    //             "cp":false,                     // If Close-All, pushed with conditional order
    //             "AP":"7476.89",                 // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //             "cr":"5.0",                     // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //             "rp":"0"                        // Realized Profit of the trade
    //         }
    //     }
    //
    // linear swap conditional
    //
    //     {
    //         "e":"ALGO_UPDATE",  // Event Type
    //         "T":1750515742297,  // Event Time
    //         "E":1750515742303,  // ccxt.Transaction Time
    //         "o":{
    //             "caid":"Q5xaq5EGKgXXa0fD7fs0Ip",     // ccxt.Client Algo Id
    //             "aid":2148719,                       // Algo Id
    //             "at":"CONDITIONAL",                  // Algo Type
    //             "o":"TAKE_PROFIT",                   // ccxt.Order Type
    //             "s":"BNBUSDT",                       // Symbol
    //             "S":"SELL",                          // Side
    //             "ps":"BOTH",                         // ccxt.Position Side
    //             "f":"GTC",                           // Time in force
    //             "q":"0.01",                          // quantity
    //             "X":"CANCELED",                      // Algo status
    //             "ai":"",                             // order id
    //             "ap": "0.00000",                     // avg fill price in matching engine, only display when order is triggered and placed in matching engine
    //             "aq": "0.00000",                     // execuated quantity in matching engine, only display when order is triggered and placed in matching engine
    //             "act": "0",                          // actual order type in matching engine, only display when order is triggered and placed in matching engine
    //             "tp":"750",                          // Trigger price
    //             "p":"750",                           // ccxt.Order Price
    //             "V":"EXPIRE_MAKER",                  // STP mode
    //             "wt":"CONTRACT_PRICE",               // Working type
    //             "pm":"NONE",                         // Price match mode
    //             "cp":false,                          // If Close-All
    //             "pP":false,                          // If price protection is turned on
    //             "R":false,                           // Is this reduce only
    //             "tt":0,                              // Trigger time
    //             "gtd":0,                             // good till time for GTD time in force
    //             "rm": "Reduce Only reject"           // algo order failed reason
    //         }
    //     }
    //
    var e interface{} = callDynamically("safeString", message, "e")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(e, "ORDER_TRADE_UPDATE"))) || ccxt.IsTrue((ccxt.IsEqual(e, "ALGO_UPDATE")))) {
        message = callDynamically("safeDict", message, "o", message)
    }
    this.HandleMyTrade(client, message)
    this.HandleOrder(client, message)
    this.HandleMyLiquidation(client, message)
}
/**
 * @method
 * @name binance#watchPositions
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {number} [since] since timestamp
 * @param {number} [limit] limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch positions in a portfolio margin account
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BinanceCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes39898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes39898)
            var market interface{} = nil
            var messageHash interface{} = ""
            symbols = callDynamically("marketSymbols", symbols)
            if !ccxt.IsTrue(callDynamically("isEmpty", symbols)) {
                market = callDynamically("getMarketFromSymbols", symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "watchPositions", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) || ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin"))) {
                typeVar = "future"
            }
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchPositions", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            var marketTypeObject interface{} = map[string]interface{} {}
            ccxt.AddElementToObject(marketTypeObject, "type", typeVar)
            ccxt.AddElementToObject(marketTypeObject, "subType", subType)
        
            retRes40128 := (<-this.Authenticate(this.Extend(marketTypeObject, params)))
            ccxt.PanicOnError(retRes40128)
            messageHash = ccxt.Add(ccxt.Add(typeVar, ":positions"), messageHash)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "watchPositions", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var urlType interface{} = typeVar
            if ccxt.IsTrue(isPortfolioMargin) {
                urlType = "papi"
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, symbols, isPortfolioMargin)
            var fetchPositionsSnapshot interface{} = callDynamically("handleOption", "watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = callDynamically("handleOption", "watchPositions", "awaitPositionsSnapshot", true)
            var cache interface{} = callDynamically("safeValue", this.Positions, typeVar)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(cache, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchPositionsSnapshot")))
                ccxt.PanicOnError(snapshot)
        
                ch <- callDynamically("filterBySymbolsSinceLimit", snapshot, symbols, since, limit, true)
                return nil
            }
        
            newPositions:= (<-callDynamically("watch", url, messageHash, nil, typeVar))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- callDynamically("filterBySymbolsSinceLimit", cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    isPortfolioMargin := ccxt.GetArg(optionalArgs, 1, false)
    _ = isPortfolioMargin
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if ccxt.IsTrue(ccxt.InOp(this.Positions, typeVar)) {
        return
    }
    var fetchPositionsSnapshot interface{} = callDynamically("handleOption", "watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchPositionsSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            callDynamically("spawn", this.LoadPositionsSnapshot, client, messageHash, typeVar, isPortfolioMargin)
        }
    } else {
        ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
    }
}
func  (this *BinanceCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}, typeVar interface{}, isPortfolioMargin interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
            if ccxt.IsTrue(isPortfolioMargin) {
                ccxt.AddElementToObject(params, "portfolioMargin", true)
            }
        
            positions:= (<-callDynamically("fetchPositions", nil, params))
            ccxt.PanicOnError(positions)
            ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
            var cache interface{} = ccxt.GetValue(this.Positions, typeVar)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = callDynamically("safeNumber", position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, ccxt.Add(typeVar, ":position"))
            }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         e: 'ACCOUNT_UPDATE',
    //         T: 1667881353112,
    //         E: 1667881353115,
    //         a: {
    //             B: [{
    //                 a: 'USDT',
    //                 wb: '1127.95750089',
    //                 cw: '1040.82091149',
    //                 bc: '0'
    //             }],
    //             P: [{
    //                 s: 'BTCUSDT',
    //                 pa: '-0.089',
    //                 ep: '19700.03933',
    //                 cr: '-1260.24809979',
    //                 up: '1.53058860',
    //                 mt: 'isolated',
    //                 iw: '87.13658940',
    //                 ps: 'BOTH',
    //                 ma: 'USDT'
    //             }],
    //             m: 'ORDER'
    //         }
    //     }
    //
    // each account is connected to a different endpoint
    // and has exactly one subscriptionhash which is the account type
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if !ccxt.IsTrue((ccxt.InOp(this.Positions, accountType))) {
        ccxt.AddElementToObject(this.Positions, accountType, ccxt.NewArrayCacheBySymbolBySide())
    }
    var cache interface{} = ccxt.GetValue(this.Positions, accountType)
    var data interface{} = callDynamically("safeDict", message, "a", map[string]interface{} {})
    var rawPositions interface{} = callDynamically("safeList", data, "P", []interface{}{})
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        var timestamp interface{} = callDynamically("safeInteger", message, "E")
        ccxt.AddElementToObject(position, "timestamp", timestamp)
        ccxt.AddElementToObject(position, "datetime", callDynamically("iso8601", timestamp))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = callDynamically("findMessageHashes", client, ccxt.Add(accountType, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = callDynamically("filterByArray", newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(callDynamically("isEmpty", positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(accountType, ":positions"))
}
func  (this *BinanceCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "s": "BTCUSDT", // Symbol
    //         "pa": "0", // ccxt.Position Amount
    //         "ep": "0.00000", // Entry Price
    //         "cr": "200", // (Pre-fee) Accumulated Realized
    //         "up": "0", // Unrealized PnL
    //         "mt": "isolated", // Margin Type
    //         "iw": "0.00000000", // Isolated Wallet (if isolated position)
    //         "ps": "BOTH" // ccxt.Position Side
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = callDynamically("safeString", position, "s")
    var contracts interface{} = callDynamically("safeString", position, "pa")
    var contractsAbs interface{} = ccxt.Precise.StringAbs(callDynamically("safeString", position, "pa"))
    var positionSide interface{} = callDynamically("safeStringLower", position, "ps")
    var hedged interface{} = true
    if ccxt.IsTrue(ccxt.IsEqual(positionSide, "both")) {
        hedged = false
        if !ccxt.IsTrue(ccxt.Precise.StringEq(contracts, "0")) {
            if ccxt.IsTrue(ccxt.Precise.StringLt(contracts, "0")) {
                positionSide = "short"
            } else {
                positionSide = "long"
            }
        }
    }
    return callDynamically("safePosition", map[string]interface{} {
    "info": position,
    "id": nil,
    "symbol": callDynamically("safeSymbol", marketId, nil, nil, "swap"),
    "notional": nil,
    "marginMode": callDynamically("safeString", position, "mt"),
    "liquidationPrice": nil,
    "entryPrice": callDynamically("safeNumber", position, "ep"),
    "unrealizedPnl": callDynamically("safeNumber", position, "up"),
    "percentage": nil,
    "contracts": callDynamically("parseNumber", contractsAbs),
    "contractSize": nil,
    "markPrice": nil,
    "side": positionSide,
    "hedged": hedged,
    "timestamp": nil,
    "datetime": nil,
    "maintenanceMargin": nil,
    "maintenanceMarginPercentage": nil,
    "collateral": nil,
    "initialMargin": nil,
    "initialMarginPercentage": nil,
    "leverage": nil,
    "marginRatio": nil,
})
}
/**
 * @method
 * @name binance#fetchMyTradesWs
 * @description fetch all trades made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-trade-history-user_data
 * @param {string} symbol unified market symbol
 * @param {int|undefined} [since] the earliest time in ms to fetch trades for
 * @param {int|undefined} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.endTime] the latest time in ms to fetch trades for
 * @param {int} [params.fromId] first trade Id to fetch
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *BinanceCore) FetchMyTradesWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes42208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes42208)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchMyTradesWs requires a symbol"));return nil
            }
            var market interface{} = callDynamically("market", symbol)
            var typeVar interface{} = this.GetMarketType("fetchMyTradesWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " fetchMyTradesWs does not support "), typeVar), " markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchMyTradesWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(since, nil)) {
                ccxt.AddElementToObject(payload, "startTime", since)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var fromId interface{} = callDynamically("safeInteger", params, "fromId")
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(fromId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(since, nil))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(this.Id, " fetchMyTradesWs does not support fetching by both fromId and since parameters at the same time"));return nil
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "myTrades",
                "params": this.SignParams(callDynamically("extend", payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTradesWs,
            }
        
            trades:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(trades)
        
            ch <- callDynamically("filterBySymbolSinceLimit", trades, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchTradesWs
 * @description fetch all trades made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve, default=500, max=1000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.fromId] trade ID to begin at
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *BinanceCore) FetchTradesWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes42758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes42758)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchTradesWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                ccxt.ThrowDynamicException(ccxt.BadRequest, ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " fetchTradesWs does not support "), typeVar), " markets"));return nil
            }
            var baseUrl interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var url interface{} = this.GetSbeWebSocketUrl(baseUrl)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := callDynamically("handleOptionAndParams", params, "fetchTradesWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": callDynamically("marketId", symbol),
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "trades.historical",
                "params": callDynamically("extend", payload, params),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTradesWs,
            }
        
            trades:= (<-callDynamically("watch", url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(trades)
        
            ch <- callDynamically("filterBySinceLimit", trades, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleTradesWs(client interface{}, message interface{})  {
    //
    // fetchMyTradesWs
    //
    //    {
    //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
    //        "status": 200,
    //        "result": [
    //            {
    //                "symbol": "BTCUSDT",
    //                "id": 1650422481,
    //                "orderId": 12569099453,
    //                "orderListId": -1,
    //                "price": "23416.10000000",
    //                "qty": "0.00635000",
    //                "quoteQty": "148.69223500",
    //                "commission": "0.00000000",
    //                "commissionAsset": "BNB",
    //                "time": 1660801715793,
    //                "isBuyer": false,
    //                "isMaker": true,
    //                "isBestMatch": true
    //            },
    //            ...
    //        ],
    //    }
    //
    // fetchTradesWs
    //
    //    {
    //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
    //        "status": 200,
    //        "result": [
    //            {
    //                "id": 0,
    //                "price": "0.00005000",
    //                "qty": "40.00000000",
    //                "quoteQty": "0.00200000",
    //                "time": 1500004800376,
    //                "isBuyerMaker": true,
    //                "isBestMatch": true
    //            }
    //            ...
    //        ],
    //    }
    //
    // SBE response (binary ArrayBuffer)
    // Will be decoded to same structure as JSON response
    //
    var messageHash interface{} = callDynamically("safeString", message, "id")
    var result interface{} = callDynamically("safeValue", message, "result")
    var trades interface{} = []interface{}{}
    // Check if result is already decoded (SBE format) or needs parsing (JSON format)
    if ccxt.IsTrue(!ccxt.IsEqual(result, nil)) {
        if ccxt.IsTrue(ccxt.IsArray(result)) {
            // JSON format - result is directly the array of trades
            trades = callDynamically("parseTrades", result)
        } else {
            // SBE format - result is an object with trades array and exponents
            var tradesArray interface{} = callDynamically("safeList", result, "trades", []interface{}{})
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetArrayLength(tradesArray), 0)) {
                // Convert mantissa values to decimal strings
                // Check if exponents are at parent level (TradesResponse) or per-trade (AccountTradesResponse)
                var parentPriceExponent interface{} = callDynamically("safeInteger", result, "priceExponent")
                var parentQtyExponent interface{} = callDynamically("safeInteger", result, "qtyExponent")
                var parentCommissionExponent interface{} = callDynamically("safeInteger", result, "commissionExponent")
                var normalizedTrades interface{} = []interface{}{}
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tradesArray)); i++ {
                    var trade interface{} = ccxt.GetValue(tradesArray, i)
                    // For TradesResponse (public trades), exponents are at parent level
                    // For AccountTradesResponse (myTrades), each trade has its own exponents
                    var priceExponent interface{} = callDynamically("safeInteger", trade, "priceExponent", parentPriceExponent)
                    var qtyExponent interface{} = callDynamically("safeInteger", trade, "qtyExponent", parentQtyExponent)
                    var commissionExponent interface{} = callDynamically("safeInteger", trade, "commissionExponent", parentCommissionExponent)
                    var price interface{} = callDynamically("applyExponent", trade.Price, priceExponent)
                    var qty interface{} = callDynamically("applyExponent", trade.Qty, qtyExponent)
                    var quoteQty interface{} = callDynamically("applyExponent", trade.QuoteQty, priceExponent)
                    var timestamp interface{} = ccxt.MathFloor(ccxt.Divide(trade.Time, 1000)) // microseconds to milliseconds
                    var normalized interface{} = map[string]interface{} {
                        "id": ccxt.String(trade.Id),
                        "price": ccxt.String(price),
                        "qty": ccxt.String(qty),
                        "quoteQty": ccxt.String(quoteQty),
                        "time": timestamp,
                        "isBuyerMaker": ccxt.IsEqual(trade.IsBuyerMaker, 1),
                        "isBestMatch": ccxt.IsEqual(trade.IsBestMatch, 1),
                    }
                    // Handle AccountTradesResponse specific fields
                    var orderId interface{} = callDynamically("safeInteger", trade, "orderId")
                    if ccxt.IsTrue(!ccxt.IsEqual(orderId, nil)) {
                        ccxt.AddElementToObject(normalized, "orderId", orderId)
                        ccxt.AddElementToObject(normalized, "orderListId", callDynamically("safeInteger", trade, "orderListId"))
                        ccxt.AddElementToObject(normalized, "symbol", callDynamically("safeString", trade, "symbol"))
                        // Convert commission from mantissa
                        var commissionMantissa interface{} = callDynamically("safeInteger", trade, "commission")
                        if ccxt.IsTrue(!ccxt.IsEqual(commissionMantissa, nil)) {
                            ccxt.AddElementToObject(normalized, "commission", ccxt.String(callDynamically("applyExponent", commissionMantissa, commissionExponent)))
                        }
                        ccxt.AddElementToObject(normalized, "commissionAsset", callDynamically("safeString", trade, "commissionAsset"))
                        ccxt.AddElementToObject(normalized, "isBuyer", ccxt.IsEqual(trade.IsBuyer, 1))
                        ccxt.AddElementToObject(normalized, "isMaker", ccxt.IsEqual(trade.IsMaker, 1))
                    }
                    ccxt.AppendToArray(&normalizedTrades, normalized)
                }
                trades = callDynamically("parseTrades", normalizedTrades)
            }
        }
    }
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name binance#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch trades in a portfolio margin account
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *BinanceCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes43698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes43698)
            var typeVar interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = callDynamically("market", symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            typeVarparamsVariable := callDynamically("handleMarketTypeAndParams", "watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := callDynamically("handleSubTypeAndParams", "watchMyTrades", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(callDynamically("isLinear", typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(callDynamically("isInverse", typeVar, subType)) {
                typeVar = "delivery"
            }
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = callDynamically("symbol", symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
                params = callDynamically("extend", params, map[string]interface{} {
            "type": ccxt.GetValue(market, "type"),
            "symbol": symbol,
        })
            }
        
            retRes43908 := (<-this.Authenticate(this.Extend(map[string]interface{} {
                "type": typeVar,
                "subType": subType,
            }, params)))
            ccxt.PanicOnError(retRes43908)
            var urlType interface{} = typeVar // we don't change type because the listening key is different
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) {
                urlType = "spot" // spot-margin shares the same stream as regular spot
            }
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := callDynamically("handleOptionAndParams2", params, "watchMyTrades", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var url interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var message interface{} = nil
        
            trades:= (<-callDynamically("watch", url, messageHash, message, typeVar))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- callDynamically("filterBySymbolSinceLimit", trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleMyTrade(client interface{}, message interface{})  {
    var messageHash interface{} = "myTrades"
    var executionType interface{} = callDynamically("safeString", message, "x")
    if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        var trade interface{} = this.ParseWsTrade(message)
        var orderId interface{} = callDynamically("safeString", trade, "order")
        var tradeFee interface{} = callDynamically("safeDict", trade, "fee", map[string]interface{} {})
        tradeFee = callDynamically("extend", map[string]interface{} {}, tradeFee)
        var symbol interface{} = callDynamically("safeString", trade, "symbol")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(orderId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(tradeFee, nil))) && ccxt.IsTrue(!ccxt.IsEqual(symbol, nil))) {
            var cachedOrders interface{} = this.Orders
            if ccxt.IsTrue(!ccxt.IsEqual(cachedOrders, nil)) {
                var orders interface{} = callDynamically("safeValue", cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
                var order interface{} = callDynamically("safeValue", orders, orderId)
                if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
                    // accumulate order fees
                    var fees interface{} = callDynamically("safeValue", order, "fees")
                    var fee interface{} = callDynamically("safeValue", order, "fee")
                    if !ccxt.IsTrue(callDynamically("isEmpty", fees)) {
                        var insertNewFeeCurrency interface{} = true
                        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(fees)); i++ {
                            var orderFee interface{} = ccxt.GetValue(fees, i)
                            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderFee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                                var feeCost interface{} = callDynamically("sum", ccxt.GetValue(tradeFee, "cost"), ccxt.GetValue(orderFee, "cost"))
                                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(order, "fees"), i), "cost", ccxt.ParseFloat(callDynamically("currencyToPrecision", ccxt.GetValue(tradeFee, "currency"), feeCost)))
                                insertNewFeeCurrency = false
                                break
                            }
                        }
                        if ccxt.IsTrue(insertNewFeeCurrency) {
                            retRes444732 := ccxt.GetValue(order, "fees")
                            ccxt.AppendToArray(&retRes444732, tradeFee)
                        }
                    } else if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                            var feeCost interface{} = callDynamically("sum", ccxt.GetValue(fee, "cost"), ccxt.GetValue(tradeFee, "cost"))
                            ccxt.AddElementToObject(ccxt.GetValue(order, "fee"), "cost", ccxt.ParseFloat(callDynamically("currencyToPrecision", ccxt.GetValue(tradeFee, "currency"), feeCost)))
                        } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), nil)) {
                            ccxt.AddElementToObject(order, "fee", tradeFee)
                        } else {
                            ccxt.AddElementToObject(order, "fees", []interface{}{fee, tradeFee})
                            ccxt.AddElementToObject(order, "fee", nil)
                        }
                    } else {
                        ccxt.AddElementToObject(order, "fee", tradeFee)
                    }
                    // save this trade in the order
                    var orderTrades interface{} = callDynamically("safeList", order, "trades", []interface{}{})
                    ccxt.AppendToArray(&orderTrades, trade)
                    ccxt.AddElementToObject(order, "trades", orderTrades)
                }
            }
        }
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = callDynamically("safeInteger", this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var myTrades interface{} = this.MyTrades
        myTrades.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
        var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHashSymbol)
    }
}
func  (this *BinanceCore) HandleOrder(client interface{}, message interface{})  {
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = callDynamically("safeString", parsed, "symbol")
    var orderId interface{} = callDynamically("safeString", parsed, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = callDynamically("safeInteger", this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cachedOrders interface{} = this.Orders
        var orders interface{} = callDynamically("safeValue", cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var order interface{} = callDynamically("safeValue", orders, orderId)
        if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
            var fee interface{} = callDynamically("safeValue", order, "fee")
            if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                ccxt.AddElementToObject(parsed, "fee", fee)
            }
            var fees interface{} = callDynamically("safeValue", order, "fees")
            if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
                ccxt.AddElementToObject(parsed, "fees", fees)
            }
            ccxt.AddElementToObject(parsed, "trades", callDynamically("safeValue", order, "trades"))
            var timestamp interface{} = callDynamically("safeInteger", parsed, "timestamp")
            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                ccxt.AddElementToObject(parsed, "timestamp", callDynamically("safeInteger", order, "timestamp"))
                ccxt.AddElementToObject(parsed, "datetime", callDynamically("safeString", order, "datetime"))
            }
        }
        cachedOrders.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = "orders"
        var symbolSpecificMessageHash interface{} = ccxt.Add("orders:", symbol)
        client.(ccxt.ClientInterface).Resolve(cachedOrders, messageHash)
        client.(ccxt.ClientInterface).Resolve(cachedOrders, symbolSpecificMessageHash)
    }
}
func  (this *BinanceCore) HandleAcountUpdate(client interface{}, message interface{})  {
    this.HandleBalance(client, message)
    this.HandlePositions(client, message)
}
func  (this *BinanceCore) HandleWsError(client interface{}, message interface{})  {
    //
    //    {
    //        "error": {
    //            "code": 2,
    //            "msg": "Invalid request: invalid stream"
    //        },
    //        "id": 1
    //    }
    //
    var id interface{} = callDynamically("safeString", message, "id")
    var rejected interface{} = false
    var error interface{} = callDynamically("safeDict", message, "error", map[string]interface{} {})
    var code interface{} = callDynamically("safeInteger", error, "code")
    var msg interface{} = callDynamically("safeString", error, "msg")
    
        {
             func(this *BinanceCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BinanceCore) interface{} {
                            // catch block:
                                    rejected = true
            // private endpoint uses id as messageHash
            client.(ccxt.ClientInterface).Reject(e, id)
            // public endpoint stores messageHash in subscriptions
            var subscriptionKeys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionKeys)); i++ {
                var subscriptionHash interface{} = ccxt.GetValue(subscriptionKeys, i)
                var subscriptionId interface{} = callDynamically("safeString", ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash), "id")
                var subscription interface{} = callDynamically("safeString", ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash), "subscription")
                if ccxt.IsTrue(ccxt.IsEqual(id, subscriptionId)) {
                    client.(ccxt.ClientInterface).Reject(e, subscriptionHash)
                    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subscription)
                    }
                }
            }
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        callDynamically("handleErrors", code, msg, client.(ccxt.ClientInterface).GetUrl(), "", map[string]interface{} {}, callDynamically("json", error), error, map[string]interface{} {}, map[string]interface{} {})
    		    return nil
    	    }(this)
        
            }
    if !ccxt.IsTrue(rejected) {
        client.(ccxt.ClientInterface).Reject(message, id)
    }
    // reset connection if 5xx error
    var codeString interface{} = callDynamically("safeString", error, "code")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(codeString, nil))) && ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(codeString, 0), "5")))) {
        client.(ccxt.ClientInterface).Reset(message)
    }
}
func  (this *BinanceCore) HandleEventStreamTerminated(client interface{}, message interface{})  {
    //
    //    {
    //        e: 'eventStreamTerminated',
    //        E: 1757896885229
    //    }
    //
    var event interface{} = callDynamically("safeString", message, "e")
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    if ccxt.IsTrue(ccxt.IsEqual(event, "eventStreamTerminated")) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), accountType)
        client.(ccxt.ClientInterface).Reject(message, accountType)
    }
}
func  (this *BinanceCore) HandleMessage(client interface{}, message interface{})  {
    // handle WebSocketAPI
    var eventMsg interface{} = callDynamically("safeDict", message, "event")
    if ccxt.IsTrue(!ccxt.IsEqual(eventMsg, nil)) {
        message = eventMsg
    }
    var status interface{} = callDynamically("safeString", message, "status")
    var error interface{} = callDynamically("safeValue", message, "error")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(error, nil))) || ccxt.IsTrue((ccxt.IsTrue(!ccxt.IsEqual(status, nil)) && ccxt.IsTrue(!ccxt.IsEqual(status, "200"))))) {
        this.HandleWsError(client, message)
        return
    }
    // user subscription wraps message in subscriptionId and event
    var id interface{} = callDynamically("safeString", message, "id")
    var subscriptions interface{} = callDynamically("safeValue", client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var method interface{} = callDynamically("safeValue", subscriptions, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
        return
    }
    // handle other APIs
    var methods interface{} = map[string]interface{} {
        "depthUpdate": this.HandleOrderBook,
        "trade": this.HandleTrade,
        "aggTrade": this.HandleTrade,
        "kline": this.HandleOHLCV,
        "markPrice_kline": this.HandleOHLCV,
        "indexPrice_kline": this.HandleOHLCV,
        "1hTicker@arr": this.HandleTickers,
        "4hTicker@arr": this.HandleTickers,
        "1dTicker@arr": this.HandleTickers,
        "24hrTicker@arr": this.HandleTickers,
        "24hrMiniTicker@arr": this.HandleTickers,
        "1hTicker": this.HandleTickers,
        "4hTicker": this.HandleTickers,
        "1dTicker": this.HandleTickers,
        "24hrTicker": this.HandleTickers,
        "24hrMiniTicker": this.HandleTickers,
        "markPriceUpdate": this.HandleMarkPrices,
        "markPriceUpdate@arr": this.HandleMarkPrices,
        "bookTicker": this.HandleBidsAsks,
        "outboundAccountPosition": this.HandleBalance,
        "balanceUpdate": this.HandleBalance,
        "ACCOUNT_UPDATE": this.HandleAcountUpdate,
        "executionReport": this.HandleOrderUpdate,
        "ORDER_TRADE_UPDATE": this.HandleOrderUpdate,
        "ALGO_UPDATE": this.HandleOrderUpdate,
        "forceOrder": this.HandleLiquidation,
        "eventStreamTerminated": this.HandleEventStreamTerminated,
        "externalLockUpdate": this.HandleBalance,
    }
    var event interface{} = callDynamically("safeString", message, "e")
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        var data interface{} = ccxt.GetValue(message, 0)
        event = ccxt.Add(callDynamically("safeString", data, "e"), "@arr")
    }
    method = callDynamically("safeValue", methods, event)
    if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
        var requestId interface{} = callDynamically("safeString", message, "id")
        if ccxt.IsTrue(!ccxt.IsEqual(requestId, nil)) {
            this.HandleSubscriptionStatus(client, message)
            return
        }
        // special case for the real-time bookTicker, since it comes without an event identifier
        //
        //     {
        //         "u": 7488717758,
        //         "s": "BTCUSDT",
        //         "b": "28621.74000000",
        //         "B": "1.43278800",
        //         "a": "28621.75000000",
        //         "A": "2.52500800"
        //     }
        //
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, nil)) && ccxt.IsTrue((ccxt.InOp(message, "a")))) && ccxt.IsTrue((ccxt.InOp(message, "b")))) {
            this.HandleBidsAsks(client, message)
        }
    } else {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *BinanceCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
