package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BinanceCore struct {
	*ccxt.BinanceCore
	base *ccxt.BinanceCore
}

func NewBinanceCore() *BinanceCore {
    p := &BinanceCore{}
	base := &ccxt.BinanceCore{}
	p.base = base
	p.BinanceCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BinanceCore) Describe() interface{}  {
    var superDescribe interface{} = this.base.Describe()
    return this.DeepExtend(superDescribe, this.DescribeData())
}
func  (this *BinanceCore) DescribeData() interface{}  {
    return map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchLiquidations": true,
            "watchLiquidationsForSymbols": true,
            "watchMyLiquidations": true,
            "watchMyLiquidationsForSymbols": true,
            "watchBidsAsks": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchOrdersForSymbols": true,
            "watchPositions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchMarkPrices": true,
            "watchMarkPrice": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "createOrderWs": true,
            "editOrderWs": true,
            "cancelOrderWs": true,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": true,
            "fetchBalanceWs": true,
            "fetchDepositsWs": false,
            "fetchMarketsWs": false,
            "fetchMyTradesWs": true,
            "fetchOHLCVWs": true,
            "fetchOrderBookWs": true,
            "fetchOpenOrdersWs": true,
            "fetchOrderWs": true,
            "fetchOrdersWs": true,
            "fetchPositionWs": true,
            "fetchPositionForSymbolWs": true,
            "fetchPositionsWs": true,
            "fetchTickerWs": true,
            "fetchTradesWs": true,
            "fetchTradingFeesWs": false,
            "fetchWithdrawalsWs": false,
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://stream.testnet.binance.vision/ws",
                    "margin": "wss://stream.testnet.binance.vision/ws",
                    "future": "wss://fstream.binancefuture.com/ws",
                    "delivery": "wss://dstream.binancefuture.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://ws-api.testnet.binance.vision/ws-api/v3",
                        "future": "wss://testnet.binancefuture.com/ws-fapi/v1",
                        "delivery": "wss://testnet.binancefuture.com/ws-dapi/v1",
                    },
                },
            },
            "demo": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://demo-stream.binance.com/ws",
                    "margin": "wss://demo-stream.binance.com/ws",
                    "future": "wss://fstream.binancefuture.com/ws",
                    "delivery": "wss://dstream.binancefuture.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://demo-ws-api.binance.com/ws-api/v3",
                        "future": "wss://testnet.binancefuture.com/ws-fapi/v1",
                        "delivery": "wss://testnet.binancefuture.com/ws-dapi/v1",
                    },
                },
            },
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://stream.binance.com:9443/ws",
                    "margin": "wss://stream.binance.com:9443/ws",
                    "future": "wss://fstream.binance.com/ws",
                    "delivery": "wss://dstream.binance.com/ws",
                    "ws-api": map[string]interface{} {
                        "spot": "wss://ws-api.binance.com:443/ws-api/v3",
                        "future": "wss://ws-fapi.binance.com/ws-fapi/v1",
                        "delivery": "wss://ws-dapi.binance.com/ws-dapi/v1",
                    },
                    "papi": "wss://fstream.binance.com/pm/ws",
                },
            },
            "doc": "https://developers.binance.com/en",
        },
        "streaming": map[string]interface{} {
            "keepAlive": 180000,
        },
        "options": map[string]interface{} {
            "returnRateLimits": false,
            "streamLimits": map[string]interface{} {
                "spot": 50,
                "margin": 50,
                "future": 50,
                "delivery": 50,
            },
            "subscriptionLimitByStream": map[string]interface{} {
                "spot": 200,
                "margin": 200,
                "future": 200,
                "delivery": 200,
            },
            "streamBySubscriptionsHash": this.CreateSafeDictionary(),
            "streamIndex": ccxt.OpNeg(1),
            "watchOrderBookRate": 100,
            "liquidationsLimit": 1000,
            "myLiquidationsLimit": 1000,
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "requestId": this.CreateSafeDictionary(),
            "watchOrderBookLimit": 1000,
            "watchTrades": map[string]interface{} {
                "name": "trade",
            },
            "watchTicker": map[string]interface{} {
                "name": "ticker",
            },
            "watchTickers": map[string]interface{} {
                "name": "ticker",
            },
            "watchOHLCV": map[string]interface{} {
                "name": "kline",
            },
            "watchOrderBook": map[string]interface{} {
                "maxRetries": 3,
                "checksum": true,
            },
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": false,
                "awaitBalanceSnapshot": true,
            },
            "watchLiquidationsForSymbols": map[string]interface{} {
                "defaultType": "swap",
            },
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
            "wallet": "wb",
            "listenKeyRefreshRate": 1200000,
            "ws": map[string]interface{} {
                "cost": 5,
            },
            "tickerChannelsMap": map[string]interface{} {
                "24hrTicker": "ticker",
                "24hrMiniTicker": "miniTicker",
                "markPriceUpdate": "markPrice",
                "1hTicker": "ticker_1h",
                "4hTicker": "ticker_4h",
                "1dTicker": "ticker_1d",
                "bookTicker": "bookTicker",
            },
        },
    }
}
func  (this *BinanceCore) RequestId(url interface{}) interface{}  {
    var options interface{} = this.SafeDict(this.Options, "requestId", this.CreateSafeDictionary())
    var previousValue interface{} = this.SafeInteger(options, url, 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "requestId"), url, newValue)
    return newValue
}
func  (this *BinanceCore) IsSpotUrl(client interface{}) interface{}  {
    return ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "/stream"), ccxt.OpNeg(1)))) || ccxt.IsTrue((ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "demo-stream"), ccxt.OpNeg(1))))
}
func  (this *BinanceCore) Stream(typeVar interface{}, subscriptionHash interface{}, optionalArgs ...interface{}) interface{}  {
    numSubscriptions := ccxt.GetArg(optionalArgs, 0, 1)
    _ = numSubscriptions
    var streamBySubscriptionsHash interface{} = this.SafeDict(this.Options, "streamBySubscriptionsHash", this.CreateSafeDictionary())
    var stream interface{} = this.SafeString(streamBySubscriptionsHash, subscriptionHash)
    if ccxt.IsTrue(ccxt.IsEqual(stream, nil)) {
        var streamIndex interface{} = this.SafeInteger(this.Options, "streamIndex", ccxt.OpNeg(1))
        var streamLimits interface{} = this.SafeValue(this.Options, "streamLimits")
        var streamLimit interface{} = this.SafeInteger(streamLimits, typeVar)
        streamIndex = ccxt.Add(streamIndex, 1)
        var normalizedIndex interface{} = ccxt.Mod(streamIndex, streamLimit)
        ccxt.AddElementToObject(this.Options, "streamIndex", streamIndex)
        stream = this.NumberToString(normalizedIndex)
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "streamBySubscriptionsHash"), subscriptionHash, stream)
        var subscriptionsByStreams interface{} = this.SafeValue(this.Options, "numSubscriptionsByStream")
        if ccxt.IsTrue(ccxt.IsEqual(subscriptionsByStreams, nil)) {
            ccxt.AddElementToObject(this.Options, "numSubscriptionsByStream", this.CreateSafeDictionary())
        }
        var subscriptionsByStream interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "numSubscriptionsByStream"), stream, 0)
        var newNumSubscriptions interface{} = ccxt.Add(subscriptionsByStream, numSubscriptions)
        var subscriptionLimitByStream interface{} = this.SafeInteger(ccxt.GetValue(this.Options, "subscriptionLimitByStream"), typeVar, 200)
        if ccxt.IsTrue(ccxt.IsGreaterThan(newNumSubscriptions, subscriptionLimitByStream)) {
            panic(ccxt.BadRequest(ccxt.Add(this.Id, " reached the limit of subscriptions by stream. Increase the number of streams, or increase the stream limit or subscription limit by stream if the exchange allows.")))
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Options, "numSubscriptionsByStream"), stream, ccxt.Add(subscriptionsByStream, numSubscriptions))
    }
    return stream
}
/**
 * @method
 * @name binance#watchLiquidations
 * @description watch the public liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/ccxt.Liquidation-ccxt.Order-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/ccxt.Liquidation-ccxt.Order-Streams
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes23815 :=  (<-this.WatchLiquidationsForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes23815)
                ch <- retRes23815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchLiquidationsForSymbols
 * @description watch the public liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-ccxt.Liquidation-ccxt.Order-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-ccxt.Liquidation-ccxt.Order-Streams
 * @param {string[]} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2548)
            var subscriptionHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var streamHash interface{} = "liquidations"
            symbols = this.MarketSymbols(symbols, nil, true, true)
            if ccxt.IsTrue(this.IsEmpty(symbols)) {
                ccxt.AppendToArray(&subscriptionHashes, ccxt.Add("!", "forceOrder@arr"))
                ccxt.AppendToArray(&messageHashes, "liquidations")
            } else {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                    ccxt.AppendToArray(&subscriptionHashes, ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@forceOrder"))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("liquidations::", ccxt.GetValue(symbols, i)))
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchLiquidationsForSymbols", firstMarket, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchLiquidationsForSymbols is not supported for spot symbols")))
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchLiquidationsForSymbols", firstMarket, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            var numSubscriptions interface{} =     ccxt.GetArrayLength(subscriptionHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, numSubscriptions))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
        
            newLiquidations:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), subscriptionHashes, subscribe))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleLiquidation(client interface{}, message interface{})  {
    //
    // future
    //    {
    //        "e":"forceOrder",
    //        "E":1698871323061,
    //        "o":{
    //           "s":"BTCUSDT",
    //           "S":"BUY",
    //           "o":"LIMIT",
    //           "f":"IOC",
    //           "q":"1.437",
    //           "p":"35100.81",
    //           "ap":"34959.70",
    //           "X":"FILLED",
    //           "l":"1.437",
    //           "z":"1.437",
    //           "T":1698871323059
    //        }
    //    }
    // delivery
    //    {
    //        "e":"forceOrder",              // Event Type
    //        "E": 1591154240950,            // Event Time
    //        "o":{
    //            "s":"BTCUSD_200925",       // Symbol
    //            "ps": "BTCUSD",            // Pair
    //            "S":"SELL",                // Side
    //            "o":"LIMIT",               // ccxt.Order Type
    //            "f":"IOC",                 // Time in Force
    //            "q":"1",                   // Original Quantity
    //            "p":"9425.5",              // Price
    //            "ap":"9496.5",             // Average Price
    //            "X":"FILLED",              // ccxt.Order Status
    //            "l":"1",                   // ccxt.Order Last Filled Quantity
    //            "z":"1",                   // ccxt.Order Filled Accumulated Quantity
    //            "T": 1591154240949,        // ccxt.Order ccxt.Trade Time
    //        }
    //    }
    //
    var rawLiquidation interface{} = this.SafeValue(message, "o", map[string]interface{} {})
    var marketId interface{} = this.SafeString(rawLiquidation, "s")
    var market interface{} = this.SafeMarket(marketId, nil, "", "contract")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var liquidation interface{} = this.ParseWsLiquidation(rawLiquidation, market)
    var liquidations interface{} = this.SafeValue(this.Liquidations, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(liquidations, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "liquidationsLimit", 1000)
        liquidations = ccxt.NewArrayCache(limit)
    }
    liquidations.(ccxt.Appender).Append(liquidation)
    ccxt.AddElementToObject(this.Liquidations, symbol, liquidations)
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "liquidations")
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("liquidations::", symbol))
}
func  (this *BinanceCore) ParseWsLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // future
    //    {
    //        "s":"BTCUSDT",
    //        "S":"BUY",
    //        "o":"LIMIT",
    //        "f":"IOC",
    //        "q":"1.437",
    //        "p":"35100.81",
    //        "ap":"34959.70",
    //        "X":"FILLED",
    //        "l":"1.437",
    //        "z":"1.437",
    //        "T":1698871323059
    //    }
    // delivery
    //    {
    //        "s":"BTCUSD_200925",       // Symbol
    //        "ps": "BTCUSD",            // Pair
    //        "S":"SELL",                // Side
    //        "o":"LIMIT",               // ccxt.Order Type
    //        "f":"IOC",                 // Time in Force
    //        "q":"1",                   // Original Quantity
    //        "p":"9425.5",              // Price
    //        "ap":"9496.5",             // Average Price
    //        "X":"FILLED",              // ccxt.Order Status
    //        "l":"1",                   // ccxt.Order Last Filled Quantity
    //        "z":"1",                   // ccxt.Order Filled Accumulated Quantity
    //        "T": 1591154240949,        // ccxt.Order ccxt.Trade Time
    //    }
    // myLiquidation
    //    {
    //        "s":"BTCUSDT",              // Symbol
    //        "c":"TEST",                 // ccxt.Client ccxt.Order Id
    //          // special client order id:
    //          // starts with "autoclose-": liquidation order
    //          // "adl_autoclose": ADL auto close order
    //          // "settlement_autoclose-": settlement order for delisting or delivery
    //        "S":"SELL",                 // Side
    //        "o":"TRAILING_STOP_MARKET", // ccxt.Order Type
    //        "f":"GTC",                  // Time in Force
    //        "q":"0.001",                // Original Quantity
    //        "p":"0",                    // Original Price
    //        "ap":"0",                   // Average Price
    //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //        "x":"NEW",                  // Execution Type
    //        "X":"NEW",                  // ccxt.Order Status
    //        "i":8886774,                // ccxt.Order Id
    //        "l":"0",                    // ccxt.Order Last Filled Quantity
    //        "z":"0",                    // ccxt.Order Filled Accumulated Quantity
    //        "L":"0",                    // Last Filled Price
    //        "N":"USDT",                 // Commission Asset, will not push if no commission
    //        "n":"0",                    // Commission, will not push if no commission
    //        "T":1568879465650,          // ccxt.Order ccxt.Trade Time
    //        "t":0,                      // ccxt.Trade Id
    //        "b":"0",                    // ccxt.Bids Notional
    //        "a":"9.91",                 // Ask Notional
    //        "m":false,                  // Is this trade the maker side?
    //        "R":false,                  // Is this reduce only
    //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
    //        "ot":"TRAILING_STOP_MARKET",// Original ccxt.Order Type
    //        "ps":"LONG",                // ccxt.Position Side
    //        "cp":false,                 // If Close-All, pushed with conditional order
    //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //        "pP": false,                // If price protection is turned on
    //        "si": 0,                    // ignore
    //        "ss": 0,                    // ignore
    //        "rp":"0",                   // Realized Profit of the trade
    //        "V":"EXPIRE_TAKER",         // STP mode
    //        "pm":"OPPONENT",            // Price match mode
    //        "gtd":0                     // TIF GTD order auto cancel time
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(liquidation, "s")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(liquidation, "T")
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": this.SafeNumber(liquidation, "l"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "price": this.SafeNumber(liquidation, "ap"),
        "side": this.SafeStringLower(liquidation, "S"),
        "baseValue": nil,
        "quoteValue": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
/**
 * @method
 * @name binance#watchMyLiquidations
 * @description watch the private liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchMyLiquidations(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            ch <- this.WatchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMyLiquidationsForSymbols
 * @description watch the private liquidations of a trading pair
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @param {string[]} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmex api endpoint
 * @returns {object} an array of [liquidation structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#liquidation-structure}
 */
func  (this *BinanceCore) WatchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4788)
            symbols = this.MarketSymbols(symbols, nil, true, true, true)
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var messageHashes interface{} = []interface{}{"myLiquidations"}
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("myLiquidations::", symbol))
                }
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyLiquidationsForSymbols", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchMyLiquidationsForSymbols", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
        
            retRes4978 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes4978)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            var message interface{} = nil
        
            newLiquidations:= (<-this.WatchMultiple(url, messageHashes, message, []interface{}{typeVar}))
            ccxt.PanicOnError(newLiquidations)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newLiquidations
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Liquidations, symbols, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleMyLiquidation(client interface{}, message interface{})  {
    //
    //    {
    //        "s":"BTCUSDT",              // Symbol
    //        "c":"TEST",                 // ccxt.Client ccxt.Order Id
    //          // special client order id:
    //          // starts with "autoclose-": liquidation order
    //          // "adl_autoclose": ADL auto close order
    //          // "settlement_autoclose-": settlement order for delisting or delivery
    //        "S":"SELL",                 // Side
    //        "o":"TRAILING_STOP_MARKET", // ccxt.Order Type
    //        "f":"GTC",                  // Time in Force
    //        "q":"0.001",                // Original Quantity
    //        "p":"0",                    // Original Price
    //        "ap":"0",                   // Average Price
    //        "sp":"7103.04",             // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //        "x":"NEW",                  // Execution Type
    //        "X":"NEW",                  // ccxt.Order Status
    //        "i":8886774,                // ccxt.Order Id
    //        "l":"0",                    // ccxt.Order Last Filled Quantity
    //        "z":"0",                    // ccxt.Order Filled Accumulated Quantity
    //        "L":"0",                    // Last Filled Price
    //        "N":"USDT",                 // Commission Asset, will not push if no commission
    //        "n":"0",                    // Commission, will not push if no commission
    //        "T":1568879465650,          // ccxt.Order ccxt.Trade Time
    //        "t":0,                      // ccxt.Trade Id
    //        "b":"0",                    // ccxt.Bids Notional
    //        "a":"9.91",                 // Ask Notional
    //        "m":false,                  // Is this trade the maker side?
    //        "R":false,                  // Is this reduce only
    //        "wt":"CONTRACT_PRICE",      // Stop Price Working Type
    //        "ot":"TRAILING_STOP_MARKET",// Original ccxt.Order Type
    //        "ps":"LONG",                // ccxt.Position Side
    //        "cp":false,                 // If Close-All, pushed with conditional order
    //        "AP":"7476.89",             // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //        "cr":"5.0",                 // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //        "pP": false,                // If price protection is turned on
    //        "si": 0,                    // ignore
    //        "ss": 0,                    // ignore
    //        "rp":"0",                   // Realized Profit of the trade
    //        "V":"EXPIRE_TAKER",         // STP mode
    //        "pm":"OPPONENT",            // Price match mode
    //        "gtd":0                     // TIF GTD order auto cancel time
    //    }
    //
    var orderType interface{} = this.SafeString(message, "o")
    if ccxt.IsTrue(!ccxt.IsEqual(orderType, "LIQUIDATION")) {
        return
    }
    var marketId interface{} = this.SafeString(message, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId)
    var liquidation interface{} = this.ParseWsLiquidation(message, market)
    var myLiquidations interface{} = this.SafeValue(this.MyLiquidations, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(myLiquidations, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "myLiquidationsLimit", 1000)
        myLiquidations = ccxt.NewArrayCache(limit)
    }
    myLiquidations.(ccxt.Appender).Append(liquidation)
    ccxt.AddElementToObject(this.MyLiquidations, symbol, myLiquidations)
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, "myLiquidations")
    client.(ccxt.ClientInterface).Resolve([]interface{}{liquidation}, ccxt.Add("myLiquidations::", symbol))
}
/**
 * @method
 * @name binance#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            // todo add support for <levels>-snapshots (depth)
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams        // <symbol>@depth<levels>@100ms or <symbol>@depth<levels> (1000ms)
            // valid <levels> are 5, 10, or 20
            //
            // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            //
            // notice the differences between trading futures and spot trading
            // the algorithms use different urls in step 1
            // delta caching and merging also differs in steps 4, 5, 6
            //
            // spot/margin
            // https://binance-docs.github.io/apidocs/spot/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
            // 2. Buffer the events you receive from the stream.
            // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
            // 4. Drop any event where u is <= lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            // futures
            // https://binance-docs.github.io/apidocs/futures/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://fstream.binance.com/stream?streams=btcusdt@depth.
            // 2. Buffer the events you receive from the stream. For same price, latest received update covers the previous one.
            // 3. Get a depth snapshot from https://fapi.binance.com/fapi/v1/depth?symbol=BTCUSDT&limit=1000 .
            // 4. Drop any event where u is < lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
            // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes62415 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes62415)
        ch <- retRes62415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6438)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var name interface{} = "depth"
            var streamHash interface{} = "multipleOrderbook"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchOrderBookForSymbols() accepts 200 symbols at most. To watch more symbols call watchOrderBookForSymbols() multiple times")))
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var watchOrderBookRate interface{} = this.SafeString(this.Options, "watchOrderBookRate", "100")
            var subParams interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook::", symbol))
                var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                var symbolHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(subscriptionHash, "@"), watchOrderBookRate), "ms")
                ccxt.AppendToArray(&subParams, symbolHash)
            }
            var messageHashesLength interface{} =     ccxt.GetArrayLength(messageHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, messageHashesLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": ccxt.ToString(requestId),
                "name": name,
                "symbols": symbols,
                "method": this.HandleOrderBookSubscription,
                "limit": limit,
                "type": typeVar,
                "params": params,
            }
        
            orderbook:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7068)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var name interface{} = "depth"
            var streamHash interface{} = "multipleOrderbook"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var watchOrderBookRate interface{} = this.SafeString(this.Options, "watchOrderBookRate", "100")
            var subParams interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("orderbook::", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                var subscriptionHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                var symbolHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(subscriptionHash, "@"), watchOrderBookRate), "ms")
                ccxt.AppendToArray(&subParams, symbolHash)
            }
            var messageHashesLength interface{} =     ccxt.GetArrayLength(subMessageHashes)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, messageHashesLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "symbols": symbols,
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "topic": "orderbook",
            }
        
                retRes74715 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscription))
                ccxt.PanicOnError(retRes74715)
                ch <- retRes74715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes76515 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes76515)
                ch <- retRes76515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrderBookWs
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#order-book
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/ccxt.Order-Book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BinanceCore) FetchOrderBookWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7808)
            var market interface{} = this.Market(symbol)
            var payload interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var marketType interface{} = this.GetMarketType("fetchOrderBookWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(marketType, "future")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOrderBookWs only supports swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "createOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            params = this.Omit(params, "test")
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "depth",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleFetchOrderBook,
            }
        
            orderbook:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orderbook)
            ccxt.AddElementToObject(orderbook, "symbol", ccxt.GetValue(market, "symbol"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleFetchOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "id":"51e2affb-0aba-4821-ba75-f2625006eb43",
    //        "status":200,
    //        "result":{
    //            "lastUpdateId":1027024,
    //            "E":1589436922972,
    //            "T":1589436922959,
    //            "bids":[
    //               [
    //                  "4.00000000",
    //                  "431.00000000"
    //               ]
    //            ],
    //            "asks":[
    //               [
    //                  "4.00000200",
    //                  "12.00000000"
    //               ]
    //            ]
    //        }
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeDict(message, "result")
    var timestamp interface{} = this.SafeInteger(result, "T")
    var orderbook interface{} = this.ParseOrderBook(result, nil, timestamp)
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger2(result, "lastUpdateId", "u"))
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BinanceCore) FetchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var symbol interface{} = this.SafeString(subscription, "symbol")
            var messageHash interface{} = ccxt.Add("orderbook::", symbol)
            
                {
                     func(this *BinanceCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *BinanceCore) interface{} {
                                    // catch block:
                                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
                    var typeVar interface{} = this.SafeValue(subscription, "type")
                    var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
                    var params interface{} = this.SafeValue(subscription, "params")
                    // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
                    // todo: this is a synch blocking call - make it async
                    // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            
                    snapshot:= (<-this.FetchRestOrderBookSafe(symbol, limit, params))
                    ccxt.PanicOnError(snapshot)
                    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Orderbooks, symbol), nil)) {
            
                        return nil
                    }
                    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
                    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
                    // unroll the accumulated deltas
                    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
                    orderbook.(ccxt.OrderBookInterface).SetCache([]interface{}{})
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
                        var messageItem interface{} = ccxt.GetValue(messages, i)
                        var U interface{} = this.SafeInteger(messageItem, "U")
                        var u interface{} = this.SafeInteger(messageItem, "u")
                        var pu interface{} = this.SafeInteger(messageItem, "pu")
                        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                            // 4. Drop any event where u is < lastUpdateId in the snapshot
                            if ccxt.IsTrue(ccxt.IsLessThan(u, ccxt.GetValue(orderbook, "nonce"))) {
                                continue
                            }
                            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual(U, ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))))) || ccxt.IsTrue((ccxt.IsEqual(pu, ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, messageItem, orderbook)
                            }
                        } else {
                            // 4. Drop any event where u is <= lastUpdateId in the snapshot
                            if ccxt.IsTrue(ccxt.IsLessThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))) {
                                continue
                            }
                            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual((ccxt.Subtract(u, 1)), ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, messageItem, orderbook)
                            }
                        }
                    }
                    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BinanceCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BinanceCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    var u interface{} = this.SafeInteger(message, "u")
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), this.SafeValue(message, "a", []interface{}{}))
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), this.SafeValue(message, "b", []interface{}{}))
    ccxt.AddElementToObject(orderbook, "nonce", u)
    var timestamp interface{} = this.SafeInteger(message, "E")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    return orderbook
}
func  (this *BinanceCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //     {
    //         "e": "depthUpdate", // Event type
    //         "E": 1577554482280, // Event time
    //         "s": "BNBBTC", // Symbol
    //         "U": 157, // First update ID in event
    //         "u": 160, // Final update ID in event
    //         "b": [ // bids
    //             [ "0.0024", "10" ], // price, size
    //         ],
    //         "a": [ // asks
    //             [ "0.0026", "100" ], // price, size
    //         ]
    //     }
    //
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var marketId interface{} = this.SafeString(message, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook::", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        //
        // https://github.com/ccxt/ccxt/issues/6672
        //
        // Sometimes Binance sends the first delta before the subscription
        // confirmation arrives. At that point the orderbook is not
        // initialized yet and the snapshot has not been requested yet
        // therefore it is safe to drop these premature messages.
        //
        return
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        // 2. Buffer the events you receive from the stream.
        ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
    } else {
        
            {
                 func(this *BinanceCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *BinanceCore) interface{} {
                                // catch block:
                                            ccxt.Remove(this.Orderbooks, symbol)
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                return nil
                            }(this)
                        }
                    }()
        		    // try block:
                                var U interface{} = this.SafeInteger(message, "U")
                    var u interface{} = this.SafeInteger(message, "u")
                    var pu interface{} = this.SafeInteger(message, "pu")
                    if ccxt.IsTrue(ccxt.IsEqual(pu, nil)) {
                        // spot
                        // 4. Drop any event where u is <= lastUpdateId in the snapshot
                        if ccxt.IsTrue(ccxt.IsGreaterThan(u, ccxt.GetValue(orderbook, "nonce"))) {
                            var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
                            var conditional interface{} = nil
                            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                                // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1
                                conditional = ccxt.IsTrue((ccxt.IsLessThanOrEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))) && ccxt.IsTrue((ccxt.IsGreaterThanOrEqual((ccxt.Subtract(u, 1)), ccxt.GetValue(orderbook, "nonce"))))
                            } else {
                                // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
                                conditional = (ccxt.IsEqual((ccxt.Subtract(U, 1)), ccxt.GetValue(orderbook, "nonce")))
                            }
                            if ccxt.IsTrue(conditional) {
                                this.HandleOrderBookMessage(client, message, orderbook)
                                if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.GetValue(orderbook, "nonce"))) {
                                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
                                }
                            } else {
                                var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
                                if ccxt.IsTrue(checksum) {
                                    panic(ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol))))
                                }
                            }
                        }
                    } else {
                        // future
                        // 4. Drop any event where u is < lastUpdateId in the snapshot
                        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(u, ccxt.GetValue(orderbook, "nonce"))) {
                            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
                            // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3
                            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsLessThanOrEqual(U, ccxt.GetValue(orderbook, "nonce")))) || ccxt.IsTrue((ccxt.IsEqual(pu, ccxt.GetValue(orderbook, "nonce"))))) {
                                this.HandleOrderBookMessage(client, message, orderbook)
                                if ccxt.IsTrue(ccxt.IsLessThanOrEqual(nonce, ccxt.GetValue(orderbook, "nonce"))) {
                                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
                                }
                            } else {
                                var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
                                if ccxt.IsTrue(checksum) {
                                    panic(ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol))))
                                }
                            }
                        }
                    }
        		    return nil
        	    }(this)
            
                }
    }
}
func  (this *BinanceCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
    // const messageHash = this.safeString (subscription, 'messageHash')
    var symbolOfSubscription interface{} = this.SafeString(subscription, "symbol") // watchOrderBook
    var symbols interface{} = this.SafeValue(subscription, "symbols", []interface{}{symbolOfSubscription}) // watchOrderBookForSymbols
    var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
    // handle list of symbols
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
        var symbol interface{} = ccxt.GetValue(symbols, i)
        if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
            ccxt.Remove(this.Orderbooks, symbol)
        }
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        subscription = this.Extend(subscription, map[string]interface{} {
            "symbol": symbol,
        })
        // fetch the snapshot in a separate async call
        this.Spawn(this.FetchOrderBookSnapshot, client, message, subscription)
    }
}
func  (this *BinanceCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "result": null,
    //         "id": 1574649734450
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeValue(subscriptionsById, id, map[string]interface{} {})
    var method interface{} = this.SafeValue(subscription, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message, subscription)
    }
    var isUnSubMessage interface{} = this.SafeBool(subscription, "unsubscribe", false)
    if ccxt.IsTrue(isUnSubMessage) {
        this.HandleUnSubscription(client, subscription)
    }
    return message
}
func  (this *BinanceCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    }
    this.CleanCache(subscription)
}
/**
 * @method
 * @name binance#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BinanceCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes10888 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10888)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var streamHash interface{} = "multipleTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times")))
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var name interface{} = nil
            nameparamsVariable := this.HandleOptionAndParams(params, "watchTradesForSymbols", "name", "trade")
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var messageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade::", symbol))
                var rawHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var query interface{} = this.Omit(params, "type")
            var subParamsLength interface{} =     ccxt.GetArrayLength(subParams)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, subParamsLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, query), messageHashes, subscribe))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTradesForSymbols
 * @description unsubscribes from the trades channel
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BinanceCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11508)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var streamHash interface{} = "multipleTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 200)) {
                    panic(ccxt.BadRequest(ccxt.Add(this.Id, " watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times")))
                }
                streamHash = ccxt.Add(streamHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var name interface{} = nil
            nameparamsVariable := this.HandleOptionAndParams(params, "watchTradesForSymbols", "name", "trade")
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
            params = this.Omit(params, "callerMethodName")
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var subMessageHashes interface{} = []interface{}{}
            var subParams interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add("trade::", symbol))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trade:", symbol))
                var rawHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), name)
                ccxt.AppendToArray(&subParams, rawHash)
            }
            var query interface{} = this.Omit(params, "type")
            var subParamsLength interface{} =     ccxt.GetArrayLength(subParams)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, streamHash, subParamsLength))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subParams,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "symbols": symbols,
                "topic": "trades",
            }
        
                retRes119615 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, query), messageHashes, subscription))
                ccxt.PanicOnError(retRes119615)
                ch <- retRes119615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTrades
 * @description unsubscribes from the trades channel
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BinanceCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12138)
        
                retRes121415 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes121415)
                ch <- retRes121415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#aggregate-trades
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-ccxt.Trade-Streams
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BinanceCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes123415 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes123415)
                ch <- retRes123415
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public watchTrades
    //
    //     {
    //         "e": "trade",       // event type
    //         "E": 1579481530911, // event time
    //         "s": "ETHBTC",      // symbol
    //         "t": 158410082,     // trade id
    //         "p": "0.01914100",  // price
    //         "q": "0.00700000",  // quantity
    //         "b": 586187049,     // buyer order id
    //         "a": 586186710,     // seller order id
    //         "T": 1579481530910, // trade time
    //         "m": false,         // is the buyer the market maker
    //         "M": true           // binance docs say it should be ignored
    //     }
    //
    //     {
    //        "e": "aggTrade",  // Event type
    //        "E": 123456789,   // Event time
    //        "s": "BNBBTC",    // Symbol
    //        "a": 12345,       // Aggregate trade ID
    //        "p": "0.001",     // Price
    //        "q": "100",       // Quantity
    //        "f": 100,         // First trade ID
    //        "l": 105,         // Last trade ID
    //        "T": 123456785,   // ccxt.Trade time
    //        "m": true,        // Is the buyer the market maker?
    //        "M": true         // Ignore
    //     }
    //
    // private watchMyTrades spot
    //
    //     {
    //         "e": "executionReport",
    //         "E": 1611063861489,
    //         "s": "BNBUSDT",
    //         "c": "m4M6AD5MF3b1ERe65l4SPq",
    //         "S": "BUY",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "2.00000000",
    //         "p": "0.00000000",
    //         "P": "0.00000000",
    //         "F": "0.00000000",
    //         "g": -1,
    //         "C": '',
    //         "x": "TRADE",
    //         "X": "PARTIALLY_FILLED",
    //         "r": "NONE",
    //         "i": 1296882607,
    //         "l": "0.33200000",
    //         "z": "0.33200000",
    //         "L": "46.86600000",
    //         "n": "0.00033200",
    //         "N": "BNB",
    //         "T": 1611063861488,
    //         "t": 109747654,
    //         "I": 2696953381,
    //         "w": false,
    //         "m": false,
    //         "M": true,
    //         "O": 1611063861488,
    //         "Z": "15.55951200",
    //         "Y": "15.55951200",
    //         "Q": "0.00000000"
    //     }
    //
    // private watchMyTrades future/delivery
    //
    //     {
    //         "s": "BTCUSDT",
    //         "c": "pb2jD6ZQHpfzSdUac8VqMK",
    //         "S": "SELL",
    //         "o": "MARKET",
    //         "f": "GTC",
    //         "q": "0.001",
    //         "p": "0",
    //         "ap": "33468.46000",
    //         "sp": "0",
    //         "x": "TRADE",
    //         "X": "FILLED",
    //         "i": 13351197194,
    //         "l": "0.001",
    //         "z": "0.001",
    //         "L": "33468.46",
    //         "n": "0.00027086",
    //         "N": "BNB",
    //         "T": 1612095165362,
    //         "t": 458032604,
    //         "b": "0",
    //         "a": "0",
    //         "m": false,
    //         "R": false,
    //         "wt": "CONTRACT_PRICE",
    //         "ot": "MARKET",
    //         "ps": "BOTH",
    //         "cp": false,
    //         "rp": "0.00335000",
    //         "pP": false,
    //         "si": 0,
    //         "ss": 0
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var executionType interface{} = this.SafeString(trade, "x")
    var isTradeExecution interface{} =     (ccxt.IsEqual(executionType, "TRADE"))
    if !ccxt.IsTrue(isTradeExecution) {
        return this.ParseTrade(trade, market)
    }
    var id interface{} = this.SafeString2(trade, "t", "a")
    var timestamp interface{} = this.SafeInteger(trade, "T")
    var price interface{} = this.SafeString2(trade, "L", "p")
    var amount interface{} = this.SafeString(trade, "q")
    if ccxt.IsTrue(isTradeExecution) {
        amount = this.SafeString(trade, "l", amount)
    }
    var cost interface{} = this.SafeString(trade, "Y")
    if ccxt.IsTrue(ccxt.IsEqual(cost, nil)) {
        if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(price, nil))) && ccxt.IsTrue((!ccxt.IsEqual(amount, nil)))) {
            cost = ccxt.Precise.StringMul(price, amount)
        }
    }
    var marketId interface{} = this.SafeString(trade, "s")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(trade, "ps"))), "contract", "spot")
    var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
    var side interface{} = this.SafeStringLower(trade, "S")
    var takerOrMaker interface{} = nil
    var orderId interface{} = this.SafeString(trade, "i")
    if ccxt.IsTrue(ccxt.InOp(trade, "m")) {
        if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
            side = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "sell", "buy") // this is reversed intentionally
        }
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(trade, "m")), "maker", "taker")
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "n")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "N")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var typeVar interface{} = this.SafeStringLower(trade, "o")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    })
}
func  (this *BinanceCore) HandleTrade(client interface{}, message interface{})  {
    // the trade streams push raw trade information in real-time
    // each trade has a unique buyer and seller
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var marketId interface{} = this.SafeString(message, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trade::", symbol)
    var trade interface{} = this.ParseWsTrade(message, market)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    tradesArray.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
}
/**
 * @method
 * @name binance#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14368)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes14598)
            var klineType interface{} = nil
            klineTypeparamsVariable := this.HandleParamString2(params, "channel", "name", "kline")
            klineType = ccxt.GetValue(klineTypeparamsVariable,0)
            params = ccxt.GetValue(klineTypeparamsVariable,1)
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, false, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var timezone interface{} = nil
            timezoneparamsVariable := this.HandleParamString(params, "timezone", nil)
            timezone = ccxt.GetValue(timezoneparamsVariable,0)
            params = ccxt.GetValue(timezoneparamsVariable,1)
            var isUtc8 interface{} = ccxt.IsTrue((!ccxt.IsEqual(timezone, nil))) && ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(timezone, "+08:00"))) || ccxt.IsTrue(ccxt.Precise.StringEq(timezone, "8"))))
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symAndTf interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = ccxt.GetValue(symAndTf, 0)
                var timeframeString interface{} = ccxt.GetValue(symAndTf, 1)
                var interval interface{} = this.SafeString(this.Timeframes, timeframeString, timeframeString)
                var market interface{} = this.Market(symbolString)
                var marketId interface{} = ccxt.GetValue(market, "lowercaseId")
                if ccxt.IsTrue(ccxt.IsEqual(klineType, "indexPriceKline")) {
                    // weird behavior for index price kline we can't use the perp suffix
                    marketId = ccxt.Replace(marketId, "_perp", "")
                }
                var shouldUseUTC8 interface{} =         (ccxt.IsTrue(isUtc8) && ccxt.IsTrue(isSpot))
                var suffix interface{} = "@+08:00"
                var utcSuffix interface{} = ccxt.Ternary(ccxt.IsTrue(shouldUseUTC8), suffix, "")
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(marketId, "@"), klineType), "_"), interval), utcSuffix))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, "multipleOHLCV"))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": rawHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            params = this.Omit(params, "callerMethodName")
        
            res:= (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscribe))
            ccxt.PanicOnError(res)
            symboltimeframecandlesVariable := res
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15258)
            var klineType interface{} = nil
            klineTypeparamsVariable := this.HandleParamString2(params, "channel", "name", "kline")
            klineType = ccxt.GetValue(klineTypeparamsVariable,0)
            params = ccxt.GetValue(klineTypeparamsVariable,1)
            var symbols interface{} = this.GetListFromObjectValues(symbolsAndTimeframes, 0)
            var marketSymbols interface{} = this.MarketSymbols(symbols, nil, false, false, true)
            var firstMarket interface{} = this.Market(ccxt.GetValue(marketSymbols, 0))
            var typeVar interface{} = ccxt.GetValue(firstMarket, "type")
            if ccxt.IsTrue(ccxt.GetValue(firstMarket, "contract")) {
                typeVar = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(firstMarket, "linear")), "future", "delivery")
            }
            var isSpot interface{} =     (ccxt.IsEqual(typeVar, "spot"))
            var timezone interface{} = nil
            timezoneparamsVariable := this.HandleParamString(params, "timezone", nil)
            timezone = ccxt.GetValue(timezoneparamsVariable,0)
            params = ccxt.GetValue(timezoneparamsVariable,1)
            var isUtc8 interface{} = ccxt.IsTrue((!ccxt.IsEqual(timezone, nil))) && ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(timezone, "+08:00"))) || ccxt.IsTrue(ccxt.Precise.StringEq(timezone, "8"))))
            var rawHashes interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symAndTf interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = ccxt.GetValue(symAndTf, 0)
                var timeframeString interface{} = ccxt.GetValue(symAndTf, 1)
                var interval interface{} = this.SafeString(this.Timeframes, timeframeString, timeframeString)
                var market interface{} = this.Market(symbolString)
                var marketId interface{} = ccxt.GetValue(market, "lowercaseId")
                if ccxt.IsTrue(ccxt.IsEqual(klineType, "indexPriceKline")) {
                    // weird behavior for index price kline we can't use the perp suffix
                    marketId = ccxt.Replace(marketId, "_perp", "")
                }
                var shouldUseUTC8 interface{} =         (ccxt.IsTrue(isUtc8) && ccxt.IsTrue(isSpot))
                var suffix interface{} = "@+08:00"
                var utcSuffix interface{} = ccxt.Ternary(ccxt.IsTrue(shouldUseUTC8), suffix, "")
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(marketId, "@"), klineType), "_"), interval), utcSuffix))
                ccxt.AppendToArray(&subMessageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe::ohlcv::", ccxt.GetValue(market, "symbol")), "::"), timeframeString))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "/"), this.Stream(typeVar, "multipleOHLCV"))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": rawHashes,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "symbols": symbols,
                "symbolsAndTimeframes": symbolsAndTimeframes,
                "subMessageHashes": subMessageHashes,
                "messageHashes": messageHashes,
                "topic": "ohlcv",
            }
            params = this.Omit(params, "callerMethodName")
        
                retRes157715 :=  (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes, subscribe))
                ccxt.PanicOnError(retRes157715)
                ch <- retRes157715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15948)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
                retRes159815 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes159815)
                ch <- retRes159815
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "e": "kline",
    //         "E": 1579482921215,
    //         "s": "ETHBTC",
    //         "k": {
    //             "t": 1579482900000,
    //             "T": 1579482959999,
    //             "s": "ETHBTC",
    //             "i": "1m",
    //             "f": 158411535,
    //             "L": 158411550,
    //             "o": "0.01913200",
    //             "c": "0.01913500",
    //             "h": "0.01913700",
    //             "l": "0.01913200",
    //             "v": "5.08400000",
    //             "n": 16,
    //             "x": false,
    //             "q": "0.09728060",
    //             "V": "3.30200000",
    //             "Q": "0.06318500",
    //             "B": "0"
    //         }
    //     }
    //
    var event interface{} = this.SafeString(message, "e")
    var eventMap interface{} = map[string]interface{} {
        "indexPrice_kline": "indexPriceKline",
        "markPrice_kline": "markPriceKline",
    }
    event = this.SafeString(eventMap, event, event)
    var kline interface{} = this.SafeValue(message, "k")
    var marketId interface{} = this.SafeString2(kline, "s", "ps")
    if ccxt.IsTrue(ccxt.IsEqual(event, "indexPriceKline")) {
        // indexPriceKline doesn't have the _PERP suffix
        marketId = this.SafeString(message, "ps")
    }
    var interval interface{} = this.SafeString(kline, "i")
    // use a reverse lookup in a static map instead
    var unifiedTimeframe interface{} = this.FindTimeframe(interval)
    var parsed interface{} = []interface{}{this.SafeInteger(kline, "t"), this.SafeFloat(kline, "o"), this.SafeFloat(kline, "h"), this.SafeFloat(kline, "l"), this.SafeFloat(kline, "c"), this.SafeFloat(kline, "v")}
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), unifiedTimeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    var resolveData interface{} = []interface{}{symbol, unifiedTimeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
/**
 * @method
 * @name binance#fetchTickerWs
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] method to use can be ticker.price or ticker.book
 * @param {boolean} [params.returnRateLimits] return the rate limits for the exchange
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) FetchTickerWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes16788)
            var market interface{} = this.Market(symbol)
            var payload interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            var typeVar interface{} = this.GetMarketType("fetchTickerWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchTickerWs only supports swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTickerWs,
            }
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchTickerWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            params = this.Omit(params, "test")
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "fetchTickerWs", "method", "ticker.book")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(this.Extend(payload, params)),
            }
        
            ticker:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(ticker)
        
            ch <- ticker
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOHLCVWs
 * @description query historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#klines
 * @param {string} symbol unified symbol of the market to query ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} since timestamp in ms of the earliest candle to fetch
 * @param {int} limit the maximum amount of candles to fetch
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {int} params.until timestamp in ms of the earliest candle to fetch
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} params.timeZone default=0 (UTC)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BinanceCore) FetchOHLCVWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes17258)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = this.GetMarketType("fetchOHLCVWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOHLCVWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCVWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
                "interval": ccxt.GetValue(this.Timeframes, timeframe),
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            if ccxt.IsTrue(!ccxt.IsEqual(since, nil)) {
                ccxt.AddElementToObject(payload, "startTime", since)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(until, nil)) {
                ccxt.AddElementToObject(payload, "endTime", until)
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "klines",
                "params": this.Extend(payload, params),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleFetchOHLCV,
            }
        
                retRes176015 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes176015)
                ch <- retRes176015
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleFetchOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
    //        "status": 200,
    //        "result": [
    //            [
    //                1655971200000,      // Kline open time
    //                "0.01086000",       // Open price
    //                "0.01086600",       // High price
    //                "0.01083600",       // Low price
    //                "0.01083800",       // Close price
    //                "2290.53800000",    // Volume
    //                1655974799999,      // Kline close time
    //                "24.85074442",      // Quote asset volume
    //                2283,               // Number of trades
    //                "1171.64000000",    // Taker buy base asset volume
    //                "12.71225884",      // Taker buy quote asset volume
    //                "0"                 // Unused field, ignore
    //            ]
    //        ],
    //        "rateLimits": [
    //            {
    //                "rateLimitType": "REQUEST_WEIGHT",
    //                "interval": "MINUTE",
    //                "intervalNum": 1,
    //                "limit": 6000,
    //                "count": 2
    //            }
    //        ]
    //    }
    //
    var result interface{} = this.SafeList(message, "result")
    var parsed interface{} = this.ParseOHLCVs(result)
    // use a reverse lookup in a static map instead
    var messageHash interface{} = this.SafeString(message, "id")
    client.(ccxt.ClientInterface).Resolve(parsed, messageHash)
}
/**
 * @method
 * @name binance#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] stream to use can be ticker or miniTicker
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes18188)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, this.Extend(params, map[string]interface{} {
            "callerMethodName": "watchTicker",
        })))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMarkPrice
 * @description watches a mark price for a specific market
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes18358)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchMarkPrices([]interface{}{symbol}, this.Extend(params, map[string]interface{} {
            "callerMethodName": "watchMarkPrice",
        })))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchMarkPrices
 * @description watches the mark price for all markets
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream-for-All-market
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            // for now watchmarkPrice uses the same messageHash as watchTicker
            // so it's impossible to watch both at the same time
            // refactor this to use different messageHashes
            channelNameparamsVariable := this.HandleOptionAndParams(params, "watchMarkPrices", "name", "markPrice")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
        
            newTickers:= (<-this.WatchMultiTickerHelper("watchMarkPrices", channelName, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            channelNameparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "name", "ticker")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(channelName, "bookTicker")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead")))
            }
        
            newTickers:= (<-this.WatchMultiTickerHelper("watchTickers", channelName, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTickers
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channelName interface{} = nil
            channelNameparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "name", "ticker")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(channelName, "bookTicker")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead")))
            }
        
            retRes19118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes19118)
            var methodName interface{} = "watchTickers"
            symbols = this.MarketSymbols(symbols, nil, true, false, true)
            var firstMarket interface{} = nil
            var marketType interface{} = nil
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                firstMarket = this.Market(ccxt.GetValue(symbols, 0))
            }
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, firstMarket, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams(methodName, firstMarket, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var rawMarketType interface{} = nil
            if ccxt.IsTrue(this.IsLinear(marketType, subType)) {
                rawMarketType = "future"
            } else if ccxt.IsTrue(this.IsInverse(marketType, subType)) {
                rawMarketType = "delivery"
            } else if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                rawMarketType = marketType
            } else {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() does not support options markets")))
            }
            var isBidAsk interface{} =     (ccxt.IsEqual(channelName, "bookTicker"))
            var subscriptionArgs interface{} = []interface{}{}
            var subMessageHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), channelName))
                    ccxt.AppendToArray(&subMessageHashes, this.GetMessageHash(channelName, ccxt.GetValue(market, "symbol"), isBidAsk))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", symbol))
                }
            } else {
                if ccxt.IsTrue(isBidAsk) {
                    if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                        panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires symbols for this channel for spot markets")))
                    }
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add("!", channelName))
                } else {
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add("!", channelName), "@arr"))
                }
                ccxt.AppendToArray(&subMessageHashes, this.GetMessageHash(channelName, nil, isBidAsk))
                ccxt.AppendToArray(&messageHashes, "unsubscribe:ticker")
            }
            var streamHash interface{} = channelName
            if ccxt.IsTrue(symbolsDefined) {
                streamHash = ccxt.Add(ccxt.Add(channelName, "::"), ccxt.Join(symbols, ","))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), rawMarketType), "/"), this.Stream(rawMarketType, streamHash))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "UNSUBSCRIBE",
                "params": subscriptionArgs,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": ccxt.ToString(requestId),
                "subMessageHashes": subMessageHashes,
                "messageHashes": subMessageHashes,
                "symbols": symbols,
                "topic": "ticker",
            }
        
                retRes197615 :=  (<-this.WatchMultiple(url, subMessageHashes, this.Extend(request, params), subMessageHashes, subscription))
                ccxt.PanicOnError(retRes197615)
                ch <- retRes197615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream
 * @see https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-ccxt.Market-Mini-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-ccxt.Ticker-Streams
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes199415 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes199415)
                ch <- retRes199415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#symbol-order-book-ticker
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Book-ccxt.Tickers-Stream
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Book-ccxt.Tickers-Stream
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BinanceCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes20098)
            symbols = this.MarketSymbols(symbols, nil, true, false, true)
        
            result:= (<-this.WatchMultiTickerHelper("watchBidsAsks", "bookTicker", symbols, params))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) WatchMultiTickerHelper(methodName interface{}, channelName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20198 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes20198)
            symbols = this.MarketSymbols(symbols, nil, true, false, true)
            var isBidAsk interface{} =     (ccxt.IsEqual(channelName, "bookTicker"))
            var isMarkPrice interface{} =     (ccxt.IsEqual(channelName, "markPrice"))
            var use1sFreq interface{} = this.SafeBool(params, "use1sFreq", true)
            var firstMarket interface{} = nil
            var marketType interface{} = nil
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                firstMarket = this.Market(ccxt.GetValue(symbols, 0))
            }
            var defaultMarket interface{} = ccxt.Ternary(ccxt.IsTrue((isMarkPrice)), "swap", nil)
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, firstMarket, params, defaultMarket)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams(methodName, firstMarket, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var rawMarketType interface{} = nil
            if ccxt.IsTrue(this.IsLinear(marketType, subType)) {
                rawMarketType = "future"
            } else if ccxt.IsTrue(this.IsInverse(marketType, subType)) {
                rawMarketType = "delivery"
            } else if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                rawMarketType = marketType
            } else {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() does not support options markets")))
            }
            var subscriptionArgs interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var suffix interface{} = ""
            if ccxt.IsTrue(isMarkPrice) {
                suffix = ccxt.Ternary(ccxt.IsTrue((use1sFreq)), "@1s", "")
            }
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "lowercaseId"), "@"), channelName), suffix))
                    ccxt.AppendToArray(&messageHashes, this.GetMessageHash(channelName, ccxt.GetValue(market, "symbol"), isBidAsk))
                }
            } else {
                if ccxt.IsTrue(isBidAsk) {
                    if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                        panic(ccxt.ArgumentsRequired(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() requires symbols for this channel for spot markets")))
                    }
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add("!", channelName))
                } else if ccxt.IsTrue(isMarkPrice) {
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add(ccxt.Add("!", channelName), "@arr"), suffix))
                } else {
                    ccxt.AppendToArray(&subscriptionArgs, ccxt.Add(ccxt.Add("!", channelName), "@arr"))
                }
                ccxt.AppendToArray(&messageHashes, this.GetMessageHash(channelName, nil, isBidAsk))
            }
            var streamHash interface{} = channelName
            if ccxt.IsTrue(symbolsDefined) {
                streamHash = ccxt.Add(ccxt.Add(channelName, "::"), ccxt.Join(symbols, ","))
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), rawMarketType), "/"), this.Stream(rawMarketType, streamHash))
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "method": "SUBSCRIBE",
                "params": subscriptionArgs,
                "id": requestId,
            }
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
        
            result:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), subscriptionArgs, subscribe))
            ccxt.PanicOnError(result)
            // for efficiency, we have two type of returned structure here - if symbols array was provided, then individual
            // ticker dict comes in, otherwise all-tickers dict comes in
            if !ccxt.IsTrue(symbolsDefined) {
        
                ch <- result
                return nil
            } else {
                var newDict interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(newDict, ccxt.GetValue(result, "symbol"), result)
        
                ch <- newDict
                return nil
            }
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsTicker(message interface{}, marketType interface{}) interface{}  {
    // markPrice
    //   {
    //       "e": "markPriceUpdate",   // Event type
    //       "E": 1562305380000,       // Event time
    //       "s": "BTCUSDT",           // Symbol
    //       "p": "11794.15000000",    // Mark price
    //       "i": "11784.62659091",    // Index price
    //       "P": "11784.25641265",    // Estimated Settle Price, only useful in the last hour before the settlement starts
    //       "r": "0.00038167",        // Funding rate
    //       "T": 1562306400000        // Next funding time
    //   }
    //
    // ticker
    //     {
    //         "e": "24hrTicker",      // event type
    //         "E": 1579485598569,     // event time
    //         "s": "ETHBTC",          // symbol
    //         "p": "-0.00004000",     // price change
    //         "P": "-0.209",          // price change percent
    //         "w": "0.01920495",      // weighted average price
    //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
    //         "c": "0.01912500",      // last (closing) price
    //         "Q": "0.10400000",      // last quantity
    //         "b": "0.01912200",      // best bid
    //         "B": "4.10400000",      // best bid quantity
    //         "a": "0.01912500",      // best ask
    //         "A": "0.00100000",      // best ask quantity
    //         "o": "0.01916500",      // open price
    //         "h": "0.01956500",      // high price
    //         "l": "0.01887700",      // low price
    //         "v": "173518.11900000", // base volume
    //         "q": "3332.40703994",   // quote volume
    //         "O": 1579399197842,     // open time
    //         "C": 1579485597842,     // close time
    //         "F": 158251292,         // first trade id
    //         "L": 158414513,         // last trade id
    //         "n": 163222,            // total number of trades
    //     }
    //
    // miniTicker
    //     {
    //         "e": "24hrMiniTicker",
    //         "E": 1671617114585,
    //         "s": "MOBBUSD",
    //         "c": "0.95900000",
    //         "o": "0.91200000",
    //         "h": "1.04000000",
    //         "l": "0.89400000",
    //         "v": "2109995.32000000",
    //         "q": "2019254.05788000"
    //     }
    // fetchTickerWs
    //     {
    //         "symbol":"BTCUSDT",
    //         "price":"72606.70",
    //         "time":1712526204284
    //     }
    // fetchTickerWs - ticker.book
    //     {
    //         "lastUpdateId":1027024,
    //         "symbol":"BTCUSDT",
    //         "bidPrice":"4.00000000",
    //         "bidQty":"431.00000000",
    //         "askPrice":"4.00000200",
    //         "askQty":"9.00000000",
    //         "time":1589437530011,
    //      }
    //
    var marketId interface{} = this.SafeString2(message, "s", "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
    var event interface{} = this.SafeString(message, "e", "bookTicker")
    if ccxt.IsTrue(ccxt.IsEqual(event, "24hrTicker")) {
        event = "ticker"
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "markPriceUpdate")) {
        // handle this separately because some fields clash with the ticker fields
        return this.SafeTicker(map[string]interface{} {
            "symbol": symbol,
            "timestamp": this.SafeInteger(message, "E"),
            "datetime": this.Iso8601(this.SafeInteger(message, "E")),
            "info": message,
            "markPrice": this.SafeString(message, "p"),
            "indexPrice": this.SafeString(message, "i"),
        })
    }
    var timestamp interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(event, "bookTicker")) {
        // take the event timestamp, if available, for spot tickers it is not
        timestamp = this.SafeInteger2(message, "E", "time")
    } else {
        // take the timestamp of the closing price for candlestick streams
        timestamp = this.SafeIntegerN(message, []interface{}{"C", "E", "time"})
    }
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var last interface{} = this.SafeString2(message, "c", "price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(message, "h"),
        "low": this.SafeString(message, "l"),
        "bid": this.SafeString2(message, "b", "bidPrice"),
        "bidVolume": this.SafeString2(message, "B", "bidQty"),
        "ask": this.SafeString2(message, "a", "askPrice"),
        "askVolume": this.SafeString2(message, "A", "askQty"),
        "vwap": this.SafeString(message, "w"),
        "open": this.SafeString(message, "o"),
        "close": last,
        "last": last,
        "previousClose": this.SafeString(message, "x"),
        "change": this.SafeString(message, "p"),
        "percentage": this.SafeString(message, "P"),
        "average": nil,
        "baseVolume": this.SafeString(message, "v"),
        "quoteVolume": this.SafeString(message, "q"),
        "info": message,
    }, market)
}
func  (this *BinanceCore) HandleTickerWs(client interface{}, message interface{})  {
    //
    // ticker.price
    //    {
    //        "id":"1",
    //        "status":200,
    //        "result":{
    //            "symbol":"BTCUSDT",
    //            "price":"73178.50",
    //            "time":1712527052374
    //        }
    //    }
    // ticker.book
    //    {
    //        "id":"9d32157c-a556-4d27-9866-66760a174b57",
    //        "status":200,
    //        "result":{
    //            "lastUpdateId":1027024,
    //            "symbol":"BTCUSDT",
    //            "bidPrice":"4.00000000",
    //            "bidQty":"431.00000000",
    //            "askPrice":"4.00000200",
    //            "askQty":"9.00000000",
    //            "time":1589437530011   // ccxt.Transaction time
    //        }
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeValue(message, "result", map[string]interface{} {})
    var ticker interface{} = this.ParseWsTicker(result, "future")
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *BinanceCore) HandleBidsAsks(client interface{}, message interface{})  {
    //
    // arrives one symbol dict or array of symbol dicts
    //
    //     {
    //         "u": 7488717758,
    //         "s": "BTCUSDT",
    //         "b": "28621.74000000",
    //         "B": "1.43278800",
    //         "a": "28621.75000000",
    //         "A": "2.52500800"
    //     }
    //
    this.HandleTickersAndBidsAsks(client, message, "bidasks")
}
func  (this *BinanceCore) HandleTickers(client interface{}, message interface{})  {
    //
    // arrives one symbol dict or array of symbol dicts
    //
    //     {
    //         "e": "24hrTicker",      // event type
    //         "E": 1579485598569,     // event time
    //         "s": "ETHBTC",          // symbol
    //         "p": "-0.00004000",     // price change
    //         "P": "-0.209",          // price change percent
    //         "w": "0.01920495",      // weighted average price
    //         "x": "0.01916500",      // the price of the first trade before the 24hr rolling window
    //         "c": "0.01912500",      // last (closing) price
    //         "Q": "0.10400000",      // last quantity
    //         "b": "0.01912200",      // best bid
    //         "B": "4.10400000",      // best bid quantity
    //         "a": "0.01912500",      // best ask
    //         "A": "0.00100000",      // best ask quantity
    //         "o": "0.01916500",      // open price
    //         "h": "0.01956500",      // high price
    //         "l": "0.01887700",      // low price
    //         "v": "173518.11900000", // base volume
    //         "q": "3332.40703994",   // quote volume
    //         "O": 1579399197842,     // open time
    //         "C": 1579485597842,     // close time
    //         "F": 158251292,         // first trade id
    //         "L": 158414513,         // last trade id
    //         "n": 163222,            // total number of trades
    //     }
    //
    this.HandleTickersAndBidsAsks(client, message, "tickers")
}
func  (this *BinanceCore) HandleTickersAndBidsAsks(client interface{}, message interface{}, methodType interface{})  {
    var isSpot interface{} = this.IsSpotUrl(client)
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((isSpot)), "spot", "contract")
    var isBidAsk interface{} =     (ccxt.IsEqual(methodType, "bidasks"))
    var channelName interface{} = nil
    var resolvedMessageHashes interface{} = []interface{}{}
    var rawTickers interface{} = []interface{}{}
    var newTickers interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        rawTickers = message
    } else {
        ccxt.AppendToArray(&rawTickers, message)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTickers)); i++ {
        var ticker interface{} = ccxt.GetValue(rawTickers, i)
        var event interface{} = this.SafeString(ticker, "e")
        if ccxt.IsTrue(isBidAsk) {
            event = "bookTicker" // as noted in `handleMessage`, bookTicker doesn't have identifier, so manually set here
        }
        channelName = this.SafeString(ccxt.GetValue(this.Options, "tickerChannelsMap"), event, event)
        if ccxt.IsTrue(ccxt.IsEqual(channelName, nil)) {
            continue
        }
        var parsedTicker interface{} = this.ParseWsTicker(ticker, marketType)
        var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
        ccxt.AddElementToObject(newTickers, symbol, parsedTicker)
        if ccxt.IsTrue(isBidAsk) {
            ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
        } else {
            ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
        }
        var messageHash interface{} = this.GetMessageHash(channelName, symbol, isBidAsk)
        ccxt.AppendToArray(&resolvedMessageHashes, messageHash)
        client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
    }
    // resolve batch endpoint
    var length interface{} =     ccxt.GetArrayLength(resolvedMessageHashes)
    if ccxt.IsTrue(ccxt.IsGreaterThan(length, 0)) {
        var batchMessageHash interface{} = this.GetMessageHash(channelName, nil, isBidAsk)
        client.(ccxt.ClientInterface).Resolve(newTickers, batchMessageHash)
    }
}
func  (this *BinanceCore) GetMessageHash(channelName interface{}, symbol interface{}, isBidAsk interface{}) interface{}  {
    var prefix interface{} = ccxt.Ternary(ccxt.IsTrue(isBidAsk), "bidask", "ticker")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        return ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(prefix, ":"), channelName), "@"), symbol)
    } else {
        return ccxt.Add(ccxt.Add(ccxt.Add(prefix, "s"), ":"), channelName)
    }
}
func  (this *BinanceCore) SignParams(optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    this.CheckRequiredCredentials()
    var extendedParams interface{} = this.Extend(map[string]interface{} {
        "timestamp": this.Nonce(),
        "apiKey": this.ApiKey,
    }, params)
    var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
    if ccxt.IsTrue(!ccxt.IsEqual(defaultRecvWindow, nil)) {
        ccxt.AddElementToObject(params, "recvWindow", defaultRecvWindow)
    }
    var recvWindow interface{} = this.SafeInteger(params, "recvWindow")
    if ccxt.IsTrue(!ccxt.IsEqual(recvWindow, nil)) {
        ccxt.AddElementToObject(params, "recvWindow", recvWindow)
    }
    extendedParams = this.Keysort(extendedParams)
    var query interface{} = this.Urlencode(extendedParams)
    var signature interface{} = nil
    if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetIndexOf(this.Secret, "PRIVATE KEY"), ccxt.OpNeg(1))) {
        if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.GetLength(this.Secret), 120)) {
            signature = ccxt.Rsa(query, this.Secret, ccxt.Sha256)
        } else {
            signature = ccxt.Eddsa(this.Encode(query), this.Secret, ccxt.Ed25519)
        }
    } else {
        signature = this.Hmac(this.Encode(query), this.Encode(this.Secret), ccxt.Sha256)
    }
    ccxt.AddElementToObject(extendedParams, "signature", signature)
    return extendedParams
}
/**
 * Ensures a User Data Stream WebSocket subscription is active for the specified scope
 * @param marketType {string} only support on 'spot'
 * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/user-data-stream-requests#subscribe-to-user-data-stream-through-signature-subscription-user_data Binance User Data Stream Documentation}
 * @returns Promise<number> The subscription ID for the user data stream
 */
func  (this *BinanceCore) EnsureUserDataStreamWsSubscribeSignature(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    marketType := ccxt.GetArg(optionalArgs, 0, "spot")
            _ = marketType
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var client interface{} = this.Client(url)
            var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
            var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
            var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
            if ccxt.IsTrue(ccxt.IsEqual(accountType, marketType)) {
        
                return nil
            }
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), marketType, true)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "userDataStream.subscribe.signature",
                "params": this.SignParams(map[string]interface{} {}),
            }
            var subscription interface{} = map[string]interface{} {
                "id": messageHash,
                "method": this.HandleUserDataStreamSubscribe,
                "subscription": marketType,
            }
        
            retRes24088 := (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(retRes24088)
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandleUserDataStreamSubscribe(client interface{}, message interface{})  {
    //
    //   {
    //     "id": 1,
    //     "status": 200,
    //     "result": {
    //         "subscriptionId": 0
    //     }
    //   }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var subscriptionId interface{} = this.SafeInteger(result, "subscriptionId")
    if ccxt.IsTrue(ccxt.IsEqual(subscriptionId, nil)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), accountType)
        client.(ccxt.ClientInterface).Reject(message, accountType)
    }
    client.(ccxt.ClientInterface).Resolve(message, messageHash)
}
func  (this *BinanceCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var time interface{} = this.Milliseconds()
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("authenticate", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("authenticate", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "authenticate", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            // For spot use WebSocket API signature subscription
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        
                retRes244912 := (<-this.EnsureUserDataStreamWsSubscribeSignature("spot"))
                ccxt.PanicOnError(retRes244912)
        
                return nil
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("authenticate", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var isIsolatedMargin interface{} =     (ccxt.IsEqual(marginMode, "isolated"))
            var isCrossMargin interface{} = ccxt.IsTrue((ccxt.IsEqual(marginMode, "cross"))) || ccxt.IsTrue((ccxt.IsEqual(marginMode, nil)))
            var symbol interface{} = this.SafeString(params, "symbol")
            params = this.Omit(params, "symbol")
            var options interface{} = this.SafeValue(this.Options, typeVar, map[string]interface{} {})
            var lastAuthenticatedTime interface{} = this.SafeInteger(options, "lastAuthenticatedTime", 0)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1200000)
            var delay interface{} = this.Sum(listenKeyRefreshRate, 10000)
            if ccxt.IsTrue(ccxt.IsGreaterThan(ccxt.Subtract(time, lastAuthenticatedTime), delay)) {
                var response interface{} = nil
                if ccxt.IsTrue(isPortfolioMargin) {
                    
            response = (<-this.PapiPostListenKey(params))
                        ccxt.PanicOnError(response)
                    params = this.Extend(params, map[string]interface{} {
                        "portfolioMargin": true,
                    })
                } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
                    
            response = (<-this.FapiPrivatePostListenKey(params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "delivery")) {
                    
            response = (<-this.DapiPrivatePostListenKey(params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) && ccxt.IsTrue(isCrossMargin)) {
                    
            response = (<-this.SapiPostUserDataStream(params))
                        ccxt.PanicOnError(response)
                } else if ccxt.IsTrue(isIsolatedMargin) {
                    if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                        panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " authenticate() requires a symbol argument for isolated margin mode")))
                    }
                    var marketId interface{} = this.MarketId(symbol)
                    params = this.Extend(params, map[string]interface{} {
                        "symbol": marketId,
                    })
                    
            response = (<-this.SapiPostUserDataStreamIsolated(params))
                        ccxt.PanicOnError(response)
                } else {
                    
            response = (<-this.PublicPostUserDataStream(params))
                        ccxt.PanicOnError(response)
                }
                ccxt.AddElementToObject(this.Options, typeVar, this.Extend(options, map[string]interface{} {
            "listenKey": this.SafeString(response, "listenKey"),
            "lastAuthenticatedTime": time,
        }))
                this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
            }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) KeepAliveListenKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
            params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = this.SafeString2(this.Options, "defaultType", "authenticate", "spot")
            typeVar = this.SafeString(params, "type", typeVar)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "keepAliveListenKey", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var subTypeInfo interface{} = this.HandleSubTypeAndParams("keepAliveListenKey", nil, params)
            var subType interface{} = ccxt.GetValue(subTypeInfo, 0)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            var options interface{} = this.SafeValue(this.Options, typeVar, map[string]interface{} {})
            var listenKey interface{} = this.SafeString(options, "listenKey")
            if ccxt.IsTrue(ccxt.IsEqual(listenKey, nil)) {
        
                return nil
            }
            var request interface{} = map[string]interface{} {}
            var symbol interface{} = this.SafeString(params, "symbol")
            params = this.Omit(params, []interface{}{"type", "symbol"})
            var time interface{} = this.Milliseconds()
            
                {
                     func(this *BinanceCore) (ret_ interface{}) {
            		    defer func() {
                            if error := recover(); error != nil {
                                if error == "break" {
                                    return
                                }
                                ret_ = func(this *BinanceCore) interface{} {
                                    // catch block:
                                            var urlType interface{} = typeVar
                    if ccxt.IsTrue(isPortfolioMargin) {
                        urlType = "papi"
                    }
                    var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
                    var client interface{} = this.Client(url)
                    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
                        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
                        client.(ccxt.ClientInterface).Reject(error, messageHash)
                    }
                    ccxt.AddElementToObject(this.Options, typeVar, this.Extend(options, map[string]interface{} {
                "listenKey": nil,
                "lastAuthenticatedTime": 0,
            }))
            
                    return nil
                                    
                                }(this)
                            }
                        }()
            		    // try block:
                                if ccxt.IsTrue(isPortfolioMargin) {
            
                        retRes251616 := (<-this.PapiPutListenKey(this.Extend(request, params)))
                        ccxt.PanicOnError(retRes251616)
                        params = this.Extend(params, map[string]interface{} {
                            "portfolioMargin": true,
                        })
                    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "future")) {
            
                        retRes251916 := (<-this.FapiPrivatePutListenKey(this.Extend(request, params)))
                        ccxt.PanicOnError(retRes251916)
                    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "delivery")) {
            
                        retRes252116 := (<-this.DapiPrivatePutListenKey(this.Extend(request, params)))
                        ccxt.PanicOnError(retRes252116)
                    } else {
                        ccxt.AddElementToObject(request, "listenKey", listenKey)
                        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) {
                            ccxt.AddElementToObject(request, "symbol", symbol)
            
                            retRes252620 := (<-this.SapiPutUserDataStream(this.Extend(request, params)))
                            ccxt.PanicOnError(retRes252620)
                        } else {
            
                            retRes252820 := (<-this.PublicPutUserDataStream(this.Extend(request, params)))
                            ccxt.PanicOnError(retRes252820)
                        }
                    }
            		    return nil
            	    }(this)
                
                    }
            ccxt.AddElementToObject(this.Options, typeVar, this.Extend(options, map[string]interface{} {
            "listenKey": listenKey,
            "lastAuthenticatedTime": time,
        }))
            // whether or not to schedule another listenKey keepAlive request
            var clients interface{} = ccxt.ObjectValues(this.Clients)
            var listenKeyRefreshRate interface{} = this.SafeInteger(this.Options, "listenKeyRefreshRate", 1200000)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(clients)); i++ {
                var client interface{} = ccxt.GetValue(clients, i)
                var subscriptionKeys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(subscriptionKeys)); j++ {
                    var subscribeType interface{} = ccxt.GetValue(subscriptionKeys, j)
                    if ccxt.IsTrue(ccxt.IsEqual(subscribeType, typeVar)) {
                        this.Delay(listenKeyRefreshRate, this.KeepAliveListenKey, params)
        
                        return nil
                    }
                }
            }
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) SetBalanceCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    isPortfolioMargin := ccxt.GetArg(optionalArgs, 0, false)
    _ = isPortfolioMargin
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), typeVar))) && ccxt.IsTrue((ccxt.InOp(this.Balance, typeVar)))) {
        return
    }
    var options interface{} = this.SafeValue(this.Options, "watchBalance")
    var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
    if ccxt.IsTrue(fetchBalanceSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash, typeVar, isPortfolioMargin)
        }
    } else {
        ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
    }
}
func  (this *BinanceCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}, isPortfolioMargin interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
            if ccxt.IsTrue(isPortfolioMargin) {
                ccxt.AddElementToObject(params, "portfolioMargin", true)
            }
        
            response:= (<-this.FetchBalance(params))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeValue(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve()
            client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add(typeVar, ":balance"))
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchBalanceWs
 * @description fetch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/websocket-api/Futures-ccxt.Account-ccxt.Balance
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-information-user_data
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/websocket-api
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot'
 * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
 * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
 * @param {string|undefined} [params.method] method to use. Can be account.balance, account.status, v2/account.balance or v2/account.status
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BinanceCore) FetchBalanceWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes26168)
            var typeVar interface{} = this.GetMarketType("fetchBalanceWs", nil, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchBalanceWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchBalanceWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "returnRateLimits": returnRateLimits,
            }
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "fetchBalanceWs", "method", "account.status")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(method, "account.status"))), this.HandleAccountStatusWs, this.HandleBalanceWs),
            }
        
                retRes263915 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes263915)
                ch <- retRes263915
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleBalanceWs(client interface{}, message interface{})  {
    //
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var rawBalance interface{} = nil
    if ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(message, "result"))) {
        // account.balance
        rawBalance = this.SafeList(message, "result", []interface{}{})
    } else {
        // account.status
        var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
        rawBalance = this.SafeList(result, "assets", []interface{}{})
    }
    var parsedBalances interface{} = this.ParseBalanceCustom(rawBalance)
    client.(ccxt.ClientInterface).Resolve(parsedBalances, messageHash)
}
func  (this *BinanceCore) HandleAccountStatusWs(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
    //        "status": 200,
    //        "result": {
    //            "makerCommission": 15,
    //            "takerCommission": 15,
    //            "buyerCommission": 0,
    //            "sellerCommission": 0,
    //            "canTrade": true,
    //            "canWithdraw": true,
    //            "canDeposit": true,
    //            "commissionRates": {
    //                "maker": "0.00150000",
    //                "taker": "0.00150000",
    //                "buyer": "0.00000000",
    //                "seller": "0.00000000"
    //            },
    //            "brokered": false,
    //            "requireSelfTradePrevention": false,
    //            "updateTime": 1660801833000,
    //            "accountType": "SPOT",
    //            "balances": [{
    //                    "asset": "BNB",
    //                    "free": "0.00000000",
    //                    "locked": "0.00000000"
    //                },
    //                {
    //                    "asset": "BTC",
    //                    "free": "1.3447112",
    //                    "locked": "0.08600000"
    //                },
    //                {
    //                    "asset": "USDT",
    //                    "free": "1021.21000000",
    //                    "locked": "0.00000000"
    //                }
    //            ],
    //            "permissions": [
    //                "SPOT"
    //            ]
    //        }
    //    }
    // swap
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var parsedBalances interface{} = this.ParseBalanceCustom(result)
    client.(ccxt.ClientInterface).Resolve(parsedBalances, messageHash)
}
/**
 * @method
 * @name binance#fetchPositionWs
 * @description fetch data on an open position
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *BinanceCore) FetchPositionWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes272215 :=  (<-this.FetchPositionsWs([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes272215)
                ch <- retRes272215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchPositionsWs
 * @description fetch all open positions
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Position-Information
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.returnRateLimits] set to true to return rate limit informations, defaults to false.
 * @param {string|undefined} [params.method] method to use. Can be account.position or v2/account.position
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *BinanceCore) FetchPositionsWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes27388)
            var payload interface{} = map[string]interface{} {}
            var market interface{} = nil
            symbols = this.MarketSymbols(symbols, "swap", true, true, true)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         ccxt.GetArrayLength(symbols)
                if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 1)) {
                    market = this.Market(ccxt.GetValue(symbols, 0))
                    ccxt.AddElementToObject(payload, "symbol", ccxt.GetValue(market, "id"))
                }
            }
            var typeVar interface{} = this.GetMarketType("fetchPositionsWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchPositionsWs only supports swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchPositionsWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "fetchPositionsWs", "method", "account.position")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": method,
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandlePositionsWs,
            }
        
            result:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(result)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandlePositionsWs(client interface{}, message interface{})  {
    //
    //    {
    //        id: '1',
    //        status: 200,
    //        result: [
    //            {
    //                symbol: 'BTCUSDT',
    //                positionAmt: '-0.014',
    //                entryPrice: '42901.1',
    //                breakEvenPrice: '30138.83333142',
    //                markPrice: '71055.98470333',
    //                unRealizedProfit: '-394.16838584',
    //                liquidationPrice: '137032.02272908',
    //                leverage: '123',
    //                maxNotionalValue: '50000',
    //                marginType: 'cross',
    //                isolatedMargin: '0.00000000',
    //                isAutoAddMargin: 'false',
    //                positionSide: 'BOTH',
    //                notional: '-994.78378584',
    //                isolatedWallet: '0',
    //                updateTime: 1708906343111,
    //                isolated: false,
    //                adlQuantile: 2
    //            },
    //            ...
    //        ]
    //    }
    //
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var positions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(result)); i++ {
        var parsed interface{} = this.ParsePositionRisk(ccxt.GetValue(result, i))
        var entryPrice interface{} = this.SafeString(parsed, "entryPrice")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0"))) && ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0.0")))) && ccxt.IsTrue((!ccxt.IsEqual(entryPrice, "0.00000000")))) {
            ccxt.AppendToArray(&positions, parsed)
        }
    }
    client.(ccxt.ClientInterface).Resolve(positions, messageHash)
}
/**
 * @method
 * @name binance#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch the balance of a portfolio margin account
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BinanceCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes28268)
        
            retRes28278 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes28278)
            var defaultType interface{} = this.SafeString(this.Options, "defaultType", "spot")
            var typeVar interface{} = this.SafeString(params, "type", defaultType)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchBalance", nil, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "watchBalance", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            var url interface{} = ""
            var urlType interface{} = typeVar
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                // route to WebSocket API connection where the user data stream is subscribed
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var options interface{} = this.SafeDict(this.Options, "watchBalance")
            var fetchBalanceSnapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", false)
            var awaitBalanceSnapshot interface{} = this.SafeBool(options, "awaitBalanceSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes285712 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes285712)
            }
            var messageHash interface{} = ccxt.Add(typeVar, ":balance")
            var message interface{} = nil
        
                retRes286115 :=  (<-this.Watch(url, messageHash, message, typeVar))
                ccxt.PanicOnError(retRes286115)
                ch <- retRes286115
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleBalance(client interface{}, message interface{})  {
    //
    // sent upon a balance update not related to orders
    //
    //     {
    //         "e": "balanceUpdate",
    //         "E": 1629352505586,
    //         "a": "IOTX",
    //         "d": "0.43750000",
    //         "T": 1629352505585
    //     }
    //
    // sent upon creating or filling an order
    //
    //     {
    //         "e": "outboundAccountPosition", // Event type
    //         "E": 1564034571105,             // Event Time
    //         "u": 1564034571073,             // Time of last account update
    //         "B": [                          // ccxt.Balances Array
    //             {
    //                 "a": "ETH",                 // Asset
    //                 "f": "10000.000000",        // Free
    //                 "l": "0.000000"             // Locked
    //             }
    //         ]
    //     }
    //
    // future/delivery
    //
    //     {
    //         "e": "ACCOUNT_UPDATE",            // Event Type
    //         "E": 1564745798939,               // Event Time
    //         "T": 1564745798938 ,              // ccxt.Transaction
    //         "i": "SfsR",                      // ccxt.Account Alias
    //         "a": {                            // Update Data
    //             "m":"ORDER",                  // Event reason type
    //             "B":[                         // ccxt.Balances
    //                 {
    //                     "a":"BTC",                // Asset
    //                     "wb":"122624.12345678",   // Wallet ccxt.Balance
    //                     "cw":"100.12345678"       // Cross Wallet ccxt.Balance
    //                 },
    //             ],
    //             "P":[
    //                 {
    //                     "s":"BTCUSD_200925",      // Symbol
    //                     "pa":"0",                 // ccxt.Position Amount
    //                     "ep":"0.0",               // Entry Price
    //                     "cr":"200",               // (Pre-fee) Accumulated Realized
    //                     "up":"0",                 // Unrealized PnL
    //                     "mt":"isolated",          // Margin Type
    //                     "iw":"0.00000000",        // Isolated Wallet (if isolated position)
    //                     "ps":"BOTH"               // ccxt.Position Side
    //                 },
    //             ]
    //         }
    //     }
    // externalLockUpdate
    //    {
    //        "e": "externalLockUpdate",  // Event Type
    //        "E": 1581557507324,         // Event Time
    //        "a": "NEO",                 // Asset
    //        "d": "10.00000000",         // Delta
    //        "T": 1581557507268          // ccxt.Transaction Time
    //    }
    //
    var wallet interface{} = this.SafeString(this.Options, "wallet", "wb") // cw for cross wallet
    // each account is connected to a different endpoint
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    var messageHash interface{} = ccxt.Add(accountType, ":balance")
    if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(this.Balance, accountType), nil)) {
        ccxt.AddElementToObject(this.Balance, accountType, map[string]interface{} {})
    }
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "info", message)
    var event interface{} = this.SafeString(message, "e")
    if ccxt.IsTrue(ccxt.IsEqual(event, "balanceUpdate")) {
        var currencyId interface{} = this.SafeString(message, "a")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var delta interface{} = this.SafeString(message, "d")
        if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Balance, accountType), code)) {
            var previousValue interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Balance, accountType), code), "free")
            if ccxt.IsTrue(!ccxt.IsString(previousValue)) {
                previousValue = this.NumberToString(previousValue)
            }
            ccxt.AddElementToObject(account, "free", ccxt.Precise.StringAdd(previousValue, delta))
        } else {
            ccxt.AddElementToObject(account, "free", delta)
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
    } else {
        message = this.SafeDict(message, "a", message)
        var B interface{} = this.SafeList(message, "B")
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(B)); i++ {
            var entry interface{} = ccxt.GetValue(B, i)
            var currencyId interface{} = this.SafeString(entry, "a")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            ccxt.AddElementToObject(account, "free", this.SafeString(entry, "f"))
            ccxt.AddElementToObject(account, "used", this.SafeString(entry, "l"))
            ccxt.AddElementToObject(account, "total", this.SafeString(entry, wallet))
            ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
        }
    }
    var timestamp interface{} = this.SafeInteger(message, "E")
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "timestamp", timestamp)
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Balance, accountType, this.SafeBalance(ccxt.GetValue(this.Balance, accountType)))
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, accountType), messageHash)
}
func  (this *BinanceCore) GetAccountTypeFromSubscriptions(subscriptions interface{}) interface{}  {
    var accountType interface{} = ""
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptions)); i++ {
        var subscription interface{} = ccxt.GetValue(subscriptions, i)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(subscription, "spot"))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "margin")))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "future")))) || ccxt.IsTrue((ccxt.IsEqual(subscription, "delivery")))) {
            accountType = subscription
            break
        }
    }
    return accountType
}
func  (this *BinanceCore) GetMarketType(method interface{}, market interface{}, optionalArgs ...interface{}) interface{}  {
    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var typeVar interface{} = nil
    typeVarparamsVariable := this.HandleMarketTypeAndParams(method, market, params)
    typeVar = ccxt.GetValue(typeVarparamsVariable,0)
    params = ccxt.GetValue(typeVarparamsVariable,1)
    var subType interface{} = nil
    subTypeparamsVariable := this.HandleSubTypeAndParams(method, market, params)
    subType = ccxt.GetValue(subTypeparamsVariable,0)
    params = ccxt.GetValue(subTypeparamsVariable,1)
    if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
        typeVar = "future"
    } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
        typeVar = "delivery"
    }
    return typeVar
}
/**
 * @method
 * @name binance#createOrderWs
 * @description create a trade order
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/New-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} params.test test order, default false
 * @param {boolean} params.returnRateLimits set to true to return rate limit information, default false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes30208)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = this.GetMarketType("createOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "delivery"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " createOrderWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var sor interface{} = this.SafeBool2(params, "sor", "SOR", false)
            params = this.Omit(params, "sor", "SOR")
            var payload interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "createOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var test interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.place",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            if ccxt.IsTrue(test) {
                if ccxt.IsTrue(sor) {
                    ccxt.AddElementToObject(message, "method", "sor.order.test")
                } else {
                    ccxt.AddElementToObject(message, "method", "order.test")
                }
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes305215 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes305215)
                ch <- retRes305215
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleOrderWs(client interface{}, message interface{})  {
    //
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //          "symbol": "BTCUSDT",
    //          "orderId": 7663053,
    //          "orderListId": -1,
    //          "clientOrderId": "x-R4BD3S82d8959d0f5114499487a614",
    //          "transactTime": 1687642291434,
    //          "price": "25000.00000000",
    //          "origQty": "0.00100000",
    //          "executedQty": "0.00000000",
    //          "cummulativeQuoteQty": "0.00000000",
    //          "status": "NEW",
    //          "timeInForce": "GTC",
    //          "type": "LIMIT",
    //          "side": "BUY",
    //          "workingTime": 1687642291434,
    //          "fills": [],
    //          "selfTradePreventionMode": "NONE"
    //        },
    //        "rateLimits": [
    //          {
    //            "rateLimitType": "ORDERS",
    //            "interval": "SECOND",
    //            "intervalNum": 10,
    //            "limit": 50,
    //            "count": 1
    //          },
    //          {
    //            "rateLimitType": "ORDERS",
    //            "interval": "DAY",
    //            "intervalNum": 1,
    //            "limit": 160000,
    //            "count": 1
    //          },
    //          {
    //            "rateLimitType": "REQUEST_WEIGHT",
    //            "interval": "MINUTE",
    //            "intervalNum": 1,
    //            "limit": 1200,
    //            "count": 12
    //          }
    //        ]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var order interface{} = this.ParseOrder(result)
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
func  (this *BinanceCore) HandleOrdersWs(client interface{}, message interface{})  {
    //
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": [{
    //            "symbol": "BTCUSDT",
    //            "orderId": 7665584,
    //            "orderListId": -1,
    //            "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
    //            "price": "26000.00000000",
    //            "origQty": "0.00100000",
    //            "executedQty": "0.00000000",
    //            "cummulativeQuoteQty": "0.00000000",
    //            "status": "NEW",
    //            "timeInForce": "GTC",
    //            "type": "LIMIT",
    //            "side": "BUY",
    //            "stopPrice": "0.00000000",
    //            "icebergQty": "0.00000000",
    //            "time": 1687642884646,
    //            "updateTime": 1687642884646,
    //            "isWorking": true,
    //            "workingTime": 1687642884646,
    //            "origQuoteOrderQty": "0.00000000",
    //            "selfTradePreventionMode": "NONE"
    //        },
    //        ...
    //        ],
    //        "rateLimits": [{
    //            "rateLimitType": "REQUEST_WEIGHT",
    //            "interval": "MINUTE",
    //            "intervalNum": 1,
    //            "limit": 1200,
    //            "count": 14
    //        }]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var orders interface{} = this.ParseOrders(result)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
/**
 * @method
 * @name binance#editOrderWs
 * @description edit a trade order
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-and-replace-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Modify-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Modify-ccxt.Order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float|undefined} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) EditOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    amount := ccxt.GetArg(optionalArgs, 0, nil)
            _ = amount
            price := ccxt.GetArg(optionalArgs, 1, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes31708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes31708)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = this.GetMarketType("editOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(marketType, "delivery"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " editOrderWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), marketType)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var isSwap interface{} =     (ccxt.IsTrue(ccxt.IsEqual(marketType, "future")) || ccxt.IsTrue(ccxt.IsEqual(marketType, "delivery")))
            var payload interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                payload = this.EditSpotOrderRequest(id, symbol, typeVar, side, amount, price, params)
            } else if ccxt.IsTrue(isSwap) {
                payload = this.EditContractOrderRequest(id, symbol, typeVar, side, amount, price, params)
            }
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "editOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            ccxt.AddElementToObject(payload, "returnRateLimits", returnRateLimits)
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": ccxt.Ternary(ccxt.IsTrue((isSwap)), "order.modify", "order.cancelReplace"),
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleEditOrderWs,
            }
        
                retRes319715 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes319715)
                ch <- retRes319715
                return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleEditOrderWs(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "id": 1,
    //        "status": 200,
    //        "result": {
    //            "cancelResult": "SUCCESS",
    //            "newOrderResult": "SUCCESS",
    //            "cancelResponse": {
    //                "symbol": "BTCUSDT",
    //                "origClientOrderId": "x-R4BD3S82813c5d7ffa594104917de2",
    //                "orderId": 7665177,
    //                "orderListId": -1,
    //                "clientOrderId": "mbrnbQsQhtCXCLY45d5q7S",
    //                "price": "26000.00000000",
    //                "origQty": "0.00100000",
    //                "executedQty": "0.00000000",
    //                "cummulativeQuoteQty": "0.00000000",
    //                "status": "CANCELED",
    //                "timeInForce": "GTC",
    //                "type": "LIMIT",
    //                "side": "BUY",
    //                "selfTradePreventionMode": "NONE"
    //            },
    //            "newOrderResponse": {
    //                "symbol": "BTCUSDT",
    //                "orderId": 7665584,
    //                "orderListId": -1,
    //                "clientOrderId": "x-R4BD3S82b54769abdd3e4b57874c52",
    //                "transactTime": 1687642884646,
    //                "price": "26000.00000000",
    //                "origQty": "0.00100000",
    //                "executedQty": "0.00000000",
    //                "cummulativeQuoteQty": "0.00000000",
    //                "status": "NEW",
    //                "timeInForce": "GTC",
    //                "type": "LIMIT",
    //                "side": "BUY",
    //                "workingTime": 1687642884646,
    //                "fills": [],
    //                "selfTradePreventionMode": "NONE"
    //            }
    //        },
    //        "rateLimits": [{
    //                "rateLimitType": "ORDERS",
    //                "interval": "SECOND",
    //                "intervalNum": 10,
    //                "limit": 50,
    //                "count": 1
    //            },
    //            {
    //                "rateLimitType": "ORDERS",
    //                "interval": "DAY",
    //                "intervalNum": 1,
    //                "limit": 160000,
    //                "count": 3
    //            },
    //            {
    //                "rateLimitType": "REQUEST_WEIGHT",
    //                "interval": "MINUTE",
    //                "intervalNum": 1,
    //                "limit": 1200,
    //                "count": 12
    //            }
    //        ]
    //    }
    // swap
    //    {
    //        "id":"1",
    //        "status":200,
    //        "result":{
    //            "orderId":667061487,
    //            "symbol":"LTCUSDT",
    //            "status":"NEW",
    //            "clientOrderId":"x-xcKtGhcu91a74c818749ee42c0f70",
    //            "price":"82.00",
    //            "avgPrice":"0.00",
    //            "origQty":"1.000",
    //            "executedQty":"0.000",
    //            "cumQty":"0.000",
    //            "cumQuote":"0.00000",
    //            "timeInForce":"GTC",
    //            "type":"LIMIT",
    //            "reduceOnly":false,
    //            "closePosition":false,
    //            "side":"BUY",
    //            "positionSide":"BOTH",
    //            "stopPrice":"0.00",
    //            "workingType":"CONTRACT_PRICE",
    //            "priceProtect":false,
    //            "origType":"LIMIT",
    //            "priceMatch":"NONE",
    //            "selfTradePreventionMode":"NONE",
    //            "goodTillDate":0,
    //            "updateTime":1712918927511
    //        }
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeDict(message, "result", map[string]interface{} {})
    var newSpotOrder interface{} = this.SafeDict(result, "newOrderResponse")
    var order interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(newSpotOrder, nil)) {
        order = this.ParseOrder(newSpotOrder)
    } else {
        order = this.ParseOrder(result)
    }
    client.(ccxt.ClientInterface).Resolve(order, messageHash)
}
/**
 * @method
 * @name binance#cancelOrderWs
 * @description cancel multiple orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-trade
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/ccxt.Cancel-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/ccxt.Cancel-ccxt.Order
 * @param {string} id order id
 * @param {string} [symbol] unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.cancelRestrictions] Supported values: ONLY_NEW - ccxt.Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - ccxt.Cancel will succeed if order status is PARTIALLY_FILLED.
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes33258)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrderWs requires a symbol")))
            }
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("cancelOrderWs", market, params)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "cancelOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            var clientOrderId interface{} = this.SafeString2(params, "origClientOrderId", "clientOrderId")
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                ccxt.AddElementToObject(payload, "origClientOrderId", clientOrderId)
            } else {
                ccxt.AddElementToObject(payload, "orderId", this.ParseToInt(id))
            }
            params = this.Omit(params, []interface{}{"origClientOrderId", "clientOrderId"})
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.cancel",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes335515 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes335515)
                ch <- retRes335515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#cancelAllOrdersWs
 * @description cancel all open orders in a market
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-open-orders-trade
 * @param {string} [symbol] unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33688 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes33688)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("cancelAllOrdersWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelAllOrdersWs only supports spot markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrdersWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "openOrders.cancelAll",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
                retRes339115 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes339115)
                ch <- retRes339115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrderWs
 * @description fetches information on an order made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#query-order-user_data
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/websocket-api/Query-ccxt.Order
 * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/websocket-api/Query-ccxt.Order
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) FetchOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes34078)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " cancelOrderWs requires a symbol")))
            }
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchOrderWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "delivery"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOrderWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            var clientOrderId interface{} = this.SafeString2(params, "origClientOrderId", "clientOrderId")
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                ccxt.AddElementToObject(payload, "origClientOrderId", clientOrderId)
            } else {
                ccxt.AddElementToObject(payload, "orderId", this.ParseToInt(id))
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "order.status",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrderWs,
            }
        
                retRes343915 :=  (<-this.Watch(url, messageHash, message, messageHash, subscription))
                ccxt.PanicOnError(retRes343915)
                ch <- retRes343915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOrdersWs
 * @description fetches information on multiple orders made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int|undefined} [since] the earliest time in ms to fetch orders for
 * @param {int|undefined} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.orderId] order id to begin at
 * @param {int} [params.startTime] earliest time in ms to retrieve orders for
 * @param {int} [params.endTime] latest time in ms to retrieve orders for
 * @param {int} [params.limit] the maximum number of order structures to retrieve
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) FetchOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes34588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes34588)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOrdersWs requires a symbol")))
            }
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchOrdersWs", market, params)
            if ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOrdersWs only supports spot markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "allOrders",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
            orders:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchClosedOrdersWs
 * @description fetch closed orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-lists
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) FetchClosedOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            orders:= (<-this.FetchOrdersWs(symbol, since, limit, params))
            ccxt.PanicOnError(orders)
            var closedOrders interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
                var order interface{} = ccxt.GetValue(orders, i)
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(order, "status"), "closed")) {
                    ccxt.AppendToArray(&closedOrders, order)
                }
            }
        
            ch <- closedOrders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchOpenOrdersWs
 * @description fetch all unfilled currently open orders
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#current-open-orders-user_data
 * @param {string} symbol unified market symbol
 * @param {int|undefined} [since] the earliest time in ms to fetch open orders for
 * @param {int|undefined} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) FetchOpenOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35238 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes35238)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchOpenOrdersWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchOpenOrdersWs only supports spot or swap markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchOrderWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                ccxt.AddElementToObject(payload, "symbol", this.MarketId(symbol))
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "openOrders.status",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleOrdersWs,
            }
        
            orders:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(orders)
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/user-data-stream#order-update
 * @see https://developers.binance.com/docs/margin_trading/trade-data-stream/Event-ccxt.Order-Update
 * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/user-data-streams/Event-ccxt.Order-Update
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for spot margin
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch portfolio margin account orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BinanceCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35688 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes35688)
            var messageHash interface{} = "orders"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchOrders", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            params = this.Extend(params, map[string]interface{} {
                "type": typeVar,
                "symbol": symbol,
            }) // needed inside authenticate for isolated margin
        
            retRes35868 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes35868)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchOrders", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var urlType interface{} = typeVar
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "margin"))) || ccxt.IsTrue((ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))) && ccxt.IsTrue((!ccxt.IsEqual(marginMode, nil)))))) {
                urlType = "spot" // spot-margin shares the same stream as regular spot
            }
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "watchOrders", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var url interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                // route orders to ws-api user data stream
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var message interface{} = nil
        
            orders:= (<-this.Watch(url, messageHash, message, typeVar))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "e": "executionReport",        // Event type
    //         "E": 1499405658658,            // Event time
    //         "s": "ETHBTC",                 // Symbol
    //         "c": "mUvoqJxFIILMdfAW5iGSOW", // ccxt.Client order ID
    //         "S": "BUY",                    // Side
    //         "o": "LIMIT",                  // ccxt.Order type
    //         "f": "GTC",                    // Time in force
    //         "q": "1.00000000",             // ccxt.Order quantity
    //         "p": "0.10264410",             // ccxt.Order price
    //         "P": "0.00000000",             // Stop price
    //         "F": "0.00000000",             // Iceberg quantity
    //         "g": -1,                       // OrderListId
    //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
    //         "x": "NEW",                    // Current execution type
    //         "X": "NEW",                    // Current order status
    //         "r": "NONE",                   // ccxt.Order reject reason; will be an error code.
    //         "i": 4293153,                  // ccxt.Order ID
    //         "l": "0.00000000",             // Last executed quantity
    //         "z": "0.00000000",             // Cumulative filled quantity
    //         "L": "0.00000000",             // Last executed price
    //         "n": "0",                      // Commission amount
    //         "N": null,                     // Commission asset
    //         "T": 1499405658657,            // ccxt.Transaction time
    //         "t": -1,                       // ccxt.Trade ID
    //         "I": 8641984,                  // Ignore
    //         "w": true,                     // Is the order on the book?
    //         "m": false,                    // Is this trade the maker side?
    //         "M": false,                    // Ignore
    //         "O": 1499405658657,            // ccxt.Order creation time
    //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
    //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
    //         "Q": "0.00000000"              // Quote ccxt.Order Qty
    //     }
    //
    // future
    //
    //     {
    //         "s":"BTCUSDT",                 // Symbol
    //         "c":"TEST",                    // ccxt.Client ccxt.Order Id
    //                                        // special client order id:
    //                                        // starts with "autoclose-": liquidation order
    //                                        // "adl_autoclose": ADL auto close order
    //         "S":"SELL",                    // Side
    //         "o":"TRAILING_STOP_MARKET",    // ccxt.Order Type
    //         "f":"GTC",                     // Time in Force
    //         "q":"0.001",                   // Original Quantity
    //         "p":"0",                       // Original Price
    //         "ap":"0",                      // Average Price
    //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //         "x":"NEW",                     // Execution Type
    //         "X":"NEW",                     // ccxt.Order Status
    //         "i":8886774,                   // ccxt.Order Id
    //         "l":"0",                       // ccxt.Order Last Filled Quantity
    //         "z":"0",                       // ccxt.Order Filled Accumulated Quantity
    //         "L":"0",                       // Last Filled Price
    //         "N":"USDT",                    // Commission Asset, will not push if no commission
    //         "n":"0",                       // Commission, will not push if no commission
    //         "T":1568879465651,             // ccxt.Order ccxt.Trade Time
    //         "t":0,                         // ccxt.Trade Id
    //         "b":"0",                       // ccxt.Bids Notional
    //         "a":"9.91",                    // Ask Notional
    //         "m":false,                     // Is this trade the maker side?
    //         "R":false,                     // Is this reduce only
    //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
    //         "ot":"TRAILING_STOP_MARKET",   // Original ccxt.Order Type
    //         "ps":"LONG",                   // ccxt.Position Side
    //         "cp":false,                    // If Close-All, pushed with conditional order
    //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //         "rp":"0"                       // Realized Profit of the trade
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var executionType interface{} = this.SafeString(order, "x")
    var orderId interface{} = this.SafeString(order, "i")
    var marketId interface{} = this.SafeString(order, "s")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(order, "ps"))), "contract", "spot")
    var symbol interface{} = this.SafeSymbol(marketId, nil, nil, marketType)
    var timestamp interface{} = this.SafeInteger(order, "O")
    var T interface{} = this.SafeInteger(order, "T")
    var lastTradeTimestamp interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(executionType, "NEW")) || ccxt.IsTrue(ccxt.IsEqual(executionType, "AMENDMENT"))) || ccxt.IsTrue(ccxt.IsEqual(executionType, "CANCELED"))) {
        if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
            timestamp = T
        }
    } else if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        lastTradeTimestamp = T
    }
    var lastUpdateTimestamp interface{} = T
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "n")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(feeCost, nil))) && ccxt.IsTrue((ccxt.Precise.StringGt(feeCost, "0")))) {
        var feeCurrencyId interface{} = this.SafeString(order, "N")
        var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    var price interface{} = this.SafeString(order, "p")
    var amount interface{} = this.SafeString(order, "q")
    var side interface{} = this.SafeStringLower(order, "S")
    var typeVar interface{} = this.SafeStringLower(order, "o")
    var filled interface{} = this.SafeString(order, "z")
    var cost interface{} = this.SafeString(order, "Z")
    var average interface{} = this.SafeString(order, "ap")
    var rawStatus interface{} = this.SafeString(order, "X")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    var trades interface{} = nil
    var clientOrderId interface{} = this.SafeString(order, "C")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(clientOrderId, nil))) || ccxt.IsTrue((ccxt.IsEqual(ccxt.GetLength(clientOrderId), 0)))) {
        clientOrderId = this.SafeString(order, "c")
    }
    var stopPrice interface{} = this.SafeString2(order, "P", "sp")
    var timeInForce interface{} = this.SafeString(order, "f")
    if ccxt.IsTrue(ccxt.IsEqual(timeInForce, "GTX")) {
        // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
        timeInForce = "PO"
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "R"),
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": amount,
        "cost": cost,
        "average": average,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": trades,
    })
}
func  (this *BinanceCore) HandleOrderUpdate(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "e": "executionReport",        // Event type
    //         "E": 1499405658658,            // Event time
    //         "s": "ETHBTC",                 // Symbol
    //         "c": "mUvoqJxFIILMdfAW5iGSOW", // ccxt.Client order ID
    //         "S": "BUY",                    // Side
    //         "o": "LIMIT",                  // ccxt.Order type
    //         "f": "GTC",                    // Time in force
    //         "q": "1.00000000",             // ccxt.Order quantity
    //         "p": "0.10264410",             // ccxt.Order price
    //         "P": "0.00000000",             // Stop price
    //         "F": "0.00000000",             // Iceberg quantity
    //         "g": -1,                       // OrderListId
    //         "C": null,                     // Original client order ID; This is the ID of the order being canceled
    //         "x": "NEW",                    // Current execution type
    //         "X": "NEW",                    // Current order status
    //         "r": "NONE",                   // ccxt.Order reject reason; will be an error code.
    //         "i": 4293153,                  // ccxt.Order ID
    //         "l": "0.00000000",             // Last executed quantity
    //         "z": "0.00000000",             // Cumulative filled quantity
    //         "L": "0.00000000",             // Last executed price
    //         "n": "0",                      // Commission amount
    //         "N": null,                     // Commission asset
    //         "T": 1499405658657,            // ccxt.Transaction time
    //         "t": -1,                       // ccxt.Trade ID
    //         "I": 8641984,                  // Ignore
    //         "w": true,                     // Is the order on the book?
    //         "m": false,                    // Is this trade the maker side?
    //         "M": false,                    // Ignore
    //         "O": 1499405658657,            // ccxt.Order creation time
    //         "Z": "0.00000000",             // Cumulative quote asset transacted quantity
    //         "Y": "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
    //         "Q": "0.00000000"              // Quote ccxt.Order Qty
    //     }
    //
    // future
    //
    //     {
    //         "e":"ORDER_TRADE_UPDATE",           // Event Type
    //         "E":1568879465651,                  // Event Time
    //         "T":1568879465650,                  // Trasaction Time
    //         "o": {
    //             "s":"BTCUSDT",                  // Symbol
    //             "c":"TEST",                     // ccxt.Client ccxt.Order Id
    //                                             // special client order id:
    //                                             // starts with "autoclose-": liquidation order
    //                                             // "adl_autoclose": ADL auto close order
    //             "S":"SELL",                     // Side
    //             "o":"TRAILING_STOP_MARKET",     // ccxt.Order Type
    //             "f":"GTC",                      // Time in Force
    //             "q":"0.001",                    // Original Quantity
    //             "p":"0",                        // Original Price
    //             "ap":"0",                       // Average Price
    //             "sp":"7103.04",                 // Stop Price. Please ignore with TRAILING_STOP_MARKET order
    //             "x":"NEW",                      // Execution Type
    //             "X":"NEW",                      // ccxt.Order Status
    //             "i":8886774,                    // ccxt.Order Id
    //             "l":"0",                        // ccxt.Order Last Filled Quantity
    //             "z":"0",                        // ccxt.Order Filled Accumulated Quantity
    //             "L":"0",                        // Last Filled Price
    //             "N":"USDT",                     // Commission Asset, will not push if no commission
    //             "n":"0",                        // Commission, will not push if no commission
    //             "T":1568879465651,              // ccxt.Order ccxt.Trade Time
    //             "t":0,                          // ccxt.Trade Id
    //             "b":"0",                        // ccxt.Bids Notional
    //             "a":"9.91",                     // Ask Notional
    //             "m":false,                      // Is this trade the maker side?
    //             "R":false,                      // Is this reduce only
    //             "wt":"CONTRACT_PRICE",          // Stop Price Working Type
    //             "ot":"TRAILING_STOP_MARKET",    // Original ccxt.Order Type
    //             "ps":"LONG",                    // ccxt.Position Side
    //             "cp":false,                     // If Close-All, pushed with conditional order
    //             "AP":"7476.89",                 // Activation Price, only puhed with TRAILING_STOP_MARKET order
    //             "cr":"5.0",                     // Callback Rate, only puhed with TRAILING_STOP_MARKET order
    //             "rp":"0"                        // Realized Profit of the trade
    //         }
    //     }
    //
    var e interface{} = this.SafeString(message, "e")
    if ccxt.IsTrue(ccxt.IsEqual(e, "ORDER_TRADE_UPDATE")) {
        message = this.SafeDict(message, "o", message)
    }
    this.HandleMyTrade(client, message)
    this.HandleOrder(client, message)
    this.HandleMyLiquidation(client, message)
}
/**
 * @method
 * @name binance#watchPositions
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {number} [since] since timestamp
 * @param {number} [limit] limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch positions in a portfolio margin account
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BinanceCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes38708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes38708)
            var market interface{} = nil
            var messageHash interface{} = ""
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                market = this.GetMarketFromSymbols(symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchPositions", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) || ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin"))) {
                typeVar = "future"
            }
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchPositions", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            var marketTypeObject interface{} = map[string]interface{} {}
            ccxt.AddElementToObject(marketTypeObject, "type", typeVar)
            ccxt.AddElementToObject(marketTypeObject, "subType", subType)
        
            retRes38938 := (<-this.Authenticate(this.Extend(marketTypeObject, params)))
            ccxt.PanicOnError(retRes38938)
            messageHash = ccxt.Add(ccxt.Add(typeVar, ":positions"), messageHash)
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "watchPositions", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var urlType interface{} = typeVar
            if ccxt.IsTrue(isPortfolioMargin) {
                urlType = "papi"
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, symbols, isPortfolioMargin)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            var cache interface{} = this.SafeValue(this.Positions, typeVar)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(cache, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchPositionsSnapshot")))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
        
            newPositions:= (<-this.Watch(url, messageHash, nil, typeVar))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    isPortfolioMargin := ccxt.GetArg(optionalArgs, 1, false)
    _ = isPortfolioMargin
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if ccxt.IsTrue(ccxt.InOp(this.Positions, typeVar)) {
        return
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = ccxt.Add(typeVar, ":fetchPositionsSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash, typeVar, isPortfolioMargin)
        }
    } else {
        ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
    }
}
func  (this *BinanceCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}, typeVar interface{}, isPortfolioMargin interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var params interface{} = map[string]interface{} {
                "type": typeVar,
            }
            if ccxt.IsTrue(isPortfolioMargin) {
                ccxt.AddElementToObject(params, "portfolioMargin", true)
            }
        
            positions:= (<-this.FetchPositions(nil, params))
            ccxt.PanicOnError(positions)
            ccxt.AddElementToObject(this.Positions, typeVar, ccxt.NewArrayCacheBySymbolBySide())
            var cache interface{} = ccxt.GetValue(this.Positions, typeVar)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve(cache)
            client.(ccxt.ClientInterface).Resolve(cache, ccxt.Add(typeVar, ":position"))
                return nil
            }()
            return ch
        }
func  (this *BinanceCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         e: 'ACCOUNT_UPDATE',
    //         T: 1667881353112,
    //         E: 1667881353115,
    //         a: {
    //             B: [{
    //                 a: 'USDT',
    //                 wb: '1127.95750089',
    //                 cw: '1040.82091149',
    //                 bc: '0'
    //             }],
    //             P: [{
    //                 s: 'BTCUSDT',
    //                 pa: '-0.089',
    //                 ep: '19700.03933',
    //                 cr: '-1260.24809979',
    //                 up: '1.53058860',
    //                 mt: 'isolated',
    //                 iw: '87.13658940',
    //                 ps: 'BOTH',
    //                 ma: 'USDT'
    //             }],
    //             m: 'ORDER'
    //         }
    //     }
    //
    // each account is connected to a different endpoint
    // and has exactly one subscriptionhash which is the account type
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    if !ccxt.IsTrue((ccxt.InOp(this.Positions, accountType))) {
        ccxt.AddElementToObject(this.Positions, accountType, ccxt.NewArrayCacheBySymbolBySide())
    }
    var cache interface{} = ccxt.GetValue(this.Positions, accountType)
    var data interface{} = this.SafeDict(message, "a", map[string]interface{} {})
    var rawPositions interface{} = this.SafeList(data, "P", []interface{}{})
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        var timestamp interface{} = this.SafeInteger(message, "E")
        ccxt.AddElementToObject(position, "timestamp", timestamp)
        ccxt.AddElementToObject(position, "datetime", this.Iso8601(timestamp))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(accountType, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(accountType, ":positions"))
}
func  (this *BinanceCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "s": "BTCUSDT", // Symbol
    //         "pa": "0", // ccxt.Position Amount
    //         "ep": "0.00000", // Entry Price
    //         "cr": "200", // (Pre-fee) Accumulated Realized
    //         "up": "0", // Unrealized PnL
    //         "mt": "isolated", // Margin Type
    //         "iw": "0.00000000", // Isolated Wallet (if isolated position)
    //         "ps": "BOTH" // ccxt.Position Side
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "s")
    var contracts interface{} = this.SafeString(position, "pa")
    var contractsAbs interface{} = ccxt.Precise.StringAbs(this.SafeString(position, "pa"))
    var positionSide interface{} = this.SafeStringLower(position, "ps")
    var hedged interface{} = true
    if ccxt.IsTrue(ccxt.IsEqual(positionSide, "both")) {
        hedged = false
        if !ccxt.IsTrue(ccxt.Precise.StringEq(contracts, "0")) {
            if ccxt.IsTrue(ccxt.Precise.StringLt(contracts, "0")) {
                positionSide = "short"
            } else {
                positionSide = "long"
            }
        }
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeSymbol(marketId, nil, nil, "contract"),
        "notional": nil,
        "marginMode": this.SafeString(position, "mt"),
        "liquidationPrice": nil,
        "entryPrice": this.SafeNumber(position, "ep"),
        "unrealizedPnl": this.SafeNumber(position, "up"),
        "percentage": nil,
        "contracts": this.ParseNumber(contractsAbs),
        "contractSize": nil,
        "markPrice": nil,
        "side": positionSide,
        "hedged": hedged,
        "timestamp": nil,
        "datetime": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
    })
}
/**
 * @method
 * @name binance#fetchMyTradesWs
 * @description fetch all trades made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-trade-history-user_data
 * @param {string} symbol unified market symbol
 * @param {int|undefined} [since] the earliest time in ms to fetch trades for
 * @param {int|undefined} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.endTime] the latest time in ms to fetch trades for
 * @param {int} [params.fromId] first trade Id to fetch
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BinanceCore) FetchMyTradesWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes40998 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes40998)
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchMyTradesWs requires a symbol")))
            }
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchMyTradesWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " fetchMyTradesWs does not support "), typeVar), " markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchMyTradesWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(since, nil)) {
                ccxt.AddElementToObject(payload, "startTime", since)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var fromId interface{} = this.SafeInteger(params, "fromId")
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(fromId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(since, nil))) {
                panic(ccxt.BadRequest(ccxt.Add(this.Id, " fetchMyTradesWs does not support fetching by both fromId and since parameters at the same time")))
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "myTrades",
                "params": this.SignParams(this.Extend(payload, params)),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTradesWs,
            }
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name binance#fetchTradesWs
 * @description fetch all trades made by the user
 * @see https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/market-data-requests#recent-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve, default=500, max=1000
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.fromId] trade ID to begin at
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BinanceCore) FetchTradesWs(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes41548 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes41548)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = this.GetMarketType("fetchTradesWs", market, params)
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue(!ccxt.IsEqual(typeVar, "future"))) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " fetchTradesWs does not support "), typeVar), " markets")))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            var requestId interface{} = this.RequestId(url)
            var messageHash interface{} = ccxt.ToString(requestId)
            var returnRateLimits interface{} = false
            returnRateLimitsparamsVariable := this.HandleOptionAndParams(params, "fetchTradesWs", "returnRateLimits", false)
            returnRateLimits = ccxt.GetValue(returnRateLimitsparamsVariable,0)
            params = ccxt.GetValue(returnRateLimitsparamsVariable,1)
            var payload interface{} = map[string]interface{} {
                "symbol": this.MarketId(symbol),
                "returnRateLimits": returnRateLimits,
            }
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                ccxt.AddElementToObject(payload, "limit", limit)
            }
            var message interface{} = map[string]interface{} {
                "id": messageHash,
                "method": "trades.historical",
                "params": this.Extend(payload, params),
            }
            var subscription interface{} = map[string]interface{} {
                "method": this.HandleTradesWs,
            }
        
            trades:= (<-this.Watch(url, messageHash, message, messageHash, subscription))
            ccxt.PanicOnError(trades)
        
            ch <- this.FilterBySinceLimit(trades, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleTradesWs(client interface{}, message interface{})  {
    //
    // fetchMyTradesWs
    //
    //    {
    //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
    //        "status": 200,
    //        "result": [
    //            {
    //                "symbol": "BTCUSDT",
    //                "id": 1650422481,
    //                "orderId": 12569099453,
    //                "orderListId": -1,
    //                "price": "23416.10000000",
    //                "qty": "0.00635000",
    //                "quoteQty": "148.69223500",
    //                "commission": "0.00000000",
    //                "commissionAsset": "BNB",
    //                "time": 1660801715793,
    //                "isBuyer": false,
    //                "isMaker": true,
    //                "isBestMatch": true
    //            },
    //            ...
    //        ],
    //    }
    //
    // fetchTradesWs
    //
    //    {
    //        "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
    //        "status": 200,
    //        "result": [
    //            {
    //                "id": 0,
    //                "price": "0.00005000",
    //                "qty": "40.00000000",
    //                "quoteQty": "0.00200000",
    //                "time": 1500004800376,
    //                "isBuyerMaker": true,
    //                "isBestMatch": true
    //            }
    //            ...
    //        ],
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var result interface{} = this.SafeList(message, "result", []interface{}{})
    var trades interface{} = this.ParseTrades(result)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
/**
 * @method
 * @name binance#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to watch trades in a portfolio margin account
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BinanceCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes42488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes42488)
            var typeVar interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchMyTrades", market, params)
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(this.IsLinear(typeVar, subType)) {
                typeVar = "future"
            } else if ccxt.IsTrue(this.IsInverse(typeVar, subType)) {
                typeVar = "delivery"
            }
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
                params = this.Extend(params, map[string]interface{} {
                    "type": ccxt.GetValue(market, "type"),
                    "symbol": symbol,
                })
            }
        
            retRes42698 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes42698)
            var urlType interface{} = typeVar // we don't change type because the listening key is different
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")) {
                urlType = "spot" // spot-margin shares the same stream as regular spot
            }
            var isPortfolioMargin interface{} = nil
            isPortfolioMarginparamsVariable := this.HandleOptionAndParams2(params, "watchMyTrades", "papi", "portfolioMargin", false)
            isPortfolioMargin = ccxt.GetValue(isPortfolioMarginparamsVariable,0)
            params = ccxt.GetValue(isPortfolioMarginparamsVariable,1)
            var url interface{} = ""
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "ws-api"), typeVar)
            } else {
                if ccxt.IsTrue(isPortfolioMargin) {
                    urlType = "papi"
                }
                url = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), urlType), "/"), ccxt.GetValue(ccxt.GetValue(this.Options, typeVar), "listenKey"))
            }
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, isPortfolioMargin)
            this.SetPositionsCache(client, typeVar, nil, isPortfolioMargin)
            var message interface{} = nil
        
            trades:= (<-this.Watch(url, messageHash, message, typeVar))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BinanceCore) HandleMyTrade(client interface{}, message interface{})  {
    var messageHash interface{} = "myTrades"
    var executionType interface{} = this.SafeString(message, "x")
    if ccxt.IsTrue(ccxt.IsEqual(executionType, "TRADE")) {
        var trade interface{} = this.ParseWsTrade(message)
        var orderId interface{} = this.SafeString(trade, "order")
        var tradeFee interface{} = this.SafeDict(trade, "fee", map[string]interface{} {})
        tradeFee = this.Extend(map[string]interface{} {}, tradeFee)
        var symbol interface{} = this.SafeString(trade, "symbol")
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(orderId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(tradeFee, nil))) && ccxt.IsTrue(!ccxt.IsEqual(symbol, nil))) {
            var cachedOrders interface{} = this.Orders
            if ccxt.IsTrue(!ccxt.IsEqual(cachedOrders, nil)) {
                var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
                var order interface{} = this.SafeValue(orders, orderId)
                if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
                    // accumulate order fees
                    var fees interface{} = this.SafeValue(order, "fees")
                    var fee interface{} = this.SafeValue(order, "fee")
                    if !ccxt.IsTrue(this.IsEmpty(fees)) {
                        var insertNewFeeCurrency interface{} = true
                        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(fees)); i++ {
                            var orderFee interface{} = ccxt.GetValue(fees, i)
                            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderFee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                                var feeCost interface{} = this.Sum(ccxt.GetValue(tradeFee, "cost"), ccxt.GetValue(orderFee, "cost"))
                                ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(order, "fees"), i), "cost", ccxt.ParseFloat(this.CurrencyToPrecision(ccxt.GetValue(tradeFee, "currency"), feeCost)))
                                insertNewFeeCurrency = false
                                break
                            }
                        }
                        if ccxt.IsTrue(insertNewFeeCurrency) {
                            retRes432632 := ccxt.GetValue(order, "fees")
                            ccxt.AppendToArray(&retRes432632, tradeFee)
                        }
                    } else if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                        if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), ccxt.GetValue(tradeFee, "currency"))) {
                            var feeCost interface{} = this.Sum(ccxt.GetValue(fee, "cost"), ccxt.GetValue(tradeFee, "cost"))
                            ccxt.AddElementToObject(ccxt.GetValue(order, "fee"), "cost", ccxt.ParseFloat(this.CurrencyToPrecision(ccxt.GetValue(tradeFee, "currency"), feeCost)))
                        } else if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(fee, "currency"), nil)) {
                            ccxt.AddElementToObject(order, "fee", tradeFee)
                        } else {
                            ccxt.AddElementToObject(order, "fees", []interface{}{fee, tradeFee})
                            ccxt.AddElementToObject(order, "fee", nil)
                        }
                    } else {
                        ccxt.AddElementToObject(order, "fee", tradeFee)
                    }
                    // save this trade in the order
                    var orderTrades interface{} = this.SafeList(order, "trades", []interface{}{})
                    ccxt.AppendToArray(&orderTrades, trade)
                    ccxt.AddElementToObject(order, "trades", orderTrades)
                }
            }
        }
        if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var myTrades interface{} = this.MyTrades
        myTrades.(ccxt.Appender).Append(trade)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHash)
        var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, messageHashSymbol)
    }
}
func  (this *BinanceCore) HandleOrder(client interface{}, message interface{})  {
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cachedOrders interface{} = this.Orders
        var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var order interface{} = this.SafeValue(orders, orderId)
        if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
            var fee interface{} = this.SafeValue(order, "fee")
            if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                ccxt.AddElementToObject(parsed, "fee", fee)
            }
            var fees interface{} = this.SafeValue(order, "fees")
            if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
                ccxt.AddElementToObject(parsed, "fees", fees)
            }
            ccxt.AddElementToObject(parsed, "trades", this.SafeValue(order, "trades"))
            var timestamp interface{} = this.SafeInteger(parsed, "timestamp")
            if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
                ccxt.AddElementToObject(parsed, "timestamp", this.SafeInteger(order, "timestamp"))
                ccxt.AddElementToObject(parsed, "datetime", this.SafeString(order, "datetime"))
            }
        }
        cachedOrders.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = "orders"
        var symbolSpecificMessageHash interface{} = ccxt.Add("orders:", symbol)
        client.(ccxt.ClientInterface).Resolve(cachedOrders, messageHash)
        client.(ccxt.ClientInterface).Resolve(cachedOrders, symbolSpecificMessageHash)
    }
}
func  (this *BinanceCore) HandleAcountUpdate(client interface{}, message interface{})  {
    this.HandleBalance(client, message)
    this.HandlePositions(client, message)
}
func  (this *BinanceCore) HandleWsError(client interface{}, message interface{})  {
    //
    //    {
    //        "error": {
    //            "code": 2,
    //            "msg": "Invalid request: invalid stream"
    //        },
    //        "id": 1
    //    }
    //
    var id interface{} = this.SafeString(message, "id")
    var rejected interface{} = false
    var error interface{} = this.SafeDict(message, "error", map[string]interface{} {})
    var code interface{} = this.SafeInteger(error, "code")
    var msg interface{} = this.SafeString(error, "msg")
    
        {
             func(this *BinanceCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BinanceCore) interface{} {
                            // catch block:
                                    rejected = true
            // private endpoint uses id as messageHash
            client.(ccxt.ClientInterface).Reject(e, id)
            // public endpoint stores messageHash in subscriptions
            var subscriptionKeys interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetSubscriptions())
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subscriptionKeys)); i++ {
                var subscriptionHash interface{} = ccxt.GetValue(subscriptionKeys, i)
                var subscriptionId interface{} = this.SafeString(ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash), "id")
                var subscription interface{} = this.SafeString(ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash), "subscription")
                if ccxt.IsTrue(ccxt.IsEqual(id, subscriptionId)) {
                    client.(ccxt.ClientInterface).Reject(e, subscriptionHash)
                    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subscription)
                    }
                }
            }
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        this.HandleErrors(code, msg, client.(ccxt.ClientInterface).GetUrl(), "", map[string]interface{} {}, this.Json(error), error, map[string]interface{} {}, map[string]interface{} {})
    		    return nil
    	    }(this)
        
            }
    if !ccxt.IsTrue(rejected) {
        client.(ccxt.ClientInterface).Reject(message, id)
    }
    // reset connection if 5xx error
    var codeString interface{} = this.SafeString(error, "code")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(codeString, nil))) && ccxt.IsTrue((ccxt.IsEqual(ccxt.GetValue(codeString, 0), "5")))) {
        client.(ccxt.ClientInterface).Reset(message)
    }
}
func  (this *BinanceCore) HandleEventStreamTerminated(client interface{}, message interface{})  {
    //
    //    {
    //        e: 'eventStreamTerminated',
    //        E: 1757896885229
    //    }
    //
    var event interface{} = this.SafeString(message, "e")
    var subscriptions interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var subscriptionsKeys interface{} = ccxt.ObjectKeys(subscriptions)
    var accountType interface{} = this.GetAccountTypeFromSubscriptions(subscriptionsKeys)
    if ccxt.IsTrue(ccxt.IsEqual(event, "eventStreamTerminated")) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), accountType)
        client.(ccxt.ClientInterface).Reject(message, accountType)
    }
}
func  (this *BinanceCore) HandleMessage(client interface{}, message interface{})  {
    // handle WebSocketAPI
    var eventMsg interface{} = this.SafeDict(message, "event")
    if ccxt.IsTrue(!ccxt.IsEqual(eventMsg, nil)) {
        message = eventMsg
    }
    var status interface{} = this.SafeString(message, "status")
    var error interface{} = this.SafeValue(message, "error")
    if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(error, nil))) || ccxt.IsTrue((ccxt.IsTrue(!ccxt.IsEqual(status, nil)) && ccxt.IsTrue(!ccxt.IsEqual(status, "200"))))) {
        this.HandleWsError(client, message)
        return
    }
    // user subscription wraps message in subscriptionId and event
    var id interface{} = this.SafeString(message, "id")
    var subscriptions interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    var method interface{} = this.SafeValue(subscriptions, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
        return
    }
    // handle other APIs
    var methods interface{} = map[string]interface{} {
        "depthUpdate": this.HandleOrderBook,
        "trade": this.HandleTrade,
        "aggTrade": this.HandleTrade,
        "kline": this.HandleOHLCV,
        "markPrice_kline": this.HandleOHLCV,
        "indexPrice_kline": this.HandleOHLCV,
        "1hTicker@arr": this.HandleTickers,
        "4hTicker@arr": this.HandleTickers,
        "1dTicker@arr": this.HandleTickers,
        "24hrTicker@arr": this.HandleTickers,
        "24hrMiniTicker@arr": this.HandleTickers,
        "1hTicker": this.HandleTickers,
        "4hTicker": this.HandleTickers,
        "1dTicker": this.HandleTickers,
        "24hrTicker": this.HandleTickers,
        "24hrMiniTicker": this.HandleTickers,
        "markPriceUpdate": this.HandleTickers,
        "markPriceUpdate@arr": this.HandleTickers,
        "bookTicker": this.HandleBidsAsks,
        "outboundAccountPosition": this.HandleBalance,
        "balanceUpdate": this.HandleBalance,
        "ACCOUNT_UPDATE": this.HandleAcountUpdate,
        "executionReport": this.HandleOrderUpdate,
        "ORDER_TRADE_UPDATE": this.HandleOrderUpdate,
        "forceOrder": this.HandleLiquidation,
        "eventStreamTerminated": this.HandleEventStreamTerminated,
        "externalLockUpdate": this.HandleBalance,
    }
    var event interface{} = this.SafeString(message, "e")
    if ccxt.IsTrue(ccxt.IsArray(message)) {
        var data interface{} = ccxt.GetValue(message, 0)
        event = ccxt.Add(this.SafeString(data, "e"), "@arr")
    }
    method = this.SafeValue(methods, event)
    if ccxt.IsTrue(ccxt.IsEqual(method, nil)) {
        var requestId interface{} = this.SafeString(message, "id")
        if ccxt.IsTrue(!ccxt.IsEqual(requestId, nil)) {
            this.HandleSubscriptionStatus(client, message)
            return
        }
        // special case for the real-time bookTicker, since it comes without an event identifier
        //
        //     {
        //         "u": 7488717758,
        //         "s": "BTCUSDT",
        //         "b": "28621.74000000",
        //         "B": "1.43278800",
        //         "a": "28621.75000000",
        //         "A": "2.52500800"
        //     }
        //
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, nil)) && ccxt.IsTrue((ccxt.InOp(message, "a")))) && ccxt.IsTrue((ccxt.InOp(message, "b")))) {
            this.HandleBidsAsks(client, message)
        }
    } else {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *BinanceCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
