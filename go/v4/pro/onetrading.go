package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type OnetradingCore struct {
	*ccxt.OnetradingCore
	base *ccxt.OnetradingCore
}

func NewOnetradingCore() *OnetradingCore {
    p := &OnetradingCore{}
	base := &ccxt.OnetradingCore{}
	p.base = base
	p.OnetradingCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *OnetradingCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": false,
            "watchTradesForSymbols": false,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://streams.onetrading.com/",
            },
        },
        "options": map[string]interface{} {
            "bp_remaining_quota": 200,
            "timeframes": map[string]interface{} {
                "1m": map[string]interface{} {
                    "unit": "MINUTES",
                    "period": 1,
                },
                "5m": map[string]interface{} {
                    "unit": "MINUTES",
                    "period": 5,
                },
                "15m": map[string]interface{} {
                    "unit": "MINUTES",
                    "period": 15,
                },
                "30m": map[string]interface{} {
                    "unit": "MINUTES",
                    "period": 30,
                },
                "1h": map[string]interface{} {
                    "unit": "HOURS",
                    "period": 1,
                },
                "4h": map[string]interface{} {
                    "unit": "HOURS",
                    "period": 4,
                },
                "1d": map[string]interface{} {
                    "unit": "DAYS",
                    "period": 1,
                },
                "1w": map[string]interface{} {
                    "unit": "WEEKS",
                    "period": 1,
                },
                "1M": map[string]interface{} {
                    "unit": "MONTHS",
                    "period": 1,
                },
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name onetrading#watchBalance
 * @see https://developers.bitpanda.com/exchange/#account-history-channel
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *OnetradingCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes898 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes898)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "balance"
            var subscribeHash interface{} = "ACCOUNT_HISTORY"
            var bpRemainingQuota interface{} = this.SafeInteger(this.Options, "bp_remaining_quota", 200)
            var subscribe interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "bp_remaining_quota": bpRemainingQuota,
                "channels": []interface{}{map[string]interface{} {
            "name": "ACCOUNT_HISTORY",
        }},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes10415 :=  (<-this.Watch(url, messageHash, request, subscribeHash, request))
                ccxt.PanicOnError(retRes10415)
                ch <- retRes10415
                return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) HandleBalanceSnapshot(client interface{}, message interface{})  {
    //
    // snapshot
    //     {
    //         "account_id": "b355abb8-aaae-4fae-903c-c60ff74723c6",
    //         "type": "BALANCES_SNAPSHOT",
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "time": "2019-04-01T13:39:17.155Z",
    //         "balances": [{
    //                 "account_id": "b355abb8-aaae-4fae-903c-c60ff74723c6",
    //                 "currency_code": "BTC",
    //                 "change": "0.5",
    //                 "available": "10.0",
    //                 "locked": "1.1234567",
    //                 "sequence": 1,
    //                 "time": "2019-04-01T13:39:17.155Z"
    //             },
    //             {
    //                 "account_id": "b355abb8-aaae-4fae-903c-c60ff74723c6",
    //                 "currency_code": "ETH",
    //                 "change": "0.5",
    //                 "available": "10.0",
    //                 "locked": "1.1234567",
    //                 "sequence": 2,
    //                 "time": "2019-04-01T13:39:17.155Z"
    //             }
    //         ]
    //     }
    //
    this.Balance = this.ParseBalance(message)
    var messageHash interface{} = "balance"
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
/**
 * @method
 * @name onetrading#watchTicker
 * @see https://developers.bitpanda.com/exchange/#market-ticker-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OnetradingCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1518)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var subscriptionHash interface{} = "MARKET_TICKER"
            var messageHash interface{} = ccxt.Add("ticker.", symbol)
            var request interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "channels": []interface{}{map[string]interface{} {
            "name": "MARKET_TICKER",
            "price_points_mode": "INLINE",
        }},
            }
        
                retRes16515 :=  (<-this.WatchMany(messageHash, request, subscriptionHash, []interface{}{symbol}, params))
                ccxt.PanicOnError(retRes16515)
                ch <- retRes16515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#watchTickers
 * @see https://developers.bitpanda.com/exchange/#market-ticker-channel
 * @description watches price tickers, a statistical calculation with the information for all markets or those specified.
 * @param {string} symbols unified symbols of the markets to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an array of [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *OnetradingCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1788)
            symbols = this.MarketSymbols(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = []interface{}{}
            }
            var subscriptionHash interface{} = "MARKET_TICKER"
            var messageHash interface{} = "tickers"
            var request interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "channels": []interface{}{map[string]interface{} {
            "name": "MARKET_TICKER",
            "price_points_mode": "INLINE",
        }},
            }
        
            tickers:= (<-this.WatchMany(messageHash, request, subscriptionHash, symbols, params))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "ticker_updates": [{
    //             "instrument": "ETH_BTC",
    //             "last_price": "0.053752",
    //             "price_change": "0.000623",
    //             "price_change_percentage": "1.17",
    //             "high": "0.055",
    //             "low": "0.052662",
    //             "volume": "6.3821593247"
    //         }],
    //         "channel_name": "MARKET_TICKER",
    //         "type": "MARKET_TICKER_UPDATES",
    //         "time": "2022-06-23T16:41:00.004162Z"
    //     }
    //
    var tickers interface{} = this.SafeValue(message, "ticker_updates", []interface{}{})
    var datetime interface{} = this.SafeString(message, "time")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(tickers)); i++ {
        var ticker interface{} = ccxt.GetValue(tickers, i)
        var marketId interface{} = this.SafeString(ticker, "instrument")
        var symbol interface{} = this.SafeSymbol(marketId)
        ccxt.AddElementToObject(this.Tickers, symbol, this.ParseWSTicker(ticker))
        var timestamp interface{} = this.Parse8601(datetime)
        ccxt.AddElementToObject(ccxt.GetValue(this.Tickers, symbol), "timestamp", timestamp)
        ccxt.AddElementToObject(ccxt.GetValue(this.Tickers, symbol), "datetime", this.Iso8601(timestamp))
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), ccxt.Add("ticker.", symbol))
    }
    client.(ccxt.ClientInterface).Resolve(this.Tickers, "tickers")
}
func  (this *OnetradingCore) ParseWSTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument": "ETH_BTC",
    //         "last_price": "0.053752",
    //         "price_change": "-0.000623",
    //         "price_change_percentage": "-1.17",
    //         "high": "0.055",
    //         "low": "0.052662",
    //         "volume": "6.3821593247"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instrument")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": this.SafeString(ticker, "last_price"),
        "last": this.SafeString(ticker, "last_price"),
        "previousClose": nil,
        "change": this.SafeString(ticker, "price_change"),
        "percentage": this.SafeString(ticker, "price_change_percentage"),
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeNumber(ticker, "volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name onetrading#watchMyTrades
 * @see https://developers.bitpanda.com/exchange/#account-history-channel
 * @description get the list of trades associated with the user
 * @param {string} symbol unified symbol of the market to fetch trades for. Use 'any' to watch all trades
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *OnetradingCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2798)
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            retRes2868 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes2868)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribeHash interface{} = "ACCOUNT_HISTORY"
            var bpRemainingQuota interface{} = this.SafeInteger(this.Options, "bp_remaining_quota", 200)
            var subscribe interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "bp_remaining_quota": bpRemainingQuota,
                "channels": []interface{}{map[string]interface{} {
            "name": "ACCOUNT_HISTORY",
        }},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            trades:= (<-this.Watch(url, messageHash, request, subscribeHash, request))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
            trades = this.FilterBySymbolSinceLimit(trades, symbol, since, limit)
            var numTrades interface{} =     ccxt.GetArrayLength(trades)
            if ccxt.IsTrue(ccxt.IsEqual(numTrades, 0)) {
        
                    retRes30719 :=  (<-this.WatchMyTrades(symbol, since, limit, params))
                    ccxt.PanicOnError(retRes30719)
                    ch <- retRes30719
                    return nil
            }
        
            ch <- trades
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#watchOrderBook
 * @see https://developers.bitpanda.com/exchange/#market-ticker-channel
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *OnetradingCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3238 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3238)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("book:", symbol)
            var subscriptionHash interface{} = "ORDER_BOOK"
            var depth interface{} = 0
            if ccxt.IsTrue(!ccxt.IsEqual(limit, nil)) {
                depth = limit
            }
            var request interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "channels": []interface{}{map[string]interface{} {
            "name": "ORDER_BOOK",
            "depth": depth,
        }},
            }
        
            orderbook:= (<-this.WatchMany(messageHash, request, subscriptionHash, []interface{}{symbol}, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //  snapshot
    //     {
    //         "instrument_code": "ETH_BTC",
    //         "bids": [
    //             ['0.053595', "4.5352"],
    //             ...
    //         ],
    //         "asks": [
    //             ['0.055455', "0.2821"],
    //             ...
    //         ],
    //         "channel_name": "ORDER_BOOK",
    //         "type": "ORDER_BOOK_SNAPSHOT",
    //         "time": "2022-06-23T15:38:02.196282Z"
    //     }
    //
    //  update
    //     {
    //         "instrument_code": "ETH_BTC",
    //         "changes": [
    //             ["BUY", '0.053593', "8.0587"]
    //         ],
    //         "channel_name": "ORDER_BOOK",
    //         "type": "ORDER_BOOK_UPDATE",
    //         "time": "2022-06-23T15:38:02.751301Z"
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var marketId interface{} = this.SafeString(message, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId)
    var dateTime interface{} = this.SafeString(message, "time")
    var timestamp interface{} = this.Parse8601(dateTime)
    var channel interface{} = ccxt.Add("book:", symbol)
    var orderbook interface{} = this.SafeValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(orderbook, nil)) {
        orderbook = this.OrderBook(map[string]interface{} {})
    }
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "ORDER_BOOK_SNAPSHOT")) {
        var snapshot interface{} = this.ParseOrderBook(message, symbol, timestamp, "bids", "asks")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "ORDER_BOOK_UPDATE")) {
        var changes interface{} = this.SafeValue(message, "changes", []interface{}{})
        this.HandleDeltas(orderbook, changes)
    } else {
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " watchOrderBook() did not recognize message type "), typeVar)))
    }
    ccxt.AddElementToObject(orderbook, "nonce", timestamp)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, channel)
}
func  (this *OnetradingCore) HandleDelta(orderbook interface{}, delta interface{})  {
    //
    //   [ 'BUY', "0.053595", "0" ]
    //
    var bidAsk interface{} = this.ParseBidAsk(delta, 1, 2)
    var typeVar interface{} = this.SafeString(delta, 0)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "BUY")) {
        var bids interface{} = ccxt.GetValue(orderbook, "bids")
        bids.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "SELL")) {
        var asks interface{} = ccxt.GetValue(orderbook, "asks")
        asks.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    } else {
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " watchOrderBook () received unknown change type "), this.Json(delta))))
    }
}
func  (this *OnetradingCore) HandleDeltas(orderbook interface{}, deltas interface{})  {
    //
    //    [
    //       [ 'BUY', "0.053593", "0" ],
    //       [ 'SELL', "0.053698", "0" ]
    //    ]
    //
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(orderbook, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name onetrading#watchOrders
 * @see https://developers.bitpanda.com/exchange/#account-history-channel
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] can listen to orders using ACCOUNT_HISTORY or TRADING
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *OnetradingCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4428)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
        
            retRes4498 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes4498)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribeHash interface{} = this.SafeString(params, "channel", "ACCOUNT_HISTORY")
            var bpRemainingQuota interface{} = this.SafeInteger(this.Options, "bp_remaining_quota", 200)
            var subscribe interface{} = map[string]interface{} {
                "type": "SUBSCRIBE",
                "bp_remaining_quota": bpRemainingQuota,
                "channels": []interface{}{map[string]interface{} {
            "name": subscribeHash,
        }},
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
            orders:= (<-this.Watch(url, messageHash, request, subscribeHash, request))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
            orders = this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            var numOrders interface{} =     ccxt.GetArrayLength(orders)
            if ccxt.IsTrue(ccxt.IsEqual(numOrders, 0)) {
        
                    retRes47019 :=  (<-this.WatchOrders(symbol, since, limit, params))
                    ccxt.PanicOnError(retRes47019)
                    ch <- retRes47019
                    return nil
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) HandleTrading(client interface{}, message interface{})  {
    //
    //     {
    //         "order_book_sequence": 892925263,
    //         "side": "BUY",
    //         "amount": "0.00046",
    //         "trade_id": "d67b9b69-ab76-480f-9ba3-b33582202836",
    //         "matched_as": "TAKER",
    //         "matched_amount": "0.00046",
    //         "matched_price": "22231.08",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "7b39f316-0a71-4bfd-adda-3062e6f0bd37",
    //         "remaining": "0.0",
    //         "channel_name": "TRADING",
    //         "type": "FILL",
    //         "time": "2022-07-21T12:41:22.883341Z"
    //     }
    //
    //     {
    //         "status": "CANCELLED",
    //         "order_book_sequence": 892928424,
    //         "amount": "0.0003",
    //         "side": "SELL",
    //         "price": "50338.65",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "b3994a08-a9e8-4a79-a08b-33e3480382df",
    //         "remaining": "0.0003",
    //         "channel_name": "TRADING",
    //         "type": "DONE",
    //         "time": "2022-07-21T12:44:24.267000Z"
    //     }
    //
    //     {
    //         "order_book_sequence": 892934476,
    //         "side": "SELL",
    //         "amount": "0.00051",
    //         "price": "22349.02",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "1c6c585c-ec3d-4b94-9292-6c3d04a31dc8",
    //         "remaining": "0.00051",
    //         "channel_name": "TRADING",
    //         "type": "BOOKED",
    //         "time": "2022-07-21T12:50:10.093000Z"
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var order interface{} = this.ParseTradingOrder(message)
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(order)
    client.(ccxt.ClientInterface).Resolve(this.Orders, ccxt.Add("orders:", ccxt.GetValue(order, "symbol")))
    client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
}
func  (this *OnetradingCore) ParseTradingOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "order_book_sequence": 892925263,
    //         "side": "BUY",
    //         "amount": "0.00046",
    //         "trade_id": "d67b9b69-ab76-480f-9ba3-b33582202836",
    //         "matched_as": "TAKER",
    //         "matched_amount": "0.00046",
    //         "matched_price": "22231.08",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "7b39f316-0a71-4bfd-adda-3062e6f0bd37",
    //         "remaining": "0.0",
    //         "channel_name": "TRADING",
    //         "type": "FILL",
    //         "time": "2022-07-21T12:41:22.883341Z"
    //     }
    //
    //     {
    //         "status": "CANCELLED",
    //         "order_book_sequence": 892928424,
    //         "amount": "0.0003",
    //         "side": "SELL",
    //         "price": "50338.65",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "b3994a08-a9e8-4a79-a08b-33e3480382df",
    //         "remaining": "0.0003",
    //         "channel_name": "TRADING",
    //         "type": "DONE",
    //         "time": "2022-07-21T12:44:24.267000Z"
    //     }
    //
    //     {
    //         "order_book_sequence": 892934476,
    //         "side": "SELL",
    //         "amount": "0.00051",
    //         "price": "22349.02",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "1c6c585c-ec3d-4b94-9292-6c3d04a31dc8",
    //         "remaining": "0.00051",
    //         "channel_name": "TRADING",
    //         "type": "BOOKED",
    //         "time": "2022-07-21T12:50:10.093000Z"
    //     }
    //
    //     {
    //         "type":"UPDATE",
    //         "channel_name": "TRADING",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "1e842f13-762a-4745-9f3b-07f1b43e7058",
    //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
    //         "time": "2020-01-11T01:01:01.999Z",
    //         "remaining": "1.23456",
    //         "order_book_sequence": 42,
    //         "status": "APPLIED",
    //         "amount": "1.35756",
    //         "amount_delta": "0.123",
    //         "modification_id": "cc0eed67-aecc-4fb4-a625-ff3890ceb4cc"
    //     }
    //  tracked
    //     {
    //         "type": "STOP_TRACKED",
    //         "channel_name": "TRADING",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "1e842f13-762a-4745-9f3b-07f1b43e7058",
    //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
    //         "time": "2020-01-11T01:01:01.999Z",
    //         "remaining": "1.23456",
    //         "order_book_sequence": 42,
    //         "trigger_price": "12345.67",
    //         "current_price": "11111.11"
    //     }
    //
    //     {
    //         "type": "STOP_TRIGGERED",
    //         "channel_name": "TRADING",
    //         "instrument_code": "BTC_EUR",
    //         "order_id": "1e842f13-762a-4745-9f3b-07f1b43e7058",
    //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
    //         "time": "2020-01-11T01:01:01.999Z",
    //         "remaining": "1.23456",
    //         "order_book_sequence": 42,
    //         "price": "13333.33"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(order, "time")
    var marketId interface{} = this.SafeString(order, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(order, "client_id"),
        "info": order,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": nil,
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeStringLower(order, "side"),
        "price": this.SafeNumber2(order, "price", "matched_price"),
        "stopPrice": this.SafeNumber(order, "trigger_price"),
        "amount": this.SafeNumber(order, "amount"),
        "cost": nil,
        "average": nil,
        "filled": nil,
        "remaining": this.SafeString(order, "remaining"),
        "status": this.ParseTradingOrderStatus(this.SafeString(order, "status")),
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *OnetradingCore) ParseTradingOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "CANCELLED": "canceled",
        "SELF_TRADE": "rejected",
        "FILLED_FULLY": "closed",
        "INSUFFICIENT_FUNDS": "rejected",
        "INSUFFICIENT_LIQUIDITY": "rejected",
        "TIME_TO_MARKET_EXCEEDED": "rejected",
        "LAST_PRICE_UNKNOWN": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *OnetradingCore) HandleOrders(client interface{}, message interface{})  {
    //
    //  snapshot
    //     {
    //         "account_id": "4920221a-48dc-423e-b336-bb65baccc7bd",
    //         "orders": [{
    //             "order": {
    //                 "order_id": "30e2de8f-9a34-472f-bcf8-3af4b7757626",
    //                 "account_holder": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "instrument_code": "BTC_EUR",
    //                 "time": "2022-06-28T06:10:02.587345Z",
    //                 "side": "SELL",
    //                 "price": "19645.48",
    //                 "amount": "0.00052",
    //                 "filled_amount": "0.00052",
    //                 "type": "MARKET",
    //                 "sequence": 7633339971,
    //                 "status": "FILLED_FULLY",
    //                 "average_price": "19645.48",
    //                 "is_post_only": false,
    //                 "order_book_sequence": 866885897,
    //                 "time_last_updated": "2022-06-28T06:10:02.766983Z",
    //                 "update_modification_sequence": 866885897
    //             },
    //             "trades": [{
    //                 "fee": {
    //                     "fee_amount": "0.01532347",
    //                     "fee_currency": "EUR",
    //                     "fee_percentage": "0.15",
    //                     "fee_group_id": "default",
    //                     "fee_type": "TAKER",
    //                     "running_trading_volume": "0.0",
    //                     "collection_type": "STANDARD"
    //                 },
    //                 "trade": {
    //                     "trade_id": "d83e302e-0b3a-4269-aa7d-ecf007cbe577",
    //                     "order_id": "30e2de8f-9a34-472f-bcf8-3af4b7757626",
    //                     "account_holder": "49203c1a-48dc-423e-b336-bb65baccc7bd",
    //                     "account_id": "4920221a-48dc-423e-b336-bb65baccc7bd",
    //                     "amount": "0.00052",
    //                     "side": "SELL",
    //                     "instrument_code": "BTC_EUR",
    //                     "price": "19645.48",
    //                     "time": "2022-06-28T06:10:02.693246Z",
    //                     "price_tick_sequence": 0,
    //                     "sequence": 7633339971
    //                 }
    //             }]
    //         }],
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "type": "INACTIVE_ORDERS_SNAPSHOT",
    //         "time": "2022-06-28T06:11:52.469242Z"
    //     }
    //
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var rawOrders interface{} = this.SafeValue(message, "orders", []interface{}{})
    var rawOrdersLength interface{} =     ccxt.GetArrayLength(rawOrders)
    if ccxt.IsTrue(ccxt.IsEqual(rawOrdersLength, 0)) {
        return
    }
    var orders interface{} = this.Orders
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var order interface{} = this.ParseOrder(ccxt.GetValue(rawOrders, i))
        var symbol interface{} = this.SafeString(order, "symbol", "")
        orders.(ccxt.Appender).Append(order)
        client.(ccxt.ClientInterface).Resolve(this.Orders, ccxt.Add("orders:", symbol))
        var rawTrades interface{} = this.SafeValue(ccxt.GetValue(rawOrders, i), "trades", []interface{}{})
        for ii := 0; ccxt.IsLessThan(ii, ccxt.GetArrayLength(rawTrades)); ii++ {
            var trade interface{} = this.ParseTrade(ccxt.GetValue(rawTrades, ii))
            symbol = this.SafeString(trade, "symbol", symbol)
            this.MyTrades.(ccxt.Appender).Append(trade)
            client.(ccxt.ClientInterface).Resolve(this.MyTrades, ccxt.Add("myTrades:", symbol))
        }
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, "myTrades")
}
func  (this *OnetradingCore) HandleAccountUpdate(client interface{}, message interface{})  {
    //
    // order created
    //     {
    //         "account_id": "49302c1a-48dc-423e-b336-bb65baccc7bd",
    //         "sequence": 7658332018,
    //         "update": {
    //             "type": "ORDER_CREATED",
    //             "activity": "TRADING",
    //             "account_holder": "43202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "order_id": "8893fd69-5ebd-496b-aaa4-269b4c18aa77",
    //             "time": "2022-06-29T04:33:29.661257Z",
    //             "order": {
    //                 "time_in_force": "GOOD_TILL_CANCELLED",
    //                 "is_post_only": false,
    //                 "order_id": "8892fd69-5ebd-496b-aaa4-269b4c18aa77",
    //                 "account_holder": "43202c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "account_id": "49302c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "instrument_code": "BTC_EUR",
    //                 "time": "2022-06-29T04:33:29.656896Z",
    //                 "side": "SELL",
    //                 "price": "50338.65",
    //                 "amount": "0.00021",
    //                 "filled_amount": "0.0",
    //                 "type": "LIMIT"
    //             },
    //             "locked": {
    //                 "currency_code": "BTC",
    //                 "amount": "0.00021",
    //                 "new_available": "0.00017",
    //                 "new_locked": "0.00021"
    //             },
    //             "id": "26e9c36a-b231-4bb0-a686-aa915a2fc9e6",
    //             "sequence": 7658332018
    //         },
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "type": "ACCOUNT_UPDATE",
    //         "time": "2022-06-29T04:33:29.684517Z"
    //     }
    //
    //  order rejected
    //     {
    //         "account_id": "49302c1a-48dc-423e-b336-bb65baccc7bd",
    //         "sequence": 7658332018,
    //         "update": {
    //             "id": "d3fe6025-5b27-4df6-a957-98b8d131cb9d",
    //             "type": "ORDER_REJECTED",
    //             "activity": "TRADING",
    //             "account_id": "b355abb8-aaae-4fae-903c-c60ff74723c6",
    //             "sequence": 0,
    //             "timestamp": "2018-08-01T13:39:15.590Z",
    //             "reason": "INSUFFICIENT_FUNDS",
    //             "order_id": "6f991342-da2c-45c6-8830-8bf519cfc8cc",
    //             "client_id": "fb497387-8223-4111-87dc-66a86f98a7cf",
    //             "unlocked": {
    //                 "currency_code": "BTC",
    //                 "amount": "1.5",
    //                 "new_locked": "2.0",
    //                 "new_available": "1.5"
    //             }
    //         }
    //     }
    //
    //  order closed
    //     {
    //         "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //         "sequence": 7658471216,
    //         "update": {
    //             "type": "ORDER_CLOSED",
    //             "activity": "TRADING",
    //             "account_holder": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "time": "2022-06-29T04:43:57.169616Z",
    //             "order_id": "8892fd69-5ebd-496b-aaa4-269b4c18aa77",
    //             "unlocked": {
    //                 "currency_code": "BTC",
    //                 "amount": "0.00021",
    //                 "new_available": "0.00038",
    //                 "new_locked": "0.0"
    //             },
    //             "order_book_sequence": 867964191,
    //             "id": "26c5e1d7-65ba-4a11-a661-14c0130ff484",
    //             "sequence": 7658471216
    //         },
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "type": "ACCOUNT_UPDATE",
    //         "time": "2022-06-29T04:43:57.182153Z"
    //     }
    //
    //  trade settled
    //     {
    //         "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //         "sequence": 7658502878,
    //         "update": {
    //             "type": "TRADE_SETTLED",
    //             "activity": "TRADING",
    //             "account_holder": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //             "time": "2022-06-29T04:46:12.933091Z",
    //             "order_id": "ad19951a-b616-401d-a062-8d0609f038a4",
    //             "order_book_sequence": 867965579,
    //             "filled_amount": "0.00052",
    //             "order": {
    //                 "amount": "0.00052",
    //                 "filled_amount": "0.00052"
    //             },
    //             "trade": {
    //                 "trade_id": "21039eb9-2df0-4227-be2d-0ea9b691ac66",
    //                 "order_id": "ad19951a-b616-401d-a062-8d0609f038a4",
    //                 "account_holder": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "account_id": "49202c1a-48dc-423e-b336-bb65baccc7bd",
    //                 "amount": "0.00052",
    //                 "side": "BUY",
    //                 "instrument_code": "BTC_EUR",
    //                 "price": "19309.29",
    //                 "time": "2022-06-29T04:46:12.870581Z",
    //                 "price_tick_sequence": 0
    //             },
    //             "fee": {
    //                 "fee_amount": "0.00000078",
    //                 "fee_currency": "BTC",
    //                 "fee_percentage": "0.15",
    //                 "fee_group_id": "default",
    //                 "fee_type": "TAKER",
    //                 "running_trading_volume": "0.00052",
    //                 "collection_type": "STANDARD"
    //             },
    //             "spent": {
    //                 "currency_code": "EUR",
    //                 "amount": "10.0408308",
    //                 "new_available": "0.0",
    //                 "new_locked": "0.15949533"
    //             },
    //             "credited": {
    //                 "currency_code": "BTC",
    //                 "amount": "0.00051922",
    //                 "new_available": "0.00089922",
    //                 "new_locked": "0.0"
    //             },
    //             "unlocked": {
    //                 "currency_code": "EUR",
    //                 "amount": "0.0",
    //                 "new_available": "0.0",
    //                 "new_locked": "0.15949533"
    //             },
    //             "id": "22b40199-2508-4176-8a14-d4785c933444",
    //             "sequence": 7658502878
    //         },
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "type": "ACCOUNT_UPDATE",
    //         "time": "2022-06-29T04:46:12.941837Z"
    //     }
    //
    //  ccxt.Trade Settled with BEST fee collection enabled
    //     {
    //         "account_id": "49302c1a-48dc-423e-b336-bb65baccc7bd",
    //         "sequence": 7658951984,
    //         "update": {
    //             "id": "70e00504-d892-456f-9aae-4da7acb36aac",
    //             "sequence": 361792,
    //             "order_book_sequence": 123456,
    //             "type": "TRADE_SETTLED",
    //             "activity": "TRADING",
    //             "account_id": "379a12c0-4560-11e9-82fe-2b25c6f7d123",
    //             "time": "2019-10-22T12:09:55.731Z",
    //             "order_id": "9fcdd91c-7f6e-45f4-9956-61cddba55de5",
    //             "client_id": "fb497387-8223-4111-87dc-66a86f98a7cf",
    //             "order": {
    //                 "amount": "0.5",
    //                 "filled_amount": "0.5"
    //             },
    //             "trade": {
    //                 "trade_id": "a828b63e-b2cb-48f0-8d99-8fc22cf98e08",
    //                 "order_id": "9fcdd91c-7f6e-45f4-9956-61cddba55de5",
    //                 "account_id": "379a12c0-4560-11e9-82fe-2b25c6f7d123",
    //                 "amount": "0.5",
    //                 "side": "BUY",
    //                 "instrument_code": "BTC_EUR",
    //                 "price": "7451.6",
    //                 "time": "2019-10-22T12:09:55.667Z"
    //             },
    //             "fee": {
    //                 "fee_amount": "23.28625",
    //                 "fee_currency": "BEST",
    //                 "fee_percentage": "0.075",
    //                 "fee_group_id": "default",
    //                 "fee_type": "TAKER",
    //                 "running_trading_volume": "0.10058",
    //                 "collection_type": "BEST",
    //                 "applied_best_eur_rate": "1.04402"
    //             },
    //             "spent": {
    //                 "currency_code": "EUR",
    //                 "amount": "3725.8",
    //                 "new_available": "14517885.0675703028781",
    //                 "new_locked": "2354.882"
    //             },
    //             "spent_on_fees": {
    //                 "currency_code": "BEST",
    //                 "amount": "23.28625",
    //                 "new_available": "9157.31375",
    //                 "new_locked": "0.0"
    //             },
    //             "credited": {
    //                 "currency_code": "BTC",
    //                 "amount": "0.5",
    //                 "new_available": "5839.89633700481",
    //                 "new_locked": "0.0"
    //             },
    //             "unlocked": {
    //                 "currency_code": "EUR",
    //                 "amount": "0.15",
    //                 "new_available": "14517885.0675703028781",
    //                 "new_locked": "2354.882"
    //             }
    //         }
    //         "channel_name": "ACCOUNT_HISTORY",
    //         "type": "ACCOUNT_UPDATE",
    //         "time": "2022-06-29T05:18:51.760338Z"
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var symbol interface{} = nil
    var orders interface{} = this.Orders
    var update interface{} = this.SafeValue(message, "update", map[string]interface{} {})
    var updateType interface{} = this.SafeString(update, "type")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(updateType, "ORDER_REJECTED")) || ccxt.IsTrue(ccxt.IsEqual(updateType, "ORDER_CLOSED"))) || ccxt.IsTrue(ccxt.IsEqual(updateType, "STOP_ORDER_TRIGGERED"))) {
        var orderId interface{} = this.SafeString(update, "order_id")
        var datetime interface{} = this.SafeString2(update, "time", "timestamp")
        var previousOrderArray interface{} = this.FilterByArray(this.Orders, "id", orderId, false)
        var previousOrder interface{} = this.SafeValue(previousOrderArray, 0, map[string]interface{} {})
        symbol = ccxt.GetValue(previousOrder, "symbol")
        var filled interface{} = this.SafeString(update, "filled_amount")
        var status interface{} = this.ParseWsOrderStatus(updateType)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(updateType, "ORDER_CLOSED")) && ccxt.IsTrue(ccxt.Precise.StringEq(filled, "0"))) {
            status = "canceled"
        }
        var orderObject interface{} = map[string]interface{} {
            "id": orderId,
            "symbol": symbol,
            "status": status,
            "timestamp": this.Parse8601(datetime),
            "datetime": datetime,
        }
        orders.(ccxt.Appender).Append(orderObject)
    } else {
        var parsed interface{} = this.ParseOrder(update)
        symbol = this.SafeString(parsed, "symbol", "")
        orders.(ccxt.Appender).Append(parsed)
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, ccxt.Add("orders:", symbol))
    client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
    // update balance
    var balanceKeys interface{} = []interface{}{"locked", "unlocked", "spent", "spent_on_fees", "credited", "deducted"}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balanceKeys)); i++ {
        var newBalance interface{} = this.SafeValue(update, ccxt.GetValue(balanceKeys, i))
        if ccxt.IsTrue(!ccxt.IsEqual(newBalance, nil)) {
            this.UpdateBalance(newBalance)
        }
    }
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
    // update trades
    if ccxt.IsTrue(ccxt.IsEqual(updateType, "TRADE_SETTLED")) {
        var parsed interface{} = this.ParseTrade(update)
        symbol = this.SafeString(parsed, "symbol", "")
        var myTrades interface{} = this.MyTrades
        myTrades.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, ccxt.Add("myTrades:", symbol))
        client.(ccxt.ClientInterface).Resolve(this.MyTrades, "myTrades")
    }
}
func  (this *OnetradingCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ORDER_REJECTED": "rejected",
        "ORDER_CLOSED": "closed",
        "STOP_ORDER_TRIGGERED": "triggered",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *OnetradingCore) UpdateBalance(balance interface{})  {
    //
    //     {
    //         "currency_code": "EUR",
    //         "amount": "0.0",
    //         "new_available": "0.0",
    //         "new_locked": "0.15949533"
    //     }
    //
    var currencyId interface{} = this.SafeString(balance, "currency_code")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(balance, "new_available"))
    ccxt.AddElementToObject(account, "used", this.SafeString(balance, "new_locked"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
}
/**
 * @method
 * @name onetrading#watchOHLCV
 * @see https://developers.bitpanda.com/exchange/#candlesticks-channel
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *OnetradingCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10648 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10648)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var marketId interface{} = ccxt.GetValue(market, "id")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var timeframeId interface{} = this.SafeValue(timeframes, timeframe)
            if ccxt.IsTrue(ccxt.IsEqual(timeframeId, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " this interval is not supported, please provide one of the supported timeframes")))
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv.", symbol), "."), timeframe)
            var subscriptionHash interface{} = "CANDLESTICKS"
            var client interface{} = this.SafeValue(this.Clients, url)
            var typeVar interface{} = "SUBSCRIBE"
            var subscription interface{} = map[string]interface{} {}
            if ccxt.IsTrue(!ccxt.IsEqual(client, nil)) {
                subscription = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
                if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                    var ohlcvMarket interface{} = this.SafeValue(subscription, marketId, map[string]interface{} {})
                    var marketSubscribed interface{} = this.SafeBool(ohlcvMarket, timeframe, false)
                    if !ccxt.IsTrue(marketSubscribed) {
                        typeVar = "UPDATE_SUBSCRIPTION"
                        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash, nil)
                    }
                } else {
                    subscription = map[string]interface{} {}
                }
            }
            var subscriptionMarketId interface{} = this.SafeValue(subscription, marketId)
            if ccxt.IsTrue(ccxt.IsEqual(subscriptionMarketId, nil)) {
                ccxt.AddElementToObject(subscription, marketId, map[string]interface{} {})
            }
            ccxt.AddElementToObject(ccxt.GetValue(subscription, marketId), timeframe, true)
            var properties interface{} = []interface{}{}
            var marketIds interface{} = ccxt.ObjectKeys(subscription)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketIdtimeframes interface{} = ccxt.ObjectKeys(ccxt.GetValue(subscription, ccxt.GetValue(marketIds, i)))
                for ii := 0; ccxt.IsLessThan(ii, ccxt.GetArrayLength(marketIdtimeframes)); ii++ {
                    var marketTimeframeId interface{} = this.SafeValue(timeframes, timeframe)
                    var property interface{} = map[string]interface{} {
                        "instrument_code": ccxt.GetValue(marketIds, i),
                        "time_granularity": marketTimeframeId,
                    }
                    ccxt.AppendToArray(&properties, property)
                }
            }
            var request interface{} = map[string]interface{} {
                "type": typeVar,
                "channels": []interface{}{map[string]interface{} {
            "name": "CANDLESTICKS",
            "properties": properties,
        }},
            }
        
            ohlcv:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), subscriptionHash, subscription))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //  snapshot
    //     {
    //         "instrument_code": "BTC_EUR",
    //         "granularity": { unit: "MONTHS", period: 1 },
    //         "high": "29750.81",
    //         "low": "16764.59",
    //         "open": "29556.02",
    //         "close": "20164.55",
    //         "volume": "107518944.610659",
    //         "last_sequence": 2275507,
    //         "channel_name": "CANDLESTICKS",
    //         "type": "CANDLESTICK_SNAPSHOT",
    //         "time": "2022-06-30T23:59:59.999000Z"
    //     }
    //
    //  update
    //     {
    //         "instrument_code": "BTC_EUR",
    //         "granularity": {
    //             "unit": "MINUTES",
    //             "period": 1
    //         },
    //         "high": "20164.16",
    //         "low": "20164.16",
    //         "open": "20164.16",
    //         "close": "20164.16",
    //         "volume": "3645.2768448",
    //         "last_sequence": 2275511,
    //         "channel_name": "CANDLESTICKS",
    //         "type": "CANDLESTICK",
    //         "time": "2022-06-24T21:20:59.999000Z"
    //     }
    //
    var marketId interface{} = this.SafeString(message, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId)
    var dateTime interface{} = this.SafeString(message, "time")
    var timeframeId interface{} = this.SafeValue(message, "granularity")
    var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
    var timeframe interface{} = this.FindTimeframe(timeframeId, timeframes)
    var channel interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv.", symbol), "."), timeframe)
    var parsed interface{} = []interface{}{this.Parse8601(dateTime), this.SafeNumber(message, "open"), this.SafeNumber(message, "high"), this.SafeNumber(message, "low"), this.SafeNumber(message, "close"), this.SafeNumber(message, "volume")}
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
    }
    stored.(ccxt.Appender).Append(parsed)
    ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    client.(ccxt.ClientInterface).Resolve(stored, channel)
}
func  (this *OnetradingCore) FindTimeframe(timeframe interface{}, optionalArgs ...interface{}) interface{}  {
    timeframes := ccxt.GetArg(optionalArgs, 0, nil)
    _ = timeframes
    timeframes = ccxt.IsTrue(timeframes) || ccxt.IsTrue(this.Timeframes)
    var keys interface{} = ccxt.ObjectKeys(timeframes)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(timeframes, key), "unit"), ccxt.GetValue(timeframe, "unit"))) && ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(timeframes, key), "period"), ccxt.GetValue(timeframe, "period")))) {
            return key
        }
    }
    return nil
}
func  (this *OnetradingCore) HandleSubscriptions(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "channels": [{
    //             "instrument_codes": [Array],
    //             "depth": 0,
    //             "name": "ORDER_BOOK"
    //         }],
    //         "type": "SUBSCRIPTIONS",
    //         "time": "2022-06-23T15:36:26.948282Z"
    //     }
    //
    return message
}
func  (this *OnetradingCore) HandleHeartbeat(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "subscription": "SYSTEM",
    //         "channel_name": "SYSTEM",
    //         "type": "HEARTBEAT",
    //         "time": "2022-06-23T16:31:49.170224Z"
    //     }
    //
    return message
}
func  (this *OnetradingCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))))
}
func  (this *OnetradingCore) HandleMessage(client interface{}, message interface{})  {
    var error interface{} = this.SafeValue(message, "error")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        this.HandleErrorMessage(client, message)
        return
    }
    var typeVar interface{} = this.SafeValue(message, "type")
    var handlers interface{} = map[string]interface{} {
        "ORDER_BOOK_UPDATE": this.HandleOrderBook,
        "ORDER_BOOK_SNAPSHOT": this.HandleOrderBook,
        "ACTIVE_ORDERS_SNAPSHOT": this.HandleOrders,
        "INACTIVE_ORDERS_SNAPSHOT": this.HandleOrders,
        "ACCOUNT_UPDATE": this.HandleAccountUpdate,
        "BALANCES_SNAPSHOT": this.HandleBalanceSnapshot,
        "SUBSCRIPTIONS": this.HandleSubscriptions,
        "SUBSCRIPTION_UPDATED": this.HandleSubscriptions,
        "PRICE_TICK": this.HandleTicker,
        "PRICE_TICK_HISTORY": this.HandleSubscriptions,
        "HEARTBEAT": this.HandleHeartbeat,
        "MARKET_TICKER_UPDATES": this.HandleTicker,
        "PRICE_POINT_UPDATES": this.HandlePricePointUpdates,
        "CANDLESTICK_SNAPSHOT": this.HandleOHLCV,
        "CANDLESTICK": this.HandleOHLCV,
        "AUTHENTICATED": this.HandleAuthenticationMessage,
        "FILL": this.HandleTrading,
        "DONE": this.HandleTrading,
        "BOOKED": this.HandleTrading,
        "UPDATE": this.HandleTrading,
        "TRACKED": this.HandleTrading,
        "TRIGGERED": this.HandleTrading,
        "STOP_TRACKED": this.HandleTrading,
        "STOP_TRIGGERED": this.HandleTrading,
    }
    var handler interface{} = this.SafeValue(handlers, typeVar)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
    }
}
func  (this *OnetradingCore) HandlePricePointUpdates(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "channel_name": "MARKET_TICKER",
    //         "type": "PRICE_POINT_UPDATES",
    //         "time": "2019-03-01T10:59:59.999Z",
    //         "price_updates": [{
    //                 "instrument": "BTC_EUR",
    //                 "prices": [{
    //                         "time": "2019-03-01T08:59:59.999Z",
    //                         "close_price": "3580.6"
    //                     },
    //                     ...
    //                 ]
    //             },
    //             ...
    //         ]
    //     }
    //
    return message
}
func  (this *OnetradingCore) HandleAuthenticationMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "channel_name": "SYSTEM",
    //        "type": "AUTHENTICATED",
    //        "time": "2022-06-24T20:45:25.447488Z"
    //    }
    //
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
        future.(*ccxt.Future).Resolve(true)
    }
    return message
}
func  (this *OnetradingCore) WatchMany(messageHash interface{}, request interface{}, subscriptionHash interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, []interface{}{})
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var marketIds interface{} = []interface{}{}
            var numSymbols interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(numSymbols, 0)) {
                marketIds = ccxt.ObjectKeys(this.Markets_by_id)
            } else {
                marketIds = this.MarketIds(symbols)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.SafeValue(this.Clients, url)
            var typeVar interface{} = "SUBSCRIBE"
            var subscription interface{} = map[string]interface{} {}
            if ccxt.IsTrue(!ccxt.IsEqual(client, nil)) {
                subscription = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash)
                if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                        var marketId interface{} = ccxt.GetValue(marketIds, i)
                        var marketSubscribed interface{} = this.SafeBool(subscription, marketId, false)
                        if !ccxt.IsTrue(marketSubscribed) {
                            typeVar = "UPDATE_SUBSCRIPTION"
                            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), subscriptionHash, nil)
                        }
                    }
                } else {
                    subscription = map[string]interface{} {}
                }
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                ccxt.AddElementToObject(subscription, marketId, true)
            }
            ccxt.AddElementToObject(request, "type", typeVar)
            ccxt.AddElementToObject(ccxt.GetValue(ccxt.GetValue(request, "channels"), 0), "instrument_codes", ccxt.ObjectKeys(subscription))
        
                retRes134715 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), subscriptionHash, subscription))
                ccxt.PanicOnError(retRes134715)
                ch <- retRes134715
                return nil
        
            }()
            return ch
        }
func  (this *OnetradingCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture("authenticated")
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                this.CheckRequiredCredentials()
                var request interface{} = map[string]interface{} {
                    "type": "AUTHENTICATE",
                    "api_token": this.ApiKey,
                }
                this.Watch(url, messageHash, this.Extend(request, params), messageHash)
            }
        
                retRes136415 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes136415)
                ch <- retRes136415
                return nil
        
            }()
            return ch
        }


func (this *OnetradingCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
