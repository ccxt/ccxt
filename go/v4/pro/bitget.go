package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitgetCore struct {
	*ccxt.BitgetCore
	base *ccxt.BitgetCore
}

func NewBitgetCore() *BitgetCore {
    p := &BitgetCore{}
	base := &ccxt.BitgetCore{}
	p.base = base
	p.BitgetCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitgetCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.bitget.com/v2/ws/public",
                    "private": "wss://ws.bitget.com/v2/ws/private",
                    "utaPublic": "wss://ws.bitget.com/v3/ws/public",
                    "utaPrivate": "wss://ws.bitget.com/v3/ws/private",
                },
                "demo": map[string]interface{} {
                    "public": "wss://wspap.bitget.com/v2/ws/public",
                    "private": "wss://wspap.bitget.com/v2/ws/private",
                    "utaPublic": "wss://wspap.bitget.com/v3/ws/public",
                    "utaPrivate": "wss://wspap.bitget.com/v3/ws/private",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "OHLCVLimit": 1000,
            "timeframes": map[string]interface{} {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1H",
                "4h": "4H",
                "6h": "6H",
                "12h": "12H",
                "1d": "1D",
                "1w": "1W",
            },
            "watchOrderBook": map[string]interface{} {
                "checksum": true,
            },
            "watchTrades": map[string]interface{} {
                "ignoreDuplicates": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "30001": ccxt.BadRequest,
                    "30002": ccxt.AuthenticationError,
                    "30003": ccxt.BadRequest,
                    "30004": ccxt.AuthenticationError,
                    "30005": ccxt.AuthenticationError,
                    "30006": ccxt.RateLimitExceeded,
                    "30007": ccxt.RateLimitExceeded,
                    "30011": ccxt.AuthenticationError,
                    "30012": ccxt.AuthenticationError,
                    "30013": ccxt.AuthenticationError,
                    "30014": ccxt.BadRequest,
                    "30015": ccxt.AuthenticationError,
                    "30016": ccxt.BadRequest,
                },
                "broad": map[string]interface{} {},
            },
        },
    })
}
func  (this *BitgetCore) GetInstType(market interface{}, optionalArgs ...interface{}) interface{}  {
    uta := ccxt.GetArg(optionalArgs, 0, false)
    _ = uta
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(uta, nil))) || !ccxt.IsTrue(uta)) {
        utaparamsVariable := this.HandleOptionAndParams(params, "getInstType", "uta", false)
        uta = ccxt.GetValue(utaparamsVariable,0)
        params = ccxt.GetValue(utaparamsVariable,1)
    }
    var instType interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(market, nil)) {
        instTypeparamsVariable := this.HandleProductTypeAndParams(nil, params)
        instType = ccxt.GetValue(instTypeparamsVariable,0)
        params = ccxt.GetValue(instTypeparamsVariable,1)
    } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.GetValue(market, "swap"))) || ccxt.IsTrue((ccxt.GetValue(market, "future")))) {
        instTypeparamsVariable := this.HandleProductTypeAndParams(market, params)
        instType = ccxt.GetValue(instTypeparamsVariable,0)
        params = ccxt.GetValue(instTypeparamsVariable,1)
    } else {
        instType = "SPOT"
    }
    var instypeAux interface{} = nil
    instypeAuxparamsVariable := this.HandleOptionAndParams(params, "getInstType", "instType", instType)
    instypeAux = ccxt.GetValue(instypeAuxparamsVariable,0)
    params = ccxt.GetValue(instypeAuxparamsVariable,1)
    instType = instypeAux
    if ccxt.IsTrue(uta) {
        instType = ccxt.ToLower(instType)
    }
    return []interface{}{instType, params}
}
/**
 * @method
 * @name bitget#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.bitget.com/api-doc/spot/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Tickers-Channel
 * @param {string} symbol unified symbol of the market to watch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitgetCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1448 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1448)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchTicker", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
            var symbolOrInstId interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "symbol", "instId")
            ccxt.AddElementToObject(args, topicOrChannel, "ticker")
            ccxt.AddElementToObject(args, symbolOrInstId, ccxt.GetValue(market, "id"))
        
                retRes15915 :=  (<-this.WatchPublic(messageHash, args, params))
                ccxt.PanicOnError(retRes15915)
                ch <- retRes15915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#unWatchTicker
 * @description unsubscribe from the ticker channel
 * @see https://www.bitget.com/api-doc/spot/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Tickers-Channel
 * @param {string} symbol unified symbol of the market to unwatch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {any} status of the unwatch request
 */
func  (this *BitgetCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1738)
        
                retRes17415 :=  (<-this.UnWatchChannel(symbol, "ticker", "ticker", params))
                ccxt.PanicOnError(retRes17415)
                ch <- retRes17415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://www.bitget.com/api-doc/spot/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Tickers-Channel
 * @param {string[]} symbols unified symbol of the market to watch the tickers for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitgetCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1908)
            symbols = this.MarketSymbols(symbols, nil, false)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketInner interface{} = this.Market(symbol)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                }
                var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
                var symbolOrInstId interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "symbol", "instId")
                ccxt.AddElementToObject(args, topicOrChannel, "ticker")
                ccxt.AddElementToObject(args, symbolOrInstId, ccxt.GetValue(marketInner, "id"))
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
            }
        
            tickers:= (<-this.WatchPublicMultiple(messageHashes, topics, params))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(tickers, "symbol"), tickers)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleTicker(client interface{}, message interface{})  {
    //
    // default
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "SPOT",
    //             "channel": "ticker",
    //             "instId": "BTCUSDT"
    //         },
    //         "data": [
    //             {
    //                 "instId": "BTCUSDT",
    //                 "lastPr": "43528.19",
    //                 "open24h": "42267.78",
    //                 "high24h": "44490.00",
    //                 "low24h": "41401.53",
    //                 "change24h": "0.03879",
    //                 "bidPr": "43528",
    //                 "askPr": "43528.01",
    //                 "bidSz": "0.0334",
    //                 "askSz": "0.1917",
    //                 "baseVolume": "15002.4216",
    //                 "quoteVolume": "648006446.7164",
    //                 "openUtc": "44071.18",
    //                 "changeUtc24h": "-0.01232",
    //                 "ts": "1701842994338"
    //             }
    //         ],
    //         "ts": 1701842994341
    //     }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
    //         "data": [
    //             {
    //                 "highPrice24h": "120255.61",
    //                 "lowPrice24h": "116145.88",
    //                 "openPrice24h": "118919.38",
    //                 "lastPrice": "119818.83",
    //                 "turnover24h": "215859996.272276",
    //                 "volume24h": "1819.756798",
    //                 "bid1Price": "119811.26",
    //                 "ask1Price": "119831.18",
    //                 "bid1Size": "0.008732",
    //                 "ask1Size": "0.004297",
    //                 "price24hPcnt": "0.02002"
    //             }
    //         ],
    //         "ts": 1753230479687
    //     }
    //
    this.HandleBidAsk(client, message)
    var ticker interface{} = this.ParseWsTicker(message)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *BitgetCore) ParseWsTicker(message interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "SPOT",
    //             "channel": "ticker",
    //             "instId": "BTCUSDT"
    //         },
    //         "data": [
    //             {
    //                 "instId": "BTCUSDT",
    //                 "lastPr": "43528.19",
    //                 "open24h": "42267.78",
    //                 "high24h": "44490.00",
    //                 "low24h": "41401.53",
    //                 "change24h": "0.03879",
    //                 "bidPr": "43528",
    //                 "askPr": "43528.01",
    //                 "bidSz": "0.0334",
    //                 "askSz": "0.1917",
    //                 "baseVolume": "15002.4216",
    //                 "quoteVolume": "648006446.7164",
    //                 "openUtc": "44071.18",
    //                 "changeUtc24h": "-0.01232",
    //                 "ts": "1701842994338"
    //             }
    //         ],
    //         "ts": 1701842994341
    //     }
    //
    // contract
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "USDT-FUTURES",
    //             "channel": "ticker",
    //             "instId": "BTCUSDT"
    //         },
    //         "data": [
    //             {
    //                 "instId": "BTCUSDT",
    //                 "lastPr": "43480.4",
    //                 "bidPr": "43476.3",
    //                 "askPr": "43476.8",
    //                 "bidSz": "0.1",
    //                 "askSz": "3.055",
    //                 "open24h": "42252.3",
    //                 "high24h": "44518.2",
    //                 "low24h": "41387.0",
    //                 "change24h": "0.03875",
    //                 "fundingRate": "0.000096",
    //                 "nextFundingTime": "1701849600000",
    //                 "markPrice": "43476.4",
    //                 "indexPrice": "43478.4",
    //                 "holdingAmount": "50670.787",
    //                 "baseVolume": "120187.104",
    //                 "quoteVolume": "5167385048.693",
    //                 "openUtc": "44071.4",
    //                 "symbolType": "1",
    //                 "symbol": "BTCUSDT",
    //                 "deliveryPrice": "0",
    //                 "ts": "1701843962811"
    //             }
    //         ],
    //         "ts": 1701843962812
    //     }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
    //         "data": [
    //             {
    //                 "highPrice24h": "120255.61",
    //                 "lowPrice24h": "116145.88",
    //                 "openPrice24h": "118919.38",
    //                 "lastPrice": "119818.83",
    //                 "turnover24h": "215859996.272276",
    //                 "volume24h": "1819.756798",
    //                 "bid1Price": "119811.26",
    //                 "ask1Price": "119831.18",
    //                 "bid1Size": "0.008732",
    //                 "ask1Size": "0.004297",
    //                 "price24hPcnt": "0.02002"
    //             }
    //         ],
    //         "ts": 1753230479687
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var ticker interface{} = this.SafeValue(data, 0, map[string]interface{} {})
    var utaTimestamp interface{} = this.SafeInteger(message, "ts")
    var timestamp interface{} = this.SafeInteger(ticker, "ts", utaTimestamp)
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var utaMarketId interface{} = this.SafeString(arg, "symbol")
    var marketId interface{} = this.SafeString(ticker, "instId", utaMarketId)
    market = this.SafeMarket(marketId, market, nil, marketType)
    var close interface{} = this.SafeString2(ticker, "lastPr", "lastPrice")
    var changeDecimal interface{} = this.SafeString(ticker, "change24h", "")
    var change interface{} = this.SafeString(ticker, "price24hPcnt", ccxt.Precise.StringMul(changeDecimal, "100"))
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString2(ticker, "high24h", "highPrice24h"),
        "low": this.SafeString2(ticker, "low24h", "lowPrice24h"),
        "bid": this.SafeString2(ticker, "bidPr", "bid1Price"),
        "bidVolume": this.SafeString2(ticker, "bidSz", "bid1Size"),
        "ask": this.SafeString2(ticker, "askPr", "ask1Price"),
        "askVolume": this.SafeString2(ticker, "askSz", "ask1Size"),
        "vwap": nil,
        "open": this.SafeString2(ticker, "open24h", "openPrice24h"),
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": nil,
        "percentage": change,
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "baseVolume", "volume24h"),
        "quoteVolume": this.SafeString2(ticker, "quoteVolume", "turnover24h"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitget#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://www.bitget.com/api-doc/spot/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Tickers-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Tickers-Channel
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitgetCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4298 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4298)
            symbols = this.MarketSymbols(symbols, nil, false)
            var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchBidsAsks", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketInner interface{} = this.Market(symbol)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                }
                var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
                var symbolOrInstId interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "symbol", "instId")
                ccxt.AddElementToObject(args, topicOrChannel, "ticker")
                ccxt.AddElementToObject(args, symbolOrInstId, ccxt.GetValue(marketInner, "id"))
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", symbol))
            }
        
            tickers:= (<-this.WatchPublicMultiple(messageHashes, topics, params))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(tickers, "symbol"), tickers)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleBidAsk(client interface{}, message interface{})  {
    var ticker interface{} = this.ParseWsBidAsk(message)
    var symbol interface{} = ccxt.GetValue(ticker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
    var messageHash interface{} = ccxt.Add("bidask:", symbol)
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
}
func  (this *BitgetCore) ParseWsBidAsk(message interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var ticker interface{} = this.SafeValue(data, 0, map[string]interface{} {})
    var utaTimestamp interface{} = this.SafeInteger(message, "ts")
    var timestamp interface{} = this.SafeInteger(ticker, "ts", utaTimestamp)
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var utaMarketId interface{} = this.SafeString(arg, "symbol")
    var marketId interface{} = this.SafeString(ticker, "instId", utaMarketId)
    market = this.SafeMarket(marketId, market, nil, marketType)
    return this.SafeTicker(map[string]interface{} {
        "symbol": ccxt.GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString2(ticker, "askPr", "ask1Price"),
        "askVolume": this.SafeString2(ticker, "askSz", "ask1Size"),
        "bid": this.SafeString2(ticker, "bidPr", "bid1Price"),
        "bidVolume": this.SafeString2(ticker, "bidSz", "bid1Size"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitget#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/Candlesticks-Channel
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitgetCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5078)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes")
            var interval interface{} = this.SafeString(timeframes, timeframe)
            var messageHash interface{} = nil
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchOHLCV", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            if ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "topic", "kline")
                ccxt.AddElementToObject(args, "symbol", ccxt.GetValue(market, "id"))
                ccxt.AddElementToObject(args, "interval", interval)
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
                messageHash = ccxt.Add("kline:", symbol)
            } else {
                ccxt.AddElementToObject(args, "channel", ccxt.Add("candle", interval))
                ccxt.AddElementToObject(args, "instId", ccxt.GetValue(market, "id"))
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
            }
        
            ohlcv:= (<-this.WatchPublic(messageHash, args, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#unWatchOHLCV
 * @description unsubscribe from the ohlcv channel
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/Candlesticks-Channel
 * @param {string} symbol unified symbol of the market to unwatch the ohlcv for
 * @param {string} [timeframe] the period for the ratio, default is 1 minute
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitgetCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5528)
            var timeframes interface{} = this.SafeDict(this.Options, "timeframes")
            var interval interface{} = this.SafeString(timeframes, timeframe)
            var channel interface{} = nil
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var instType interface{} = nil
            var messageHash interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "unWatchOHLCV", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            if ccxt.IsTrue(uta) {
                channel = "kline"
                ccxt.AddElementToObject(args, "topic", channel)
                ccxt.AddElementToObject(args, "symbol", ccxt.GetValue(market, "id"))
                ccxt.AddElementToObject(args, "interval", interval)
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
                ccxt.AddElementToObject(params, "interval", interval)
                messageHash = ccxt.Add(channel, symbol)
            } else {
                channel = ccxt.Add("candle", interval)
                ccxt.AddElementToObject(args, "channel", channel)
                ccxt.AddElementToObject(args, "instId", ccxt.GetValue(market, "id"))
                messageHash = ccxt.Add("candles:", interval)
            }
        
                retRes58215 :=  (<-this.UnWatchChannel(symbol, channel, messageHash, params))
                ccxt.PanicOnError(retRes58215)
                ch <- retRes58215
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "SPOT",
    //             "channel": "candle1m",
    //             "instId": "BTCUSDT"
    //         },
    //         "data": [
    //             [
    //                 "1701871620000",
    //                 "44080.23",
    //                 "44080.23",
    //                 "44028.5",
    //                 "44028.51",
    //                 "9.9287",
    //                 "437404.105512",
    //                 "437404.105512"
    //             ],
    //             [
    //                 "1701871680000",
    //                 "44028.51",
    //                 "44108.11",
    //                 "44028.5",
    //                 "44108.11",
    //                 "17.139",
    //                 "755436.870643",
    //                 "755436.870643"
    //             ],
    //         ],
    //         "ts": 1701901610417
    //     }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "usdt-futures",
    //             "topic": "kline",
    //             "symbol": "BTCUSDT",
    //             "interval": "1m"
    //         },
    //         "data": [
    //             {
    //                 "start": "1755564480000",
    //                 "open": "116286",
    //                 "close": "116256.2",
    //                 "high": "116310.2",
    //                 "low": "116232.8",
    //                 "volume": "39.7062",
    //                 "turnover": "4616746.46654"
    //             },
    //         ],
    //         "ts": 1755594421877
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var marketId interface{} = this.SafeString2(arg, "instId", "symbol")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var channel interface{} = this.SafeString2(arg, "channel", "topic")
    var interval interface{} = this.SafeString(arg, "interval")
    var isUta interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(interval, nil)) {
        isUta = false
        interval = ccxt.Replace(channel, "candle", "")
    } else {
        isUta = true
    }
    var timeframes interface{} = this.SafeValue(this.Options, "timeframes")
    var timeframe interface{} = this.FindTimeframe(interval, timeframes)
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var parsed interface{} = this.ParseWsOHLCV(ccxt.GetValue(data, i), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = nil
    if ccxt.IsTrue(isUta) {
        messageHash = ccxt.Add("kline:", symbol)
    } else {
        messageHash = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *BitgetCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1701871620000",  // timestamp
    //         "44080.23", // open
    //         "44080.23", // high
    //         "44028.5", // low
    //         "44028.51", // close
    //         "9.9287", // base volume
    //         "437404.105512", // quote volume
    //         "437404.105512" // USDT volume
    //     ]
    //
    // uta
    //
    //     {
    //         "start": "1755564480000",
    //         "open": "116286",
    //         "close": "116256.2",
    //         "high": "116310.2",
    //         "low": "116232.8",
    //         "volume": "39.7062",
    //         "turnover": "4616746.46654"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var volumeIndex interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.GetValue(market, "inverse"))), 6, 5)
    return []interface{}{this.SafeInteger2(ohlcv, "start", 0), this.SafeNumber2(ohlcv, "open", 1), this.SafeNumber2(ohlcv, "high", 2), this.SafeNumber2(ohlcv, "low", 3), this.SafeNumber2(ohlcv, "close", 4), this.SafeNumber2(ohlcv, "volume", volumeIndex)}
}
/**
 * @method
 * @name bitget#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Order-Book-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Order-Book-Channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitgetCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes73115 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes73115)
                ch <- retRes73115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#unWatchOrderBook
 * @description unsubscribe from the orderbook channel
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Order-Book-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Order-Book-Channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.limit] orderbook limit, default is undefined
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitgetCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7488)
            var channel interface{} = "books"
            var limit interface{} = this.SafeInteger(params, "limit")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, 1))) || ccxt.IsTrue((ccxt.IsEqual(limit, 5)))) || ccxt.IsTrue((ccxt.IsEqual(limit, 15)))) || ccxt.IsTrue((ccxt.IsEqual(limit, 50)))) {
                params = this.Omit(params, "limit")
                channel = ccxt.Add(channel, ccxt.ToString(limit))
            }
        
                retRes75515 :=  (<-this.UnWatchChannel(symbol, channel, "orderbook", params))
                ccxt.PanicOnError(retRes75515)
                ch <- retRes75515
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) UnWatchChannel(symbol interface{}, channel interface{}, messageHashTopic interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7598)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", messageHashTopic), ":"), ccxt.GetValue(market, "symbol"))
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "unWatchChannel", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            instTypeparamsVariable := this.GetInstType(market, uta, params)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            if ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "topic", channel)
                ccxt.AddElementToObject(args, "symbol", ccxt.GetValue(market, "id"))
                ccxt.AddElementToObject(args, "interval", this.SafeString(params, "interval", "1m"))
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
                params = this.Omit(params, "interval")
            } else {
                ccxt.AddElementToObject(args, "channel", channel)
                ccxt.AddElementToObject(args, "instId", ccxt.GetValue(market, "id"))
            }
        
                retRes77915 :=  (<-this.UnWatchPublic(messageHash, args, params))
                ccxt.PanicOnError(retRes77915)
                ch <- retRes77915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/ccxt.Order-Book-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/ccxt.Order-Book-Channel
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitgetCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7968)
            symbols = this.MarketSymbols(symbols)
            var channel interface{} = "books"
            var incrementalFeed interface{} = true
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(limit, 1))) || ccxt.IsTrue((ccxt.IsEqual(limit, 5)))) || ccxt.IsTrue((ccxt.IsEqual(limit, 15)))) || ccxt.IsTrue((ccxt.IsEqual(limit, 50)))) {
                channel = ccxt.Add(channel, ccxt.ToString(limit))
                incrementalFeed = false
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var instType interface{} = nil
                instTypeparamsVariable := this.GetInstType(market, uta, params)
                instType = ccxt.GetValue(instTypeparamsVariable,0)
                params = ccxt.GetValue(instTypeparamsVariable,1)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                }
                var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
                var symbolOrInstId interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "symbol", "instId")
                ccxt.AddElementToObject(args, topicOrChannel, channel)
                ccxt.AddElementToObject(args, symbolOrInstId, ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
            }
            if ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(params, "uta", true)
            }
        
            orderbook:= (<-this.WatchPublicMultiple(messageHashes, topics, params))
            ccxt.PanicOnError(orderbook)
            if ccxt.IsTrue(incrementalFeed) {
        
                ch <- orderbook.(ccxt.OrderBookInterface).Limit()
                return nil
            } else {
        
                ch <- orderbook
                return nil
            }
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //   {
    //       "action":"snapshot",
    //       "arg":{
    //          "instType":"SPOT",
    //          "channel":"books5",
    //          "instId":"BTCUSDT"
    //       },
    //       "data":[
    //          {
    //             "asks":[
    //                ["21041.11","0.0445"],
    //                ["21041.16","0.0411"],
    //                ["21041.21","0.0421"],
    //                ["21041.26","0.0811"],
    //                ["21041.65","1.9465"]
    //             ],
    //             "bids":[
    //                ["21040.76","0.0417"],
    //                ["21040.71","0.0434"],
    //                ["21040.66","0.1141"],
    //                ["21040.61","0.3004"],
    //                ["21040.60","1.3357"]
    //             ],
    //             "checksum": -1367582038,
    //             "ts":"1656413855484"
    //          }
    //       ]
    //   }
    //
    // {
    //     "action": "snapshot",
    //     "arg": { "instType": "usdt-futures", "topic": "books", "symbol": "BTCUSDT" },
    //     "data": [
    //         {
    //             "a": [Array],
    //             "b": [Array],
    //             "checksum": 0,
    //             "pseq": 0,
    //             "seq": "1343064377779269632",
    //             "ts": "1755937421270"
    //         }
    //     ],
    //     "ts": 1755937421337
    // }
    //
    var arg interface{} = this.SafeValue(message, "arg")
    var channel interface{} = this.SafeString2(arg, "channel", "topic")
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var marketId interface{} = this.SafeString2(arg, "instId", "symbol")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    var data interface{} = this.SafeValue(message, "data")
    var rawOrderBook interface{} = this.SafeValue(data, 0)
    var timestamp interface{} = this.SafeInteger(rawOrderBook, "ts")
    var incrementalBook interface{} = ccxt.IsEqual(channel, "books")
    if ccxt.IsTrue(incrementalBook) {
        // storedOrderBook = this.safeValue (this.orderbooks, symbol)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            // const ob = this.orderBook ({})
            var ob interface{} = this.CountedOrderBook(map[string]interface{} {})
            ccxt.AddElementToObject(ob, "symbol", symbol)
            ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
        }
        var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var asks interface{} = this.SafeList2(rawOrderBook, "asks", "a", []interface{}{})
        var bids interface{} = this.SafeList2(rawOrderBook, "bids", "b", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(storedOrderBook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(storedOrderBook, "bids"), bids)
        ccxt.AddElementToObject(storedOrderBook, "timestamp", timestamp)
        ccxt.AddElementToObject(storedOrderBook, "datetime", this.Iso8601(timestamp))
        var checksum interface{} = this.HandleOption("watchOrderBook", "checksum", true)
        var isSnapshot interface{} = ccxt.IsEqual(this.SafeString(message, "action"), "snapshot") // snapshot does not have a checksum
        if ccxt.IsTrue(!ccxt.IsTrue(isSnapshot) && ccxt.IsTrue(checksum)) {
            var storedAsks interface{} = ccxt.GetValue(storedOrderBook, "asks")
            var storedBids interface{} = ccxt.GetValue(storedOrderBook, "bids")
            var asksLength interface{} =             ccxt.GetArrayLength(storedAsks)
            var bidsLength interface{} =             ccxt.GetArrayLength(storedBids)
            var payloadArray interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, 25); i++ {
                if ccxt.IsTrue(ccxt.IsLessThan(i, bidsLength)) {
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedBids, i), 2), 0))
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedBids, i), 2), 1))
                }
                if ccxt.IsTrue(ccxt.IsLessThan(i, asksLength)) {
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 2), 0))
                    ccxt.AppendToArray(&payloadArray, ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(storedAsks, i), 2), 1))
                }
            }
            var payload interface{} = ccxt.Join(payloadArray, ":")
            var calculatedChecksum interface{} = this.Crc32(payload, true)
            var responseChecksum interface{} = this.SafeInteger(rawOrderBook, "checksum")
            if ccxt.IsTrue(!ccxt.IsEqual(calculatedChecksum, responseChecksum)) {
                // if (messageHash in client.(*ccxt.WSClient).Subscriptions) {
                //     // delete client.(*ccxt.WSClient).Subscriptions[messageHash]
                //     // delete this.orderbooks[symbol]
                // }
                this.Spawn(this.HandleCheckSumError, client, symbol, messageHash)
                return
            }
        }
    } else {
        var orderbook interface{} = this.OrderBook(map[string]interface{} {})
        var parsedOrderbook interface{} = this.ParseOrderBook(rawOrderBook, symbol, timestamp)
        orderbook.(ccxt.OrderBookInterface).Reset(parsedOrderbook)
        ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    }
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
}
func  (this *BitgetCore) HandleCheckSumError(client interface{}, symbol interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            retRes9488 := (<-this.UnWatchOrderBook(symbol))
            ccxt.PanicOnError(retRes9488)
            error := ccxt.ChecksumError(ccxt.Add(ccxt.Add(this.Id, " "), this.OrderbookChecksumMessage(symbol)))
            client.(ccxt.ClientInterface).Reject(error, messageHash)
                return nil
            }()
            return ch
        }
func  (this *BitgetCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    // we store the string representations in the orderbook for checksum calculation
    // this simplifies the code for generating checksums as we do not need to do any complex number transformations
    ccxt.AppendToArray(&bidAsk, delta)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *BitgetCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name bitget#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitgetCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes98215 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes98215)
                ch <- retRes98215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitgetCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
        
            retRes10048 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes10048)
            symbols = this.MarketSymbols(symbols)
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchTradesForSymbols", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var instType interface{} = nil
                instTypeparamsVariable := this.GetInstType(market, uta, params)
                instType = ccxt.GetValue(instTypeparamsVariable,0)
                params = ccxt.GetValue(instTypeparamsVariable,1)
                var args interface{} = map[string]interface{} {
                    "instType": instType,
                }
                var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
                var symbolOrInstId interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "symbol", "instId")
                ccxt.AddElementToObject(args, topicOrChannel, ccxt.Ternary(ccxt.IsTrue(uta), "publicTrade", "trade"))
                ccxt.AddElementToObject(args, symbolOrInstId, ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&topics, args)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade:", symbol))
            }
            if ccxt.IsTrue(uta) {
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
            }
        
            trades:= (<-this.WatchPublicMultiple(messageHashes, topics, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
            var result interface{} = this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            if ccxt.IsTrue(this.HandleOption("watchTrades", "ignoreDuplicates", true)) {
                var filtered interface{} = this.RemoveRepeatedTradesFromArray(result)
                filtered = this.SortBy(filtered, "timestamp")
        
                ch <- filtered
                return nil
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitget#unWatchTrades
 * @description unsubscribe from the trades channel
 * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/public/New-Trades-Channel
 * @param {string} symbol unified symbol of the market to unwatch the trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {any} status of the unwatch request
 */
func  (this *BitgetCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "unWatchTrades", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            var channelTopic interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "publicTrade", "trade")
        
                retRes105915 :=  (<-this.UnWatchChannel(symbol, channelTopic, "trade", params))
                ccxt.PanicOnError(retRes105915)
                ch <- retRes105915
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "SPOT", "channel": "trade", "instId": "BTCUSDT" },
    //         "data": [
    //             {
    //                 "ts": "1701910980366",
    //                 "price": "43854.01",
    //                 "size": "0.0535",
    //                 "side": "buy",
    //                 "tradeId": "1116461060594286593"
    //             },
    //         ],
    //         "ts": 1701910980730
    //     }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "spot", "topic": "publicTrade", "symbol": "BTCUSDT" },
    //         "data": [
    //             {
    //                 "T": "1756287827920",
    //                 "P": "110878.5",
    //                 "v": "0.07",
    //                 "S": "buy",
    //                 "L": "1344534089797185550"
    //                 "i": "1344534089797185549"
    //             },
    //         ],
    //         "ts": 1701910980730
    //     }
    //
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var marketId interface{} = this.SafeString2(arg, "instId", "symbol")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(data)
    // fix chronological order by reversing
    for i := 0; ccxt.IsLessThan(i, length); i++ {
        var index interface{} = ccxt.Subtract(ccxt.Subtract(length, i), 1)
        var rawTrade interface{} = ccxt.GetValue(data, index)
        var parsed interface{} = this.ParseWsTrade(rawTrade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add("trade:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *BitgetCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "ts": "1701910980366",
    //         "price": "43854.01",
    //         "size": "0.0535",
    //         "side": "buy",
    //         "tradeId": "1116461060594286593"
    //     }
    // swap private
    //
    //            {
    //               "orderId": "1169142761031114781",
    //               "tradeId": "1169142761312637004",
    //               "symbol": "LTCUSDT",
    //               "orderType": "market",
    //               "side": "buy",
    //               "price": "80.87",
    //               "baseVolume": "0.1",
    //               "quoteVolume": "8.087",
    //               "profit": "0",
    //               "tradeSide": "open",
    //               "posMode": "hedge_mode",
    //               "tradeScope": "taker",
    //               "feeDetail": [
    //                  {
    //                     "feeCoin": "USDT",
    //                     "deduction": "no",
    //                     "totalDeductionFee": "0",
    //                     "totalFee": "-0.0048522"
    //                  }
    //               ],
    //               "cTime": "1714471276596",
    //               "uTime": "1714471276596"
    //            }
    // spot private
    //        {
    //           "orderId": "1169142457356959747",
    //           "tradeId": "1169142457636958209",
    //           "symbol": "LTCUSDT",
    //           "orderType": "market",
    //           "side": "buy",
    //           "priceAvg": "81.069",
    //           "size": "0.074",
    //           "amount": "5.999106",
    //           "tradeScope": "taker",
    //           "feeDetail": [
    //              {
    //                 "feeCoin": "LTC",
    //                 "deduction": "no",
    //                 "totalDeductionFee": "0",
    //                 "totalFee": "0.000074"
    //              }
    //           ],
    //           "cTime": "1714471204194",
    //           "uTime": "1714471204194"
    //        }
    //
    // uta private
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderType": "market",
    //         "updatedTime": "1736378720623",
    //         "side": "buy",
    //         "orderId": "1288888888888888888",
    //         "execPnl": "0",
    //         "feeDetail": [
    //             {
    //                 "feeCoin": "USDT",
    //                 "fee": "0.569958"
    //             }
    //         ],
    //         "execTime": "1736378720623",
    //         "tradeScope": "taker",
    //         "tradeSide": "open",
    //         "execId": "1288888888888888888",
    //         "execLinkId": "1288888888888888888",
    //         "execPrice": "94993",
    //         "holdSide": "long",
    //         "execValue": "949.93",
    //         "category": "USDT-FUTURES",
    //         "execQty": "0.01",
    //         "clientOid": "1288888888888888889"
    // uta
    //
    //     {
    //         "i": "1344534089797185549", // Fill execution ID
    //         "L": "1344534089797185550", // Execution correlation ID
    //         "p": "110878.5", // Fill price
    //         "v": "0.07", // Fill size
    //         "S": "buy", // Fill side
    //         "T": "1756287827920" // Fill timestamp
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var instId interface{} = this.SafeString2(trade, "symbol", "instId")
    var posMode interface{} = this.SafeString(trade, "posMode")
    var category interface{} = this.SafeString(trade, "category")
    var defaultType interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(category, nil)) {
        defaultType = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(category, "SPOT"))), "contract", "spot")
    } else {
        defaultType = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(posMode, nil))), "contract", "spot")
    }
    if ccxt.IsTrue(ccxt.IsEqual(market, nil)) {
        market = this.SafeMarket(instId, nil, nil, defaultType)
    }
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"uTime", "cTime", "ts", "T", "execTime"})
    var feeDetail interface{} = this.SafeList(trade, "feeDetail", []interface{}{})
    var first interface{} = this.SafeDict(feeDetail, 0)
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(first, nil)) {
        var feeCurrencyId interface{} = this.SafeString(first, "feeCoin")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": ccxt.Precise.StringAbs(this.SafeString2(first, "totalFee", "fee")),
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeStringN(trade, []interface{}{"tradeId", "i", "execId"}),
        "order": this.SafeString2(trade, "orderId", "L"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": this.SafeString(trade, "orderType"),
        "side": this.SafeString2(trade, "side", "S"),
        "takerOrMaker": this.SafeString(trade, "tradeScope"),
        "price": this.SafeStringN(trade, []interface{}{"priceAvg", "price", "execPrice", "P"}),
        "amount": this.SafeStringN(trade, []interface{}{"size", "baseVolume", "execQty", "v"}),
        "cost": this.SafeStringN(trade, []interface{}{"amount", "quoteVolume", "execValue"}),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitget#watchPositions
 * @description watch all open positions
 * @see https://www.bitget.com/api-doc/contract/websocket/private/Positions-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/private/Positions-Channel
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @param {string} [params.instType] one of 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES', default is 'USDT-FUTURES'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BitgetCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12738)
            var market interface{} = nil
            var messageHash interface{} = ""
            var subscriptionHash interface{} = "positions"
            var instType interface{} = "USDT-FUTURES"
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchPositions", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                market = this.GetMarketFromSymbols(symbols)
                instTypeparamsVariable := this.GetInstType(market, uta, params)
                instType = ccxt.GetValue(instTypeparamsVariable,0)
                params = ccxt.GetValue(instTypeparamsVariable,1)
            }
            if ccxt.IsTrue(uta) {
                instType = "UTA"
            }
            messageHash = ccxt.Add(ccxt.Add(instType, ":positions"), messageHash)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "position", "positions")
            ccxt.AddElementToObject(args, topicOrChannel, channel)
            if !ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "instId", "default")
            } else {
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
            }
        
            newPositions:= (<-this.WatchPrivate(messageHash, subscriptionHash, args, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(newPositions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "USDT-FUTURES",
    //             "channel": "positions",
    //             "instId": "default"
    //         },
    //         "data": [
    //             {
    //                 "posId": "926036334386778112",
    //                 "instId": "BTCUSDT",
    //                 "marginCoin": "USDT",
    //                 "marginSize": "2.19245",
    //                 "marginMode": "crossed",
    //                 "holdSide": "long",
    //                 "posMode": "hedge_mode",
    //                 "total": "0.001",
    //                 "available": "0.001",
    //                 "frozen": "0",
    //                 "openPriceAvg": "43849",
    //                 "leverage": 20,
    //                 "achievedProfits": "0",
    //                 "unrealizedPL": "-0.0032",
    //                 "unrealizedPLR": "-0.00145955438",
    //                 "liquidationPrice": "17629.684814834",
    //                 "keepMarginRate": "0.004",
    //                 "marginRate": "0.007634649185",
    //                 "cTime": "1652331666985",
    //                 "uTime": "1701913016923",
    //                 "autoMargin": "off"
    //             },
    //             ...
    //         ]
    //         "ts": 1701913043767
    //     }
    //
    // uta
    //
    //     {
    //         "data": [
    //             {
    //                 "symbol": "BTCUSDT",
    //                 "leverage": "20",
    //                 "openFeeTotal": "",
    //                 "mmr": "",
    //                 "breakEvenPrice": "",
    //                 "available": "0",
    //                 "liqPrice": "",
    //                 "marginMode": "crossed",
    //                 "unrealisedPnl": "0",
    //                 "markPrice": "94987.1",
    //                 "createdTime": "1736378720620",
    //                 "avgPrice": "0",
    //                 "totalFundingFee": "0",
    //                 "updatedTime": "1736378720620",
    //                 "marginCoin": "USDT",
    //                 "frozen": "0",
    //                 "profitRate": "",
    //                 "closeFeeTotal": "",
    //                 "marginSize": "0",
    //                 "curRealisedPnl": "0",
    //                 "size": "0",
    //                 "positionStatus": "ended",
    //                 "posSide": "long",
    //                 "holdMode": "hedge_mode"
    //             }
    //         ],
    //         "arg": {
    //             "instType": "UTA",
    //             "topic": "position"
    //         },
    //         "action": "snapshot",
    //         "ts": 1730711666652
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeString(arg, "instType", "")
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    var action interface{} = this.SafeString(message, "action")
    if ccxt.IsTrue(!ccxt.IsTrue((ccxt.InOp(this.Positions, instType))) || ccxt.IsTrue((ccxt.IsEqual(action, "snapshot")))) {
        ccxt.AddElementToObject(this.Positions, instType, ccxt.NewArrayCacheBySymbolBySide())
    }
    var cache interface{} = ccxt.GetValue(this.Positions, instType)
    var rawPositions interface{} = this.SafeList(message, "data", []interface{}{})
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var marketId interface{} = this.SafeString2(rawPosition, "instId", "symbol")
        var market interface{} = this.SafeMarket(marketId, nil, nil, "contract")
        var position interface{} = this.ParseWsPosition(rawPosition, market)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(instType, ":positions::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add(instType, ":positions"))
}
func  (this *BitgetCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "posId": "926036334386778112",
    //         "instId": "BTCUSDT",
    //         "marginCoin": "USDT",
    //         "marginSize": "2.19245",
    //         "marginMode": "crossed",
    //         "holdSide": "long",
    //         "posMode": "hedge_mode",
    //         "total": "0.001",
    //         "available": "0.001",
    //         "frozen": "0",
    //         "openPriceAvg": "43849",
    //         "leverage": 20,
    //         "achievedProfits": "0",
    //         "unrealizedPL": "-0.0032",
    //         "unrealizedPLR": "-0.00145955438",
    //         "liquidationPrice": "17629.684814834",
    //         "keepMarginRate": "0.004",
    //         "marginRate": "0.007634649185",
    //         "cTime": "1652331666985",
    //         "uTime": "1701913016923",
    //         "autoMargin": "off"
    //     }
    //
    // uta
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "leverage": "20",
    //         "openFeeTotal": "",
    //         "mmr": "",
    //         "breakEvenPrice": "",
    //         "available": "0",
    //         "liqPrice": "",
    //         "marginMode": "crossed",
    //         "unrealisedPnl": "0",
    //         "markPrice": "94987.1",
    //         "createdTime": "1736378720620",
    //         "avgPrice": "0",
    //         "totalFundingFee": "0",
    //         "updatedTime": "1736378720620",
    //         "marginCoin": "USDT",
    //         "frozen": "0",
    //         "profitRate": "",
    //         "closeFeeTotal": "",
    //         "marginSize": "0",
    //         "curRealisedPnl": "0",
    //         "size": "0",
    //         "positionStatus": "ended",
    //         "posSide": "long",
    //         "holdMode": "hedge_mode"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(position, "instId", "symbol")
    var marginModeId interface{} = this.SafeString(position, "marginMode")
    var marginMode interface{} = this.GetSupportedMapping(marginModeId, map[string]interface{} {
        "crossed": "cross",
        "isolated": "isolated",
    })
    var hedgedId interface{} = this.SafeString2(position, "posMode", "holdMode")
    var hedged interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(hedgedId, "hedge_mode"))), true, false)
    var timestamp interface{} = this.SafeIntegerN(position, []interface{}{"updatedTime", "uTime", "cTime", "createdTime"})
    var percentageDecimal interface{} = this.SafeString2(position, "unrealizedPLR", "profitRate")
    var percentage interface{} = ccxt.Precise.StringMul(percentageDecimal, "100")
    var contractSize interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
        contractSize = ccxt.GetValue(market, "contractSize")
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": this.SafeString(position, "posId"),
        "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
        "notional": nil,
        "marginMode": marginMode,
        "liquidationPrice": this.SafeNumber2(position, "liquidationPrice", "liqPrice"),
        "entryPrice": this.SafeNumber2(position, "openPriceAvg", "avgPrice"),
        "unrealizedPnl": this.SafeNumber2(position, "unrealizedPL", "unrealisedPnl"),
        "percentage": this.ParseNumber(percentage),
        "contracts": this.SafeNumber2(position, "total", "size"),
        "contractSize": contractSize,
        "markPrice": this.SafeNumber(position, "markPrice"),
        "side": this.SafeString2(position, "holdSide", "posSide"),
        "hedged": hedged,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": this.SafeNumber2(position, "keepMarginRate", "mmr"),
        "collateral": this.SafeNumber(position, "available"),
        "initialMargin": this.SafeNumber(position, "marginSize"),
        "initialMarginPercentage": nil,
        "leverage": this.SafeNumber(position, "leverage"),
        "marginRatio": this.SafeNumber(position, "marginRate"),
    })
}
/**
 * @method
 * @name bitget#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://www.bitget.com/api-doc/spot/websocket/private/ccxt.Order-Channel
 * @see https://www.bitget.com/api-doc/spot/websocket/private/Plan-ccxt.Order-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/private/ccxt.Order-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/private/Plan-ccxt.Order-Channel
 * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Cross-Orders
 * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Isolate-Orders
 * @see https://www.bitget.com/api-doc/uta/websocket/private/ccxt.Order-Channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] *contract only* set to true for watching trigger orders
 * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin orders]
 * @param {string} [params.type] 'spot', 'swap'
 * @param {string} [params.subType] 'linear', 'inverse'
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitgetCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15388)
            var market interface{} = nil
            var marketId interface{} = nil
            var isTrigger interface{} = nil
            isTriggerparamsVariable := this.IsTriggerOrder(params)
            isTrigger = ccxt.GetValue(isTriggerparamsVariable,0)
            params = ccxt.GetValue(isTriggerparamsVariable,1)
            var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue((isTrigger)), "triggerOrder", "order")
            var subscriptionHash interface{} = "order:trades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                marketId = ccxt.GetValue(market, "id")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchOrders", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            var productType interface{} = this.SafeString(params, "productType")
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var subType interface{} = nil
            subTypeparamsVariable := this.HandleSubTypeAndParams("watchOrders", market, params, "linear")
            subType = ccxt.GetValue(subTypeparamsVariable,0)
            params = ccxt.GetValue(subTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) || ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")))) && ccxt.IsTrue((ccxt.IsEqual(symbol, nil)))) {
                marketId = "default"
            }
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(productType, nil))) && ccxt.IsTrue((!ccxt.IsEqual(typeVar, "spot")))) && ccxt.IsTrue((ccxt.IsEqual(symbol, nil)))) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), subType)
            } else if ccxt.IsTrue(ccxt.IsEqual(productType, "USDT-FUTURES")) {
                messageHash = ccxt.Add(messageHash, ":linear")
            } else if ccxt.IsTrue(ccxt.IsEqual(productType, "COIN-FUTURES")) {
                messageHash = ccxt.Add(messageHash, ":inverse")
            } else if ccxt.IsTrue(ccxt.IsEqual(productType, "USDC-FUTURES")) {
                messageHash = ccxt.Add(messageHash, ":usdcfutures") // non unified channel
            }
            var instType interface{} = nil
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(market, nil)) && ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot"))) {
                instType = "SPOT"
            } else {
                instTypeparamsVariable := this.GetInstType(market, uta, params)
                instType = ccxt.GetValue(instTypeparamsVariable,0)
                params = ccxt.GetValue(instTypeparamsVariable,1)
            }
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) && ccxt.IsTrue((!ccxt.IsEqual(symbol, nil)))) {
                subscriptionHash = ccxt.Add(ccxt.Add(subscriptionHash, ":"), symbol)
            }
            if ccxt.IsTrue(isTrigger) {
                subscriptionHash = ccxt.Add(subscriptionHash, ":stop") // we don't want to re-use the same subscription hash for stop orders
            }
            var instId interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) || ccxt.IsTrue(ccxt.IsEqual(typeVar, "margin")))), marketId, "default") // different from other streams here the 'rest' id is required for spot markets, contract markets require default here
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue(isTrigger), "orders-algo", "orders")
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchOrders", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(marginMode, nil)) {
                instType = "MARGIN"
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), marginMode)
                if ccxt.IsTrue(ccxt.IsEqual(marginMode, "isolated")) {
                    channel = "orders-isolated"
                } else {
                    channel = "orders-crossed"
                }
            }
            if ccxt.IsTrue(uta) {
                instType = "UTA"
                channel = "order"
            }
            subscriptionHash = ccxt.Add(ccxt.Add(subscriptionHash, ":"), instType)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
            ccxt.AddElementToObject(args, topicOrChannel, channel)
            if !ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "instId", instId)
            } else {
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
            }
        
            orders:= (<-this.WatchPrivate(messageHash, subscriptionHash, args, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleOrder(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "SPOT", "channel": "orders", "instId": "BTCUSDT" },
    //         "data": [
    //             // see all examples in parseWsOrder
    //         ],
    //         "ts": 1701923297285
    //     }
    //
    // contract
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "USDT-FUTURES", "channel": "orders", "instId": "default" },
    //         "data": [
    //             // see all examples in parseWsOrder
    //         ],
    //         "ts": 1701920595879
    //     }
    //
    // isolated and cross margin
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "MARGIN", "channel": "orders-crossed", "instId": "BTCUSDT" },
    //         "data": [
    //             // see examples in parseWsOrder
    //         ],
    //         "ts": 1701923982497
    //     }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //             "instType": "UTA",
    //             "topic": "order"
    //         },
    //         "data": [
    //             {
    //                 "category": "usdt-futures",
    //                 "symbol": "BTCUSDT",
    //                 "orderId": "xxx",
    //                 "clientOid": "xxx",
    //                 "price": "",
    //                 "qty": "0.001",
    //                 "amount": "1000",
    //                 "holdMode": "hedge_mode",
    //                 "holdSide": "long",
    //                 "tradeSide": "open",
    //                 "orderType": "market",
    //                 "timeInForce": "gtc",
    //                 "side": "buy",
    //                 "marginMode": "crossed",
    //                 "marginCoin": "USDT",
    //                 "reduceOnly": "no",
    //                 "cumExecQty": "0.001",
    //                 "cumExecValue": "83.1315",
    //                 "avgPrice": "83131.5",
    //                 "totalProfit": "0",
    //                 "orderStatus": "filled",
    //                 "cancelReason": "",
    //                 "leverage": "20",
    //                 "feeDetail": [
    //                     {
    //                         "feeCoin": "USDT",
    //                         "fee": "0.0332526"
    //                     }
    //                 ],
    //                 "createdTime": "1742367838101",
    //                 "updatedTime": "1742367838115",
    //                 "stpMode": "none"
    //             }
    //         ],
    //         "ts": 1742367838124
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var channel interface{} = this.SafeString2(arg, "channel", "topic")
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var argInstId interface{} = this.SafeString(arg, "instId")
    var marketType interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(instType, "spot")) {
        marketType = "spot"
    } else if ccxt.IsTrue(ccxt.IsEqual(instType, "margin")) {
        marketType = "spot"
    } else {
        marketType = "contract"
    }
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
    var category interface{} = this.SafeStringLower(first, "category", instType)
    var isLinearSwap interface{} =     (ccxt.IsEqual(category, "usdt-futures"))
    var isInverseSwap interface{} =     (ccxt.IsEqual(category, "coin-futures"))
    var isUSDCFutures interface{} =     (ccxt.IsEqual(category, "usdc-futures"))
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.TriggerOrders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var isTrigger interface{} = ccxt.IsTrue((ccxt.IsEqual(channel, "orders-algo"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "ordersAlgo")))
    var stored interface{} = ccxt.Ternary(ccxt.IsTrue(isTrigger), this.TriggerOrders, this.Orders)
    var messageHash interface{} = ccxt.Ternary(ccxt.IsTrue(isTrigger), "triggerOrder", "order")
    var marketSymbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString2(order, "instId", "symbol", argInstId)
        var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
        var parsed interface{} = this.ParseWsOrder(order, market)
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(marketSymbols, symbol, true)
    }
    var keys interface{} = ccxt.ObjectKeys(marketSymbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var symbol interface{} = ccxt.GetValue(keys, i)
        var innerMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        if ccxt.IsTrue(ccxt.IsEqual(channel, "orders-crossed")) {
            innerMessageHash = ccxt.Add(innerMessageHash, ":cross")
        } else if ccxt.IsTrue(ccxt.IsEqual(channel, "orders-isolated")) {
            innerMessageHash = ccxt.Add(innerMessageHash, ":isolated")
        }
        client.(ccxt.ClientInterface).Resolve(stored, innerMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    if ccxt.IsTrue(isLinearSwap) {
        client.(ccxt.ClientInterface).Resolve(stored, "order:linear")
    }
    if ccxt.IsTrue(isInverseSwap) {
        client.(ccxt.ClientInterface).Resolve(stored, "order:inverse")
    }
    if ccxt.IsTrue(isUSDCFutures) {
        client.(ccxt.ClientInterface).Resolve(stored, "order:usdcfutures")
    }
}
func  (this *BitgetCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //   {
    //         instId: 'EOSUSDT',
    //         orderId: '1171779081105780739',
    //         price: '0.81075', // limit price, field not present for market orders
    //         clientOid: 'a2330139-1d04-4d78-98be-07de3cfd1055',
    //         notional: '5.675250', // this is not cost! but notional
    //         newSize: '7.0000', // this is not cost! quanity (for limit order or market sell) or cost (for market buy order)
    //         size: '5.6752', // this is not cost, neither quanity, but notional! this field for "spot" can be ignored at all
    //         // Note: for limit order (even filled) we don't have cost value in response, only in market order
    //         orderType: 'limit', // limit, market
    //         force: 'gtc',
    //         side: 'buy',
    //         accBaseVolume: '0.0000', // in case of 'filled', this would be set (for limit orders, this is the only indicator of the amount filled)
    //         priceAvg: '0.00000', // in case of 'filled', this would be set
    //         status: 'live', // live, filled, partially_filled
    //         cTime: '1715099824215',
    //         uTime: '1715099824215',
    //         feeDetail: [],
    //         enterPointSource: 'API'
    //                   #### trigger order has these additional fields: ####
    //         "triggerPrice": "35100",
    //         "price": "35100", // this is same as trigger price
    //         "executePrice": "35123", // this is limit price
    //         "triggerType": "fill_price",
    //         "planType": "amount",
    //                   #### in case order had a partial fill: ####
    //         fillPrice: '35123',
    //         tradeId: '1171775539946528779',
    //         baseVolume: '7', // field present in market order
    //         fillTime: '1715098979937',
    //         fillFee: '-0.0069987',
    //         fillFeeCoin: 'BTC',
    //         tradeScope: 'T',
    //    }
    //
    // contract
    //
    //     {
    //         accBaseVolume: '0', // total amount filled during lifetime for order
    //         cTime: '1715065875539',
    //         clientOid: '1171636690041344003',
    //         enterPointSource: 'API',
    //         feeDetail: [ {
    //             "feeCoin": "USDT",
    //             "fee": "-0.162003"
    //         } ],
    //         force: 'gtc',
    //         instId: 'SEOSSUSDT',
    //         leverage: '10',
    //         marginCoin: 'USDT',
    //         marginMode: 'crossed',
    //         notionalUsd: '10.4468',
    //         orderId: '1171636690028761089',
    //         orderType: 'market',
    //         posMode: 'hedge_mode', // one_way_mode, hedge_mode
    //         posSide: 'short', // short, long, net
    //         price: '0', // zero for market order
    //         reduceOnly: 'no',
    //         side: 'sell',
    //         size: '13', // this is contracts amount
    //         status: 'live', // live, filled, cancelled
    //         tradeSide: 'open',
    //         uTime: '1715065875539'
    //                   #### when filled order is incoming, these additional fields are present too: ###
    //         baseVolume: '9', // amount filled for the incoming update/trade
    //         accBaseVolume: '13', // i.e. 9 has been filled from 13 amount (this value is same as 'size')
    //         fillFee: '-0.0062712',
    //         fillFeeCoin: 'SUSDT',
    //         fillNotionalUsd: '10.452',
    //         fillPrice: '0.804',
    //         fillTime: '1715065875605',
    //         pnl: '0',
    //         priceAvg: '0.804',
    //         tradeId: '1171636690314407937',
    //         tradeScope: 'T',
    //                   #### trigger order has these additional fields:
    //         "triggerPrice": "0.800000000",
    //         "price": "0.800000000",  // <-- this is same as trigger price, actual limit-price is not present in initial response
    //         "triggerType": "mark_price",
    //         "triggerTime": "1715082796679",
    //         "planType": "pl",
    //         "actualSize": "0.000000000",
    //         "stopSurplusTriggerType": "fill_price",
    //         "stopLossTriggerType": "fill_price",
    //     }
    //
    // isolated and cross margin
    //
    //     {
    //         enterPointSource: "web",
    //         feeDetail: [
    //           {
    //             feeCoin: "AAVE",
    //             deduction: "no",
    //             totalDeductionFee: "0",
    //             totalFee: "-0.00010740",
    //           },
    //         ],
    //         force: "gtc",
    //         orderType: "limit",
    //         price: "93.170000000",
    //         fillPrice: "93.170000000",
    //         baseSize: "0.110600000", // total amount of order
    //         quoteSize: "10.304602000", // total cost of order (independently if order is filled or pending)
    //         baseVolume: "0.107400000", // filled amount of order (during order's lifecycle, and not for this specific incoming update)
    //         fillTotalAmount: "10.006458000", // filled cost of order (during order's lifecycle, and not for this specific incoming update)
    //         side: "buy",
    //         status: "partially_filled",
    //         cTime: "1717875017306",
    //         clientOid: "b57afe789a06454e9c560a2aab7f7201",
    //         loanType: "auto-loan",
    //         orderId: "1183419084588060673",
    //       }
    //
    // uta
    //
    //     {
    //         "category": "usdt-futures",
    //         "symbol": "BTCUSDT",
    //         "orderId": "xxx",
    //         "clientOid": "xxx",
    //         "price": "",
    //         "qty": "0.001",
    //         "amount": "1000",
    //         "holdMode": "hedge_mode",
    //         "holdSide": "long",
    //         "tradeSide": "open",
    //         "orderType": "market",
    //         "timeInForce": "gtc",
    //         "side": "buy",
    //         "marginMode": "crossed",
    //         "marginCoin": "USDT",
    //         "reduceOnly": "no",
    //         "cumExecQty": "0.001",
    //         "cumExecValue": "83.1315",
    //         "avgPrice": "83131.5",
    //         "totalProfit": "0",
    //         "orderStatus": "filled",
    //         "cancelReason": "",
    //         "leverage": "20",
    //         "feeDetail": [
    //             {
    //                 "feeCoin": "USDT",
    //                 "fee": "0.0332526"
    //             }
    //         ],
    //         "createdTime": "1742367838101",
    //         "updatedTime": "1742367838115",
    //         "stpMode": "none"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var isSpot interface{} =     !ccxt.IsTrue((ccxt.InOp(order, "posMode")))
    var isMargin interface{} =     (ccxt.InOp(order, "loanType"))
    var category interface{} = this.SafeStringLower(order, "category")
    if ccxt.IsTrue(ccxt.IsEqual(category, "spot")) {
        isSpot = true
    }
    if ccxt.IsTrue(ccxt.IsEqual(category, "margin")) {
        isMargin = true
    }
    var marketId interface{} = this.SafeString2(order, "instId", "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger2(order, "cTime", "createdTime")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var rawStatus interface{} = this.SafeString2(order, "status", "orderStatus")
    var orderFee interface{} = this.SafeValue(order, "feeDetail", []interface{}{})
    var fee interface{} = this.SafeValue(orderFee, 0)
    var feeAmount interface{} = this.SafeString(fee, "fee")
    var feeObject interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeAmount, nil)) {
        var feeCurrency interface{} = this.SafeString(fee, "feeCoin")
        feeObject = map[string]interface{} {
            "cost": this.ParseNumber(ccxt.Precise.StringAbs(feeAmount)),
            "currency": this.SafeCurrencyCode(feeCurrency),
        }
    }
    var triggerPrice interface{} = this.SafeNumber(order, "triggerPrice")
    var isTriggerOrder interface{} =     (!ccxt.IsEqual(triggerPrice, nil))
    var price interface{} = nil
    if !ccxt.IsTrue(isTriggerOrder) {
        price = this.SafeNumber(order, "price")
    } else if ccxt.IsTrue(ccxt.IsTrue(isSpot) && ccxt.IsTrue(isTriggerOrder)) {
        // for spot trigger order, limit price is this
        price = this.SafeNumber(order, "executePrice")
    }
    var avgPrice interface{} = this.OmitZero(this.SafeStringLowerN(order, []interface{}{"priceAvg", "fillPrice", "avgPrice"}))
    var side interface{} = this.SafeString(order, "side")
    var typeVar interface{} = this.SafeString(order, "orderType")
    var accBaseVolume interface{} = this.OmitZero(this.SafeString2(order, "accBaseVolume", "cumExecQty"))
    var newSizeValue interface{} = this.OmitZero(this.SafeString2(order, "newSize", "cumExecValue"))
    var isMarketOrder interface{} =     (ccxt.IsEqual(typeVar, "market"))
    var isBuy interface{} =     (ccxt.IsEqual(side, "buy"))
    var totalAmount interface{} = nil
    var filledAmount interface{} = nil
    var cost interface{} = nil
    var remaining interface{} = nil
    var totalFilled interface{} = this.SafeString2(order, "accBaseVolume", "cumExecQty")
    if ccxt.IsTrue(isSpot) {
        if ccxt.IsTrue(isMargin) {
            totalAmount = this.SafeString2(order, "baseSize", "qty")
            totalFilled = this.SafeString2(order, "baseVolume", "cumExecQty")
            cost = this.SafeString2(order, "fillTotalAmount", "cumExecValue")
        } else {
            var partialFillAmount interface{} = this.SafeString(order, "baseVolume")
            if ccxt.IsTrue(!ccxt.IsEqual(partialFillAmount, nil)) {
                filledAmount = partialFillAmount
            } else {
                filledAmount = totalFilled
            }
            if ccxt.IsTrue(isMarketOrder) {
                if ccxt.IsTrue(isBuy) {
                    totalAmount = accBaseVolume
                    cost = newSizeValue
                } else {
                    totalAmount = newSizeValue
                }
            } else {
                totalAmount = this.SafeString2(order, "newSize", "qty")
            }
        }
    } else {
        // baseVolume should not be used for "amount" for contracts !
        filledAmount = this.SafeString2(order, "baseVolume", "cumExecQty")
        totalAmount = this.SafeString2(order, "size", "qty")
        cost = this.SafeString2(order, "fillNotionalUsd", "cumExecValue")
    }
    remaining = ccxt.Precise.StringSub(totalAmount, totalFilled)
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": this.SafeString(order, "clientOid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger2(order, "uTime", "updatedTime"),
        "type": typeVar,
        "timeInForce": this.SafeStringUpper2(order, "force", "timeInForce"),
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "amount": totalAmount,
        "cost": cost,
        "average": avgPrice,
        "filled": filledAmount,
        "remaining": remaining,
        "status": this.ParseWsOrderStatus(rawStatus),
        "fee": feeObject,
        "trades": nil,
    }, market)
}
func  (this *BitgetCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "live": "open",
        "partially_filled": "open",
        "filled": "closed",
        "cancelled": "canceled",
        "not_trigger": "open",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name bitget#watchMyTrades
 * @description watches trades made by the user
 * @see https://www.bitget.com/api-doc/contract/websocket/private/Fill-Channel
 * @see https://www.bitget.com/api-doc/uta/websocket/private/Fill-Channel
 * @param {str} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *BitgetCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes20418)
            var market interface{} = nil
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var instType interface{} = nil
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchMyTrades", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(market, nil)) && ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot"))) {
                instType = "SPOT"
            } else {
                instTypeparamsVariable := this.GetInstType(market, uta, params)
                instType = ccxt.GetValue(instTypeparamsVariable,0)
                params = ccxt.GetValue(instTypeparamsVariable,1)
            }
            if ccxt.IsTrue(uta) {
                instType = "UTA"
            }
            var subscriptionHash interface{} = ccxt.Add("fill:", instType)
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
            ccxt.AddElementToObject(args, topicOrChannel, "fill")
            if !ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "instId", "default")
            } else {
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
            }
        
            trades:= (<-this.WatchPrivate(messageHash, subscriptionHash, args, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // spot
    // {
    //     "action": "snapshot",
    //     "arg": {
    //        "instType": "SPOT",
    //        "channel": "fill",
    //        "instId": "default"
    //     },
    //     "data": [
    //        {
    //           "orderId": "1169142457356959747",
    //           "tradeId": "1169142457636958209",
    //           "symbol": "LTCUSDT",
    //           "orderType": "market",
    //           "side": "buy",
    //           "priceAvg": "81.069",
    //           "size": "0.074",
    //           "amount": "5.999106",
    //           "tradeScope": "taker",
    //           "feeDetail": [
    //              {
    //                 "feeCoin": "LTC",
    //                 "deduction": "no",
    //                 "totalDeductionFee": "0",
    //                 "totalFee": "0.000074"
    //              }
    //           ],
    //           "cTime": "1714471204194",
    //           "uTime": "1714471204194"
    //        }
    //     ],
    //     "ts": 1714471204270
    // }
    // swap
    //     {
    //         "action": "snapshot",
    //         "arg": {
    //            "instType": "USDT-FUTURES",
    //            "channel": "fill",
    //            "instId": "default"
    //         },
    //         "data": [
    //            {
    //               "orderId": "1169142761031114781",
    //               "tradeId": "1169142761312637004",
    //               "symbol": "LTCUSDT",
    //               "orderType": "market",
    //               "side": "buy",
    //               "price": "80.87",
    //               "baseVolume": "0.1",
    //               "quoteVolume": "8.087",
    //               "profit": "0",
    //               "tradeSide": "open",
    //               "posMode": "hedge_mode",
    //               "tradeScope": "taker",
    //               "feeDetail": [
    //                  {
    //                     "feeCoin": "USDT",
    //                     "deduction": "no",
    //                     "totalDeductionFee": "0",
    //                     "totalFee": "-0.0048522"
    //                  }
    //               ],
    //               "cTime": "1714471276596",
    //               "uTime": "1714471276596"
    //            }
    //         ],
    //         "ts": 1714471276629
    //     }
    //
    // uta
    //
    //     {
    //         "data": [
    //             {
    //                 "symbol": "BTCUSDT",
    //                 "orderType": "market",
    //                 "updatedTime": "1736378720623",
    //                 "side": "buy",
    //                 "orderId": "1288888888888888888",
    //                 "execPnl": "0",
    //                 "feeDetail": [
    //                     {
    //                         "feeCoin": "USDT",
    //                         "fee": "0.569958"
    //                     }
    //                 ],
    //                 "execTime": "1736378720623",
    //                 "tradeScope": "taker",
    //                 "tradeSide": "open",
    //                 "execId": "1288888888888888888",
    //                 "execLinkId": "1288888888888888888",
    //                 "execPrice": "94993",
    //                 "holdSide": "long",
    //                 "execValue": "949.93",
    //                 "category": "USDT-FUTURES",
    //                 "execQty": "0.01",
    //                 "clientOid": "1288888888888888889"
    //             }
    //         ],
    //         "arg": {
    //             "instType": "UTA",
    //             "topic": "fill"
    //         },
    //         "action": "snapshot",
    //         "ts": 1733904123981
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCache(limit)
    }
    var stored interface{} = this.MyTrades
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(data)
    var messageHash interface{} = "myTrades"
    for i := 0; ccxt.IsLessThan(i, length); i++ {
        var trade interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseWsTrade(trade)
        stored.(ccxt.Appender).Append(parsed)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        var symbolSpecificMessageHash interface{} = ccxt.Add("myTrades:", symbol)
        client.(ccxt.ClientInterface).Resolve(stored, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name bitget#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.bitget.com/api-doc/spot/websocket/private/ccxt.Account-Channel
 * @see https://www.bitget.com/api-doc/contract/websocket/private/ccxt.Account-Channel
 * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Margin-Cross-ccxt.Account-Assets
 * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Margin-isolated-account-assets
 * @see https://www.bitget.com/api-doc/uta/websocket/private/ccxt.Account-Channel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
 * @param {string} [params.instType] one of 'SPOT', 'MARGIN', 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
 * @param {string} [params.marginMode] 'isolated' or 'cross' for watching spot margin balances
 * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BitgetCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("watchBalance", params)
            marginMode = ccxt.GetValue(marginModeparamsVariable,0)
            params = ccxt.GetValue(marginModeparamsVariable,1)
            var instType interface{} = nil
            var channel interface{} = "account"
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "swap"))) || ccxt.IsTrue((ccxt.IsEqual(typeVar, "future")))) {
                instType = "USDT-FUTURES"
            } else if ccxt.IsTrue(!ccxt.IsEqual(marginMode, nil)) {
                instType = "MARGIN"
                if !ccxt.IsTrue(uta) {
                    if ccxt.IsTrue(ccxt.IsEqual(marginMode, "isolated")) {
                        channel = "account-isolated"
                    } else {
                        channel = "account-crossed"
                    }
                }
            } else if !ccxt.IsTrue(uta) {
                instType = "SPOT"
            }
            instTypeparamsVariable := this.HandleOptionAndParams(params, "watchBalance", "instType", instType)
            instType = ccxt.GetValue(instTypeparamsVariable,0)
            params = ccxt.GetValue(instTypeparamsVariable,1)
            if ccxt.IsTrue(uta) {
                instType = "UTA"
            }
            var args interface{} = map[string]interface{} {
                "instType": instType,
            }
            var topicOrChannel interface{} = ccxt.Ternary(ccxt.IsTrue(uta), "topic", "channel")
            ccxt.AddElementToObject(args, topicOrChannel, channel)
            if !ccxt.IsTrue(uta) {
                ccxt.AddElementToObject(args, "coin", "default")
            } else {
                params = this.Extend(params, map[string]interface{} {
                    "uta": true,
                })
            }
            var messageHash interface{} = ccxt.Add("balance:", ccxt.ToLower(instType))
        
                retRes226315 :=  (<-this.WatchPrivate(messageHash, messageHash, args, params))
                ccxt.PanicOnError(retRes226315)
                ch <- retRes226315
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "SPOT", "channel": "account", "coin": "default" },
    //         "data": [
    //             {
    //                 "coin": "USDT",
    //                 "available": "19.1430952856087",
    //                 "frozen": "7",
    //                 "locked": "0",
    //                 "limitAvailable": "0",
    //                 "uTime": "1701931970487"
    //             },
    //         ],
    //         "ts": 1701931970487
    //     }
    //
    // swap
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "USDT-FUTURES", "channel": "account", "coin": "default" },
    //         "data": [
    //             {
    //                 "marginCoin": "USDT",
    //                 "frozen": "5.36581500",
    //                 "available": "26.14309528",
    //                 "maxOpenPosAvailable": "20.77728028",
    //                 "maxTransferOut": "20.77728028",
    //                 "equity": "26.14309528",
    //                 "usdtEquity": "26.143095285166"
    //             }
    //         ],
    //         "ts": 1701932570822
    //     }
    //
    // margin
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "MARGIN", "channel": "account-crossed", "coin": "default" },
    //         "data": [
    //             {
    //                 "uTime": "1701933110544",
    //                 "id": "1096916799926710272",
    //                 "coin": "USDT",
    //                 "available": "16.24309528",
    //                 "borrow": "0.00000000",
    //                 "frozen": "9.90000000",
    //                 "interest": "0.00000000",
    //                 "coupon": "0.00000000"
    //             }
    //         ],
    //         "ts": 1701933110544
    //     }
    //
    // uta
    //
    //     {
    //         "data": [{
    //             "unrealisedPnL": "-10116.55",
    //             "totalEquity": "4976919.05",
    //             "positionMgnRatio": "0",
    //             "mmr": "408.08",
    //             "effEquity": "4847952.35",
    //             "imr": "17795.97",
    //             "mgnRatio": "0",
    //             "coin": [{
    //                 "debts": "0",
    //                 "balance": "0.9992",
    //                 "available": "0.9992",
    //                 "borrow": "0",
    //                 "locked": "0",
    //                 "equity": "0.9992",
    //                 "coin": "ETH",
    //                 "usdValue": "2488.667472"
    //             }]
    //         }],
    //         "arg": {
    //             "instType": "UTA",
    //             "topic": "account"
    //         },
    //         "action": "snapshot",
    //         "ts": 1740546523244
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawBalance interface{} = ccxt.GetValue(data, i)
        if ccxt.IsTrue(ccxt.IsEqual(instType, "uta")) {
            var coins interface{} = this.SafeList(rawBalance, "coin", []interface{}{})
            for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(coins)); j++ {
                var entry interface{} = ccxt.GetValue(coins, j)
                var currencyId interface{} = this.SafeString(entry, "coin")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
                var borrow interface{} = this.SafeString(entry, "borrow")
                var debts interface{} = this.SafeString(entry, "debts")
                if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(borrow, nil))) || ccxt.IsTrue((!ccxt.IsEqual(debts, nil)))) {
                    ccxt.AddElementToObject(account, "debt", ccxt.Precise.StringAdd(borrow, debts))
                }
                ccxt.AddElementToObject(account, "free", this.SafeString(entry, "available"))
                ccxt.AddElementToObject(account, "used", this.SafeString(entry, "locked"))
                ccxt.AddElementToObject(account, "total", this.SafeString(entry, "balance"))
                ccxt.AddElementToObject(this.Balance, code, account)
            }
        } else {
            var currencyId interface{} = this.SafeString2(rawBalance, "coin", "marginCoin")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
            var borrow interface{} = this.SafeString(rawBalance, "borrow")
            if ccxt.IsTrue(!ccxt.IsEqual(borrow, nil)) {
                var interest interface{} = this.SafeString(rawBalance, "interest")
                ccxt.AddElementToObject(account, "debt", ccxt.Precise.StringAdd(borrow, interest))
            }
            var freeQuery interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(rawBalance, "maxTransferOut"))), "maxTransferOut", "available")
            ccxt.AddElementToObject(account, "free", this.SafeString(rawBalance, freeQuery))
            ccxt.AddElementToObject(account, "total", this.SafeString(rawBalance, "equity"))
            ccxt.AddElementToObject(account, "used", this.SafeString(rawBalance, "frozen"))
            ccxt.AddElementToObject(this.Balance, code, account)
        }
    }
    this.Balance = this.SafeBalance(this.Balance)
    var messageHash interface{} = ccxt.Add("balance:", instType)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *BitgetCore) WatchPublic(messageHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            var url interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchPublic", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            if ccxt.IsTrue(uta) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "utaPublic")
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            }
            var sandboxMode interface{} = this.SafeBool2(this.Options, "sandboxMode", "sandbox", false)
            if ccxt.IsTrue(sandboxMode) {
                var instType interface{} = this.SafeString(args, "instType")
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(instType, "SCOIN-FUTURES"))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDT-FUTURES")))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDC-FUTURES")))) {
                    if ccxt.IsTrue(uta) {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "utaPublic")
                    } else {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "public")
                    }
                }
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes242315 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes242315)
                ch <- retRes242315
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) UnWatchPublic(messageHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            var url interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "unWatchPublic", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            if ccxt.IsTrue(uta) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "utaPublic")
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            }
            var sandboxMode interface{} = this.SafeBool2(this.Options, "sandboxMode", "sandbox", false)
            if ccxt.IsTrue(sandboxMode) {
                var instType interface{} = this.SafeString(args, "instType")
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(instType, "SCOIN-FUTURES"))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDT-FUTURES")))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDC-FUTURES")))) {
                    if ccxt.IsTrue(uta) {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "utaPublic")
                    } else {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "public")
                    }
                }
            }
            var request interface{} = map[string]interface{} {
                "op": "unsubscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes245115 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes245115)
                ch <- retRes245115
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) WatchPublicMultiple(messageHashes interface{}, argsArray interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            var url interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchPublicMultiple", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            if ccxt.IsTrue(uta) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "utaPublic")
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            }
            var sandboxMode interface{} = this.SafeBool2(this.Options, "sandboxMode", "sandbox", false)
            if ccxt.IsTrue(sandboxMode) {
                var argsArrayFirst interface{} = this.SafeDict(argsArray, 0, map[string]interface{} {})
                var instType interface{} = this.SafeString(argsArrayFirst, "instType")
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(instType, "SCOIN-FUTURES"))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDT-FUTURES")))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDC-FUTURES")))) {
                    if ccxt.IsTrue(uta) {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "utaPublic")
                    } else {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "public")
                    }
                }
            }
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": argsArray,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes248015 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes248015)
                ch <- retRes248015
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = this.SafeString(params, "url")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var timestamp interface{} = ccxt.ToString(this.Seconds())
                var auth interface{} = ccxt.Add(ccxt.Add(timestamp, "GET"), "/user/verify")
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var operation interface{} = "login"
                var request interface{} = map[string]interface{} {
                    "op": operation,
                    "args": []interface{}{map[string]interface{} {
            "apiKey": this.ApiKey,
            "passphrase": this.Password,
            "timestamp": timestamp,
            "sign": signature,
        }},
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes250915 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes250915)
                ch <- retRes250915
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) WatchPrivate(messageHash interface{}, subscriptionHash interface{}, args interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var uta interface{} = nil
            var url interface{} = nil
            utaparamsVariable := this.HandleOptionAndParams(params, "watchPrivate", "uta", false)
            uta = ccxt.GetValue(utaparamsVariable,0)
            params = ccxt.GetValue(utaparamsVariable,1)
            if ccxt.IsTrue(uta) {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "utaPrivate")
            } else {
                url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            }
            var sandboxMode interface{} = this.SafeBool2(this.Options, "sandboxMode", "sandbox", false)
            if ccxt.IsTrue(sandboxMode) {
                var instType interface{} = this.SafeString(args, "instType")
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(instType, "SCOIN-FUTURES"))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDT-FUTURES")))) && ccxt.IsTrue((!ccxt.IsEqual(instType, "SUSDC-FUTURES")))) {
                    if ccxt.IsTrue(uta) {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "utaPrivate")
                    } else {
                        url = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "demo"), "private")
                    }
                }
            }
        
            retRes25328 := (<-this.Authenticate(map[string]interface{} {
                "url": url,
            }))
            ccxt.PanicOnError(retRes25328)
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": []interface{}{args},
            }
            var message interface{} = this.Extend(request, params)
        
                retRes253815 :=  (<-this.Watch(url, messageHash, message, subscriptionHash))
                ccxt.PanicOnError(retRes253815)
                ch <- retRes253815
                return nil
        
            }()
            return ch
        }
func  (this *BitgetCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //  { event: "login", code: 0 }
    //
    var messageHash interface{} = "authenticated"
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
    future.(*ccxt.Future).Resolve(true)
}
func  (this *BitgetCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    { event: "error", code: 30015, msg: "Invalid sign" }
    //
    var event interface{} = this.SafeString(message, "event")
    
        {
            ret__ := func(this *BitgetCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BitgetCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(e, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                // Note: if error happens on a subscribe event, user will have to close exchange to resubscribe. Issue #19041
                client.(ccxt.ClientInterface).Reject(e)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsEqual(event, "error")) {
                var code interface{} = this.SafeString(message, "code")
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), code, feedback)
                var msg interface{} = this.SafeString(message, "msg", "")
                this.ThrowBroadlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "broad"), msg, feedback)
                panic(ccxt.ExchangeError(feedback))
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *BitgetCore) HandleMessage(client interface{}, message interface{})  {
    //
    //   {
    //       "action": "snapshot",
    //       "arg": { instType: 'SPOT', channel: "ticker", instId: "BTCUSDT" },
    //       "data": [
    //         {
    //           "instId": "BTCUSDT",
    //           "last": "21150.53",
    //           "open24h": "20759.65",
    //           "high24h": "21202.29",
    //           "low24h": "20518.82",
    //           "bestBid": "21150.500000",
    //           "bestAsk": "21150.600000",
    //           "baseVolume": "25402.1961",
    //           "quoteVolume": "530452554.2156",
    //           "ts": 1656408934044,
    //           "labeId": 0
    //         }
    //       ]
    //   }
    // pong message
    //    "pong"
    //
    // login
    //
    //     { event: "login", code: 0 }
    //
    // subscribe
    //
    //    {
    //        "event": "subscribe",
    //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
    //    }
    // unsubscribe
    //    {
    //        "op":"unsubscribe",
    //        "args":[
    //          {
    //            "instType":"USDT-FUTURES",
    //            "channel":"ticker",
    //            "instId":"BTCUSDT"
    //          }
    //        ]
    //    }
    //
    // uta
    //
    //     {
    //         "action": "snapshot",
    //         "arg": { "instType": "spot", topic: "ticker", symbol: "BTCUSDT" },
    //         "data": [
    //             {
    //                 "highPrice24h": "120255.61",
    //                 "lowPrice24h": "116145.88",
    //                 "openPrice24h": "118919.38",
    //                 "lastPrice": "119818.83",
    //                 "turnover24h": "215859996.272276",
    //                 "volume24h": "1819.756798",
    //                 "bid1Price": "119811.26",
    //                 "ask1Price": "119831.18",
    //                 "bid1Size": "0.008732",
    //                 "ask1Size": "0.004297",
    //                 "price24hPcnt": "0.02002"
    //             }
    //         ],
    //         "ts": 1753230479687
    //     }
    //
    // unsubscribe
    //
    //     {
    //         "event": "unsubscribe",
    //         "arg": {
    //             "instType": "spot",
    //             "topic": "kline",
    //             "symbol": "BTCUSDT",
    //             "interval": "1m"
    //         }
    //     }
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var content interface{} = this.SafeString(message, "message")
    if ccxt.IsTrue(ccxt.IsEqual(content, "pong")) {
        this.HandlePong(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "login")) {
        this.HandleAuthenticate(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "subscribe")) {
        this.HandleSubscriptionStatus(client, message)
        return
    }
    if ccxt.IsTrue(ccxt.IsEqual(event, "unsubscribe")) {
        this.HandleUnSubscriptionStatus(client, message)
        return
    }
    var methods interface{} = map[string]interface{} {
        "ticker": this.HandleTicker,
        "trade": this.HandleTrades,
        "publicTrade": this.HandleTrades,
        "fill": this.HandleMyTrades,
        "order": this.HandleOrder,
        "orders": this.HandleOrder,
        "ordersAlgo": this.HandleOrder,
        "orders-algo": this.HandleOrder,
        "orders-crossed": this.HandleOrder,
        "orders-isolated": this.HandleOrder,
        "account": this.HandleBalance,
        "position": this.HandlePositions,
        "positions": this.HandlePositions,
        "account-isolated": this.HandleBalance,
        "account-crossed": this.HandleBalance,
        "kline": this.HandleOHLCV,
    }
    var arg interface{} = this.SafeValue(message, "arg", map[string]interface{} {})
    var topic interface{} = this.SafeValue2(arg, "channel", "topic", "")
    var method interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "candle"), 0)) {
        this.HandleOHLCV(client, message)
    }
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, "books"), 0)) {
        this.HandleOrderBook(client, message)
    }
}
func  (this *BitgetCore) Ping(client interface{}) interface{}  {
    return "ping"
}
func  (this *BitgetCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *BitgetCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "event": "subscribe",
    //        "arg": { instType: 'SPOT', channel: "account", instId: "default" }
    //    }
    //
    return message
}
func  (this *BitgetCore) HandleOrderBookUnSubscription(client interface{}, message interface{})  {
    //
    //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"books","instId":"BTCUSDT"}}
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var instId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:orderbook:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("orderbook:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " orderbook "), symbol))
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), subMessageHash)) {
        client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *BitgetCore) HandleTradesUnSubscription(client interface{}, message interface{})  {
    //
    //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"trade","instId":"BTCUSDT"}}
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var instId interface{} = this.SafeString2(arg, "instId", "symbol")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:trade:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("trade:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
        ccxt.Remove(this.Trades, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " trades "), symbol))
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), subMessageHash)) {
        client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *BitgetCore) HandleTickerUnSubscription(client interface{}, message interface{})  {
    //
    //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"trade","instId":"BTCUSDT"}}
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var instId interface{} = this.SafeString2(arg, "instId", "symbol")
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("unsubscribe:ticker:", ccxt.GetValue(market, "symbol"))
    var subMessageHash interface{} = ccxt.Add("ticker:", symbol)
    if ccxt.IsTrue(ccxt.InOp(this.Tickers, symbol)) {
        ccxt.Remove(this.Tickers, symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subMessageHash)
    }
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
    }
    error := ccxt.UnsubscribeError(ccxt.Add(ccxt.Add(this.Id, " ticker "), symbol))
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), subMessageHash)) {
        client.(ccxt.ClientInterface).Reject(error, subMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(true, messageHash)
}
func  (this *BitgetCore) HandleOHLCVUnSubscription(client interface{}, message interface{})  {
    //
    //    {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"candle1m","instId":"BTCUSDT"}}
    //
    // UTA
    //
    //    {"event":"unsubscribe","arg":{"instType":"spot","topic":"kline","symbol":"BTCUSDT","interval":"1m"}}
    //
    var arg interface{} = this.SafeDict(message, "arg", map[string]interface{} {})
    var instType interface{} = this.SafeStringLower(arg, "instType")
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(instType, "spot"))), "spot", "contract")
    var instId interface{} = this.SafeString2(arg, "instId", "symbol")
    var channel interface{} = this.SafeString2(arg, "channel", "topic")
    var interval interface{} = this.SafeString(arg, "interval")
    var isUta interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(interval, nil)) {
        isUta = false
        interval = ccxt.Replace(channel, "candle", "")
    } else {
        isUta = true
    }
    var timeframes interface{} = this.SafeValue(this.Options, "timeframes")
    var timeframe interface{} = this.FindTimeframe(interval, timeframes)
    var market interface{} = this.SafeMarket(instId, nil, nil, typeVar)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = nil
    var subMessageHash interface{} = nil
    if ccxt.IsTrue(isUta) {
        messageHash = ccxt.Add("unsubscribe:kline:", symbol)
        subMessageHash = ccxt.Add("kline:", symbol)
    } else {
        messageHash = ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:candles:", timeframe), ":"), symbol)
        subMessageHash = ccxt.Add(ccxt.Add(ccxt.Add("candles:", timeframe), ":"), symbol)
    }
    if ccxt.IsTrue(ccxt.InOp(this.Ohlcvs, symbol)) {
        if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)) {
            ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        }
    }
    this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
}
func  (this *BitgetCore) HandleUnSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //  {
    //      "op":"unsubscribe",
    //      "args":[
    //        {
    //          "instType":"USDT-FUTURES",
    //          "channel":"ticker",
    //          "instId":"BTCUSDT"
    //        },
    //        {
    //          "instType":"USDT-FUTURES",
    //          "channel":"candle1m",
    //          "instId":"BTCUSDT"
    //        }
    //      ]
    //  }
    //  or
    // {"event":"unsubscribe","arg":{"instType":"SPOT","channel":"books","instId":"BTCUSDT"}}
    //
    var argsList interface{} = this.SafeList(message, "args")
    if ccxt.IsTrue(ccxt.IsEqual(argsList, nil)) {
        argsList = []interface{}{this.SafeDict(message, "arg", map[string]interface{} {})}
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(argsList)); i++ {
        var arg interface{} = ccxt.GetValue(argsList, i)
        var channel interface{} = this.SafeString2(arg, "channel", "topic")
        if ccxt.IsTrue(ccxt.IsEqual(channel, "books")) {
            // for now only unWatchOrderBook is supporteod
            this.HandleOrderBookUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(channel, "trade"))) || ccxt.IsTrue((ccxt.IsEqual(channel, "publicTrade")))) {
            this.HandleTradesUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.IsEqual(channel, "ticker")) {
            this.HandleTickerUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.StartsWith(channel, "candle")) {
            this.HandleOHLCVUnSubscription(client, message)
        } else if ccxt.IsTrue(ccxt.StartsWith(channel, "kline")) {
            this.HandleOHLCVUnSubscription(client, message)
        }
    }
    return message
}


func (this *BitgetCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
