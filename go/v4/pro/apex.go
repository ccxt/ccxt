package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ApexCore struct {
	*ccxt.ApexCore
	base *ccxt.ApexCore
}

func NewApexCore() *ApexCore {
    p := &ApexCore{}
	base := &ccxt.ApexCore{}
	p.base = base
	p.ApexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ApexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPositions": true,
            "watchMyTrades": true,
            "watchBalance": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://omni.apex.exchange/assets/logo_content-CY9uyFbz.svg",
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://quote.omni.apex.exchange/realtime_public?v=2",
                    "private": "wss://quote.omni.apex.exchange/realtime_private?v=2",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://qa-quote.omni.apex.exchange/realtime_public?v=2",
                    "private": "wss://qa-quote.omni.apex.exchange/realtime_private?v=2",
                },
            },
            "www": "https://apex.exchange/",
            "doc": "https://api-docs.pro.apex.exchange",
            "fees": "https://apex-pro.gitbook.io/apex-pro/apex-omni-live-now/trading-perpetual-contracts/trading-fees",
            "referral": "https://omni.apex.exchange/trade",
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 18000,
        },
    })
}
/**
 * @method
 * @name apex#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *ApexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes7015 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes7015)
                ch <- retRes7015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *ApexCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes858)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "&timestamp="), timeStamp)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add("recentlyTrade.H.", ccxt.GetValue(market, "id2"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("trade:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
        
            trades:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "recentlyTrade.H.BTCUSDT",
    //         "type": "snapshot",
    //         "ts": 1672304486868,
    //         "data": [
    //             {
    //                 "T": 1672304486865,
    //                 "s": "BTCUSDT",
    //                 "S": "Buy",
    //                 "v": "0.001",
    //                 "p": "16578.50",
    //                 "L": "PlusTick",
    //                 "i": "20f43950-d8dd-5b31-9112-a178eb6023ef",
    //                 "BT": false
    //             },
    //             // sorted by newest first
    //         ]
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var trades interface{} = data
    var parts interface{} = ccxt.Split(topic, ".")
    var marketId interface{} = this.SafeString(parts, 2)
    var market interface{} = this.SafeMarket(marketId, nil, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var length interface{} =     ccxt.GetArrayLength(trades)
    for j := 0; ccxt.IsLessThan(j, length); j++ {
        var index interface{} = ccxt.Subtract(ccxt.Subtract(length, j), 1)
        var parsed interface{} = this.ParseWsTrade(ccxt.GetValue(trades, index), market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *ApexCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public
    //    {
    //         "T": 1672304486865,
    //         "s": "BTCUSDT",
    //         "S": "Buy",
    //         "v": "0.001",
    //         "p": "16578.50",
    //         "L": "PlusTick",
    //         "i": "20f43950-d8dd-5b31-9112-a178eb6023af",
    //         "BT": false
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeStringN(trade, []interface{}{"i", "id", "v"})
    var marketId interface{} = this.SafeStringN(trade, []interface{}{"s", "symbol"})
    market = this.SafeMarket(marketId, market, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"t", "T", "createdAt"})
    var side interface{} = this.SafeStringLowerN(trade, []interface{}{"S", "side"})
    var price interface{} = this.SafeStringN(trade, []interface{}{"p", "price"})
    var amount interface{} = this.SafeStringN(trade, []interface{}{"q", "v", "size"})
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": nil,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name apex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ApexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes20615 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes20615)
                ch <- retRes20615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ApexCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2208)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            symbols = this.MarketSymbols(symbols)
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "&timestamp="), timeStamp)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                    limit = 25
                }
                var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add("orderBook", ccxt.ToString(limit)), ".H."), ccxt.GetValue(market, "id2"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("orderbook:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
        
            orderbook:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ApexCore) WatchTopics(url interface{}, messageHashes interface{}, topics interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "op": "subscribe",
                "args": topics,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes25115 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes25115)
                ch <- retRes25115
                return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "orderbook25.H.BTCUSDT",
    //         "type": "snapshot",
    //         "ts": 1672304484978,
    //         "data": {
    //             "s": "BTCUSDT",
    //             "b": [
    //                 ...,
    //                 [
    //                     "16493.50",
    //                     "0.006"
    //                 ],
    //                 [
    //                     "16493.00",
    //                     "0.100"
    //                 ]
    //             ],
    //             "a": [
    //                 [
    //                     "16611.00",
    //                     "0.029"
    //                 ],
    //                 [
    //                     "16612.00",
    //                     "0.213"
    //                 ],
    //             ],
    //             "u": 18521288,
    //             "seq": 7961638724
    //         }
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var isSnapshot interface{} =     (ccxt.IsEqual(typeVar, "snapshot"))
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId, nil, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeIntegerProduct(message, "ts", 0.001)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(isSnapshot) {
        var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "b", "a")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeList(data, "a", []interface{}{})
        var bids interface{} = this.SafeList(data, "b", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *ApexCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *ApexCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name apex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ApexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3368)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "&timestamp="), timeStamp)
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
            var topic interface{} = ccxt.Add(ccxt.Add("instrumentInfo", ".H."), ccxt.GetValue(market, "id2"))
            var topics interface{} = []interface{}{topic}
        
                retRes34415 :=  (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
                ccxt.PanicOnError(retRes34415)
                ch <- retRes34415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ApexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3578)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "&timestamp="), timeStamp)
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var topic interface{} = ccxt.Add(ccxt.Add("instrumentInfo", ".H."), ccxt.GetValue(market, "id2"))
                ccxt.AppendToArray(&topics, topic)
                var messageHash interface{} = ccxt.Add("ticker:", symbol)
                ccxt.AppendToArray(&messageHashes, messageHash)
            }
        
            ticker:= (<-this.WatchTopics(url, messageHashes, topics, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleTicker(client interface{}, message interface{})  {
    // "topic":"instrumentInfo.H.BTCUSDT",
    //     "type":"snapshot",
    //     "data":{
    //     "symbol":"BTCUSDT",
    //         "lastPrice":"21572.5",
    //         "price24hPcnt":"-0.0194318181818182",
    //         "highPrice24h":"25306.5",
    //         "lowPrice24h":"17001.5",
    //         "turnover24h":"1334891.4545",
    //         "volume24h":"64.896",
    //         "nextFundingTime":"2022-08-26T08:00:00Z",
    //         "oraclePrice":"21412.060000000002752512",
    //         "indexPrice":"21409.82",
    //         "openInterest":"49.598",
    //         "tradeCount":"0",
    //         "fundingRate":"0.0000125",
    //         "predictedFundingRate":"0.0000125"
    // },
    //     "cs":44939063,
    //     "ts":1661500091955487
    // }
    var topic interface{} = this.SafeString(message, "topic", "")
    var updateType interface{} = this.SafeString(message, "type", "")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var symbol interface{} = nil
    var parsed interface{} = nil
    if ccxt.IsTrue((ccxt.IsEqual(updateType, "snapshot"))) {
        parsed = this.ParseTicker(data)
        symbol = ccxt.GetValue(parsed, "symbol")
    } else if ccxt.IsTrue(ccxt.IsEqual(updateType, "delta")) {
        var topicParts interface{} = ccxt.Split(topic, ".")
        var topicLength interface{} =         ccxt.GetArrayLength(topicParts)
        var marketId interface{} = this.SafeString(topicParts, ccxt.Subtract(topicLength, 1))
        var market interface{} = this.SafeMarket(marketId, nil, nil)
        symbol = ccxt.GetValue(market, "symbol")
        var ticker interface{} = this.SafeDict(this.Tickers, symbol, map[string]interface{} {})
        var rawTicker interface{} = this.SafeDict(ticker, "info", map[string]interface{} {})
        var merged interface{} = this.Extend(rawTicker, data)
        parsed = this.ParseTicker(merged)
    }
    var timestamp interface{} = this.SafeIntegerProduct(message, "ts", 0.001)
    ccxt.AddElementToObject(parsed, "timestamp", timestamp)
    ccxt.AddElementToObject(parsed, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(this.Tickers, symbol, parsed)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
/**
 * @method
 * @name apex#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ApexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.pro.apex.exchange/#websocket-v3-for-omni-websocket-endpoint
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ApexCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4598 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4598)
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "&timestamp="), timeStamp)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                symbolString = ccxt.GetValue(market, "id2")
                var unfiedTimeframe interface{} = this.SafeString(data, 1, "1")
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add("candle.", timeframeId), "."), symbolString))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), unfiedTimeframe))
            }
            symboltimeframestoredVariable := (<-this.WatchTopics(url, messageHashes, rawHashes, params))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "candle.5.BTCUSDT",
    //         "data": [
    //             {
    //                 "start": 1672324800000,
    //                 "end": 1672325099999,
    //                 "interval": "5",
    //                 "open": "16649.5",
    //                 "close": "16677",
    //                 "high": "16677",
    //                 "low": "16608",
    //                 "volume": "2.081",
    //                 "turnover": "34666.4005",
    //                 "confirm": false,
    //                 "timestamp": 1672324988882
    //             }
    //         ],
    //         "ts": 1672324988882,
    //         "type": "snapshot"
    //     }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var topicParts interface{} = ccxt.Split(topic, ".")
    var topicLength interface{} =     ccxt.GetArrayLength(topicParts)
    var timeframeId interface{} = this.SafeString(topicParts, 1)
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var marketId interface{} = this.SafeString(topicParts, ccxt.Subtract(topicLength, 1))
    var isSpot interface{} = ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), ccxt.OpNeg(1))
    var marketType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
    var market interface{} = this.SafeMarket(marketId, nil, nil, marketType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var parsed interface{} = this.ParseWsOHLCV(ccxt.GetValue(data, i))
        stored.(ccxt.Appender).Append(parsed)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *ApexCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "start": 1670363160000,
    //         "end": 1670363219999,
    //         "interval": "1",
    //         "open": "16987.5",
    //         "close": "16987.5",
    //         "high": "16988",
    //         "low": "16987.5",
    //         "volume": "23.511",
    //         "turnover": "399396.344",
    //         "confirm": false,
    //         "timestamp": 1670363219614
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "start"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber2(ohlcv, "volume", "turnover")}
}
/**
 * @method
 * @name apex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://api-docs.pro.apex.exchange/#private-websocket
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ApexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var messageHash interface{} = "myTrades"
        
            retRes5738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5738)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "&timestamp="), timeStamp)
        
            retRes5808 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes5808)
        
            trades:= (<-this.WatchTopics(url, []interface{}{messageHash}, []interface{}{"myTrades"}, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchPositions
 * @see https://api-docs.pro.apex.exchange/#private-websocket
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *ApexCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6008 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6008)
            var messageHash interface{} = ""
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.MarketSymbols(symbols)
                messageHash = ccxt.Add("::", ccxt.Join(symbols, ","))
            }
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "&timestamp="), timeStamp)
            messageHash = ccxt.Add("positions", messageHash)
            var client interface{} = this.Client(url)
        
            retRes6108 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes6108)
            this.SetPositionsCache(client, symbols)
            var cache interface{} = this.Positions
            if ccxt.IsTrue(ccxt.IsEqual(cache, nil)) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
            var topics interface{} = []interface{}{"positions"}
        
            newPositions:= (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name apex#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://api-docs.pro.apex.exchange/#private-websocket
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ApexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6378)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var timeStamp interface{} = ccxt.ToString(this.Milliseconds())
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "&timestamp="), timeStamp)
        
            retRes6458 := (<-this.Authenticate(url))
            ccxt.PanicOnError(retRes6458)
            var topics interface{} = []interface{}{"orders"}
        
            orders:= (<-this.WatchTopics(url, []interface{}{messageHash}, topics, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleMyTrades(client interface{}, lists interface{})  {
    // [
    //     {
    //         "symbol":"ETH-USDT",
    //         "side":"BUY",
    //         "orderId":"2048046080",
    //         "fee":"0.625000",
    //         "liquidity":"TAKER",
    //         "accountId":"1024000",
    //         "createdAt":1652185521361,
    //         "isOpen":true,
    //         "size":"0.500",
    //         "price":"2500.0",
    //         "quoteAmount":"1250.0000",
    //         "id":"2048000182272",
    //         "updatedAt":1652185678345
    //     }
    // ]
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trades interface{} = this.MyTrades
    var symbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(lists)); i++ {
        var rawTrade interface{} = ccxt.GetValue(lists, i)
        var parsed interface{} = nil
        parsed = this.ParseWsTrade(rawTrade)
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        trades.(ccxt.Appender).Append(parsed)
    }
    var keys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var currentMessageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(keys, i))
        client.(ccxt.ClientInterface).Resolve(trades, currentMessageHash)
    }
    // non-symbol specific
    var messageHash interface{} = "myTrades"
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
}
func  (this *ApexCore) HandleOrder(client interface{}, lists interface{})  {
    // [
    //     {
    //         "symbol":"ETH-USDT",
    //         "cumSuccessFillFee":"0.625000",
    //         "trailingPercent":"0",
    //         "type":"LIMIT",
    //         "unfillableAt":1654779600000,
    //         "isDeleverage":false,
    //         "createdAt":1652185521339,
    //         "price":"2500.0",
    //         "cumSuccessFillValue":"0",
    //         "id":"2048046080",
    //         "cancelReason":"",
    //         "timeInForce":1,
    //         "updatedAt":1652185521392,
    //         "limitFee":"0.625000",
    //         "side":"BUY",
    //         "clientOrderId":"522843990",
    //         "triggerPrice":"",
    //         "expiresAt":1654779600000,
    //         "cumSuccessFillSize":"0",
    //         "accountId":"1024000",
    //         "size":"0.500",
    //         "reduceOnly":false,
    //         "isLiquidate":false,
    //         "remainingSize":"0.000",
    //         "status":"PENDING"
    //     }
    // ]
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var symbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(lists)); i++ {
        var parsed interface{} = nil
        parsed = this.ParseOrder(ccxt.GetValue(lists, i))
        var symbol interface{} = ccxt.GetValue(parsed, "symbol")
        ccxt.AddElementToObject(symbols, symbol, true)
        orders.(ccxt.Appender).Append(parsed)
    }
    var symbolsArray interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsArray)); i++ {
        var currentMessageHash interface{} = ccxt.Add("orders:", ccxt.GetValue(symbolsArray, i))
        client.(ccxt.ClientInterface).Resolve(orders, currentMessageHash)
    }
    var messageHash interface{} = "orders"
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
func  (this *ApexCore) SetPositionsCache(client interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    if ccxt.IsTrue(!ccxt.IsEqual(this.Positions, nil)) {
        return
    }
    var messageHash interface{} = "fetchPositionsSnapshot"
    if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
        client.(ccxt.ClientInterface).Future(messageHash)
        this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
    }
}
func  (this *ApexCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // as only one ws channel gives positions for all types, for snapshot must load all positions
            var fetchFunctions interface{} = []interface{}{this.FetchPositions(nil)}
        
            promises:= (<-ccxt.PromiseAll(fetchFunctions))
            ccxt.PanicOnError(promises)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(promises)); i++ {
                var positions interface{} = ccxt.GetValue(promises, i)
                for ii := 0; ccxt.IsLessThan(ii, ccxt.GetArrayLength(positions)); ii++ {
                    var position interface{} = ccxt.GetValue(positions, ii)
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "positions")
            }
                return nil
            }()
            return ch
        }
func  (this *ApexCore) HandlePositions(client interface{}, lists interface{})  {
    //
    // [
    //     {
    //         "symbol":"ETH-USDT",
    //         "exitPrice":"0",
    //         "side":"LONG",
    //         "maxSize":"2820.000",
    //         "sumOpen":"1.820",
    //         "sumClose":"0.000",
    //         "netFunding":"0.000000",
    //         "entryPrice":"2500.000000000000000000",
    //         "accountId":"1024000",
    //         "createdAt":1652179377769,
    //         "size":"1.820",
    //         "realizedPnl":"0",
    //         "closedAt":1652185521392,
    //         "updatedAt":1652185521392
    //     }
    // ]
    //
    // each account is connected to a different endpoint
    // and has exactly one subscriptionhash which is the account type
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(lists)); i++ {
        var rawPosition interface{} = ccxt.GetValue(lists, i)
        var position interface{} = this.ParsePosition(rawPosition)
        var side interface{} = this.SafeString(position, "side")
        // hacky solution to handle closing positions
        // without crashing, we should handle this properly later
        ccxt.AppendToArray(&newPositions, position)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(side, nil)) || ccxt.IsTrue(ccxt.IsEqual(side, ""))) {
            // closing update, adding both sides to "reset" both sides
            // since we don't know which side is being closed
            ccxt.AddElementToObject(position, "side", "long")
            cache.(ccxt.Appender).Append(position)
            ccxt.AddElementToObject(position, "side", "short")
            cache.(ccxt.Appender).Append(position)
            ccxt.AddElementToObject(position, "side", nil)
        } else {
            // regular update
            cache.(ccxt.Appender).Append(position)
        }
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
func  (this *ApexCore) Authenticate(url interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var timestamp interface{} = ccxt.ToString(this.Milliseconds())
            var request_path interface{} = "/ws/accounts"
            var http_method interface{} = "GET"
            var messageString interface{} =     (ccxt.Add(ccxt.Add(timestamp, http_method), request_path))
            var signature interface{} = this.Hmac(this.Encode(messageString), this.Encode(this.StringToBase64(this.Secret)), ccxt.Sha256, "base64")
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                // auth sign
                var request interface{} = map[string]interface{} {
                    "type": "login",
                    "topics": []interface{}{"ws_zk_accounts_v3"},
                    "httpMethod": http_method,
                    "requestPath": request_path,
                    "apiKey": this.ApiKey,
                    "passphrase": this.Password,
                    "timestamp": timestamp,
                    "signature": signature,
                }
                var message interface{} = map[string]interface{} {
                    "op": "login",
                    "args": []interface{}{ccxt.JsonStringify(request)},
                }
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes87315 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes87315)
                ch <- retRes87315
                return nil
        
            }()
            return ch
        }
func  (this *ApexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "success": false,
    //       "ret_msg": "error:invalid op",
    //       "conn_id": "5e079fdd-9c7f-404d-9dbf-969d650838b5",
    //       "request": { op: '', args: null }
    //   }
    //
    // auth error
    //
    //   {
    //       "success": false,
    //       "ret_msg": "error:USVC1111",
    //       "conn_id": "e73770fb-a0dc-45bd-8028-140e20958090",
    //       "request": {
    //         "op": "auth",
    //         "args": [
    //           "9rFT6uR4uz9Imkw4Wx",
    //           "1653405853543",
    //           "542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889"
    //         ]
    //   }
    //
    //   { code: '-10009', desc: "Invalid period!" }
    //
    //   {
    //       "reqId":"1",
    //       "retCode":170131,
    //       "retMsg":"Insufficient balance.",
    //       "op":"order.create",
    //       "data":{
    //
    //       },
    //       "header":{
    //           "X-Bapi-Limit":"20",
    //           "X-Bapi-Limit-Status":"19",
    //           "X-Bapi-Limit-Reset-Timestamp":"1714236608944",
    //           "Traceid":"3d7168a137bf32a947b7e5e6a575ac7f",
    //           "Timenow":"1714236608946"
    //       },
    //       "connId":"cojifin88smerbj9t560-406"
    //   }
    //
    var code interface{} = this.SafeStringN(message, []interface{}{"code", "ret_code", "retCode"})
    
        {
            ret__ := func(this *ApexCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *ApexCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(error, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                var messageHash interface{} = this.SafeString(message, "reqId")
                client.(ccxt.ClientInterface).Reject(error, messageHash)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(code, nil)) && ccxt.IsTrue(!ccxt.IsEqual(code, "0"))) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
                var msg interface{} = this.SafeString2(message, "retMsg", "ret_msg")
                this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), msg, feedback)
                panic(ccxt.ExchangeError(feedback))
            }
            var success interface{} = this.SafeValue(message, "success")
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(success, nil)) && !ccxt.IsTrue(success)) {
                var ret_msg interface{} = this.SafeString(message, "ret_msg")
                var request interface{} = this.SafeValue(message, "request", map[string]interface{} {})
                var op interface{} = this.SafeString(request, "op")
                if ccxt.IsTrue(ccxt.IsEqual(op, "auth")) {
                    panic(ccxt.AuthenticationError(ccxt.Add("Authentication failed: ", ret_msg)))
                } else {
                    panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), ret_msg)))
                }
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *ApexCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var topic interface{} = this.SafeString2(message, "topic", "op", "")
    var methods interface{} = map[string]interface{} {
        "ws_zk_accounts_v3": this.HandleAccount,
        "orderBook": this.HandleOrderBook,
        "depth": this.HandleOrderBook,
        "candle": this.HandleOHLCV,
        "kline": this.HandleOHLCV,
        "ticker": this.HandleTicker,
        "instrumentInfo": this.HandleTicker,
        "trade": this.HandleTrades,
        "recentlyTrade": this.HandleTrades,
        "pong": this.HandlePong,
        "auth": this.HandleAuthenticate,
        "ping": this.HandlePing,
    }
    var exacMethod interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(exacMethod, nil)) {
        ccxt.CallDynamically(exacMethod, client, message)
        return
    }
    var keys interface{} = ccxt.ObjectKeys(methods)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(topic, ccxt.GetValue(keys, i)), 0)) {
            var method interface{} = ccxt.GetValue(methods, key)
            ccxt.CallDynamically(method, client, message)
            return
        }
    }
    // unified auth acknowledgement
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "AUTH_RESP")) {
        this.HandleAuthenticate(client, message)
    }
}
func  (this *ApexCore) Ping(client interface{}) interface{}  {
    var timeStamp interface{} = this.Milliseconds()
    client.(ccxt.ClientInterface).SetLastPong(timeStamp)
    return map[string]interface{} {
        "args": []interface{}{ccxt.ToString(timeStamp)},
        "op": "ping",
    }
}
func  (this *ApexCore) Pong(client interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    //
            //     {"op": "ping", "args": ["1761069137485"]}
            //
            var timeStamp interface{} = this.Milliseconds()
            
                {
                     func(this *ApexCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *ApexCore) interface{} {
                                    // catch block:
                                            error := ccxt.NetworkError(ccxt.Add(ccxt.Add(this.Id, " handlePing failed with error "), this.ExceptionMessage(e)))
                    client.(ccxt.ClientInterface).Reset(error)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                        
                    retRes101112 := (<-client.(ccxt.ClientInterface).Send(map[string]interface{} {
                        "args": []interface{}{ccxt.ToString(timeStamp)},
                        "op": "pong",
                    }))
                    ccxt.PanicOnError(retRes101112)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *ApexCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "success": true,
    //       "ret_msg": "pong",
    //       "conn_id": "db3158a0-8960-44b9-a9de-ac350ee13158",
    //       "request": { op: "ping", args: null }
    //   }
    //
    //   { pong: 1653296711335 }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.SafeInteger(message, "pong", this.Milliseconds()))
    return message
}
func  (this *ApexCore) HandlePing(client interface{}, message interface{})  {
    this.Spawn(this.Pong, client, message)
}
func  (this *ApexCore) HandleAccount(client interface{}, message interface{})  {
    var contents interface{} = this.SafeDict(message, "contents", map[string]interface{} {})
    var fills interface{} = this.SafeList(contents, "fills", []interface{}{})
    if ccxt.IsTrue(!ccxt.IsEqual(fills, nil)) {
        this.HandleMyTrades(client, fills)
    }
    var positions interface{} = this.SafeList(contents, "positions", []interface{}{})
    if ccxt.IsTrue(!ccxt.IsEqual(positions, nil)) {
        this.HandlePositions(client, positions)
    }
    var orders interface{} = this.SafeList(contents, "orders", []interface{}{})
    if ccxt.IsTrue(!ccxt.IsEqual(orders, nil)) {
        this.HandleOrder(client, orders)
    }
}
func  (this *ApexCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "success": true,
    //        "ret_msg": '',
    //        "op": "auth",
    //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
    //    }
    //
    var success interface{} = this.SafeValue(message, "success")
    var code interface{} = this.SafeInteger(message, "retCode")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(ccxt.IsTrue(success) || ccxt.IsTrue(ccxt.IsEqual(code, 0))) {
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
    return message
}
func  (this *ApexCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "topic": "kline",
    //        "event": "sub",
    //        "params": {
    //          "symbol": "LTCUSDT",
    //          "binary": "false",
    //          "klineType": "1m",
    //          "symbolName": "LTCUSDT"
    //        },
    //        "code": "0",
    //        "msg": "Success"
    //    }
    //
    return message
}


func (this *ApexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
