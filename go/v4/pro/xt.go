package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type XtCore struct {
	*ccxt.XtCore
	base *ccxt.XtCore
}

func NewXtCore() *XtCore {
    p := &XtCore{}
	base := &ccxt.XtCore{}
	p.base = base
	p.XtCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *XtCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOHLCV": true,
            "unWatchOHLCV": true,
            "watchOrderBook": true,
            "unWatchOrderBook": true,
            "watchTicker": true,
            "unWatchTicker": true,
            "watchTickers": true,
            "unWatchTickers": true,
            "watchTrades": true,
            "unWatchTrades": true,
            "watchTradesForSymbols": false,
            "watchBalance": true,
            "watchOrders": true,
            "watchMyTrades": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://stream.xt.com",
                    "contract": "wss://fstream.xt.com/ws",
                },
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "watchTicker": map[string]interface{} {
                "method": "ticker",
            },
            "watchTickers": map[string]interface{} {
                "method": "tickers",
            },
            "watchPositions": map[string]interface{} {
                "type": "swap",
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 20000,
            "ping": this.Ping,
        },
        "token": nil,
    })
}
/**
 * @ignore
 * @method
 * @description required for private endpoints
 * @param {string} isContract true for contract trades
 * @see https://doc.xt.com/#websocket_privategetToken
 * @see https://doc.xt.com/#futures_user_websocket_v2base
 * @returns {string} listen key / access token
 */
func  (this *XtCore) GetListenKey(isContract interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    this.CheckRequiredCredentials()
            var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue(isContract), "contract", "spot")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), tradeType)
            if !ccxt.IsTrue(isContract) {
                url = ccxt.Add(url, "/private")
            }
            var client interface{} = this.Client(url)
            var token interface{} = this.SafeString(client.(ccxt.ClientInterface).GetSubscriptions(), "token")
            if ccxt.IsTrue(ccxt.IsEqual(token, nil)) {
                if ccxt.IsTrue(isContract) {
        
                    response:= (<-this.PrivateLinearGetFutureUserV1UserListenKey())
                    ccxt.PanicOnError(response)
                    //
                    //    {
                    //        returnCode: '0',
                    //        msgInfo: 'success',
                    //        error: null,
                    //        result: '3BC1D71D6CF96DA3458FC35B05B633351684511731128'
                    //    }
                    //
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), "token", this.SafeString(response, "result"))
                } else {
        
                    response:= (<-this.PrivateSpotPostWsToken())
                    ccxt.PanicOnError(response)
                    //
                    //    {
                    //        "rc": 0,
                    //        "mc": "SUCCESS",
                    //        "ma": [],
                    //        "result": {
                    //            "token": "eyJhbqGciOiJSUzI1NiJ9.eyJhY2NvdW50SWQiOiIyMTQ2Mjg1MzIyNTU5Iiwic3ViIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsInNjb3BlIjoiYXV0aCIsImlzcyI6Inh0LmNvbSIsImxhc3RBdXRoVGltZSI6MTY2MzgxMzY5MDk1NSwic2lnblR5cGUiOiJBSyIsInVzZXJOYW1lIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsImV4cCI6MTY2NjQwNTY5MCwiZGV2aWNlIjoidW5rbm93biIsInVzZXJJZCI6MjE0NjI4NTMyMjU1OX0.h3zJlJBQrK2x1HvUxsKivnn6PlSrSDXXXJ7WqHAYSrN2CG5XPTKc4zKnTVoYFbg6fTS0u1fT8wH7wXqcLWXX71vm0YuP8PCvdPAkUIq4-HyzltbPr5uDYd0UByx0FPQtq1exvsQGe7evXQuDXx3SEJXxEqUbq_DNlXPTq_JyScI",
                    //            "refreshToken": "eyJhbGciOiqJSUzI1NiJ9.eyJhY2NvdW50SWQiOiIyMTQ2Mjg1MzIyNTU5Iiwic3ViIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsInNjb3BlIjoicmVmcmVzaCIsImlzcyI6Inh0LmNvbSIsImxhc3RBdXRoVGltZSI6MTY2MzgxMzY5MDk1NSwic2lnblR5cGUiOiJBSyIsInVzZXJOYW1lIjoibGh4dDRfMDAwMUBzbmFwbWFpbC5jYyIsImV4cCI6MTY2NjQwNTY5MCwiZGV2aWNlIjoidW5rbm93biIsInVzZXJJZCI6MjE0NjI4NTMyMjU1OX0.Fs3YVm5YrEOzzYOSQYETSmt9iwxUHBovh2u73liv1hLUec683WGfktA_s28gMk4NCpZKFeQWFii623FvdfNoteXR0v1yZ2519uNvNndtuZICDdv3BQ4wzW1wIHZa1skxFfqvsDnGdXpjqu9UFSbtHwxprxeYfnxChNk4ssei430"
                    //        }
                    //    }
                    //
                    var result interface{} = this.SafeDict(response, "result")
                    ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), "token", this.SafeString(result, "accessToken"))
                }
            }
        
            ch <- ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), "token")
            return nil
        
            }()
            return ch
        }
func  (this *XtCore) GetCacheIndex(orderbook interface{}, cache interface{}) interface{}  {
    // return the first index of the cache that can be applied to the orderbook or -1 if not possible
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    var firstDelta interface{} = this.SafeValue(cache, 0)
    var firstDeltaNonce interface{} = this.SafeInteger2(firstDelta, "i", "u")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(firstDeltaNonce, 1))) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaNonce interface{} = this.SafeInteger2(delta, "i", "u")
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(deltaNonce, nonce)) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
func  (this *XtCore) HandleDelta(orderbook interface{}, delta interface{})  {
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger2(delta, "i", "u"))
    var obAsks interface{} = this.SafeList(delta, "a", []interface{}{})
    var obBids interface{} = this.SafeList(delta, "b", []interface{}{})
    var bids interface{} = ccxt.GetValue(orderbook, "bids")
    var asks interface{} = ccxt.GetValue(orderbook, "asks")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(obBids)); i++ {
        var bid interface{} = ccxt.GetValue(obBids, i)
        var price interface{} = this.SafeNumber(bid, 0)
        var quantity interface{} = this.SafeNumber(bid, 1)
        bids.(ccxt.IOrderBookSide).Store(price, quantity)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(obAsks)); i++ {
        var ask interface{} = ccxt.GetValue(obAsks, i)
        var price interface{} = this.SafeNumber(ask, 0)
        var quantity interface{} = this.SafeNumber(ask, 1)
        asks.(ccxt.IOrderBookSide).Store(price, quantity)
    }
}
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @see https://doc.xt.com/#websocket_privaterequestFormat
 * @see https://doc.xt.com/#futures_market_websocket_v2base
 * @param {string} name name of the channel
 * @param {string} access public or private
 * @param {string} methodName the name of the CCXT class method
 * @param {object} [market] CCXT market
 * @param {string[]} [symbols] unified market symbols
 * @param {object} params extra parameters specific to the xt api
 * @returns {object} data from the websocket stream
 */
func  (this *XtCore) Subscribe(name interface{}, access interface{}, methodName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    market := ccxt.GetArg(optionalArgs, 0, nil)
            _ = market
            symbols := ccxt.GetArg(optionalArgs, 1, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var privateAccess interface{} = ccxt.IsEqual(access, "private")
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isContract interface{} =     (!ccxt.IsEqual(typeVar, "spot"))
            var id interface{} = ccxt.Add(this.NumberToString(this.Milliseconds()), name) // call back ID
            var subscribe interface{} = map[string]interface{} {
                "method": ccxt.Ternary(ccxt.IsTrue(isContract), "SUBSCRIBE", "subscribe"),
                "id": id,
            }
            if ccxt.IsTrue(privateAccess) {
                if !ccxt.IsTrue(isContract) {
                    ccxt.AddElementToObject(subscribe, "params", []interface{}{name})
                    ccxt.AddElementToObject(subscribe, "listenKey", (<-this.GetListenKey(isContract)))
                } else {
        
                    listenKey:= (<-this.GetListenKey(isContract))
                    ccxt.PanicOnError(listenKey)
                    var param interface{} = ccxt.Add(ccxt.Add(name, "@"), listenKey)
                    ccxt.AddElementToObject(subscribe, "params", []interface{}{param})
                }
            } else {
                ccxt.AddElementToObject(subscribe, "params", []interface{}{name})
            }
            var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue(isContract), "contract", "spot")
            var messageHash interface{} = ccxt.Add(ccxt.Add(name, "::"), tradeType)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), ccxt.Join(symbols, ","))
            }
            var request interface{} = this.Extend(subscribe, params)
            var tail interface{} = access
            if ccxt.IsTrue(isContract) {
                tail = ccxt.Ternary(ccxt.IsTrue(privateAccess), "user", "market")
            }
            var subscription interface{} = map[string]interface{} {
                "id": id,
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), tradeType), "/"), tail)
        
                retRes20315 :=  (<-this.Watch(url, messageHash, request, messageHash, subscription))
                ccxt.PanicOnError(retRes20315)
                ch <- retRes20315
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @see https://doc.xt.com/#websocket_privaterequestFormat
 * @see https://doc.xt.com/#futures_market_websocket_v2base
 * @param {string} messageHash the message hash of the subscription
 * @param {string} name name of the channel
 * @param {string} access public or private
 * @param {string} methodName the name of the CCXT class method
 * @param {string} topic topic of the subscription
 * @param {object} [market] CCXT market
 * @param {string[]} [symbols] unified market symbols
 * @param {object} params extra parameters specific to the xt api
 * @param {object} subscriptionParams extra parameters specific to the subscription
 * @returns {object} data from the websocket stream
 */
func  (this *XtCore) UnSubscribe(messageHash interface{}, name interface{}, access interface{}, methodName interface{}, topic interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    market := ccxt.GetArg(optionalArgs, 0, nil)
            _ = market
            symbols := ccxt.GetArg(optionalArgs, 1, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            subscriptionParams := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = subscriptionParams
            var privateAccess interface{} = ccxt.IsEqual(access, "private")
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var isContract interface{} =     (!ccxt.IsEqual(typeVar, "spot"))
            var id interface{} = ccxt.Add(this.NumberToString(this.Milliseconds()), name) // call back ID
            var unsubscribe interface{} = map[string]interface{} {
                "method": ccxt.Ternary(ccxt.IsTrue(isContract), "UNSUBSCRIBE", "unsubscribe"),
                "id": id,
            }
            if ccxt.IsTrue(privateAccess) {
                if !ccxt.IsTrue(isContract) {
                    ccxt.AddElementToObject(unsubscribe, "params", []interface{}{name})
                    ccxt.AddElementToObject(unsubscribe, "listenKey", (<-this.GetListenKey(isContract)))
                } else {
        
                    listenKey:= (<-this.GetListenKey(isContract))
                    ccxt.PanicOnError(listenKey)
                    var param interface{} = ccxt.Add(ccxt.Add(name, "@"), listenKey)
                    ccxt.AddElementToObject(unsubscribe, "params", []interface{}{param})
                }
            } else {
                ccxt.AddElementToObject(unsubscribe, "params", []interface{}{name})
            }
            var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue(isContract), "contract", "spot")
            var subMessageHash interface{} = ccxt.Add(ccxt.Add(name, "::"), tradeType)
            var request interface{} = this.Extend(unsubscribe, params)
            var tail interface{} = access
            if ccxt.IsTrue(isContract) {
                tail = ccxt.Ternary(ccxt.IsTrue(privateAccess), "user", "market")
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), tradeType), "/"), tail)
            var subscription interface{} = map[string]interface{} {
                "unsubscribe": true,
                "id": id,
                "subMessageHashes": []interface{}{subMessageHash},
                "messageHashes": []interface{}{messageHash},
                "symbols": symbols,
                "topic": topic,
            }
            var symbolsAndTimeframes interface{} = this.SafeList(subscriptionParams, "symbolsAndTimeframes")
            if ccxt.IsTrue(!ccxt.IsEqual(symbolsAndTimeframes, nil)) {
                ccxt.AddElementToObject(subscription, "symbolsAndTimeframes", symbolsAndTimeframes)
                subscriptionParams = this.Omit(subscriptionParams, "symbolsAndTimeframes")
            }
        
                retRes26615 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash, this.Extend(subscription, subscriptionParams)))
                ccxt.PanicOnError(retRes26615)
                ch <- retRes26615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.xt.com/#websocket_publictickerRealTime
 * @see https://doc.xt.com/#futures_market_websocket_v2tickerRealTime
 * @see https://doc.xt.com/#futures_market_websocket_v2aggTickerRealTime
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} [params.method] 'agg_ticker' (contract only) or 'ticker', default = 'ticker' - the endpoint that will be streamed
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *XtCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2828 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2828)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeDict(this.Options, "watchTicker")
            var defaultMethod interface{} = this.SafeString(options, "method", "ticker")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            var name interface{} = ccxt.Add(ccxt.Add(method, "@"), ccxt.GetValue(market, "id"))
        
                retRes28815 :=  (<-this.Subscribe(name, "public", "watchTicker", market, nil, params))
                ccxt.PanicOnError(retRes28815)
                ch <- retRes28815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#unWatchTicker
 * @description stops watching a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.xt.com/#websocket_publictickerRealTime
 * @see https://doc.xt.com/#futures_market_websocket_v2tickerRealTime
 * @see https://doc.xt.com/#futures_market_websocket_v2aggTickerRealTime
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} [params.method] 'agg_ticker' (contract only) or 'ticker', default = 'ticker' - the endpoint that will be streamed
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *XtCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3048 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3048)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeDict(this.Options, "unWatchTicker")
            var defaultMethod interface{} = this.SafeString(options, "method", "ticker")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            var name interface{} = ccxt.Add(ccxt.Add(method, "@"), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("unsubscribe::", name)
        
                retRes31115 :=  (<-this.UnSubscribe(messageHash, name, "public", "unWatchTicker", defaultMethod, market, nil, params))
                ccxt.PanicOnError(retRes31115)
                ch <- retRes31115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.xt.com/#websocket_publicallTicker
 * @see https://doc.xt.com/#futures_market_websocket_v2allTicker
 * @see https://doc.xt.com/#futures_market_websocket_v2allAggTicker
 * @param {string} [symbols] unified market symbols
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} [params.method] 'agg_tickers' (contract only) or 'tickers', default = 'tickers' - the endpoint that will be streamed
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *XtCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3278)
            var options interface{} = this.SafeDict(this.Options, "watchTickers")
            var defaultMethod interface{} = this.SafeString(options, "method", "tickers")
            var name interface{} = this.SafeString(params, "method", defaultMethod)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                market = this.Market(ccxt.GetValue(symbols, 0))
            }
        
            tickers:= (<-this.Subscribe(name, "public", "watchTickers", market, symbols, params))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#unWatchTickers
 * @description stops watching a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://doc.xt.com/#websocket_publicallTicker
 * @see https://doc.xt.com/#futures_market_websocket_v2allTicker
 * @see https://doc.xt.com/#futures_market_websocket_v2allAggTicker
 * @param {string} [symbols] unified market symbols
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {string} [params.method] 'agg_tickers' (contract only) or 'tickers', default = 'tickers' - the endpoint that will be streamed
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure}
 */
func  (this *XtCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3558)
            var options interface{} = this.SafeDict(this.Options, "unWatchTickers")
            var defaultMethod interface{} = this.SafeString(options, "method", "tickers")
            var name interface{} = this.SafeString(params, "method", defaultMethod)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchTickers() does not support symbols argument, unsubscribtion is for all tickers at once only")))
            }
            var messageHash interface{} = ccxt.Add("unsubscribe::", name)
        
            tickers:= (<-this.UnSubscribe(messageHash, name, "public", "unWatchTickers", "ticker", nil, symbols, params))
            ccxt.PanicOnError(tickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://doc.xt.com/#websocket_publicsymbolKline
 * @see https://doc.xt.com/#futures_market_websocket_v2symbolKline
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, or 1M
 * @param {int} [since] not used by xt watchOHLCV
 * @param {int} [limit] not used by xt watchOHLCV
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *XtCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3848 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3848)
            var market interface{} = this.Market(symbol)
            var name interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline@", ccxt.GetValue(market, "id")), ","), timeframe)
        
            ohlcv:= (<-this.Subscribe(name, "public", "watchOHLCV", market, nil, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#unWatchOHLCV
 * @description stops watching historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://doc.xt.com/#websocket_publicsymbolKline
 * @see https://doc.xt.com/#futures_market_websocket_v2symbolKline
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, or 1M
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *XtCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4068)
            var market interface{} = this.Market(symbol)
            var name interface{} = ccxt.Add(ccxt.Add(ccxt.Add("kline@", ccxt.GetValue(market, "id")), ","), timeframe)
            var messageHash interface{} = ccxt.Add("unsubscribe::", name)
            var symbolsAndTimeframes interface{} = []interface{}{[]interface{}{ccxt.GetValue(market, "symbol"), timeframe}}
        
                retRes41115 :=  (<-this.UnSubscribe(messageHash, name, "public", "unWatchOHLCV", "ohlcv", market, []interface{}{symbol}, params, map[string]interface{} {
                "symbolsAndTimeframes": symbolsAndTimeframes,
            }))
                ccxt.PanicOnError(retRes41115)
                ch <- retRes41115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://doc.xt.com/#websocket_publicdealRecord
 * @see https://doc.xt.com/#futures_market_websocket_v2dealRecord
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
 */
func  (this *XtCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4278 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4278)
            var market interface{} = this.Market(symbol)
            var name interface{} = ccxt.Add("trade@", ccxt.GetValue(market, "id"))
        
            trades:= (<-this.Subscribe(name, "public", "watchTrades", market, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#unWatchTrades
 * @description stops watching the list of most recent trades for a particular symbol
 * @see https://doc.xt.com/#websocket_publicdealRecord
 * @see https://doc.xt.com/#futures_market_websocket_v2dealRecord
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
 */
func  (this *XtCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4488 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4488)
            var market interface{} = this.Market(symbol)
            var name interface{} = ccxt.Add("trade@", ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add("unsubscribe::", name)
        
                retRes45215 :=  (<-this.UnSubscribe(messageHash, name, "public", "unWatchTrades", "trades", market, []interface{}{symbol}, params))
                ccxt.PanicOnError(retRes45215)
                ch <- retRes45215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://doc.xt.com/#websocket_publiclimitDepth
 * @see https://doc.xt.com/#websocket_publicincreDepth
 * @see https://doc.xt.com/#futures_market_websocket_v2limitDepth
 * @see https://doc.xt.com/#futures_market_websocket_v2increDepth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] not used by xt watchOrderBook
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {int} [params.levels] 5, 10, 20, or 50
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
 */
func  (this *XtCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4708)
            var market interface{} = this.Market(symbol)
            var levels interface{} = this.SafeString(params, "levels")
            params = this.Omit(params, "levels")
            var name interface{} = ccxt.Add("depth_update@", ccxt.GetValue(market, "id"))
            if ccxt.IsTrue(!ccxt.IsEqual(levels, nil)) {
                name = ccxt.Add(ccxt.Add(ccxt.Add("depth@", ccxt.GetValue(market, "id")), ","), levels)
            }
        
            orderbook:= (<-this.Subscribe(name, "public", "watchOrderBook", market, nil, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#unWatchOrderBook
 * @description stops watching information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://doc.xt.com/#websocket_publiclimitDepth
 * @see https://doc.xt.com/#websocket_publicincreDepth
 * @see https://doc.xt.com/#futures_market_websocket_v2limitDepth
 * @see https://doc.xt.com/#futures_market_websocket_v2increDepth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} params extra parameters specific to the xt api endpoint
 * @param {int} [params.levels] 5, 10, 20, or 50
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure} indexed by market symbols
 */
func  (this *XtCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4968)
            var market interface{} = this.Market(symbol)
            var levels interface{} = this.SafeString(params, "levels")
            params = this.Omit(params, "levels")
            var name interface{} = ccxt.Add("depth_update@", ccxt.GetValue(market, "id"))
            if ccxt.IsTrue(!ccxt.IsEqual(levels, nil)) {
                name = ccxt.Add(ccxt.Add(ccxt.Add("depth@", ccxt.GetValue(market, "id")), ","), levels)
            }
            var messageHash interface{} = ccxt.Add("unsubscribe::", name)
        
                retRes50515 :=  (<-this.UnSubscribe(messageHash, name, "public", "unWatchOrderBook", "orderbook", market, []interface{}{symbol}, params))
                ccxt.PanicOnError(retRes50515)
                ch <- retRes50515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://doc.xt.com/#websocket_privateorderChange
 * @see https://doc.xt.com/#futures_user_websocket_v2order
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] not used by xt watchOrders
 * @param {int} [limit] the maximum number of orders to return
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure}
 */
func  (this *XtCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5218 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5218)
            var name interface{} = "order"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            orders:= (<-this.Subscribe(name, "private", "watchOrders", market, nil, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://doc.xt.com/#websocket_privateorderDeal
 * @see https://doc.xt.com/#futures_user_websocket_v2trade
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve
 * @param {object} params extra parameters specific to the kucoin api endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *XtCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5478 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5478)
            var name interface{} = "trade"
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            trades:= (<-this.Subscribe(name, "private", "watchMyTrades", market, nil, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://doc.xt.com/#websocket_privatebalanceChange
 * @see https://doc.xt.com/#futures_user_websocket_v2balance
 * @param {object} params extra parameters specific to the xt api endpoint
 * @returns {object[]} a list of [balance structures]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *XtCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5708)
            var name interface{} = "balance"
        
                retRes57215 :=  (<-this.Subscribe(name, "private", "watchBalance", nil, nil, params))
                ccxt.PanicOnError(retRes57215)
                ch <- retRes57215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name xt#watchPositions
 * @see https://doc.xt.com/#futures_user_websocket_v2position
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {number} [since] since timestamp
 * @param {number} [limit] limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *XtCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5878 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5878)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "contract"), "/"), "user")
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            var cache interface{} = this.Positions
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(this.IsEmpty(cache))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
            var name interface{} = "position"
        
            newPositions:= (<-this.Subscribe(name, "private", "watchPositions", nil, nil, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(cache, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *XtCore) SetPositionsCache(client interface{})  {
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot")
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    }
}
func  (this *XtCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions(nil))
            ccxt.PanicOnError(positions)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "position::contract")
            }
                return nil
            }()
            return ch
        }
func  (this *XtCore) HandlePosition(client interface{}, message interface{})  {
    //
    //    {
    //      topic: 'position',
    //      event: 'position',
    //      data: {
    //        accountId: 245296,
    //        accountType: 0,
    //        symbol: 'eth_usdt',
    //        contractType: 'PERPETUAL',
    //        positionType: 'CROSSED',
    //        positionSide: 'LONG',
    //        positionSize: '1',
    //        closeOrderSize: '0',
    //        availableCloseSize: '1',
    //        realizedProfit: '-0.0121',
    //        entryPrice: '2637.87',
    //        openOrderSize: '1',
    //        isolatedMargin: '2.63787',
    //        openOrderMarginFrozen: '2.78832014',
    //        underlyingType: 'U_BASED',
    //        leverage: 10,
    //        welfareAccount: false,
    //        profitFixedLatest: {},
    //        closeProfit: '0.0000',
    //        totalFee: '-0.0158',
    //        totalFundFee: '0.0037',
    //        markPrice: '2690.96'
    //      }
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var position interface{} = this.ParsePosition(data)
    cache.(ccxt.Appender).Append(position)
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "position::contract")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray([]interface{}{position}, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve([]interface{}{position}, "position::contract")
}
func  (this *XtCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        topic: 'ticker',
    //        event: 'ticker@btc_usdt',
    //        data: {
    //           s: 'btc_usdt',            // symbol
    //           t: 1683501935877,         // time(Last transaction time)
    //           cv: '-82.67',             // priceChangeValue(24 hour price change)
    //           cr: '-0.0028',            // priceChangeRate 24-hour price change (percentage)
    //           o: '28823.87',            // open price
    //           c: '28741.20',            // close price
    //           h: '29137.64',            // highest price
    //           l: '28660.93',            // lowest price
    //           q: '6372.601573',         // quantity
    //           v: '184086075.2772391'    // volume
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "ticker",
    //        "event": "ticker@btc_usdt",
    //        "data": {
    //            "s": "btc_index",  // trading pair
    //            "o": "49000",      // opening price
    //            "c": "50000",      // closing price
    //            "h": "0.1",        // highest price
    //            "l": "0.1",        // lowest price
    //            "a": "0.1",        // volume
    //            "v": "0.1",        // turnover
    //            "ch": "0.21",      // quote change
    //            "t": 123124124     // timestamp
    //       }
    //    }
    //
    // agg_ticker (contract)
    //
    //    {
    //        "topic": "agg_ticker",
    //        "event": "agg_ticker@btc_usdt",
    //        "data": {
    //            "s": "btc_index",          // trading pair
    //            "o": "49000",              // opening price
    //            "c": "50000",              // closing price
    //            "h": "0.1",                // highest price
    //            "l": "0.1",                // lowest price
    //            "a": "0.1",                // volume
    //            "v": "0.1",                // turnover
    //            "ch": "0.21",              // quote change
    //            "i": "0.21" ,              // index price
    //            "m": "0.21",               // mark price
    //            "bp": "0.21",              // bid price
    //            "ap": "0.21" ,             // ask price
    //            "t": 123124124             // timestamp
    //       }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var cv interface{} = this.SafeString(data, "cv")
        var isSpot interface{} = !ccxt.IsEqual(cv, nil)
        var ticker interface{} = this.ParseTicker(data)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        var event interface{} = this.SafeString(message, "event")
        var messageHashTail interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "contract")
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, "::"), messageHashTail)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
    return message
}
func  (this *XtCore) HandleTickers(client interface{}, message interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        topic: 'tickers',
    //        event: 'tickers',
    //        data: [
    //            {
    //                s: 'elon_usdt',
    //                t: 1683502958381,
    //                cv: '-0.0000000125',
    //                cr: '-0.0495',
    //                o: '0.0000002522',
    //                c: '0.0000002397',
    //                h: '0.0000002690',
    //                l: '0.0000002371',
    //                q: '3803783034.0000000000',
    //                v: '955.3260820022'
    //            },
    //            ...
    //        ]
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "tickers",
    //        "event": "tickers",
    //        "data": [
    //            {
    //                "s": "btc_index",  // trading pair
    //                "o": "49000",      // opening price
    //                "c": "50000",      // closing price
    //                "h": "0.1",        // highest price
    //                "l": "0.1",        // lowest price
    //                "a": "0.1",        // volume
    //                "v": "0.1",        // turnover
    //                "ch": "0.21",      // quote change
    //                "t": 123124124     // timestamp
    //            }
    //        ]
    //    }
    //
    // agg_ticker (contract)
    //
    //    {
    //        "topic": "agg_tickers",
    //        "event": "agg_tickers",
    //        "data": [
    //            {
    //                "s": "btc_index",          // trading pair
    //                "o": "49000",              // opening price
    //                "c": "50000",              // closing price
    //                "h": "0.1",                // highest price
    //                "l": "0.1",                // lowest price
    //                "a": "0.1",                // volume
    //                "v": "0.1",                // turnover
    //                "ch": "0.21",              // quote change
    //                "i": "0.21" ,              // index price
    //                "m": "0.21",               // mark price
    //                "bp": "0.21",              // bid price
    //                "ap": "0.21" ,             // ask price
    //                "t": 123124124             // timestamp
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var firstTicker interface{} = this.SafeDict(data, 0)
    var spotTest interface{} = this.SafeString2(firstTicker, "cv", "aq")
    var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(spotTest, nil))), "spot", "contract")
    var newTickers interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var tickerData interface{} = ccxt.GetValue(data, i)
        var ticker interface{} = this.ParseTicker(tickerData)
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        ccxt.AppendToArray(&newTickers, ticker)
    }
    var messageHashStart interface{} = ccxt.Add(ccxt.Add(this.SafeString(message, "topic"), "::"), tradeType)
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), ccxt.Add(messageHashStart, "::"))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 2)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var tickers interface{} = this.FilterByArray(newTickers, "symbol", symbols)
        var tickersSymbols interface{} = ccxt.ObjectKeys(tickers)
        var numTickers interface{} =         ccxt.GetArrayLength(tickersSymbols)
        if ccxt.IsTrue(ccxt.IsGreaterThan(numTickers, 0)) {
            client.(ccxt.ClientInterface).Resolve(tickers, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(this.Tickers, messageHashStart)
    return message
}
func  (this *XtCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        "topic": "kline",
    //        "event": "kline@btc_usdt,5m",
    //        "data": {
    //            "s": "btc_usdt",        // symbol
    //            "t": 1656043200000,     // time
    //            "i": "5m",              // interval
    //            "o": "44000",           // open price
    //            "c": "50000",           // close price
    //            "h": "52000",           // highest price
    //            "l": "36000",           // lowest price
    //            "q": "34.2",            // qty(quantity)
    //            "v": "230000"           // volume
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "kline",
    //        "event": "kline@btc_usdt,5m",
    //        "data": {
    //            "s": "btc_index",      // trading pair
    //            "o": "49000",          // opening price
    //            "c": "50000",          // closing price
    //            "h": "0.1",            // highest price
    //            "l": "0.1",            // lowest price
    //            "a": "0.1",            // volume
    //            "v": "0.1",            // turnover
    //            "ch": "0.21",          // quote change
    //            "t": 123124124         // timestamp
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var timeframe interface{} = this.SafeString(data, "i")
        var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(data, "q"))), "spot", "contract")
        var market interface{} = this.SafeMarket(marketId, nil, nil, tradeType)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var parsed interface{} = this.ParseOHLCV(data, market)
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeDict(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        var event interface{} = this.SafeString(message, "event")
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, "::"), tradeType)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *XtCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        topic: 'trade',
    //        event: 'trade@btc_usdt',
    //        data: {
    //            s: 'btc_usdt',
    //            i: '228825383103928709',
    //            t: 1684258222702,
    //            p: '27003.65',
    //            q: '0.000796',
    //            b: true
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "trade",
    //        "event": "trade@btc_usdt",
    //        "data": {
    //            "s": "btc_index",  // trading pair
    //            "p": "50000",      // price
    //            "a": "0.1"         // Quantity
    //            "m": "BID"         // Deal side  BID:Buy ASK:Sell
    //            "t": 123124124     // timestamp
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeStringLower(data, "s")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var trade interface{} = this.ParseTrade(data)
        var i interface{} = this.SafeString(data, "i")
        var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(i, nil))), "spot", "contract")
        var market interface{} = this.SafeMarket(marketId, nil, nil, tradeType)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var event interface{} = this.SafeString(message, "event")
        var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
            var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            tradesArray = ccxt.NewArrayCache(tradesLimit)
            ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
        }
        tradesArray.(ccxt.Appender).Append(trade)
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, "::"), tradeType)
        client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    }
    return message
}
func  (this *XtCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // spot
    //
    //    {
    //        "topic": "depth",
    //        "event": "depth@btc_usdt,20",
    //        "data": {
    //            "s": "btc_usdt",        // symbol
    //            "fi": 1681433733351,    // firstUpdateId = previous lastUpdateId + 1
    //            "i": 1681433733371,     // updateId
    //            "a": [                  // asks(sell order)
    //                [                   // [0]price, [1]quantity
    //                    "34000",        // price
    //                    "1.2"           // quantity
    //                ],
    //                [
    //                    "34001",
    //                    "2.3"
    //                ]
    //            ],
    //            "b": [                   // bids(buy order)
    //                [
    //                    "32000",
    //                    "0.2"
    //                ],
    //                [
    //                    "31000",
    //                    "0.5"
    //                ]
    //            ]
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "depth",
    //        "event": "depth@btc_usdt,20",
    //        "data": {
    //            s: "btc_usdt",
    //            pu: "548111455664",
    //            fu: "548111455665",
    //            u: "548111455667",
    //            a: [
    //                [
    //                    "26841.5",
    //                    "50210",
    //                ],
    //            ],
    //            b: [
    //                [
    //                    "26841",
    //                    "67075",
    //                ],
    //            ],
    //            t: 1684530667083,
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "s")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var event interface{} = this.SafeString(message, "event")
        var splitEvent interface{} = ccxt.Split(event, ",")
        event = this.SafeString(splitEvent, 0)
        var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(data, "fu"))), "contract", "spot")
        var market interface{} = this.SafeMarket(marketId, nil, nil, tradeType)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var obAsks interface{} = this.SafeList(data, "a")
        var obBids interface{} = this.SafeList(data, "b")
        var messageHash interface{} = ccxt.Add(ccxt.Add(event, "::"), tradeType)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var subscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
            var limit interface{} = this.SafeInteger(subscription, "limit")
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var nonce interface{} = this.SafeInteger(orderbook, "nonce")
        if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
            var cacheLength interface{} =             ccxt.GetArrayLength(orderbook.(ccxt.OrderBookInterface).GetCache())
            var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 25)
            if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
                this.Spawn(this.LoadOrderBook, client, messageHash, symbol)
            }
            ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), data)
            return
        }
        if ccxt.IsTrue(!ccxt.IsEqual(obAsks, nil)) {
            var asks interface{} = ccxt.GetValue(orderbook, "asks")
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(obAsks)); i++ {
                var ask interface{} = ccxt.GetValue(obAsks, i)
                var price interface{} = this.SafeNumber(ask, 0)
                var quantity interface{} = this.SafeNumber(ask, 1)
                asks.(ccxt.IOrderBookSide).Store(price, quantity)
            }
        }
        if ccxt.IsTrue(!ccxt.IsEqual(obBids, nil)) {
            var bids interface{} = ccxt.GetValue(orderbook, "bids")
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(obBids)); i++ {
                var bid interface{} = ccxt.GetValue(obBids, i)
                var price interface{} = this.SafeNumber(bid, 0)
                var quantity interface{} = this.SafeNumber(bid, 1)
                bids.(ccxt.IOrderBookSide).Store(price, quantity)
            }
        }
        var timestamp interface{} = this.SafeInteger(data, "t")
        ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger2(data, "i", "u"))
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
    }
}
func  (this *XtCore) ParseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "s": "btc_usdt",                         // symbol
    //        "t": 1656043204763,                      // time happened time
    //        "i": "6216559590087220004",              // orderId,
    //        "ci": "test123",                         // clientOrderId
    //        "st": "PARTIALLY_FILLED",                // state
    //        "sd": "BUY",                             // side BUY/SELL
    //        "eq": "2",                               // executedQty executed quantity
    //        "ap": "30000",                           // avg price
    //        "f": "0.002"                             // fee
    //    }
    //
    // contract
    //
    //    {
    //        "symbol": "btc_usdt",                    // Trading pair
    //        "orderId": "1234",                       // ccxt.Order Id
    //        "origQty": "34244",                      // Original Quantity
    //        "avgPrice": "123",                       // Quantity
    //        "price": "1111",                         // Average price
    //        "executedQty": "34244",                  // Volume (Cont)
    //        "orderSide": "BUY",                      // BUY, SELL
    //        "positionSide": "LONG",                  // LONG, SHORT
    //        "marginFrozen": "123",                   // Occupied margin
    //        "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
    //        "sourceId" : "1231231",                  // Triggering conditions ID
    //        "state": "",                             // state:NEWNew order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:ccxt.Order failed;EXPIREDExpired
    //        "createTime": 1731231231,                // CreateTime
    //        "clientOrderId": "204788317630342726"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "s")
    var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(trade, "symbol"))), "contract", "spot")
    market = this.SafeMarket(marketId, market, nil, tradeType)
    var timestamp interface{} = this.SafeString(trade, "t")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "order": this.SafeString(trade, "i", "orderId"),
        "type": this.ParseOrderStatus(this.SafeString(trade, "st", "state")),
        "side": this.SafeStringLower(trade, "sd", "orderSide"),
        "takerOrMaker": nil,
        "price": this.SafeNumber(trade, "price"),
        "amount": this.SafeString(trade, "origQty"),
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": this.SafeNumber(trade, "f"),
            "rate": nil,
        },
    }, market)
}
func  (this *XtCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        "s": "btc_usdt",                // symbol
    //        "bc": "btc",                    // base currency
    //        "qc": "usdt",                   // quotation currency
    //        "t": 1656043204763,             // happened time
    //        "ct": 1656043204663,            // create time
    //        "i": "6216559590087220004",     // order id,
    //        "ci": "test123",                // client order id
    //        "st": "PARTIALLY_FILLED",       // state NEW/PARTIALLY_FILLED/FILLED/CANCELED/REJECTED/EXPIRED
    //        "sd": "BUY",                    // side BUY/SELL
    //        "tp": "LIMIT",                  // type LIMIT/MARKET
    //        "oq":  "4"                      // original quantity
    //        "oqq":  48000,                  // original quotation quantity
    //        "eq": "2",                      // executed quantity
    //        "lq": "2",                      // remaining quantity
    //        "p": "4000",                    // price
    //        "ap": "30000",                  // avg price
    //        "f":"0.002"                     // fee
    //    }
    //
    // contract
    //
    //    {
    //        "symbol": "btc_usdt",                    // Trading pair
    //        "orderId": "1234",                       // ccxt.Order Id
    //        "origQty": "34244",                      // Original Quantity
    //        "avgPrice": "123",                       // Quantity
    //        "price": "1111",                         // Average price
    //        "executedQty": "34244",                  // Volume (Cont)
    //        "orderSide": "BUY",                      // BUY, SELL
    //        "positionSide": "LONG",                  // LONG, SHORT
    //        "marginFrozen": "123",                   // Occupied margin
    //        "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
    //        "sourceId" : "1231231",                  // Triggering conditions ID
    //        "state": "",                             // state:NEWNew order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:ccxt.Order failed;EXPIREDExpired
    //        "createTime": 1731231231,                // CreateTime
    //        "clientOrderId": "204788317630342726"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(order, "s", "symbol")
    var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(order, "symbol"))), "contract", "spot")
    market = this.SafeMarket(marketId, market, nil, tradeType)
    var timestamp interface{} = this.SafeInteger2(order, "ct", "createTime")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString2(order, "i", "orderId"),
        "clientOrderId": this.SafeString2(order, "ci", "clientOrderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": ccxt.GetValue(market, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeStringLower2(order, "sd", "orderSide"),
        "price": this.SafeNumber2(order, "p", "price"),
        "stopPrice": nil,
        "stopLoss": nil,
        "takeProfit": nil,
        "amount": this.SafeString2(order, "oq", "origQty"),
        "filled": this.SafeString2(order, "eq", "executedQty"),
        "remaining": this.SafeString(order, "lq"),
        "cost": nil,
        "average": this.SafeString2(order, "ap", "avgPrice"),
        "status": this.ParseOrderStatus(this.SafeString(order, "st", "state")),
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": this.SafeNumber(order, "f"),
        },
        "trades": nil,
    }, market)
}
func  (this *XtCore) HandleOrder(client interface{}, message interface{}) interface{}  {
    //
    // spot
    //
    //    {
    //        "topic": "order",
    //        "event": "order",
    //        "data": {
    //            "s": "btc_usdt",                // symbol
    //            "t": 1656043204763,             // time happened time
    //            "i": "6216559590087220004",     // orderId,
    //            "ci": "test123",                // clientOrderId
    //            "st": "PARTIALLY_FILLED",       // state
    //            "sd": "BUY",                    // side BUY/SELL
    //            "eq": "2",                      // executedQty executed quantity
    //            "ap": "30000",                  // avg price
    //            "f": "0.002"                    // fee
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "order",
    //        "event": "order@123456",
    //        "data": {
    //             "symbol": "btc_usdt",                    // Trading pair
    //             "orderId": "1234",                       // ccxt.Order Id
    //             "origQty": "34244",                      // Original Quantity
    //             "avgPrice": "123",                       // Quantity
    //             "price": "1111",                         // Average price
    //             "executedQty": "34244",                  // Volume (Cont)
    //             "orderSide": "BUY",                      // BUY, SELL
    //             "positionSide": "LONG",                  // LONG, SHORT
    //             "marginFrozen": "123",                   // Occupied margin
    //             "sourceType": "default",                 // DEFAULT:normal order,ENTRUST:plan commission,PROFIR:Take Profit and Stop Loss
    //             "sourceId" : "1231231",                  // Triggering conditions ID
    //             "state": "",                             // state:NEWNew order (unfilled);PARTIALLY_FILLED:Partial deal;PARTIALLY_CANCELED:Partial revocation;FILLED:Filled;CANCELED:Cancled;REJECTED:ccxt.Order failed;EXPIREDExpired
    //             "createTime": 1731231231,                // CreateTime
    //             "clientOrderId": "204788317630342726"
    //           }
    //    }
    //
    var orders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit")
        orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = orders
    }
    var order interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString2(order, "s", "symbol")
    if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
        var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(order, "symbol"))), "contract", "spot")
        var market interface{} = this.SafeMarket(marketId, nil, nil, tradeType)
        var parsed interface{} = this.ParseWsOrder(order, market)
        orders.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add("order::", tradeType))
    }
    return message
}
func  (this *XtCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    //    {
    //        topic: 'balance',
    //        event: 'balance',
    //        data: {
    //            a: 3513677381884,
    //            t: 1684250056775,
    //            c: 'usdt',
    //            b: '7.71000000',
    //            f: '0.00000000',
    //            z: 'SPOT'
    //        }
    //    }
    //
    // contract
    //
    //    {
    //        "topic": "balance",
    //        "event": "balance@123456",
    //        "data": {
    //            "coin": "usdt",
    //            "underlyingType": 1,                          // 1:Coin-M,2:USDT-M
    //            "walletBalance": "123",                       // ccxt.Balance
    //            "openOrderMarginFrozen": "123",               // Frozen order
    //            "isolatedMargin": "213",                      // Isolated Margin
    //            "crossedMargin": "0"                          // Crossed Margin
    //            "availableBalance": '2.256114450000000000',
    //            "coupon": '0',
    //            "bonus": '0'
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var currencyId interface{} = this.SafeString2(data, "c", "coin")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(data, "availableBalance"))
    ccxt.AddElementToObject(account, "used", this.SafeString(data, "f"))
    ccxt.AddElementToObject(account, "total", this.SafeString2(data, "b", "walletBalance"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
    var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(data, "coin"))), "contract", "spot")
    client.(ccxt.ClientInterface).Resolve(this.Balance, ccxt.Add("balance::", tradeType))
}
func  (this *XtCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    // spot
    //
    //    {
    //        "topic": "trade",
    //        "event": "trade",
    //        "data": {
    //            "s": "btc_usdt",                // symbol
    //            "t": 1656043204763,             // time
    //            "i": "6316559590087251233",     // tradeId
    //            "oi": "6216559590087220004",    // orderId
    //            "p": "30000",                   // trade price
    //            "q": "3",                       // qty quantity
    //            "v": "90000"                    // volume trade amount
    //        }
    //    }
    //
    // contract
    //
    //    {
    //       "topic": "trade",
    //       "event": "trade@123456",
    //       "data": {
    //            "symbol": 'btc_usdt',
    //            "orderSide": 'SELL',
    //            "positionSide": 'LONG',
    //            "orderId": '231485367663419328',
    //            "price": '27152.7',
    //            "quantity": '33',
    //            "marginUnfrozen": '2.85318000',
    //            "timestamp": 1684892412565
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var stored interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = stored
    }
    var parsedTrade interface{} = this.ParseTrade(data)
    var market interface{} = this.Market(ccxt.GetValue(parsedTrade, "symbol"))
    stored.(ccxt.Appender).Append(parsedTrade)
    var tradeType interface{} = ccxt.Ternary(ccxt.IsTrue(ccxt.GetValue(market, "contract")), "contract", "spot")
    client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add("trade::", tradeType))
}
func  (this *XtCore) HandleMessage(client interface{}, message interface{})  {
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "pong")) {
        client.(ccxt.ClientInterface).OnPong()
    } else if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
        var topic interface{} = this.SafeString(message, "topic")
        var methods interface{} = map[string]interface{} {
            "kline": this.HandleOHLCV,
            "depth": this.HandleOrderBook,
            "depth_update": this.HandleOrderBook,
            "ticker": this.HandleTicker,
            "agg_ticker": this.HandleTicker,
            "tickers": this.HandleTickers,
            "agg_tickers": this.HandleTickers,
            "balance": this.HandleBalance,
            "order": this.HandleOrder,
            "position": this.HandlePosition,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(ccxt.IsEqual(topic, "trade")) {
            var data interface{} = this.SafeDict(message, "data")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.InOp(data, "oi"))) || ccxt.IsTrue((ccxt.InOp(data, "orderId")))) {
                method = this.HandleMyTrades
            } else {
                method = this.HandleTrade
            }
        }
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    } else {
        this.HandleSubscriptionStatus(client, message)
    }
}
func  (this *XtCore) Ping(client interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return "ping"
}
func  (this *XtCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         id: '1763045665228ticker@eth_usdt',
    //         code: 0,
    //         msg: 'SUCCESS',
    //         method: 'unsubscribe'
    //     }
    //
    //     {
    //         code: 0,
    //         msg: 'success',
    //         id: '1764032903806ticker@btc_usdt',
    //         sessionId: '5e1597fffeb08f50-00000001-06401597-943ec6d3c64310dd-9b247bee'
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var unsubscribe interface{} = false
    if ccxt.IsTrue(!ccxt.IsEqual(id, nil)) {
        var subscription interface{} = this.SafeDict(subscriptionsById, id, map[string]interface{} {})
        unsubscribe = this.SafeBool(subscription, "unsubscribe", false)
        if ccxt.IsTrue(unsubscribe) {
            this.HandleUnSubscription(client, subscription)
        }
    }
    return message
}
func  (this *XtCore) HandleUnSubscription(client interface{}, subscription interface{})  {
    var messageHashes interface{} = this.SafeList(subscription, "messageHashes", []interface{}{})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(messageHashes)); j++ {
        var unsubHash interface{} = ccxt.GetValue(messageHashes, j)
        var subHash interface{} = ccxt.GetValue(subMessageHashes, j)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    }
    this.CleanCache(subscription)
}
func  (this *XtCore) HandleErrorMessage(client interface{}, message interface{})  {
    //
    //    {
    //        "id": "123",
    //        "code": 401,
    //        "msg": "token expire"
    //    }
    //
    var msg interface{} = this.SafeString(message, "msg")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(msg, "invalid_listen_key"))) || ccxt.IsTrue((ccxt.IsEqual(msg, "token expire")))) {
        ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), "token", nil)
        this.GetListenKey(true)
        return
    }
    client.(ccxt.ClientInterface).Reject(message)
}


func (this *XtCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
