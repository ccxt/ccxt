package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoinbaseCore struct {
	*ccxt.CoinbaseCore
	base *ccxt.CoinbaseCore
}

func NewCoinbaseCore() *CoinbaseCore {
    p := &CoinbaseCore{}
	base := &ccxt.CoinbaseCore{}
	p.base = base
	p.CoinbaseCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoinbaseCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "cancelAllOrdersWs": false,
            "cancelOrdersWs": false,
            "cancelOrderWs": false,
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchBalanceWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "fetchTradesWs": false,
            "watchBalance": false,
            "watchMyTrades": false,
            "watchOHLCV": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchTrades": true,
            "unWatchOrders": true,
            "unWatchTradesForSymbols": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://advanced-trade-ws.coinbase.com",
            },
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "myTradesLimit": 1000,
            "sides": map[string]interface{} {
                "bid": "bids",
                "offer": "asks",
            },
        },
    })
}
/**
 * @ignore
 * @method
 * @description subscribes to a websocket channel
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-overview#subscribe
 * @param {string} name the name of the channel
 * @param {boolean} isPrivate whether the channel is private or not
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseCore) Subscribe(name interface{}, isPrivate interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes698)
            var market interface{} = nil
            var messageHash interface{} = name
            var productIds interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsArray(symbol)) {
                var symbols interface{} = this.MarketSymbols(symbol)
                var marketIds interface{} = this.MarketIds(symbols)
                productIds = marketIds
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), ccxt.Join(symbol, ","))
            } else if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                messageHash = ccxt.Add(ccxt.Add(name, "::"), symbol)
                productIds = []interface{}{ccxt.GetValue(market, "id")}
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": productIds,
                "channel": name,
            }
            if ccxt.IsTrue(isPrivate) {
                subscribe = this.Extend(subscribe, this.CreateWSAuth(name, productIds))
            }
        
                retRes9515 :=  (<-this.Watch(url, messageHash, subscribe, messageHash))
                ccxt.PanicOnError(retRes9515)
                ch <- retRes9515
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description unSubscribes to a websocket channel
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-overview#subscribe
 * @param {string} topic unified topic
 * @param {string} name the name of the channel
 * @param {boolean} isPrivate whether the channel is private or not
 * @param {string} [symbol] unified market symbol
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseCore) UnSubscribe(topic interface{}, name interface{}, isPrivate interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
        
            retRes1108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1108)
            if ccxt.IsTrue(this.SafeBool(this.Options, "unSubscriptionPending", false)) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " another unSubscription is pending, coinbase does not support concurrent unSubscriptions")))
            }
            ccxt.AddElementToObject(this.Options, "unSubscriptionPending", true)
            var market interface{} = nil
            var watchMessageHash interface{} = name
            var unWatchMessageHash interface{} = ccxt.Add("unsubscribe:", name)
            var productIds interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsArray(symbol)) {
                var symbols interface{} = this.MarketSymbols(symbol)
                var marketIds interface{} = this.MarketIds(symbols)
                productIds = marketIds
                watchMessageHash = ccxt.Add(ccxt.Add(watchMessageHash, "::"), ccxt.Join(symbol, ","))
                unWatchMessageHash = ccxt.Add(ccxt.Add(unWatchMessageHash, "::"), ccxt.Join(symbol, ","))
            } else if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                watchMessageHash = ccxt.Add(ccxt.Add(name, "::"), symbol)
                unWatchMessageHash = ccxt.Add(ccxt.Add(unWatchMessageHash, "::"), symbol)
                productIds = []interface{}{ccxt.GetValue(market, "id")}
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            // '{"type": "unsubscribe", "product_ids": ["BTC-USD", "ETH-USD"], "channel": "ticker"}'
            var message interface{} = map[string]interface{} {
                "type": "unsubscribe",
                "product_ids": productIds,
                "channel": name,
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": []interface{}{unWatchMessageHash},
                "subMessageHashes": []interface{}{watchMessageHash},
                "topic": topic,
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
            }
            if ccxt.IsTrue(isPrivate) {
                message = this.Extend(message, this.CreateWSAuth(name, productIds))
            }
            ccxt.AddElementToObject(this.Options, "unSubscription", subscription)
        
            res:= (<-this.Watch(url, unWatchMessageHash, message, unWatchMessageHash, subscription))
            ccxt.PanicOnError(res)
            ccxt.AddElementToObject(this.Options, "unSubscriptionPending", false)
            ccxt.AddElementToObject(this.Options, "unSubscription", nil)
        
            ch <- res
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description subscribes to a websocket channel
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-overview#subscribe
 * @param {string} name the name of the channel
 * @param {boolean} isPrivate whether the channel is private or not
 * @param {string[]} [symbols] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseCore) SubscribeMultiple(name interface{}, isPrivate interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1678)
            var productIds interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols, nil, false)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&productIds, marketId)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, "::"), symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "product_ids": productIds,
                "channel": name,
            }
            if ccxt.IsTrue(isPrivate) {
                subscribe = this.Extend(subscribe, this.CreateWSAuth(name, productIds))
            }
        
                retRes18715 :=  (<-this.WatchMultiple(url, messageHashes, subscribe, messageHashes))
                ccxt.PanicOnError(retRes18715)
                ch <- retRes18715
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description unsubscribes to a websocket channel
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-overview#subscribe
 * @param {string} topic unified topic
 * @param {string} name the name of the channel
 * @param {boolean} isPrivate whether the channel is private or not
 * @param {string[]} [symbols] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} subscription to a websocket channel
 */
func  (this *CoinbaseCore) UnSubscribeMultiple(topic interface{}, name interface{}, isPrivate interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(this.SafeBool(this.Options, "unSubscriptionPending", false)) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " another unSubscription is pending, coinbase does not support concurrent unSubscriptions")))
            }
            ccxt.AddElementToObject(this.Options, "unSubscriptionPending", true)
        
            retRes2078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2078)
            var productIds interface{} = []interface{}{}
            var watchMessageHashes interface{} = []interface{}{}
            var unWatchMessageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols, nil, false)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&productIds, marketId)
                ccxt.AppendToArray(&watchMessageHashes, ccxt.Add(ccxt.Add(name, "::"), symbol))
                ccxt.AppendToArray(&unWatchMessageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:", name), "::"), symbol))
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var message interface{} = map[string]interface{} {
                "type": "unsubscribe",
                "product_ids": productIds,
                "channel": name,
            }
            if ccxt.IsTrue(isPrivate) {
                message = this.Extend(message, this.CreateWSAuth(name, productIds))
            }
            var subscription interface{} = map[string]interface{} {
                "messageHashes": unWatchMessageHashes,
                "subMessageHashes": watchMessageHashes,
                "topic": topic,
                "unsubscribe": true,
                "symbols": symbols,
            }
            ccxt.AddElementToObject(this.Options, "unSubscription", subscription)
        
            res:= (<-this.WatchMultiple(url, unWatchMessageHashes, message, unWatchMessageHashes, subscription))
            ccxt.PanicOnError(res)
            ccxt.AddElementToObject(this.Options, "unSubscriptionPending", false)
            ccxt.AddElementToObject(this.Options, "unSubscription", nil)
        
            ch <- res
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseCore) CreateWSAuth(name interface{}, productIds interface{}) interface{}  {
    var subscribe interface{} = map[string]interface{} {}
    var timestamp interface{} = this.NumberToString(this.Seconds())
    this.CheckRequiredCredentials()
    var isCloudAPiKey interface{} = ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(this.ApiKey, "organizations/"), 0))) || ccxt.IsTrue((ccxt.StartsWith(this.Secret, "-----BEGIN")))
    var auth interface{} = ccxt.Add(ccxt.Add(timestamp, name), ccxt.Join(productIds, ","))
    if !ccxt.IsTrue(isCloudAPiKey) {
        ccxt.AddElementToObject(subscribe, "api_key", this.ApiKey)
        ccxt.AddElementToObject(subscribe, "timestamp", timestamp)
        ccxt.AddElementToObject(subscribe, "signature", this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256))
    } else {
        if ccxt.IsTrue(ccxt.StartsWith(this.ApiKey, "-----BEGIN")) {
            panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " apiKey should contain the name (eg: organizations/3b910e93....) and not the public key")))
        }
        var currentToken interface{} = this.SafeString(this.Options, "wsToken")
        var tokenTimestamp interface{} = this.SafeInteger(this.Options, "wsTokenTimestamp", 0)
        var seconds interface{} = this.Seconds()
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(currentToken, nil)) || ccxt.IsTrue(ccxt.IsLessThan(ccxt.Add(tokenTimestamp, 120), seconds))) {
            // we should generate new token
            var token interface{} = this.CreateAuthToken(seconds)
            ccxt.AddElementToObject(this.Options, "wsToken", token)
            ccxt.AddElementToObject(this.Options, "wsTokenTimestamp", seconds)
        }
        ccxt.AddElementToObject(subscribe, "jwt", this.SafeString(this.Options, "wsToken"))
    }
    return subscribe
}
/**
 * @method
 * @name coinbase#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#ticker-channel
 * @param {string} [symbol] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinbaseCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2818 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2818)
            var name interface{} = "ticker"
        
                retRes28315 :=  (<-this.Subscribe(name, false, symbol, params))
                ccxt.PanicOnError(retRes28315)
                ch <- retRes28315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchTicker
 * @description stops watching a price ticker
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#ticker-channel
 * @param {string} [symbol] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinbaseCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2968)
            var name interface{} = "ticker"
        
                retRes29815 :=  (<-this.UnSubscribe("ticker", name, false, symbol))
                ccxt.PanicOnError(retRes29815)
                ch <- retRes29815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#ticker-batch-channel
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinbaseCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3118)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            var name interface{} = "ticker_batch"
        
            ticker:= (<-this.SubscribeMultiple(name, false, symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                var symbol interface{} = ccxt.GetValue(ticker, "symbol")
                ccxt.AddElementToObject(tickers, symbol, ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.Tickers
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchTickers
 * @description stop watching
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#ticker-batch-channel
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinbaseCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3368 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3368)
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
        
                retRes34015 :=  (<-this.UnSubscribeMultiple("ticker", "ticker_batch", false, symbols))
                ccxt.PanicOnError(retRes34015)
                ch <- retRes34015
                return nil
        
            }()
            return ch
        }
func  (this *CoinbaseCore) HandleTickers(client interface{}, message interface{})  {
    //
    //    {
    //        "channel": "ticker",
    //        "client_id": "",
    //        "timestamp": "2023-02-09T20:30:37.167359596Z",
    //        "sequence_num": 0,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "tickers": [
    //                    {
    //                        "type": "ticker",
    //                        "product_id": "BTC-USD",
    //                        "price": "21932.98",
    //                        "volume_24_h": "16038.28770938",
    //                        "low_24_h": "21835.29",
    //                        "high_24_h": "23011.18",
    //                        "low_52_w": "15460",
    //                        "high_52_w": "48240",
    //                        "price_percent_chg_24_h": "-4.15775596190603"
    // new as of 2024-04-12
    //                        "best_bid":"21835.29",
    //                        "best_bid_quantity": "0.02000000",
    //                        "best_ask":"23011.18",
    //                        "best_ask_quantity": "0.01500000"
    //                    }
    //                ]
    //            }
    //        ]
    //    }
    //
    //    {
    //        "channel": "ticker_batch",
    //        "client_id": "",
    //        "timestamp": "2023-03-01T12:15:18.382173051Z",
    //        "sequence_num": 0,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "tickers": [
    //                    {
    //                        "type": "ticker",
    //                        "product_id": "DOGE-USD",
    //                        "price": "0.08212",
    //                        "volume_24_h": "242556423.3",
    //                        "low_24_h": "0.07989",
    //                        "high_24_h": "0.08308",
    //                        "low_52_w": "0.04908",
    //                        "high_52_w": "0.1801",
    //                        "price_percent_chg_24_h": "0.50177456859626"
    // new as of 2024-04-12
    //                        "best_bid":"0.07989",
    //                        "best_bid_quantity": "500.0",
    //                        "best_ask":"0.08308",
    //                        "best_ask_quantity": "300.0"
    //                    }
    //                ]
    //            }
    //        ]
    //    }
    //
    // note! seems coinbase might also send empty data like:
    //
    //    {
    //        "channel": "ticker_batch",
    //        "client_id": "",
    //        "timestamp": "2024-05-24T18:22:24.546809523Z",
    //        "sequence_num": 1,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "tickers": [
    //                    {
    //                        "type": "ticker",
    //                        "product_id": "",
    //                        "price": "",
    //                        "volume_24_h": "",
    //                        "low_24_h": "",
    //                        "high_24_h": "",
    //                        "low_52_w": "",
    //                        "high_52_w": "",
    //                        "price_percent_chg_24_h": ""
    //                    }
    //                ]
    //            }
    //        ]
    //    }
    //
    //
    var channel interface{} = this.SafeString(message, "channel")
    var events interface{} = this.SafeList(message, "events", []interface{}{})
    var datetime interface{} = this.SafeString(message, "timestamp")
    var timestamp interface{} = this.Parse8601(datetime)
    var newTickers interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(events)); i++ {
        var tickersObj interface{} = ccxt.GetValue(events, i)
        var tickers interface{} = this.SafeList(tickersObj, "tickers", []interface{}{})
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(tickers)); j++ {
            var ticker interface{} = ccxt.GetValue(tickers, j)
            var wsMarketId interface{} = this.SafeString(ticker, "product_id")
            if ccxt.IsTrue(ccxt.IsEqual(wsMarketId, nil)) {
                continue
            }
            var result interface{} = this.ParseWsTicker(ticker)
            ccxt.AddElementToObject(result, "timestamp", timestamp)
            ccxt.AddElementToObject(result, "datetime", datetime)
            var symbol interface{} = ccxt.GetValue(result, "symbol")
            ccxt.AddElementToObject(this.Tickers, symbol, result)
            ccxt.AppendToArray(&newTickers, result)
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "::"), symbol)
            client.(ccxt.ClientInterface).Resolve(result, messageHash)
            this.TryResolveUsdc(client, messageHash, result)
        }
    }
}
func  (this *CoinbaseCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "type": "ticker",
    //         "product_id": "DOGE-USD",
    //         "price": "0.08212",
    //         "volume_24_h": "242556423.3",
    //         "low_24_h": "0.07989",
    //         "high_24_h": "0.08308",
    //         "low_52_w": "0.04908",
    //         "high_52_w": "0.1801",
    //         "price_percent_chg_24_h": "0.50177456859626"
    // new as of 2024-04-12
    //         "best_bid":"0.07989",
    //         "best_bid_quantity": "500.0",
    //         "best_ask":"0.08308",
    //         "best_ask_quantity": "300.0"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "product_id")
    var timestamp interface{} = nil
    var last interface{} = this.SafeNumber(ticker, "price")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(marketId, market, "-"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high_24_h"),
        "low": this.SafeString(ticker, "low_24_h"),
        "bid": this.SafeString(ticker, "best_bid"),
        "bidVolume": this.SafeString(ticker, "best_bid_quantity"),
        "ask": this.SafeString(ticker, "best_ask"),
        "askVolume": this.SafeString(ticker, "best_ask_quantity"),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "price_percent_chg_24_h"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume_24_h"),
        "quoteVolume": nil,
    })
}
/**
 * @method
 * @name coinbase#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#market-trades-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinbaseCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5188 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5188)
            symbol = this.Symbol(symbol)
            var name interface{} = "market_trades"
        
            trades:= (<-this.Subscribe(name, false, symbol, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchTrades
 * @description stops watching the list of most recent trades for a particular symbol
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#market-trades-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinbaseCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5388)
            var name interface{} = "market_trades"
        
                retRes54015 :=  (<-this.UnSubscribe("trades", name, false, symbol))
                ccxt.PanicOnError(retRes54015)
                ch <- retRes54015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#market-trades-channel
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinbaseCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5558)
            var name interface{} = "market_trades"
        
            trades:= (<-this.SubscribeMultiple(name, false, symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchTradesForSymbols
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#market-trades-channel
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinbaseCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5768)
            var name interface{} = "market_trades"
        
                retRes57815 :=  (<-this.UnSubscribeMultiple("trades", name, false, symbols, params))
                ccxt.PanicOnError(retRes57815)
                ch <- retRes57815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#user-channel
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CoinbaseCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5938)
            var name interface{} = "user"
        
            orders:= (<-this.Subscribe(name, true, symbol, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchOrders
 * @description stops watching information on multiple orders made by the user
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#user-channel
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CoinbaseCore) UnWatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6128 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6128)
            var name interface{} = "user"
        
                retRes61415 :=  (<-this.UnSubscribe("orders", name, true, this.Symbol(symbol)))
                ccxt.PanicOnError(retRes61415)
                ch <- retRes61415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#level2-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6288)
            var name interface{} = "level2"
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            orderbook:= (<-this.Subscribe(name, false, symbol, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#unWatchOrderBook
 * @description stops watching information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#level2-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6468 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6468)
            symbol = this.Symbol(symbol)
            var name interface{} = "level2"
        
                retRes64915 :=  (<-this.UnSubscribe("orderbook", name, false, symbol))
                ccxt.PanicOnError(retRes64915)
                ch <- retRes64915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbase#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.cloud.coinbase.com/advanced-trade-api/docs/ws-channels#level2-channel
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinbaseCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6638)
            var name interface{} = "level2"
        
            orderbook:= (<-this.SubscribeMultiple(name, false, symbols, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *CoinbaseCore) HandleTrade(client interface{}, message interface{})  {
    //
    //    {
    //        "channel": "market_trades",
    //        "client_id": "",
    //        "timestamp": "2023-02-09T20:19:35.39625135Z",
    //        "sequence_num": 0,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "trades": [
    //                    {
    //                        "trade_id": "000000000",
    //                        "product_id": "ETH-USD",
    //                        "price": "1260.01",
    //                        "size": "0.3",
    //                        "side": "BUY",
    //                        "time": "2019-08-14T20:42:27.265Z",
    //                    }
    //                ]
    //            }
    //        ]
    //    }
    //
    var events interface{} = this.SafeList(message, "events")
    var event interface{} = this.SafeValue(events, 0)
    var trades interface{} = this.SafeList(event, "trades")
    var trade interface{} = this.SafeDict(trades, 0)
    var marketId interface{} = this.SafeString(trade, "product_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var messageHash interface{} = ccxt.Add("market_trades::", symbol)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCacheBySymbolById(tradesLimit)
        ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(events)); i++ {
        var currentEvent interface{} = ccxt.GetValue(events, i)
        var currentTrades interface{} = this.SafeList(currentEvent, "trades")
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(currentTrades)); j++ {
            var item interface{} = ccxt.GetValue(currentTrades, i)
            tradesArray.(ccxt.Appender).Append(this.ParseTrade(item))
        }
    }
    client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
    this.TryResolveUsdc(client, messageHash, tradesArray)
}
func  (this *CoinbaseCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "channel": "user",
    //        "client_id": "",
    //        "timestamp": "2023-02-09T20:33:57.609931463Z",
    //        "sequence_num": 0,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "orders": [
    //                    {
    //                        "order_id": "XXX",
    //                        "client_order_id": "YYY",
    //                        "cumulative_quantity": "0",
    //                        "leaves_quantity": "0.000994",
    //                        "avg_price": "0",
    //                        "total_fees": "0",
    //                        "status": "OPEN",
    //                        "product_id": "BTC-USD",
    //                        "creation_time": "2022-12-07T19:42:18.719312Z",
    //                        "order_side": "BUY",
    //                        "order_type": "ccxt.Limit"
    //                    },
    //                ]
    //            }
    //        ]
    //    }
    //
    var events interface{} = this.SafeList(message, "events")
    var marketIds interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(events)); i++ {
        var event interface{} = ccxt.GetValue(events, i)
        var responseOrders interface{} = this.SafeList(event, "orders")
        for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(responseOrders)); j++ {
            var responseOrder interface{} = ccxt.GetValue(responseOrders, j)
            var parsed interface{} = this.ParseWsOrder(responseOrder)
            var cachedOrders interface{} = this.Orders
            var marketId interface{} = this.SafeString(responseOrder, "product_id")
            if !ccxt.IsTrue((ccxt.InOp(marketIds, marketId))) {
                ccxt.AppendToArray(&marketIds, marketId)
            }
            cachedOrders.(ccxt.Appender).Append(parsed)
        }
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var symbol interface{} = this.SafeSymbol(marketId)
        var messageHash interface{} = ccxt.Add("user::", symbol)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
        this.TryResolveUsdc(client, messageHash, this.Orders)
    }
    client.(ccxt.ClientInterface).Resolve(this.Orders, "user")
}
func  (this *CoinbaseCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "order_id": "XXX",
    //        "client_order_id": "YYY",
    //        "cumulative_quantity": "0",
    //        "leaves_quantity": "0.000994",
    //        "avg_price": "0",
    //        "total_fees": "0",
    //        "status": "OPEN",
    //        "product_id": "BTC-USD",
    //        "creation_time": "2022-12-07T19:42:18.719312Z",
    //        "order_side": "BUY",
    //        "order_type": "ccxt.Limit"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var clientOrderId interface{} = this.SafeString(order, "client_order_id")
    var marketId interface{} = this.SafeString(order, "product_id")
    var datetime interface{} = this.SafeString2(order, "time", "creation_time")
    market = this.SafeMarket(marketId, market)
    var stopPrice interface{} = this.SafeString(order, "stop_price")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": this.SafeString(market, "symbol"),
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastTradeTimestamp": nil,
        "type": this.SafeString(order, "order_type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString2(order, "side", "order_side"),
        "price": this.SafeString(order, "limit_price"),
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": this.SafeString(order, "cumulative_quantity"),
        "cost": this.OmitZero(this.SafeString(order, "filled_value")),
        "average": this.SafeString(order, "avg_price"),
        "filled": this.SafeString(order, "cumulative_quantity"),
        "remaining": this.SafeString(order, "leaves_quantity"),
        "status": this.SafeStringLower(order, "status"),
        "fee": map[string]interface{} {
            "amount": this.SafeString(order, "total_fees"),
            "currency": this.SafeString(market, "quote"),
        },
        "trades": nil,
    })
}
func  (this *CoinbaseCore) HandleOrderBookHelper(orderbook interface{}, updates interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(updates)); i++ {
        var trade interface{} = ccxt.GetValue(updates, i)
        var sideId interface{} = this.SafeString(trade, "side")
        var side interface{} = this.SafeString(ccxt.GetValue(this.Options, "sides"), sideId)
        var price interface{} = this.SafeNumber(trade, "price_level")
        var amount interface{} = this.SafeNumber(trade, "new_quantity")
        var orderbookSide interface{} = ccxt.GetValue(orderbook, side)
        orderbookSide.(ccxt.IOrderBookSide).Store(price, amount)
    }
}
func  (this *CoinbaseCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "channel": "l2_data",
    //        "client_id": "",
    //        "timestamp": "2023-02-09T20:32:50.714964855Z",
    //        "sequence_num": 0,
    //        "events": [
    //            {
    //                "type": "snapshot",
    //                "product_id": "BTC-USD",
    //                "updates": [
    //                    {
    //                        "side": "bid",
    //                        "event_time": "1970-01-01T00:00:00Z",
    //                        "price_level": "21921.74",
    //                        "new_quantity": "0.06317902"
    //                    },
    //                    {
    //                        "side": "bid",
    //                        "event_time": "1970-01-01T00:00:00Z",
    //                        "price_level": "21921.3",
    //                        "new_quantity": "0.02"
    //                    },
    //                ]
    //            }
    //        ]
    //    }
    //
    var events interface{} = this.SafeList(message, "events")
    var datetime interface{} = this.SafeString(message, "timestamp")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(events)); i++ {
        var event interface{} = ccxt.GetValue(events, i)
        var updates interface{} = this.SafeList(event, "updates", []interface{}{})
        var marketId interface{} = this.SafeString(event, "product_id")
        // sometimes we subscribe to BTC/USDC and coinbase returns BTC/USD, as they are aliases
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add("level2::", symbol)
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
        var limit interface{} = this.SafeInteger(subscription, "limit")
        var typeVar interface{} = this.SafeString(event, "type")
        if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        // unknown bug, can't reproduce, but sometimes orderbook is undefined
        if ccxt.IsTrue(!ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) && ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(this.Orderbooks, symbol), nil))) {
            continue
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        this.HandleOrderBookHelper(orderbook, updates)
        ccxt.AddElementToObject(orderbook, "timestamp", this.Parse8601(datetime))
        ccxt.AddElementToObject(orderbook, "datetime", datetime)
        ccxt.AddElementToObject(orderbook, "symbol", symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        this.TryResolveUsdc(client, messageHash, orderbook)
    }
}
func  (this *CoinbaseCore) TryResolveUsdc(client interface{}, messageHash interface{}, result interface{})  {
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.EndsWith(messageHash, "/USD")) || ccxt.IsTrue(ccxt.EndsWith(messageHash, "-USD"))) {
        client.(ccxt.ClientInterface).Resolve(result, ccxt.Add(messageHash, "C")) // when subscribing to BTC/USDC and coinbase returns BTC/USD, so resolve USDC too
    }
}
func  (this *CoinbaseCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "type": "subscriptions",
    //         "channels": [
    //             {
    //                 "name": "level2",
    //                 "product_ids": [ "ETH-BTC" ]
    //             }
    //         ]
    //     }
    //
    //
    //      {
    //        channel: 'subscriptions',
    //        client_id: '',
    //        timestamp: '2025-09-15T17:02:49.90120868Z',
    //        sequence_num: 3,
    //        events: [ { subscriptions: {} } ]
    //      }
    //
    var events interface{} = this.SafeList(message, "events", []interface{}{})
    var firstEvent interface{} = this.SafeValue(events, 0, map[string]interface{} {})
    var isUnsub interface{} =     (ccxt.InOp(firstEvent, "subscriptions"))
    var subKeys interface{} = ccxt.ObjectKeys(ccxt.GetValue(firstEvent, "subscriptions"))
    var subKeysLength interface{} =     ccxt.GetArrayLength(subKeys)
    if ccxt.IsTrue(ccxt.IsTrue(isUnsub) && ccxt.IsTrue(ccxt.IsEqual(subKeysLength, 0))) {
        var unSubObject interface{} = this.SafeDict(this.Options, "unSubscription", map[string]interface{} {})
        var messageHashes interface{} = this.SafeList(unSubObject, "messageHashes", []interface{}{})
        var subMessageHashes interface{} = this.SafeList(unSubObject, "subMessageHashes", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
            var messageHash interface{} = ccxt.GetValue(messageHashes, i)
            var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
            this.CleanUnsubscription(client.(*ccxt.Client), subHash, messageHash)
        }
        this.CleanCache(unSubObject)
    }
    return message
}
func  (this *CoinbaseCore) HandleHeartbeats(client interface{}, message interface{}) interface{}  {
    // although the subscription takes a product_ids parameter (i.e. symbol),
    // there is no (clear) way of mapping the message back to the symbol.
    //
    //     {
    //         "channel": "heartbeats",
    //         "client_id": "",
    //         "timestamp": "2023-06-23T20:31:26.122969572Z",
    //         "sequence_num": 0,
    //         "events": [
    //           {
    //               "current_time": "2023-06-23 20:31:56.121961769 +0000 UTC m=+91717.525857105",
    //               "heartbeat_counter": "3049"
    //           }
    //         ]
    //     }
    //
    return message
}
func  (this *CoinbaseCore) HandleMessage(client interface{}, message interface{})  {
    var channel interface{} = this.SafeString(message, "channel")
    var methods interface{} = map[string]interface{} {
        "subscriptions": this.HandleSubscriptionStatus,
        "ticker": this.HandleTickers,
        "ticker_batch": this.HandleTickers,
        "market_trades": this.HandleTrade,
        "user": this.HandleOrder,
        "l2_data": this.HandleOrderBook,
        "heartbeats": this.HandleHeartbeats,
    }
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "error")) {
        var errorMessage interface{} = this.SafeString(message, "message")
        panic(ccxt.ExchangeError(errorMessage))
    }
    var method interface{} = this.SafeValue(methods, channel)
    if ccxt.IsTrue(method) {
        ccxt.CallDynamically(method, client, message)
    }
}


func (this *CoinbaseCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
