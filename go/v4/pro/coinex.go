package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CoinexCore struct {
	*ccxt.CoinexCore
	base *ccxt.CoinexCore
}

func NewCoinexCore() *CoinexCore {
    p := &CoinexCore{}
	base := &ccxt.CoinexCore{}
	p.base = base
	p.CoinexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *CoinexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchBidsAsks": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOHLCV": false,
            "fetchOHLCVWs": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": "wss://socket.coinex.com/v2/spot/",
                    "swap": "wss://socket.coinex.com/v2/futures/",
                },
            },
        },
        "options": map[string]interface{} {
            "ws": map[string]interface{} {
                "gunzip": true,
            },
            "timeframes": map[string]interface{} {
                "1m": 60,
                "3m": 180,
                "5m": 300,
                "15m": 900,
                "30m": 1800,
                "1h": 3600,
                "2h": 7200,
                "4h": 14400,
                "6h": 21600,
                "12h": 43200,
                "1d": 86400,
                "3d": 259200,
                "1w": 604800,
            },
            "account": "spot",
            "watchOrderBook": map[string]interface{} {
                "limits": []interface{}{5, 10, 20, 50},
                "defaultLimit": 50,
                "aggregations": []interface{}{"1000", "100", "10", "1", "0", "0.1", "0.01", "0.001", "0.0001", "0.00001", "0.000001", "0.0000001", "0.00000001", "0.000000001", "0.0000000001", "0.00000000001"},
                "defaultAggregation": "0",
            },
        },
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "20001": ccxt.BadRequest,
                "20002": ccxt.NotSupported,
                "21001": ccxt.AuthenticationError,
                "21002": ccxt.AuthenticationError,
                "23001": ccxt.RequestTimeout,
                "23002": ccxt.RateLimitExceeded,
                "24001": ccxt.ExchangeError,
                "24002": ccxt.ExchangeNotAvailable,
                "30001": ccxt.BadRequest,
                "30002": ccxt.NotSupported,
                "31001": ccxt.AuthenticationError,
                "31002": ccxt.AuthenticationError,
                "33001": ccxt.RequestTimeout,
                "33002": ccxt.RateLimitExceeded,
                "34001": ccxt.ExchangeError,
                "34002": ccxt.ExchangeNotAvailable,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *CoinexCore) RequestId() interface{}  {
    var requestId interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", requestId)
    return requestId
}
func  (this *CoinexCore) HandleTicker(client interface{}, message interface{})  {
    //
    //  spot
    //
    //     {
    //         "method": "state.update",
    //         "data": {
    //             "state_list": [
    //                 {
    //                     "market": "LATUSDT",
    //                     "last": "0.008157",
    //                     "open": "0.008286",
    //                     "close": "0.008157",
    //                     "high": "0.008390",
    //                     "low": "0.008106",
    //                     "volume": "807714.49139758",
    //                     "volume_sell": "286170.69645599",
    //                     "volume_buy": "266161.23236408",
    //                     "value": "6689.21644207",
    //                     "period": 86400
    //                 },
    //             ]
    //         },
    //         "id": null
    //     }
    //
    //  swap
    //
    //     {
    //         "method": "state.update",
    //         "data": {
    //             "state_list": [
    //                 {
    //                     "market": "ETHUSD_SIGNPRICE",
    //                     "last": "1892.29",
    //                     "open": "1884.62",
    //                     "close": "1892.29",
    //                     "high": "1894.09",
    //                     "low": "1863.72",
    //                     "volume": "0",
    //                     "value": "0",
    //                     "volume_sell": "0",
    //                     "volume_buy": "0",
    //                     "open_interest_size": "0",
    //                     "insurance_fund_size": "0",
    //                     "latest_funding_rate": "0",
    //                     "next_funding_rate": "0",
    //                     "latest_funding_time": 0,
    //                     "next_funding_time": 0,
    //                     "period": 86400
    //                 },
    //             ]
    //         ],
    //         "id": null
    //     }
    //
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var rawTickers interface{} = this.SafeList(data, "state_list", []interface{}{})
    var newTickers interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTickers)); i++ {
        var entry interface{} = ccxt.GetValue(rawTickers, i)
        var marketId interface{} = this.SafeString(entry, "market")
        var symbol interface{} = this.SafeSymbol(marketId, nil, nil, defaultType)
        var market interface{} = this.SafeMarket(marketId, nil, nil, defaultType)
        var parsedTicker interface{} = this.ParseWSTicker(entry, market)
        ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
        ccxt.AddElementToObject(newTickers, symbol, parsedTicker)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "tickers::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var tickers interface{} = this.FilterByArray(newTickers, "symbol", symbols)
        var tickersSymbols interface{} = ccxt.ObjectKeys(tickers)
        var numTickers interface{} =         ccxt.GetArrayLength(tickersSymbols)
        if ccxt.IsTrue(ccxt.IsGreaterThan(numTickers, 0)) {
            client.(ccxt.ClientInterface).Resolve(tickers, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newTickers, "tickers")
}
func  (this *CoinexCore) ParseWSTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  spot
    //
    //     {
    //         "market": "LATUSDT",
    //         "last": "0.008157",
    //         "open": "0.008286",
    //         "close": "0.008157",
    //         "high": "0.008390",
    //         "low": "0.008106",
    //         "volume": "807714.49139758",
    //         "volume_sell": "286170.69645599",
    //         "volume_buy": "266161.23236408",
    //         "value": "6689.21644207",
    //         "period": 86400
    //     }
    //
    //  swap
    //
    //     {
    //         "market": "ETHUSD_SIGNPRICE",
    //         "last": "1892.29",
    //         "open": "1884.62",
    //         "close": "1892.29",
    //         "high": "1894.09",
    //         "low": "1863.72",
    //         "volume": "0",
    //         "value": "0",
    //         "volume_sell": "0",
    //         "volume_buy": "0",
    //         "open_interest_size": "0",
    //         "insurance_fund_size": "0",
    //         "latest_funding_rate": "0",
    //         "next_funding_rate": "0",
    //         "latest_funding_time": 0,
    //         "next_funding_time": 0,
    //         "period": 86400
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var marketId interface{} = this.SafeString(ticker, "market")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, nil, defaultType),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": this.SafeString(ticker, "volume_buy"),
        "ask": nil,
        "askVolume": this.SafeString(ticker, "volume_sell"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": this.SafeString(ticker, "close"),
        "last": this.SafeString(ticker, "last"),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "value"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.coinex.com/api/v2/assets/balance/ws/spot_balance
 * @see https://docs.coinex.com/api/v2/assets/balance/ws/futures_balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *CoinexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2588 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2588)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params, "spot")
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes2618 := (<-this.Authenticate(typeVar))
            ccxt.PanicOnError(retRes2618)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            // coinex throws a closes the websocket when subscribing over 1422 currencies, therefore we filter out inactive currencies
            var activeCurrencies interface{} = this.FilterBy(this.Currencies_by_id, "active", true)
            var activeCurrenciesById interface{} = this.IndexBy(activeCurrencies, "id")
            var currencies interface{} = ccxt.ObjectKeys(activeCurrenciesById)
            if ccxt.IsTrue(ccxt.IsEqual(currencies, nil)) {
                currencies = []interface{}{}
            }
            var messageHash interface{} = "balances"
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                messageHash = ccxt.Add(messageHash, ":spot")
            } else {
                messageHash = ccxt.Add(messageHash, ":swap")
            }
            var subscribe interface{} = map[string]interface{} {
                "method": "balance.subscribe",
                "params": map[string]interface{} {
                    "ccy_list": currencies,
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(subscribe, params)
        
                retRes28215 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes28215)
                ch <- retRes28215
                return nil
        
            }()
            return ch
        }
func  (this *CoinexCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "method": "balance.update",
    //         "data": {
    //             "balance_list": [
    //                 {
    //                     "margin_market": "BTCUSDT",
    //                     "ccy": "BTC",
    //                     "available": "44.62207740",
    //                     "frozen": "0.00000000",
    //                     "updated_at": 1689152421692
    //                 },
    //             ]
    //         },
    //         "id": null
    //     }
    //
    // swap
    //
    //     {
    //         "method": "balance.update",
    //         "data": {
    //             "balance_list": [
    //                 {
    //                     "ccy": "USDT",
    //                     "available": "97.92470982756335000001",
    //                     "frozen": "0.00000000000000000000",
    //                     "margin": "0.61442700000000000000",
    //                     "transferrable": "97.92470982756335000001",
    //                     "unrealized_pnl": "-0.00807000000000000000",
    //                     "equity": "97.92470982756335000001"
    //                 },
    //             ]
    //         },
    //         "id": null
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Balance, nil)) {
        this.Balance = map[string]interface{} {}
    }
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var balances interface{} = this.SafeList(data, "balance_list", []interface{}{})
    var firstEntry interface{} = ccxt.GetValue(balances, 0)
    var updated interface{} = this.SafeInteger(firstEntry, "updated_at")
    var unrealizedPnl interface{} = this.SafeString(firstEntry, "unrealized_pnl")
    var isSpot interface{} =     (!ccxt.IsEqual(updated, nil))
    var isSwap interface{} =     (!ccxt.IsEqual(unrealizedPnl, nil))
    var info interface{} = nil
    var account interface{} = nil
    var rawBalances interface{} = []interface{}{}
    if ccxt.IsTrue(isSpot) {
        account = "spot"
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
            rawBalances = this.ArrayConcat(rawBalances, balances)
        }
        info = rawBalances
    }
    if ccxt.IsTrue(isSwap) {
        account = "swap"
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(balances)); i++ {
            rawBalances = this.ArrayConcat(rawBalances, balances)
        }
        info = rawBalances
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawBalances)); i++ {
        var entry interface{} = ccxt.GetValue(rawBalances, i)
        this.ParseWsBalance(entry, account)
    }
    var messageHash interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(account, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Balance, account), nil)) {
            ccxt.AddElementToObject(this.Balance, account, map[string]interface{} {})
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, account), "info", info)
        ccxt.AddElementToObject(this.Balance, account, this.SafeBalance(ccxt.GetValue(this.Balance, account)))
        messageHash = ccxt.Add("balances:", account)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, account), messageHash)
    }
}
func  (this *CoinexCore) ParseWsBalance(balance interface{}, optionalArgs ...interface{})  {
    //
    // spot
    //
    //     {
    //         "margin_market": "BTCUSDT",
    //         "ccy": "BTC",
    //         "available": "44.62207740",
    //         "frozen": "0.00000000",
    //         "updated_at": 1689152421692
    //     }
    //
    // swap
    //
    //     {
    //         "ccy": "USDT",
    //         "available": "97.92470982756335000001",
    //         "frozen": "0.00000000000000000000",
    //         "margin": "0.61442700000000000000",
    //         "transferrable": "97.92470982756335000001",
    //         "unrealized_pnl": "-0.00807000000000000000",
    //         "equity": "97.92470982756335000001"
    //     }
    //
    accountType := ccxt.GetArg(optionalArgs, 0, nil)
    _ = accountType
    var account interface{} = this.Account()
    var currencyId interface{} = this.SafeString(balance, "ccy")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    ccxt.AddElementToObject(account, "free", this.SafeString(balance, "available"))
    ccxt.AddElementToObject(account, "used", this.SafeString(balance, "frozen"))
    if ccxt.IsTrue(!ccxt.IsEqual(accountType, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Balance, accountType), nil)) {
            ccxt.AddElementToObject(this.Balance, accountType, map[string]interface{} {})
        }
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, accountType), code, account)
    } else {
        ccxt.AddElementToObject(this.Balance, code, account)
    }
}
/**
 * @method
 * @name coinex#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://docs.coinex.com/api/v2/spot/deal/ws/user-deals
 * @see https://docs.coinex.com/api/v2/futures/deal/ws/user-deals
 * @param {string} [symbol] unified symbol of the market the trades were made in
 * @param {int} [since] the earliest time in ms to watch trades
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *CoinexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4208)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchMyTrades", market, params, "spot")
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes4288 := (<-this.Authenticate(typeVar))
            ccxt.PanicOnError(retRes4288)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscribedSymbols interface{} = []interface{}{}
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
                ccxt.AppendToArray(&subscribedSymbols, ccxt.GetValue(market, "id"))
            } else {
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    messageHash = ccxt.Add(messageHash, ":spot")
                } else {
                    messageHash = ccxt.Add(messageHash, ":swap")
                }
            }
            var message interface{} = map[string]interface{} {
                "method": "user_deals.subscribe",
                "params": map[string]interface{} {
                    "market_list": subscribedSymbols,
                },
                "id": this.RequestId(),
            }
            var request interface{} = this.DeepExtend(message, params)
        
            trades:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CoinexCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "user_deals.update",
    //         "data": {
    //             "deal_id": 3514376759,
    //             "created_at": 1689152421692,
    //             "market": "BTCUSDT",
    //             "side": "buy",
    //             "order_id": 8678890,
    //             "margin_market": "BTCUSDT",
    //             "price": "30718.42",
    //             "amount": "0.00000325",
    //             "role": "taker",
    //             "fee": "0.0299",
    //             "fee_ccy": "USDT"
    //         },
    //         "id": null
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "market")
    var isSpot interface{} = ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), ccxt.OpNeg(1))
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    var market interface{} = this.SafeMarket(marketId, nil, nil, defaultType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("myTrades:", symbol)
    var messageWithType interface{} = ccxt.Add("myTrades:", ccxt.GetValue(market, "type"))
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var parsed interface{} = this.ParseWsTrade(data, market)
    stored.(ccxt.Appender).Append(parsed)
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageWithType)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *CoinexCore) HandleTrades(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "method": "deals.update",
    //         "data": {
    //             "market": "BTCUSDT",
    //             "deal_list": [
    //                 {
    //                     "deal_id": 3514376759,
    //                     "created_at": 1689152421692,
    //                     "side": "buy",
    //                     "price": "30718.42",
    //                     "amount": "0.00000325"
    //                 },
    //             ]
    //         },
    //         "id": null
    //     }
    //
    // swap
    //
    //     {
    //         "method": "deals.update",
    //         "data": {
    //             "market": "BTCUSDT",
    //             "deal_list": [
    //                 {
    //                     "deal_id": 3514376759,
    //                     "created_at": 1689152421692,
    //                     "side": "buy",
    //                     "price": "30718.42",
    //                     "amount": "0.00000325"
    //                 },
    //             ]
    //         },
    //         "id": null
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var trades interface{} = this.SafeList(data, "deal_list", []interface{}{})
    var marketId interface{} = this.SafeString(data, "market")
    var isSpot interface{} = ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), ccxt.OpNeg(1))
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    var market interface{} = this.SafeMarket(marketId, nil, nil, defaultType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = ccxt.GetValue(trades, i)
        var parsed interface{} = this.ParseWsTrade(trade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
func  (this *CoinexCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot watchTrades
    //
    //     {
    //         "deal_id": 3514376759,
    //         "created_at": 1689152421692,
    //         "side": "buy",
    //         "price": "30718.42",
    //         "amount": "0.00000325"
    //     }
    //
    // swap watchTrades
    //
    //     {
    //         "deal_id": 3514376759,
    //         "created_at": 1689152421692,
    //         "side": "buy",
    //         "price": "30718.42",
    //         "amount": "0.00000325"
    //     }
    //
    // spot and swap watchMyTrades
    //
    //     {
    //         "deal_id": 3514376759,
    //         "created_at": 1689152421692,
    //         "market": "BTCUSDT",
    //         "side": "buy",
    //         "order_id": 8678890,
    //         "margin_market": "BTCUSDT",
    //         "price": "30718.42",
    //         "amount": "0.00000325",
    //         "role": "taker",
    //         "fee": "0.0299",
    //         "fee_ccy": "USDT"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "created_at")
    var isSpot interface{} =     (ccxt.InOp(trade, "margin_market"))
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    var marketId interface{} = this.SafeString(trade, "market")
    market = this.SafeMarket(marketId, market, nil, defaultType)
    var fee interface{} = map[string]interface{} {}
    var feeCost interface{} = this.OmitZero(this.SafeString(trade, "fee"))
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "fee_ccy", ccxt.GetValue(market, "quote"))
        fee = map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": feeCost,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "deal_id"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeSymbol(marketId, market, nil, defaultType),
        "order": this.SafeString(trade, "order_id"),
        "type": nil,
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": this.SafeString(trade, "role"),
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "amount"),
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coinex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-state
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6398)
            var market interface{} = this.Market(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, ccxt.GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-state
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6568)
            var marketIds interface{} = this.MarketIds(symbols)
            var market interface{} = nil
            var messageHashes interface{} = []interface{}{}
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    market = this.Market(symbol)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("tickers::", ccxt.GetValue(market, "symbol")))
                }
            } else {
                marketIds = []interface{}{}
                ccxt.AppendToArray(&messageHashes, "tickers")
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchTickers", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionHashes interface{} = []interface{}{"all@ticker"}
            var subscribe interface{} = map[string]interface{} {
                "method": "state.subscribe",
                "params": map[string]interface{} {
                    "market_list": marketIds,
                },
                "id": this.RequestId(),
            }
        
            result:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(subscribe, params), subscriptionHashes))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market-deals
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-deals
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes70115 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes70115)
                ch <- retRes70115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#watchTradesForSymbols
 * @description watch the most recent trades for a list of symbols
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market-deals
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-deals
 * @param {string[]} symbols unified symbols of the markets to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *CoinexCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7178)
            var subscribedSymbols interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            var market interface{} = nil
            var callerMethodName interface{} = nil
            callerMethodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchTradesForSymbols")
            callerMethodName = ccxt.GetValue(callerMethodNameparamsVariable,0)
            params = ccxt.GetValue(callerMethodNameparamsVariable,1)
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    market = this.Market(symbol)
                    ccxt.AppendToArray(&subscribedSymbols, ccxt.GetValue(market, "id"))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", ccxt.GetValue(market, "symbol")))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "trades")
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams(callerMethodName, market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            // const subscriptionHashes = [ 'trades' ]
            var subscribe interface{} = map[string]interface{} {
                "method": "deals.subscribe",
                "params": map[string]interface{} {
                    "market_list": subscribedSymbols,
                },
                "id": this.RequestId(),
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(subscribe, params), messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- trades
                return nil
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market-depth
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-depth
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinexCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7628)
            var watchOrderBookSubscriptions interface{} = map[string]interface{} {}
            var messageHashes interface{} = []interface{}{}
            var market interface{} = nil
            var typeVar interface{} = nil
            var callerMethodName interface{} = nil
            callerMethodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOrderBookForSymbols")
            callerMethodName = ccxt.GetValue(callerMethodNameparamsVariable,0)
            params = ccxt.GetValue(callerMethodNameparamsVariable,1)
            var options interface{} = this.SafeDict(this.Options, "watchOrderBook", map[string]interface{} {})
            var limits interface{} = this.SafeList(options, "limits", []interface{}{})
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = this.SafeInteger(options, "defaultLimit", 50)
            }
            if !ccxt.IsTrue(this.InArray(limit, limits)) {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " watchOrderBookForSymbols() limit must be one of "), ccxt.Join(limits, ", "))))
            }
            var defaultAggregation interface{} = this.SafeString(options, "defaultAggregation", "0")
            var aggregations interface{} = this.SafeList(options, "aggregations", []interface{}{})
            var aggregation interface{} = this.SafeString(params, "aggregation", defaultAggregation)
            if !ccxt.IsTrue(this.InArray(aggregation, aggregations)) {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " watchOrderBookForSymbols() aggregation must be one of "), ccxt.Join(aggregations, ", "))))
            }
            params = this.Omit(params, "aggregation")
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if !ccxt.IsTrue(symbolsDefined) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a symbol argument")))
            }
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                market = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", ccxt.GetValue(market, "symbol")))
                ccxt.AddElementToObject(watchOrderBookSubscriptions, symbol, []interface{}{ccxt.GetValue(market, "id"), limit, aggregation, true})
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams(callerMethodName, market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var marketList interface{} = ccxt.ObjectValues(watchOrderBookSubscriptions)
            var subscribe interface{} = map[string]interface{} {
                "method": "depth.subscribe",
                "params": map[string]interface{} {
                    "market_list": marketList,
                },
                "id": this.RequestId(),
            }
            // const subscriptionHashes = this.hash (this.encode (this.json (watchOrderBookSubscriptions)), ccxt.Sha256)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
        
            orderbooks:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(subscribe, params), messageHashes))
            ccxt.PanicOnError(orderbooks)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- orderbooks
                return nil
            }
        
            ch <- orderbooks.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market-depth
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *CoinexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrderBook")
        
                retRes82315 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes82315)
                ch <- retRes82315
                return nil
        
            }()
            return ch
        }
func  (this *CoinexCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, 0, 1)
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *CoinexCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *CoinexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "depth.update",
    //         "data": {
    //             "market": "BTCUSDT",
    //             "is_full": true,
    //             "depth": {
    //                 "asks": [
    //                     [
    //                         "30740.00",
    //                         "0.31763545"
    //                     ],
    //                 ],
    //                 "bids": [
    //                     [
    //                         "30736.00",
    //                         "0.04857373"
    //                     ],
    //                 ],
    //                 "last": "30746.28",
    //                 "updated_at": 1689152421692,
    //                 "checksum": 2578768879
    //             }
    //         },
    //         "id": null
    //     }
    //
    var isSpot interface{} = ccxt.IsGreaterThan(ccxt.GetIndexOf(client.(ccxt.ClientInterface).GetUrl(), "spot"), ccxt.OpNeg(1))
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var depth interface{} = this.SafeDict(data, "depth", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "market")
    var market interface{} = this.SafeMarket(marketId, nil, nil, defaultType)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var name interface{} = "orderbook"
    var messageHash interface{} = ccxt.Add(ccxt.Add(name, ":"), symbol)
    var timestamp interface{} = this.SafeInteger(depth, "updated_at")
    var currentOrderBook interface{} = this.SafeValue(this.Orderbooks, symbol)
    var fullOrderBook interface{} = this.SafeBool(data, "is_full", false)
    if ccxt.IsTrue(fullOrderBook) {
        var snapshot interface{} = this.ParseOrderBook(depth, symbol, timestamp)
        if ccxt.IsTrue(ccxt.IsEqual(currentOrderBook, nil)) {
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(snapshot))
        } else {
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        }
    } else {
        var asks interface{} = this.SafeList(depth, "asks", []interface{}{})
        var bids interface{} = this.SafeList(depth, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(currentOrderBook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(currentOrderBook, "bids"), bids)
        ccxt.AddElementToObject(currentOrderBook, "nonce", timestamp)
        ccxt.AddElementToObject(currentOrderBook, "timestamp", timestamp)
        ccxt.AddElementToObject(currentOrderBook, "datetime", this.Iso8601(timestamp))
        ccxt.AddElementToObject(this.Orderbooks, symbol, currentOrderBook)
    }
    // this.checkOrderBookChecksum (this.orderbooks[symbol])
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
}
/**
 * @method
 * @name coinex#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.coinex.com/api/v2/spot/order/ws/user-order
 * @see https://docs.coinex.com/api/v2/futures/order/ws/user-order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] if the orders to watch are trigger orders or not
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *CoinexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9138)
            var trigger interface{} = this.SafeBool2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var messageHash interface{} = "orders"
            var market interface{} = nil
            var marketList interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params, "spot")
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes9258 := (<-this.Authenticate(typeVar))
            ccxt.PanicOnError(retRes9258)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                marketList = []interface{}{ccxt.GetValue(market, "id")}
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            } else {
                marketList = []interface{}{}
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    messageHash = ccxt.Add(messageHash, ":spot")
                } else {
                    messageHash = ccxt.Add(messageHash, ":swap")
                }
            }
            var method interface{} = nil
            if ccxt.IsTrue(trigger) {
                method = "stop.subscribe"
            } else {
                method = "order.subscribe"
            }
            var message interface{} = map[string]interface{} {
                "method": method,
                "params": map[string]interface{} {
                    "market_list": marketList,
                },
                "id": this.RequestId(),
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var request interface{} = this.DeepExtend(message, params)
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash, request))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *CoinexCore) HandleOrders(client interface{}, message interface{})  {
    //
    // spot
    //
    //     {
    //         "method": "order.update",
    //         "data": {
    //             "event": "put",
    //             "order": {
    //                 "order_id": 12750,
    //                 "market": "BTCUSDT",
    //                 "margin_market": "BTCUSDT",
    //                 "type": "limit",
    //                 "side": "buy",
    //                 "price": "5999.00",
    //                 "amount": "1.50000000",
    //                 "unfill_amount": "1.50000000",
    //                 "fill_value": "1.50000000",
    //                 "taker_fee_rate": "0.0001",
    //                 "maker_fee_rate": "0.0001",
    //                 "base_ccy_fee": "0.0001",
    //                 "quote_ccy_fee": "0.0001",
    //                 "discount_ccy_fee": "0.0001",
    //                 "last_fill_amount": "0",
    //                 "last_fill_price": "0",
    //                 "client_id": "buy1_1234",
    //                 "created_at": 1689152421692,
    //                 "updated_at": 1689152421692,
    //             }
    //         },
    //         "id": null
    //     }
    //
    // spot stop
    //
    //     {
    //         "method": "stop.update",
    //         "data": {
    //             "event": 1,
    //             "stop": {
    //                 "stop_id": 102067022299,
    //                 "market": "BTCUSDT",
    //                 "margin_market": "BTCUSDT",
    //                 "type": "limit",
    //                 "side": "buy",
    //                 "price": "20000.00",
    //                 "amount": "0.10000000",
    //                 "trigger_price": "20000.00",
    //                 "trigger_direction": "lower",
    //                 "taker_fee_rate": "0.0016",
    //                 "maker_fee_rate": "0.0016",
    //                 "status": "active_success",
    //                 "client_id": "",
    //                 "created_at": 1689152996689,
    //                 "updated_at": 1689152996689,
    //             }
    //         },
    //         "id": null
    //     }
    //
    // swap
    //
    //     {
    //         "method": "order.update",
    //         "data": {
    //             "event": "put",
    //             "order": {
    //                 "order_id": 98388656341,
    //                 "stop_id": 0,
    //                 "market": "BTCUSDT",
    //                 "side": "buy",
    //                 "type": "limit",
    //                 "amount": "0.0010",
    //                 "price": "50000.00",
    //                 "unfilled_amount": "0.0010",
    //                 "filled_amount": "0",
    //                 "filled_value": "0",
    //                 "fee": "0",
    //                 "fee_ccy": "USDT",
    //                 "taker_fee_rate": "0.00046",
    //                 "maker_fee_rate": "0.00000000000000000000",
    //                 "client_id": "",
    //                 "last_filled_amount": "0.0010",
    //                 "last_filled_price": "30721.35",
    //                 "created_at": 1689145715129,
    //                 "updated_at": 1689145715129
    //             }
    //         },
    //         "id": null
    //     }
    //
    // swap stop
    //
    //     {
    //         "method": "stop.update",
    //         "data": {
    //             "event": "put",
    //             "stop": {
    //                 "stop_id": 98389557871,
    //                 "market": "BTCUSDT",
    //                 "side": "sell",
    //                 "type": "limit",
    //                 "price": "20000.00",
    //                 "amount": "0.0100",
    //                 "trigger_price": "20000.00",
    //                 "trigger_direction": "higer",
    //                 "trigger_price_type": "index_price",
    //                 "taker_fee_rate": "0.00046",
    //                 "maker_fee_rate": "0.00026",
    //                 "client_id": "",
    //                 "created_at": 1689146382674,
    //                 "updated_at": 1689146382674
    //             }
    //         },
    //         "id": null
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var order interface{} = this.SafeDict2(data, "order", "stop", map[string]interface{} {})
    var parsedOrder interface{} = this.ParseWsOrder(order)
    var symbol interface{} = ccxt.GetValue(parsedOrder, "symbol")
    var market interface{} = this.Market(symbol)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    orders.(ccxt.Appender).Append(parsedOrder)
    var messageHash interface{} = "orders"
    var messageWithType interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(market, "type"))
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageWithType)
    messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *CoinexCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "order_id": 12750,
    //         "market": "BTCUSDT",
    //         "margin_market": "BTCUSDT",
    //         "type": "limit",
    //         "side": "buy",
    //         "price": "5999.00",
    //         "amount": "1.50000000",
    //         "unfill_amount": "1.50000000",
    //         "fill_value": "1.50000000",
    //         "taker_fee_rate": "0.0001",
    //         "maker_fee_rate": "0.0001",
    //         "base_ccy_fee": "0.0001",
    //         "quote_ccy_fee": "0.0001",
    //         "discount_ccy_fee": "0.0001",
    //         "last_fill_amount": "0",
    //         "last_fill_price": "0",
    //         "client_id": "buy1_1234",
    //         "created_at": 1689152421692,
    //         "updated_at": 1689152421692,
    //     }
    //
    // spot stop
    //
    //     {
    //         "stop_id": 102067022299,
    //         "market": "BTCUSDT",
    //         "margin_market": "BTCUSDT",
    //         "type": "limit",
    //         "side": "buy",
    //         "price": "20000.00",
    //         "amount": "0.10000000",
    //         "trigger_price": "20000.00",
    //         "trigger_direction": "lower",
    //         "taker_fee_rate": "0.0016",
    //         "maker_fee_rate": "0.0016",
    //         "status": "active_success",
    //         "client_id": "",
    //         "created_at": 1689152996689,
    //         "updated_at": 1689152996689,
    //     }
    //
    // swap
    //
    //     {
    //         "order_id": 98388656341,
    //         "stop_id": 0,
    //         "market": "BTCUSDT",
    //         "side": "buy",
    //         "type": "limit",
    //         "amount": "0.0010",
    //         "price": "50000.00",
    //         "unfilled_amount": "0.0010",
    //         "filled_amount": "0",
    //         "filled_value": "0",
    //         "fee": "0",
    //         "fee_ccy": "USDT",
    //         "taker_fee_rate": "0.00046",
    //         "maker_fee_rate": "0.00000000000000000000",
    //         "client_id": "",
    //         "last_filled_amount": "0.0010",
    //         "last_filled_price": "30721.35",
    //         "created_at": 1689145715129,
    //         "updated_at": 1689145715129
    //     }
    //
    // swap stop
    //
    //     {
    //         "stop_id": 98389557871,
    //         "market": "BTCUSDT",
    //         "side": "sell",
    //         "type": "limit",
    //         "price": "20000.00",
    //         "amount": "0.0100",
    //         "trigger_price": "20000.00",
    //         "trigger_direction": "higer",
    //         "trigger_price_type": "index_price",
    //         "taker_fee_rate": "0.00046",
    //         "maker_fee_rate": "0.00026",
    //         "client_id": "",
    //         "created_at": 1689146382674,
    //         "updated_at": 1689146382674
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "created_at")
    var marketId interface{} = this.SafeString(order, "market")
    var status interface{} = this.SafeString(order, "status")
    var isSpot interface{} =     (ccxt.InOp(order, "margin_market"))
    var defaultType interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    market = this.SafeMarket(marketId, market, nil, defaultType)
    var fee interface{} = nil
    var feeCost interface{} = this.OmitZero(this.SafeString2(order, "fee", "quote_ccy_fee"))
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(order, "fee_ccy", ccxt.GetValue(market, "quote"))
        fee = map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": feeCost,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString2(order, "order_id", "stop_id"),
        "clientOrderId": this.SafeString(order, "client_id"),
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": this.SafeInteger(order, "updated_at"),
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": this.SafeString(order, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString(order, "side"),
        "price": this.SafeString(order, "price"),
        "stopPrice": this.SafeString(order, "trigger_price"),
        "triggerPrice": this.SafeString(order, "trigger_price"),
        "amount": this.SafeString(order, "amount"),
        "filled": this.SafeString2(order, "filled_amount", "fill_value"),
        "remaining": this.SafeString2(order, "unfilled_amount", "unfill_amount"),
        "cost": nil,
        "average": nil,
        "status": this.ParseWsOrderStatus(status),
        "fee": fee,
        "trades": nil,
    }, market)
}
func  (this *CoinexCore) ParseWsOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "active_success": "open",
        "active_fail": "canceled",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinex#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.coinex.com/api/v2/spot/market/ws/market-bbo
 * @see https://docs.coinex.com/api/v2/futures/market/ws/market-bbo
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *CoinexCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12428)
            var marketIds interface{} = this.MarketIds(symbols)
            var messageHashes interface{} = []interface{}{}
            var market interface{} = nil
            var symbolsDefined interface{} =     (!ccxt.IsEqual(symbols, nil))
            if ccxt.IsTrue(symbolsDefined) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    market = this.Market(symbol)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("bidsasks:", ccxt.GetValue(market, "symbol")))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "bidsasks")
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBidsAsks", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var subscriptionHashes interface{} = []interface{}{"all@bidsasks"}
            var subscribe interface{} = map[string]interface{} {
                "method": "bbo.subscribe",
                "params": map[string]interface{} {
                    "market_list": marketIds,
                },
                "id": this.RequestId(),
            }
        
            result:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(subscribe, params), subscriptionHashes))
            ccxt.PanicOnError(result)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *CoinexCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "method": "bbo.update",
    //         "data": {
    //             "market": "BTCUSDT",
    //             "updated_at": 1656660154,
    //             "best_bid_price": "20000",
    //             "best_bid_size": "0.1",
    //             "best_ask_price": "20001",
    //             "best_ask_size": "0.15"
    //         },
    //         "id": null
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var parsedTicker interface{} = this.ParseWsBidAsk(data)
    var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
    var messageHash interface{} = ccxt.Add("bidsasks:", symbol)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *CoinexCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "BTCUSDT",
    //         "updated_at": 1656660154,
    //         "best_bid_price": "20000",
    //         "best_bid_size": "0.1",
    //         "best_ask_price": "20001",
    //         "best_ask_size": "0.15"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var marketId interface{} = this.SafeString(ticker, "market")
    market = this.SafeMarket(marketId, market, nil, defaultType)
    var timestamp interface{} = this.SafeInteger(ticker, "updated_at")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, nil, defaultType),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeNumber(ticker, "best_ask_price"),
        "askVolume": this.SafeNumber(ticker, "best_ask_size"),
        "bid": this.SafeNumber(ticker, "best_bid_price"),
        "bidVolume": this.SafeNumber(ticker, "best_bid_size"),
        "info": ticker,
    }, market)
}
func  (this *CoinexCore) HandleMessage(client interface{}, message interface{})  {
    var method interface{} = this.SafeString(message, "method")
    var error interface{} = this.SafeString(message, "message")
    if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
        this.HandleErrors(1, "", client.(ccxt.ClientInterface).GetUrl(), method, map[string]interface{} {}, this.Json(error), message, map[string]interface{} {}, map[string]interface{} {})
    }
    var handlers interface{} = map[string]interface{} {
        "state.update": this.HandleTicker,
        "balance.update": this.HandleBalance,
        "deals.update": this.HandleTrades,
        "user_deals.update": this.HandleMyTrades,
        "depth.update": this.HandleOrderBook,
        "order.update": this.HandleOrders,
        "stop.update": this.HandleOrders,
        "bbo.update": this.HandleBidAsk,
    }
    var handler interface{} = this.SafeValue(handlers, method)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
        return
    }
    this.HandleSubscriptionStatus(client, message)
}
func  (this *CoinexCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if ccxt.IsTrue(ccxt.IsEqual(response, nil)) {
        return nil
    }
    //
    //     { "id": 1, "code": 20001, "message": "invalid argument" }
    //     { "id": 2, "code": 21001, "message": "require auth" }
    //     { "id": 1, "code": 21002, "message": "Signature Incorrect" }
    //
    var message interface{} = this.SafeStringLower(response, "message")
    var isErrorMessage interface{} = ccxt.IsTrue((!ccxt.IsEqual(message, nil))) && ccxt.IsTrue((!ccxt.IsEqual(message, "ok")))
    var errorCode interface{} = this.SafeString(response, "code")
    var isErrorCode interface{} = ccxt.IsTrue((!ccxt.IsEqual(errorCode, nil))) && ccxt.IsTrue((!ccxt.IsEqual(errorCode, "0")))
    if ccxt.IsTrue(ccxt.IsTrue(isErrorCode) || ccxt.IsTrue(isErrorMessage)) {
        var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ccxt.ExchangeError(feedback))
    }
    return nil
}
func  (this *CoinexCore) HandleAuthenticationMessage(client interface{}, message interface{})  {
    //
    // success
    //
    //     {
    //         "id": 1,
    //         "code": 0,
    //         "message": "OK"
    //     }
    //
    // fail
    //
    //     {
    //         "id": 1,
    //         "code": 21002,
    //         "message": ""
    //     }
    //
    var status interface{} = this.SafeStringLower(message, "message")
    var errorCode interface{} = this.SafeString(message, "code")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(status, "ok"))) || ccxt.IsTrue((ccxt.IsEqual(errorCode, "0")))) {
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
}
func  (this *CoinexCore) HandleSubscriptionStatus(client interface{}, message interface{})  {
    var id interface{} = this.SafeInteger(message, "id")
    var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    if ccxt.IsTrue(!ccxt.IsEqual(subscription, nil)) {
        var futureIndex interface{} = this.SafeString(subscription, "future")
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), futureIndex)
        if ccxt.IsTrue(!ccxt.IsEqual(future, nil)) {
            future.(*ccxt.Future).Resolve(true)
        }
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), id)
    }
}
func  (this *CoinexCore) Authenticate(typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar)
            var client interface{} = this.Client(url)
            var time interface{} = this.Milliseconds()
            var timestamp interface{} = ccxt.ToString(time)
            var messageHash interface{} = "authenticated"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(!ccxt.IsEqual(authenticated, nil)) {
        
                    retRes142319 := <- future.(*ccxt.Future).Await()
                    ccxt.PanicOnError(retRes142319)
                    ch <- retRes142319
                    return nil
            }
            var requestId interface{} = this.RequestId()
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
                "future": messageHash,
            }
            var hmac interface{} = this.Hmac(this.Encode(timestamp), this.Encode(this.Secret), ccxt.Sha256, "hex")
            var request interface{} = map[string]interface{} {
                "id": requestId,
                "method": "server.sign",
                "params": map[string]interface{} {
                    "access_id": this.ApiKey,
                    "signed_str": ccxt.ToLower(hmac),
                    "timestamp": time,
                },
            }
            this.Watch(url, messageHash, request, requestId, subscribe)
            ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, true)
        
                retRes144215 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes144215)
                ch <- retRes144215
                return nil
        
            }()
            return ch
        }


func (this *CoinexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
