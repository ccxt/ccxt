package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type GrvtCore struct {
	*ccxt.GrvtCore
	base *ccxt.GrvtCore
}

func NewGrvtCore() *GrvtCore {
    p := &GrvtCore{}
	base := &ccxt.GrvtCore{}
	p.base = base
	p.GrvtCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *GrvtCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchMyTrades": true,
            "watchPositions": true,
            "watchOrders": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "publicMarket": "wss://market-data.grvt.io/ws/full",
                    "privateTrading": "wss://trades.grvt.io/ws/full",
                },
            },
        },
        "options": map[string]interface{} {
            "watchOrderBookForSymbols": map[string]interface{} {
                "depth": 100,
                "interval": 500,
                "channel": "v1.book.s",
            },
            "watchTickers": map[string]interface{} {
                "channel": "v1.ticker.s",
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 300000,
        },
    })
}
func  (this *GrvtCore) HandleMessage(client interface{}, message interface{})  {
    //
    // confirmation
    //
    //  {
    //     jsonrpc: '2.0',
    //     result: {
    //         stream: 'v1.mini.d',
    //         subs: [ 'BTC_USDT_Perp@500' ],
    //         unsubs: [],
    //         num_snapshots: [ 1 ],
    //         first_sequence_number: [ '1061214' ],
    //         latest_sequence_number: [ '1061213' ]
    //     },
    //     id: 1,
    //     method: 'subscribe'
    //  }
    //
    // ticker
    //
    //  {
    //     stream: "v1.mini.d",
    //     selector: "BTC_USDT_Perp@500",
    //     sequence_number: "0",
    //     feed: {
    //         event_time: "1767198134519661154",
    //         instrument: "BTC_USDT_Perp",
    //         ...
    //     },
    //     prev_sequence_number: "0",
    //  }
    //
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var methods interface{} = map[string]interface{} {
        "v1.ticker.s": this.HandleTicker,
        "v1.ticker.d": this.HandleTicker,
        "v1.mini.d": this.HandleTicker,
        "v1.mini.s": this.HandleTicker,
        "v1.trade": this.HandleTrades,
        "v1.candle": this.HandleOHLCV,
        "v1.book.s": this.HandleOrderBook,
        "v1.book.d": this.HandleOrderBook,
        "v1.fill": this.HandleMyTrade,
        "v1.position": this.HandlePosition,
        "v1.order": this.HandleOrder,
    }
    var methodName interface{} = this.SafeString(message, "method")
    if ccxt.IsTrue(ccxt.IsEqual(methodName, "subscribe")) {
        // return from confirmation
        return
    }
    var channel interface{} = this.SafeString(message, "stream")
    var method interface{} = this.SafeValue(methods, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *GrvtCore) SubscribeMultiple(messageHashes interface{}, request interface{}, rawHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    publicOrPrivate := ccxt.GetArg(optionalArgs, 0, true)
            _ = publicOrPrivate
            var payload interface{} = map[string]interface{} {
                "jsonrpc": "2.0",
                "method": "subscribe",
                "params": request,
                "id": this.RequestId(),
            }
            var apiPart interface{} = ccxt.Ternary(ccxt.IsTrue(publicOrPrivate), "publicMarket", "privateTrading")
        
                retRes12015 :=  (<-this.WatchMultiple(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), apiPart), messageHashes, payload, rawHashes))
                ccxt.PanicOnError(retRes12015)
                ch <- retRes12015
                return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) RequestId() interface{}  {
    this.LockId()
    var newValue interface{} = this.Sum(this.SafeInteger(this.Options, "requestId", 0), 1)
    ccxt.AddElementToObject(this.Options, "requestId", newValue)
    this.UnlockId()
    return newValue
}
/**
 * @method
 * @name grvt#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.grvt.io/market_data_streams/#mini-ticker-snap-feed-selector
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *GrvtCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1418 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1418)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, this.Extend(params, map[string]interface{} {
            "callerMethodName": "watchTicker",
        })))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *GrvtCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTickers requires a symbols argument")))
            }
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchTickers", "channel", "v1.ticker.s")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
            retRes1628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1628)
            symbols = this.MarketSymbols(symbols)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var interval interface{} = this.SafeInteger(params, "interval", 500) // raw, 50, 100, 200, 500, 1000, 5000
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(marketId, "@"), interval))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker::", ccxt.GetValue(market, "symbol")))
            }
            var request interface{} = map[string]interface{} {
                "stream": channel,
                "selectors": rawHashes,
            }
        
            ticker:= (<-this.SubscribeMultiple(messageHashes, this.Extend(params, request), rawHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleTicker(client interface{}, message interface{})  {
    //
    // v1.ticker.s
    //
    //    {
    //        "stream": "v1.ticker.s",
    //        "selector": "BTC_USDT_Perp@500",
    //        "sequence_number": "0",
    //        "feed": {
    //            "event_time": "1767199535382794823",
    //            "instrument": "BTC_USDT_Perp",
    //            "mark_price": "87439.392166151",
    //            "index_price": "87462.426721779",
    //            "last_price": "87467.5",
    //            "last_size": "0.001",
    //            "mid_price": "87474.35",
    //            "best_bid_price": "87474.3",
    //            "best_bid_size": "2.435",
    //            "best_ask_price": "87474.4",
    //            "best_ask_size": "3.825",
    //            "funding_rate_8h_curr": "0.01",
    //            "funding_rate_8h_avg": "0.01",
    //            "interest_rate": "0.0",
    //            "forward_price": "0.0",
    //            "buy_volume_24h_b": "3115.631",
    //            "sell_volume_24h_b": "3195.236",
    //            "buy_volume_24h_q": "275739265.1558",
    //            "sell_volume_24h_q": "282773286.2658",
    //            "high_price": "89187.2",
    //            "low_price": "87404.1",
    //            "open_price": "88667.1",
    //            "open_interest": "1914.093886738",
    //            "long_short_ratio": "1.472050",
    //            "funding_rate": "0.01",
    //            "funding_interval_hours": 8,
    //            "next_funding_time": "1767225600000000000"
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    // v1.mini.s
    //
    //    {
    //        "stream": "v1.mini.s",
    //        "selector": "BTC_USDT_Perp@500",
    //        "sequence_number": "0",
    //        "feed": {
    //            "event_time": "1767198364309454192",
    //            "instrument": "BTC_USDT_Perp",
    //            "mark_price": "87792.25830235",
    //            "index_price": "87806.705713684",
    //            "last_price": "87800.0",
    //            "last_size": "0.032",
    //            "mid_price": "87799.95",
    //            "best_bid_price": "87799.9",
    //            "best_bid_size": "0.151",
    //            "best_ask_price": "87800.0",
    //            "best_ask_size": "5.733"
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    //  v1.mini.d
    //
    //    {
    //        "stream": "v1.mini.d",
    //        "selector": "BTC_USDT_Perp@500",
    //        "sequence_number": "1061718",
    //        "feed": {
    //            "event_time": "1767198266500017753",
    //            "instrument": "BTC_USDT_Perp",
    //            "index_price": "87820.929569614",
    //            "best_ask_size": "5.708"
    //        },
    //        "prev_sequence_number": "1061717"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed", map[string]interface{} {})
    var selector interface{} = this.SafeString(message, "selector")
    var parts interface{} = ccxt.Split(selector, "@")
    var marketId interface{} = this.SafeString(parts, 0)
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ticker interface{} = this.ParseWsTicker(data, market)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, ccxt.Add("ticker::", symbol))
}
func  (this *GrvtCore) ParseWsTicker(message interface{}, optionalArgs ...interface{}) interface{}  {
    // same dict as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTicker(message, market)
}
/**
 * @method
 * @name grvt#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://api-docs.grvt.io/market_data_streams/#trade_1
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *GrvtCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes29215 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes29215)
                ch <- retRes29215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://api-docs.grvt.io/market_data_streams/#trade_1
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.name] the name of the method to call, 'trade' or 'aggTrade', default is 'trade'
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *GrvtCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3088)
            symbols = this.MarketSymbols(symbols)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var limitRaw interface{} = this.SafeInteger(params, "limit", 50) // 50, 200, 500, 1000
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(marketId, "@"), limitRaw))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trade::", ccxt.GetValue(market, "symbol")))
            }
            var request interface{} = map[string]interface{} {
                "stream": "v1.trade",
                "selectors": rawHashes,
            }
        
            trades:= (<-this.SubscribeMultiple(messageHashes, this.Extend(params, request), rawHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.trade",
    //        "selector": "BTC_USDT_Perp@50",
    //        "sequence_number": "0",
    //        "feed": {
    //            "event_time": "1767257046164798775",
    //            "instrument": "BTC_USDT_Perp",
    //            "is_taker_buyer": true,
    //            "size": "0.001",
    //            "price": "87700.1",
    //            "mark_price": "87700.817100682",
    //            "index_price": "87708.566729268",
    //            "interest_rate": "0.0",
    //            "forward_price": "0.0",
    //            "trade_id": "73808524-19",
    //            "venue": "ORDERBOOK",
    //            "is_rpi": false
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed", map[string]interface{} {})
    var selector interface{} = this.SafeString(message, "selector")
    var parts interface{} = ccxt.Split(selector, "@")
    var marketId interface{} = this.SafeString(parts, 0)
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var parsed interface{} = this.ParseWsTrade(data)
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add("trade::", symbol))
}
func  (this *GrvtCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTrade(trade, market)
}
/**
 * @method
 * @name grvt#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.grvt.io/market_data_streams/#candlestick_1
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *GrvtCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3908 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3908)
            symbol = this.Symbol(symbol)
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.grvt.io/market_data_streams/#candlestick_1
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *GrvtCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4098)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var data interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var symbolString interface{} = this.SafeString(data, 0)
                var market interface{} = this.Market(symbolString)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var unfiedTimeframe interface{} = this.SafeString(data, 1, "1")
                var timeframeId interface{} = this.SafeString(this.Timeframes, unfiedTimeframe, unfiedTimeframe)
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(ccxt.Add(marketId, "@"), timeframeId), "-TRADE"))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), unfiedTimeframe))
            }
            var request interface{} = map[string]interface{} {
                "stream": "v1.candle",
                "selectors": rawHashes,
            }
            symboltimeframestoredVariable := (<-this.SubscribeMultiple(messageHashes, this.Extend(params, request), rawHashes))
            symbol := ccxt.GetValue(symboltimeframestoredVariable,0)
            timeframe := ccxt.GetValue(symboltimeframestoredVariable,1)
            stored := ccxt.GetValue(symboltimeframestoredVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(stored).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(stored, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.candle",
    //        "selector": "BTC_USDT_Perp@CI_1_M-TRADE",
    //        "sequence_number": "0",
    //        "feed": {
    //            "open_time": "1767263280000000000",
    //            "close_time": "1767263340000000000",
    //            "open": "87799.1",
    //            "close": "87799.1",
    //            "high": "87799.1",
    //            "low": "87799.1",
    //            "volume_b": "0.0",
    //            "volume_q": "0.0",
    //            "trades": 0,
    //            "instrument": "BTC_USDT_Perp"
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed", map[string]interface{} {})
    var selector interface{} = this.SafeString(message, "selector")
    var parts interface{} = ccxt.Split(selector, "@")
    var marketId interface{} = this.SafeString(parts, 0)
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var secondPart interface{} = this.SafeString(parts, 1)
    var timeframeId interface{} = ccxt.Replace(secondPart, "-TRADE", "")
    var timeframe interface{} = this.FindTimeframe(timeframeId)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.HandleOption("watchOHLCV", "limit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(data, market)
    stored.(ccxt.Appender).Append(parsed)
    var resolveData interface{} = []interface{}{symbol, timeframe, stored}
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
func  (this *GrvtCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseOHLCV(ohlcv, market)
}
/**
 * @method
 * @name grvt#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.grvt.io/market_data_streams/#orderbook-snap
 * @see https://api-docs.grvt.io/market_data_streams/#orderbook-delta
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *GrvtCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4948)
            symbol = this.Symbol(symbol)
        
                retRes49615 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes49615)
                ch <- retRes49615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.grvt.io/market_data_streams/#orderbook-snap
 * @see https://api-docs.grvt.io/market_data_streams/#orderbook-delta
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *GrvtCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5118)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "channel", "v1.book.d")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            var isSnapshot interface{} = ccxt.IsEqual(channel, "v1.book.s")
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrderBookForSymbols() requires a non-empty array of symbols")))
            }
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limitparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "limit", 100)
                limit = ccxt.GetValue(limitparamsVariable,0)
                params = ccxt.GetValue(limitparamsVariable,1)
            }
            var interval interface{} = nil
            intervalparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "interval", 500)
            interval = ccxt.GetValue(intervalparamsVariable,0)
            params = ccxt.GetValue(intervalparamsVariable,1)
            symbols = this.MarketSymbols(symbols)
            var extraPart interface{} = ccxt.Ternary(ccxt.IsTrue(isSnapshot), (ccxt.Add(ccxt.Add(interval, "-"), limit)), interval)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(marketId, "@"), extraPart))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook::", ccxt.GetValue(market, "symbol")))
            }
            var request interface{} = map[string]interface{} {
                "stream": channel,
                "selectors": rawHashes,
            }
        
            orderbook:= (<-this.SubscribeMultiple(messageHashes, this.Extend(request, params), rawHashes))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.book.s",
    //        "selector": "BTC_USDT_Perp@500-100",
    //        "sequence_number": "0",
    //        "feed": {
    //            "event_time": "1767292408400000000",
    //            "instrument": "BTC_USDT_Perp",
    //            "bids": [
    //                {
    //                    "price": "88107.3",
    //                    "size": "5.322",
    //                    "num_orders": 11
    //                },
    //            ],
    //            "asks": [
    //                {
    //                    "price": "88107.4",
    //                    "size": "5.273",
    //                    "num_orders": 37
    //                },
    //            ]
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed", map[string]interface{} {})
    var selector interface{} = this.SafeString(message, "selector")
    var parts interface{} = ccxt.Split(selector, "@")
    var marketId interface{} = this.SafeString(parts, 0)
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeIntegerProduct(data, "event_time", 0.000001)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var sequenceNumber interface{} = this.SafeInteger(message, "sequence_number")
    var stream interface{} = this.SafeString(message, "stream")
    var isSnapshotChannel interface{} = ccxt.IsEqual(stream, "v1.book.s")
    var isSnapshotMessage interface{} = ccxt.IsLessThanOrEqual(sequenceNumber, 0)
    if ccxt.IsTrue(ccxt.IsTrue(isSnapshotChannel) || ccxt.IsTrue(isSnapshotMessage)) {
        var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "size")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeList(data, "asks", []interface{}{})
        var bids interface{} = this.SafeList(data, "bids", []interface{}{})
        this.HandleDeltasWithKeys(ccxt.GetValue(orderbook, "asks"), asks, "price", "size")
        this.HandleDeltasWithKeys(ccxt.GetValue(orderbook, "bids"), bids, "price", "size")
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    ccxt.AddElementToObject(orderbook, "nonce", sequenceNumber)
    var messageHash interface{} = ccxt.Add("orderbook::", symbol)
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *GrvtCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes6048 := (<-this.SignIn())
            ccxt.PanicOnError(retRes6048)
            var wsOptions interface{} = this.SafeDict(this.Options, "ws", map[string]interface{} {})
            var authenticated interface{} = this.SafeString(wsOptions, "token")
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var accountId interface{} = this.SafeString(this.Options, "AuthAccountId")
                var cookieValue interface{} = this.SafeString(this.Options, "AuthCookieValue")
                if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(cookieValue, nil)) || ccxt.IsTrue(ccxt.IsEqual(accountId, nil))) {
                    panic(ccxt.AuthenticationError(ccxt.Add(this.Id, " : at first, you need to authenticate with exchange using signIn() method.")))
                }
                var defaultOptions interface{} = map[string]interface{} {
                    "ws": map[string]interface{} {
                        "options": map[string]interface{} {
                            "headers": map[string]interface{} {
                                "Cookie": cookieValue,
                                "X-Grvt-ccxt.Account-Id": accountId,
                            },
                        },
                    },
                }
                this.ExtendExchangeOptions(defaultOptions)
                this.Client(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateTrading"))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name grvt#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://api-docs.grvt.io/trading_streams/#fill
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.unifiedMargin] use unified margin account
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *GrvtCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var subAccountId interface{} = this.GetSubAccountId(params)
        
            retRes6428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6428)
        
            retRes6438 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6438)
            var messageHashes interface{} = []interface{}{}
            var rawHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(subAccountId, "-"), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("myTrades::", ccxt.GetValue(market, "symbol")))
            } else {
                ccxt.AppendToArray(&messageHashes, "myTrades")
                ccxt.AppendToArray(&rawHashes, subAccountId)
            }
            var request interface{} = map[string]interface{} {
                "stream": "v1.fill",
                "selectors": rawHashes,
            }
        
            trades:= (<-this.SubscribeMultiple(messageHashes, this.Extend(request, params), messageHashes, false))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.fill",
    //        "selector": "2147050003876484-BTC_USDT_Perp",
    //        "sequence_number": "1",
    //        "feed": {
    //            "event_time": "1767354369431470728",
    //            "sub_account_id": "2147050003876484",
    //            "instrument": "BTC_USDT_Perp",
    //            "is_buyer": true,
    //            "is_taker": true,
    //            "size": "0.001",
    //            "price": "89473.4",
    //            "mark_price": "89475.966335827",
    //            "index_price": "89515.016819765",
    //            "interest_rate": "0.0",
    //            "forward_price": "0.0",
    //            "realized_pnl": "0.0",
    //            "fee": "0.040263",
    //            "fee_rate": "0.045",
    //            "trade_id": "74150425-1",
    //            "order_id": "0x0101010503a12f6e000000007791f1bd",
    //            "venue": "ORDERBOOK",
    //            "is_liquidation": false,
    //            "client_order_id": "99191900",
    //            "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
    //            "broker": "UNSPECIFIED",
    //            "is_rpi": false,
    //            "builder": "0x00",
    //            "builder_fee_rate": "0.0",
    //            "builder_fee": "0"
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trade interface{} = this.ParseWsMyTrade(data)
    this.MyTrades.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, ccxt.Add("myTrades::", ccxt.GetValue(trade, "symbol")))
    client.(ccxt.ClientInterface).Resolve(this.MyTrades, "myTrades")
}
func  (this *GrvtCore) ParseWsMyTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTrade(trade, market)
}
/**
 * @method
 * @name grvt#watchPositions
 * @see https://api-docs.grvt.io/trading_streams/#positions
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *GrvtCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var subAccountId interface{} = this.GetSubAccountId(params)
        
            retRes7298 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes7298)
        
            retRes7308 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7308)
            symbols = this.MarketSymbols(symbols)
            var rawHashes interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(subAccountId, "-"), ccxt.GetValue(market, "id")))
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("positions::", ccxt.GetValue(market, "symbol")))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "positions")
                ccxt.AppendToArray(&rawHashes, subAccountId)
            }
            var request interface{} = map[string]interface{} {
                "stream": "v1.position",
                "selectors": rawHashes,
            }
        
            newPositions:= (<-this.SubscribeMultiple(messageHashes, this.Extend(request, params), rawHashes, false))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandlePosition(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.position",
    //        "selector": "2147050003876484-BTC_USDT_Perp",
    //        "sequence_number": "0",
    //        "feed": {
    //            "event_time": "1767356959482262748",
    //            "sub_account_id": "2147050003876484",
    //            "instrument": "BTC_USDT_Perp",
    //            "size": "0.001",
    //            "notional": "89.430118",
    //            "entry_price": "89426.4",
    //            "exit_price": "0.0",
    //            "mark_price": "89430.118505969",
    //            "unrealized_pnl": "0.003718",
    //            "realized_pnl": "0.0",
    //            "total_pnl": "0.003718",
    //            "roi": "0.0041",
    //            "quote_index_price": "0.999101105",
    //            "est_liquidation_price": "74347.153505969",
    //            "leverage": "20.0",
    //            "cumulative_fee": "0.040241",
    //            "cumulative_realized_funding_payment": "0.0",
    //            "margin_type": "CROSS"
    //        },
    //        "prev_sequence_number": "0"
    //    }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var data interface{} = this.SafeDict(message, "feed")
    var position interface{} = this.ParseWsPosition(data)
    var symbol interface{} = this.SafeString(position, "symbol")
    this.Positions.(ccxt.Appender).Append(position)
    var newPositions interface{} = []interface{}{}
    ccxt.AppendToArray(&newPositions, position)
    client.(ccxt.ClientInterface).Resolve(newPositions, ccxt.Add("positions::", symbol))
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
func  (this *GrvtCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParsePosition(position, market)
}
/**
 * @method
 * @name grvt#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://api-docs.grvt.io/trading_streams/#order_1-feed-selector
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *GrvtCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var subAccountId interface{} = this.GetSubAccountId(params)
        
            retRes8168 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8168)
        
            retRes8178 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8178)
            var messageHashes interface{} = []interface{}{}
            var rawHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                ccxt.AppendToArray(&messageHashes, "orders")
                ccxt.AppendToArray(&rawHashes, subAccountId)
            } else {
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("order::", ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&rawHashes, ccxt.Add(ccxt.Add(subAccountId, "-"), ccxt.GetValue(market, "id")))
            }
            var request interface{} = map[string]interface{} {
                "stream": "v1.order",
                "selectors": rawHashes,
            }
        
            orders:= (<-this.SubscribeMultiple(messageHashes, this.Extend(request, params), rawHashes, false))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) HandleOrder(client interface{}, message interface{})  {
    //
    //    {
    //        "stream": "v1.order",
    //        "selector": "2147050003876484",
    //        "sequence_number": "17",
    //        "feed": {
    //            "order_id": "0x010101050390cd89000000007799a374",
    //            "sub_account_id": "2147050003876484",
    //            "is_market": false,
    //            "time_in_force": "GOOD_TILL_TIME",
    //            "post_only": false,
    //            "reduce_only": false,
    //            "legs": [
    //                {
    //                    "instrument": "BTC_USDT_Perp",
    //                    "size": "0.001",
    //                    "limit_price": "87443.0",
    //                    "is_buying_asset": true
    //                }
    //            ],
    //            "signature": {
    //                "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
    //                "r": "0x4d2b96fdf384f9d8f050e3d72327813a7308969d11dba179eaec514c3427f059",
    //                "s": "0x42717bf56091606691a569d612f302ac27e51d41df840ae217dcd0310790cd89",
    //                "v": 28,
    //                "expiration": "1769951360245000000",
    //                "nonce": 747860882,
    //                "chain_id": "0"
    //            },
    //            "metadata": {
    //                "client_order_id": "747860882",
    //                "create_time": "1767359366686762920",
    //                "trigger": {
    //                    "trigger_type": "UNSPECIFIED",
    //                    "tpsl": {
    //                        "trigger_by": "UNSPECIFIED",
    //                        "trigger_price": "0.0",
    //                        "close_position": false
    //                    }
    //                },
    //                "broker": "UNSPECIFIED",
    //                "is_position_transfer": false,
    //                "allow_crossing": false
    //            },
    //            "state": {
    //                "status": "OPEN",
    //                "reject_reason": "UNSPECIFIED",
    //                "book_size": [
    //                    "0.001"
    //                ],
    //                "traded_size": [
    //                    "0.0"
    //                ],
    //                "update_time": "1767359366686762920",
    //                "avg_fill_price": [
    //                    "0.0"
    //                ]
    //            },
    //            "builder": "0x00",
    //            "builder_fee": "0.0"
    //        },
    //        "prev_sequence_number": "16"
    //    }
    //
    var data interface{} = this.SafeDict(message, "feed")
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var order interface{} = this.ParseWsOrder(data)
    this.Orders.(ccxt.Appender).Append(order)
    client.(ccxt.ClientInterface).Resolve(this.Orders, "orders")
    var ordersForSymbol interface{} = this.FilterBySymbolSinceLimit(this.Orders, ccxt.GetValue(order, "symbol"), nil, nil, true)
    client.(ccxt.ClientInterface).Resolve(ordersForSymbol, ccxt.Add("orders::", ccxt.GetValue(order, "symbol")))
}
func  (this *GrvtCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseOrder(order, market)
}
func  (this *GrvtCore) HandleErrorMessage(client interface{}, response interface{}) interface{}  {
    //
    //    {
    //        "jsonrpc": "2.0",
    //        "error": {
    //            "code": 3000,
    //            "message": "Instrument is invalid"
    //        },
    //        "id": 1,
    //        "method": "subscribe"
    //    }
    //
    var error interface{} = this.SafeDict(response, "error")
    var errorCode interface{} = this.SafeString(error, "code")
    if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
        var body interface{} = this.Json(response)
        var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), body)
        var message interface{} = this.SafeString(error, "message")
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), body)))
    }
    return false
}


func (this *GrvtCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
