package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BlofinCore struct {
	*ccxt.BlofinCore
	base *ccxt.BlofinCore
}

func NewBlofinCore() *BlofinCore {
    p := &BlofinCore{}
	base := &ccxt.BlofinCore{}
	p.base = base
	p.BlofinCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BlofinCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrders": true,
            "watchOrdersForSymbols": true,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "swap": map[string]interface{} {
                        "public": "wss://openapi.blofin.com/ws/public",
                        "private": "wss://openapi.blofin.com/ws/private",
                    },
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "swap": map[string]interface{} {
                        "public": "wss://demo-trading-openapi.blofin.com/ws/public",
                        "private": "wss://demo-trading-openapi.blofin.com/ws/private",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "defaultType": "swap",
            "tradesLimit": 1000,
            "watchOrderBook": map[string]interface{} {
                "channel": "books",
            },
            "watchOrderBookForSymbols": map[string]interface{} {
                "channel": "books",
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 25000,
        },
    })
}
func  (this *BlofinCore) Ping(client interface{}) interface{}  {
    return "ping"
}
func  (this *BlofinCore) HandlePong(client interface{}, message interface{})  {
    //
    //   'pong'
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
}
/**
 * @method
 * @name blofin#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.blofin.com/index.html#ws-trades-channel
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BlofinCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTrades")
        
                retRes9215 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes9215)
                ch <- retRes9215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name blofin#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://docs.blofin.com/index.html#ws-trades-channel
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BlofinCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes1078 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1078)
        
            trades:= (<-this.WatchMultipleWrapper(true, "trades", "watchTradesForSymbols", symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var firstMarket interface{} = this.SafeDict(trades, 0)
                var firstSymbol interface{} = this.SafeString(firstMarket, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(firstSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //       arg: {
    //         channel: "trades",
    //         instId: "DOGE-USDT",
    //       },
    //       data : [
    //         <same object as shown in REST example>,
    //         ...
    //       ]
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeList(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(data, nil)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawTrade interface{} = ccxt.GetValue(data, i)
        var trade interface{} = this.ParseWsTrade(rawTrade)
        var symbol interface{} = ccxt.GetValue(trade, "symbol")
        var stored interface{} = this.SafeValue(this.Trades, symbol)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            stored = ccxt.NewArrayCache(limit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        stored.(ccxt.Appender).Append(trade)
        var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
}
func  (this *BlofinCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTrade(trade, market)
}
/**
 * @method
 * @name blofin#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.blofin.com/index.html#ws-order-book-channel
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BlofinCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrderBook")
        
                retRes16815 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes16815)
                ch <- retRes16815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name blofin#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.blofin.com/index.html#ws-order-book-channel
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.depth] the type of order book to subscribe to, default is 'depth/increase100', also accepts 'depth5' or 'depth20' or depth50
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BlofinCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1838 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1838)
            var callerMethodName interface{} = nil
            callerMethodNameparamsVariable := this.HandleParamString(params, "callerMethodName", "watchOrderBookForSymbols")
            callerMethodName = ccxt.GetValue(callerMethodNameparamsVariable,0)
            params = ccxt.GetValue(callerMethodNameparamsVariable,1)
            var channelName interface{} = nil
            channelNameparamsVariable := this.HandleOptionAndParams(params, callerMethodName, "channel", "books")
            channelName = ccxt.GetValue(channelNameparamsVariable,0)
            params = ccxt.GetValue(channelNameparamsVariable,1)
            // due to some problem, temporarily disable other channels
            if ccxt.IsTrue(!ccxt.IsEqual(channelName, "books")) {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), callerMethodName), "() at this moment "), channelName), " is not supported, coming soon")))
            }
        
            orderbook:= (<-this.WatchMultipleWrapper(true, channelName, callerMethodName, symbols, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //   {
    //     arg: {
    //         channel: "books",
    //         instId: "DOGE-USDT",
    //     },
    //     action: "snapshot", // can be 'snapshot' or 'update'
    //     data: {
    //         asks: [   [ 0.08096, 1 ], [ 0.08097, 123 ], ...   ],
    //         bids: [   [ 0.08095, 4 ], [ 0.08094, 237 ], ...   ],
    //         ts: "1707491587909",
    //         prevSeqId: "0", // in case of 'update' there will be some value, less then seqId
    //         seqId: "3374250786",
    //     },
    // }
    //
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var timestamp interface{} = this.SafeInteger(data, "ts")
    var action interface{} = this.SafeString(message, "action")
    if ccxt.IsTrue(ccxt.IsEqual(action, "snapshot")) {
        var orderBookSnapshot interface{} = this.ParseOrderBook(data, symbol, timestamp)
        ccxt.AddElementToObject(orderBookSnapshot, "nonce", this.SafeInteger(data, "seqId"))
        orderbook.(ccxt.OrderBookInterface).Reset(orderBookSnapshot)
    } else {
        var asks interface{} = this.SafeList(data, "asks", []interface{}{})
        var bids interface{} = this.SafeList(data, "bids", []interface{}{})
        this.HandleDeltasWithKeys(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltasWithKeys(ccxt.GetValue(orderbook, "bids"), bids)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
/**
 * @method
 * @name blofin#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.blofin.com/index.html#ws-tickers-channel
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BlofinCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchTicker")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
        
            result:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(result, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name blofin#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.blofin.com/index.html#ws-tickers-channel
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BlofinCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchTickers() requires a list of symbols")))
            }
        
            ticker:= (<-this.WatchMultipleWrapper(true, "tickers", "watchTickers", symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleTicker(client interface{}, message interface{})  {
    //
    // message
    //
    //     {
    //         arg: {
    //             channel: "tickers",
    //             instId: "DOGE-USDT",
    //         },
    //         data: [
    //             <same object as shown in REST example>
    //         ],
    //     }
    //
    this.HandleBidAsk(client, message)
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeList(message, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.ParseWsTicker(ccxt.GetValue(data, i))
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), symbol)
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
    }
}
func  (this *BlofinCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTicker(ticker, market)
}
/**
 * @method
 * @name blofin#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.blofin.com/index.html#ws-tickers-channel
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BlofinCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3228 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3228)
            symbols = this.MarketSymbols(symbols, nil, false)
            var firstMarket interface{} = this.Market(ccxt.GetValue(symbols, 0))
            var channel interface{} = "tickers"
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBidsAsks", firstMarket, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType), "public"))
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&args, map[string]interface{} {
                    "channel": channel,
                    "instId": ccxt.GetValue(market, "id"),
                })
            }
            var request interface{} = this.GetSubscriptionRequest(args)
        
            ticker:= (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), messageHashes))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleBidAsk(client interface{}, message interface{})  {
    var data interface{} = this.SafeList(message, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.ParseWsBidAsk(ccxt.GetValue(data, i))
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        var messageHash interface{} = ccxt.Add("bidask:", symbol)
        ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *BlofinCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instId")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "ts")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "askPrice"),
        "askVolume": this.SafeString(ticker, "askSize"),
        "bid": this.SafeString(ticker, "bidPrice"),
        "bidVolume": this.SafeString(ticker, "bidSize"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name blofin#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BlofinCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOHLCV")
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name blofin#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.blofin.com/index.html#ws-candlesticks-channel
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BlofinCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\\'BTC/USDT\\', \\'1m\\'], [\\'LTC/USDT\\', \\'5m\\']]")))
            }
        
            retRes4108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4108)
            symboltimeframecandlesVariable := (<-this.WatchMultipleWrapper(true, "candle", "watchOHLCVForSymbols", symbolsAndTimeframes, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    // message
    //
    //     {
    //         arg: {
    //             channel: "candle1m",
    //             instId: "DOGE-USDT",
    //         },
    //         data: [
    //             [ same object as shown in REST example ]
    //         ],
    //     }
    //
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeList(message, "data")
    var marketId interface{} = this.SafeString(arg, "instId")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = ccxt.Replace(channelName, "candle", "")
    var unifiedTimeframe interface{} = this.FindTimeframe(interval)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeDict(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), unifiedTimeframe, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var candle interface{} = ccxt.GetValue(data, i)
        var parsed interface{} = this.ParseOHLCV(candle, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    var resolveData interface{} = []interface{}{symbol, unifiedTimeframe, stored}
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candle", interval), ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(resolveData, messageHash)
}
/**
 * @method
 * @name blofin#watchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.blofin.com/index.html#ws-account-channel
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BlofinCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4678)
        
            retRes4688 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4688)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsEqual(marketType, "spot")) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchBalance() is not supported for spot markets yet")))
            }
            var messageHash interface{} = ccxt.Add(marketType, ":balance")
            var sub interface{} = map[string]interface{} {
                "channel": "account",
            }
            var request interface{} = this.GetSubscriptionRequest([]interface{}{sub})
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType), "private"))
        
                retRes48015 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes48015)
                ch <- retRes48015
                return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         arg: {
    //           channel: "account",
    //         },
    //         data: <same object as shown in REST example>,
    //     }
    //
    var marketType interface{} = "swap" // for now
    if !ccxt.IsTrue((ccxt.InOp(this.Balance, marketType))) {
        ccxt.AddElementToObject(this.Balance, marketType, map[string]interface{} {})
    }
    ccxt.AddElementToObject(this.Balance, marketType, this.ParseWsBalance(message))
    var messageHash interface{} = ccxt.Add(marketType, ":balance")
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, marketType), messageHash)
}
func  (this *BlofinCore) ParseWsBalance(message interface{}) interface{}  {
    return this.ParseBalance(message)
}
/**
 * @method
 * @name biofin#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.blofin.com/index.html#ws-order-channel
 * @see https://docs.blofin.com/index.html#ws-algo-orders-channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for trigger orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure
 */
func  (this *BlofinCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            ccxt.AddElementToObject(params, "callerMethodName", "watchOrders")
            var symbolsArray interface{} = ccxt.Ternary(ccxt.IsTrue((!ccxt.IsEqual(symbol, nil))), []interface{}{symbol}, []interface{}{})
        
                retRes52115 :=  (<-this.WatchOrdersForSymbols(symbolsArray, since, limit, params))
                ccxt.PanicOnError(retRes52115)
                ch <- retRes52115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name blofin#watchOrdersForSymbols
 * @description watches information on multiple orders made by the user across multiple symbols
 * @see https://docs.blofin.com/index.html#ws-order-channel
 * @see https://docs.blofin.com/index.html#ws-algo-orders-channel
 * @param {string[]} symbols
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set to true for trigger orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure
 */
func  (this *BlofinCore) WatchOrdersForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5388 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5388)
        
            retRes5398 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5398)
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var channel interface{} = ccxt.Ternary(ccxt.IsTrue(trigger), "orders-algo", "orders")
        
            orders:= (<-this.WatchMultipleWrapper(false, channel, "watchOrdersForSymbols", symbols, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(orders, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(orders).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         action: 'update',
    //         arg: { channel: 'orders' },
    //         data: [
    //           <same object as shown in REST example>
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeList(message, "data")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = this.ParseWsOrder(ccxt.GetValue(data, i))
        var symbol interface{} = ccxt.GetValue(order, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), symbol)
        orders.(ccxt.Appender).Append(order)
        client.(ccxt.ClientInterface).Resolve(orders, messageHash)
        client.(ccxt.ClientInterface).Resolve(orders, channelName)
    }
}
func  (this *BlofinCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseOrder(order, market)
}
/**
 * @method
 * @name blofin#watchPositions
 * @see https://docs.blofin.com/index.html#ws-positions-channel
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BlofinCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5968 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5968)
        
            retRes5978 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5978)
        
            newPositions:= (<-this.WatchMultipleWrapper(false, "positions", "watchPositions", symbols, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         arg: { channel: 'positions' },
    //         data: [
    //           <same object as shown in REST example>
    //         ]
    //     }
    //
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var arg interface{} = this.SafeDict(message, "arg")
    var channelName interface{} = this.SafeString(arg, "channel")
    var data interface{} = this.SafeList(message, "data")
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var position interface{} = this.ParseWsPosition(ccxt.GetValue(data, i))
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
        var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), ccxt.GetValue(position, "symbol"))
        client.(ccxt.ClientInterface).Resolve(position, messageHash)
    }
}
func  (this *BlofinCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParsePosition(position, market)
}
func  (this *BlofinCore) WatchMultipleWrapper(isPublic interface{}, channelName interface{}, callerMethodName interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // underlier method for all watch-multiple symbols
            symbolsArray := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbolsArray
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6378)
            callerMethodNameparamsVariable := this.HandleParamString(params, "callerMethodName", callerMethodName)
            callerMethodName = ccxt.GetValue(callerMethodNameparamsVariable,0)
            params = ccxt.GetValue(callerMethodNameparamsVariable,1)
            // if ccxt.OHLCV method are being called, then symbols would be symbolsAndTimeframes (multi-dimensional) array
            var isOHLCV interface{} =     (ccxt.IsEqual(channelName, "candle"))
            var symbols interface{} = ccxt.Ternary(ccxt.IsTrue(isOHLCV), this.GetListFromObjectValues(symbolsArray, 0), symbolsArray)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var firstMarket interface{} = nil
            var firstSymbol interface{} = this.SafeString(symbols, 0)
            if ccxt.IsTrue(!ccxt.IsEqual(firstSymbol, nil)) {
                firstMarket = this.Market(firstSymbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(callerMethodName, firstMarket, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            if ccxt.IsTrue(!ccxt.IsEqual(marketType, "swap")) {
                panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), callerMethodName), "() does not support "), marketType), " markets yet")))
            }
            var rawSubscriptions interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(symbols, nil)) {
                symbols = []interface{}{}
            }
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsGreaterThan(symbolsLength, 0)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var current interface{} = ccxt.GetValue(symbols, i)
                    var market interface{} = nil
                    var channel interface{} = channelName
                    if ccxt.IsTrue(isOHLCV) {
                        market = this.Market(current)
                        var tfArray interface{} = ccxt.GetValue(symbolsArray, i)
                        var tf interface{} = ccxt.GetValue(tfArray, 1)
                        var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                        channel = ccxt.Add(channel, interval)
                    } else {
                        market = this.Market(current)
                    }
                    var topic interface{} = map[string]interface{} {
                        "channel": channel,
                        "instId": ccxt.GetValue(market, "id"),
                    }
                    ccxt.AppendToArray(&rawSubscriptions, topic)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(market, "symbol")))
                }
            } else {
                ccxt.AppendToArray(&rawSubscriptions, map[string]interface{} {
                    "channel": channelName,
                })
                ccxt.AppendToArray(&messageHashes, channelName)
            }
            // private channel are difference, they only need plural channel name for multiple symbols
            if ccxt.IsTrue(this.InArray(channelName, []interface{}{"orders", "orders-algo", "positions"})) {
                rawSubscriptions = []interface{}{map[string]interface{} {
            "channel": channelName,
        }}
            }
            var request interface{} = this.GetSubscriptionRequest(rawSubscriptions)
            var privateOrPublic interface{} = ccxt.Ternary(ccxt.IsTrue(isPublic), "public", "private")
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType), privateOrPublic))
        
                retRes69115 :=  (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), messageHashes))
                ccxt.PanicOnError(retRes69115)
                ch <- retRes69115
                return nil
        
            }()
            return ch
        }
func  (this *BlofinCore) GetSubscriptionRequest(args interface{}) interface{}  {
    return map[string]interface{} {
        "op": "subscribe",
        "args": args,
    }
}
func  (this *BlofinCore) HandleMessage(client interface{}, message interface{})  {
    //
    // message examples
    //
    // {
    //   arg: {
    //     channel: "trades",
    //     instId: "DOGE-USDT",
    //   },
    //   event: "subscribe"
    // }
    //
    // incoming data updates' examples can be seen under each handler method
    //
    var methods interface{} = map[string]interface{} {
        "pong": this.HandlePong,
        "trades": this.HandleTrades,
        "books": this.HandleOrderBook,
        "tickers": this.HandleTicker,
        "candle": this.HandleOHLCV,
        "account": this.HandleBalance,
        "orders": this.HandleOrders,
        "orders-algo": this.HandleOrders,
        "positions": this.HandlePositions,
    }
    var method interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(message, "pong")) {
        method = this.SafeValue(methods, "pong")
    } else {
        var event interface{} = this.SafeString(message, "event")
        if ccxt.IsTrue(ccxt.IsEqual(event, "subscribe")) {
            return
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "login")) {
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticate_hash")
            future.(*ccxt.Future).Resolve(true)
            return
        } else if ccxt.IsTrue(ccxt.IsEqual(event, "error")) {
            panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " error: "), this.Json(message))))
        }
        var arg interface{} = this.SafeDict(message, "arg")
        var channelName interface{} = this.SafeString(arg, "channel")
        method = this.SafeValue(methods, channelName)
        if ccxt.IsTrue(!ccxt.IsTrue(method) && ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channelName, "candle"), 0))) {
            method = ccxt.GetValue(methods, "candle")
        }
    }
    if ccxt.IsTrue(method) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *BlofinCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var milliseconds interface{} = this.Milliseconds()
            var messageHash interface{} = "authenticate_hash"
            var timestamp interface{} = ccxt.ToString(milliseconds)
            var nonce interface{} = ccxt.Add("n_", timestamp)
            var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("/users/self/verify", "GET"), timestamp), ""), nonce)
            var signature interface{} = this.StringToBase64(this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256))
            var request interface{} = map[string]interface{} {
                "op": "login",
                "args": []interface{}{map[string]interface{} {
            "apiKey": this.ApiKey,
            "passphrase": this.Password,
            "timestamp": timestamp,
            "nonce": nonce,
            "sign": signature,
        }},
            }
            var marketType interface{} = "swap" // for now
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType), "private"))
        
            retRes7768 := (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
            ccxt.PanicOnError(retRes7768)
                return nil
            }()
            return ch
        }


func (this *BlofinCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
