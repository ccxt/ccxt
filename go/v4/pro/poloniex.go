package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type PoloniexCore struct {
	*ccxt.PoloniexCore
	base *ccxt.PoloniexCore
}

func NewPoloniexCore() *PoloniexCore {
    p := &PoloniexCore{}
	base := &ccxt.PoloniexCore{}
	p.base = base
	p.PoloniexCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *PoloniexCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchBalance": true,
            "watchStatus": false,
            "watchOrders": true,
            "watchMyTrades": true,
            "createOrderWs": true,
            "editOrderWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": true,
            "cancelOrdersWs": true,
            "cancelAllOrdersWs": true,
            "fetchTradesWs": false,
            "fetchBalanceWs": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.poloniex.com/ws/public",
                    "private": "wss://ws.poloniex.com/ws/private",
                },
            },
        },
        "options": map[string]interface{} {
            "createMarketBuyOrderRequiresPrice": true,
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "OHLCVLimit": 1000,
            "watchOrderBook": map[string]interface{} {
                "name": "book_lv2",
            },
            "connectionsLimit": 2000,
            "requestsLimit": 500,
            "timeframes": map[string]interface{} {
                "1m": "candles_minute_1",
                "5m": "candles_minute_5",
                "10m": "candles_minute_10",
                "15m": "candles_minute_15",
                "30m": "candles_minute_30",
                "1h": "candles_hour_1",
                "2h": "candles_hour_2",
                "4h": "candles_hour_4",
                "6h": "candles_hour_6",
                "12h": "candles_hour_12",
                "1d": "candles_day_1",
                "3d": "candles_day_3",
                "1w": "candles_week_1",
                "1M": "candles_month_1",
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 15000,
            "ping": this.Ping,
        },
    })
}
/**
 * @ignore
 * @method
 * @description authenticates the user to access private web socket channels
 * @see https://api-docs.poloniex.com/spot/websocket/authentication
 * @returns {object} response from exchange
 */
func  (this *PoloniexCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var timestamp interface{} = this.NumberToString(this.Milliseconds())
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(future, nil)) {
                var accessPath interface{} = "/ws"
                var requestString interface{} = ccxt.Add(ccxt.Add(ccxt.Add("GET\n", accessPath), "\nsignTimestamp="), timestamp)
                var signature interface{} = this.Hmac(this.Encode(requestString), this.Encode(this.Secret), ccxt.Sha256, "base64")
                var request interface{} = map[string]interface{} {
                    "event": "subscribe",
                    "channel": []interface{}{"auth"},
                    "params": map[string]interface{} {
                        "key": this.ApiKey,
                        "signTimestamp": timestamp,
                        "signature": signature,
                        "signatureMethod": "HmacSHA256",
                        "signatureVersion": "2",
                    },
                }
                var message interface{} = this.Extend(request, params)
                
            future = (<-this.Watch(url, messageHash, message, messageHash))
                    ccxt.PanicOnError(future)
                //
                //    {
                //        "data": {
                //            "success": true,
                //            "ts": 1645597033915
                //        },
                //        "channel": "auth"
                //    }
                //
                //    # Failure to return results
                //
                //    {
                //        "data": {
                //            "success": false,
                //            "message": "Authentication failed!",
                //            "ts": 1646276295075
                //        },
                //        "channel": "auth"
                //    }
                //
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @param {string} name name of the channel
 * @param {string} messageHash unique identifier for the message
 * @param {boolean} isPrivate true for the authenticated url, false for the public url
 * @param {string[]} [symbols] CCXT market symbols
 * @param {object} [params] extra parameters specific to the poloniex api
 * @returns {object} data from the websocket stream
 */
func  (this *PoloniexCore) Subscribe(name interface{}, messageHash interface{}, isPrivate interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var publicOrPrivate interface{} = ccxt.Ternary(ccxt.IsTrue(isPrivate), "private", "public")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), publicOrPrivate)
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "channel": []interface{}{name},
            }
            var marketIds interface{} = []interface{}{}
            if ccxt.IsTrue(this.IsEmpty(symbols)) {
                ccxt.AppendToArray(&marketIds, "all")
            } else {
                messageHash = ccxt.Add(ccxt.Add(messageHash, "::"), ccxt.Join(symbols, ","))
                marketIds = this.MarketIds(symbols)
            }
            if ccxt.IsTrue(!ccxt.IsEqual(name, "balances")) {
                ccxt.AddElementToObject(subscribe, "symbols", marketIds)
            }
            var request interface{} = this.Extend(subscribe, params)
        
                retRes16615 :=  (<-this.Watch(url, messageHash, request, messageHash))
                ccxt.PanicOnError(retRes16615)
                ch <- retRes16615
                return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @description Connects to a websocket channel
 * @param {string} name name of the channel
 * @param {object} [params] extra parameters specific to the poloniex api
 * @returns {object} data from the websocket stream
 */
func  (this *PoloniexCore) TradeRequest(name interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var messageHash interface{} = ccxt.ToString(this.Nonce())
            var subscribe interface{} = map[string]interface{} {
                "id": messageHash,
                "event": name,
                "params": params,
            }
        
                retRes18515 :=  (<-this.Watch(url, messageHash, subscribe, messageHash))
                ccxt.PanicOnError(retRes18515)
                ch <- retRes18515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#createOrderWs
 * @see https://api-docs.poloniex.com/spot/websocket/trade-request#create-order
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the poloniex api endpoint
 * @param {string} [params.timeInForce] GTC (default), IOC, FOK
 * @param {string} [params.clientOrderId] Maximum 64-character length.*
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.amount] quote units for the order
 * @param {boolean} [params.allowBorrow] allow order to be placed by borrowing funds (Default: false)
 * @param {string} [params.stpMode] self-trade prevention, defaults to expire_taker, none: enable self-trade; expire_taker: taker order will be canceled when self-trade happens
 * @param {string} [params.slippageTolerance] used to control the maximum slippage ratio, the value range is greater than 0 and less than 1
 * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *PoloniexCore) CreateOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    price := ccxt.GetArg(optionalArgs, 0, nil)
            _ = price
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2118)
        
            retRes2128 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes2128)
            var market interface{} = this.Market(symbol)
            var uppercaseType interface{} = ccxt.ToUpper(typeVar)
            var uppercaseSide interface{} = ccxt.ToUpper(side)
            var isPostOnly interface{} = this.IsPostOnly(ccxt.IsEqual(uppercaseType, "MARKET"), ccxt.IsEqual(uppercaseType, "LIMIT_MAKER"), params)
            if ccxt.IsTrue(isPostOnly) {
                uppercaseType = "LIMIT_MAKER"
            }
            var request interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
                "side": ccxt.ToUpper(side),
                "type": ccxt.ToUpper(typeVar),
            }
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(uppercaseType, "MARKET"))) && ccxt.IsTrue((ccxt.IsEqual(uppercaseSide, "BUY")))) {
                var quoteAmount interface{} = nil
                var createMarketBuyOrderRequiresPrice interface{} = true
                createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
                createMarketBuyOrderRequiresPrice = ccxt.GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0)
                params = ccxt.GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                var cost interface{} = this.SafeNumber(params, "cost")
                params = this.Omit(params, "cost")
                if ccxt.IsTrue(!ccxt.IsEqual(cost, nil)) {
                    quoteAmount = this.CostToPrecision(symbol, cost)
                } else if ccxt.IsTrue(createMarketBuyOrderRequiresPrice) {
                    if ccxt.IsTrue(ccxt.IsEqual(price, nil)) {
                        panic(ccxt.InvalidOrder(ccxt.Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
                    } else {
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var costRequest interface{} = ccxt.Precise.StringMul(amountString, priceString)
                        quoteAmount = this.CostToPrecision(symbol, costRequest)
                    }
                } else {
                    quoteAmount = this.CostToPrecision(symbol, amount)
                }
                ccxt.AddElementToObject(request, "amount", quoteAmount)
            } else {
                ccxt.AddElementToObject(request, "quantity", this.AmountToPrecision(ccxt.GetValue(market, "symbol"), amount))
                if ccxt.IsTrue(!ccxt.IsEqual(price, nil)) {
                    ccxt.AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
            }
        
            orders:= (<-this.TradeRequest("createOrder", this.Extend(request, params)))
            ccxt.PanicOnError(orders)
            var order interface{} = this.SafeDict(orders, 0)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#cancelOrderWs
 * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-multiple-orders
 * @description cancel multiple orders
 * @param {string} id order id
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the poloniex api endpoint
 * @param {string} [params.clientOrderId] client order id
 * @returns {object} an list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *PoloniexCore) CancelOrderWs(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if ccxt.IsTrue(!ccxt.IsEqual(clientOrderId, nil)) {
                var clientOrderIds interface{} = this.SafeValue(params, "clientOrderId", []interface{}{})
                ccxt.AddElementToObject(params, "clientOrderIds", this.ArrayConcat(clientOrderIds, []interface{}{clientOrderId}))
            }
        
            orders:= (<-this.CancelOrdersWs([]interface{}{id}, symbol, params))
            ccxt.PanicOnError(orders)
            var order interface{} = this.SafeDict(orders, 0)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#cancelOrdersWs
 * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-multiple-orders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the poloniex api endpoint
 * @param {string[]} [params.clientOrderIds] client order ids
 * @returns {object} an list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *PoloniexCore) CancelOrdersWs(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2918 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2918)
        
            retRes2928 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes2928)
            var request interface{} = map[string]interface{} {
                "orderIds": ids,
            }
        
                retRes29615 :=  (<-this.TradeRequest("cancelOrders", this.Extend(request, params)))
                ccxt.PanicOnError(retRes29615)
                ch <- retRes29615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#cancelAllOrdersWs
 * @see https://api-docs.poloniex.com/spot/websocket/trade-request#cancel-all-orders
 * @description cancel all open orders of a type. Only applicable to ccxt.Option in Portfolio Margin mode, and MMP privilege is required.
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the poloniex api endpoint
 * @returns {object[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *PoloniexCore) CancelAllOrdersWs(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3098)
        
            retRes3108 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes3108)
        
                retRes31115 :=  (<-this.TradeRequest("cancelAllOrders", params))
                ccxt.PanicOnError(retRes31115)
                ch <- retRes31115
                return nil
        
            }()
            return ch
        }
func  (this *PoloniexCore) HandleOrderRequest(client interface{}, message interface{})  {
    //
    //    {
    //        "id": "1234567",
    //        "data": [{
    //           "orderId": 205343650954092544,
    //           "clientOrderId": "",
    //           "message": "",
    //           "code": 200
    //        }]
    //    }
    //
    var messageHash interface{} = this.SafeString(message, "id")
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var orders interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = ccxt.GetValue(data, i)
        var parsedOrder interface{} = this.ParseWsOrder(order)
        ccxt.AppendToArray(&orders, parsedOrder)
    }
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
}
/**
 * @method
 * @name poloniex#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#candlesticks
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *PoloniexCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3508 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3508)
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var channel interface{} = this.SafeString(timeframes, timeframe, timeframe)
            if ccxt.IsTrue(ccxt.IsEqual(channel, nil)) {
                panic(ccxt.BadRequest(ccxt.Add(ccxt.Add(this.Id, " watchOHLCV cannot take a timeframe of "), timeframe)))
            }
        
            ohlcv:= (<-this.Subscribe(channel, channel, false, []interface{}{symbol}, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *PoloniexCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3738 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3738)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- this.SafeValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#ticker
 * @param {string[]} symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *PoloniexCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3898 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3898)
            var name interface{} = "ticker"
            symbols = this.MarketSymbols(symbols)
        
            newTickers:= (<-this.Subscribe(name, name, false, symbols, params))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newTickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *PoloniexCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes41115 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes41115)
                ch <- retRes41115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchTradesForSymbols
 * @description get the list of most recent trades for a list of symbols
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#trades
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *PoloniexCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4268)
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            var name interface{} = "trades"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var marketIds interface{} = this.MarketIds(symbols)
            var subscribe interface{} = map[string]interface{} {
                "event": "subscribe",
                "channel": []interface{}{name},
                "symbols": marketIds,
            }
            var request interface{} = this.Extend(subscribe, params)
            var messageHashes interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(name, "::"), ccxt.GetValue(symbols, i)))
                }
            }
        
            trades:= (<-this.WatchMultiple(url, messageHashes, request, messageHashes))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.poloniex.com/spot/websocket/market-data#book-level-2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] not used by poloniex watchOrderBook
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *PoloniexCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4658 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4658)
            var watchOrderBookOptions interface{} = this.SafeValue(this.Options, "watchOrderBook")
            var name interface{} = this.SafeString(watchOrderBookOptions, "name", "book_lv2")
            nameparamsVariable := this.HandleOptionAndParams(params, "method", "name", name)
            name = ccxt.GetValue(nameparamsVariable,0)
            params = ccxt.GetValue(nameparamsVariable,1)
        
            orderbook:= (<-this.Subscribe(name, name, false, []interface{}{symbol}, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://api-docs.poloniex.com/spot/websocket/order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] not used by poloniex watchOrders
 * @param {int} [limit] not used by poloniex watchOrders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *PoloniexCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4858)
            var name interface{} = "orders"
        
            retRes4878 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4878)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
            }
            var symbols interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(symbol, nil))), nil, []interface{}{symbol})
        
            orders:= (<-this.Subscribe(name, name, true, symbols, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(orders, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchMyTrades
 * @description watches information on multiple trades made by the user using orders stream
 * @see https://api-docs.poloniex.com/spot/websocket/order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] not used by poloniex watchMyTrades
 * @param {int} [limit] not used by poloniex watchMyTrades
 * @param {object} [params] extra parameters specific to the poloniex strean
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *PoloniexCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5118)
            var name interface{} = "orders"
            var messageHash interface{} = "myTrades"
        
            retRes5148 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5148)
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
            }
            var symbols interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(symbol, nil))), nil, []interface{}{symbol})
        
            trades:= (<-this.Subscribe(name, messageHash, true, symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-docs.poloniex.com/spot/websocket/balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *PoloniexCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5358)
            var name interface{} = "balances"
        
            retRes5378 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5378)
        
                retRes53815 :=  (<-this.Subscribe(name, name, true, nil, params))
                ccxt.PanicOnError(retRes53815)
                ch <- retRes53815
                return nil
        
            }()
            return ch
        }
func  (this *PoloniexCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "amount": "840.7240416",
    //        "high": "24832.35",
    //        "quantity": "0.033856",
    //        "tradeCount": 1,
    //        "low": "24832.35",
    //        "closeTime": 1676942519999,
    //        "startTime": 1676942460000,
    //        "close": "24832.35",
    //        "open": "24832.35",
    //        "ts": 1676942492072
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "startTime"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "quantity")}
}
func  (this *PoloniexCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "channel": "candles_minute_1",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "amount": "840.7240416",
    //                "high": "24832.35",
    //                "quantity": "0.033856",
    //                "tradeCount": 1,
    //                "low": "24832.35",
    //                "closeTime": 1676942519999,
    //                "startTime": 1676942460000,
    //                "close": "24832.35",
    //                "open": "24832.35",
    //                "ts": 1676942492072
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    data = this.SafeValue(data, 0)
    var channel interface{} = this.SafeString(message, "channel")
    var marketId interface{} = this.SafeString(data, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(symbol)
    var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
    var timeframe interface{} = this.FindTimeframe(channel, timeframes)
    var messageHash interface{} = ccxt.Add(ccxt.Add(channel, "::"), symbol)
    var parsed interface{} = this.ParseWsOHLCV(data, market)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        stored.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    }
    return message
}
func  (this *PoloniexCore) HandleTrade(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "channel": "trades",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "amount": "13.41634893",
    //                "quantity": "0.000537",
    //                "takerSide": "buy",
    //                "createTime": 1676950548834,
    //                "price": "24983.89",
    //                "id": "62486976",
    //                "ts": 1676950548839
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var item interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(item, "symbol")
        if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
            var trade interface{} = this.ParseWsTrade(item)
            var symbol interface{} = ccxt.GetValue(trade, "symbol")
            var typeVar interface{} = "trades"
            var messageHash interface{} = ccxt.Add(ccxt.Add(typeVar, "::"), symbol)
            var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
            if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
                var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
                tradesArray = ccxt.NewArrayCache(tradesLimit)
                ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
            }
            tradesArray.(ccxt.Appender).Append(trade)
            client.(ccxt.ClientInterface).Resolve(tradesArray, messageHash)
        }
    }
    return message
}
func  (this *PoloniexCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // handleTrade
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "amount": "13.41634893",
    //        "quantity": "0.000537",
    //        "takerSide": "buy",
    //        "createTime": 1676950548834,
    //        "price": "24983.89",
    //        "id": "62486976",
    //        "ts": 1676950548839
    //    }
    //
    // private trade
    //    {
    //        "orderId":"186250258089635840",
    //        "tradeId":"62036513",
    //        "clientOrderId":"",
    //        "accountType":"SPOT",
    //        "eventType":"trade",
    //        "symbol":"ADA_USDT",
    //        "side":"SELL",
    //        "type":"MARKET",
    //        "price":"0",
    //        "quantity":"3",
    //        "state":"FILLED",
    //        "createTime":1685371921891,
    //        "tradeTime":1685371921908,
    //        "tradePrice":"0.37694",
    //        "tradeQty":"3",
    //        "feeCurrency":"USDT",
    //        "tradeFee":"0.00226164",
    //        "tradeAmount":"1.13082",
    //        "filledQuantity":"3",
    //        "filledAmount":"1.13082",
    //        "ts":1685371921945,
    //        "source":"WEB",
    //        "orderAmount":"0",
    //        "matchRole":"TAKER"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "createTime")
    var takerMaker interface{} = this.SafeStringLower2(trade, "matchRole", "taker")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString2(trade, "id", "tradeId"),
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": this.SafeString(trade, "orderId"),
        "type": this.SafeStringLower(trade, "type"),
        "side": this.SafeStringLower2(trade, "takerSide", "side"),
        "takerOrMaker": takerMaker,
        "price": this.OmitZero(this.SafeString2(trade, "tradePrice", "price")),
        "amount": this.OmitZero(this.SafeString2(trade, "filledQuantity", "quantity")),
        "cost": this.SafeString2(trade, "amount", "filledAmount"),
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": this.SafeString(trade, "tradeFee"),
            "currency": this.SafeString(trade, "feeCurrency"),
        },
    }, market)
}
func  (this *PoloniexCore) ParseStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "PENDING_CANCEL": "open",
        "PARTIALLY_CANCELED": "open",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *PoloniexCore) ParseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "type": "LIMIT",
    //        "quantity": "1",
    //        "orderId": "32471407854219264",
    //        "tradeFee": "0",
    //        "clientOrderId": "",
    //        "accountType": "SPOT",
    //        "feeCurrency": "",
    //        "eventType": "place",
    //        "source": "API",
    //        "side": "BUY",
    //        "filledQuantity": "0",
    //        "filledAmount": "0",
    //        "matchRole": "MAKER",
    //        "state": "NEW",
    //        "tradeTime": 0,
    //        "tradeAmount": "0",
    //        "orderAmount": "0",
    //        "createTime": 1648708186922,
    //        "price": "47112.1",
    //        "tradeQty": "0",
    //        "tradePrice": "0",
    //        "tradeId": "0",
    //        "ts": 1648708187469
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "tradeTime")
    var marketId interface{} = this.SafeString(trade, "symbol")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "tradeId"),
        "symbol": this.SafeSymbol(marketId, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": this.SafeString(trade, "orderId"),
        "type": this.SafeStringLower(trade, "type"),
        "side": this.SafeString(trade, "side"),
        "takerOrMaker": this.SafeStringLower(trade, "matchRole"),
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "tradeAmount"),
        "cost": nil,
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": this.SafeString(trade, "tradeFee"),
            "currency": this.SafeString(trade, "feeCurrency"),
        },
    }, market)
}
func  (this *PoloniexCore) HandleOrder(client interface{}, message interface{}) interface{}  {
    //
    // ccxt.Order is created
    //
    //    {
    //        "channel": "orders",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "type": "LIMIT",
    //                "quantity": "1",
    //                "orderId": "32471407854219264",
    //                "tradeFee": "0",
    //                "clientOrderId": "",
    //                "accountType": "SPOT",
    //                "feeCurrency": "",
    //                "eventType": "place",
    //                "source": "API",
    //                "side": "BUY",
    //                "filledQuantity": "0",
    //                "filledAmount": "0",
    //                "matchRole": "MAKER",
    //                "state": "NEW",
    //                "tradeTime": 0,
    //                "tradeAmount": "0",
    //                "orderAmount": "0",
    //                "createTime": 1648708186922,
    //                "price": "47112.1",
    //                "tradeQty": "0",
    //                "tradePrice": "0",
    //                "tradeId": "0",
    //                "ts": 1648708187469
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var orders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit")
        orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = orders
    }
    var marketIds interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var order interface{} = this.SafeValue(data, i)
        var marketId interface{} = this.SafeString(order, "symbol")
        var eventType interface{} = this.SafeString(order, "eventType")
        if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
            var symbol interface{} = this.SafeSymbol(marketId)
            var orderId interface{} = this.SafeString(order, "orderId")
            var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(eventType, "place")) || ccxt.IsTrue(ccxt.IsEqual(eventType, "canceled"))) {
                var parsed interface{} = this.ParseWsOrder(order)
                orders.(ccxt.Appender).Append(parsed)
            } else {
                var previousOrders interface{} = this.SafeValue(orders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
                var previousOrder interface{} = this.SafeValue2(previousOrders, orderId, clientOrderId)
                var trade interface{} = this.ParseWsTrade(order)
                this.HandleMyTrades(client, trade)
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "trades"), nil)) {
                    ccxt.AddElementToObject(previousOrder, "trades", []interface{}{})
                }
                retRes84820 := ccxt.GetValue(previousOrder, "trades")
                ccxt.AppendToArray(&retRes84820, trade)
                ccxt.AddElementToObject(previousOrder, "lastTradeTimestamp", ccxt.GetValue(trade, "timestamp"))
                var totalCost interface{} = "0"
                var totalAmount interface{} = "0"
                var previousOrderTrades interface{} = ccxt.GetValue(previousOrder, "trades")
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(previousOrderTrades)); j++ {
                    var previousOrderTrade interface{} = ccxt.GetValue(previousOrderTrades, j)
                    var cost interface{} = this.NumberToString(ccxt.GetValue(previousOrderTrade, "cost"))
                    var amount interface{} = this.NumberToString(ccxt.GetValue(previousOrderTrade, "amount"))
                    totalCost = ccxt.Precise.StringAdd(totalCost, cost)
                    totalAmount = ccxt.Precise.StringAdd(totalAmount, amount)
                }
                if ccxt.IsTrue(ccxt.Precise.StringGt(totalAmount, "0")) {
                    ccxt.AddElementToObject(previousOrder, "average", this.ParseNumber(ccxt.Precise.StringDiv(totalCost, totalAmount)))
                }
                ccxt.AddElementToObject(previousOrder, "cost", this.ParseNumber(totalCost))
                if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "filled"), nil)) {
                    var tradeAmount interface{} = this.NumberToString(ccxt.GetValue(trade, "amount"))
                    var previousOrderFilled interface{} = this.NumberToString(ccxt.GetValue(previousOrder, "filled"))
                    previousOrderFilled = ccxt.Precise.StringAdd(previousOrderFilled, tradeAmount)
                    ccxt.AddElementToObject(previousOrder, "filled", previousOrderFilled)
                    if ccxt.IsTrue(!ccxt.IsEqual(ccxt.GetValue(previousOrder, "amount"), nil)) {
                        var previousOrderAmount interface{} = this.NumberToString(ccxt.GetValue(previousOrder, "amount"))
                        ccxt.AddElementToObject(previousOrder, "remaining", this.ParseNumber(ccxt.Precise.StringSub(previousOrderAmount, previousOrderFilled)))
                    }
                }
                if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(previousOrder, "fee"), nil)) {
                    ccxt.AddElementToObject(previousOrder, "fee", map[string]interface{} {
    "rate": nil,
    "cost": 0,
    "currency": ccxt.GetValue(ccxt.GetValue(trade, "fee"), "currency"),
})
                }
                if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"), nil))) && ccxt.IsTrue((!ccxt.IsEqual(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost"), nil)))) {
                    var stringOrderCost interface{} = this.NumberToString(ccxt.GetValue(ccxt.GetValue(previousOrder, "fee"), "cost"))
                    var stringTradeCost interface{} = this.NumberToString(ccxt.GetValue(ccxt.GetValue(trade, "fee"), "cost"))
                    ccxt.AddElementToObject(ccxt.GetValue(previousOrder, "fee"), "cost", ccxt.Precise.StringAdd(stringOrderCost, stringTradeCost))
                }
                var rawState interface{} = this.SafeString(order, "state")
                var state interface{} = this.ParseStatus(rawState)
                ccxt.AddElementToObject(previousOrder, "status", state)
                // update the newUpdates count
                orders.(ccxt.Appender).Append(previousOrder)
            }
            ccxt.AppendToArray(&marketIds, marketId)
        }
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(marketIds)); i++ {
        var marketId interface{} = ccxt.GetValue(marketIds, i)
        var market interface{} = this.Market(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add("orders::", symbol)
        client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(orders, "orders")
    return message
}
func  (this *PoloniexCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "type": "LIMIT",
    //        "quantity": "1",
    //        "orderId": "32471407854219264",
    //        "tradeFee": "0",
    //        "clientOrderId": "",
    //        "accountType": "SPOT",
    //        "feeCurrency": "",
    //        "eventType": "place",
    //        "source": "API",
    //        "side": "BUY",
    //        "filledQuantity": "0",
    //        "filledAmount": "0",
    //        "matchRole": "MAKER",
    //        "state": "NEW",
    //        "tradeTime": 0,
    //        "tradeAmount": "0",
    //        "orderAmount": "0",
    //        "createTime": 1648708186922,
    //        "price": "47112.1",
    //        "tradeQty": "0",
    //        "tradePrice": "0",
    //        "tradeId": "0",
    //        "ts": 1648708187469
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "orderId")
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var marketId interface{} = this.SafeString(order, "symbol")
    var timestamp interface{} = this.SafeString(order, "ts")
    var filledAmount interface{} = this.SafeString(order, "filledAmount")
    var status interface{} = this.SafeString(order, "state")
    var trades interface{} = nil
    if !ccxt.IsTrue(ccxt.Precise.StringEq(filledAmount, "0")) {
        trades = []interface{}{}
        var trade interface{} = this.ParseWsOrderTrade(order)
        ccxt.AppendToArray(&trades, trade)
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": this.SafeSymbol(marketId, market),
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "type": this.SafeString(order, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString(order, "side"),
        "price": this.SafeString(order, "price"),
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": this.SafeString(order, "quantity"),
        "cost": nil,
        "average": nil,
        "filled": filledAmount,
        "remaining": this.SafeString(order, "remaining_size"),
        "status": this.ParseStatus(status),
        "fee": map[string]interface{} {
            "rate": nil,
            "cost": this.SafeString(order, "tradeFee"),
            "currency": this.SafeString(order, "feeCurrency"),
        },
        "trades": trades,
    })
}
func  (this *PoloniexCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "channel": "ticker",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "startTime": 1677280800000,
    //                "open": "23154.32",
    //                "high": "23212.21",
    //                "low": "22761.01",
    //                "close": "23148.86",
    //                "quantity": "105.179566",
    //                "amount": "2423161.17436702",
    //                "tradeCount": 17582,
    //                "dailyChange": "-0.0002",
    //                "markPrice": "23151.09",
    //                "closeTime": 1677367197924,
    //                "ts": 1677367251090
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var newTickers interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var item interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(item, "symbol")
        if ccxt.IsTrue(!ccxt.IsEqual(marketId, nil)) {
            var ticker interface{} = this.ParseTicker(item)
            var symbol interface{} = ccxt.GetValue(ticker, "symbol")
            ccxt.AddElementToObject(this.Tickers, symbol, ticker)
            ccxt.AddElementToObject(newTickers, symbol, ticker)
        }
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "ticker::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var tickers interface{} = this.FilterByArray(newTickers, "symbol", symbols)
        if !ccxt.IsTrue(this.IsEmpty(tickers)) {
            client.(ccxt.ClientInterface).Resolve(tickers, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newTickers, "ticker")
    return message
}
func  (this *PoloniexCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // snapshot
    //
    //    {
    //        "channel": "book_lv2",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "createTime": 1677368876253,
    //                "asks": [
    //                    ["5.65", "0.02"],
    //                    ...
    //                ],
    //                "bids": [
    //                    ["6.16", "0.6"],
    //                    ...
    //                ],
    //                "lastId": 164148724,
    //                "id": 164148725,
    //                "ts": 1677368876316
    //            }
    //        ],
    //        "action": "snapshot"
    //    }
    //
    // update
    //
    //    {
    //        "channel": "book_lv2",
    //        "data": [
    //            {
    //                "symbol": "BTC_USDT",
    //                "createTime": 1677368876882,
    //                "asks": [
    //                    ["6.35", "3"]
    //                ],
    //                "bids": [
    //                    ["5.65", "0.02"]
    //                ],
    //                "lastId": 164148725,
    //                "id": 164148726,
    //                "ts": 1677368876890
    //            }
    //        ],
    //        "action": "update"
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var typeVar interface{} = this.SafeString(message, "action")
    var snapshot interface{} = ccxt.IsEqual(typeVar, "snapshot")
    var update interface{} = ccxt.IsEqual(typeVar, "update")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var item interface{} = ccxt.GetValue(data, i)
        var marketId interface{} = this.SafeString(item, "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var name interface{} = "book_lv2"
        var messageHash interface{} = ccxt.Add(ccxt.Add(name, "::"), symbol)
        var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, map[string]interface{} {})
        var limit interface{} = this.SafeInteger(subscription, "limit")
        var timestamp interface{} = this.SafeInteger(item, "ts")
        var asks interface{} = this.SafeValue(item, "asks")
        var bids interface{} = this.SafeValue(item, "bids")
        if ccxt.IsTrue(ccxt.IsTrue(snapshot) || ccxt.IsTrue(update)) {
            if ccxt.IsTrue(snapshot) {
                ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
            }
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            if ccxt.IsTrue(!ccxt.IsEqual(bids, nil)) {
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(bids)); j++ {
                    var bid interface{} = this.SafeValue(bids, j)
                    var price interface{} = this.SafeNumber(bid, 0)
                    var amount interface{} = this.SafeNumber(bid, 1)
                    var bidsSide interface{} = ccxt.GetValue(orderbook, "bids")
                    bidsSide.(ccxt.IOrderBookSide).Store(price, amount)
                }
            }
            if ccxt.IsTrue(!ccxt.IsEqual(asks, nil)) {
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(asks)); j++ {
                    var ask interface{} = this.SafeValue(asks, j)
                    var price interface{} = this.SafeNumber(ask, 0)
                    var amount interface{} = this.SafeNumber(ask, 1)
                    var asksSide interface{} = ccxt.GetValue(orderbook, "asks")
                    asksSide.(ccxt.IOrderBookSide).Store(price, amount)
                }
            }
            ccxt.AddElementToObject(orderbook, "symbol", symbol)
            ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
            ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        }
    }
}
func  (this *PoloniexCore) HandleBalance(client interface{}, message interface{})  {
    //
    //    {
    //       "channel": "balances",
    //       "data": [
    //            {
    //                "changeTime": 1657312008411,
    //                "accountId": "1234",
    //                "accountType": "SPOT",
    //                "eventType": "place_order",
    //                "available": "9999999983.668",
    //                "currency": "BTC",
    //                "id": 60018450912695040,
    //                "userId": 12345,
    //                "hold": "16.332",
    //                "ts": 1657312008443
    //            }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    var messageHash interface{} = "balances"
    this.Balance = this.ParseWsBalance(data)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *PoloniexCore) ParseWsBalance(response interface{}) interface{}  {
    //
    //    [
    //        {
    //            "changeTime": 1657312008411,
    //            "accountId": "1234",
    //            "accountType": "SPOT",
    //            "eventType": "place_order",
    //            "available": "9999999983.668",
    //            "currency": "BTC",
    //            "id": 60018450912695040,
    //            "userId": 12345,
    //            "hold": "16.332",
    //            "ts": 1657312008443
    //        }
    //    ]
    //
    var firstBalance interface{} = this.SafeValue(response, 0, map[string]interface{} {})
    var timestamp interface{} = this.SafeInteger(firstBalance, "ts")
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(response)); i++ {
        var balance interface{} = this.SafeValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var newAccount interface{} = this.Account()
        ccxt.AddElementToObject(newAccount, "free", this.SafeString(balance, "available"))
        ccxt.AddElementToObject(newAccount, "used", this.SafeString(balance, "hold"))
        ccxt.AddElementToObject(result, code, newAccount)
    }
    return this.SafeBalance(result)
}
func  (this *PoloniexCore) HandleMyTrades(client interface{}, parsedTrade interface{})  {
    // emulated using the orders' stream
    var messageHash interface{} = "myTrades"
    var symbol interface{} = ccxt.GetValue(parsedTrade, "symbol")
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trades interface{} = this.MyTrades
    trades.(ccxt.Appender).Append(parsedTrade)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    var symbolMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(trades, symbolMessageHash)
}
func  (this *PoloniexCore) HandlePong(client interface{})  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
}
func  (this *PoloniexCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var typeVar interface{} = this.SafeString(message, "channel")
    var event interface{} = this.SafeString(message, "event")
    if ccxt.IsTrue(ccxt.IsEqual(event, "pong")) {
        client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    }
    var methods interface{} = map[string]interface{} {
        "candles_minute_1": this.HandleOHLCV,
        "candles_minute_5": this.HandleOHLCV,
        "candles_minute_10": this.HandleOHLCV,
        "candles_minute_15": this.HandleOHLCV,
        "candles_minute_30": this.HandleOHLCV,
        "candles_hour_1": this.HandleOHLCV,
        "candles_hour_2": this.HandleOHLCV,
        "candles_hour_4": this.HandleOHLCV,
        "candles_hour_6": this.HandleOHLCV,
        "candles_hour_12": this.HandleOHLCV,
        "candles_day_1": this.HandleOHLCV,
        "candles_day_3": this.HandleOHLCV,
        "candles_week_1": this.HandleOHLCV,
        "candles_month_1": this.HandleOHLCV,
        "book": this.HandleOrderBook,
        "book_lv2": this.HandleOrderBook,
        "ticker": this.HandleTicker,
        "trades": this.HandleTrade,
        "orders": this.HandleOrder,
        "balances": this.HandleBalance,
        "createOrder": this.HandleOrderRequest,
        "cancelOrder": this.HandleOrderRequest,
        "cancelAllOrders": this.HandleOrderRequest,
        "auth": this.HandleAuthenticate,
    }
    var method interface{} = this.SafeValue(methods, typeVar)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "auth")) {
        this.HandleAuthenticate(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, nil)) {
        this.HandleOrderRequest(client, message)
    } else {
        var data interface{} = this.SafeValue(message, "data", []interface{}{})
        var dataLength interface{} =         ccxt.GetArrayLength(data)
        if ccxt.IsTrue(ccxt.IsGreaterThan(dataLength, 0)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}
func  (this *PoloniexCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        message: 'Invalid channel value ["ordersss"]',
    //        event: 'error'
    //    }
    //
    //    {
    //        "orderId": 0,
    //        "clientOrderId": null,
    //        "message": "ccxt.Currency trade disabled",
    //        "code": 21352
    //    }
    //
    //    {
    //       "event": "error",
    //       "message": "Platform in maintenance mode"
    //    }
    //    {
    //       "id":"1722386782048",
    //       "data":[
    //          {
    //             "orderId":0,
    //             "clientOrderId":null,
    //             "message":"available insufficient",
    //             "code":21721
    //          }
    //       ]
    //    }
    //
    var id interface{} = this.SafeString(message, "id")
    var event interface{} = this.SafeString(message, "event")
    var data interface{} = this.SafeList(message, "data")
    var first interface{} = this.SafeDict(data, 0)
    var orderId interface{} = this.SafeString(first, "orderId")
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(event, "error"))) || ccxt.IsTrue((ccxt.IsEqual(orderId, "0")))) {
        
            {
                ret__ := func(this *PoloniexCore) (ret_ interface{}) {
        		    defer func() {
                        if e := recover(); e != nil {
                            if e == "break" {
                                return
                            }
                            ret_ = func(this *PoloniexCore) interface{} {
                                // catch block:
                                            if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                        var messageHash interface{} = "authenticated"
                        client.(ccxt.ClientInterface).Reject(e, messageHash)
                        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                        }
                    } else {
                        client.(ccxt.ClientInterface).Reject(e, id)
                    }
                    return true
                                
                            }(this)
                        }
                    }()
        		    // try block:
                                var error interface{} = this.SafeString(first, "message")
                    var code interface{} = this.SafeString(first, "code")
                    var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                    this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
                    this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), error, feedback)
                    panic(ccxt.ExchangeError(feedback))
        		    
        	    }(this)
            
                    if ret__ != nil {
                        return ret__
                    }
                    return nil
                }
    }
    return false
}
func  (this *PoloniexCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "success": true,
    //        "ret_msg": '',
    //        "op": "auth",
    //        "conn_id": "ce3dpomvha7dha97tvp0-2xh"
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    var success interface{} = this.SafeValue(data, "success")
    var messageHash interface{} = "authenticated"
    if ccxt.IsTrue(success) {
        client.(ccxt.ClientInterface).Resolve(message, messageHash)
    } else {
        error := ccxt.AuthenticationError(ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message)))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
        }
    }
    return message
}
func  (this *PoloniexCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "event": "ping",
    }
}


func (this *PoloniexCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
