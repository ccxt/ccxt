package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type WooCore struct {
	*ccxt.WooCore
	base *ccxt.WooCore
}

func NewWooCore() *WooCore {
    p := &WooCore{}
	base := &ccxt.WooCore{}
	p.base = base
	p.WooCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *WooCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPositions": true,
            "unWatchTicker": true,
            "unWatchTickers": true,
            "unWatchOrderBook": true,
            "unWatchOHLCV": true,
            "unWatchTrades": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://wss.woox.io/ws/stream",
                    "private": "wss://wss.woox.io/v2/ws/private/stream",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://wss.staging.woox.io/ws/stream",
                    "private": "wss://wss.staging.woox.io/v2/ws/private/stream",
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "uid": true,
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "requestId": map[string]interface{} {},
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 9000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "Auth is needed.": ccxt.AuthenticationError,
                },
            },
        },
    })
}
func  (this *WooCore) RequestId(url interface{}) interface{}  {
    var options interface{} = this.SafeValue(this.Options, "requestId", map[string]interface{} {})
    var previousValue interface{} = this.SafeInteger(options, url, 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "requestId"), url, newValue)
    return newValue
}
func  (this *WooCore) WatchPublic(messageHash interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var urlUid interface{} = ccxt.Ternary(ccxt.IsTrue((this.Uid)), ccxt.Add("/", this.Uid), "")
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), urlUid)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes9215 :=  (<-this.Watch(url, messageHash, request, messageHash, subscribe))
                ccxt.PanicOnError(retRes9215)
                ch <- retRes9215
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) UnwatchPublic(subHash interface{}, symbol interface{}, topic interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var urlUid interface{} = ccxt.Ternary(ccxt.IsTrue((this.Uid)), ccxt.Add("/", this.Uid), "")
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), urlUid)
            var requestId interface{} = this.RequestId(url)
            var unsubHash interface{} = ccxt.Add("unsubscribe::", subHash)
            var message interface{} = map[string]interface{} {
                "id": requestId,
                "event": "unsubscribe",
                "topic": subHash,
            }
            var subscription interface{} = map[string]interface{} {
                "id": ccxt.ToString(requestId),
                "unsubscribe": true,
                "symbols": []interface{}{symbol},
                "topic": topic,
                "subMessageHashes": []interface{}{subHash},
                "unsubMessageHashes": []interface{}{unsubHash},
            }
            var symbolsAndTimeframes interface{} = this.SafeList(params, "symbolsAndTimeframes")
            if ccxt.IsTrue(!ccxt.IsEqual(symbolsAndTimeframes, nil)) {
                ccxt.AddElementToObject(subscription, "symbolsAndTimeframes", symbolsAndTimeframes)
                params = this.Omit(params, "symbolsAndTimeframes")
            }
        
                retRes11815 :=  (<-this.Watch(url, unsubHash, this.Extend(message, params), unsubHash, subscription))
                ccxt.PanicOnError(retRes11815)
                ch <- retRes11815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#watchOrderBook
 * @see https://docs.woox.io/#orderbookupdate
 * @see https://docs.woox.io/#orderbook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either (default) 'orderbook' or 'orderbookupdate', default is 'orderbook'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *WooCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1348)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "method", "orderbook")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), method)
            var urlUid interface{} = ccxt.Ternary(ccxt.IsTrue((this.Uid)), ccxt.Add("/", this.Uid), "")
            var url interface{} = ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), urlUid)
            var requestId interface{} = this.RequestId(url)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
                "id": requestId,
            }
            var subscription interface{} = map[string]interface{} {
                "id": ccxt.ToString(requestId),
                "name": method,
                "symbol": ccxt.GetValue(market, "symbol"),
                "limit": limit,
                "params": params,
            }
            if ccxt.IsTrue(ccxt.IsEqual(method, "orderbookupdate")) {
                ccxt.AddElementToObject(subscription, "method", this.HandleOrderBookSubscription)
            }
        
            orderbook:= (<-this.Watch(url, topic, this.Extend(request, params), topic, subscription))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.woox.io/#orderbookupdate
 * @see https://docs.woox.io/#orderbook
 * @param {string} symbol unified symbol of the market
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *WooCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1728)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "method", "orderbook")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var market interface{} = this.Market(symbol)
            var subHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), method)
            var topic interface{} = "orderbook"
        
                retRes17815 :=  (<-this.UnwatchPublic(subHash, ccxt.GetValue(market, "symbol"), topic, params))
                ccxt.PanicOnError(retRes17815)
                ch <- retRes17815
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "PERP_BTC_USDT@orderbookupdate",
    //         "ts": 1722500373999,
    //         "data": {
    //             "symbol": "PERP_BTC_USDT",
    //             "prevTs": 1722500373799,
    //             "bids": [
    //                 [
    //                     0.30891,
    //                     2469.98
    //                 ]
    //             ],
    //             "asks": [
    //                 [
    //                     0.31075,
    //                     2379.63
    //                 ]
    //             ]
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var topic interface{} = this.SafeString(message, "topic")
    var method interface{} = this.SafeString(ccxt.Split(topic, "@"), 1)
    if ccxt.IsTrue(ccxt.IsEqual(method, "orderbookupdate")) {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            return
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
        if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
            ccxt.AppendToArray(orderbook.(ccxt.OrderBookInterface).GetCache(), message)
        } else {
            
                {
                     func(this *WooCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *WooCore) interface{} {
                                    // catch block:
                                                    ccxt.Remove(this.Orderbooks, symbol)
                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), topic)
                            client.(ccxt.ClientInterface).Reject(e, topic)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                        var ts interface{} = this.SafeInteger(message, "ts")
                            if ccxt.IsTrue(ccxt.IsGreaterThan(ts, timestamp)) {
                                this.HandleOrderBookMessage(client, message, orderbook)
                                client.(ccxt.ClientInterface).Resolve(orderbook, topic)
                            }
            		    return nil
            	    }(this)
                
                    }
        }
    } else {
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
            var subscription interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), topic)
            var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
            ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var timestamp interface{} = this.SafeInteger(message, "ts")
        var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
        client.(ccxt.ClientInterface).Resolve(orderbook, topic)
    }
}
func  (this *WooCore) HandleOrderBookSubscription(client interface{}, message interface{}, subscription interface{})  {
    var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
    var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
    var symbol interface{} = this.SafeString(subscription, "symbol") // watchOrderBook
    if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
        ccxt.Remove(this.Orderbooks, symbol)
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}, limit))
    this.Spawn(this.FetchOrderBookSnapshot, client, message, subscription)
}
func  (this *WooCore) FetchOrderBookSnapshot(client interface{}, message interface{}, subscription interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var symbol interface{} = this.SafeString(subscription, "symbol")
            var messageHash interface{} = this.SafeString(message, "topic")
            
                {
                     func(this *WooCore) (ret_ interface{}) {
            		    defer func() {
                            if e := recover(); e != nil {
                                if e == "break" {
                                    return
                                }
                                ret_ = func(this *WooCore) interface{} {
                                    // catch block:
                                            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                    client.(ccxt.ClientInterface).Reject(e, messageHash)
                                    return nil
                                }(this)
                            }
                        }()
            		    // try block:
                                var defaultLimit interface{} = this.SafeInteger(this.Options, "watchOrderBookLimit", 1000)
                    var limit interface{} = this.SafeInteger(subscription, "limit", defaultLimit)
                    var params interface{} = this.SafeValue(subscription, "params")
            
                    snapshot:= (<-this.FetchRestOrderBookSafe(symbol, limit, params))
                    ccxt.PanicOnError(snapshot)
                    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Orderbooks, symbol), nil)) {
            
                        return nil
                    }
                    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
                    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
                    var messages interface{} = orderbook.(ccxt.OrderBookInterface).GetCache()
                    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messages)); i++ {
                        var messageItem interface{} = ccxt.GetValue(messages, i)
                        var ts interface{} = this.SafeInteger(messageItem, "ts")
                        if ccxt.IsTrue(ccxt.IsLessThan(ts, ccxt.GetValue(orderbook, "timestamp"))) {
                            continue
                        } else {
                            this.HandleOrderBookMessage(client, messageItem, orderbook)
                        }
                    }
                    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
                    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            		    return nil
            	    }(this)
                
                    }
                return nil
            }()
            return ch
        }
func  (this *WooCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    var data interface{} = this.SafeDict(message, "data")
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), this.SafeValue(data, "asks", []interface{}{}))
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), this.SafeValue(data, "bids", []interface{}{}))
    var timestamp interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    return orderbook
}
func  (this *WooCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat2(delta, "price", 0)
    var amount interface{} = this.SafeFloat2(delta, "quantity", 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *WooCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name woo#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3208 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3208)
            var name interface{} = "ticker"
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes33015 :=  (<-this.WatchPublic(topic, message))
                ccxt.PanicOnError(retRes33015)
                ch <- retRes33015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3428)
            var method interface{} = nil
            methodparamsVariable := this.HandleOptionAndParams(params, "watchTicker", "method", "ticker")
            method = ccxt.GetValue(methodparamsVariable,0)
            params = ccxt.GetValue(methodparamsVariable,1)
            var market interface{} = this.Market(symbol)
            var subHash interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), method)
            var topic interface{} = "ticker"
        
                retRes34815 :=  (<-this.UnwatchPublic(subHash, ccxt.GetValue(market, "symbol"), topic, params))
                ccxt.PanicOnError(retRes34815)
                ch <- retRes34815
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "PERP_BTC_USDT",
    //         "open": 19441.5,
    //         "close": 20147.07,
    //         "high": 20761.87,
    //         "low": 19320.54,
    //         "volume": 2481.103,
    //         "amount": 50037935.0286,
    //         "count": 3689
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(nil, market),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": this.SafeString(ticker, "close"),
        "last": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "amount"),
        "info": ticker,
    }, market)
}
func  (this *WooCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "topic": "PERP_BTC_USDT@ticker",
    //         "ts": 1657120017000,
    //         "data": {
    //             "symbol": "PERP_BTC_USDT",
    //             "open": 19441.5,
    //             "close": 20147.07,
    //             "high": 20761.87,
    //             "low": 19320.54,
    //             "volume": 2481.103,
    //             "amount": 50037935.0286,
    //             "count": 3689
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data")
    var topic interface{} = this.SafeValue(message, "topic")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var timestamp interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(data, "date", timestamp)
    var ticker interface{} = this.ParseWsTicker(data, market)
    ccxt.AddElementToObject(ticker, "symbol", ccxt.GetValue(market, "symbol"))
    ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(market, "symbol"), ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, topic)
    return message
}
/**
 * @method
 * @name woo#watchTickers
 * @see https://docs.woox.io/#24h-tickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4288 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4288)
            symbols = this.MarketSymbols(symbols)
            var name interface{} = "tickers"
            var topic interface{} = name
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            tickers:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchTickers
 * @see https://docs.woox.io/#24h-tickers
 * @description stops watching a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to stop fetching the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4518 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4518)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchTickers() does not support a symbols argument. Only unwatch all tickers at once")))
            }
            var topic interface{} = "ticker"
            var subHash interface{} = "tickers"
        
                retRes45715 :=  (<-this.UnwatchPublic(subHash, nil, topic, params))
                ccxt.PanicOnError(retRes45715)
                ch <- retRes45715
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleTickers(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"tickers",
    //         "ts":1618820615000,
    //         "data":[
    //             {
    //                 "symbol":"SPOT_OKB_USDT",
    //                 "open":16.297,
    //                 "close":17.183,
    //                 "high":24.707,
    //                 "low":11.997,
    //                 "volume":0,
    //                 "amount":0,
    //                 "count":0
    //             },
    //             {
    //                 "symbol":"SPOT_XRP_USDT",
    //                 "open":1.3515,
    //                 "close":1.43794,
    //                 "high":1.96674,
    //                 "low":0.39264,
    //                 "volume":750127.1,
    //                 "amount":985440.5122,
    //                 "count":396
    //             },
    //         ...
    //         ]
    //     }
    //
    var topic interface{} = this.SafeValue(message, "topic")
    var data interface{} = this.SafeValue(message, "data")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var marketId interface{} = this.SafeString(ccxt.GetValue(data, i), "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var ticker interface{} = this.ParseWsTicker(this.Extend(ccxt.GetValue(data, i), map[string]interface{} {
            "date": timestamp,
        }), market)
        ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(market, "symbol"), ticker)
        ccxt.AppendToArray(&result, ticker)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
/**
 * @method
 * @name woo#watchBidsAsks
 * @see https://docs.woox.io/#bbos
 * @description watches best bid & ask for symbols
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5148 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5148)
            symbols = this.MarketSymbols(symbols)
            var name interface{} = "bbos"
            var topic interface{} = name
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            bidsasks:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(bidsasks)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- bidsasks
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchBidsAsks
 * @see https://docs.woox.io/#bbos
 * @description unWatches best bid & ask for symbols
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for (not used by woo)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) UnWatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5408 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5408)
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " unWatchBidsAsks() does not support a symbols argument. Only unwatch all bidsAsks at once")))
            }
            var subHash interface{} = "bbos"
            var topic interface{} = "bidsasks"
        
                retRes54615 :=  (<-this.UnwatchPublic(subHash, nil, topic, params))
                ccxt.PanicOnError(retRes54615)
                ch <- retRes54615
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "bbos",
    //         "ts": 1618822376000,
    //         "data": [
    //             {
    //                 "symbol": "SPOT_FIL_USDT",
    //                 "ask": 159.0318,
    //                 "askSize": 370.43,
    //                 "bid": 158.9158,
    //                 "bidSize": 16
    //             }
    //         ]
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var result interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.SafeDict(data, i)
        ccxt.AddElementToObject(ticker, "ts", timestamp)
        var parsedTicker interface{} = this.ParseWsBidAsk(ticker)
        var symbol interface{} = ccxt.GetValue(parsedTicker, "symbol")
        ccxt.AddElementToObject(this.Bidsasks, symbol, parsedTicker)
        ccxt.AddElementToObject(result, symbol, parsedTicker)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
func  (this *WooCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "ts")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "askSize"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bidSize"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name woo#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.woox.io/#k-line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *WooCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6108)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1m"))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "5m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "15m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "30m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1h")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1d")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1w")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1M")))) {
                panic(ccxt.ExchangeError(ccxt.Add(this.Id, " watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M")))
            }
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var name interface{} = "kline"
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name), "_"), interval)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            ohlcv:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchOHLCV
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.woox.io/#k-line
 * @param {string} symbol unified symbol of the market
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *WooCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6428 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6428)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var topic interface{} = "ohlcv"
            var name interface{} = "kline"
            var subHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name), "_"), interval)
            ccxt.AddElementToObject(params, "symbolsAndTimeframes", []interface{}{[]interface{}{ccxt.GetValue(market, "symbol"), timeframe}})
        
                retRes64915 :=  (<-this.UnwatchPublic(subHash, ccxt.GetValue(market, "symbol"), topic, params))
                ccxt.PanicOnError(retRes64915)
                ch <- retRes64915
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"SPOT_BTC_USDT@kline_1m",
    //         "ts":1618822432146,
    //         "data":{
    //             "symbol":"SPOT_BTC_USDT",
    //             "type":"1m",
    //             "open":56948.97,
    //             "close":56891.76,
    //             "high":56948.97,
    //             "low":56889.06,
    //             "volume":44.00947568,
    //             "amount":2504584.9,
    //             "startTime":1618822380000,
    //             "endTime":1618822440000
    //         }
    //     }
    //
    var data interface{} = this.SafeValue(message, "data")
    var topic interface{} = this.SafeValue(message, "topic")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(data, "type")
    var timeframe interface{} = this.FindTimeframe(interval)
    var parsed interface{} = []interface{}{this.SafeInteger(data, "startTime"), this.SafeFloat(data, "open"), this.SafeFloat(data, "high"), this.SafeFloat(data, "low"), this.SafeFloat(data, "close"), this.SafeFloat(data, "volume")}
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, topic)
}
/**
 * @method
 * @name woo#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.woox.io/#trade
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *WooCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7098 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7098)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@trade")
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#unWatchTrades
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.woox.io/#trade
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *WooCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7358)
            var market interface{} = this.Market(symbol)
            var topic interface{} = "trades"
            var subHash interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@trade")
        
                retRes73915 :=  (<-this.UnwatchPublic(subHash, ccxt.GetValue(market, "symbol"), topic, params))
                ccxt.PanicOnError(retRes73915)
                ch <- retRes73915
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleTrade(client interface{}, message interface{})  {
    //
    // {
    //     "topic":"SPOT_ADA_USDT@trade",
    //     "ts":1618820361552,
    //     "data":{
    //         "symbol":"SPOT_ADA_USDT",
    //         "price":1.27988,
    //         "size":300,
    //         "side":"BUY",
    //         "source":0
    //     }
    // }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var data interface{} = this.SafeValue(message, "data")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var trade interface{} = this.ParseWsTrade(this.Extend(data, map[string]interface{} {
        "timestamp": timestamp,
    }), market)
    var tradesArray interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(tradesArray, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        tradesArray = ccxt.NewArrayCache(limit)
    }
    tradesArray.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, tradesArray)
    client.(ccxt.ClientInterface).Resolve(tradesArray, topic)
}
func  (this *WooCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"SPOT_ADA_USDT",
    //         "timestamp":1618820361552,
    //         "price":1.27988,
    //         "size":300,
    //         "side":"BUY",
    //         "source":0
    //     }
    // private trade
    //    {
    //     "msgType": 0,  // execution report
    //     "symbol": "SPOT_BTC_USDT",
    //     "clientOrderId": 0,
    //     "orderId": 54774393,
    //     "type": "MARKET",
    //     "side": "BUY",
    //     "quantity": 0.0,
    //     "price": 0.0,
    //     "tradeId": 56201985,
    //     "executedPrice": 23534.06,
    //     "executedQuantity": 0.00040791,
    //     "fee": 2.1E-7,
    //     "feeAsset": "BTC",
    //     "totalExecutedQuantity": 0.00040791,
    //     "avgPrice": 23534.06,
    //     "status": "FILLED",
    //     "reason": "",
    //     "orderTag": "default",
    //     "totalFee": 2.1E-7,
    //     "feeCurrency": "BTC",
    //     "totalRebate": 0,
    //     "rebateCurrency": "USDT",
    //     "visible": 0.0,
    //     "timestamp": 1675406261689,
    //     "reduceOnly": false,
    //     "maker": false
    //   }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var price interface{} = this.SafeString2(trade, "executedPrice", "price")
    var amount interface{} = this.SafeString2(trade, "executedQuantity", "size")
    var cost interface{} = ccxt.Precise.StringMul(price, amount)
    var side interface{} = this.SafeStringLower(trade, "side")
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var maker interface{} = this.SafeBool(trade, "marker")
    var takerOrMaker interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(maker, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(maker), "maker", "taker")
    }
    var typeVar interface{} = this.SafeStringLower(trade, "type")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(trade, "fee")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "feeCurrency")),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "tradeId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": this.SafeString(trade, "orderId"),
        "takerOrMaker": takerOrMaker,
        "type": typeVar,
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *WooCore) CheckRequiredUid(optionalArgs ...interface{}) interface{}  {
    error := ccxt.GetArg(optionalArgs, 0, true)
    _ = error
    if !ccxt.IsTrue(this.Uid) {
        if ccxt.IsTrue(error) {
            panic(ccxt.AuthenticationError(ccxt.Add(this.Id, " requires `uid` credential (woox calls it `application_id`)")))
        } else {
            return false
        }
    }
    return true
}
func  (this *WooCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.Uid)
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var event interface{} = "auth"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var ts interface{} = ccxt.ToString(this.Nonce())
                var auth interface{} = ccxt.Add("|", ts)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = map[string]interface{} {
                    "event": event,
                    "params": map[string]interface{} {
                        "apikey": this.ApiKey,
                        "sign": signature,
                        "timestamp": ts,
                    },
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash, message)
            }
        
                retRes88615 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes88615)
                ch <- retRes88615
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) WatchPrivate(messageHash interface{}, message interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8908 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes8908)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.Uid)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes89715 :=  (<-this.Watch(url, messageHash, request, messageHash, subscribe))
                ccxt.PanicOnError(retRes89715)
                ch <- retRes89715
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) WatchPrivateMultiple(messageHashes interface{}, message interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9018 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes9018)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.Uid)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes90815 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes, subscribe))
                ccxt.PanicOnError(retRes90815)
                ch <- retRes90815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#watchOrders
 * @see https://docs.woox.io/#executionreport
 * @see https://docs.woox.io/#algoexecutionreportv2
 * @description watches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if trigger order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *WooCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9258 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9258)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var topic interface{} = ccxt.Ternary(ccxt.IsTrue((trigger)), "algoexecutionreportv2", "executionreport")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var messageHash interface{} = topic
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            orders:= (<-this.WatchPrivate(messageHash, message))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#watchMyTrades
 * @see https://docs.woox.io/#executionreport
 * @see https://docs.woox.io/#algoexecutionreportv2
 * @description watches information on multiple trades made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if trigger order
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *WooCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9618 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9618)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var topic interface{} = ccxt.Ternary(ccxt.IsTrue((trigger)), "algoexecutionreportv2", "executionreport")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.WatchPrivate(messageHash, message))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *WooCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "PERP_BTC_USDT",
    //         "clientOrderId": 0,
    //         "orderId": 52952826,
    //         "type": "LIMIT",
    //         "side": "SELL",
    //         "quantity": 0.01,
    //         "price": 22000,
    //         "tradeId": 0,
    //         "executedPrice": 0,
    //         "executedQuantity": 0,
    //         "fee": 0,
    //         "feeAsset": "USDT",
    //         "totalExecutedQuantity": 0,
    //         "status": "NEW",
    //         "reason": '',
    //         "orderTag": "default",
    //         "totalFee": 0,
    //         "visible": 0.01,
    //         "timestamp": 1657515556799,
    //         "reduceOnly": false,
    //         "maker": false
    //     }
    //     {
    //      "symbol": "SPOT_BTC_USDT",
    //      "rootAlgoOrderId": 2573778,
    //      "parentAlgoOrderId": 0,
    //      "algoOrderId": 2573778,
    //      "clientOrderId": 0,
    //      "orderTag": "default",
    //      "algoType": "STOP_LOSS",
    //      "side": "SELL",
    //      "quantity": 0.00011,
    //      "triggerPrice": 98566.67,
    //      "triggerStatus": "USELESS",
    //      "price": 0,
    //      "type": "MARKET",
    //      "triggerTradePrice": 0,
    //      "triggerTime": 0,
    //      "tradeId": 0,
    //      "executedPrice": 0,
    //      "executedQuantity": 0,
    //      "fee": 0,
    //      "reason": "",
    //      "feeAsset": "",
    //      "totalExecutedQuantity": 0,
    //      "averageExecutedPrice": 0,
    //      "totalFee": 0,
    //      "timestamp": 1761030467426,
    //      "visibleQuantity": 0,
    //      "reduceOnly": false,
    //      "triggerPriceType": "MARKET_PRICE",
    //      "positionSide": "BOTH",
    //      "feeCurrency": "",
    //      "totalRebate": 0.0,
    //      "rebateCurrency": "",
    //      "triggered": false,
    //      "maker": false,
    //      "activated": false,
    //      "isTriggered": false,
    //      "isMaker": false,
    //      "isActivated": false,
    //      "rootAlgoStatus": "NEW",
    //      "algoStatus": "NEW"
    // }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var orderId interface{} = this.SafeString2(order, "orderId", "algoOrderId")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeString(order, "totalFee"),
        "currency": this.SafeString(order, "feeAsset"),
    }
    var priceString interface{} = this.SafeString(order, "price")
    var price interface{} = this.SafeNumber(order, "price")
    var avgPrice interface{} = this.SafeNumber(order, "avgPrice")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.Precise.StringEq(priceString, "0")) && ccxt.IsTrue((!ccxt.IsEqual(avgPrice, nil)))) {
        price = avgPrice
    }
    var amount interface{} = this.SafeFloat(order, "quantity")
    var side interface{} = this.SafeStringLower(order, "side")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var filled interface{} = this.SafeNumber(order, "totalExecutedQuantity")
    var totalExecQuantity interface{} = this.SafeFloat(order, "totalExecutedQuantity")
    var remaining interface{} = amount
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(amount, totalExecQuantity)) {
        remaining = ccxt.Subtract(remaining, totalExecQuantity)
    }
    var rawStatus interface{} = this.SafeString2(order, "status", "algoStatus")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    var trades interface{} = nil
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var triggerPrice interface{} = this.SafeString(order, "triggerPrice")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": timestamp,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "reduceOnly": this.SafeBool(order, "reduceOnly"),
        "amount": amount,
        "cost": nil,
        "average": avgPrice,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": trades,
    })
}
func  (this *WooCore) HandleOrderUpdate(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "executionreport",
    //         "ts": 1657515556799,
    //         "data": {
    //             "symbol": "PERP_BTC_USDT",
    //             "clientOrderId": 0,
    //             "orderId": 52952826,
    //             "type": "LIMIT",
    //             "side": "SELL",
    //             "quantity": 0.01,
    //             "price": 22000,
    //             "tradeId": 0,
    //             "executedPrice": 0,
    //             "executedQuantity": 0,
    //             "fee": 0,
    //             "feeAsset": "USDT",
    //             "totalExecutedQuantity": 0,
    //             "status": "NEW",
    //             "reason": '',
    //             "orderTag": "default",
    //             "totalFee": 0,
    //             "visible": 0.01,
    //             "timestamp": 1657515556799,
    //             "reduceOnly": false,
    //             "maker": false
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsArray(data)) {
        // algoexecutionreportv2
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var order interface{} = ccxt.GetValue(data, i)
            var tradeId interface{} = this.OmitZero(this.SafeString(data, "tradeId"))
            if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
                this.HandleMyTrade(client, order)
            }
            this.HandleOrder(client, order, topic)
        }
    } else {
        // executionreport
        var tradeId interface{} = this.OmitZero(this.SafeString(data, "tradeId"))
        if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
            this.HandleMyTrade(client, data)
        }
        this.HandleOrder(client, data, topic)
    }
}
func  (this *WooCore) HandleOrder(client interface{}, message interface{}, topic interface{})  {
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cachedOrders interface{} = this.Orders
        var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var order interface{} = this.SafeValue(orders, orderId)
        if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
            var fee interface{} = this.SafeValue(order, "fee")
            if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                ccxt.AddElementToObject(parsed, "fee", fee)
            }
            var fees interface{} = this.SafeValue(order, "fees")
            if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
                ccxt.AddElementToObject(parsed, "fees", fees)
            }
            ccxt.AddElementToObject(parsed, "trades", this.SafeValue(order, "trades"))
            ccxt.AddElementToObject(parsed, "timestamp", this.SafeInteger(order, "timestamp"))
            ccxt.AddElementToObject(parsed, "datetime", this.SafeString(order, "datetime"))
        }
        cachedOrders.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.Orders, topic)
        var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(topic, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHashSymbol)
    }
}
func  (this *WooCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    //    {
    //     "msgType": 0,  // execution report
    //     "symbol": "SPOT_BTC_USDT",
    //     "clientOrderId": 0,
    //     "orderId": 54774393,
    //     "type": "MARKET",
    //     "side": "BUY",
    //     "quantity": 0.0,
    //     "price": 0.0,
    //     "tradeId": 56201985,
    //     "executedPrice": 23534.06,
    //     "executedQuantity": 0.00040791,
    //     "fee": 2.1E-7,
    //     "feeAsset": "BTC",
    //     "totalExecutedQuantity": 0.00040791,
    //     "avgPrice": 23534.06,
    //     "status": "FILLED",
    //     "reason": "",
    //     "orderTag": "default",
    //     "totalFee": 2.1E-7,
    //     "feeCurrency": "BTC",
    //     "totalRebate": 0,
    //     "rebateCurrency": "USDT",
    //     "visible": 0.0,
    //     "timestamp": 1675406261689,
    //     "reduceOnly": false,
    //     "maker": false
    //   }
    //
    var myTrades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(myTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        myTrades = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var trade interface{} = this.ParseWsTrade(message)
    myTrades.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("myTrades:", ccxt.GetValue(trade, "symbol"))
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
    messageHash = "myTrades"
    client.(ccxt.ClientInterface).Resolve(myTrades, messageHash)
}
/**
 * @method
 * @name woo#watchPositions
 * @see https://docs.woox.io/#position-push
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param since
 * @param limit
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *WooCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12478 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12478)
            var messageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("positions::", symbol))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "positions")
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.Uid)
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client, symbols)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": "position",
            }
        
            newPositions:= (<-this.WatchPrivateMultiple(messageHashes, request, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *WooCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    } else {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
}
func  (this *WooCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions())
            ccxt.PanicOnError(positions)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeNumber(position, "contracts", 0)
                if ccxt.IsTrue(ccxt.IsGreaterThan(contracts, 0)) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "positions")
            }
                return nil
            }()
            return ch
        }
func  (this *WooCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        "topic":"position",
    //        "ts":1705292345255,
    //        "data":{
    //           "positions":{
    //              "PERP_LTC_USDT":{
    //                 "holding":1,
    //                 "pendingLongQty":0,
    //                 "pendingShortQty":0,
    //                 "averageOpenPrice":71.53,
    //                 "pnl24H":0,
    //                 "fee24H":0.07153,
    //                 "settlePrice":71.53,
    //                 "markPrice":71.32098452065145,
    //                 "version":7886,
    //                 "openingTime":1705292304267,
    //                 "pnl24HPercentage":0,
    //                 "adlQuantile":1,
    //                 "positionSide":"BOTH"
    //              }
    //           }
    //        }
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var rawPositions interface{} = this.SafeValue(data, "positions", map[string]interface{} {})
    var postitionsIds interface{} = ccxt.ObjectKeys(rawPositions)
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(postitionsIds)); i++ {
        var marketId interface{} = ccxt.GetValue(postitionsIds, i)
        var market interface{} = this.SafeMarket(marketId)
        var rawPosition interface{} = ccxt.GetValue(rawPositions, marketId)
        var position interface{} = this.ParsePosition(rawPosition, market)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
        var messageHash interface{} = ccxt.Add("positions::", ccxt.GetValue(market, "symbol"))
        client.(ccxt.ClientInterface).Resolve(position, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
/**
 * @method
 * @see https://docs.woox.io/#balance
 * @name woo#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *WooCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes13668)
            var topic interface{} = "balance"
            var messageHash interface{} = topic
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes137415 :=  (<-this.WatchPrivate(messageHash, message))
                ccxt.PanicOnError(retRes137415)
                ch <- retRes137415
                return nil
        
            }()
            return ch
        }
func  (this *WooCore) HandleBalance(client interface{}, message interface{})  {
    //
    //   {
    //       "topic": "balance",
    //       "ts": 1695716888789,
    //       "data": {
    //          "balances": {
    //             "USDT": {
    //                "holding": 266.56059176,
    //                "frozen": 0,
    //                "interest": 0,
    //                "pendingShortQty": 0,
    //                "pendingExposure": 0,
    //                "pendingLongQty": 0,
    //                "pendingLongExposure": 0,
    //                "version": 37,
    //                "staked": 0,
    //                "unbonding": 0,
    //                "vault": 0,
    //                "averageOpenPrice": 0,
    //                "pnl24H": 0,
    //                "fee24H": 0,
    //                "markPrice": 1,
    //                "pnl24HPercentage": 0
    //             }
    //          }
    //
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    var balances interface{} = this.SafeValue(data, "balances")
    var keys interface{} = ccxt.ObjectKeys(balances)
    var ts interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(this.Balance, "info", data)
    ccxt.AddElementToObject(this.Balance, "timestamp", ts)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(ts))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        var value interface{} = ccxt.GetValue(balances, key)
        var code interface{} = this.SafeCurrencyCode(key)
        var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
        var total interface{} = this.SafeString(value, "holding")
        var used interface{} = this.SafeString(value, "frozen")
        ccxt.AddElementToObject(account, "total", total)
        ccxt.AddElementToObject(account, "used", used)
        ccxt.AddElementToObject(account, "free", ccxt.Precise.StringSub(total, used))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
}
func  (this *WooCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // {"id":"1","event":"subscribe","success":false,"ts":1710780997216,"errorMsg":"Auth is needed."}
    //
    if !ccxt.IsTrue((ccxt.InOp(message, "success"))) {
        return false
    }
    var success interface{} = this.SafeBool(message, "success")
    if ccxt.IsTrue(success) {
        return false
    }
    var errorMessage interface{} = this.SafeString(message, "errorMsg")
    
        {
            ret__ := func(this *WooCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *WooCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(error, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(error)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorMessage, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorMessage, feedback)
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *WooCore) HandleUnSubscription(client interface{}, message interface{})  {
    //
    //     {
    //         "id": "2",
    //         "event": "unsubscribe",
    //         "success": true,
    //         "ts": 1759568478343,
    //         "data": "SPOT_BTC_USDT@orderbook"
    //     }
    //
    var subscribeHash interface{} = this.SafeString(message, "data")
    var unsubscribeHash interface{} = ccxt.Add("unsubscribe::", subscribeHash)
    var subscription interface{} = this.SafeDict(client.(ccxt.ClientInterface).GetSubscriptions(), unsubscribeHash, map[string]interface{} {})
    var subMessageHashes interface{} = this.SafeList(subscription, "subMessageHashes", []interface{}{})
    var unsubMessageHashes interface{} = this.SafeList(subscription, "unsubMessageHashes", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(subMessageHashes)); i++ {
        var subHash interface{} = ccxt.GetValue(subMessageHashes, i)
        var unsubHash interface{} = ccxt.GetValue(unsubMessageHashes, i)
        this.CleanUnsubscription(client.(*ccxt.Client), subHash, unsubHash)
    }
    this.CleanCache(subscription)
}
func  (this *WooCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var methods interface{} = map[string]interface{} {
        "ping": this.HandlePing,
        "pong": this.HandlePong,
        "subscribe": this.HandleSubscribe,
        "unsubscribe": this.HandleUnSubscription,
        "orderbook": this.HandleOrderBook,
        "orderbookupdate": this.HandleOrderBook,
        "ticker": this.HandleTicker,
        "tickers": this.HandleTickers,
        "kline": this.HandleOHLCV,
        "auth": this.HandleAuth,
        "executionreport": this.HandleOrderUpdate,
        "algoexecutionreportv2": this.HandleOrderUpdate,
        "trade": this.HandleTrade,
        "balance": this.HandleBalance,
        "position": this.HandlePositions,
        "bbos": this.HandleBidAsk,
    }
    var event interface{} = this.SafeString(message, "event")
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
        return
    }
    var topic interface{} = this.SafeString(message, "topic")
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        method = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
            return
        }
        var splitTopic interface{} = ccxt.Split(topic, "@")
        var splitLength interface{} =         ccxt.GetArrayLength(splitTopic)
        if ccxt.IsTrue(ccxt.IsEqual(splitLength, 2)) {
            var name interface{} = this.SafeString(splitTopic, 1)
            method = this.SafeValue(methods, name)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
                return
            }
            var splitName interface{} = ccxt.Split(name, "_")
            var splitNameLength interface{} =             ccxt.GetArrayLength(splitTopic)
            if ccxt.IsTrue(ccxt.IsEqual(splitNameLength, 2)) {
                method = this.SafeValue(methods, this.SafeString(splitName, 0))
                if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                    ccxt.CallDynamically(method, client, message)
                }
            }
        }
    }
}
func  (this *WooCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "event": "ping",
    }
}
func  (this *WooCore) HandlePing(client interface{}, message interface{}) interface{}  {
    return map[string]interface{} {
        "event": "pong",
    }
}
func  (this *WooCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    // { event: "pong", ts: 1657117026090 }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *WooCore) HandleSubscribe(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "id": "666888",
    //         "event": "subscribe",
    //         "success": true,
    //         "ts": 1657117712212
    //     }
    //
    var id interface{} = this.SafeString(message, "id")
    var subscriptionsById interface{} = this.IndexBy(client.(ccxt.ClientInterface).GetSubscriptions(), "id")
    var subscription interface{} = this.SafeValue(subscriptionsById, id, map[string]interface{} {})
    var method interface{} = this.SafeValue(subscription, "method")
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message, subscription)
    }
    return message
}
func  (this *WooCore) HandleAuth(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "auth",
    //         "success": true,
    //         "ts": 1657463158812
    //     }
    //
    var messageHash interface{} = "authenticated"
    var success interface{} = this.SafeValue(message, "success")
    if ccxt.IsTrue(success) {
        // client.resolve (message, messageHash)
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        // allows further authentication attempts
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
        }
    }
}


func (this *WooCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
