package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BackpackCore struct {
	*ccxt.BackpackCore
	base *ccxt.BackpackCore
}

func NewBackpackCore() *BackpackCore {
    p := &BackpackCore{}
	base := &ccxt.BackpackCore{}
	p.base = base
	p.BackpackCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BackpackCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchBidsAsks": true,
            "watchMyTrades": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchPositions": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "unwatchBidsAsks": true,
            "unwatchOHLCV": true,
            "unwatchOHLCVForSymbols": true,
            "unwatchOrderBook": true,
            "unwatchOrderBookForSymbols": true,
            "unwatchTicker": true,
            "unwatchTickers": true,
            "unWatchTrades": true,
            "unWatchTradesForSymbols": true,
            "unWatchOrders": true,
            "unWatchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws.backpack.exchange",
                    "private": "wss://ws.backpack.exchange",
                },
            },
        },
        "options": map[string]interface{} {
            "timeframes": map[string]interface{} {},
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 119000,
        },
    })
}
func  (this *BackpackCore) WatchPublic(topics interface{}, messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            unwatch := ccxt.GetArg(optionalArgs, 1, false)
            _ = unwatch
        
            retRes638 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes638)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var method interface{} = ccxt.Ternary(ccxt.IsTrue(unwatch), "UNSUBSCRIBE", "SUBSCRIBE")
            var request interface{} = map[string]interface{} {
                "method": method,
                "params": topics,
            }
            var message interface{} = this.DeepExtend(request, params)
            if ccxt.IsTrue(unwatch) {
                this.HandleUnsubscriptions(url, messageHashes, message)
        
                return nil
            }
        
                retRes7515 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes7515)
                ch <- retRes7515
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) WatchPrivate(topics interface{}, messageHashes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            unwatch := ccxt.GetArg(optionalArgs, 1, false)
            _ = unwatch
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private")
            var instruction interface{} = "subscribe"
            var ts interface{} = ccxt.ToString(this.Nonce())
            var method interface{} = ccxt.Ternary(ccxt.IsTrue(unwatch), "UNSUBSCRIBE", "SUBSCRIBE")
            var recvWindow interface{} = this.SafeString2(this.Options, "recvWindow", "X-Window", "5000")
            var payload interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add("instruction=", instruction), "&"), "timestamp="), ts), "&window="), recvWindow)
            var secretBytes interface{} = this.Base64ToBinary(this.Secret)
            var seed interface{} = this.ArraySlice(secretBytes, 0, 32)
            var signature interface{} = ccxt.Eddsa(this.Encode(payload), seed, ccxt.Ed25519)
            var request interface{} = map[string]interface{} {
                "method": method,
                "params": topics,
                "signature": []interface{}{this.ApiKey, signature, ts, recvWindow},
            }
            var message interface{} = this.DeepExtend(request, params)
            if ccxt.IsTrue(unwatch) {
                this.HandleUnsubscriptions(url, messageHashes, message)
        
                return nil
            }
        
                retRes9915 :=  (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
                ccxt.PanicOnError(retRes9915)
                ch <- retRes9915
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleUnsubscriptions(url interface{}, messageHashes interface{}, message interface{})  {
    var client interface{} = this.Client(url)
    this.WatchMultiple(url, messageHashes, message, messageHashes)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var subMessageHash interface{} = ccxt.Replace(messageHash, "unsubscribe:", "")
        this.CleanUnsubscription(client.(*ccxt.Client), subMessageHash, messageHash)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "ticker"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:ticker:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Tickers, symbol)) {
                ccxt.Remove(this.Tickers, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "bidask"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:bidask:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Bidsasks, symbol)) {
                ccxt.Remove(this.Bidsasks, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "candles"), 0)) {
            var splitHashes interface{} = ccxt.Split(messageHash, ":")
            var symbol interface{} = this.SafeString(splitHashes, 2)
            var timeframe interface{} = this.SafeString(splitHashes, 3)
            if ccxt.IsTrue(ccxt.InOp(this.Ohlcvs, symbol)) {
                if ccxt.IsTrue(ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)) {
                    ccxt.Remove(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
                }
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "orderbook"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:orderbook:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Orderbooks, symbol)) {
                ccxt.Remove(this.Orderbooks, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "trades"), 0)) {
            var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:trades:", "")
            if ccxt.IsTrue(ccxt.InOp(this.Trades, symbol)) {
                ccxt.Remove(this.Trades, symbol)
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "orders"), 0)) {
            if ccxt.IsTrue(ccxt.IsEqual(messageHash, "unsubscribe:orders")) {
                var cache interface{} = this.Orders
                var keys interface{} = ccxt.ObjectKeys(cache)
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(keys)); j++ {
                    var symbol interface{} = ccxt.GetValue(keys, j)
                    ccxt.Remove(this.Orders, symbol)
                }
            } else {
                var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:orders:", "")
                if ccxt.IsTrue(ccxt.InOp(this.Orders, symbol)) {
                    ccxt.Remove(this.Orders, symbol)
                }
            }
        } else if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(messageHash, "positions"), 0)) {
            if ccxt.IsTrue(ccxt.IsEqual(messageHash, "unsubscribe:positions")) {
                var cache interface{} = this.Positions
                var keys interface{} = ccxt.ObjectKeys(cache)
                for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(keys)); j++ {
                    var symbol interface{} = ccxt.GetValue(keys, j)
                    ccxt.Remove(this.Positions, symbol)
                }
            } else {
                var symbol interface{} = ccxt.Replace(messageHash, "unsubscribe:positions:", "")
                if ccxt.IsTrue(ccxt.InOp(this.Positions, symbol)) {
                    ccxt.Remove(this.Positions, symbol)
                }
            }
        }
    }
}
/**
 * @method
 * @name backpack#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1808 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1808)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.Add("ticker", "."), ccxt.GetValue(market, "id"))
            var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", ":"), symbol)
        
                retRes18515 :=  (<-this.WatchPublic([]interface{}{topic}, []interface{}{messageHash}, params))
                ccxt.PanicOnError(retRes18515)
                ch <- retRes18515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchTicker
 * @description unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) UnWatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes19815 :=  (<-this.UnWatchTickers([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes19815)
                ch <- retRes19815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2118)
            symbols = this.MarketSymbols(symbols, nil, false)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", symbol))
                ccxt.AppendToArray(&topics, ccxt.Add("ticker.", marketId))
            }
        
            retRes2218 := (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(retRes2218)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) UnWatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2358)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add("ticker.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:ticker:", symbol))
            }
        
                retRes24515 :=  (<-this.WatchPublic(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes24515)
                ch <- retRes24515
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             E: '1754176123312507',
    //             V: '19419526.742584',
    //             c: '3398.57',
    //             e: 'ticker',
    //             h: '3536.65',
    //             l: '3371.8',
    //             n: 17152,
    //             o: '3475.45',
    //             s: 'ETH_USDC',
    //             v: '5573.5827'
    //         },
    //         stream: 'bookTicker.ETH_USDC'
    //     }
    //
    var ticker interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(ticker, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var parsedTicker interface{} = this.ParseWsTicker(ticker, market)
    var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", ":"), symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
func  (this *BackpackCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         E: '1754178406415232',
    //         V: '19303818.6923',
    //         c: '3407.54',
    //         e: 'ticker',
    //         h: '3536.65',
    //         l: '3369.18',
    //         n: 17272,
    //         o: '3481.71',
    //         s: 'ETH_USDC',
    //         v: '5542.3911'
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var microseconds interface{} = this.SafeInteger(ticker, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    var marketId interface{} = this.SafeString(ticker, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "c")
    var open interface{} = this.SafeString(ticker, "o")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "h"),
        "low": this.SafeNumber(ticker, "l"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "v"),
        "quoteVolume": this.SafeString(ticker, "V"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name backpack#watchBidsAsks
 * @description watches best bid & ask for symbols
 * @see https://docs.backpack.exchange/#tag/Streams/Public/Book-ticker
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3328 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3328)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add("bookTicker.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", symbol))
            }
        
            retRes3428 := (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(retRes3428)
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchBidsAsks
 * @description unWatches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) UnWatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3558 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3558)
            symbols = this.MarketSymbols(symbols, nil, false)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add("bookTicker.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:bidask:", symbol))
            }
        
                retRes36515 :=  (<-this.WatchPublic(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes36515)
                ch <- retRes36515
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             A: '0.4087',
    //             B: '0.0020',
    //             E: '1754517402450016',
    //             T: '1754517402449064',
    //             a: '3667.50',
    //             b: '3667.49',
    //             e: 'bookTicker',
    //             s: 'ETH_USDC',
    //             u: 1328288557
    //         },
    //         stream: 'bookTicker.ETH_USDC'
    //     }
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var parsedBidAsk interface{} = this.ParseWsBidAsk(data, market)
    var messageHash interface{} = ccxt.Add(ccxt.Add("bidask", ":"), symbol)
    ccxt.AddElementToObject(this.Bidsasks, symbol, parsedBidAsk)
    client.(ccxt.ClientInterface).Resolve(parsedBidAsk, messageHash)
}
func  (this *BackpackCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         A: '0.4087',
    //         B: '0.0020',
    //         E: '1754517402450016',
    //         T: '1754517402449064',
    //         a: '3667.50',
    //         b: '3667.49',
    //         e: 'bookTicker',
    //         s: 'ETH_USDC',
    //         u: 1328288557
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var microseconds interface{} = this.SafeInteger(ticker, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    var ask interface{} = this.SafeString(ticker, "a")
    var askVolume interface{} = this.SafeString(ticker, "A")
    var bid interface{} = this.SafeString(ticker, "b")
    var bidVolume interface{} = this.SafeString(ticker, "B")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": ask,
        "askVolume": askVolume,
        "bid": bid,
        "bidVolume": bidVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name backpack#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BackpackCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            result:= (<-this.WatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, since, limit, params))
            ccxt.PanicOnError(result)
        
            ch <- ccxt.GetValue(ccxt.GetValue(result, symbol), timeframe)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BackpackCore) UnWatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes45715 :=  (<-this.UnWatchOHLCVForSymbols([]interface{}{[]interface{}{symbol, timeframe}}, params))
                ccxt.PanicOnError(retRes45715)
                ch <- retRes45715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#watchOHLCVForSymbols
 * @description watches historical candlestick data containing the open, high, low, close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BackpackCore) WatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [\\'ETH/USDC\\', \\'1m\\']")))
            }
        
            retRes4768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4768)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(ccxt.Add("kline.", interval), "."), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("candles:", ccxt.GetValue(market, "symbol")), ":"), interval))
            }
            symboltimeframecandlesVariable := (<-this.WatchPublic(topics, messageHashes, params))
            symbol := ccxt.GetValue(symboltimeframecandlesVariable,0)
            timeframe := ccxt.GetValue(symboltimeframecandlesVariable,1)
            candles := ccxt.GetValue(symboltimeframecandlesVariable,2)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(candles).GetLimit(symbol, limit)
            }
            var filtered interface{} = this.FilterBySinceLimit(candles, since, limit, 0, true)
        
            ch <- this.CreateOHLCVObject(symbol, timeframe, filtered)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchOHLCVForSymbols
 * @description unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
 * @param {string[][]} symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch ccxt.OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BackpackCore) UnWatchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbolsAndTimeframes)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) || !ccxt.IsTrue(ccxt.IsArray(ccxt.GetValue(symbolsAndTimeframes, 0)))) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [\\'ETH/USDC\\', \\'1m\\']")))
            }
        
            retRes5108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5108)
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolsAndTimeframes)); i++ {
                var symbolAndTimeframe interface{} = ccxt.GetValue(symbolsAndTimeframes, i)
                var marketId interface{} = this.SafeString(symbolAndTimeframe, 0)
                var market interface{} = this.Market(marketId)
                var tf interface{} = this.SafeString(symbolAndTimeframe, 1)
                var interval interface{} = this.SafeString(this.Timeframes, tf, tf)
                ccxt.AppendToArray(&topics, ccxt.Add(ccxt.Add(ccxt.Add("kline.", interval), "."), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(ccxt.Add("unsubscribe:candles:", ccxt.GetValue(market, "symbol")), ":"), interval))
            }
        
                retRes52215 :=  (<-this.WatchPublic(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes52215)
                ch <- retRes52215
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             E: '1754519557526056',
    //             T: '2025-08-07T00:00:00',
    //             X: false,
    //             c: '3680.520000000',
    //             e: 'kline',
    //             h: '3681.370000000',
    //             l: '3667.650000000',
    //             n: 255,
    //             o: '3670.150000000',
    //             s: 'ETH_USDC',
    //             t: '2025-08-06T22:00:00',
    //             v: '62.2621000'
    //         },
    //         stream: 'kline.2h.ETH_USDC'
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stream interface{} = this.SafeString(message, "stream")
    var parts interface{} = ccxt.Split(stream, ".")
    var timeframe interface{} = this.SafeString(parts, 1)
    if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
        ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
    }
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored := ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcv interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(data)
    ohlcv.(ccxt.Appender).Append(parsed)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("candles:", symbol), ":"), timeframe)
    client.(ccxt.ClientInterface).Resolve([]interface{}{symbol, timeframe, ohlcv}, messageHash)
}
func  (this *BackpackCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         E: '1754519557526056',
    //         T: '2025-08-07T00:00:00',
    //         X: false,
    //         c: '3680.520000000',
    //         e: 'kline',
    //         h: '3681.370000000',
    //         l: '3667.650000000',
    //         n: 255,
    //         o: '3670.150000000',
    //         s: 'ETH_USDC',
    //         t: '2025-08-06T22:00:00',
    //         v: '62.2621000'
    //     },
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "T")), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name backpack#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Trade
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes60615 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes60615)
                ch <- retRes60615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchTrades
 * @description unWatches from the stream channel
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Trade
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BackpackCore) UnWatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes61915 :=  (<-this.UnWatchTradesForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes61915)
                ch <- retRes61915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#watchTradesForSymbols
 * @description watches information on multiple trades made in a market
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BackpackCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6348)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchTradesForSymbols() requires a non-empty array of symbols")))
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add("trade.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("trades:", symbol))
            }
        
            trades:= (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeValue(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchTradesForSymbols
 * @description unWatches from the stream channel
 * @see https://docs.backpack.exchange/#tag/Streams/Public/ccxt.Trade
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BackpackCore) UnWatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6678)
            symbols = this.MarketSymbols(symbols)
            var symbolsLength interface{} =     ccxt.GetArrayLength(symbols)
            if ccxt.IsTrue(ccxt.IsEqual(symbolsLength, 0)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " unWatchTradesForSymbols() requires a non-empty array of symbols")))
            }
            var topics interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var marketId interface{} = this.MarketId(symbol)
                ccxt.AppendToArray(&topics, ccxt.Add("trade.", marketId))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:trades:", symbol))
            }
        
                retRes68115 :=  (<-this.WatchPublic(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes68115)
                ch <- retRes68115
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             E: '1754601477746429',
    //             T: '1754601477744000',
    //             a: '5121860761',
    //             b: '5121861755',
    //             e: 'trade',
    //             m: false,
    //             p: '3870.25',
    //             q: '0.0008',
    //             s: 'ETH_USDC_PERP',
    //             t: 10782547
    //         },
    //         stream: 'trade.ETH_USDC_PERP'
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var stored interface{} = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var cache interface{} = ccxt.GetValue(this.Trades, symbol)
    var trade interface{} = this.ParseWsTrade(data, market)
    cache.(ccxt.Appender).Append(trade)
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    client.(ccxt.ClientInterface).Resolve(cache, messageHash)
    client.(ccxt.ClientInterface).Resolve(cache, "trades")
}
func  (this *BackpackCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         E: '1754601477746429',
    //         T: '1754601477744000',
    //         a: '5121860761',
    //         b: '5121861755',
    //         e: 'trade',
    //         m: false,
    //         p: '3870.25',
    //         q: '0.0008',
    //         s: 'ETH_USDC_PERP',
    //         t: 10782547
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var microseconds interface{} = this.SafeInteger(trade, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    var id interface{} = this.SafeString(trade, "t")
    var marketId interface{} = this.SafeString(trade, "s")
    market = this.SafeMarket(marketId, market)
    var isMaker interface{} = this.SafeBool(trade, "m")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue(isMaker), "sell", "buy")
    var takerOrMaker interface{} = ccxt.Ternary(ccxt.IsTrue(isMaker), "maker", "taker")
    var price interface{} = this.SafeString(trade, "p")
    var amount interface{} = this.SafeString(trade, "q")
    var orderId interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(side, "buy")) {
        orderId = this.SafeString(trade, "b")
    } else {
        orderId = this.SafeString(trade, "a")
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": nil,
        },
    }, market)
}
/**
 * @method
 * @name backpack#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.backpack.exchange/#tag/Streams/Public/Depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BackpackCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
                retRes78115 :=  (<-this.WatchOrderBookForSymbols([]interface{}{symbol}, limit, params))
                ccxt.PanicOnError(retRes78115)
                ch <- retRes78115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#watchOrderBookForSymbols
 * @see https://docs.backpack.exchange/#tag/Streams/Public/Depth
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BackpackCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7968 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7968)
            symbols = this.MarketSymbols(symbols, nil, false)
            var marketIds interface{} = this.MarketIds(symbols)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("orderbook:", symbol))
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var topic interface{} = ccxt.Add("depth.", marketId)
                ccxt.AppendToArray(&topics, topic)
            }
        
            orderbook:= (<-this.WatchPublic(topics, messageHashes, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()  // todo check if limit is needed
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchOrderBook
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BackpackCore) UnWatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes82115 :=  (<-this.UnWatchOrderBookForSymbols([]interface{}{symbol}, params))
                ccxt.PanicOnError(retRes82115)
                ch <- retRes82115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchOrderBookForSymbols
 * @description unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string[]} symbols unified array of symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BackpackCore) UnWatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes8348)
            symbols = this.MarketSymbols(symbols, nil, false)
            var marketIds interface{} = this.MarketIds(symbols)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                ccxt.AppendToArray(&messageHashes, ccxt.Add("unsubscribe:orderbook:", symbol))
                var marketId interface{} = ccxt.GetValue(marketIds, i)
                var topic interface{} = ccxt.Add("depth.", marketId)
                ccxt.AppendToArray(&topics, topic)
            }
        
                retRes84615 :=  (<-this.WatchPublic(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes84615)
                ch <- retRes84615
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // initial snapshot is fetched with ccxt's fetchOrderBook
    // the feed does not include a snapshot, just the deltas
    //
    //     {
    //         "data": {
    //             "E": "1754903057555305",
    //             "T": "1754903057554352",
    //             "U": 1345937436,
    //             "a": [],
    //             "b": [],
    //             "e": "depth",
    //             "s": "ETH_USDC",
    //             "u": 1345937436
    //         },
    //         "stream": "depth.ETH_USDC"
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var symbol interface{} = this.SafeSymbol(marketId)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var storedOrderBook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var nonce interface{} = this.SafeInteger(storedOrderBook, "nonce")
    var deltaNonce interface{} = this.SafeInteger(data, "u")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    if ccxt.IsTrue(ccxt.IsEqual(nonce, nil)) {
        var cacheLength interface{} =         ccxt.GetArrayLength(storedOrderBook.(ccxt.OrderBookInterface).GetCache())
        // the rest API is very delayed
        // usually it takes at least 9 deltas to resolve
        var snapshotDelay interface{} = this.HandleOption("watchOrderBook", "snapshotDelay", 10)
        if ccxt.IsTrue(ccxt.IsEqual(cacheLength, snapshotDelay)) {
            this.Spawn(this.LoadOrderBook, client, messageHash, symbol, nil, map[string]interface{} {})
        }
        ccxt.AppendToArray(storedOrderBook.(ccxt.OrderBookInterface).GetCache(), data)
        return
    } else if ccxt.IsTrue(ccxt.IsGreaterThan(nonce, deltaNonce)) {
        return
    }
    this.HandleDelta(storedOrderBook, data)
    client.(ccxt.ClientInterface).Resolve(storedOrderBook, messageHash)
}
func  (this *BackpackCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(this.SafeInteger(delta, "T"), 1000))
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    ccxt.AddElementToObject(orderbook, "nonce", this.SafeInteger(delta, "u"))
    var bids interface{} = this.SafeList(delta, "b", []interface{}{})
    var asks interface{} = this.SafeList(delta, "a", []interface{}{})
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    this.HandleBidAsks(storedBids, bids)
    this.HandleBidAsks(storedAsks, asks)
}
func  (this *BackpackCore) HandleBidAsks(bookSide interface{}, bidAsks interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidAsks)); i++ {
        var bidAsk interface{} = this.ParseBidAsk(ccxt.GetValue(bidAsks, i))
        bookSide.(ccxt.IOrderBookSide).StoreArray(bidAsk)
    }
}
func  (this *BackpackCore) GetCacheIndex(orderbook interface{}, cache interface{}) interface{}  {
    //
    // {"E":"1759338824897386","T":"1759338824895616","U":1662976171,"a":[],"b":[["117357.0","0.00000"]],"e":"depth","s":"BTC_USDC_PERP","u":1662976171}
    var firstDelta interface{} = this.SafeDict(cache, 0)
    var nonce interface{} = this.SafeInteger(orderbook, "nonce")
    var firstDeltaStart interface{} = this.SafeInteger(firstDelta, "U")
    if ccxt.IsTrue(ccxt.IsLessThan(nonce, ccxt.Subtract(firstDeltaStart, 1))) {
        return ccxt.OpNeg(1)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(cache)); i++ {
        var delta interface{} = ccxt.GetValue(cache, i)
        var deltaStart interface{} = this.SafeInteger(delta, "U")
        var deltaEnd interface{} = this.SafeInteger(delta, "u")
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(nonce, ccxt.Subtract(deltaStart, 1)))) && ccxt.IsTrue((ccxt.IsLessThan(nonce, deltaEnd)))) {
            return i
        }
    }
    return ccxt.GetArrayLength(cache)
}
/**
 * @method
 * @name backpack#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.backpack.exchange/#tag/Streams/Private/ccxt.Order-update
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BackpackCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9478 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9478)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var topic interface{} = "account.orderUpdate"
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                topic = ccxt.Add("account.orderUpdate.", ccxt.GetValue(market, "id"))
                messageHash = ccxt.Add("orders:", symbol)
            }
        
            orders:= (<-this.WatchPrivate([]interface{}{topic}, []interface{}{messageHash}, params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchOrders
 * @description unWatches information on multiple orders made by the user
 * @see https://docs.backpack.exchange/#tag/Streams/Private/ccxt.Order-update
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BackpackCore) UnWatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9768)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
            }
            var topic interface{} = "account.orderUpdate"
            var messageHash interface{} = "unsubscribe:orders"
            if ccxt.IsTrue(!ccxt.IsEqual(market, nil)) {
                topic = ccxt.Add("account.orderUpdate.", ccxt.GetValue(market, "id"))
                messageHash = ccxt.Add("unsubscribe:orders:", symbol)
            }
        
                retRes98815 :=  (<-this.WatchPrivate([]interface{}{topic}, []interface{}{messageHash}, params, true))
                ccxt.PanicOnError(retRes98815)
                ch <- retRes98815
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             E: '1754939110175843',
    //             O: 'USER',
    //             Q: '4.30',
    //             S: 'Bid',
    //             T: '1754939110174703',
    //             V: 'RejectTaker',
    //             X: 'New',
    //             Z: '0',
    //             e: 'orderAccepted',
    //             f: 'GTC',
    //             i: '5406825793',
    //             o: 'MARKET',
    //             q: '0.0010',
    //             r: false,
    //             s: 'ETH_USDC',
    //             t: null,
    //             z: '0'
    //         },
    //         stream: 'account.orderUpdate.ETH_USDC'
    //     }
    //
    var messageHash interface{} = "orders"
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "s")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var parsed interface{} = this.ParseWsOrder(data, market)
    var orders interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        orders = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = orders
    }
    orders.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(orders, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orders, symbolSpecificMessageHash)
}
func  (this *BackpackCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         E: '1754939110175879',
    //         L: '4299.16',
    //         N: 'ETH',
    //         O: 'USER',
    //         Q: '4.30',
    //         S: 'Bid',
    //         T: '1754939110174705',
    //         V: 'RejectTaker',
    //         X: 'Filled',
    //         Z: '4.299160',
    //         e: 'orderFill',
    //         f: 'GTC',
    //         i: '5406825793',
    //         l: '0.0010',
    //         m: false,
    //         n: '0.000001',
    //         o: 'MARKET',
    //         q: '0.0010',
    //         r: false,
    //         s: 'ETH_USDC',
    //         t: 2888471,
    //         z: '0.0010'
    //     },
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "i")
    var clientOrderId interface{} = this.SafeString(order, "c")
    var microseconds interface{} = this.SafeInteger(order, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    var status interface{} = this.ParseWsOrderStatus(this.SafeString(order, "X"), market)
    var marketId interface{} = this.SafeString(order, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var typeVar interface{} = this.SafeStringLower(order, "o")
    var timeInForce interface{} = this.SafeString(order, "f")
    var side interface{} = this.ParseWsOrderSide(this.SafeString(order, "S"))
    var price interface{} = this.SafeString(order, "p")
    var triggerPrice interface{} = this.SafeNumber(order, "P")
    var amount interface{} = this.SafeString(order, "q")
    var cost interface{} = this.SafeString(order, "Z")
    var filled interface{} = this.SafeString(order, "l")
    var fee interface{} = nil
    var feeCurrency interface{} = this.SafeString(order, "N")
    if ccxt.IsTrue(!ccxt.IsEqual(feeCurrency, nil)) {
        fee = map[string]interface{} {
            "currency": feeCurrency,
            "cost": nil,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "triggerPrice": triggerPrice,
        "average": nil,
        "amount": amount,
        "cost": cost,
        "filled": filled,
        "remaining": nil,
        "fee": fee,
        "trades": nil,
        "info": order,
    }, market)
}
func  (this *BackpackCore) ParseWsOrderStatus(status interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var statuses interface{} = map[string]interface{} {
        "New": "open",
        "Filled": "closed",
        "Cancelled": "canceled",
        "Expired": "canceled",
        "PartiallyFilled": "open",
        "TriggerPending": "open",
        "TriggerFailed": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *BackpackCore) ParseWsOrderSide(side interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "Bid": "buy",
        "Ask": "sell",
    }
    return this.SafeString(sides, side, side)
}
/**
 * @method
 * @name backpack#watchPositions
 * @description watch all open positions
 * @see https://docs.backpack.exchange/#tag/Streams/Private/ccxt.Position-update
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BackpackCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11438 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11438)
            symbols = this.MarketSymbols(symbols)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add("positions", ":"), symbol))
                    ccxt.AppendToArray(&topics, ccxt.Add("account.positionUpdate.", this.MarketId(symbol)))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "positions")
                ccxt.AppendToArray(&topics, "account.positionUpdate")
            }
        
            positions:= (<-this.WatchPrivate(topics, messageHashes, params))
            ccxt.PanicOnError(positions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- positions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name backpack#unWatchPositions
 * @description unWatches from the stream channel
 * @see https://docs.backpack.exchange/#tag/Streams/Private/ccxt.Position-update
 * @param {string[]} [symbols] list of unified market symbols to watch positions for
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BackpackCore) UnWatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11748)
            symbols = this.MarketSymbols(symbols)
            var messageHashes interface{} = []interface{}{}
            var topics interface{} = []interface{}{}
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add("unsubscribe:positions", ":"), symbol))
                    ccxt.AppendToArray(&topics, ccxt.Add("account.positionUpdate.", this.MarketId(symbol)))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "unsubscribe:positions")
                ccxt.AppendToArray(&topics, "account.positionUpdate")
            }
        
                retRes118815 :=  (<-this.WatchPrivate(topics, messageHashes, params, true))
                ccxt.PanicOnError(retRes118815)
                ch <- retRes118815
                return nil
        
            }()
            return ch
        }
func  (this *BackpackCore) HandlePositions(client interface{}, message interface{})  {
    //
    //     {
    //         data: {
    //             B: '4236.36',
    //             E: '1754943862040486',
    //             M: '4235.88650933',
    //             P: '-0.000473',
    //             Q: '0.0010',
    //             T: '1754943862040487',
    //             b: '4238.479',
    //             e: 'positionOpened',
    //             f: '0.02',
    //             i: 5411399049,
    //             l: '0',
    //             m: '0.0125',
    //             n: '4.23588650933',
    //             p: '0',
    //             q: '0.0010',
    //             s: 'ETH_USDC_PERP'
    //         },
    //         stream: 'account.positionUpdate'
    //     }
    //
    var messageHash interface{} = "positions"
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolById()
    }
    var cache interface{} = this.Positions
    var parsedPosition interface{} = this.ParseWsPosition(data)
    var microseconds interface{} = this.SafeInteger(data, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    ccxt.AddElementToObject(parsedPosition, "timestamp", timestamp)
    ccxt.AddElementToObject(parsedPosition, "datetime", this.Iso8601(timestamp))
    cache.(ccxt.Appender).Append(parsedPosition)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), ccxt.GetValue(parsedPosition, "symbol"))
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, messageHash)
    client.(ccxt.ClientInterface).Resolve([]interface{}{parsedPosition}, symbolSpecificMessageHash)
}
func  (this *BackpackCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         B: '4236.36',
    //         E: '1754943862040486',
    //         M: '4235.88650933',
    //         P: '-0.000473',
    //         Q: '0.0010',
    //         T: '1754943862040487',
    //         b: '4238.479',
    //         e: 'positionOpened',
    //         f: '0.02',
    //         i: 5411399049,
    //         l: '0',
    //         m: '0.0125',
    //         n: '4.23588650933',
    //         p: '0',
    //         q: '0.0010',
    //         s: 'ETH_USDC_PERP'
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(position, "i")
    var marketId interface{} = this.SafeString(position, "s")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var notional interface{} = this.SafeString(position, "n")
    var liquidationPrice interface{} = this.SafeString(position, "l")
    var entryPrice interface{} = this.SafeString(position, "b")
    var realizedPnl interface{} = this.SafeString(position, "p")
    var unrealisedPnl interface{} = this.SafeString(position, "P")
    var contracts interface{} = this.SafeString(position, "Q")
    var markPrice interface{} = this.SafeString(position, "M")
    var netQuantity interface{} = this.SafeNumber(position, "q")
    var hedged interface{} = false
    var side interface{} = "long"
    if ccxt.IsTrue(ccxt.IsLessThan(netQuantity, 0)) {
        side = "short"
    }
    if ccxt.IsTrue(ccxt.IsEqual(netQuantity, nil)) {
        hedged = nil
        side = nil
    }
    var microseconds interface{} = this.SafeInteger(position, "E")
    var timestamp interface{} = this.ParseToInt(ccxt.Divide(microseconds, 1000))
    var maintenanceMarginPercentage interface{} = this.SafeNumber(position, "m")
    var initialMarginPercentage interface{} = this.SafeNumber(position, "f")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": id,
        "symbol": symbol,
        "notional": notional,
        "marginMode": nil,
        "liquidationPrice": liquidationPrice,
        "entryPrice": entryPrice,
        "realizedPnl": realizedPnl,
        "unrealizedPnl": unrealisedPnl,
        "percentage": nil,
        "contracts": contracts,
        "contractSize": nil,
        "markPrice": markPrice,
        "side": side,
        "hedged": hedged,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": maintenanceMarginPercentage,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": initialMarginPercentage,
        "leverage": nil,
        "marginRatio": nil,
    })
}
func  (this *BackpackCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var data interface{} = this.SafeDict(message, "data")
    var event interface{} = this.SafeString(data, "e")
    if ccxt.IsTrue(ccxt.IsEqual(event, "ticker")) {
        this.HandleTicker(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "bookTicker")) {
        this.HandleBidAsk(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "kline")) {
        this.HandleOHLCV(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "trade")) {
        this.HandleTrades(client, message)
    } else if ccxt.IsTrue(ccxt.IsEqual(event, "depth")) {
        this.HandleOrderBook(client, message)
    } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, "orderAccepted")) || ccxt.IsTrue(ccxt.IsEqual(event, "orderUpdate"))) || ccxt.IsTrue(ccxt.IsEqual(event, "orderFill"))) || ccxt.IsTrue(ccxt.IsEqual(event, "orderCancelled"))) || ccxt.IsTrue(ccxt.IsEqual(event, "orderExpired"))) || ccxt.IsTrue(ccxt.IsEqual(event, "orderModified"))) || ccxt.IsTrue(ccxt.IsEqual(event, "triggerPlaced"))) || ccxt.IsTrue(ccxt.IsEqual(event, "triggerFailed"))) {
        this.HandleOrder(client, message)
    } else if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(event, "positionAdjusted")) || ccxt.IsTrue(ccxt.IsEqual(event, "positionOpened"))) || ccxt.IsTrue(ccxt.IsEqual(event, "positionClosed"))) || ccxt.IsTrue(ccxt.IsEqual(event, "positionUpdated"))) {
        this.HandlePositions(client, message)
    }
}
func  (this *BackpackCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         id: null,
    //         error: {
    //             code: 4006,
    //             message: 'Invalid stream'
    //         }
    //     }
    //
    var error interface{} = this.SafeDict(message, "error", map[string]interface{} {})
    var code interface{} = this.SafeInteger(error, "code")
    
        {
             func(this *BackpackCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BackpackCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(code, nil)) {
                var msg interface{} = this.SafeString(error, "message")
                panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), msg)))
            }
            return true
    		    
    	    }(this)
        
            }
    return true
}


func (this *BackpackCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
