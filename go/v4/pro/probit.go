package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ProbitCore struct {
	*ccxt.ProbitCore
	base *ccxt.ProbitCore
}

func NewProbitCore() *ProbitCore {
    p := &ProbitCore{}
	base := &ccxt.ProbitCore{}
	p.base = base
	p.ProbitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ProbitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": false,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchMyTrades": true,
            "watchOrders": true,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.probit.com/api/exchange/v1/ws",
            },
            "test": map[string]interface{} {
                "ws": "wss://demo-api.probit.com/api/exchange/v1/ws",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "filter": "order_books_l2",
                "interval": 100,
            },
        },
        "streaming": map[string]interface{} {},
    })
}
/**
 * @method
 * @name probit#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs-en.probit.com/reference/balance-1
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *ProbitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes538 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes538)
            var messageHash interface{} = "balance"
        
                retRes5515 :=  (<-this.SubscribePrivate(messageHash, "balance", params))
                ccxt.PanicOnError(retRes5515)
                ch <- retRes5515
                return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "balance",
    //         "reset": false,
    //         "data": {
    //             "USDT": {
    //                 "available": "15",
    //                 "total": "15"
    //             }
    //         }
    //     }
    //
    var messageHash interface{} = "balance"
    this.ParseWSBalance(message)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *ProbitCore) ParseWSBalance(message interface{})  {
    //
    //     {
    //         "channel": "balance",
    //         "reset": false,
    //         "data": {
    //             "USDT": {
    //                 "available": "15",
    //                 "total": "15"
    //             }
    //         }
    //     }
    //
    var reset interface{} = this.SafeBool(message, "reset", false)
    var data interface{} = this.SafeValue(message, "data", map[string]interface{} {})
    var currencyIds interface{} = ccxt.ObjectKeys(data)
    if ccxt.IsTrue(reset) {
        this.Balance = map[string]interface{} {}
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = ccxt.GetValue(currencyIds, i)
        var entry interface{} = ccxt.GetValue(data, currencyId)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(entry, "available"))
        ccxt.AddElementToObject(account, "total", this.SafeString(entry, "total"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
}
/**
 * @method
 * @name probit#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs-en.probit.com/reference/marketdata
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.interval] Unit time to synchronize market information (ms). Available units: 100, 500
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ProbitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var channel interface{} = "ticker"
        
                retRes11915 :=  (<-this.SubscribePublic("watchTicker", symbol, "ticker", channel, params))
                ccxt.PanicOnError(retRes11915)
                ch <- retRes11915
                return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleTicker(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "marketdata",
    //         "market_id": "BTC-USDT",
    //         "status": "ok",
    //         "lag": 0,
    //         "ticker": {
    //             "time": "2022-07-21T14:18:04.000Z",
    //             "last": "22591.3",
    //             "low": "22500.1",
    //             "high": "39790.7",
    //             "change": "-1224",
    //             "base_volume": "1002.32005445",
    //             "quote_volume": "23304489.385351021"
    //         },
    //         "reset": true
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var ticker interface{} = this.SafeValue(message, "ticker", map[string]interface{} {})
    var market interface{} = this.SafeMarket(marketId)
    var parsedTicker interface{} = this.ParseTicker(ticker, market)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, parsedTicker)
    client.(ccxt.ClientInterface).Resolve(parsedTicker, messageHash)
}
/**
 * @method
 * @name probit#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs-en.probit.com/reference/trade_history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.interval] Unit time to synchronize market information (ms). Available units: 100, 500
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *ProbitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var channel interface{} = "recent_trades"
            symbol = this.SafeSymbol(symbol)
        
            trades:= (<-this.SubscribePublic("watchTrades", symbol, "trades", channel, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "marketdata",
    //         "market_id": "BTC-USDT",
    //         "status": "ok",
    //         "lag": 0,
    //         "recent_trades": [
    //             {
    //                 "id": "BTC-USDT:8010233",
    //                 "price": "22701.4",
    //                 "quantity": "0.011011",
    //                 "time": "2022-07-21T13:40:40.983Z",
    //                 "side": "buy",
    //                 "tick_direction": "up"
    //             }
    //             ...
    //         ]
    //         "reset": true
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var market interface{} = this.SafeMarket(marketId)
    var trades interface{} = this.SafeValue(message, "recent_trades", []interface{}{})
    if ccxt.IsTrue(this.SafeBool(message, "reset", false)) {
        return  // see comment in handleMessage
    }
    var messageHash interface{} = ccxt.Add("trades:", symbol)
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(trades)); i++ {
        var trade interface{} = ccxt.GetValue(trades, i)
        var parsed interface{} = this.ParseTrade(trade, market)
        stored.(ccxt.Appender).Append(parsed)
    }
    ccxt.AddElementToObject(this.Trades, symbol, stored)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), messageHash)
}
/**
 * @method
 * @name probit#watchMyTrades
 * @description get the list of trades associated with the user
 * @see https://docs-en.probit.com/reference/trade_history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *ProbitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2298 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2298)
        
            retRes2308 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes2308)
            var messageHash interface{} = "trades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.SafeSymbol(symbol)
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            trades:= (<-this.SubscribePrivate(messageHash, "trade_history", params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleMyTrades(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "trade_history",
    //         "reset": false,
    //         "data": [{
    //             "id": "BTC-USDT:8010722",
    //             "order_id": "4124999207",
    //             "side": "buy",
    //             "fee_amount": "0.0134999868096",
    //             "fee_currency_id": "USDT",
    //             "status": "settled",
    //             "price": "23136.7",
    //             "quantity": "0.00032416",
    //             "cost": "7.499992672",
    //             "time": "2022-07-21T17:09:33.056Z",
    //             "market_id": "BTC-USDT"
    //         }]
    //     }
    //
    var rawTrades interface{} = this.SafeValue(message, "data", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(rawTrades)
    if ccxt.IsTrue(ccxt.IsEqual(length, 0)) {
        return
    }
    if ccxt.IsTrue(this.SafeBool(message, "reset", false)) {
        return  // see comment in handleMessage
    }
    var messageHash interface{} = "trades"
    var stored interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = stored
    }
    var trades interface{} = this.ParseTrades(rawTrades)
    var tradeSymbols interface{} = map[string]interface{} {}
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(trades)); j++ {
        var trade interface{} = ccxt.GetValue(trades, j)
        // don't include 'executed' state, because it's just blanket state of the trade, emited before actual trade event
        if ccxt.IsTrue(ccxt.IsEqual(this.SafeString(ccxt.GetValue(trade, "info"), "status"), "executed")) {
            continue
        }
        ccxt.AddElementToObject(tradeSymbols, ccxt.GetValue(trade, "symbol"), true)
        stored.(ccxt.Appender).Append(trade)
    }
    var unique interface{} = ccxt.ObjectKeys(tradeSymbols)
    var uniqueLength interface{} =     ccxt.GetArrayLength(unique)
    if ccxt.IsTrue(ccxt.IsEqual(uniqueLength, 0)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(unique)); i++ {
        var symbol interface{} = ccxt.GetValue(unique, i)
        var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(stored, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name probit#watchOrders
 * @description watches information on an order made by the user
 * @see https://docs-en.probit.com/reference/open_order
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {int} [since] timestamp in ms of the earliest order to watch
 * @param {int} [limit] the maximum amount of orders to watch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] choose what channel to use. Can open_order or order_history.
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ProbitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3158 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes3158)
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.SafeSymbol(symbol)
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.SubscribePrivate(messageHash, "open_order", params))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleOrders(client interface{}, message interface{})  {
    //
    //     {
    //         "channel": "order_history",
    //         "reset": true,
    //         "data": [{
    //                 "id": "4124999207",
    //                 "user_id": "633dc56a-621b-4680-8a4e-85a823499b6d",
    //                 "market_id": "BTC-USDT",
    //                 "type": "market",
    //                 "side": "buy",
    //                 "limit_price": "0",
    //                 "time_in_force": "ioc",
    //                 "filled_cost": "7.499992672",
    //                 "filled_quantity": "0.00032416",
    //                 "open_quantity": "0",
    //                 "status": "filled",
    //                 "time": "2022-07-21T17:09:33.056Z",
    //                 "client_order_id": '',
    //                 "cost": "7.5"
    //             },
    //             ...
    //         ]
    //     }
    //
    var rawOrders interface{} = this.SafeValue(message, "data", []interface{}{})
    var length interface{} =     ccxt.GetArrayLength(rawOrders)
    if ccxt.IsTrue(ccxt.IsEqual(length, 0)) {
        return
    }
    var messageHash interface{} = "orders"
    var reset interface{} = this.SafeBool(message, "reset", false)
    var stored interface{} = this.Orders
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(stored, nil)) || ccxt.IsTrue(reset)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        stored = ccxt.NewArrayCacheBySymbolById(limit)
        this.Orders = stored
    }
    var orderSymbols interface{} = map[string]interface{} {}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawOrders)); i++ {
        var rawOrder interface{} = ccxt.GetValue(rawOrders, i)
        var order interface{} = this.ParseOrder(rawOrder)
        ccxt.AddElementToObject(orderSymbols, ccxt.GetValue(order, "symbol"), true)
        stored.(ccxt.Appender).Append(order)
    }
    var unique interface{} = ccxt.ObjectKeys(orderSymbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(unique)); i++ {
        var symbol interface{} = ccxt.GetValue(unique, i)
        var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(stored, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name probit#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs-en.probit.com/reference/marketdata
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ProbitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchOrderBook", "filter", "order_books")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
        
            orderbook:= (<-this.SubscribePublic("watchOrderBook", symbol, "orderbook", channel, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) SubscribePrivate(messageHash interface{}, channel interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var subscribe interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": channel,
            }
            var request interface{} = this.Extend(subscribe, params)
            var subscribeHash interface{} = messageHash
        
                retRes40715 :=  (<-this.Watch(url, messageHash, request, subscribeHash))
                ccxt.PanicOnError(retRes40715)
                ch <- retRes40715
                return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) SubscribePublic(methodName interface{}, symbol interface{}, dataType interface{}, filter interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4118)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var subscribeHash interface{} = ccxt.Add("marketdata:", symbol)
            var messageHash interface{} = ccxt.Add(ccxt.Add(dataType, ":"), symbol)
            var filters interface{} = map[string]interface{} {}
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscribeHash)) {
                // already subscribed
                filters = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), subscribeHash)
                if !ccxt.IsTrue((ccxt.InOp(filters, filter))) {
                    // resubscribe
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), subscribeHash)
                }
            }
            ccxt.AddElementToObject(filters, filter, true)
            var keys interface{} = ccxt.ObjectKeys(filters)
            var interval interface{} = nil
            intervalparamsVariable := this.HandleOptionAndParams(params, methodName, "interval", 100)
            interval = ccxt.GetValue(intervalparamsVariable,0)
            params = ccxt.GetValue(intervalparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "type": "subscribe",
                "channel": "marketdata",
                "market_id": ccxt.GetValue(market, "id"),
                "filter": keys,
                "interval": interval,
            }
            request = this.Extend(request, params)
        
                retRes43915 :=  (<-this.Watch(url, messageHash, request, subscribeHash, filters))
                ccxt.PanicOnError(retRes43915)
                ch <- retRes43915
                return nil
        
            }()
            return ch
        }
func  (this *ProbitCore) HandleOrderBook(client interface{}, message interface{}, orderBook interface{})  {
    //
    //     {
    //         "channel": "marketdata",
    //         "market_id": "BTC-USDT",
    //         "status": "ok",
    //         "lag": 0,
    //         "order_books": [
    //           { side: "buy", price: '1420.7', quantity: "0.057" },
    //           ...
    //         ],
    //         "reset": true
    //     }
    //
    var marketId interface{} = this.SafeString(message, "market_id")
    var symbol interface{} = this.SafeSymbol(marketId)
    var dataBySide interface{} = this.GroupBy(orderBook, "side")
    var messageHash interface{} = ccxt.Add("orderbook:", symbol)
    // let orderbook = this.safeValue (this.orderbooks, symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook(map[string]interface{} {}))
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var reset interface{} = this.SafeBool(message, "reset", false)
    if ccxt.IsTrue(reset) {
        var snapshot interface{} = this.ParseOrderBook(dataBySide, symbol, nil, "buy", "sell", "price", "quantity")
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        this.HandleDelta(orderbook, dataBySide)
    }
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *ProbitCore) HandleBidAsks(bookSide interface{}, bidAsks interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(bidAsks)); i++ {
        var bidAsk interface{} = ccxt.GetValue(bidAsks, i)
        var parsed interface{} = this.ParseBidAsk(bidAsk, "price", "quantity")
        bookSide.(ccxt.IOrderBookSide).StoreArray(parsed)
    }
}
func  (this *ProbitCore) HandleDelta(orderbook interface{}, delta interface{})  {
    var storedBids interface{} = ccxt.GetValue(orderbook, "bids")
    var storedAsks interface{} = ccxt.GetValue(orderbook, "asks")
    var asks interface{} = this.SafeValue(delta, "sell", []interface{}{})
    var bids interface{} = this.SafeValue(delta, "buy", []interface{}{})
    this.HandleBidAsks(storedBids, bids)
    this.HandleBidAsks(storedAsks, asks)
}
func  (this *ProbitCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "errorCode": "INVALID_ARGUMENT",
    //         "message": '',
    //         "details": {
    //             "interval": "invalid"
    //         }
    //     }
    //
    var code interface{} = this.SafeString(message, "errorCode")
    var errMessage interface{} = this.SafeString(message, "message", "")
    var details interface{} = this.SafeValue(message, "details")
    var feedback interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), code), " "), errMessage), " "), this.Json(details))
    if ccxt.IsTrue(ccxt.InOp(this.Exceptions, "exact")) {
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), code, feedback)
    }
    if ccxt.IsTrue(ccxt.InOp(this.Exceptions, "broad")) {
        this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), errMessage, feedback)
    }
    panic(ccxt.ExchangeError(feedback))
}
func  (this *ProbitCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    //     { type: "authorization", result: "ok" }
    //
    var result interface{} = this.SafeString(message, "result")
    var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
    if ccxt.IsTrue(ccxt.IsEqual(result, "ok")) {
        var messageHash interface{} = "authenticated"
        client.(ccxt.ClientInterface).Resolve(message, messageHash)
    } else {
        future.(*ccxt.Future).Reject(message)
        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
    }
}
func  (this *ProbitCore) HandleMarketData(client interface{}, message interface{})  {
    var ticker interface{} = this.SafeValue(message, "ticker")
    if ccxt.IsTrue(!ccxt.IsEqual(ticker, nil)) {
        this.HandleTicker(client, message)
    }
    var trades interface{} = this.SafeValue(message, "recent_trades", []interface{}{})
    var tradesLength interface{} =     ccxt.GetArrayLength(trades)
    if ccxt.IsTrue(tradesLength) {
        this.HandleTrades(client, message)
    }
    var orderBook interface{} = this.SafeValueN(message, []interface{}{"order_books", "order_books_l1", "order_books_l2", "order_books_l3", "order_books_l4"}, []interface{}{})
    var orderBookLength interface{} =     ccxt.GetArrayLength(orderBook)
    if ccxt.IsTrue(orderBookLength) {
        this.HandleOrderBook(client, message, orderBook)
    }
}
func  (this *ProbitCore) HandleMessage(client interface{}, message interface{})  {
    //
    //     {
    //         "errorCode": "INVALID_ARGUMENT",
    //         "message": '',
    //         "details": {
    //             "interval": "invalid"
    //         }
    //     }
    //
    // Note about 'reset' field
    // 'reset': true field - it happens once after initial subscription, which just returns old items by the moment of subscription (like "fetchMyTrades" does)
    //
    var errorCode interface{} = this.SafeString(message, "errorCode")
    if ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) {
        this.HandleErrorMessage(client, message)
        return
    }
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "authorization")) {
        this.HandleAuthenticate(client, message)
        return
    }
    var handlers interface{} = map[string]interface{} {
        "marketdata": this.HandleMarketData,
        "balance": this.HandleBalance,
        "trade_history": this.HandleMyTrades,
        "open_order": this.HandleOrders,
        "order_history": this.HandleOrders,
    }
    var channel interface{} = this.SafeString(message, "channel")
    var handler interface{} = this.SafeValue(handlers, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(handler, nil)) {
        ccxt.CallDynamically(handler, client, message)
        return
    }
    error := ccxt.NotSupported(ccxt.Add(ccxt.Add(this.Id, " handleMessage: unknown message: "), this.Json(message)))
    client.(ccxt.ClientInterface).Reject(error)
}
func  (this *ProbitCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var expires interface{} = this.SafeInteger(this.Options, "expires", 0)
            var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(future, nil))) || ccxt.IsTrue((ccxt.IsGreaterThan(this.Milliseconds(), expires)))) {
        
                response:= (<-this.SignIn())
                ccxt.PanicOnError(response)
                //
                //     {
                //         "access_token": "0ttDv/2hTTn3bLi8GP1gKaneiEQ6+0hOBenPrxNQt2s=",
                //         "token_type": "bearer",
                //         "expires_in": 900
                //     }
                //
                var accessToken interface{} = this.SafeString(response, "access_token")
                var request interface{} = map[string]interface{} {
                    "type": "authorization",
                    "token": accessToken,
                }
                
            future = (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                    ccxt.PanicOnError(future)
                ccxt.AddElementToObject(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash, future)
            }
        
            ch <- future
            return nil
        
            }()
            return ch
        }


func (this *ProbitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
