package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ModetradeCore struct {
	*ccxt.ModetradeCore
	base *ccxt.ModetradeCore
}

func NewModetradeCore() *ModetradeCore {
    p := &ModetradeCore{}
	base := &ccxt.ModetradeCore{}
	p.base = base
	p.ModetradeCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ModetradeCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://ws-evm.orderly.org/ws/stream",
                    "private": "wss://ws-private-evm.orderly.org/v2/ws/private/stream",
                },
            },
            "test": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://testnet-ws-evm.orderly.org/ws/stream",
                    "private": "wss://testnet-ws-private-evm.orderly.org/v2/ws/private/stream",
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "accountId": true,
        },
        "options": map[string]interface{} {
            "tradesLimit": 1000,
            "ordersLimit": 1000,
            "requestId": map[string]interface{} {},
            "watchPositions": map[string]interface{} {
                "fetchPositionsSnapshot": true,
                "awaitPositionsSnapshot": true,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
            "keepAlive": 10000,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "Auth is needed.": ccxt.AuthenticationError,
                },
            },
        },
    })
}
func  (this *ModetradeCore) RequestId(url interface{}) interface{}  {
    var options interface{} = this.SafeDict(this.Options, "requestId", map[string]interface{} {})
    var previousValue interface{} = this.SafeInteger(options, url, 0)
    var newValue interface{} = this.Sum(previousValue, 1)
    ccxt.AddElementToObject(ccxt.GetValue(this.Options, "requestId"), url, newValue)
    return newValue
}
func  (this *ModetradeCore) WatchPublic(messageHash interface{}, message interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    // the default id
            var id interface{} = "OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY"
            if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(this.AccountId, nil)) && ccxt.IsTrue(!ccxt.IsEqual(this.AccountId, ""))) {
                id = this.AccountId
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public"), "/"), id)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes9215 :=  (<-this.Watch(url, messageHash, request, messageHash, subscribe))
                ccxt.PanicOnError(retRes9215)
                ch <- retRes9215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name modetrade#watchOrderBook
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/orderbook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *ModetradeCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1068 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1068)
            var name interface{} = "orderbook"
            var market interface{} = this.Market(symbol)
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            orderbook:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "PERP_BTC_USDC@orderbook",
    //         "ts": 1650121915308,
    //         "data": {
    //             "symbol": "PERP_BTC_USDC",
    //             "bids": [
    //                 [
    //                     0.30891,
    //                     2469.98
    //                 ]
    //             ],
    //             "asks": [
    //                 [
    //                     0.31075,
    //                     2379.63
    //                 ]
    //             ]
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var topic interface{} = this.SafeString(message, "topic")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        ccxt.AddElementToObject(this.Orderbooks, symbol, this.OrderBook())
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var snapshot interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks")
    orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    client.(ccxt.ClientInterface).Resolve(orderbook, topic)
}
/**
 * @method
 * @name modetrade#watchTicker
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/24-hour-ticker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ModetradeCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1668 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1668)
            var name interface{} = "ticker"
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes17615 :=  (<-this.WatchPublic(topic, message))
                ccxt.PanicOnError(retRes17615)
                ch <- retRes17615
                return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "PERP_BTC_USDC",
    //         "open": 19441.5,
    //         "close": 20147.07,
    //         "high": 20761.87,
    //         "low": 19320.54,
    //         "volume": 2481.103,
    //         "amount": 50037935.0286,
    //         "count": 3689
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(nil, market),
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": this.SafeString(ticker, "close"),
        "last": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "amount"),
        "info": ticker,
    }, market)
}
func  (this *ModetradeCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "topic": "PERP_BTC_USDC@ticker",
    //         "ts": 1657120017000,
    //         "data": {
    //             "symbol": "PERP_BTC_USDC",
    //             "open": 19441.5,
    //             "close": 20147.07,
    //             "high": 20761.87,
    //             "low": 19320.54,
    //             "volume": 2481.103,
    //             "amount": 50037935.0286,
    //             "count": 3689
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var timestamp interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(data, "date", timestamp)
    var ticker interface{} = this.ParseWsTicker(data, market)
    ccxt.AddElementToObject(ticker, "symbol", ccxt.GetValue(market, "symbol"))
    ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(market, "symbol"), ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, topic)
    return message
}
/**
 * @method
 * @name modetrade#watchTickers
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/24-hour-tickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ModetradeCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2568 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2568)
            symbols = this.MarketSymbols(symbols)
            var name interface{} = "tickers"
            var topic interface{} = name
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            tickers:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleTickers(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"tickers",
    //         "ts":1618820615000,
    //         "data":[
    //             {
    //                 "symbol":"PERP_NEAR_USDC",
    //                 "open":16.297,
    //                 "close":17.183,
    //                 "high":24.707,
    //                 "low":11.997,
    //                 "volume":0,
    //                 "amount":0,
    //                 "count":0
    //             },
    //         ...
    //         ]
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var marketId interface{} = this.SafeString(ccxt.GetValue(data, i), "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var ticker interface{} = this.ParseWsTicker(this.Extend(ccxt.GetValue(data, i), map[string]interface{} {
            "date": timestamp,
        }), market)
        ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(market, "symbol"), ticker)
        ccxt.AppendToArray(&result, ticker)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
/**
 * @method
 * @name modetrade#watchBidsAsks
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/bbos
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *ModetradeCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3138)
            symbols = this.MarketSymbols(symbols)
            var name interface{} = "bbos"
            var topic interface{} = name
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            tickers:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(tickers)
        
            ch <- this.FilterByArray(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleBidAsk(client interface{}, message interface{})  {
    //
    //     {
    //       "topic": "bbos",
    //       "ts": 1726212495000,
    //       "data": [
    //         {
    //           "symbol": "PERP_BTC_USDC",
    //           "ask": 0.16570,
    //           "askSize": 4224,
    //           "bid": 0.16553,
    //           "bidSize": 6645
    //         }
    //       ]
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeList(message, "data", []interface{}{})
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var ticker interface{} = this.ParseWsBidAsk(this.Extend(ccxt.GetValue(data, i), map[string]interface{} {
            "ts": timestamp,
        }))
        ccxt.AddElementToObject(this.Tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        ccxt.AppendToArray(&result, ticker)
    }
    client.(ccxt.ClientInterface).Resolve(result, topic)
}
func  (this *ModetradeCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "ts")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "askSize"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bidSize"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name modetrade#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/k-line
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ModetradeCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes3848 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3848)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1m"))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "5m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "15m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "30m")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1h")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1d")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1w")))) && ccxt.IsTrue((!ccxt.IsEqual(timeframe, "1M")))) {
                panic(ccxt.NotSupported(ccxt.Add(this.Id, " watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M")))
            }
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var name interface{} = "kline"
            var topic interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.GetValue(market, "id"), "@"), name), "_"), interval)
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            ohlcv:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"PERP_BTC_USDC@kline_1m",
    //         "ts":1618822432146,
    //         "data":{
    //             "symbol":"PERP_BTC_USDC",
    //             "type":"1m",
    //             "open":56948.97,
    //             "close":56891.76,
    //             "high":56948.97,
    //             "low":56889.06,
    //             "volume":44.00947568,
    //             "amount":2504584.9,
    //             "startTime":1618822380000,
    //             "endTime":1618822440000
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var topic interface{} = this.SafeString(message, "topic")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var interval interface{} = this.SafeString(data, "type")
    var timeframe interface{} = this.FindTimeframe(interval)
    var parsed interface{} = []interface{}{this.SafeInteger(data, "startTime"), this.SafeNumber(data, "open"), this.SafeNumber(data, "high"), this.SafeNumber(data, "low"), this.SafeNumber(data, "close"), this.SafeNumber(data, "volume")}
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
        stored = ccxt.NewArrayCacheByTimestamp(limit)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
    }
    var ohlcvCache interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    ohlcvCache.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(ohlcvCache, topic)
}
/**
 * @method
 * @name modetrade#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/public/trade
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func  (this *ModetradeCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4628)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var topic interface{} = ccxt.Add(ccxt.GetValue(market, "id"), "@trade")
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            trades:= (<-this.WatchPublic(topic, message))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleTrade(client interface{}, message interface{})  {
    //
    // {
    //     "topic":"PERP_ADA_USDC@trade",
    //     "ts":1618820361552,
    //     "data":{
    //         "symbol":"PERP_ADA_USDC",
    //         "price":1.27988,
    //         "size":300,
    //         "side":"BUY",
    //     }
    // }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var timestamp interface{} = this.SafeInteger(message, "ts")
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var trade interface{} = this.ParseWsTrade(this.Extend(data, map[string]interface{} {
        "timestamp": timestamp,
    }), market)
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        var stored interface{} = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var trades interface{} = ccxt.GetValue(this.Trades, symbol)
    trades.(ccxt.Appender).Append(trade)
    ccxt.AddElementToObject(this.Trades, symbol, trades)
    client.(ccxt.ClientInterface).Resolve(trades, topic)
}
func  (this *ModetradeCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"PERP_ADA_USDC",
    //         "timestamp":1618820361552,
    //         "price":1.27988,
    //         "size":300,
    //         "side":"BUY",
    //     }
    // private stream
    //     {
    //         symbol: 'PERP_XRP_USDC',
    //         clientOrderId: '',
    //         orderId: 1167632251,
    //         type: 'MARKET',
    //         side: 'BUY',
    //         quantity: 20,
    //         price: 0,
    //         tradeId: '1715179456664012',
    //         executedPrice: 0.5276,
    //         executedQuantity: 20,
    //         fee: 0.006332,
    //         feeAsset: 'USDC',
    //         totalExecutedQuantity: 20,
    //         avgPrice: 0.5276,
    //         averageExecutedPrice: 0.5276,
    //         status: 'FILLED',
    //         reason: '',
    //         totalFee: 0.006332,
    //         visible: 0,
    //         visibleQuantity: 0,
    //         timestamp: 1715179456660,
    //         orderTag: 'CCXT',
    //         createdTime: 1715179456656,
    //         maker: false
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var price interface{} = this.SafeString2(trade, "executedPrice", "price")
    var amount interface{} = this.SafeString2(trade, "executedQuantity", "size")
    var cost interface{} = ccxt.Precise.StringMul(price, amount)
    var side interface{} = this.SafeStringLower(trade, "side")
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var takerOrMaker interface{} = nil
    var maker interface{} = this.SafeBool(trade, "maker")
    if ccxt.IsTrue(!ccxt.IsEqual(maker, nil)) {
        takerOrMaker = ccxt.Ternary(ccxt.IsTrue(maker), "maker", "taker")
    }
    var fee interface{} = nil
    var feeValue interface{} = this.SafeString(trade, "fee")
    if ccxt.IsTrue(!ccxt.IsEqual(feeValue, nil)) {
        fee = map[string]interface{} {
            "cost": feeValue,
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "feeAsset")),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "tradeId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": this.SafeString(trade, "orderId"),
        "takerOrMaker": takerOrMaker,
        "type": this.SafeStringLower(trade, "type"),
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *ModetradeCore) HandleAuth(client interface{}, message interface{})  {
    //
    //     {
    //         "event": "auth",
    //         "success": true,
    //         "ts": 1657463158812
    //     }
    //
    var messageHash interface{} = "authenticated"
    var success interface{} = this.SafeValue(message, "success")
    if ccxt.IsTrue(success) {
        // client.resolve (message, messageHash)
        var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
        future.(*ccxt.Future).Resolve(true)
    } else {
        error := ccxt.AuthenticationError(this.Json(message))
        client.(ccxt.ClientInterface).Reject(error, messageHash)
        // allows further authentication attempts
        if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
            ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
        }
    }
}
func  (this *ModetradeCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.AccountId)
            var client interface{} = this.Client(url)
            var messageHash interface{} = "authenticated"
            var event interface{} = "auth"
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var ts interface{} = ccxt.ToString(this.Nonce())
                var auth interface{} = ts
                var secret interface{} = this.Secret
                if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(secret, "ccxt.Ed25519:"), 0)) {
                    var parts interface{} = ccxt.Split(secret, "ccxt.Ed25519:")
                    secret = ccxt.GetValue(parts, 1)
                }
                var signature interface{} = ccxt.Eddsa(this.Encode(auth), this.Base58ToBinary(secret), ccxt.Ed25519)
                var request interface{} = map[string]interface{} {
                    "event": event,
                    "params": map[string]interface{} {
                        "orderly_key": this.ApiKey,
                        "sign": signature,
                        "timestamp": ts,
                    },
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes63615 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes63615)
                ch <- retRes63615
                return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) WatchPrivate(messageHash interface{}, message interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6408 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes6408)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.AccountId)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes64715 :=  (<-this.Watch(url, messageHash, request, messageHash, subscribe))
                ccxt.PanicOnError(retRes64715)
                ch <- retRes64715
                return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) WatchPrivateMultiple(messageHashes interface{}, message interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6518 := (<-this.Authenticate(params))
            ccxt.PanicOnError(retRes6518)
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.AccountId)
            var requestId interface{} = this.RequestId(url)
            var subscribe interface{} = map[string]interface{} {
                "id": requestId,
            }
            var request interface{} = this.Extend(subscribe, message)
        
                retRes65815 :=  (<-this.WatchMultiple(url, messageHashes, request, messageHashes, subscribe))
                ccxt.PanicOnError(retRes65815)
                ch <- retRes65815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name modetrade#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/execution-report
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/algo-execution-report
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if trigger order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ModetradeCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6758 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6758)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var topic interface{} = ccxt.Ternary(ccxt.IsTrue((trigger)), "algoexecutionreport", "executionreport")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var messageHash interface{} = topic
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            orders:= (<-this.WatchPrivate(messageHash, message))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name modetrade#watchMyTrades
 * @description watches information on multiple trades made by the user
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/execution-report
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/algo-execution-report
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true if trigger order
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *ModetradeCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7118)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var topic interface{} = ccxt.Ternary(ccxt.IsTrue((trigger)), "algoexecutionreport", "executionreport")
            params = this.Omit(params, "stop")
            var messageHash interface{} = "myTrades"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(messageHash, ccxt.Add(":", symbol))
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
            orders:= (<-this.WatchPrivate(messageHash, message))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "PERP_BTC_USDT",
    //         "clientOrderId": 0,
    //         "orderId": 52952826,
    //         "type": "LIMIT",
    //         "side": "SELL",
    //         "quantity": 0.01,
    //         "price": 22000,
    //         "tradeId": 0,
    //         "executedPrice": 0,
    //         "executedQuantity": 0,
    //         "fee": 0,
    //         "feeAsset": "USDT",
    //         "totalExecutedQuantity": 0,
    //         "status": "NEW",
    //         "reason": '',
    //         "orderTag": "default",
    //         "totalFee": 0,
    //         "visible": 0.01,
    //         "timestamp": 1657515556799,
    //         "reduceOnly": false,
    //         "maker": false
    //     }
    // algo order
    //     {
    //         "symbol":"PERP_MATIC_USDC",
    //         "rootAlgoOrderId":123,
    //         "parentAlgoOrderId":123,
    //         "algoOrderId":123,
    //         "orderTag":"some tags",
    //         "algoType": "STOP",
    //         "clientOrderId":"client_id",
    //         "type":"LIMIT",
    //         "side":"BUY",
    //         "quantity":7029.0,
    //         "price":0.7699,
    //         "tradeId":0,
    //         "triggerTradePrice":0,
    //         "triggerTime":1234567,
    //         "triggered": false,
    //         "activated": false,
    //         "executedPrice":0.0,
    //         "executedQuantity":0.0,
    //         "fee":0.0,
    //         "feeAsset":"USDC",
    //         "totalExecutedQuantity":0.0,
    //         "averageExecutedQuantity":0.0,
    //         "avgPrice":0,
    //         "triggerPrice":0.0,
    //         "triggerPriceType":"STOP",
    //         "isActivated": false,
    //         "status":"NEW",
    //         "rootAlgoStatus": "FILLED",
    //         "algoStatus": "FILLED",
    //         "reason":"",
    //         "totalFee":0.0,
    //         "visible": 7029.0,
    //         "visibleQuantity":7029.0,
    //         "timestamp":1704679472448,
    //         "maker":false,
    //         "isMaker":false,
    //         "createdTime":1704679472448
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var orderId interface{} = this.SafeString(order, "orderId")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.Market(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeString(order, "totalFee"),
        "currency": this.SafeString(order, "feeAsset"),
    }
    var priceString interface{} = this.SafeString(order, "price")
    var price interface{} = this.SafeNumber(order, "price")
    var avgPrice interface{} = this.SafeNumber(order, "avgPrice")
    if ccxt.IsTrue(ccxt.IsTrue(ccxt.Precise.StringEq(priceString, "0")) && ccxt.IsTrue((!ccxt.IsEqual(avgPrice, nil)))) {
        price = avgPrice
    }
    var amount interface{} = this.SafeString(order, "quantity")
    var side interface{} = this.SafeStringLower(order, "side")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var filled interface{} = this.SafeNumber(order, "totalExecutedQuantity")
    var totalExecQuantity interface{} = this.SafeString(order, "totalExecutedQuantity")
    var remaining interface{} = amount
    if ccxt.IsTrue(ccxt.Precise.StringGe(amount, totalExecQuantity)) {
        remaining = ccxt.Precise.StringSub(remaining, totalExecQuantity)
    }
    var rawStatus interface{} = this.SafeString(order, "status")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    var trades interface{} = nil
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var triggerPrice interface{} = this.SafeNumber(order, "triggerPrice")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": timestamp,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": trades,
    })
}
func  (this *ModetradeCore) HandleOrderUpdate(client interface{}, message interface{})  {
    //
    //     {
    //         "topic": "executionreport",
    //         "ts": 1657515556799,
    //         "data": {
    //             "symbol": "PERP_BTC_USDT",
    //             "clientOrderId": 0,
    //             "orderId": 52952826,
    //             "type": "LIMIT",
    //             "side": "SELL",
    //             "quantity": 0.01,
    //             "price": 22000,
    //             "tradeId": 0,
    //             "executedPrice": 0,
    //             "executedQuantity": 0,
    //             "fee": 0,
    //             "feeAsset": "USDT",
    //             "totalExecutedQuantity": 0,
    //             "status": "NEW",
    //             "reason": '',
    //             "orderTag": "default",
    //             "totalFee": 0,
    //             "visible": 0.01,
    //             "timestamp": 1657515556799,
    //             "maker": false
    //         }
    //     }
    //
    var topic interface{} = this.SafeString(message, "topic")
    var data interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsArray(data)) {
        // algoexecutionreport
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var order interface{} = ccxt.GetValue(data, i)
            var tradeId interface{} = this.OmitZero(this.SafeString(data, "tradeId"))
            if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
                this.HandleMyTrade(client, order)
            }
            this.HandleOrder(client, order, topic)
        }
    } else {
        // executionreport
        var tradeId interface{} = this.OmitZero(this.SafeString(data, "tradeId"))
        if ccxt.IsTrue(!ccxt.IsEqual(tradeId, nil)) {
            this.HandleMyTrade(client, data)
        }
        this.HandleOrder(client, data, topic)
    }
}
func  (this *ModetradeCore) HandleOrder(client interface{}, message interface{}, topic interface{})  {
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    var orderId interface{} = this.SafeString(parsed, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var cachedOrders interface{} = this.Orders
        var orders interface{} = this.SafeDict(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var order interface{} = this.SafeDict(orders, orderId)
        if ccxt.IsTrue(!ccxt.IsEqual(order, nil)) {
            var fee interface{} = this.SafeValue(order, "fee")
            if ccxt.IsTrue(!ccxt.IsEqual(fee, nil)) {
                ccxt.AddElementToObject(parsed, "fee", fee)
            }
            var fees interface{} = this.SafeList(order, "fees")
            if ccxt.IsTrue(!ccxt.IsEqual(fees, nil)) {
                ccxt.AddElementToObject(parsed, "fees", fees)
            }
            ccxt.AddElementToObject(parsed, "trades", this.SafeList(order, "trades"))
            ccxt.AddElementToObject(parsed, "timestamp", this.SafeInteger(order, "timestamp"))
            ccxt.AddElementToObject(parsed, "datetime", this.SafeString(order, "datetime"))
        }
        cachedOrders.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(this.Orders, topic)
        var messageHashSymbol interface{} = ccxt.Add(ccxt.Add(topic, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(this.Orders, messageHashSymbol)
    }
}
func  (this *ModetradeCore) HandleMyTrade(client interface{}, message interface{})  {
    //
    // {
    //     symbol: 'PERP_XRP_USDC',
    //     clientOrderId: '',
    //     orderId: 1167632251,
    //     type: 'MARKET',
    //     side: 'BUY',
    //     quantity: 20,
    //     price: 0,
    //     tradeId: '1715179456664012',
    //     executedPrice: 0.5276,
    //     executedQuantity: 20,
    //     fee: 0.006332,
    //     feeAsset: 'USDC',
    //     totalExecutedQuantity: 20,
    //     avgPrice: 0.5276,
    //     averageExecutedPrice: 0.5276,
    //     status: 'FILLED',
    //     reason: '',
    //     totalFee: 0.006332,
    //     visible: 0,
    //     visibleQuantity: 0,
    //     timestamp: 1715179456660,
    //     orderTag: 'CCXT',
    //     createdTime: 1715179456656,
    //     maker: false
    // }
    //
    var messageHash interface{} = "myTrades"
    var marketId interface{} = this.SafeString(message, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var trade interface{} = this.ParseWsTrade(message, market)
    var trades interface{} = this.MyTrades
    if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        trades = ccxt.NewArrayCacheBySymbolById(limit)
        this.MyTrades = trades
    }
    trades.(ccxt.Appender).Append(trade)
    client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(trades, symbolSpecificMessageHash)
}
/**
 * @method
 * @name modetrade#watchPositions
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/position-push
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param since timestamp in ms of the earliest position to fetch
 * @param limit the maximum number of positions to fetch
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *ModetradeCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9958 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes9958)
            var messageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols)
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                    var symbol interface{} = ccxt.GetValue(symbols, i)
                    ccxt.AppendToArray(&messageHashes, ccxt.Add("positions::", symbol))
                }
            } else {
                ccxt.AppendToArray(&messageHashes, "positions")
            }
            var url interface{} = ccxt.Add(ccxt.Add(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "private"), "/"), this.AccountId)
            var client interface{} = this.Client(url)
            this.SetPositionsCache(client, symbols)
            var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", true)
            var awaitPositionsSnapshot interface{} = this.HandleOption("watchPositions", "awaitPositionsSnapshot", true)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(fetchPositionsSnapshot) && ccxt.IsTrue(awaitPositionsSnapshot)) && ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil))) {
        
                snapshot:= (<-client.(ccxt.ClientInterface).Future("fetchPositionsSnapshot"))
                ccxt.PanicOnError(snapshot)
        
                ch <- this.FilterBySymbolsSinceLimit(snapshot, symbols, since, limit, true)
                return nil
            }
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": "position",
            }
        
            newPositions:= (<-this.WatchPrivateMultiple(messageHashes, request, params))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) SetPositionsCache(client interface{}, typeVar interface{}, optionalArgs ...interface{})  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    var fetchPositionsSnapshot interface{} = this.HandleOption("watchPositions", "fetchPositionsSnapshot", false)
    if ccxt.IsTrue(fetchPositionsSnapshot) {
        var messageHash interface{} = "fetchPositionsSnapshot"
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadPositionsSnapshot, client, messageHash)
        }
    } else {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
}
func  (this *ModetradeCore) LoadPositionsSnapshot(client interface{}, messageHash interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            positions:= (<-this.FetchPositions())
            ccxt.PanicOnError(positions)
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var cache interface{} = this.Positions
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
                var position interface{} = ccxt.GetValue(positions, i)
                var contracts interface{} = this.SafeString(position, "contracts", "0")
                if ccxt.IsTrue(ccxt.Precise.StringGt(contracts, "0")) {
                    cache.(ccxt.Appender).Append(position)
                }
            }
            // don't remove the future from the .futures cache
            if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash)) {
                var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
                future.(*ccxt.Future).Resolve(cache)
                client.(ccxt.ClientInterface).Resolve(cache, "positions")
            }
                return nil
            }()
            return ch
        }
func  (this *ModetradeCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        "topic":"position",
    //        "ts":1705292345255,
    //        "data":{
    //           "positions":[
    //              {
    //                     "symbol":"PERP_ETH_USDC",
    //                     "positionQty":3.1408,
    //                     "costPosition":5706.51952,
    //                     "lastSumUnitaryFunding":0.804,
    //                     "sumUnitaryFundingVersion":0,
    //                     "pendingLongQty":0.0,
    //                     "pendingShortQty":-1.0,
    //                     "settlePrice":1816.9,
    //                     "averageOpenPrice":1804.51490427,
    //                     "unsettledPnl":-2.79856,
    //                     "pnl24H":-338.90179488,
    //                     "fee24H":4.242423,
    //                     "markPrice":1816.2,
    //                     "estLiqPrice":0.0,
    //                     "version":179967,
    //                     "imrwithOrders":0.1,
    //                     "mmrwithOrders":0.05,
    //                     "mmr":0.05,
    //                     "imr":0.1,
    //                     "timestamp":1685154032762
    //              }
    //           ]
    //        }
    //    }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var rawPositions interface{} = this.SafeList(data, "positions", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawPositions)); i++ {
        var rawPosition interface{} = ccxt.GetValue(rawPositions, i)
        var marketId interface{} = this.SafeString(rawPosition, "symbol")
        var market interface{} = this.SafeMarket(marketId)
        var position interface{} = this.ParseWsPosition(rawPosition, market)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
        var messageHash interface{} = ccxt.Add("positions::", ccxt.GetValue(market, "symbol"))
        client.(ccxt.ClientInterface).Resolve(position, messageHash)
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
func  (this *ModetradeCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"PERP_ETH_USDC",
    //         "positionQty":3.1408,
    //         "costPosition":5706.51952,
    //         "lastSumUnitaryFunding":0.804,
    //         "sumUnitaryFundingVersion":0,
    //         "pendingLongQty":0.0,
    //         "pendingShortQty":-1.0,
    //         "settlePrice":1816.9,
    //         "averageOpenPrice":1804.51490427,
    //         "unsettledPnl":-2.79856,
    //         "pnl24H":-338.90179488,
    //         "fee24H":4.242423,
    //         "markPrice":1816.2,
    //         "estLiqPrice":0.0,
    //         "version":179967,
    //         "imrwithOrders":0.1,
    //         "mmrwithOrders":0.05,
    //         "mmr":0.05,
    //         "imr":0.1,
    //         "timestamp":1685154032762
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var contract interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(contract, market)
    var size interface{} = this.SafeString(position, "positionQty")
    var side interface{} = nil
    if ccxt.IsTrue(ccxt.Precise.StringGt(size, "0")) {
        side = "long"
    } else {
        side = "short"
    }
    var contractSize interface{} = this.SafeString(market, "contractSize")
    var markPrice interface{} = this.SafeString(position, "markPrice")
    var timestamp interface{} = this.SafeInteger(position, "timestamp")
    var entryPrice interface{} = this.SafeString(position, "averageOpenPrice")
    var unrealisedPnl interface{} = this.SafeString(position, "unsettledPnl")
    size = ccxt.Precise.StringAbs(size)
    var notional interface{} = ccxt.Precise.StringMul(size, markPrice)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "entryPrice": this.ParseNumber(entryPrice),
        "notional": this.ParseNumber(notional),
        "leverage": nil,
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(size),
        "contractSize": this.ParseNumber(contractSize),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber(position, "estLiqPrice"),
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": "cross",
        "marginType": nil,
        "side": side,
        "percentage": nil,
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name modetrade#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://orderly.network/docs/build-on-evm/evm-api/websocket-api/private/balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *ModetradeCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11938)
            var topic interface{} = "balance"
            var messageHash interface{} = topic
            var request interface{} = map[string]interface{} {
                "event": "subscribe",
                "topic": topic,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes120115 :=  (<-this.WatchPrivate(messageHash, message))
                ccxt.PanicOnError(retRes120115)
                ch <- retRes120115
                return nil
        
            }()
            return ch
        }
func  (this *ModetradeCore) HandleBalance(client interface{}, message interface{})  {
    //
    //     {
    //         "topic":"balance",
    //         "ts":1651836695254,
    //         "data":{
    //             "balances":{
    //                 "USDC":{
    //                     "holding":5555815.47398272,
    //                     "frozen":0,
    //                     "interest":0,
    //                     "pendingShortQty":0,
    //                     "pendingExposure":0,
    //                     "pendingLongQty":0,
    //                     "pendingLongExposure":0,
    //                     "version":894,
    //                     "staked":51370692,
    //                     "unbonding":0,
    //                     "vault":0,
    //                     "averageOpenPrice":0.00000574,
    //                     "pnl24H":0,
    //                     "fee24H":0.01914,
    //                     "markPrice":0.31885
    //                 }
    //             }
    //         }
    //     }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var balances interface{} = this.SafeDict(data, "balances", map[string]interface{} {})
    var keys interface{} = ccxt.ObjectKeys(balances)
    var ts interface{} = this.SafeInteger(message, "ts")
    ccxt.AddElementToObject(this.Balance, "info", data)
    ccxt.AddElementToObject(this.Balance, "timestamp", ts)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(ts))
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
        var key interface{} = ccxt.GetValue(keys, i)
        var value interface{} = ccxt.GetValue(balances, key)
        var code interface{} = this.SafeCurrencyCode(key)
        var account interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.InOp(this.Balance, code))), ccxt.GetValue(this.Balance, code), this.Account())
        var total interface{} = this.SafeString(value, "holding")
        var used interface{} = this.SafeString(value, "frozen")
        ccxt.AddElementToObject(account, "total", total)
        ccxt.AddElementToObject(account, "used", used)
        ccxt.AddElementToObject(account, "free", ccxt.Precise.StringSub(total, used))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, "balance")
}
func  (this *ModetradeCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    // {"id":"1","event":"subscribe","success":false,"ts":1710780997216,"errorMsg":"Auth is needed."}
    //
    if !ccxt.IsTrue((ccxt.InOp(message, "success"))) {
        return false
    }
    var success interface{} = this.SafeBool(message, "success")
    if ccxt.IsTrue(success) {
        return false
    }
    var errorMessage interface{} = this.SafeString(message, "errorMsg")
    
        {
            ret__ := func(this *ModetradeCore) (ret_ interface{}) {
    		    defer func() {
                    if error := recover(); error != nil {
                        if error == "break" {
                            return
                        }
                        ret_ = func(this *ModetradeCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(error, ccxt.AuthenticationError)) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(error, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            } else {
                client.(ccxt.ClientInterface).Reject(error)
            }
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorMessage, nil)) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorMessage, feedback)
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *ModetradeCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var methods interface{} = map[string]interface{} {
        "ping": this.HandlePing,
        "pong": this.HandlePong,
        "subscribe": this.HandleSubscribe,
        "orderbook": this.HandleOrderBook,
        "ticker": this.HandleTicker,
        "tickers": this.HandleTickers,
        "kline": this.HandleOHLCV,
        "trade": this.HandleTrade,
        "auth": this.HandleAuth,
        "executionreport": this.HandleOrderUpdate,
        "algoexecutionreport": this.HandleOrderUpdate,
        "position": this.HandlePositions,
        "balance": this.HandleBalance,
        "bbos": this.HandleBidAsk,
    }
    var event interface{} = this.SafeString(message, "event")
    var method interface{} = this.SafeValue(methods, event)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
        return
    }
    var topic interface{} = this.SafeString(message, "topic")
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        method = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
            return
        }
        var splitTopic interface{} = ccxt.Split(topic, "@")
        var splitLength interface{} =         ccxt.GetArrayLength(splitTopic)
        if ccxt.IsTrue(ccxt.IsEqual(splitLength, 2)) {
            var name interface{} = this.SafeString(splitTopic, 1)
            method = this.SafeValue(methods, name)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
                return
            }
            var splitName interface{} = ccxt.Split(name, "_")
            var splitNameLength interface{} =             ccxt.GetArrayLength(splitTopic)
            if ccxt.IsTrue(ccxt.IsEqual(splitNameLength, 2)) {
                method = this.SafeValue(methods, this.SafeString(splitName, 0))
                if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                    ccxt.CallDynamically(method, client, message)
                }
            }
        }
    }
}
func  (this *ModetradeCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "event": "ping",
    }
}
func  (this *ModetradeCore) HandlePing(client interface{}, message interface{}) interface{}  {
    return map[string]interface{} {
        "event": "pong",
    }
}
func  (this *ModetradeCore) HandlePong(client interface{}, message interface{}) interface{}  {
    //
    // { event: "pong", ts: 1614667590000 }
    //
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *ModetradeCore) HandleSubscribe(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "id": "666888",
    //         "event": "subscribe",
    //         "success": true,
    //         "ts": 1657117712212
    //     }
    //
    return message
}


func (this *ModetradeCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
