package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BithumbCore struct {
	*ccxt.BithumbCore
	base *ccxt.BithumbCore
}

func NewBithumbCore() *BithumbCore {
    p := &BithumbCore{}
	base := &ccxt.BithumbCore{}
	p.base = base
	p.BithumbCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BithumbCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "public": "wss://pubwss.bithumb.com/pub/ws",
                    "publicV2": "wss://ws-api.bithumb.com/websocket/v1",
                    "privateV2": "wss://ws-api.bithumb.com/websocket/v1/private",
                },
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name bithumb#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
 */
func  (this *BithumbCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
        
            retRes538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes538)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "ticker",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
                "tickTypes": []interface{}{this.SafeString(params, "tickTypes", "24H")},
            }
        
                retRes6115 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes6115)
                ch <- retRes6115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BithumbCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes748 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes748)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var marketIds interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&marketIds, ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
            var request interface{} = map[string]interface{} {
                "type": "ticker",
                "symbols": marketIds,
                "tickTypes": []interface{}{this.SafeString(params, "tickTypes", "24H")},
            }
            var message interface{} = this.Extend(request, params)
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "ticker",
    //        "content" : {
    //            "symbol" : "BTC_KRW",           // 통화코드
    //            "tickType" : "24H",                 // 변동 기준시간- 30M, 1H, 12H, 24H, MID
    //            "date" : "20200129",                // 일자
    //            "time" : "121844",                  // 시간
    //            "openPrice" : "2302",               // 시가
    //            "closePrice" : "2317",              // 종가
    //            "lowPrice" : "2272",                // 저가
    //            "highPrice" : "2344",               // 고가
    //            "value" : "2831915078.07065789",    // 누적거래금액
    //            "volume" : "1222314.51355788",  // 누적거래량
    //            "sellVolume" : "760129.34079004",   // 매도누적거래량
    //            "buyVolume" : "462185.17276784",    // 매수누적거래량
    //            "prevClosePrice" : "2326",          // 전일종가
    //            "chgRate" : "0.65",                 // 변동률
    //            "chgAmt" : "15",                    // 변동금액
    //            "volumePower" : "60.80"         // 체결강도
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var marketId interface{} = this.SafeString(content, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var ticker interface{} = this.ParseWsTicker(content)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *BithumbCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol" : "BTC_KRW",           // 통화코드
    //        "tickType" : "24H",                 // 변동 기준시간- 30M, 1H, 12H, 24H, MID
    //        "date" : "20200129",                // 일자
    //        "time" : "121844",                  // 시간
    //        "openPrice" : "2302",               // 시가
    //        "closePrice" : "2317",              // 종가
    //        "lowPrice" : "2272",                // 저가
    //        "highPrice" : "2344",               // 고가
    //        "value" : "2831915078.07065789",    // 누적거래금액
    //        "volume" : "1222314.51355788",  // 누적거래량
    //        "sellVolume" : "760129.34079004",   // 매도누적거래량
    //        "buyVolume" : "462185.17276784",    // 매수누적거래량
    //        "prevClosePrice" : "2326",          // 전일종가
    //        "chgRate" : "0.65",                 // 변동률
    //        "chgAmt" : "15",                    // 변동금액
    //        "volumePower" : "60.80"         // 체결강도
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var date interface{} = this.SafeString(ticker, "date", "")
    var time interface{} = this.SafeString(ticker, "time", "")
    var datetime interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Slice(date, 0, 4), "-"), ccxt.Slice(date, 4, 6)), "-"), ccxt.Slice(date, 6, 8)), "T"), ccxt.Slice(time, 0, 2)), ":"), ccxt.Slice(time, 2, 4)), ":"), ccxt.Slice(time, 4, 6))
    var marketId interface{} = this.SafeString(ticker, "symbol")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, "_"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "high": this.SafeString(ticker, "highPrice"),
        "low": this.SafeString(ticker, "lowPrice"),
        "bid": nil,
        "bidVolume": this.SafeString(ticker, "buyVolume"),
        "ask": nil,
        "askVolume": this.SafeString(ticker, "sellVolume"),
        "vwap": nil,
        "open": this.SafeString(ticker, "openPrice"),
        "close": this.SafeString(ticker, "closePrice"),
        "last": nil,
        "previousClose": this.SafeString(ticker, "prevClosePrice"),
        "change": this.SafeString(ticker, "chgAmt"),
        "percentage": this.SafeString(ticker, "chgRate"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "value"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bithumb#watchOrderBook
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func  (this *BithumbCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1938 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1938)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
            var request interface{} = map[string]interface{} {
                "type": "orderbookdepth",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "orderbookdepth",
    //            "content" : {
    //            "list" : [
    //                {
    //                    "symbol" : "BTC_KRW",
    //                    "orderType" : "ask",        // 주문타입 – bid / ask
    //                    "price" : "10593000",       // 호가
    //                    "quantity" : "1.11223318",  // 잔량
    //                    "total" : "3"               // 건수
    //                },
    //                {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10596000", "quantity" : "0.5495", "total" : "8"},
    //                {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10598000", "quantity" : "18.2085", "total" : "10"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10532000", "quantity" : "0", "total" : "0"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10572000", "quantity" : "2.3324", "total" : "4"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10571000", "quantity" : "1.469", "total" : "3"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10569000", "quantity" : "0.5152", "total" : "2"}
    //            ],
    //            "datetime":1580268255864325     // 일시
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var list interface{} = this.SafeList(content, "list", []interface{}{})
    var first interface{} = this.SafeDict(list, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(first, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var timestampStr interface{} = this.SafeString(content, "datetime")
    var timestamp interface{} = this.ParseToInt(ccxt.Slice(timestampStr, 0, 13))
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook()
        ccxt.AddElementToObject(ob, "symbol", symbol)
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    this.HandleDeltas(orderbook, list)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BithumbCore) HandleDelta(orderbook interface{}, delta interface{})  {
    //
    //    {
    //        symbol: "ETH_BTC",
    //        orderType: "bid",
    //        price: "0.07349517",
    //        quantity: "0",
    //        total: "0",
    //    }
    //
    var sideId interface{} = this.SafeString(delta, "orderType")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, "bid"))), "bids", "asks")
    var bidAsk interface{} = this.ParseBidAsk(delta, "price", "quantity")
    var orderbookSide interface{} = ccxt.GetValue(orderbook, side)
    orderbookSide.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *BithumbCore) HandleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(orderbook, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name bithumb#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#public-trades}
 */
func  (this *BithumbCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2858 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2858)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "public")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trade:", symbol)
            var request interface{} = map[string]interface{} {
                "type": "transaction",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "transaction",
    //        "content" : {
    //            "list" : [
    //                {
    //                    "symbol" : "BTC_KRW",
    //                    "buySellGb" : "1",
    //                    "contPrice" : "10579000",
    //                    "contQty" : "0.01",
    //                    "contAmt" : "105790.00",
    //                    "contDtm" : "2020-01-29 12:24:18.830039",
    //                    "updn" : "dn"
    //                }
    //            ]
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var rawTrades interface{} = this.SafeList(content, "list", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var rawTrade interface{} = ccxt.GetValue(rawTrades, i)
        var marketId interface{} = this.SafeString(rawTrade, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
        if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            var stored interface{} = ccxt.NewArrayCache(limit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        var trades interface{} = ccxt.GetValue(this.Trades, symbol)
        var parsed interface{} = this.ParseWsTrade(rawTrade)
        trades.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    }
}
func  (this *BithumbCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol" : "BTC_KRW",
    //        "buySellGb" : "1",
    //        "contPrice" : "10579000",
    //        "contQty" : "0.01",
    //        "contAmt" : "105790.00",
    //        "contDtm" : "2020-01-29 12:24:18.830038",
    //        "updn" : "dn"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var datetime interface{} = this.SafeString(trade, "contDtm")
    // that date is not UTC iso8601, but exchange's local time, -9hr difference
    var timestamp interface{} = ccxt.Subtract(this.Parse8601(datetime), 32400000)
    var sideId interface{} = this.SafeString(trade, "buySellGb")
    return this.SafeTrade(map[string]interface{} {
        "id": nil,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeSymbol(marketId, market, "_"),
        "order": nil,
        "type": nil,
        "side": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, "1"))), "buy", "sell"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "contPrice"),
        "amount": this.SafeString(trade, "contQty"),
        "cost": this.SafeString(trade, "contAmt"),
        "fee": nil,
    }, market)
}
func  (this *BithumbCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "status" : "5100",
    //        "resmsg" : "Invalid Filter Syntax"
    //    }
    //
    if !ccxt.IsTrue((ccxt.InOp(message, "status"))) {
        return true
    }
    var errorCode interface{} = this.SafeString(message, "status")
    
        {
             func(this *BithumbCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BithumbCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, "0000")) {
                var msg interface{} = this.SafeString(message, "resmsg")
                panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), msg)))
            }
            return true
    		    
    	    }(this)
        
            }
    return true
}
/**
 * @method
 * @name bithumb#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apidocs.bithumb.com/v2.1.5/reference/%EB%82%B4-%EC%9E%90%EC%82%B0-myasset
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BithumbCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4058 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4058)
        
            retRes4068 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4068)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var messageHash interface{} = "myAsset"
            var request interface{} = []interface{}{map[string]interface{} {
            "ticket": "ccxt",
        }, map[string]interface{} {
            "type": messageHash,
        }}
        
            balance:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(balance)
        
            ch <- balance
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleBalance(client interface{}, message interface{})  {
    //
    //    {
    //        "type": "myAsset",
    //        "assets": [
    //            {
    //                "currency": "KRW",
    //                "balance": "2061832.35",
    //                "locked": "3824127.3"
    //            }
    //        ],
    //        "asset_timestamp": 1727052537592,
    //        "timestamp": 1727052537687,
    //        "stream_type": "REALTIME"
    //    }
    //
    var messageHash interface{} = "myAsset"
    var assets interface{} = this.SafeList(message, "assets", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Balance, nil)) {
        this.Balance = map[string]interface{} {}
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(assets)); i++ {
        var asset interface{} = ccxt.GetValue(assets, i)
        var currencyId interface{} = this.SafeString(asset, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(asset, "balance"))
        ccxt.AddElementToObject(account, "used", this.SafeString(asset, "locked"))
        ccxt.AddElementToObject(this.Balance, code, account)
    }
    ccxt.AddElementToObject(this.Balance, "info", message)
    var timestamp interface{} = this.SafeInteger(message, "timestamp")
    ccxt.AddElementToObject(this.Balance, "timestamp", timestamp)
    ccxt.AddElementToObject(this.Balance, "datetime", this.Iso8601(timestamp))
    this.Balance = this.SafeBalance(this.Balance)
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *BithumbCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var wsOptions interface{} = this.SafeDict(this.Options, "ws", map[string]interface{} {})
            var authenticated interface{} = this.SafeString(wsOptions, "token")
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var payload interface{} = map[string]interface{} {
                    "access_key": this.ApiKey,
                    "nonce": this.Uuid(),
                    "timestamp": this.Milliseconds(),
                }
                var jwtToken interface{} = ccxt.Jwt(payload, this.Encode(this.Secret), ccxt.Sha256)
                ccxt.AddElementToObject(wsOptions, "token", jwtToken)
                ccxt.AddElementToObject(wsOptions, "options", map[string]interface{} {
            "headers": map[string]interface{} {
                "authorization": ccxt.Add("Bearer ", jwtToken),
            },
        })
                ccxt.AddElementToObject(this.Options, "ws", wsOptions)
            }
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var client interface{} = this.Client(url)
        
            ch <- client
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://apidocs.bithumb.com/v2.1.5/reference/%EB%82%B4-%EC%A3%BC%EB%AC%B8-%EB%B0%8F-%EC%B2%B4%EA%B2%B0-myorder
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.codes] market codes to filter orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BithumbCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4928 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4928)
        
            retRes4938 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4938)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), "privateV2")
            var messageHash interface{} = "myOrder"
            var codes interface{} = this.SafeList(params, "codes", []interface{}{})
            var request interface{} = []interface{}{map[string]interface{} {
            "ticket": "ccxt",
        }, map[string]interface{} {
            "type": messageHash,
            "codes": codes,
        }}
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = ccxt.GetValue(market, "symbol")
                messageHash = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
            }
        
            orders:= (<-this.Watch(url, messageHash, request, messageHash))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleOrders(client interface{}, message interface{})  {
    //
    //    {
    //        "type": "myOrder",
    //        "code": "KRW-BTC",
    //        "uuid": "C0101000000001818113",
    //        "ask_bid": "BID",
    //        "order_type": "limit",
    //        "state": "trade",
    //        "trade_uuid": "C0101000000001744207",
    //        "price": 1927000,
    //        "volume": 0.4697,
    //        "remaining_volume": 0.0803,
    //        "executed_volume": 0.4697,
    //        "trades_count": 1,
    //        "reserved_fee": 0,
    //        "remaining_fee": 0,
    //        "paid_fee": 0,
    //        "executed_funds": 905111.9000,
    //        "trade_timestamp": 1727052318148,
    //        "order_timestamp": 1727052318074,
    //        "timestamp": 1727052318369,
    //        "stream_type": "REALTIME"
    //    }
    //
    var messageHash interface{} = "myOrder"
    var parsed interface{} = this.ParseWsOrder(message)
    var symbol interface{} = this.SafeString(parsed, "symbol")
    // const orderId = this.safeString (parsed, 'id')
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var cachedOrders interface{} = this.Orders
    cachedOrders.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(cachedOrders, messageHash)
    var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(cachedOrders, symbolSpecificMessageHash)
}
func  (this *BithumbCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "type": "myOrder",
    //        "code": "KRW-BTC",
    //        "uuid": "C0101000000001818113",
    //        "ask_bid": "BID",
    //        "order_type": "limit",
    //        "state": "trade",
    //        "trade_uuid": "C0101000000001744207",
    //        "price": 1927000,
    //        "volume": 0.4697,
    //        "remaining_volume": 0.0803,
    //        "executed_volume": 0.4697,
    //        "trades_count": 1,
    //        "reserved_fee": 0,
    //        "remaining_fee": 0,
    //        "paid_fee": 0,
    //        "executed_funds": 905111.9000,
    //        "trade_timestamp": 1727052318148,
    //        "order_timestamp": 1727052318074,
    //        "timestamp": 1727052318369,
    //        "stream_type": "REALTIME"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "code")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var timestamp interface{} = this.SafeInteger(order, "order_timestamp")
    var sideId interface{} = this.SafeString(order, "ask_bid")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, "BID"))), ("buy"), ("sell"))
    var typeId interface{} = this.SafeString(order, "order_type")
    var typeVar interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(typeId, "limit")) {
        typeVar = "limit"
    } else if ccxt.IsTrue(ccxt.IsEqual(typeId, "price")) {
        typeVar = "market"
    } else if ccxt.IsTrue(ccxt.IsEqual(typeId, "market")) {
        typeVar = "market"
    }
    var stateId interface{} = this.SafeString(order, "state")
    var status interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(stateId, "wait")) {
        status = "open"
    } else if ccxt.IsTrue(ccxt.IsEqual(stateId, "trade")) {
        status = "open"
    } else if ccxt.IsTrue(ccxt.IsEqual(stateId, "done")) {
        status = "closed"
    } else if ccxt.IsTrue(ccxt.IsEqual(stateId, "cancel")) {
        status = "canceled"
    }
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "volume")
    var remaining interface{} = this.SafeString(order, "remaining_volume")
    var filled interface{} = this.SafeString(order, "executed_volume")
    var cost interface{} = this.SafeString(order, "executed_funds")
    var feeCost interface{} = this.SafeString(order, "paid_fee")
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        var marketForFee interface{} = this.SafeMarket(marketId, market)
        var feeCurrency interface{} = this.SafeString(marketForFee, "quote")
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "uuid"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "trade_timestamp"),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": amount,
        "cost": cost,
        "average": nil,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
func  (this *BithumbCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var topic interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        var methods interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "orderbookdepth": this.HandleOrderBook,
            "transaction": this.HandleTrades,
            "myAsset": this.HandleBalance,
            "myOrder": this.HandleOrders,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *BithumbCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
