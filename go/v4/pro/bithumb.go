package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BithumbCore struct {
	*ccxt.BithumbCore
	base *ccxt.BithumbCore
}

func NewBithumbCore() *BithumbCore {
    p := &BithumbCore{}
	base := &ccxt.BithumbCore{}
	p.base = base
	p.BithumbCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BithumbCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": false,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchOrderBook": true,
            "watchOHLCV": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://pubwss.bithumb.com/pub/ws",
            },
        },
        "options": map[string]interface{} {},
        "streaming": map[string]interface{} {},
        "exceptions": map[string]interface{} {},
    })
}
/**
 * @method
 * @name bithumb#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.channel] the channel to subscribe to, tickers by default. Can be tickers, sprd-tickers, index-tickers, block-tickers
 * @returns {object} a [ticker structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
 */
func  (this *BithumbCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
        
            retRes468 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes468)
            var market interface{} = this.Market(symbol)
            var messageHash interface{} = ccxt.Add("ticker:", ccxt.GetValue(market, "symbol"))
            var request interface{} = map[string]interface{} {
                "type": "ticker",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
                "tickTypes": []interface{}{this.SafeString(params, "tickTypes", "24H")},
            }
        
                retRes5415 :=  (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
                ccxt.PanicOnError(retRes5415)
                ch <- retRes5415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BithumbCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes678)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var marketIds interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            symbols = this.MarketSymbols(symbols, nil, false, true, true)
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var symbol interface{} = ccxt.GetValue(symbols, i)
                var market interface{} = this.Market(symbol)
                ccxt.AppendToArray(&marketIds, ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
            }
            var request interface{} = map[string]interface{} {
                "type": "ticker",
                "symbols": marketIds,
                "tickTypes": []interface{}{this.SafeString(params, "tickTypes", "24H")},
            }
            var message interface{} = this.Extend(request, params)
        
            newTicker:= (<-this.WatchMultiple(url, messageHashes, message, messageHashes))
            ccxt.PanicOnError(newTicker)
            if ccxt.IsTrue(this.NewUpdates) {
                var result interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(result, ccxt.GetValue(newTicker, "symbol"), newTicker)
        
                ch <- result
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "ticker",
    //        "content" : {
    //            "symbol" : "BTC_KRW",           // 통화코드
    //            "tickType" : "24H",                 // 변동 기준시간- 30M, 1H, 12H, 24H, MID
    //            "date" : "20200129",                // 일자
    //            "time" : "121844",                  // 시간
    //            "openPrice" : "2302",               // 시가
    //            "closePrice" : "2317",              // 종가
    //            "lowPrice" : "2272",                // 저가
    //            "highPrice" : "2344",               // 고가
    //            "value" : "2831915078.07065789",    // 누적거래금액
    //            "volume" : "1222314.51355788",  // 누적거래량
    //            "sellVolume" : "760129.34079004",   // 매도누적거래량
    //            "buyVolume" : "462185.17276784",    // 매수누적거래량
    //            "prevClosePrice" : "2326",          // 전일종가
    //            "chgRate" : "0.65",                 // 변동률
    //            "chgAmt" : "15",                    // 변동금액
    //            "volumePower" : "60.80"         // 체결강도
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var marketId interface{} = this.SafeString(content, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var ticker interface{} = this.ParseWsTicker(content)
    var messageHash interface{} = ccxt.Add("ticker:", symbol)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Tickers, symbol), messageHash)
}
func  (this *BithumbCore) ParseWsTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol" : "BTC_KRW",           // 통화코드
    //        "tickType" : "24H",                 // 변동 기준시간- 30M, 1H, 12H, 24H, MID
    //        "date" : "20200129",                // 일자
    //        "time" : "121844",                  // 시간
    //        "openPrice" : "2302",               // 시가
    //        "closePrice" : "2317",              // 종가
    //        "lowPrice" : "2272",                // 저가
    //        "highPrice" : "2344",               // 고가
    //        "value" : "2831915078.07065789",    // 누적거래금액
    //        "volume" : "1222314.51355788",  // 누적거래량
    //        "sellVolume" : "760129.34079004",   // 매도누적거래량
    //        "buyVolume" : "462185.17276784",    // 매수누적거래량
    //        "prevClosePrice" : "2326",          // 전일종가
    //        "chgRate" : "0.65",                 // 변동률
    //        "chgAmt" : "15",                    // 변동금액
    //        "volumePower" : "60.80"         // 체결강도
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var date interface{} = this.SafeString(ticker, "date", "")
    var time interface{} = this.SafeString(ticker, "time", "")
    var datetime interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Slice(date, 0, 4), "-"), ccxt.Slice(date, 4, 6)), "-"), ccxt.Slice(date, 6, 8)), "T"), ccxt.Slice(time, 0, 2)), ":"), ccxt.Slice(time, 2, 4)), ":"), ccxt.Slice(time, 4, 6))
    var marketId interface{} = this.SafeString(ticker, "symbol")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, "_"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "high": this.SafeString(ticker, "highPrice"),
        "low": this.SafeString(ticker, "lowPrice"),
        "bid": nil,
        "bidVolume": this.SafeString(ticker, "buyVolume"),
        "ask": nil,
        "askVolume": this.SafeString(ticker, "sellVolume"),
        "vwap": nil,
        "open": this.SafeString(ticker, "openPrice"),
        "close": this.SafeString(ticker, "closePrice"),
        "last": nil,
        "previousClose": this.SafeString(ticker, "prevClosePrice"),
        "change": this.SafeString(ticker, "chgAmt"),
        "percentage": this.SafeString(ticker, "chgRate"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "value"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bithumb#watchOrderBook
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func  (this *BithumbCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1868 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1868)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
            var request interface{} = map[string]interface{} {
                "type": "orderbookdepth",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
            }
        
            orderbook:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "orderbookdepth",
    //            "content" : {
    //            "list" : [
    //                {
    //                    "symbol" : "BTC_KRW",
    //                    "orderType" : "ask",        // 주문타입 – bid / ask
    //                    "price" : "10593000",       // 호가
    //                    "quantity" : "1.11223318",  // 잔량
    //                    "total" : "3"               // 건수
    //                },
    //                {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10596000", "quantity" : "0.5495", "total" : "8"},
    //                {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10598000", "quantity" : "18.2085", "total" : "10"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10532000", "quantity" : "0", "total" : "0"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10572000", "quantity" : "2.3324", "total" : "4"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10571000", "quantity" : "1.469", "total" : "3"},
    //                {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10569000", "quantity" : "0.5152", "total" : "2"}
    //            ],
    //            "datetime":1580268255864325     // 일시
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var list interface{} = this.SafeList(content, "list", []interface{}{})
    var first interface{} = this.SafeDict(list, 0, map[string]interface{} {})
    var marketId interface{} = this.SafeString(first, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
    var timestampStr interface{} = this.SafeString(content, "datetime")
    var timestamp interface{} = this.ParseToInt(ccxt.Slice(timestampStr, 0, 13))
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook()
        ccxt.AddElementToObject(ob, "symbol", symbol)
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    this.HandleDeltas(orderbook, list)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *BithumbCore) HandleDelta(orderbook interface{}, delta interface{})  {
    //
    //    {
    //        symbol: "ETH_BTC",
    //        orderType: "bid",
    //        price: "0.07349517",
    //        quantity: "0",
    //        total: "0",
    //    }
    //
    var sideId interface{} = this.SafeString(delta, "orderType")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, "bid"))), "bids", "asks")
    var bidAsk interface{} = this.ParseBidAsk(delta, "price", "quantity")
    var orderbookSide interface{} = ccxt.GetValue(orderbook, side)
    orderbookSide.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
func  (this *BithumbCore) HandleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(orderbook, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name bithumb#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B9%97%EC%8D%B8-%EA%B1%B0%EB%9E%98%EC%86%8C-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%8B%A0
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#public-trades}
 */
func  (this *BithumbCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes2788 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2788)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("trade:", symbol)
            var request interface{} = map[string]interface{} {
                "type": "transaction",
                "symbols": []interface{}{ccxt.Add(ccxt.Add(ccxt.GetValue(market, "base"), "_"), ccxt.GetValue(market, "quote"))},
            }
        
            trades:= (<-this.Watch(url, messageHash, this.Extend(request, params), messageHash))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "type" : "transaction",
    //        "content" : {
    //            "list" : [
    //                {
    //                    "symbol" : "BTC_KRW",
    //                    "buySellGb" : "1",
    //                    "contPrice" : "10579000",
    //                    "contQty" : "0.01",
    //                    "contAmt" : "105790.00",
    //                    "contDtm" : "2020-01-29 12:24:18.830039",
    //                    "updn" : "dn"
    //                }
    //            ]
    //        }
    //    }
    //
    var content interface{} = this.SafeDict(message, "content", map[string]interface{} {})
    var rawTrades interface{} = this.SafeList(content, "list", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTrades)); i++ {
        var rawTrade interface{} = ccxt.GetValue(rawTrades, i)
        var marketId interface{} = this.SafeString(rawTrade, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
        if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
            var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
            var stored interface{} = ccxt.NewArrayCache(limit)
            ccxt.AddElementToObject(this.Trades, symbol, stored)
        }
        var trades interface{} = ccxt.GetValue(this.Trades, symbol)
        var parsed interface{} = this.ParseWsTrade(rawTrade)
        trades.(ccxt.Appender).Append(parsed)
        var messageHash interface{} = ccxt.Add(ccxt.Add("trade", ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(trades, messageHash)
    }
}
func  (this *BithumbCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol" : "BTC_KRW",
    //        "buySellGb" : "1",
    //        "contPrice" : "10579000",
    //        "contQty" : "0.01",
    //        "contAmt" : "105790.00",
    //        "contDtm" : "2020-01-29 12:24:18.830038",
    //        "updn" : "dn"
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var datetime interface{} = this.SafeString(trade, "contDtm")
    // that date is not UTC iso8601, but exchange's local time, -9hr difference
    var timestamp interface{} = ccxt.Subtract(this.Parse8601(datetime), 32400000)
    var sideId interface{} = this.SafeString(trade, "buySellGb")
    return this.SafeTrade(map[string]interface{} {
        "id": nil,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeSymbol(marketId, market, "_"),
        "order": nil,
        "type": nil,
        "side": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(sideId, "1"))), "buy", "sell"),
        "takerOrMaker": nil,
        "price": this.SafeString(trade, "contPrice"),
        "amount": this.SafeString(trade, "contQty"),
        "cost": this.SafeString(trade, "contAmt"),
        "fee": nil,
    }, market)
}
func  (this *BithumbCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    {
    //        "status" : "5100",
    //        "resmsg" : "Invalid Filter Syntax"
    //    }
    //
    if !ccxt.IsTrue((ccxt.InOp(message, "status"))) {
        return true
    }
    var errorCode interface{} = this.SafeString(message, "status")
    
        {
             func(this *BithumbCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BithumbCore) interface{} {
                            // catch block:
                                    client.(ccxt.ClientInterface).Reject(e)
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(errorCode, "0000")) {
                var msg interface{} = this.SafeString(message, "resmsg")
                panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), msg)))
            }
            return true
    		    
    	    }(this)
        
            }
    return true
}
func  (this *BithumbCore) HandleMessage(client interface{}, message interface{})  {
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var topic interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(!ccxt.IsEqual(topic, nil)) {
        var methods interface{} = map[string]interface{} {
            "ticker": this.HandleTicker,
            "orderbookdepth": this.HandleOrderBook,
            "transaction": this.HandleTrades,
        }
        var method interface{} = this.SafeValue(methods, topic)
        if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
            ccxt.CallDynamically(method, client, message)
        }
    }
}


func (this *BithumbCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
