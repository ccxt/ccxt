package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitmartCore struct {
	*ccxt.BitmartCore
	base *ccxt.BitmartCore
}

func NewBitmartCore() *BitmartCore {
    p := &BitmartCore{}
	base := &ccxt.BitmartCore{}
	p.base = base
	p.BitmartCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *BitmartCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "createOrderWs": false,
            "editOrderWs": false,
            "fetchOpenOrdersWs": false,
            "fetchOrderWs": false,
            "cancelOrderWs": false,
            "cancelOrdersWs": false,
            "cancelAllOrdersWs": false,
            "ws": true,
            "watchBalance": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchBidsAsks": true,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": true,
            "watchOrders": true,
            "watchTrades": true,
            "watchTradesForSymbols": true,
            "watchOHLCV": true,
            "watchPosition": "emulated",
            "watchPositions": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": map[string]interface{} {
                    "spot": map[string]interface{} {
                        "public": "wss://ws-manager-compress.{hostname}/api?protocol=1.1",
                        "private": "wss://ws-manager-compress.{hostname}/user?protocol=1.1",
                    },
                    "swap": map[string]interface{} {
                        "public": "wss://openapi-ws-v2.{hostname}/api?protocol=1.1",
                        "private": "wss://openapi-ws-v2.{hostname}/user?protocol=1.1",
                    },
                },
            },
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "watchBalance": map[string]interface{} {
                "fetchBalanceSnapshot": true,
                "awaitBalanceSnapshot": false,
            },
            "watchOrderBook": map[string]interface{} {
                "depth": "depth/increase100",
            },
            "watchOrderBookForSymbols": map[string]interface{} {
                "depth": "depth/increase100",
            },
            "watchTrades": map[string]interface{} {
                "ignoreDuplicates": true,
            },
            "ws": map[string]interface{} {
                "inflate": true,
            },
            "timeframes": map[string]interface{} {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "45m": "45m",
                "1h": "1H",
                "2h": "2H",
                "3h": "3H",
                "4h": "4H",
                "1d": "1D",
                "1w": "1W",
                "1M": "1M",
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 15000,
        },
    })
}
func  (this *BitmartCore) Subscribe(channel interface{}, symbol interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "public"))
            var request interface{} = map[string]interface{} {}
            var messageHash interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add("spot/", channel), ":"), ccxt.GetValue(market, "id"))
                request = map[string]interface{} {
                    "op": "subscribe",
                    "args": []interface{}{messageHash},
                }
            } else {
                messageHash = ccxt.Add(ccxt.Add(ccxt.Add("futures/", channel), ":"), ccxt.GetValue(market, "id"))
                var speed interface{} = this.SafeString(params, "speed")
                if ccxt.IsTrue(!ccxt.IsEqual(speed, nil)) {
                    params = this.Omit(params, "speed")
                    messageHash = ccxt.Add(messageHash, ccxt.Add(":", speed))
                }
                request = map[string]interface{} {
                    "action": "subscribe",
                    "args": []interface{}{messageHash},
                }
            }
        
                retRes11915 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes11915)
                ch <- retRes11915
                return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) SubscribeMultiple(channel interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            symbols = this.MarketSymbols(symbols, typeVar, false, true)
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "public"))
            var channelType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))), "spot", "futures")
            var actionType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(typeVar, "spot"))), "op", "action")
            var rawSubscriptions interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                var message interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(channelType, "/"), channel), ":"), ccxt.GetValue(market, "id"))
                ccxt.AppendToArray(&rawSubscriptions, message)
                ccxt.AppendToArray(&messageHashes, ccxt.Add(ccxt.Add(channel, ":"), ccxt.GetValue(market, "symbol")))
            }
            // as an exclusion, futures "tickers" need one generic request for all symbols
            // if ((type !== 'spot') && (channel === 'ticker')) {
            //     rawSubscriptions = [ channelType + '/' + channel ]
            // }
            // ccxt.Exchange update from 2025-02-11 supports subscription by trading pair for swap
            var request interface{} = map[string]interface{} {
                "args": rawSubscriptions,
            }
            ccxt.AddElementToObject(request, actionType, "subscribe")
        
                retRes14415 :=  (<-this.WatchMultiple(url, messageHashes, this.DeepExtend(request, params), rawSubscriptions))
                ccxt.PanicOnError(retRes14415)
                ch <- retRes14415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#watchBalance
 * @see https://developer-pro.bitmart.com/en/spot/#private-balance-change
 * @see https://developer-pro.bitmart.com/en/futuresv2/#private-assets-channel
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *BitmartCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1578 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1578)
            var typeVar interface{} = "spot"
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes1608 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes1608)
            var request interface{} = map[string]interface{} {}
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                request = map[string]interface{} {
                    "op": "subscribe",
                    "args": []interface{}{"spot/user/balance:BALANCE_UPDATE"},
                }
            } else {
                request = map[string]interface{} {
                    "action": "subscribe",
                    "args": []interface{}{"futures/asset:USDT", "futures/asset:BTC", "futures/asset:ETH"},
                }
            }
            var messageHash interface{} = ccxt.Add("balance:", typeVar)
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "private"))
            var client interface{} = this.Client(url)
            this.SetBalanceCache(client, typeVar, messageHash)
            var fetchBalanceSnapshot interface{} = nil
            var awaitBalanceSnapshot interface{} = nil
            fetchBalanceSnapshotparamsVariable := this.HandleOptionAndParams(this.Options, "watchBalance", "fetchBalanceSnapshot", true)
            fetchBalanceSnapshot = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(fetchBalanceSnapshotparamsVariable,1)
            awaitBalanceSnapshotparamsVariable := this.HandleOptionAndParams(this.Options, "watchBalance", "awaitBalanceSnapshot", false)
            awaitBalanceSnapshot = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,0)
            params = ccxt.GetValue(awaitBalanceSnapshotparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(fetchBalanceSnapshot) && ccxt.IsTrue(awaitBalanceSnapshot)) {
        
                retRes18212 := (<-client.(ccxt.ClientInterface).Future(ccxt.Add(typeVar, ":fetchBalanceSnapshot")))
                ccxt.PanicOnError(retRes18212)
            }
        
                retRes18415 :=  (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
                ccxt.PanicOnError(retRes18415)
                ch <- retRes18415
                return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) SetBalanceCache(client interface{}, typeVar interface{}, subscribeHash interface{})  {
    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), subscribeHash)) {
        return
    }
    var options interface{} = this.SafeValue(this.Options, "watchBalance")
    var snapshot interface{} = this.SafeBool(options, "fetchBalanceSnapshot", true)
    if ccxt.IsTrue(snapshot) {
        var messageHash interface{} = ccxt.Add(ccxt.Add(typeVar, ":"), "fetchBalanceSnapshot")
        if !ccxt.IsTrue((ccxt.InOp(client.(ccxt.ClientInterface).GetFutures(), messageHash))) {
            client.(ccxt.ClientInterface).Future(messageHash)
            this.Spawn(this.LoadBalanceSnapshot, client, messageHash, typeVar)
        }
    }
    ccxt.AddElementToObject(this.Balance, typeVar, map[string]interface{} {})
}
func  (this *BitmartCore) LoadBalanceSnapshot(client interface{}, messageHash interface{}, typeVar interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                
            response:= (<-this.FetchBalance(map[string]interface{} {
            "type": typeVar,
        }))
            ccxt.PanicOnError(response)
            ccxt.AddElementToObject(this.Balance, typeVar, this.Extend(response, this.SafeValue(this.Balance, typeVar, map[string]interface{} {})))
            // don't remove the future from the .futures cache
            var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
            future.(*ccxt.Future).Resolve()
            client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), ccxt.Add("balance:", typeVar))
                return nil
            }()
            return ch
        }
func  (this *BitmartCore) HandleBalance(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "data":[
    //           {
    //              "balance_details":[
    //                 {
    //                    "av_bal":"0.206000000000000000000000000000",
    //                    "ccy":"LTC",
    //                    "fz_bal":"0.100000000000000000000000000000"
    //                 }
    //              ],
    //              "event_time":"1701632345416",
    //              "event_type":"TRANSACTION_COMPLETED"
    //           }
    //        ],
    //        "table":"spot/user/balance"
    //    }
    // swap
    //    {
    //        group: 'futures/asset:USDT',
    //        data: {
    //            currency: 'USDT',
    //            available_balance: '37.19688649135',
    //            position_deposit: '0.788687546',
    //            frozen_balance: '0'
    //        }
    //    }
    //
    var channel interface{} = this.SafeString2(message, "table", "group")
    var data interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(data, nil)) {
        return
    }
    var isSpot interface{} =     (ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, "spot"), 0))
    var typeVar interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), "spot", "swap")
    ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "info", message)
    if ccxt.IsTrue(isSpot) {
        if !ccxt.IsTrue(ccxt.IsArray(data)) {
            return
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var timestamp interface{} = this.SafeInteger(message, "event_time")
            ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "timestamp", timestamp)
            ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), "datetime", this.Iso8601(timestamp))
            var balanceDetails interface{} = this.SafeValue(ccxt.GetValue(data, i), "balance_details", []interface{}{})
            for ii := 0; ccxt.IsLessThan(ii, ccxt.GetArrayLength(balanceDetails)); ii++ {
                var rawBalance interface{} = ccxt.GetValue(balanceDetails, i)
                var account interface{} = this.Account()
                var currencyId interface{} = this.SafeString(rawBalance, "ccy")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                ccxt.AddElementToObject(account, "free", this.SafeString(rawBalance, "av_bal"))
                ccxt.AddElementToObject(account, "used", this.SafeString(rawBalance, "fz_bal"))
                ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
            }
        }
    } else {
        var currencyId interface{} = this.SafeString(data, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        ccxt.AddElementToObject(account, "free", this.SafeString(data, "available_balance"))
        ccxt.AddElementToObject(account, "used", this.SafeString(data, "frozen_balance"))
        ccxt.AddElementToObject(ccxt.GetValue(this.Balance, typeVar), code, account)
    }
    ccxt.AddElementToObject(this.Balance, typeVar, this.SafeBalance(ccxt.GetValue(this.Balance, typeVar)))
    var messageHash interface{} = ccxt.Add("balance:", typeVar)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Balance, typeVar), messageHash)
}
/**
 * @method
 * @name bitmart#watchTrades
 * @see https://developer-pro.bitmart.com/en/spot/#public-trade-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-trade-channel
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitmartCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
                retRes29615 :=  (<-this.WatchTradesForSymbols([]interface{}{symbol}, since, limit, params))
                ccxt.PanicOnError(retRes29615)
                ch <- retRes29615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#watchTradesForSymbols
 * @see https://developer-pro.bitmart.com/en/spot/#public-trade-channel
 * @description get the list of most recent trades for a list of symbols
 * @param {string[]} symbols unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *BitmartCore) WatchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3118 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3118)
            var marketType interface{} = nil
            symbolsmarketTypeparamsVariable := this.GetParamsForMultipleSub("watchTradesForSymbols", symbols, limit, params)
            symbols = ccxt.GetValue(symbolsmarketTypeparamsVariable,0)
            marketType = ccxt.GetValue(symbolsmarketTypeparamsVariable,1)
            params = ccxt.GetValue(symbolsmarketTypeparamsVariable,2)
            var channelName interface{} = "trade"
        
            trades:= (<-this.SubscribeMultiple(channelName, marketType, symbols, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                var first interface{} = this.SafeDict(trades, 0)
                var tradeSymbol interface{} = this.SafeString(first, "symbol")
                limit = ccxt.ToGetsLimit(trades).GetLimit(tradeSymbol, limit)
            }
            var result interface{} = this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            if ccxt.IsTrue(this.HandleOption("watchTrades", "ignoreDuplicates", true)) {
                var filtered interface{} = this.RemoveRepeatedTradesFromArray(result)
                filtered = this.SortBy(filtered, "timestamp")
        
                ch <- filtered
                return nil
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) GetParamsForMultipleSub(methodName interface{}, symbols interface{}, optionalArgs ...interface{}) interface{}  {
    limit := ccxt.GetArg(optionalArgs, 0, nil)
    _ = limit
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    symbols = this.MarketSymbols(symbols, nil, false, true)
    var length interface{} =     ccxt.GetArrayLength(symbols)
    if ccxt.IsTrue(ccxt.IsGreaterThan(length, 20)) {
        panic(ccxt.NotSupported(ccxt.Add(ccxt.Add(ccxt.Add(this.Id, " "), methodName), "() accepts a maximum of 20 symbols in one request")))
    }
    var market interface{} = this.Market(ccxt.GetValue(symbols, 0))
    var marketType interface{} = nil
    marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params)
    marketType = ccxt.GetValue(marketTypeparamsVariable,0)
    params = ccxt.GetValue(marketTypeparamsVariable,1)
    return []interface{}{symbols, marketType, params}
}
/**
 * @method
 * @name bitmart#watchTicker
 * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitmartCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3538 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3538)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.WatchTickers([]interface{}{symbol}, params))
            ccxt.PanicOnError(tickers)
        
            ch <- ccxt.GetValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#watchTickers
 * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitmartCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3708 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3708)
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchTickers", market, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
        
            ticker:= (<-this.SubscribeMultiple("ticker", marketType, symbols, params))
            ccxt.PanicOnError(ticker)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(ticker, "symbol"), ticker)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#watchBidsAsks
 * @see https://developer-pro.bitmart.com/en/spot/#public-ticker-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-ticker-channel
 * @description watches best bid & ask for symbols
 * @param {string[]} symbols unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *BitmartCore) WatchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3948 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3948)
            symbols = this.MarketSymbols(symbols, nil, false)
            var firstMarket interface{} = this.GetMarketFromSymbols(symbols)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("watchBidsAsks", firstMarket, params)
            marketType = ccxt.GetValue(marketTypeparamsVariable,0)
            params = ccxt.GetValue(marketTypeparamsVariable,1)
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), marketType), "public"))
            var channelType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marketType, "spot"))), "spot", "futures")
            var actionType interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marketType, "spot"))), "op", "action")
            var rawSubscriptions interface{} = []interface{}{}
            var messageHashes interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&rawSubscriptions, ccxt.Add(ccxt.Add(channelType, "/ticker:"), ccxt.GetValue(market, "id")))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("bidask:", ccxt.GetValue(symbols, i)))
            }
            if ccxt.IsTrue(!ccxt.IsEqual(marketType, "spot")) {
                rawSubscriptions = []interface{}{ccxt.Add(channelType, "/ticker")}
            }
            var request interface{} = map[string]interface{} {
                "args": rawSubscriptions,
            }
            ccxt.AddElementToObject(request, actionType, "subscribe")
        
            newTickers:= (<-this.WatchMultiple(url, messageHashes, request, rawSubscriptions))
            ccxt.PanicOnError(newTickers)
            if ccxt.IsTrue(this.NewUpdates) {
                var tickers interface{} = map[string]interface{} {}
                ccxt.AddElementToObject(tickers, ccxt.GetValue(newTickers, "symbol"), newTickers)
        
                ch <- tickers
                return nil
            }
        
            ch <- this.FilterByArray(this.Bidsasks, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandleBidAsk(client interface{}, message interface{})  {
    var table interface{} = this.SafeString(message, "table")
    var isSpot interface{} =     (!ccxt.IsEqual(table, nil))
    var rawTickers interface{} = []interface{}{}
    if ccxt.IsTrue(isSpot) {
        rawTickers = this.SafeList(message, "data", []interface{}{})
    } else {
        rawTickers = []interface{}{this.SafeValue(message, "data", map[string]interface{} {})}
    }
    if !ccxt.IsTrue(ccxt.GetArrayLength(rawTickers)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTickers)); i++ {
        var ticker interface{} = this.ParseWsBidAsk(ccxt.GetValue(rawTickers, i))
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Bidsasks, symbol, ticker)
        var messageHash interface{} = ccxt.Add("bidask:", symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *BitmartCore) ParseWsBidAsk(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "ms_t")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "ask": this.SafeString2(ticker, "ask_px", "ask_price"),
        "askVolume": this.SafeString2(ticker, "ask_sz", "ask_vol"),
        "bid": this.SafeString2(ticker, "bid_px", "bid_price"),
        "bidVolume": this.SafeString2(ticker, "bid_sz", "bid_vol"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitmart#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://developer-pro.bitmart.com/en/spot/#private-order-progress
 * @see https://developer-pro.bitmart.com/en/futuresv2/#private-order-channel
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *BitmartCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes4768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4768)
            var market interface{} = nil
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                symbol = this.Symbol(symbol)
                market = this.Market(symbol)
                messageHash = ccxt.Add("orders::", symbol)
            }
            var typeVar interface{} = "spot"
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrders", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
        
            retRes4868 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes4868)
            var request interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                var argsRequest interface{} = "spot/user/order:"
                if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                    argsRequest = ccxt.Add(argsRequest, ccxt.GetValue(market, "id"))
                } else {
                    argsRequest = "spot/user/orders:ALL_SYMBOLS"
                }
                request = map[string]interface{} {
                    "op": "subscribe",
                    "args": []interface{}{argsRequest},
                }
            } else {
                request = map[string]interface{} {
                    "action": "subscribe",
                    "args": []interface{}{"futures/order"},
                }
            }
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "private"))
        
            newOrders:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), messageHash))
            ccxt.PanicOnError(newOrders)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newOrders
                return nil
            }
        
            ch <- this.FilterBySymbolSinceLimit(this.Orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandleOrders(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "data":[
    //            {
    //                "symbol": "LTC_USDT",
    //                "notional": '',
    //                "side": "buy",
    //                "last_fill_time": "0",
    //                "ms_t": "1646216634000",
    //                "type": "limit",
    //                "filled_notional": "0.000000000000000000000000000000",
    //                "last_fill_price": "0",
    //                "size": "0.500000000000000000000000000000",
    //                "price": "50.000000000000000000000000000000",
    //                "last_fill_count": "0",
    //                "filled_size": "0.000000000000000000000000000000",
    //                "margin_trading": "0",
    //                "state": "8",
    //                "order_id": "24807076628",
    //                "order_type": "0"
    //              }
    //        ],
    //        "table":"spot/user/order"
    //    }
    // swap
    //    {
    //        "group":"futures/order",
    //        "data":[
    //           {
    //              "action":2,
    //              "order":{
    //                 "order_id":"2312045036986775",
    //                 "client_order_id":"",
    //                 "price":"71.61707928",
    //                 "size":"1",
    //                 "symbol":"LTCUSDT",
    //                 "state":1,
    //                 "side":4,
    //                 "type":"market",
    //                 "leverage":"1",
    //                 "open_type":"cross",
    //                 "deal_avg_price":"0",
    //                 "deal_size":"0",
    //                 "create_time":1701625324646,
    //                 "update_time":1701625324640,
    //                 "plan_order_id":"",
    //                 "last_trade":null
    //              }
    //           }
    //        ]
    //    }
    //
    var orders interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(orders, nil)) {
        return
    }
    var ordersLength interface{} =     ccxt.GetArrayLength(orders)
    var newOrders interface{} = []interface{}{}
    var symbols interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsGreaterThan(ordersLength, 0)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
            this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
        }
        var stored interface{} = this.Orders
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(orders)); i++ {
            var order interface{} = this.ParseWsOrder(ccxt.GetValue(orders, i))
            stored.(ccxt.Appender).Append(order)
            ccxt.AppendToArray(&newOrders, order)
            var symbol interface{} = ccxt.GetValue(order, "symbol")
            ccxt.AddElementToObject(symbols, symbol, true)
        }
    }
    var messageHash interface{} = "orders"
    var symbolKeys interface{} = ccxt.ObjectKeys(symbols)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbolKeys)); i++ {
        var symbol interface{} = ccxt.GetValue(symbolKeys, i)
        var symbolSpecificMessageHash interface{} = ccxt.Add(ccxt.Add(messageHash, "::"), symbol)
        client.(ccxt.ClientInterface).Resolve(newOrders, symbolSpecificMessageHash)
    }
    client.(ccxt.ClientInterface).Resolve(newOrders, messageHash)
}
func  (this *BitmartCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //    {
    //        "symbol": "LTC_USDT",
    //        "notional": '',
    //        "side": "buy",
    //        "last_fill_time": "0",
    //        "ms_t": "1646216634000",
    //        "type": "limit",
    //        "filled_notional": "0.000000000000000000000000000000",
    //        "last_fill_price": "0",
    //        "size": "0.500000000000000000000000000000",
    //        "price": "50.000000000000000000000000000000",
    //        "last_fill_count": "0",
    //        "filled_size": "0.000000000000000000000000000000",
    //        "margin_trading": "0",
    //        "state": "8",
    //        "order_id": "24807076628",
    //        "order_type": "0"
    //    }
    // swap
    //    {
    //       "action":2,
    //       "order":{
    //          "order_id":"2312045036986775",
    //          "client_order_id":"",
    //          "price":"71.61707928",
    //          "size":"1",
    //          "symbol":"LTCUSDT",
    //          "state":1,
    //          "side":4,
    //          "type":"market",
    //          "leverage":"1",
    //          "open_type":"cross",
    //          "deal_avg_price":"0",
    //          "deal_size":"0",
    //          "create_time":1701625324646,
    //          "update_time":1701625324640,
    //          "plan_order_id":"",
    //          "last_trade":null
    //       }
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var action interface{} = this.SafeNumber(order, "action")
    var isSpot interface{} =     (ccxt.IsEqual(action, nil))
    if ccxt.IsTrue(isSpot) {
        var marketId interface{} = this.SafeString(order, "symbol")
        market = this.SafeMarket(marketId, market, "_", "spot")
        var id interface{} = this.SafeString(order, "order_id")
        var clientOrderId interface{} = this.SafeString(order, "clientOid")
        var price interface{} = this.SafeString(order, "price")
        var filled interface{} = this.SafeString(order, "filled_size")
        var amount interface{} = this.SafeString(order, "size")
        var typeVar interface{} = this.SafeString(order, "type")
        var rawState interface{} = this.SafeString(order, "state")
        var status interface{} = this.ParseOrderStatusByType(ccxt.GetValue(market, "type"), rawState)
        var timestamp interface{} = this.SafeInteger(order, "ms_t")
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var side interface{} = this.SafeStringLower(order, "side")
        return this.SafeOrder(map[string]interface{} {
            "info": order,
            "symbol": symbol,
            "id": id,
            "clientOrderId": clientOrderId,
            "timestamp": nil,
            "datetime": nil,
            "lastTradeTimestamp": timestamp,
            "type": typeVar,
            "timeInForce": nil,
            "postOnly": nil,
            "side": side,
            "price": price,
            "stopPrice": nil,
            "triggerPrice": nil,
            "amount": amount,
            "cost": nil,
            "average": nil,
            "filled": filled,
            "remaining": nil,
            "status": status,
            "fee": nil,
            "trades": nil,
        }, market)
    } else {
        var orderInfo interface{} = this.SafeValue(order, "order")
        var marketId interface{} = this.SafeString(orderInfo, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId, market, "", "swap")
        var orderId interface{} = this.SafeString(orderInfo, "order_id")
        var timestamp interface{} = this.SafeInteger(orderInfo, "create_time")
        var updatedTimestamp interface{} = this.SafeInteger(orderInfo, "update_time")
        var lastTrade interface{} = this.SafeValue(orderInfo, "last_trade")
        var cachedOrders interface{} = this.Orders
        var orders interface{} = this.SafeValue(cachedOrders.(*ccxt.ArrayCache).Hashmap, symbol, map[string]interface{} {})
        var cachedOrder interface{} = this.SafeValue(orders, orderId)
        var trades interface{} = nil
        if ccxt.IsTrue(!ccxt.IsEqual(cachedOrder, nil)) {
            trades = this.SafeValue(order, "trades")
        }
        if ccxt.IsTrue(!ccxt.IsEqual(lastTrade, nil)) {
            if ccxt.IsTrue(ccxt.IsEqual(trades, nil)) {
                trades = []interface{}{}
            }
            ccxt.AppendToArray(&trades, lastTrade)
        }
        return this.SafeOrder(map[string]interface{} {
            "info": order,
            "symbol": symbol,
            "id": orderId,
            "clientOrderId": this.SafeString(orderInfo, "client_order_id"),
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
            "lastTradeTimestamp": updatedTimestamp,
            "type": this.SafeString(orderInfo, "type"),
            "timeInForce": nil,
            "postOnly": nil,
            "side": this.ParseWsOrderSide(this.SafeString(orderInfo, "side")),
            "price": this.SafeString(orderInfo, "price"),
            "stopPrice": nil,
            "triggerPrice": nil,
            "amount": this.SafeString(orderInfo, "size"),
            "cost": nil,
            "average": this.SafeString(orderInfo, "deal_avg_price"),
            "filled": this.SafeString(orderInfo, "deal_size"),
            "remaining": nil,
            "status": this.ParseWsOrderStatus(this.SafeString(order, "action")),
            "fee": nil,
            "trades": trades,
        }, market)
    }
}
func  (this *BitmartCore) ParseWsOrderStatus(statusId interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "closed",
        "2": "open",
        "3": "canceled",
        "4": "closed",
        "5": "canceled",
        "6": "open",
        "7": "open",
        "8": "closed",
        "9": "closed",
    }
    return this.SafeString(statuses, statusId, statusId)
}
func  (this *BitmartCore) ParseWsOrderSide(sideId interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "1": "buy",
        "2": "buy",
        "3": "sell",
        "4": "sell",
    }
    return this.SafeString(sides, sideId, sideId)
}
/**
 * @method
 * @name bitmart#watchPositions
 * @see https://developer-pro.bitmart.com/en/futures/#private-position-channel
 * @description watch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *BitmartCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7678 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7678)
            var typeVar interface{} = "swap"
        
            retRes7698 := (<-this.Authenticate(typeVar, params))
            ccxt.PanicOnError(retRes7698)
            symbols = this.MarketSymbols(symbols, "swap", true, true, false)
            var messageHash interface{} = "positions"
            if ccxt.IsTrue(!ccxt.IsEqual(symbols, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            var subscriptionHash interface{} = "futures/position"
            var request interface{} = map[string]interface{} {
                "action": "subscribe",
                "args": []interface{}{"futures/position"},
            }
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "private"))
        
            newPositions:= (<-this.Watch(url, messageHash, this.DeepExtend(request, params), subscriptionHash))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandlePositions(client interface{}, message interface{})  {
    //
    //    {
    //        "group":"futures/position",
    //        "data":[
    //           {
    //              "symbol":"LTCUSDT",
    //              "hold_volume":"5",
    //              "position_type":2,
    //              "open_type":2,
    //              "frozen_volume":"0",
    //              "close_volume":"0",
    //              "hold_avg_price":"71.582",
    //              "close_avg_price":"0",
    //              "open_avg_price":"71.582",
    //              "liquidate_price":"0",
    //              "create_time":1701623327513,
    //              "update_time":1701627620439
    //           },
    //           {
    //              "symbol":"LTCUSDT",
    //              "hold_volume":"6",
    //              "position_type":1,
    //              "open_type":2,
    //              "frozen_volume":"0",
    //              "close_volume":"0",
    //              "hold_avg_price":"71.681666666666666667",
    //              "close_avg_price":"0",
    //              "open_avg_price":"71.681666666666666667",
    //              "liquidate_price":"0",
    //              "create_time":1701621167225,
    //              "update_time":1701628152614
    //           }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data", []interface{}{})
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = ccxt.NewArrayCacheBySymbolBySide()
    }
    var cache interface{} = this.Positions
    var newPositions interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
        var rawPosition interface{} = ccxt.GetValue(data, i)
        var position interface{} = this.ParseWsPosition(rawPosition)
        ccxt.AppendToArray(&newPositions, position)
        cache.(ccxt.Appender).Append(position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
}
func  (this *BitmartCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //       "symbol":"LTCUSDT",
    //       "hold_volume":"6",
    //       "position_type":1,
    //       "open_type":2,
    //       "frozen_volume":"0",
    //       "close_volume":"0",
    //       "hold_avg_price":"71.681666666666666667",
    //       "close_avg_price":"0",
    //       "open_avg_price":"71.681666666666666667",
    //       "liquidate_price":"0",
    //       "create_time":1701621167225,
    //       "update_time":1701628152614
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market, nil, "swap")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var openTimestamp interface{} = this.SafeInteger(position, "create_time")
    var timestamp interface{} = this.SafeInteger(position, "update_time")
    var side interface{} = this.SafeInteger(position, "position_type")
    var marginModeId interface{} = this.SafeInteger(position, "open_type")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "timestamp": openTimestamp,
        "datetime": this.Iso8601(openTimestamp),
        "lastUpdateTimestamp": timestamp,
        "hedged": nil,
        "side": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, 1))), "long", "short"),
        "contracts": this.SafeNumber(position, "hold_volume"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "entryPrice": this.SafeNumber(position, "open_avg_price"),
        "markPrice": this.SafeNumber(position, "hold_avg_price"),
        "lastPrice": nil,
        "notional": nil,
        "leverage": nil,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "unrealizedPnl": nil,
        "realizedPnl": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidate_price"),
        "marginMode": ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(marginModeId, 1))), "isolated", "cross"),
        "percentage": nil,
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
func  (this *BitmartCore) HandleTrade(client interface{}, message interface{})  {
    //
    // spot
    //    {
    //        "table": "spot/trade",
    //        "data": [
    //            {
    //                "price": "52700.50",
    //                "s_t": 1630982050,
    //                "side": "buy",
    //                "size": "0.00112",
    //                "symbol": "BTC_USDT"
    //            },
    //        ]
    //    }
    //
    // swap
    //    {
    //        "group":"futures/trade:BTCUSDT",
    //        "data":[
    //           {
    //              "trade_id":6798697637,
    //              "symbol":"BTCUSDT",
    //              "deal_price":"39735.8",
    //              "deal_vol":"2",
    //              "way":1,
    //              "created_at":"2023-12-03T15:48:23.517518538Z",
    //              "m": true,
    //           }
    //        ]
    //    }
    //
    var data interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(data, nil)) {
        return
    }
    var symbol interface{} = nil
    var length interface{} =     ccxt.GetArrayLength(data)
    var isSwap interface{} =     (ccxt.InOp(message, "group"))
    if ccxt.IsTrue(isSwap) {
        // in swap, chronologically decreasing: 1709536849322, 1709536848954,
        for i := 0; ccxt.IsLessThan(i, length); i++ {
            var index interface{} = ccxt.Subtract(ccxt.Subtract(length, i), 1)
            symbol = this.HandleTradeLoop(ccxt.GetValue(data, index))
        }
    } else {
        // in spot, chronologically increasing: 1709536771200, 1709536771226,
        for i := 0; ccxt.IsLessThan(i, length); i++ {
            symbol = this.HandleTradeLoop(ccxt.GetValue(data, i))
        }
    }
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Trades, symbol), ccxt.Add("trade:", symbol))
}
func  (this *BitmartCore) HandleTradeLoop(entry interface{}) interface{}  {
    var trade interface{} = this.ParseWsTrade(entry)
    var symbol interface{} = ccxt.GetValue(trade, "symbol")
    var tradesLimit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
    if ccxt.IsTrue(ccxt.IsEqual(this.SafeValue(this.Trades, symbol), nil)) {
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(tradesLimit))
    }
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    stored.(ccxt.Appender).Append(trade)
    return symbol
}
func  (this *BitmartCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         "ms_t": 1740320841473,
    //         "price": "2806.54",
    //         "s_t": 1740320841,
    //         "side": "sell",
    //         "size": "0.77598",
    //         "symbol": "ETH_USDT"
    //     }
    //
    // swap
    //     {
    //         "trade_id": "3000000245258661",
    //         "symbol": "ETHUSDT",
    //         "deal_price": "2811.1",
    //         "deal_vol": "1858",
    //         "way": 2,
    //         "m": true,
    //         "created_at": "2025-02-23T13:59:59.646490751Z"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "ms_t")
    var datetime interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(timestamp, nil)) {
        datetime = this.SafeString(trade, "created_at")
        timestamp = this.Parse8601(datetime)
    } else {
        datetime = this.Iso8601(timestamp)
    }
    var takerOrMaker interface{} = nil // true for public trades
    var side interface{} = this.SafeString(trade, "side")
    var buyerMaker interface{} = this.SafeBool(trade, "m")
    if ccxt.IsTrue(!ccxt.IsEqual(buyerMaker, nil)) {
        if ccxt.IsTrue(ccxt.IsEqual(side, nil)) {
            if ccxt.IsTrue(buyerMaker) {
                side = "sell"
            } else {
                side = "buy"
            }
        }
        takerOrMaker = "taker"
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "trade_id"),
        "order": nil,
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": ccxt.GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "price": this.SafeString2(trade, "price", "deal_price"),
        "amount": this.SafeString2(trade, "size", "deal_vol"),
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": nil,
    }, market)
}
func  (this *BitmartCore) HandleTicker(client interface{}, message interface{})  {
    //
    //    {
    //        "data": [
    //            {
    //                "base_volume_24h": "78615593.81",
    //                "high_24h": "52756.97",
    //                "last_price": "52638.31",
    //                "low_24h": "50991.35",
    //                "open_24h": "51692.03",
    //                "s_t": 1630981727,
    //                "symbol": "BTC_USDT"
    //            }
    //        ],
    //        "table": "spot/ticker"
    //    }
    //
    //     {
    //         "data": {
    //             "symbol": "ETHUSDT",
    //             "last_price": "2807.73",
    //             "volume_24": "2227011952",
    //             "range": "0.0273398194664491",
    //             "mark_price": "2807.5",
    //             "index_price": "2808.71047619",
    //             "ask_price": "2808.04",
    //             "ask_vol": "7371",
    //             "bid_price": "2807.28",
    //             "bid_vol": "3561"
    //         },
    //         "group": "futures/ticker:ETHUSDT@100ms"
    //     }
    //
    this.HandleBidAsk(client, message)
    var table interface{} = this.SafeString(message, "table")
    var isSpot interface{} =     (!ccxt.IsEqual(table, nil))
    var rawTickers interface{} = []interface{}{}
    if ccxt.IsTrue(isSpot) {
        rawTickers = this.SafeList(message, "data", []interface{}{})
    } else {
        rawTickers = []interface{}{this.SafeValue(message, "data", map[string]interface{} {})}
    }
    if !ccxt.IsTrue(ccxt.GetArrayLength(rawTickers)) {
        return
    }
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(rawTickers)); i++ {
        var ticker interface{} = ccxt.Ternary(ccxt.IsTrue(isSpot), this.ParseTicker(ccxt.GetValue(rawTickers, i)), this.ParseWsSwapTicker(ccxt.GetValue(rawTickers, i)))
        var symbol interface{} = ccxt.GetValue(ticker, "symbol")
        ccxt.AddElementToObject(this.Tickers, symbol, ticker)
        var messageHash interface{} = ccxt.Add("ticker:", symbol)
        client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    }
}
func  (this *BitmartCore) ParseWsSwapTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ETHUSDT",
    //         "last_price": "2807.73",
    //         "volume_24": "2227011952",
    //         "range": "0.0273398194664491",
    //         "mark_price": "2807.5",
    //         "index_price": "2808.71047619",
    //         "ask_price": "2808.04",
    //         "ask_vol": "7371",
    //         "bid_price": "2807.28",
    //         "bid_vol": "3561"
    //     }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market, "", "swap"),
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "bid_price"),
        "bidVolume": this.SafeString(ticker, "bid_vol"),
        "ask": this.SafeString(ticker, "ask_price"),
        "askVolume": this.SafeString(ticker, "ask_vol"),
        "vwap": nil,
        "open": nil,
        "close": nil,
        "last": this.SafeString(ticker, "last_price"),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeString(ticker, "volume_24"),
        "info": ticker,
        "markPrice": this.SafeString(ticker, "mark_price"),
        "indexPrice": this.SafeString(ticker, "index_price"),
    }, market)
}
/**
 * @method
 * @name bitmart#watchOHLCV
 * @see https://developer-pro.bitmart.com/en/spot/#public-kline-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-klinebin-channel
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BitmartCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11458 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes11458)
            symbol = this.Symbol(symbol)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = "spot"
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrderBook", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeString(timeframes, timeframe)
            var name interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                name = ccxt.Add("kline", interval)
            } else {
                name = ccxt.Add("klineBin", interval)
            }
        
            ohlcv:= (<-this.Subscribe(name, symbol, typeVar, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandleOHLCV(client interface{}, message interface{})  {
    //
    //    {
    //        "data": [
    //            {
    //                "candle": [
    //                    1631056350,
    //                    "46532.83",
    //                    "46555.71",
    //                    "46511.41",
    //                    "46555.71",
    //                    "0.25"
    //                ],
    //                "symbol": "BTC_USDT"
    //            }
    //        ],
    //        "table": "spot/kline1m"
    //    }
    // swap
    //    {
    //        "group":"futures/klineBin1m:BTCUSDT",
    //        "data":{
    //           "symbol":"BTCUSDT",
    //           "items":[
    //              {
    //                 "o":"39635.8",
    //                 "h":"39636",
    //                 "l":"39614.4",
    //                 "c":"39629.7",
    //                 "v":"31852",
    //                 "ts":1701617761
    //              }
    //           ]
    //        }
    //    }
    //
    var channel interface{} = this.SafeString2(message, "table", "group")
    var isSpot interface{} =     (ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, "spot"), 0))
    var data interface{} = this.SafeValue(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(data, nil)) {
        return
    }
    var parts interface{} = ccxt.Split(channel, "/")
    var part1 interface{} = this.SafeString(parts, 1, "")
    var interval interface{} = ccxt.Replace(part1, "kline", "")
    interval = ccxt.Replace(interval, "Bin", "")
    var intervalParts interface{} = ccxt.Split(interval, ":")
    interval = this.SafeString(intervalParts, 0)
    // use a reverse lookup in a static map instead
    var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
    var timeframe interface{} = this.FindTimeframe(interval, timeframes)
    var duration interface{} = this.ParseTimeframe(timeframe)
    var durationInMs interface{} = ccxt.Multiply(duration, 1000)
    if ccxt.IsTrue(isSpot) {
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var marketId interface{} = this.SafeString(ccxt.GetValue(data, i), "symbol")
            var market interface{} = this.SafeMarket(marketId)
            var symbol interface{} = ccxt.GetValue(market, "symbol")
            var rawOHLCV interface{} = this.SafeValue(ccxt.GetValue(data, i), "candle")
            var parsed interface{} = this.ParseOHLCV(rawOHLCV, market)
            ccxt.AddElementToObject(parsed, 0, ccxt.Multiply(this.ParseToInt(ccxt.Divide(ccxt.GetValue(parsed, 0), durationInMs)), durationInMs))
            ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
            var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
            if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
                var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
                stored = ccxt.NewArrayCacheByTimestamp(limit)
                ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
            }
            stored.(ccxt.Appender).Append(parsed)
            var messageHash interface{} = ccxt.Add(ccxt.Add(channel, ":"), marketId)
            client.(ccxt.ClientInterface).Resolve(stored, messageHash)
        }
    } else {
        var marketId interface{} = this.SafeString(data, "symbol")
        var market interface{} = this.SafeMarket(marketId, nil, nil, "swap")
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var items interface{} = this.SafeValue(data, "items", []interface{}{})
        ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
        var stored interface{} = this.SafeValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
        if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored = ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, stored)
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(items)); i++ {
            var candle interface{} = ccxt.GetValue(items, i)
            var parsed interface{} = this.ParseOHLCV(candle, market)
            stored.(ccxt.Appender).Append(parsed)
        }
        client.(ccxt.ClientInterface).Resolve(stored, channel)
    }
}
/**
 * @method
 * @name bitmart#watchOrderBook
 * @see https://developer-pro.bitmart.com/en/spot/#public-depth-all-channel
 * @see https://developer-pro.bitmart.com/en/spot/#public-depth-increase-channel
 * @see https://developer-pro.bitmart.com/en/futuresv2/#public-depth-channel
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.speed] *futures only* '100ms' or '200ms'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitmartCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12728 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes12728)
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var depth interface{} = this.SafeString(options, "depth", "depth/increase100")
            symbol = this.Symbol(symbol)
            var market interface{} = this.Market(symbol)
            var typeVar interface{} = "spot"
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchOrderBook", market, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) && ccxt.IsTrue(ccxt.IsEqual(depth, "depth/increase100"))) {
                depth = "depth50"
            }
        
            orderbook:= (<-this.Subscribe(depth, symbol, typeVar, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *BitmartCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
func  (this *BitmartCore) HandleOrderBookMessage(client interface{}, message interface{}, orderbook interface{}) interface{}  {
    //
    //     {
    //         "asks": [
    //             [ '46828.38', "0.21847" ],
    //             [ '46830.68', "0.08232" ],
    //             [ '46832.08', "0.09285" ],
    //             [ '46837.82', "0.02028" ],
    //             [ '46839.43', "0.15068" ]
    //         ],
    //         "bids": [
    //             [ '46820.78', "0.00444" ],
    //             [ '46814.33', "0.00234" ],
    //             [ '46813.50', "0.05021" ],
    //             [ '46808.14', "0.00217" ],
    //             [ '46808.04', "0.00013" ]
    //         ],
    //         "ms_t": 1631044962431,
    //         "symbol": "BTC_USDT"
    //     }
    //
    var asks interface{} = this.SafeList(message, "asks", []interface{}{})
    var bids interface{} = this.SafeList(message, "bids", []interface{}{})
    this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
    this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
    var timestamp interface{} = this.SafeInteger(message, "ms_t")
    var marketId interface{} = this.SafeString(message, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    ccxt.AddElementToObject(orderbook, "symbol", symbol)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    return orderbook
}
func  (this *BitmartCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // spot depth-all
    //
    //    {
    //        "data": [
    //            {
    //                "asks": [
    //                    [ '46828.38', "0.21847" ],
    //                    [ '46830.68', "0.08232" ],
    //                    ...
    //                ],
    //                "bids": [
    //                    [ '46820.78', "0.00444" ],
    //                    [ '46814.33', "0.00234" ],
    //                    ...
    //                ],
    //                "ms_t": 1631044962431,
    //                "symbol": "BTC_USDT"
    //            }
    //        ],
    //        "table": "spot/depth5"
    //    }
    //
    // spot increse depth snapshot
    //
    //    {
    //        "data":[
    //           {
    //               "asks":[
    //                   [ "43652.52", "0.02039" ],
    //                   ...
    //                ],
    //                "bids":[
    //                   [ "43652.51", "0.00500" ],
    //                   ...
    //                ],
    //                "ms_t":1703376836487,
    //                "symbol":"BTC_USDT",
    //                "type":"snapshot", // or update
    //                "version":2141731
    //           }
    //        ],
    //        "table":"spot/depth/increase100"
    //    }
    //
    // swap
    //
    //    {
    //        "group":"futures/depth50:BTCUSDT",
    //        "data":{
    //           "symbol":"BTCUSDT",
    //           "way":1,
    //           "depths":[
    //              {
    //                 "price":"39509.8",
    //                 "vol":"2379"
    //              },
    //              {
    //                 "price":"39509.6",
    //                 "vol":"6815"
    //              },
    //              ...
    //           ],
    //           "ms_t":1701566021194
    //        }
    //    }
    //
    var isSpot interface{} =     (ccxt.InOp(message, "table"))
    var datas interface{} = []interface{}{}
    if ccxt.IsTrue(isSpot) {
        datas = this.SafeList(message, "data", datas)
    } else {
        var orderBookEntry interface{} = this.SafeDict(message, "data")
        if ccxt.IsTrue(!ccxt.IsEqual(orderBookEntry, nil)) {
            ccxt.AppendToArray(&datas, orderBookEntry)
        }
    }
    var length interface{} =     ccxt.GetArrayLength(datas)
    if ccxt.IsTrue(ccxt.IsLessThanOrEqual(length, 0)) {
        return
    }
    var channelName interface{} = this.SafeString2(message, "table", "group")
    // find limit subscribed to
    var limitsToCheck interface{} = []interface{}{"100", "50", "20", "10", "5"}
    var limit interface{} = 0
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(limitsToCheck)); i++ {
        var limitString interface{} = ccxt.GetValue(limitsToCheck, i)
        if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channelName, limitString), 0)) {
            limit = this.ParseToInt(limitString)
            break
        }
    }
    if ccxt.IsTrue(isSpot) {
        var channel interface{} = ccxt.Replace(channelName, "spot/", "")
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(datas)); i++ {
            var update interface{} = ccxt.GetValue(datas, i)
            var marketId interface{} = this.SafeString(update, "symbol")
            var symbol interface{} = this.SafeSymbol(marketId)
            if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
                var ob interface{} = this.OrderBook(map[string]interface{} {}, limit)
                ccxt.AddElementToObject(ob, "symbol", symbol)
                ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
            }
            var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
            var typeVar interface{} = this.SafeString(update, "type")
            if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(typeVar, "snapshot"))) || ccxt.IsTrue((!ccxt.IsTrue((ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channelName, "increase"), 0)))))) {
                orderbook.(ccxt.OrderBookInterface).Reset(map[string]interface{} {})
            }
            this.HandleOrderBookMessage(client, update, orderbook)
            var timestamp interface{} = this.SafeInteger(update, "ms_t")
            if ccxt.IsTrue(ccxt.IsEqual(ccxt.GetValue(orderbook, "timestamp"), nil)) {
                ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
                ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(channelName, ":"), marketId)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
            // resolve ForSymbols
            var messageHashForMulti interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
            client.(ccxt.ClientInterface).Resolve(orderbook, messageHashForMulti)
        }
    } else {
        var tableParts interface{} = ccxt.Split(channelName, ":")
        var channel interface{} = ccxt.Replace(ccxt.GetValue(tableParts, 0), "futures/", "")
        var data interface{} = ccxt.GetValue(datas, 0) // contract markets always contain only one member
        var depths interface{} = ccxt.GetValue(data, "depths")
        var marketId interface{} = this.SafeString(data, "symbol")
        var symbol interface{} = this.SafeSymbol(marketId)
        if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
            var ob interface{} = this.OrderBook(map[string]interface{} {}, limit)
            ccxt.AddElementToObject(ob, "symbol", symbol)
            ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
        }
        var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
        var way interface{} = this.SafeInteger(data, "way")
        var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(way, 1))), "bids", "asks")
        if ccxt.IsTrue(ccxt.IsEqual(way, 1)) {
            ccxt.AddElementToObject(orderbook, side, ccxt.NewBids([]interface{}{}, limit))
        } else {
            ccxt.AddElementToObject(orderbook, side, ccxt.NewAsks([]interface{}{}, limit))
        }
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(depths)); i++ {
            var depth interface{} = ccxt.GetValue(depths, i)
            var price interface{} = this.SafeNumber(depth, "price")
            var amount interface{} = this.SafeNumber(depth, "vol")
            var orderbookSide interface{} = this.SafeValue(orderbook, side)
            orderbookSide.(ccxt.IOrderBookSide).Store(price, amount)
        }
        var bidsLength interface{} =         ccxt.GetArrayLength(ccxt.GetValue(orderbook, "bids"))
        var asksLength interface{} =         ccxt.GetArrayLength(ccxt.GetValue(orderbook, "asks"))
        if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(bidsLength, 0))) || ccxt.IsTrue((ccxt.IsEqual(asksLength, 0)))) {
            return
        }
        var timestamp interface{} = this.SafeInteger(data, "ms_t")
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
        var messageHash interface{} = channelName
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
        // resolve ForSymbols
        var messageHashForMulti interface{} = ccxt.Add(ccxt.Add(channel, ":"), symbol)
        client.(ccxt.ClientInterface).Resolve(orderbook, messageHashForMulti)
    }
}
/**
 * @method
 * @name bitmart#watchOrderBookForSymbols
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developer-pro.bitmart.com/en/spot/#public-depth-increase-channel
 * @param {string[]} symbols unified array of symbols
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.depth] the type of order book to subscribe to, default is 'depth/increase100', also accepts 'depth5' or 'depth20' or depth50
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *BitmartCore) WatchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15088 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes15088)
            var typeVar interface{} = nil
            symbolstypeVarparamsVariable := this.GetParamsForMultipleSub("watchOrderBookForSymbols", symbols, limit, params)
            symbols = ccxt.GetValue(symbolstypeVarparamsVariable,0)
            typeVar = ccxt.GetValue(symbolstypeVarparamsVariable,1)
            params = ccxt.GetValue(symbolstypeVarparamsVariable,2)
            var channel interface{} = nil
            channelparamsVariable := this.HandleOptionAndParams(params, "watchOrderBookForSymbols", "depth", "depth/increase100")
            channel = ccxt.GetValue(channelparamsVariable,0)
            params = ccxt.GetValue(channelparamsVariable,1)
            if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsEqual(typeVar, "swap")) && ccxt.IsTrue(ccxt.IsEqual(channel, "depth/increase100"))) {
                channel = "depth50"
            }
        
            orderbook:= (<-this.SubscribeMultiple(channel, typeVar, symbols, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) Authenticate(typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = this.ImplodeHostname(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), typeVar), "private"))
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture(messageHash)
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var timestamp interface{} = ccxt.ToString(this.Milliseconds())
                var memo interface{} = this.Uid
                var path interface{} = "bitmart.WebSocket"
                var auth interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(timestamp, "#"), memo), "#"), path)
                var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), ccxt.Sha256)
                var request interface{} = nil
                if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                    request = map[string]interface{} {
                        "op": "login",
                        "args": []interface{}{this.ApiKey, timestamp, signature},
                    }
                } else {
                    request = map[string]interface{} {
                        "action": "access",
                        "args": []interface{}{this.ApiKey, timestamp, signature, "web"},
                    }
                }
                var message interface{} = this.Extend(request, params)
                this.Watch(url, messageHash, message, messageHash)
            }
        
                retRes155715 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes155715)
                ch <- retRes155715
                return nil
        
            }()
            return ch
        }
func  (this *BitmartCore) HandleSubscriptionStatus(client interface{}, message interface{}) interface{}  {
    //
    //    {"event":"subscribe","channel":"spot/depth:BTC-USDT"}
    //
    return message
}
func  (this *BitmartCore) HandleAuthenticate(client interface{}, message interface{})  {
    //
    // spot
    //    { event: "login" }
    // swap
    //    { action: 'access', success: true }
    //
    var messageHash interface{} = "authenticated"
    var future interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetFutures(), messageHash)
    future.(*ccxt.Future).Resolve(true)
}
func  (this *BitmartCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //    { event: "error", message: "Invalid sign", errorCode: 30013 }
    //    {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
    //    {
    //        action: '',
    //        group: 'futures/trade:BTCUSDT',
    //        success: false,
    //        request: { action: '', args: [ 'futures/trade:BTCUSDT' ] },
    //        error: 'Invalid action [] for group [futures/trade:BTCUSDT]'
    //    }
    //
    var errorCode interface{} = this.SafeString(message, "errorCode")
    var error interface{} = this.SafeString(message, "error")
    
        {
            ret__ := func(this *BitmartCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *BitmartCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue((ccxt.IsInstance(e, ccxt.AuthenticationError))) {
                var messageHash interface{} = "authenticated"
                client.(ccxt.ClientInterface).Reject(e, messageHash)
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                }
            }
            client.(ccxt.ClientInterface).Reject(e)
            return true
                            
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(errorCode, nil)) || ccxt.IsTrue(!ccxt.IsEqual(error, nil))) {
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
                var messageString interface{} = this.SafeValue(message, "message", error)
                this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), messageString, feedback)
                var action interface{} = this.SafeString(message, "action")
                if ccxt.IsTrue(ccxt.IsEqual(action, "access")) {
                    panic(ccxt.AuthenticationError(feedback))
                }
                panic(ccxt.ExchangeError(feedback))
            }
            return false
    		    
    	    }(this)
        
                if ret__ != nil {
                    return ret__
                }
                return nil
            }
}
func  (this *BitmartCore) HandleMessage(client interface{}, message interface{})  {
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    //
    //     {"event":"error","message":"Unrecognized request: {\"event\":\"subscribe\",\"channel\":\"spot/depth:BTC-USDT\"}","errorCode":30039}
    //
    // subscribe events on spot:
    //
    //     {"event":"subscribe", "topic":"spot/kline1m:BTC_USDT" }
    //
    // subscribe on contracts:
    //
    //     {"action":"subscribe", "group":"futures/klineBin1m:BTCUSDT", "success":true, "request":{"action":"subscribe", "args":[ "futures/klineBin1m:BTCUSDT" ] } }
    //
    // regular updates - spot
    //
    //     {
    //         "table": "spot/depth",
    //         "action": "partial",
    //         "data": [
    //             {
    //                 "instrument_id":   "BTC-USDT",
    //                 "asks": [
    //                     ["5301.8", "0.03763319", "1"],
    //                     ["5302.4", "0.00305", "2"],
    //                 ],
    //                 "bids": [
    //                     ["5301.7", "0.58911427", "6"],
    //                     ["5301.6", "0.01222922", "4"],
    //                 ],
    //                 "timestamp": "2020-03-16T03:25:00.440Z",
    //                 "checksum": -2088736623
    //             }
    //         ]
    //     }
    //
    // regular updates - contracts
    //
    //     {
    //         group: "futures/klineBin1m:BTCUSDT",
    //         data: {
    //           symbol: "BTCUSDT",
    //           items: [ { o: "67944.7", "h": .... } ],
    //         },
    //       }
    //
    //     { data: '', table: "spot/user/order" }
    //
    // the only realiable way (for both spot & swap) is to check 'data' key
    var isDataUpdate interface{} =     (ccxt.InOp(message, "data"))
    if !ccxt.IsTrue(isDataUpdate) {
        var event interface{} = this.SafeString2(message, "event", "action")
        if ccxt.IsTrue(!ccxt.IsEqual(event, nil)) {
            var methods interface{} = map[string]interface{} {
                "login": this.HandleAuthenticate,
                "access": this.HandleAuthenticate,
                "subscribe": this.HandleSubscriptionStatus,
            }
            var method interface{} = this.SafeValue(methods, event)
            if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                ccxt.CallDynamically(method, client, message)
            }
        }
    } else {
        var channel interface{} = this.SafeString2(message, "table", "group")
        var methods interface{} = map[string]interface{} {
            "depth": this.HandleOrderBook,
            "ticker": this.HandleTicker,
            "trade": this.HandleTrade,
            "kline": this.HandleOHLCV,
            "order": this.HandleOrders,
            "position": this.HandlePositions,
            "balance": this.HandleBalance,
            "asset": this.HandleBalance,
        }
        var keys interface{} = ccxt.ObjectKeys(methods)
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(keys)); i++ {
            var key interface{} = ccxt.GetValue(keys, i)
            if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(channel, key), 0)) {
                var method interface{} = this.SafeValue(methods, key)
                ccxt.CallDynamically(method, client, message)
            }
        }
    }
}


func (this *BitmartCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
