package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type WhitebitCore struct {
	*ccxt.WhitebitCore
	base *ccxt.WhitebitCore
}

func NewWhitebitCore() *WhitebitCore {
    p := &WhitebitCore{}
	base := &ccxt.WhitebitCore{}
	p.base = base
	p.WhitebitCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *WhitebitCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchBalance": true,
            "watchMyTrades": true,
            "watchOHLCV": true,
            "watchOrderBook": true,
            "watchOrders": true,
            "watchTicker": true,
            "watchTickers": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://api.whitebit.com/ws",
            },
        },
        "options": map[string]interface{} {
            "timeframes": map[string]interface{} {
                "1m": "60",
                "5m": "300",
                "15m": "900",
                "30m": "1800",
                "1h": "3600",
                "4h": "14400",
                "8h": "28800",
                "1d": "86400",
                "1w": "604800",
            },
            "watchOrderBook": map[string]interface{} {
                "priceInterval": 0,
            },
        },
        "streaming": map[string]interface{} {
            "ping": this.Ping,
        },
        "exceptions": map[string]interface{} {
            "ws": map[string]interface{} {
                "exact": map[string]interface{} {
                    "1": ccxt.BadRequest,
                    "2": ccxt.BadRequest,
                    "4": ccxt.BadRequest,
                    "6": ccxt.AuthenticationError,
                },
            },
        },
    })
}
/**
 * @method
 * @name whitebit#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.whitebit.com/public/websocket/#kline
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *WhitebitCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes778 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes778)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var timeframes interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var interval interface{} = this.SafeInteger(timeframes, timeframe)
            var marketId interface{} = ccxt.GetValue(market, "id")
            // currently there is no way of knowing
            // the interval upon getting an update
            // so that can't be part of the message hash, and the user can only subscribe
            // to one timeframe per symbol
            var messageHash interface{} = ccxt.Add("candles:", symbol)
            var reqParams interface{} = []interface{}{marketId, interval}
            var method interface{} = "candles_subscribe"
        
            ohlcv:= (<-this.WatchPublic(messageHash, method, reqParams, params))
            ccxt.PanicOnError(ohlcv)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    // {
    //     "method": "candles_update",
    //     "params": [
    //       [
    //         1655204760,
    //         "22374.15",
    //         "22351.34",
    //         "22374.27",
    //         "22342.52",
    //         "30.213426",
    //         "675499.29718947",
    //         "BTC_USDT"
    //       ]
    //     ],
    //     "id": null
    // }
    //
    var params interface{} = this.SafeValue(message, "params", []interface{}{})
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(params)); i++ {
        var data interface{} = ccxt.GetValue(params, i)
        var marketId interface{} = this.SafeString(data, 7)
        var market interface{} = this.SafeMarket(marketId)
        var symbol interface{} = ccxt.GetValue(market, "symbol")
        var messageHash interface{} = ccxt.Add(ccxt.Add("candles", ":"), symbol)
        var parsed interface{} = this.ParseOHLCV(data, market)
        // this.ohlcvs[symbol] = this.safeValue (this.ohlcvs, symbol)
        if !ccxt.IsTrue((ccxt.InOp(this.Ohlcvs, symbol))) {
            ccxt.AddElementToObject(this.Ohlcvs, symbol, map[string]interface{} {})
        }
        // let stored = this.ohlcvs[symbol]['unknown']; // we don't know the timeframe but we need to respect the type
        if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), "unknown"))) {
            var limit interface{} = this.SafeInteger(this.Options, "OHLCVLimit", 1000)
            stored := ccxt.NewArrayCacheByTimestamp(limit)
            ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), "unknown", stored)
        }
        var ohlcv interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), "unknown")
        ohlcv.(ccxt.Appender).Append(parsed)
        client.(ccxt.ClientInterface).Resolve(ohlcv, messageHash)
    }
    return message
}
/**
 * @method
 * @name whitebit#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.whitebit.com/public/websocket/#market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *WhitebitCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes1528 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1528)
            var market interface{} = this.Market(symbol)
            if ccxt.IsTrue(ccxt.IsEqual(limit, nil)) {
                limit = 10 // max 100
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), ccxt.GetValue(market, "symbol"))
            var method interface{} = "depth_subscribe"
            var options interface{} = this.SafeValue(this.Options, "watchOrderBook", map[string]interface{} {})
            var defaultPriceInterval interface{} = this.SafeString(options, "priceInterval", "0")
            var priceInterval interface{} = this.SafeString(params, "priceInterval", defaultPriceInterval)
            params = this.Omit(params, "priceInterval")
            var reqParams interface{} = []interface{}{ccxt.GetValue(market, "id"), limit, priceInterval, true}
        
            orderbook:= (<-this.WatchPublic(messageHash, method, reqParams, params))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // {
    //     "method":"depth_update",
    //     "params":[
    //        true,
    //        {
    //           "timestamp": 1708679568.940867,
    //           "asks":[
    //              [ "21252.45","0.01957"],
    //              ["21252.55","0.126205"],
    //              ["21252.66","0.222689"],
    //              ["21252.76","0.185358"],
    //              ["21252.87","0.210077"],
    //              ["21252.98","0.303991"],
    //              ["21253.08","0.327909"],
    //              ["21253.19","0.399007"],
    //              ["21253.3","0.427695"],
    //              ["21253.4","0.492901"]
    //           ],
    //           "bids":[
    //              ["21248.82","0.22"],
    //              ["21248.73","0.000467"],
    //              ["21248.62","0.100864"],
    //              ["21248.51","0.061436"],
    //              ["21248.42","0.091"],
    //              ["21248.41","0.126839"],
    //              ["21248.3","0.063511"],
    //              ["21248.2","0.110547"],
    //              ["21248","0.25257"],
    //              ["21247.7","1.71813"]
    //           ]
    //        },
    //        "BTC_USDT"
    //     ],
    //     "id":null
    //  }
    //
    var params interface{} = this.SafeValue(message, "params", []interface{}{})
    var isSnapshot interface{} = this.SafeValue(params, 0)
    var marketId interface{} = this.SafeString(params, 2)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var data interface{} = this.SafeValue(params, 1)
    var timestamp interface{} = this.SafeTimestamp(data, "timestamp")
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook()
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
    ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    if ccxt.IsTrue(isSnapshot) {
        var snapshot interface{} = this.ParseOrderBook(data, symbol)
        orderbook.(ccxt.OrderBookInterface).Reset(snapshot)
    } else {
        var asks interface{} = this.SafeValue(data, "asks", []interface{}{})
        var bids interface{} = this.SafeValue(data, "bids", []interface{}{})
        this.HandleDeltas(ccxt.GetValue(orderbook, "asks"), asks)
        this.HandleDeltas(ccxt.GetValue(orderbook, "bids"), bids)
    }
    var messageHash interface{} = ccxt.Add(ccxt.Add("orderbook", ":"), symbol)
    client.(ccxt.ClientInterface).Resolve(orderbook, messageHash)
}
func  (this *WhitebitCore) HandleDelta(bookside interface{}, delta interface{})  {
    var price interface{} = this.SafeFloat(delta, 0)
    var amount interface{} = this.SafeFloat(delta, 1)
    bookside.(ccxt.IOrderBookSide).Store(price, amount)
}
func  (this *WhitebitCore) HandleDeltas(bookside interface{}, deltas interface{})  {
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(deltas)); i++ {
        this.HandleDelta(bookside, ccxt.GetValue(deltas, i))
    }
}
/**
 * @method
 * @name whitebit#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.whitebit.com/public/websocket/#market-statistics
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *WhitebitCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2608 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2608)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var method interface{} = "market_subscribe"
            var messageHash interface{} = ccxt.Add("ticker:", symbol)
        
                retRes26615 :=  (<-this.WatchMultipleSubscription(messageHash, method, symbol, false, params))
                ccxt.PanicOnError(retRes26615)
                    // every time we want to subscribe to another market we have to "re-subscribe" sending it all again
        ch <- retRes26615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name whitebit#watchTickers
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
 * @see https://docs.whitebit.com/public/websocket/#market-statistics
 * @param {string[]} [symbols] unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *WhitebitCore) WatchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2798 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2798)
            symbols = this.MarketSymbols(symbols, nil, false)
            var method interface{} = "market_subscribe"
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var id interface{} = this.Nonce()
            var messageHashes interface{} = []interface{}{}
            var args interface{} = []interface{}{}
            for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(symbols)); i++ {
                var market interface{} = this.Market(ccxt.GetValue(symbols, i))
                ccxt.AppendToArray(&messageHashes, ccxt.Add("ticker:", ccxt.GetValue(market, "symbol")))
                ccxt.AppendToArray(&args, ccxt.GetValue(market, "id"))
            }
            var request interface{} = map[string]interface{} {
                "id": id,
                "method": method,
                "params": args,
            }
        
            retRes2968 := (<-this.WatchMultiple(url, messageHashes, this.Extend(request, params), messageHashes))
            ccxt.PanicOnError(retRes2968)
        
            ch <- this.FilterByArray(this.Tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleTicker(client interface{}, message interface{}) interface{}  {
    //
    //   {
    //       "method": "market_update",
    //       "params": [
    //         "BTC_USDT",
    //         {
    //           "close": "22293.86",
    //           "deal": "1986990019.96552952",
    //           "high": "24360.7",
    //           "last": "22293.86",
    //           "low": "20851.44",
    //           "open": "24076.12",
    //           "period": 86400,
    //           "volume": "87016.995668"
    //         }
    //       ],
    //       "id": null
    //   }
    //
    var tickers interface{} = this.SafeValue(message, "params", []interface{}{})
    var marketId interface{} = this.SafeString(tickers, 0)
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var rawTicker interface{} = this.SafeValue(tickers, 1, map[string]interface{} {})
    var messageHash interface{} = ccxt.Add(ccxt.Add("ticker", ":"), symbol)
    var ticker interface{} = this.ParseTicker(rawTicker, market)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    // watchTicker
    client.(ccxt.ClientInterface).Resolve(ticker, messageHash)
    // watchTickers
    var messageHashes interface{} = ccxt.ObjectKeys(client.(ccxt.ClientInterface).GetFutures())
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var currentMessageHash interface{} = ccxt.GetValue(messageHashes, i)
        if ccxt.IsTrue(ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(currentMessageHash, "tickers"), 0)) && ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(currentMessageHash, symbol), 0))) {
            // Example: user calls watchTickers with ['LTC/USDT', 'ETH/USDT']
            // the associated messagehash will be: 'tickers:LTC/USDT:ETH/USDT'
            // since we only have access to a single symbol at a time
            // we have to do a reverse lookup into the tickers hashes
            // and check if the current symbol is a part of one or more
            // tickers hashes and resolve them
            // user might have multiple watchTickers promises
            // watchTickers ( ['LTC/USDT', 'ETH/USDT'] ), watchTickers ( ['ETC/USDT', 'DOGE/USDT'] )
            // and we want to make sure we resolve only the correct ones
            client.(ccxt.ClientInterface).Resolve(ticker, currentMessageHash)
        }
    }
    return message
}
/**
 * @method
 * @name whitebit#watchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.whitebit.com/public/websocket/#market-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *WhitebitCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3628 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3628)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add(ccxt.Add("trades", ":"), symbol)
            var method interface{} = "trades_subscribe"
            // every time we want to subscribe to another market we have to 're-subscribe' sending it all again
        
            trades:= (<-this.WatchMultipleSubscription(messageHash, method, symbol, false, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleTrades(client interface{}, message interface{})  {
    //
    //    {
    //        "method":"trades_update",
    //        "params":[
    //           "BTC_USDT",
    //           [
    //              {
    //                 "id":1900632398,
    //                 "time":1656320231.404343,
    //                 "price":"21443.04",
    //                 "amount":"0.072844",
    //                 "type":"buy"
    //              },
    //              {
    //                 "id":1900632397,
    //                 "time":1656320231.400001,
    //                 "price":"21443.15",
    //                 "amount":"0.060757",
    //                 "type":"buy"
    //              }
    //           ]
    //        ]
    //    }
    //
    var params interface{} = this.SafeValue(message, "params", []interface{}{})
    var marketId interface{} = this.SafeString(params, 0)
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var stored interface{} = this.SafeValue(this.Trades, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(stored, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        stored = ccxt.NewArrayCache(limit)
        ccxt.AddElementToObject(this.Trades, symbol, stored)
    }
    var data interface{} = this.SafeValue(params, 1, []interface{}{})
    var parsedTrades interface{} = this.ParseTrades(data, market)
    for j := 0; ccxt.IsLessThan(j, ccxt.GetArrayLength(parsedTrades)); j++ {
        stored.(ccxt.Appender).Append(ccxt.GetValue(parsedTrades, j))
    }
    var messageHash interface{} = ccxt.Add("trades:", ccxt.GetValue(market, "symbol"))
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
/**
 * @method
 * @name whitebit#watchMyTrades
 * @description watches trades made by the user
 * @see https://docs.whitebit.com/private/websocket/#deals
 * @param {str} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *WhitebitCore) WatchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchMyTrades() requires a symbol argument")))
            }
        
            retRes4348 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4348)
        
            retRes4358 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4358)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("myTrades:", symbol)
            var method interface{} = "deals_subscribe"
        
            trades:= (<-this.WatchMultipleSubscription(messageHash, method, symbol, true, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleMyTrades(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    //   {
    //       "method": "deals_update",
    //       "params": [
    //         1894994106,
    //         1656151427.729706,
    //         "LTC_USDT",
    //         96624037337,
    //         "56.78",
    //         "0.16717",
    //         "0.0094919126",
    //         ''
    //       ],
    //       "id": null
    //   }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var trade interface{} = this.SafeValue(message, "params")
    if ccxt.IsTrue(ccxt.IsEqual(this.MyTrades, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        this.MyTrades = ccxt.NewArrayCache(limit)
    }
    var stored interface{} = this.MyTrades
    var parsed interface{} = this.ParseWsTrade(trade)
    stored.(ccxt.Appender).Append(parsed)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var messageHash interface{} = ccxt.Add("myTrades:", symbol)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
}
func  (this *WhitebitCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   [
    //         1894994106, // id
    //         1656151427.729706, // deal time
    //         "LTC_USDT", // symbol
    //         96624037337, // order id
    //         "56.78", // price
    //         "0.16717", // amount
    //         "0.0094919126", // fee
    //         '' // client order id
    //    ]
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var orderId interface{} = this.SafeString(trade, 3)
    var timestamp interface{} = this.SafeTimestamp(trade, 1)
    var id interface{} = this.SafeString(trade, 0)
    var price interface{} = this.SafeString(trade, 4)
    var amount interface{} = this.SafeString(trade, 5)
    var marketId interface{} = this.SafeString(trade, 2)
    market = this.SafeMarket(marketId, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, 6)
    if ccxt.IsTrue(!ccxt.IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": ccxt.GetValue(market, "quote"),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": ccxt.GetValue(market, "symbol"),
        "order": orderId,
        "type": nil,
        "side": nil,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name whitebit#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://docs.whitebit.com/private/websocket/#orders-pending
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *WhitebitCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if ccxt.IsTrue(ccxt.IsEqual(symbol, nil)) {
                panic(ccxt.ArgumentsRequired(ccxt.Add(this.Id, " watchOrders() requires a symbol argument")))
            }
        
            retRes5378 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5378)
        
            retRes5388 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5388)
            var market interface{} = this.Market(symbol)
            symbol = ccxt.GetValue(market, "symbol")
            var messageHash interface{} = ccxt.Add("orders:", symbol)
            var method interface{} = "ordersPending_subscribe"
        
            trades:= (<-this.WatchMultipleSubscription(messageHash, method, symbol, false, params))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(trades, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleOrder(client interface{}, message interface{}, optionalArgs ...interface{})  {
    //
    // {
    //     "method": "ordersPending_update",
    //     "params": [
    //       1, // 1 = new, 2 = update 3 = cancel or execute
    //       {
    //         "id": 96433622651,
    //         "market": "LTC_USDT",
    //         "type": 1,
    //         "side": 2,
    //         "ctime": 1656092215.39375,
    //         "mtime": 1656092215.39375,
    //         "price": "25",
    //         "amount": "0.202",
    //         "taker_fee": "0.001",
    //         "maker_fee": "0.001",
    //         "left": "0.202",
    //         "deal_stock": "0",
    //         "deal_money": "0",
    //         "deal_fee": "0",
    //         "client_order_id": ''
    //       }
    //     ]
    //     "id": null
    // }
    //
    subscription := ccxt.GetArg(optionalArgs, 0, nil)
    _ = subscription
    var params interface{} = this.SafeValue(message, "params", []interface{}{})
    var data interface{} = this.SafeValue(params, 1)
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var stored interface{} = this.Orders
    var status interface{} = this.SafeInteger(params, 0)
    var parsed interface{} = this.ParseWsOrder(this.Extend(data, map[string]interface{} {
        "status": status,
    }))
    stored.(ccxt.Appender).Append(parsed)
    var symbol interface{} = ccxt.GetValue(parsed, "symbol")
    var messageHash interface{} = ccxt.Add("orders:", symbol)
    client.(ccxt.ClientInterface).Resolve(this.Orders, messageHash)
}
func  (this *WhitebitCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   {
    //         "id": 96433622651,
    //         "market": "LTC_USDT",
    //         "type": 1,
    //         "side": 2, //1- sell 2-buy
    //         "ctime": 1656092215.39375,
    //         "mtime": 1656092215.39375,
    //         "price": "25",
    //         "amount": "0.202",
    //         "taker_fee": "0.001",
    //         "maker_fee": "0.001",
    //         "left": "0.202",
    //         "deal_stock": "0",
    //         "deal_money": "0",
    //         "deal_fee": "0",
    //         "activation_price": "40",
    //         "activation_condition": "lte",
    //         "client_order_id": ''
    //         "status": 1, // 1 = new, 2 = update 3 = cancel or execute
    //    }
    //
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.SafeInteger(order, "status")
    var marketId interface{} = this.SafeString(order, "market")
    market = this.SafeMarket(marketId, market)
    var id interface{} = this.SafeString(order, "id")
    var clientOrderId interface{} = this.OmitZero(this.SafeString(order, "client_order_id"))
    var price interface{} = this.SafeString(order, "price")
    var filled interface{} = this.SafeString(order, "deal_stock")
    var cost interface{} = this.SafeString(order, "deal_money")
    var stopPrice interface{} = this.SafeString(order, "activation_price")
    var rawType interface{} = this.SafeString(order, "type")
    var typeVar interface{} = this.ParseWsOrderType(rawType)
    var amount interface{} = nil
    var remaining interface{} = nil
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "market")) {
        amount = this.SafeString(order, "deal_stock")
        remaining = "0"
    } else {
        remaining = this.SafeString(order, "left")
        amount = this.SafeString(order, "amount")
    }
    var timestamp interface{} = this.SafeTimestamp(order, "ctime")
    var lastTradeTimestamp interface{} = this.SafeTimestamp(order, "mtime")
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var rawSide interface{} = this.SafeInteger(order, "side")
    var side interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(rawSide, 1))), "sell", "buy")
    var dealFee interface{} = this.SafeString(order, "deal_fee")
    var fee interface{} = nil
    if ccxt.IsTrue(!ccxt.IsEqual(dealFee, nil)) {
        fee = map[string]interface{} {
            "cost": this.ParseNumber(dealFee),
            "currency": ccxt.GetValue(market, "quote"),
        }
    }
    var unifiedStatus interface{} = nil
    if ccxt.IsTrue(ccxt.IsTrue((ccxt.IsEqual(status, 1))) || ccxt.IsTrue((ccxt.IsEqual(status, 2)))) {
        unifiedStatus = "open"
    } else {
        if ccxt.IsTrue(ccxt.Precise.StringEquals(remaining, "0")) {
            unifiedStatus = "closed"
        } else {
            unifiedStatus = "canceled"
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "symbol": symbol,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": stopPrice,
        "triggerPrice": stopPrice,
        "amount": amount,
        "cost": cost,
        "average": nil,
        "filled": filled,
        "remaining": remaining,
        "status": unifiedStatus,
        "fee": fee,
        "trades": nil,
    }, market)
}
func  (this *WhitebitCore) ParseWsOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "limit",
        "2": "market",
        "202": "market",
        "3": "limit",
        "4": "market",
        "5": "limit",
        "6": "market",
        "8": "limit",
        "10": "market",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name whitebit#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.whitebit.com/private/websocket/#balance-spot
 * @see https://docs.whitebit.com/private/websocket/#balance-margin
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *WhitebitCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7108 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7108)
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("watchBalance", nil, params)
            typeVar = ccxt.GetValue(typeVarparamsVariable,0)
            params = ccxt.GetValue(typeVarparamsVariable,1)
            var messageHash interface{} = "wallet:"
            var method interface{} = nil
            if ccxt.IsTrue(ccxt.IsEqual(typeVar, "spot")) {
                method = "balanceSpot_subscribe"
                messageHash = ccxt.Add(messageHash, "spot")
            } else {
                method = "balanceMargin_subscribe"
                messageHash = ccxt.Add(messageHash, "margin")
            }
            var currencies interface{} = ccxt.ObjectKeys(this.Currencies)
        
                retRes72315 :=  (<-this.WatchPrivate(messageHash, method, currencies, params))
                ccxt.PanicOnError(retRes72315)
                ch <- retRes72315
                return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleBalance(client interface{}, message interface{})  {
    //
    //   {
    //       "method":"balanceSpot_update",
    //       "params":[
    //          {
    //             "LTC":{
    //                "available":"0.16587",
    //                "freeze":"0"
    //             }
    //          }
    //       ],
    //       "id":null
    //   }
    //
    var method interface{} = this.SafeString(message, "method")
    var data interface{} = this.SafeValue(message, "params")
    var balanceDict interface{} = this.SafeValue(data, 0)
    ccxt.AddElementToObject(this.Balance, "info", balanceDict)
    var keys interface{} = ccxt.ObjectKeys(balanceDict)
    var currencyId interface{} = this.SafeValue(keys, 0)
    var rawBalance interface{} = this.SafeValue(balanceDict, currencyId)
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    ccxt.AddElementToObject(account, "free", this.SafeString(rawBalance, "available"))
    ccxt.AddElementToObject(account, "used", this.SafeString(rawBalance, "freeze"))
    ccxt.AddElementToObject(this.Balance, code, account)
    this.Balance = this.SafeBalance(this.Balance)
    var messageHash interface{} = "wallet:"
    if ccxt.IsTrue(ccxt.IsGreaterThanOrEqual(ccxt.GetIndexOf(method, "Spot"), 0)) {
        messageHash = ccxt.Add(messageHash, "spot")
    } else {
        messageHash = ccxt.Add(messageHash, "margin")
    }
    client.(ccxt.ClientInterface).Resolve(this.Balance, messageHash)
}
func  (this *WhitebitCore) WatchPublic(messageHash interface{}, method interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    reqParams := ccxt.GetArg(optionalArgs, 0, []interface{}{})
            _ = reqParams
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "id": id,
                "method": method,
                "params": reqParams,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes77215 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes77215)
                ch <- retRes77215
                return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) WatchMultipleSubscription(messageHash interface{}, method interface{}, symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    isNested := ccxt.GetArg(optionalArgs, 0, false)
            _ = isNested
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7768 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes7768)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var id interface{} = this.Nonce()
            var client interface{} = this.SafeValue(this.Clients, url)
            var request interface{} = nil
            var marketIds interface{} = []interface{}{}
            if ccxt.IsTrue(ccxt.IsEqual(client, nil)) {
                var subscription interface{} = map[string]interface{} {}
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                ccxt.AddElementToObject(subscription, marketId, true)
                marketIds = []interface{}{marketId}
                if ccxt.IsTrue(isNested) {
                    marketIds = []interface{}{marketIds}
                }
                request = map[string]interface{} {
                    "id": id,
                    "method": method,
                    "params": marketIds,
                }
                var message interface{} = this.Extend(request, params)
        
                    retRes79719 :=  (<-this.Watch(url, messageHash, message, method, subscription))
                    ccxt.PanicOnError(retRes79719)
                    ch <- retRes79719
                    return nil
            } else {
                var subscription interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), method, map[string]interface{} {})
                var hasSymbolSubscription interface{} = true
                var market interface{} = this.Market(symbol)
                var marketId interface{} = ccxt.GetValue(market, "id")
                var isSubscribed interface{} = this.SafeBool(subscription, marketId, false)
                if !ccxt.IsTrue(isSubscribed) {
                    ccxt.AddElementToObject(subscription, marketId, true)
                    hasSymbolSubscription = false
                }
                if ccxt.IsTrue(hasSymbolSubscription) {
        
                        retRes81023 :=  (<-this.Watch(url, messageHash, request, method, subscription))
                        ccxt.PanicOnError(retRes81023)
                                    // already subscribed to this market(s)
        ch <- retRes81023
                        return nil
                } else {
                    // resubscribe
                    var marketIdsNew interface{} = []interface{}{}
                    marketIdsNew = ccxt.ObjectKeys(subscription)
                    if ccxt.IsTrue(isNested) {
                        marketIdsNew = []interface{}{marketIdsNew}
                    }
                    var resubRequest interface{} = map[string]interface{} {
                        "id": id,
                        "method": method,
                        "params": marketIdsNew,
                    }
                    if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), method)) {
                        ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), method)
                    }
        
                        retRes82623 :=  (<-this.Watch(url, messageHash, resubRequest, method, subscription))
                        ccxt.PanicOnError(retRes82623)
                        ch <- retRes82623
                        return nil
                }
            }
        
            }()
            return ch
        }
func  (this *WhitebitCore) WatchPrivate(messageHash interface{}, method interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    reqParams := ccxt.GetArg(optionalArgs, 0, []interface{}{})
            _ = reqParams
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes8338 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes8338)
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var id interface{} = this.Nonce()
            var request interface{} = map[string]interface{} {
                "id": id,
                "method": method,
                "params": reqParams,
            }
            var message interface{} = this.Extend(request, params)
        
                retRes84215 :=  (<-this.Watch(url, messageHash, message, messageHash))
                ccxt.PanicOnError(retRes84215)
                ch <- retRes84215
                return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var url interface{} = ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws")
            var messageHash interface{} = "authenticated"
            var client interface{} = this.Client(url)
            var future interface{} = client.(ccxt.ClientInterface).ReusableFuture("authenticated")
            var authenticated interface{} = this.SafeValue(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
        
                authToken:= (<-this.V4PrivatePostProfileWebsocketToken())
                ccxt.PanicOnError(authToken)
                //
                //   {
                //       "websocket_token": "$2y$10$lxCvTXig/XrcTBFY1bdFseCKQmFTDtCpEzHNVnXowGplExFxPJp9y"
                //   }
                //
                var token interface{} = this.SafeString(authToken, "websocket_token")
                var id interface{} = this.Nonce()
                var request interface{} = map[string]interface{} {
                    "id": id,
                    "method": "authorize",
                    "params": []interface{}{token, "public"},
                }
                var subscription interface{} = map[string]interface{} {
                    "id": id,
                    "method": this.HandleAuthenticate,
                }
                
                    {
                         func(this *WhitebitCore) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *WhitebitCore) interface{} {
                                        // catch block:
                                                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), messageHash)
                            future.(*ccxt.Future).Reject(e)
                                        return nil
                                    }(this)
                                }
                            }()
                		    // try block:
                            
                            retRes87416 := (<-this.Watch(url, messageHash, request, messageHash, subscription))
                            ccxt.PanicOnError(retRes87416)
                		    return nil
                	    }(this)
                    
                        }
            }
        
                retRes88015 := <- future.(*ccxt.Future).Await()
                ccxt.PanicOnError(retRes88015)
                ch <- retRes88015
                return nil
        
            }()
            return ch
        }
func  (this *WhitebitCore) HandleAuthenticate(client interface{}, message interface{}) interface{}  {
    //
    //     { error: null, result: { status: "success" }, id: 1656084550 }
    //
    var future interface{} = ccxt.GetValue(client.(ccxt.ClientInterface).GetFutures(), "authenticated")
    future.(*ccxt.Future).Resolve(1)
    return message
}
func  (this *WhitebitCore) HandleErrorMessage(client interface{}, message interface{}) interface{}  {
    //
    //     {
    //         "error": { code: 1, message: "invalid argument" },
    //         "result": null,
    //         "id": 1656090882
    //     }
    //
    var error interface{} = this.SafeValue(message, "error")
    
        {
             func(this *WhitebitCore) (ret_ interface{}) {
    		    defer func() {
                    if e := recover(); e != nil {
                        if e == "break" {
                            return
                        }
                        ret_ = func(this *WhitebitCore) interface{} {
                            // catch block:
                                    if ccxt.IsTrue(ccxt.IsInstance(e, ccxt.AuthenticationError)) {
                client.(ccxt.ClientInterface).Reject(e, "authenticated")
                if ccxt.IsTrue(ccxt.InOp(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")) {
                    ccxt.Remove(client.(ccxt.ClientInterface).GetSubscriptions(), "authenticated")
                }
                return false
            }
                            return nil
                        }(this)
                    }
                }()
    		    // try block:
                        if ccxt.IsTrue(!ccxt.IsEqual(error, nil)) {
                var code interface{} = this.SafeString(message, "code")
                var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), this.Json(message))
                this.ThrowExactlyMatchedException(ccxt.GetValue(ccxt.GetValue(this.Exceptions, "ws"), "exact"), code, feedback)
            }
    		    return nil
    	    }(this)
        
            }
    return message
}
func  (this *WhitebitCore) HandleMessage(client interface{}, message interface{})  {
    //
    // auth
    //    { error: null, result: { status: "success" }, id: 1656084550 }
    //
    // pong
    //    { error: null, result: "pong", id: 0 }
    //
    if !ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var result interface{} = this.SafeString(message, "result")
    if ccxt.IsTrue(ccxt.IsEqual(result, "pong")) {
        this.HandlePong(client, message)
        return
    }
    var id interface{} = this.SafeInteger(message, "id")
    if ccxt.IsTrue(!ccxt.IsEqual(id, nil)) {
        this.HandleSubscriptionStatus(client, message, id)
        return
    }
    var methods interface{} = map[string]interface{} {
        "market_update": this.HandleTicker,
        "trades_update": this.HandleTrades,
        "depth_update": this.HandleOrderBook,
        "candles_update": this.HandleOHLCV,
        "ordersPending_update": this.HandleOrder,
        "ordersExecuted_update": this.HandleOrder,
        "balanceSpot_update": this.HandleBalance,
        "balanceMargin_update": this.HandleBalance,
        "deals_update": this.HandleMyTrades,
    }
    var topic interface{} = this.SafeValue(message, "method")
    var method interface{} = this.SafeValue(methods, topic)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *WhitebitCore) HandleSubscriptionStatus(client interface{}, message interface{}, id interface{})  {
    // not every method stores its subscription
    // as an object so we can't do indeById here
    var subs interface{} = client.(ccxt.ClientInterface).GetSubscriptions()
    var values interface{} = ccxt.ObjectValues(subs)
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(values)); i++ {
        var subscription interface{} = ccxt.GetValue(values, i)
        if ccxt.IsTrue(!ccxt.IsEqual(subscription, true)) {
            var subId interface{} = this.SafeInteger(subscription, "id")
            if ccxt.IsTrue(ccxt.IsTrue((!ccxt.IsEqual(subId, nil))) && ccxt.IsTrue((ccxt.IsEqual(subId, id)))) {
                var method interface{} = this.SafeValue(subscription, "method")
                if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
                    ccxt.CallDynamically(method, client, message)
                    return
                }
            }
        }
    }
}
func  (this *WhitebitCore) HandlePong(client interface{}, message interface{}) interface{}  {
    client.(ccxt.ClientInterface).SetLastPong(this.Milliseconds())
    return message
}
func  (this *WhitebitCore) Ping(client interface{}) interface{}  {
    return map[string]interface{} {
        "id": 0,
        "method": "ping",
        "params": []interface{}{},
    }
}


func (this *WhitebitCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
