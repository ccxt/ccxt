package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DydxCore struct {
    Exchange

}

func NewDydxCore() *DydxCore {
    p := &DydxCore{}
    setDefaults(p)
    return p
}

func  (this *DydxCore) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "dydx",
        "name": "dYdX",
        "countries": []interface{}{"US"},
        "rateLimit": 100,
        "version": "v4",
        "certified": false,
        "dex": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelWithdraw": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopLossOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": false,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": false,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": false,
            "fetchCurrencies": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": false,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": false,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactions": false,
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": false,
            "setLeverage": false,
            "setMargin": false,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1MIN",
            "5m": "5MINS",
            "15m": "15MINS",
            "30m": "30MINS",
            "1h": "1HOUR",
            "4h": "4HOURS",
            "1d": "1DAY",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/617ea0c1-f05a-4d26-9fcb-a0d1d4091ae1",
            "api": map[string]interface{} {
                "indexer": "https://indexer.dydx.trade/v4",
                "nodeRpc": "https://dydx-ops-rpc.kingnodes.com",
                "nodeRest": "https://dydx-rest.publicnode.com",
            },
            "test": map[string]interface{} {
                "indexer": "https://indexer.v4testnet.dydx.exchange/v4",
                "nodeRpc": "https://test-dydx-rpc.kingnodes.com",
                "nodeRest": "https://test-dydx-rest.kingnodes.com",
            },
            "www": "https://www.dydx.xyz",
            "doc": []interface{}{"https://docs.dydx.xyz"},
            "fees": []interface{}{"https://docs.dydx.exchange/introduction-trading_fees"},
            "referral": "dydx.trade?ref=ccxt",
        },
        "api": map[string]interface{} {
            "indexer": map[string]interface{} {
                "get": map[string]interface{} {
                    "addresses/{address}": 1,
                    "addresses/{address}/parentSubaccountNumber/{number}": 1,
                    "addresses/{address}/subaccountNumber/{subaccountNumber}": 1,
                    "assetPositions": 1,
                    "assetPositions/parentSubaccountNumber": 1,
                    "candles/perpetualMarkets/{market}": 1,
                    "compliance/screen/{address}": 1,
                    "fills": 1,
                    "fills/parentSubaccountNumber": 1,
                    "fundingPayments": 1,
                    "fundingPayments/parentSubaccount": 1,
                    "height": 0.1,
                    "historical-pnl": 1,
                    "historical-pnl/parentSubaccountNumber": 1,
                    "historicalBlockTradingRewards/{address}": 1,
                    "historicalFunding/{market}": 1,
                    "historicalTradingRewardAggregations/{address}": 1,
                    "orderbooks/perpetualMarket/{market}": 1,
                    "orders": 1,
                    "orders/parentSubaccountNumber": 1,
                    "orders/{orderId}": 1,
                    "perpetualMarkets": 1,
                    "perpetualPositions": 1,
                    "perpetualPositions/parentSubaccountNumber": 1,
                    "screen": 1,
                    "sparklines": 1,
                    "time": 1,
                    "trades/perpetualMarket/{market}": 1,
                    "transfers": 1,
                    "transfers/between": 1,
                    "transfers/parentSubaccountNumber": 1,
                    "vault/v1/megavault/historicalPnl": 1,
                    "vault/v1/megavault/positions": 1,
                    "vault/v1/vaults/historicalPnl": 1,
                    "perpetualMarketSparklines": 1,
                    "perpetualMarkets/{ticker}": 1,
                    "perpetualMarkets/{ticker}/orderbook": 1,
                    "trades/perpetualMarket/{ticker}": 1,
                    "historicalFunding/{ticker}": 1,
                    "candles/{ticker}/{resolution}": 1,
                    "addresses/{address}/subaccounts": 1,
                    "addresses/{address}/subaccountNumber/{subaccountNumber}/assetPositions": 1,
                    "addresses/{address}/subaccountNumber/{subaccountNumber}/perpetualPositions": 1,
                    "addresses/{address}/subaccountNumber/{subaccountNumber}/orders": 1,
                    "fills/parentSubaccount": 1,
                    "historical-pnl/parentSubaccount": 1,
                },
            },
            "nodeRpc": map[string]interface{} {
                "get": map[string]interface{} {
                    "abci_info": 1,
                    "block": 1,
                    "broadcast_tx_async": 1,
                    "broadcast_tx_sync": 1,
                    "tx": 1,
                },
            },
            "nodeRest": map[string]interface{} {
                "get": map[string]interface{} {
                    "cosmos/auth/v1beta1/account_info/{dydxAddress}": 1,
                },
                "post": map[string]interface{} {
                    "cosmos/tx/v1beta1/encode": 1,
                    "cosmos/tx/v1beta1/simulate": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0001"),
                "taker": this.ParseNumber("0.0005"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": false,
            "secret": false,
            "privateKey": false,
        },
        "options": map[string]interface{} {
            "mnemonic": nil,
            "chainName": "dydx-mainnet-1",
            "chainId": 1,
            "sandboxMode": false,
            "defaultFeeDenom": "uusdc",
            "defaultFeeMultiplier": "1.6",
            "feeDenom": map[string]interface{} {
                "USDC_DENOM": "ibc/8E27BA2D5493AF5636760E354E46004562C46AB7EC0CC4C1CA14E9E20E2545B5",
                "USDC_GAS_DENOM": "uusdc",
                "USDC_DECIMALS": 6,
                "USDC_GAS_PRICE": "0.025",
                "CHAINTOKEN_DENOM": "adydx",
                "CHAINTOKEN_DECIMALS": 18,
                "CHAINTOKEN_GAS_PRICE": "25000000000",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 90,
                    "untilDays": 10000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "forSwap": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "hedged": true,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forSwap",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "9": InvalidOrder,
                "10": InvalidOrder,
                "11": InvalidOrder,
                "12": InvalidOrder,
                "13": InvalidOrder,
                "14": InvalidOrder,
                "15": InvalidOrder,
                "16": InvalidOrder,
                "17": InvalidOrder,
                "18": InvalidOrder,
                "19": InvalidOrder,
                "20": InvalidOrder,
                "21": InvalidOrder,
                "22": InvalidOrder,
                "23": InvalidOrder,
                "24": InvalidOrder,
                "25": InvalidOrder,
                "26": InvalidOrder,
                "27": InvalidOrder,
                "28": InvalidOrder,
                "29": InvalidOrder,
                "30": InvalidOrder,
                "31": InvalidOrder,
                "32": InvalidOrder,
                "33": InvalidOrder,
                "34": InvalidOrder,
                "35": InvalidOrder,
                "36": InvalidOrder,
                "37": InvalidOrder,
                "39": InvalidOrder,
                "40": InvalidOrder,
                "41": InvalidOrder,
                "42": InvalidOrder,
                "43": InvalidOrder,
                "44": InvalidOrder,
                "45": InvalidOrder,
                "46": InvalidOrder,
                "47": InvalidOrder,
                "48": InvalidOrder,
                "49": InvalidOrder,
                "50": InvalidOrder,
                "1000": BadRequest,
                "1001": BadRequest,
                "1002": BadRequest,
                "1003": InvalidOrder,
                "1004": InvalidOrder,
                "1005": InvalidOrder,
                "1006": InvalidOrder,
                "1007": InvalidOrder,
                "1008": InvalidOrder,
                "1009": InvalidOrder,
                "1010": InvalidOrder,
                "1011": InvalidOrder,
                "1012": InvalidOrder,
                "1013": InvalidOrder,
                "1014": InvalidOrder,
                "1015": InvalidOrder,
                "1017": InvalidOrder,
                "1018": InvalidOrder,
                "1019": InvalidOrder,
                "1020": InvalidOrder,
                "1021": InvalidOrder,
                "1022": InvalidOrder,
                "2000": InvalidOrder,
                "2001": InvalidOrder,
                "2002": InvalidOrder,
                "2003": InvalidOrder,
                "2004": InvalidOrder,
                "2005": InvalidOrder,
                "3000": InvalidOrder,
                "3001": InvalidOrder,
                "3002": InvalidOrder,
                "3003": InvalidOrder,
                "3004": InvalidOrder,
                "3005": InvalidOrder,
                "3006": InvalidOrder,
                "3007": InvalidOrder,
                "3008": InvalidOrder,
                "3009": InvalidOrder,
                "3010": InvalidOrder,
                "4000": InvalidOrder,
                "4001": InvalidOrder,
                "4002": InvalidOrder,
                "4003": InvalidOrder,
                "4004": InvalidOrder,
                "4005": InvalidOrder,
                "4006": InvalidOrder,
                "4007": InvalidOrder,
                "4008": InvalidOrder,
                "5000": InvalidOrder,
                "5001": InvalidOrder,
                "6000": InvalidOrder,
                "6001": InvalidOrder,
                "6002": InvalidOrder,
                "9000": InvalidOrder,
                "9001": InvalidOrder,
                "9002": InvalidOrder,
                "9003": InvalidOrder,
                "10000": InvalidOrder,
                "10001": InvalidOrder,
                "11000": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "insufficient funds": InsufficientFunds,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name dydx#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.dydx.xyz/indexer-client/http#get-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *DydxCore) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.IndexerGetTime(params))
            PanicOnError(response)
        
                //
            // {
            //     "iso": "2025-07-20T15:12:13.466Z",
            //     "epoch": 1753024333.466
            // }
            //
        ch <- this.SafeInteger(response, "epoch")
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseMarket(market interface{}) interface{}  {
    //
    // {
    //     "clobPairId": "0",
    //     "ticker": "BTC-USD",
    //     "status": "ACTIVE",
    //     "oraclePrice": "118976.5376",
    //     "priceChange24H": "659.9736",
    //     "volume24H": "1292729.3605",
    //     "trades24H": 9387,
    //     "nextFundingRate": "0",
    //     "initialMarginFraction": "0.02",
    //     "maintenanceMarginFraction": "0.012",
    //     "openInterest": "52.0691",
    //     "atomicResolution": -10,
    //     "quantumConversionExponent": -9,
    //     "tickSize": "1",
    //     "stepSize": "0.0001",
    //     "stepBaseQuantums": 1000000,
    //     "subticksPerTick": 100000,
    //     "marketType": "CROSS",
    //     "openInterestLowerCap": "0",
    //     "openInterestUpperCap": "0",
    //     "baseOpenInterest": "50.3776",
    //     "defaultFundingRate1H": "0"
    // }
    //
    var quoteId interface{} = "USDC"
    var marketId interface{} = this.SafeString(market, "ticker")
    var parts interface{} = Split(marketId, "-")
    var baseName interface{} = this.SafeString(parts, 0)
    var baseId interface{} = this.SafeString(market, "baseId", baseName) // idk where 'baseId' comes from, but leaving as is
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = "USDC"
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
    var contract interface{} = true
    var swap interface{} = true
    var amountPrecisionStr interface{} = this.SafeString(market, "stepSize")
    var pricePrecisionStr interface{} = this.SafeString(market, "tickSize")
    var status interface{} = this.SafeString(market, "status")
    var active interface{} = true
    if IsTrue(!IsEqual(status, "ACTIVE")) {
        active = false
    }
    return this.SafeMarketStructure(map[string]interface{} {
        "id": this.SafeString(market, "ticker"),
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "baseName": baseName,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": "swap",
        "spot": false,
        "margin": nil,
        "swap": swap,
        "future": false,
        "option": false,
        "active": active,
        "contract": contract,
        "contractSize": this.ParseNumber("1"),
        "linear": true,
        "inverse": false,
        "taker": nil,
        "maker": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(amountPrecisionStr),
            "price": this.ParseNumber(pricePrecisionStr),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
/**
 * @method
 * @name dydx#fetchMarkets
 * @description retrieves data on all markets for hyperliquid
 * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *DydxCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.IndexerGetPerpetualMarkets(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "markets": {
            //         "BTC-USD": {
            //             "clobPairId": "0",
            //             "ticker": "BTC-USD",
            //             "status": "ACTIVE",
            //             "oraclePrice": "118976.5376",
            //             "priceChange24H": "659.9736",
            //             "volume24H": "1292729.3605",
            //             "trades24H": 9387,
            //             "nextFundingRate": "0",
            //             "initialMarginFraction": "0.02",
            //             "maintenanceMarginFraction": "0.012",
            //             "openInterest": "52.0691",
            //             "atomicResolution": -10,
            //             "quantumConversionExponent": -9,
            //             "tickSize": "1",
            //             "stepSize": "0.0001",
            //             "stepBaseQuantums": 1000000,
            //             "subticksPerTick": 100000,
            //             "marketType": "CROSS",
            //             "openInterestLowerCap": "0",
            //             "openInterestUpperCap": "0",
            //             "baseOpenInterest": "50.3776",
            //             "defaultFundingRate1H": "0"
            //         }
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "markets", map[string]interface{} {})
            var markets interface{} = ObjectValues(data)
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "02ac5b1f0000000200000002",
    //     "side": "BUY",
    //     "size": "0.0501",
    //     "price": "115732",
    //     "type": "LIMIT",
    //     "createdAt": "2025-07-25T05:11:09.800Z",
    //     "createdAtHeight": "44849951"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "createdAt"))
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "size")
    var side interface{} = this.SafeStringLower(trade, "side")
    var id interface{} = this.SafeString(trade, "id")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "order": nil,
        "takerOrMaker": nil,
        "type": nil,
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name dydx#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://developer.woox.io/api-reference/endpoint/public_data/marketTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *DydxCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6738 := (<-this.LoadMarkets())
            PanicOnError(retRes6738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.IndexerGetTradesPerpetualMarketMarket(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "trades": [
            //         {
            //             "id": "02ac5b1f0000000200000002",
            //             "side": "BUY",
            //             "size": "0.0501",
            //             "price": "115732",
            //             "type": "LIMIT",
            //             "createdAt": "2025-07-25T05:11:09.800Z",
            //             "createdAtHeight": "44849951"
            //         }
            //     ]
            // }
            //
            var rows interface{} = this.SafeList(response, "trades", []interface{}{})
        
            ch <- this.ParseTrades(rows, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "startedAt": "2025-07-25T09:47:00.000Z",
    //     "ticker": "BTC-USD",
    //     "resolution": "1MIN",
    //     "low": "116099",
    //     "high": "116099",
    //     "open": "116099",
    //     "close": "116099",
    //     "baseTokenVolume": "0",
    //     "usdVolume": "0",
    //     "trades": 0,
    //     "startingOpenInterest": "54.0594",
    //     "orderbookMidPriceOpen": "115845.5",
    //     "orderbookMidPriceClose": "115845.5"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "startedAt")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "baseTokenVolume")}
}
/**
 * @method
 * @name dydx#fetchOHLCV
 * @see https://docs.dydx.xyz/indexer-client/http#get-candles
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *DydxCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7438 := (<-this.LoadMarkets())
            PanicOnError(retRes7438)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromIso", this.Iso8601(since))
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "toIso", this.Iso8601(until))
            }
        
            response:= (<-this.IndexerGetCandlesPerpetualMarketsMarket(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "candles": [
            //         {
            //             "startedAt": "2025-07-25T09:47:00.000Z",
            //             "ticker": "BTC-USD",
            //             "resolution": "1MIN",
            //             "low": "116099",
            //             "high": "116099",
            //             "open": "116099",
            //             "close": "116099",
            //             "baseTokenVolume": "0",
            //             "usdVolume": "0",
            //             "trades": 0,
            //             "startingOpenInterest": "54.0594",
            //             "orderbookMidPriceOpen": "115845.5",
            //             "orderbookMidPriceClose": "115845.5"
            //         }
            //     ]
            // }
            //
            var rows interface{} = this.SafeList(response, "candles", []interface{}{})
        
            ch <- this.ParseOHLCVs(rows, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.dydx.xyz/indexer-client/http#get-historical-funding
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func  (this *DydxCore) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes8028 := (<-this.LoadMarkets())
            PanicOnError(retRes8028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "effectiveBeforeOrAt", this.Iso8601(until))
            }
        
            response:= (<-this.IndexerGetHistoricalFundingMarket(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "historicalFunding": [
            //         {
            //             "ticker": "BTC-USD",
            //             "rate": "0",
            //             "price": "116302.62419",
            //             "effectiveAtHeight": "44865196",
            //             "effectiveAt": "2025-07-25T11:00:00.013Z"
            //         }
            //     ]
            // }
            //
            var rates interface{} = []interface{}{}
            var rows interface{} = this.SafeList(response, "historicalFunding", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var entry interface{} = GetValue(rows, i)
                var timestamp interface{} = this.Parse8601(this.SafeString(entry, "effectiveAt"))
                var marketId interface{} = this.SafeString(entry, "ticker")
                AppendToArray(&rates, map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(marketId, market),
                    "fundingRate": this.SafeNumber(entry, "rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) HandlePublicAddress(methodName interface{}, params interface{}) interface{}  {
    var userAux interface{} = nil
    userAuxparamsVariable := this.HandleOptionAndParams(params, methodName, "user");
    userAux = GetValue(userAuxparamsVariable,0);
    params = GetValue(userAuxparamsVariable,1)
    var user interface{} = userAux
    userparamsVariable := this.HandleOptionAndParams(params, methodName, "address", userAux);
    user = GetValue(userparamsVariable,0);
    params = GetValue(userparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(user, nil))) && IsTrue((!IsEqual(user, "")))) {
        return []interface{}{user, params}
    }
    if IsTrue(IsTrue((!IsEqual(this.WalletAddress, nil))) && IsTrue((!IsEqual(this.WalletAddress, "")))) {
        return []interface{}{this.WalletAddress, params}
    }
    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a user parameter inside \\'params\\' or the walletAddress set")))
}
func  (this *DydxCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "dad46410-3444-5566-a129-19a619300fb7",
    //     "subaccountId": "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
    //     "clientId": "716238006",
    //     "clobPairId": "0",
    //     "side": "BUY",
    //     "size": "0.001",
    //     "totalFilled": "0.001",
    //     "price": "400000",
    //     "type": "LIMIT",
    //     "status": "FILLED",
    //     "timeInForce": "GTT",
    //     "reduceOnly": false,
    //     "orderFlags": "64",
    //     "goodTilBlockTime": "2025-07-28T12:07:33.000Z",
    //     "createdAtHeight": "45058325",
    //     "clientMetadata": "2",
    //     "updatedAt": "2025-07-28T12:06:35.330Z",
    //     "updatedAtHeight": "45058326",
    //     "postOnly": false,
    //     "ticker": "BTC-USD",
    //     "subaccountNumber": 0
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.ParseOrderStatus(this.SafeStringUpper(order, "status"))
    var marketId interface{} = this.SafeString(order, "ticker")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var filled interface{} = this.SafeString(order, "totalFilled")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "updatedAt"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "size")
    var typeVar interface{} = this.ParseOrderType(this.SafeStringUpper(order, "type"))
    var side interface{} = this.SafeStringLower(order, "side")
    var timeInForce interface{} = this.SafeStringUpper(order, "timeInForce")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "id"),
        "clientOrderId": this.SafeString(order, "clientId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": timestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": this.SafeBool(order, "postOnly"),
        "reduceOnly": this.SafeBool(order, "reduceOnly"),
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *DydxCore) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "UNTRIGGERED": "open",
        "OPEN": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "BEST_EFFORT_CANCELED": "canceling",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *DydxCore) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "LIMIT": "LIMIT",
        "STOP_LIMIT": "LIMIT",
        "TAKE_PROFIT_LIMIT": "LIMIT",
        "MARKET": "MARKET",
        "STOP_MARKET": "MARKET",
        "TAKE_PROFIT_MARKET": "MARKET",
        "TRAILING_STOP": "MARKET",
    }
    return this.SafeStringUpper(types, typeVar, typeVar)
}
/**
 * @method
 * @name dydx#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.dydx.xyz/indexer-client/http#get-order
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9588 := (<-this.LoadMarkets())
            PanicOnError(retRes9588)
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
            order:= (<-this.IndexerGetOrdersOrderId(this.Extend(request, params)))
            PanicOnError(order)
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.dydx.xyz/indexer-client/http#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            var subAccountNumber interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchOrders", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            subAccountNumberparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "subAccountNumber", "0");
            subAccountNumber = GetValue(subAccountNumberparamsVariable,0);
            params = GetValue(subAccountNumberparamsVariable,1)
        
            retRes9848 := (<-this.LoadMarkets())
            PanicOnError(retRes9848)
            var request interface{} = map[string]interface{} {
                "address": userAddress,
                "subaccountNumber": subAccountNumber,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "ticker", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.IndexerGetOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //         "id": "dad46410-3444-5566-a129-19a619300fb7",
            //         "subaccountId": "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
            //         "clientId": "716238006",
            //         "clobPairId": "0",
            //         "side": "BUY",
            //         "size": "0.001",
            //         "totalFilled": "0.001",
            //         "price": "400000",
            //         "type": "LIMIT",
            //         "status": "FILLED",
            //         "timeInForce": "GTT",
            //         "reduceOnly": false,
            //         "orderFlags": "64",
            //         "goodTilBlockTime": "2025-07-28T12:07:33.000Z",
            //         "createdAtHeight": "45058325",
            //         "clientMetadata": "2",
            //         "updatedAt": "2025-07-28T12:06:35.330Z",
            //         "updatedAtHeight": "45058326",
            //         "postOnly": false,
            //         "ticker": "BTC-USD",
            //         "subaccountNumber": 0
            //     }
            // ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.dydx.xyz/indexer-client/http#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "OPEN",
            }
        
                retRes104515 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes104515)
                ch <- retRes104515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.dydx.xyz/indexer-client/http#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "FILLED",
            }
        
                retRes106515 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes106515)
                ch <- retRes106515
                return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "market": "BTC-USD",
    //     "status": "OPEN",
    //     "side": "SHORT",
    //     "size": "-0.407",
    //     "maxSize": "-0.009",
    //     "entryPrice": "118692.04840909090909090909",
    //     "exitPrice": "119526.565625",
    //     "realizedPnl": "476.42665909090909090909088",
    //     "unrealizedPnl": "-57.26681734000000000000037",
    //     "createdAt": "2025-07-14T07:53:55.631Z",
    //     "createdAtHeight": "44140908",
    //     "closedAt": null,
    //     "sumOpen": "0.44",
    //     "sumClose": "0.032",
    //     "netFunding": "503.13121",
    //     "subaccountNumber": 0
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "market")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var side interface{} = this.SafeStringLower(position, "side")
    var quantity interface{} = this.SafeString(position, "size")
    if IsTrue(!IsEqual(side, "long")) {
        quantity = Precise.StringMul("-1", quantity)
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(position, "createdAt"))
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "entryPrice": this.SafeNumber(position, "entryPrice"),
        "markPrice": nil,
        "notional": nil,
        "collateral": nil,
        "unrealizedPnl": this.SafeNumber(position, "unrealizedPnl"),
        "side": side,
        "contracts": this.ParseNumber(quantity),
        "contractSize": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "hedged": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "liquidationPrice": nil,
        "marginRatio": nil,
        "marginMode": nil,
        "percentage": nil,
    })
}
/**
 * @method
 * @name dydx#fetchPosition
 * @description fetch data on an open position
 * @see https://docs.dydx.xyz/indexer-client/http#list-positions
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func  (this *DydxCore) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            positions:= (<-this.FetchPositions([]interface{}{symbol}, params))
            PanicOnError(positions)
        
            ch <- this.SafeDict(positions, 0, map[string]interface{} {})
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchPositions
 * @description fetch all open positions
 * @see https://docs.dydx.xyz/indexer-client/http#list-positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func  (this *DydxCore) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            var subAccountNumber interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchPositions", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            subAccountNumberparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "subAccountNumber", "0");
            subAccountNumber = GetValue(subAccountNumberparamsVariable,0);
            params = GetValue(subAccountNumberparamsVariable,1)
        
            retRes11578 := (<-this.LoadMarkets())
            PanicOnError(retRes11578)
            var request interface{} = map[string]interface{} {
                "address": userAddress,
                "subaccountNumber": subAccountNumber,
                "status": "OPEN",
            }
        
            response:= (<-this.IndexerGetPerpetualPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "positions": [
            //         {
            //             "market": "BTC-USD",
            //             "status": "OPEN",
            //             "side": "SHORT",
            //             "size": "-0.407",
            //             "maxSize": "-0.009",
            //             "entryPrice": "118692.04840909090909090909",
            //             "exitPrice": "119526.565625",
            //             "realizedPnl": "476.42665909090909090909088",
            //             "unrealizedPnl": "-57.26681734000000000000037",
            //             "createdAt": "2025-07-14T07:53:55.631Z",
            //             "createdAtHeight": "44140908",
            //             "closedAt": null,
            //             "sumOpen": "0.44",
            //             "sumClose": "0.032",
            //             "netFunding": "503.13121",
            //             "subaccountNumber": 0
            //         }
            //     ]
            // }
            //
            var rows interface{} = this.SafeList(response, "positions", []interface{}{})
        
            ch <- this.ParsePositions(rows, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) HashMessage(message interface{}) interface{}  {
    return this.Hash(message, keccak, "hex")
}
func  (this *DydxCore) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    var r interface{} = GetValue(signature, "r")
    var s interface{} = GetValue(signature, "s")
    return map[string]interface{} {
        "r": PadStart(r, 64, "0"),
        "s": PadStart(s, 64, "0"),
        "v": this.Sum(27, GetValue(signature, "v")),
    }
}
func  (this *DydxCore) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func  (this *DydxCore) SignOnboardingAction() interface{}  {
    var message interface{} = map[string]interface{} {
        "action": "dYdX Chain Onboarding",
    }
    var chainId interface{} = GetValue(this.Options, "chainId")
    var domain interface{} = map[string]interface{} {
        "chainId": chainId,
        "name": "dYdX Chain",
    }
    var messageTypes interface{} = map[string]interface{} {
        "dYdX": []interface{}{map[string]interface{} {
    "name": "action",
    "type": "string",
}},
    }
    var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, message)
    if IsTrue(IsTrue(IsEqual(this.PrivateKey, nil)) || IsTrue(IsEqual(this.PrivateKey, ""))) {
        panic(ArgumentsRequired(Add(this.Id, " signOnboardingAction() requires a privateKey to be set.")))
    }
    var signature interface{} = this.SignMessage(msg, this.PrivateKey)
    return signature
}
func  (this *DydxCore) SignDydxTx(privateKey interface{}, message interface{}, memo interface{}, chainId interface{}, account interface{}, authenticators interface{}, optionalArgs ...interface{}) interface{}  {
    fee := GetArg(optionalArgs, 0, nil)
    _ = fee
    encodedTxsignDocVariable := this.EncodeDydxTxForSigning(message, memo, chainId, account, authenticators, fee);
    encodedTx := GetValue(encodedTxsignDocVariable,0);
    signDoc := GetValue(encodedTxsignDocVariable,1)
    var signature interface{} = this.SignHash(encodedTx, privateKey)
    return this.EncodeDydxTxRaw(signDoc, Add(GetValue(signature, "r"), GetValue(signature, "s")))
}
func  (this *DydxCore) RetrieveCredentials() interface{}  {
    var credentials interface{} = this.SafeDict(this.Options, "dydxCredentials")
    if IsTrue(!IsEqual(credentials, nil)) {
        return credentials
    }
    var entropy interface{} = this.SafeString(this.Options, "mnemonic")
    if IsTrue(IsEqual(entropy, nil)) {
        var signature interface{} = this.SignOnboardingAction()
        entropy = this.HashMessage(this.Base16ToBinary(Add(GetValue(signature, "r"), GetValue(signature, "s"))))
    }
    credentials = this.RetrieveDydxCredentials(entropy)
    AddElementToObject(credentials, "privateKey", this.BinaryToBase16(GetValue(credentials, "privateKey")))
    AddElementToObject(credentials, "publicKey", this.BinaryToBase16(GetValue(credentials, "publicKey")))
    AddElementToObject(this.Options, "dydxCredentials", credentials)
    return credentials
}
func  (this *DydxCore) FetchDydxAccount() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                // required in js
        
        retRes12568 := (<-this.LoadDydxProtos())
        PanicOnError(retRes12568)
        var dydxAccount interface{} = this.SafeDict(this.Options, "dydxAccount")
        if IsTrue(!IsEqual(dydxAccount, nil)) {
        
            ch <- dydxAccount
            return nil
        }
        if IsTrue(IsEqual(this.WalletAddress, nil)) {
            panic(ArgumentsRequired(Add(this.Id, " fetchDydxAccount() requires the walletAddress to be set using the dydx chain address eg: dydx1cpb4tedmwq304c2kc9pwzjwq0sc6z2a4tasxrz")))
        }
        if !IsTrue(StartsWith(this.WalletAddress, "dydx")) {
            panic(ArgumentsRequired(Add(this.Id, " fetchDydxAccount() requires a valid dydx chain address, starting with dydx, not the l1 address.")))
        }
        var request interface{} = map[string]interface{} {
            "dydxAddress": this.WalletAddress,
        }
        //
        // {
        //     "info": {
        //         "address": "string",
        //         "pub_key": {
        //             "type_url": "string",
        //             "key": "string"
        //         },
        //         "account_number": "string",
        //         "sequence": "string"
        //     }
        // }
        //
        
        response:= (<-this.NodeRestGetCosmosAuthV1beta1AccountInfoDydxAddress(request))
        PanicOnError(response)
        var account interface{} = this.SafeDict(response, "info")
        AddElementToObject(account, "pub_key", map[string]interface{} {
            "key": GetValue(GetValue(account, "pub_key"), "key"),
        })
        AddElementToObject(this.Options, "dydxAccount", account)
        
        ch <- account
        return nil
        
            }()
            return ch
        }
func  (this *DydxCore) Pow(n interface{}, m interface{}) interface{}  {
    var r interface{} = Precise.StringMul(n, "1")
    var c interface{} = this.ParseToInt(m)
    // TODO: cap
    for i := 1; IsLessThan(i, c); i++ {
        r = Precise.StringMul(r, n)
    }
    return r
}
func  (this *DydxCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only", false)
    var orderType interface{} = ToUpper(typeVar)
    var market interface{} = this.Market(symbol)
    var orderSide interface{} = ToUpper(side)
    var subaccountId interface{} = 0
    subaccountIdparamsVariable := this.HandleOptionAndParams(params, "createOrder", "subAccountId", subaccountId);
    subaccountId = GetValue(subaccountIdparamsVariable,0);
    params = GetValue(subaccountIdparamsVariable,1)
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    var stopLossPrice interface{} = this.SafeValue(params, "stopLossPrice", triggerPrice)
    var takeProfitPrice interface{} = this.SafeValue(params, "takeProfitPrice")
    var isConditional interface{} = IsTrue(IsTrue(!IsEqual(triggerPrice, nil)) || IsTrue(!IsEqual(stopLossPrice, nil))) || IsTrue(!IsEqual(takeProfitPrice, nil))
    var isMarket interface{} = IsEqual(orderType, "MARKET")
    var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce", "GTT")
    var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
    var amountStr interface{} = this.AmountToPrecision(symbol, amount)
    var priceStr interface{} = this.PriceToPrecision(symbol, price)
    var marketInfo interface{} = this.SafeDict(market, "info")
    var atomicResolution interface{} = GetValue(marketInfo, "atomicResolution")
    var quantumScale interface{} = this.Pow("10", Precise.StringNeg(atomicResolution))
    var quantums interface{} = Precise.StringMul(amountStr, quantumScale)
    var quantumConversionExponent interface{} = GetValue(marketInfo, "quantumConversionExponent")
    var priceScale interface{} = this.Pow("10", Precise.StringSub(Precise.StringSub(atomicResolution, quantumConversionExponent), "-6"))
    var subticks interface{} = Precise.StringMul(priceStr, priceScale)
    var clientMetadata interface{} = 0
    var conditionalType interface{} = 0
    var conditionalOrderTriggerSubticks interface{} = "0"
    var orderFlag interface{} = nil
    var timeInForceNumber interface{} = nil
    if IsTrue(IsEqual(timeInForce, "FOK")) {
        panic(InvalidOrder(Add(this.Id, " timeInForce fok has been deprecated")))
    }
    if IsTrue(IsEqual(orderType, "MARKET")) {
        // short-term
        orderFlag = 0
        clientMetadata = 1 // STOP_MARKET / TAKE_PROFIT_MARKET
        if IsTrue(!IsEqual(timeInForce, nil)) {
            // default is ioc
            timeInForceNumber = 1
        }
    } else if IsTrue(IsEqual(orderType, "LIMIT")) {
        if IsTrue(IsEqual(timeInForce, "GTT")) {
            // long-term
            orderFlag = 64
            if IsTrue(postOnly) {
                timeInForceNumber = 2
            } else {
                timeInForceNumber = 0
            }
        } else {
            orderFlag = 0
            if IsTrue(IsEqual(timeInForce, "IOC")) {
                timeInForceNumber = 1
            } else {
                panic(InvalidOrder("unexpected code path: timeInForce"))
            }
        }
    }
    if IsTrue(isConditional) {
        // conditional
        orderFlag = 32
        if IsTrue(!IsEqual(stopLossPrice, nil)) {
            conditionalType = 1
            conditionalOrderTriggerSubticks = this.PriceToPrecision(symbol, stopLossPrice)
        } else if IsTrue(!IsEqual(takeProfitPrice, nil)) {
            conditionalType = 2
            conditionalOrderTriggerSubticks = this.PriceToPrecision(symbol, takeProfitPrice)
        }
        conditionalOrderTriggerSubticks = Precise.StringMul(conditionalOrderTriggerSubticks, priceScale)
    }
    var latestBlockHeight interface{} = this.SafeInteger(params, "latestBlockHeight")
    var goodTillBlock interface{} = this.SafeInteger(params, "goodTillBlock")
    var goodTillBlockTime interface{} = nil
    var goodTillBlockTimeInSeconds interface{} = 2592000
    goodTillBlockTimeInSecondsparamsVariable := this.HandleOptionAndParams(params, "createOrder", "goodTillBlockTimeInSeconds", goodTillBlockTimeInSeconds);
    goodTillBlockTimeInSeconds = GetValue(goodTillBlockTimeInSecondsparamsVariable,0);
    params = GetValue(goodTillBlockTimeInSecondsparamsVariable,1) // default is 30 days
    if IsTrue(IsEqual(orderFlag, 0)) {
        if IsTrue(IsEqual(goodTillBlock, nil)) {
            // short term order
            goodTillBlock = Add(latestBlockHeight, 20)
        }
    } else {
        if IsTrue(IsEqual(goodTillBlockTimeInSeconds, nil)) {
            panic(ArgumentsRequired("goodTillBlockTimeInSeconds is required."))
        }
        goodTillBlockTime = Add(this.Seconds(), goodTillBlockTimeInSeconds)
    }
    var sideNumber interface{} = Ternary(IsTrue((IsEqual(orderSide, "BUY"))), 1, 2)
    var defaultClientOrderId interface{} = this.RandNumber(9) // 2**32 - 1 is 10 digits, but it may overflow with 10
    var clientOrderId interface{} = this.SafeInteger(params, "clientOrderId", defaultClientOrderId)
    var orderPayload interface{} = map[string]interface{} {
        "order": map[string]interface{} {
            "orderId": map[string]interface{} {
                "subaccountId": map[string]interface{} {
                    "owner": this.GetWalletAddress(),
                    "number": subaccountId,
                },
                "clientId": clientOrderId,
                "orderFlags": orderFlag,
                "clobPairId": GetValue(marketInfo, "clobPairId"),
            },
            "side": sideNumber,
            "quantums": this.ToDydxLong(quantums),
            "subticks": this.ToDydxLong(subticks),
            "goodTilBlock": goodTillBlock,
            "goodTilBlockTime": goodTillBlockTime,
            "timeInForce": timeInForceNumber,
            "reduceOnly": reduceOnly,
            "clientMetadata": clientMetadata,
            "conditionType": conditionalType,
            "conditionalOrderTriggerSubticks": this.ToDydxLong(conditionalOrderTriggerSubticks),
            "orderRouterAddress": this.SafeString(this.Options, "routerAddress", "dydx165sfn2k3vucvq7gklauy2r3agyjw4c3m60ascn"),
        },
    }
    var signingPayload interface{} = map[string]interface{} {
        "typeUrl": "/dydxprotocol.clob.MsgPlaceOrder",
        "value": orderPayload,
    }
    params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only", "clientOrderId", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "latestBlockHeight", "goodTillBlock", "goodTillBlockTimeInSeconds", "subaccountId"})
    var orderId interface{} = this.CreateOrderIdFromParts(this.GetWalletAddress(), subaccountId, clientOrderId, orderFlag, GetValue(marketInfo, "clobPairId"))
    return []interface{}{orderId, this.Extend(signingPayload, params)}
}
func  (this *DydxCore) CreateOrderIdFromParts(address interface{}, subAccountNumber interface{}, clientOrderId interface{}, orderFlags interface{}, clobPairId interface{}) interface{}  {
    var nameSp interface{} = this.SafeString(this.Options, "namespace", "0f9da948-a6fb-4c45-9edc-4685c3f3317d")
    var prefixAddress interface{} = Add(Add(address, "-"), ToString(subAccountNumber))
    var prefix interface{} = this.Uuid5(nameSp, prefixAddress)
    var orderInfo interface{} = Add(Add(Add(Add(Add(Add(prefix, "-"), this.NumberToString(clientOrderId)), "-"), this.NumberToString(clobPairId)), "-"), this.NumberToString(orderFlags))
    return this.Uuid5(nameSp, orderInfo)
}
func  (this *DydxCore) FetchLatestBlockHeight(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.NodeRpcGetAbciInfo(params))
            PanicOnError(response)
            //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "response": {
            //             "data": "dydxprotocol",
            //             "version": "9.1.0-rc0",
            //             "last_block_height": "49157714",
            //             "last_block_app_hash": "9LHAcDDI5zmWiC6bGiiGtxuWPlKJV+/fTBZk/WQ/Y4U="
            //         }
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result")
            var info interface{} = this.SafeDict(result, "response")
        
            ch <- this.SafeInteger(info, "last_block_height")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#createOrder
 * @see https://docs.dydx.xyz/interaction/trading#place-an-order
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTT", "IOC", or "PO"
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {float} [params.stopLossPrice] price for a stoploss order
 * @param {float} [params.takeProfitPrice] price for a takeprofit order
 * @param {string} [params.clientOrderId] a unique id for the order
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {float} [params.goodTillBlock] expired block number for the order, required for market order and non limit GTT order, default value is latestBlockHeight + 20
 * @param {float} [params.goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional, default value is 30 days
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14768 := (<-this.LoadMarkets())
            PanicOnError(retRes14768)
            var credentials interface{} = this.RetrieveCredentials()
        
            account:= (<-this.FetchDydxAccount())
            PanicOnError(account)
        
            lastBlockHeight:= (<-this.FetchLatestBlockHeight())
            PanicOnError(lastBlockHeight)
            // params['latestBlockHeight'] = lastBlockHeight;
            var newParams interface{} = this.Extend(params, map[string]interface{} {
                "latestBlockHeight": lastBlockHeight,
            })
            var orderRequestRes interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, newParams)
            var orderId interface{} = GetValue(orderRequestRes, 0)
            var orderRequest interface{} = GetValue(orderRequestRes, 1)
            var chainName interface{} = GetValue(this.Options, "chainName")
            var signedTx interface{} = this.SignDydxTx(GetValue(credentials, "privateKey"), orderRequest, "", chainName, account, nil)
            var request interface{} = map[string]interface{} {
                "tx": signedTx,
            }
            // nodeRpcGetBroadcastTxAsync
        
            response:= (<-this.NodeRpcGetBroadcastTxSync(request))
            PanicOnError(response)
            //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "code": 0,
            //         "data": "",
            //         "log": "[]",
            //         "codespace": "",
            //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": result,
                "id": orderId,
                "clientOrderId": GetValue(GetValue(GetValue(GetValue(orderRequest, "value"), "order"), "orderId"), "clientId"),
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#cancelOrder
 * @description cancels an open order
 * @see https://docs.dydx.xyz/interaction/trading/#cancel-an-order
 * @param {string} id it should be the clientOrderId in this case
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id used when creating the order
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {float} [params.orderFlags] default is 64, orderFlags for the order, market order and non limit GTT order is 0, limit GTT order is 64 and conditional order is 32
 * @param {float} [params.goodTillBlock] expired block number for the order, required for market order and non limit GTT order (orderFlags = 0), default value is latestBlockHeight + 20
 * @param {float} [params.goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional (orderFlagss > 0), default value is 30 days
 * @param {int} [params.subAccountId] sub account id, default is 0
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            if IsTrue(!IsTrue(isTrigger) && IsTrue((IsEqual(symbol, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes15358 := (<-this.LoadMarkets())
            PanicOnError(retRes15358)
            var market interface{} = this.Market(symbol)
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientId", id)
            if IsTrue(IsEqual(clientOrderId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a clientOrderId parameter, cancelling using id is not currently supported.")))
            }
            var idString interface{} = ToString(id)
            if IsTrue(IsTrue(!IsEqual(id, nil)) && IsTrue(IsGreaterThan(GetIndexOf(idString, "-"), OpNeg(1)))) {
                panic(NotSupported(Add(this.Id, " cancelOrder() cancelling using id is not currently supported, please use provide the clientOrderId parameter.")))
            }
            var goodTillBlock interface{} = this.SafeInteger(params, "goodTillBlock")
            var goodTillBlockTimeInSeconds interface{} = 2592000
            goodTillBlockTimeInSecondsparamsVariable := this.HandleOptionAndParams(params, "cancelOrder", "goodTillBlockTimeInSeconds", goodTillBlockTimeInSeconds);
            goodTillBlockTimeInSeconds = GetValue(goodTillBlockTimeInSecondsparamsVariable,0);
            params = GetValue(goodTillBlockTimeInSecondsparamsVariable,1) // default is 30 days
            var goodTillBlockTime interface{} = nil
            var defaultOrderFlags interface{} = Ternary(IsTrue((isTrigger)), 32, 64)
            var orderFlags interface{} = this.SafeInteger(params, "orderFlags", defaultOrderFlags)
            var subAccountId interface{} = 0
            subAccountIdparamsVariable := this.HandleOptionAndParams(params, "cancelOrder", "subAccountId", subAccountId);
            subAccountId = GetValue(subAccountIdparamsVariable,0);
            params = GetValue(subAccountIdparamsVariable,1)
            params = this.Omit(params, []interface{}{"clientOrderId", "orderFlags", "goodTillBlock", "goodTillBlockTime", "goodTillBlockTimeInSeconds", "subaccountId", "clientId"})
            if IsTrue(IsTrue(IsTrue(!IsEqual(orderFlags, 0)) && IsTrue(!IsEqual(orderFlags, 64))) && IsTrue(!IsEqual(orderFlags, 32))) {
                panic(InvalidOrder(Add(this.Id, " invalid orderFlags, allowed values are (0, 64, 32).")))
            }
            if IsTrue(IsGreaterThan(orderFlags, 0)) {
                if IsTrue(IsEqual(goodTillBlockTimeInSeconds, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " goodTillBlockTimeInSeconds is required in params for long term or conditional order.")))
                }
                if IsTrue(IsTrue(!IsEqual(goodTillBlock, nil)) && IsTrue(IsGreaterThan(goodTillBlock, 0))) {
                    panic(InvalidOrder(Add(this.Id, " goodTillBlock should be 0 for long term or conditional order.")))
                }
                goodTillBlockTime = Add(this.Seconds(), goodTillBlockTimeInSeconds)
            } else {
                if IsTrue(IsEqual(goodTillBlock, nil)) {
        
                    latestBlockHeight:= (<-this.FetchLatestBlockHeight())
                    PanicOnError(latestBlockHeight)
                    goodTillBlock = Add(latestBlockHeight, 20)
                }
            }
            var credentials interface{} = this.RetrieveCredentials()
        
            account:= (<-this.FetchDydxAccount())
            PanicOnError(account)
            var cancelPayload interface{} = map[string]interface{} {
                "orderId": map[string]interface{} {
                    "subaccountId": map[string]interface{} {
                        "owner": this.GetWalletAddress(),
                        "number": subAccountId,
                    },
                    "clientId": clientOrderId,
                    "orderFlags": orderFlags,
                    "clobPairId": GetValue(GetValue(market, "info"), "clobPairId"),
                },
                "goodTilBlock": goodTillBlock,
                "goodTilBlockTime": goodTillBlockTime,
            }
            var signingPayload interface{} = map[string]interface{} {
                "typeUrl": "/dydxprotocol.clob.MsgCancelOrder",
                "value": cancelPayload,
            }
            var chainName interface{} = GetValue(this.Options, "chainName")
            var signedTx interface{} = this.SignDydxTx(GetValue(credentials, "privateKey"), signingPayload, "", chainName, account, nil)
            var request interface{} = map[string]interface{} {
                "tx": signedTx,
            }
            // nodeRpcGetBroadcastTxAsync
        
            response:= (<-this.NodeRpcGetBroadcastTxSync(request))
            PanicOnError(response)
            //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "code": 0,
            //         "data": "",
            //         "log": "[]",
            //         "codespace": "",
            //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": result,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#cancelOrders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderIds] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
 * @param {int} [params.subAccountId] sub account id, default is 0
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *DydxCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16288 := (<-this.LoadMarkets())
            PanicOnError(retRes16288)
            var market interface{} = this.Market(symbol)
            var clientOrderIds interface{} = this.SafeList(params, "clientOrderIds")
            if !IsTrue(clientOrderIds) {
                panic(NotSupported(Add(this.Id, " cancelOrders only support clientOrderIds.")))
            }
            var subAccountId interface{} = 0
            subAccountIdparamsVariable := this.HandleOptionAndParams(params, "cancelOrders", "subAccountId", subAccountId);
            subAccountId = GetValue(subAccountIdparamsVariable,0);
            params = GetValue(subAccountIdparamsVariable,1)
            var goodTillBlock interface{} = this.SafeInteger(params, "goodTillBlock")
            if IsTrue(IsEqual(goodTillBlock, nil)) {
        
                latestBlockHeight:= (<-this.FetchLatestBlockHeight())
                PanicOnError(latestBlockHeight)
                goodTillBlock = Add(latestBlockHeight, 20)
            }
            params = this.Omit(params, []interface{}{"clientOrderIds", "goodTillBlock", "subaccountId"})
            var credentials interface{} = this.RetrieveCredentials()
        
            account:= (<-this.FetchDydxAccount())
            PanicOnError(account)
            var cancelOrders interface{} = map[string]interface{} {
                "clientIds": clientOrderIds,
                "clobPairId": GetValue(GetValue(market, "info"), "clobPairId"),
            }
            var cancelPayload interface{} = map[string]interface{} {
                "subaccountId": map[string]interface{} {
                    "owner": this.GetWalletAddress(),
                    "number": subAccountId,
                },
                "shortTermCancels": []interface{}{cancelOrders},
                "goodTilBlock": goodTillBlock,
            }
            var signingPayload interface{} = map[string]interface{} {
                "typeUrl": "/dydxprotocol.clob.MsgBatchCancel",
                "value": cancelPayload,
            }
            var chainName interface{} = GetValue(this.Options, "chainName")
            var signedTx interface{} = this.SignDydxTx(GetValue(credentials, "privateKey"), signingPayload, "", chainName, account, nil)
            var request interface{} = map[string]interface{} {
                "tx": signedTx,
            }
            // nodeRpcGetBroadcastTxAsync
        
            response:= (<-this.NodeRpcGetBroadcastTxSync(request))
            PanicOnError(response)
            //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "code": 0,
            //         "data": "",
            //         "log": "[]",
            //         "codespace": "",
            //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": result,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-market-orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *DydxCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16978 := (<-this.LoadMarkets())
            PanicOnError(retRes16978)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.IndexerGetOrderbooksPerpetualMarketMarket(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "bids": [
            //         {
            //             "price": "118267",
            //             "size": "0.3182"
            //         }
            //     ],
            //     "asks": [
            //         {
            //             "price": "118485",
            //             "size": "0.0001"
            //         }
            //     ]
            // }
            //
        ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), nil, "bids", "asks", "price", "size")
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
    //     "sender": {
    //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
    //         "subaccountNumber": 0
    //     },
    //     "recipient": {
    //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
    //         "subaccountNumber": 1
    //     },
    //     "size": "0.000001",
    //     "createdAt": "2025-07-29T09:43:02.105Z",
    //     "createdAtHeight": "45116125",
    //     "symbol": "USDC",
    //     "type": "TRANSFER_OUT",
    //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(item, "symbol")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var typeVar interface{} = this.SafeStringUpper(item, "type")
    var direction interface{} = nil
    if IsTrue(!IsEqual(typeVar, nil)) {
        if IsTrue(IsTrue(IsEqual(typeVar, "TRANSFER_IN")) || IsTrue(IsEqual(typeVar, "DEPOSIT"))) {
            direction = "in"
        } else if IsTrue(IsTrue(IsEqual(typeVar, "TRANSFER_OUT")) || IsTrue(IsEqual(typeVar, "WITHDRAWAL"))) {
            direction = "out"
        }
    }
    var amount interface{} = this.SafeString(item, "size")
    var timestamp interface{} = this.Parse8601(this.SafeString(item, "createdAt"))
    var sender interface{} = this.SafeDict(item, "sender")
    var recipient interface{} = this.SafeDict(item, "recipient")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "id"),
        "direction": direction,
        "account": this.SafeString(sender, "address"),
        "referenceAccount": this.SafeString(recipient, "address"),
        "referenceId": this.SafeString(item, "transactionHash"),
        "type": this.ParseLedgerEntryType(typeVar),
        "currency": code,
        "amount": this.ParseNumber(amount),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": nil,
        "status": nil,
        "fee": nil,
    }, currency)
}
func  (this *DydxCore) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var ledgerType interface{} = map[string]interface{} {
        "TRANSFER_IN": "transfer",
        "TRANSFER_OUT": "transfer",
        "DEPOSIT": "deposit",
        "WITHDRAWAL": "withdrawal",
    }
    return this.SafeString(ledgerType, typeVar, typeVar)
}
/**
 * @method
 * @name dydx#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
 */
func  (this *DydxCore) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18018 := (<-this.LoadMarkets())
            PanicOnError(retRes18018)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, this.Extend(params, map[string]interface{} {
            "methodName": "fetchLedger",
        })))
            PanicOnError(response)
        
            ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) EstimateTxFee(message interface{}, memo interface{}, account interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var txBytes interface{} = this.EncodeDydxTxForSimulation(message, memo, GetValue(account, "sequence"), GetValue(account, "pub_key"))
            var request interface{} = map[string]interface{} {
                "txBytes": txBytes,
            }
        
            response:= (<-this.NodeRestPostCosmosTxV1beta1Simulate(request))
            PanicOnError(response)
            //
            // {
            //     gas_info: { gas_wanted: '18446744073709551615', gas_used: '86055' },
            //     result: {
            //         ...
            //     }
            // }
            //
            var gasInfo interface{} = this.SafeDict(response, "gas_info")
            if IsTrue(IsEqual(gasInfo, nil)) {
                panic(ExchangeError(Add(this.Id, " failed to simulate transaction.")))
            }
            var gasUsed interface{} = this.SafeString(gasInfo, "gas_used")
            if IsTrue(IsEqual(gasUsed, nil)) {
                panic(ExchangeError(Add(this.Id, " failed to simulate transaction.")))
            }
            var defaultFeeDenom interface{} = this.SafeString(this.Options, "defaultFeeDenom")
            var defaultFeeMultiplier interface{} = this.SafeString(this.Options, "defaultFeeMultiplier")
            var feeDenom interface{} = this.SafeDict(this.Options, "feeDenom")
            var gasPrice interface{} = nil
            var denom interface{} = nil
            if IsTrue(IsEqual(defaultFeeDenom, "uusdc")) {
                gasPrice = GetValue(feeDenom, "USDC_GAS_PRICE")
                denom = GetValue(feeDenom, "USDC_DENOM")
            } else {
                gasPrice = GetValue(feeDenom, "CHAINTOKEN_GAS_PRICE")
                denom = GetValue(feeDenom, "CHAINTOKEN_DENOM")
            }
            var gasLimit interface{} = MathCeil(this.ParseToNumeric(Precise.StringMul(gasUsed, defaultFeeMultiplier)))
            var feeAmount interface{} = Precise.StringMul(this.NumberToString(gasLimit), gasPrice)
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(feeAmount, "."), 0)) {
                feeAmount = this.NumberToString(MathCeil(this.ParseToNumeric(feeAmount)))
            }
            var feeObj interface{} = map[string]interface{} {
                "amount": feeAmount,
                "denom": denom,
            }
        
            ch <- map[string]interface{} {
                "amount": []interface{}{feeObj},
                "gasLimit": gasLimit,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#transfer
 * @description transfer currency internally between wallets on the same account
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from *main, subaccount*
 * @param {string} toAccount account to transfer to *subaccount, address*
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address for order
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func  (this *DydxCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(code, "USDC")) {
                panic(NotSupported(Add(this.Id, " transfer() only support USDC")))
            }
        
            retRes18758 := (<-this.LoadMarkets())
            PanicOnError(retRes18758)
            var fromSubaccountId interface{} = this.SafeInteger(params, "fromSubaccountId")
            var toSubaccountId interface{} = this.SafeInteger(params, "toSubaccountId")
            if IsTrue(!IsEqual(fromAccount, "main")) {
                // throw error if from subaccount id is undefind
                if IsTrue(IsEqual(fromAccount, nil)) {
                    panic(NotSupported(Add(this.Id, " transfer only support main > subaccount and subaccount <> subaccount.")))
                }
                if IsTrue(IsTrue(IsEqual(fromSubaccountId, nil)) || IsTrue(IsEqual(toSubaccountId, nil))) {
                    panic(ArgumentsRequired(Add(this.Id, " transfer requires fromSubaccountId and toSubaccountId.")))
                }
            }
            params = this.Omit(params, []interface{}{"fromSubaccountId", "toSubaccountId"})
            var credentials interface{} = this.RetrieveCredentials()
        
            account:= (<-this.FetchDydxAccount())
            PanicOnError(account)
            var usd interface{} = this.ParseToInt(Precise.StringMul(this.NumberToString(amount), "1000000"))
            var payload interface{} = nil
            var signingPayload interface{} = nil
            if IsTrue(IsEqual(fromAccount, "main")) {
                // deposit to subaccount
                if IsTrue(IsEqual(toSubaccountId, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " transfer() requeire toSubaccoutnId.")))
                }
                payload = map[string]interface{} {
                    "sender": this.GetWalletAddress(),
                    "recipient": map[string]interface{} {
                        "owner": this.GetWalletAddress(),
                        "number": toSubaccountId,
                    },
                    "assetId": 0,
                    "quantums": usd,
                }
                signingPayload = map[string]interface{} {
                    "typeUrl": "/dydxprotocol.sending.MsgDepositToSubaccount",
                    "value": payload,
                }
            } else {
                payload = map[string]interface{} {
                    "transfer": map[string]interface{} {
                        "sender": map[string]interface{} {
                            "owner": fromAccount,
                            "number": fromSubaccountId,
                        },
                        "recipient": map[string]interface{} {
                            "owner": toAccount,
                            "number": toSubaccountId,
                        },
                        "assetId": 0,
                        "amount": usd,
                    },
                }
                signingPayload = map[string]interface{} {
                    "typeUrl": "/dydxprotocol.sending.MsgCreateTransfer",
                    "value": payload,
                }
            }
        
            txFee:= (<-this.EstimateTxFee(signingPayload, "", account))
            PanicOnError(txFee)
            var chainName interface{} = GetValue(this.Options, "chainName")
            var signedTx interface{} = this.SignDydxTx(GetValue(credentials, "privateKey"), signingPayload, "", chainName, account, nil, txFee)
            var request interface{} = map[string]interface{} {
                "tx": signedTx,
            }
            // nodeRpcGetBroadcastTxAsync
        
            response:= (<-this.NodeRpcGetBroadcastTxSync(request))
            PanicOnError(response)
        
                //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "code": 0,
            //         "data": "",
            //         "log": "[]",
            //         "codespace": "",
            //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
        ch <- this.ParseTransfer(response)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
    //     "sender": {
    //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
    //         "subaccountNumber": 0
    //     },
    //     "recipient": {
    //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
    //         "subaccountNumber": 1
    //     },
    //     "size": "0.000001",
    //     "createdAt": "2025-07-29T09:43:02.105Z",
    //     "createdAtHeight": "45116125",
    //     "symbol": "USDC",
    //     "type": "TRANSFER_OUT",
    //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transfer, "id")
    var currencyId interface{} = this.SafeString(transfer, "symbol")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var amount interface{} = this.SafeNumber(transfer, "size")
    var sender interface{} = this.SafeDict(transfer, "sender")
    var recipient interface{} = this.SafeDict(transfer, "recipient")
    var fromAccount interface{} = this.SafeString(sender, "address")
    var toAccount interface{} = this.SafeString(recipient, "address")
    var timestamp interface{} = this.Parse8601(this.SafeString(transfer, "createdAt"))
    return map[string]interface{} {
        "info": transfer,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": code,
        "amount": amount,
        "fromAccount": fromAccount,
        "toAccount": toAccount,
        "status": nil,
    }
}
/**
 * @method
 * @name dydx#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func  (this *DydxCore) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20118 := (<-this.LoadMarkets())
            PanicOnError(retRes20118)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, this.Extend(params, map[string]interface{} {
            "methodName": "fetchTransfers",
        })))
            PanicOnError(response)
            var transferIn interface{} = this.FilterBy(response, "type", "TRANSFER_IN")
            var transferOut interface{} = this.FilterBy(response, "type", "TRANSFER_OUT")
            var rows interface{} = this.ArrayConcat(transferIn, transferOut)
        
            ch <- this.ParseTransfers(rows, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
    //     "sender": {
    //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
    //         "subaccountNumber": 0
    //     },
    //     "recipient": {
    //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
    //         "subaccountNumber": 1
    //     },
    //     "size": "0.000001",
    //     "createdAt": "2025-07-29T09:43:02.105Z",
    //     "createdAtHeight": "45116125",
    //     "symbol": "USDC",
    //     "type": "TRANSFER_OUT",
    //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var sender interface{} = this.SafeDict(transaction, "sender")
    var recipient interface{} = this.SafeDict(transaction, "recipient")
    var addressTo interface{} = this.SafeString(recipient, "address")
    var addressFrom interface{} = this.SafeString(sender, "address")
    var txid interface{} = this.SafeString(transaction, "transactionHash")
    var currencyId interface{} = this.SafeString(transaction, "symbol")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "createdAt"))
    var amount interface{} = this.SafeNumber(transaction, "size")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": addressTo,
        "addressTo": addressTo,
        "addressFrom": addressFrom,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": this.SafeStringLower(transaction, "type"),
        "amount": amount,
        "currency": code,
        "status": nil,
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": nil,
    }
}
/**
 * @method
 * @name dydx#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func  (this *DydxCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(code, "USDC")) {
                panic(NotSupported(Add(this.Id, " withdraw() only support USDC")))
            }
        
            retRes20928 := (<-this.LoadMarkets())
            PanicOnError(retRes20928)
            this.CheckAddress(address)
            var subaccountId interface{} = this.SafeInteger(params, "subaccountId")
            if IsTrue(IsEqual(subaccountId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " withdraw requires subaccountId.")))
            }
            params = this.Omit(params, []interface{}{"subaccountId"})
            var currency interface{} = this.Currency(code)
            var credentials interface{} = this.RetrieveCredentials()
        
            account:= (<-this.FetchDydxAccount())
            PanicOnError(account)
            var usd interface{} = this.ParseToInt(Precise.StringMul(this.NumberToString(amount), "1000000"))
            var payload interface{} = map[string]interface{} {
                "sender": map[string]interface{} {
                    "owner": this.GetWalletAddress(),
                    "number": subaccountId,
                },
                "recipient": address,
                "assetId": 0,
                "quantums": usd,
            }
            var signingPayload interface{} = map[string]interface{} {
                "typeUrl": "/dydxprotocol.sending.MsgWithdrawFromSubaccount",
                "value": payload,
            }
        
            txFee:= (<-this.EstimateTxFee(signingPayload, tag, account))
            PanicOnError(txFee)
            var chainName interface{} = GetValue(this.Options, "chainName")
            var signedTx interface{} = this.SignDydxTx(GetValue(credentials, "privateKey"), signingPayload, tag, chainName, account, nil, txFee)
            var request interface{} = map[string]interface{} {
                "tx": signedTx,
            }
            // nodeRpcGetBroadcastTxAsync
        
            response:= (<-this.NodeRpcGetBroadcastTxSync(request))
            PanicOnError(response)
            //
            // {
            //     "jsonrpc": "2.0",
            //     "id": -1,
            //     "result": {
            //         "code": 0,
            //         "data": "",
            //         "log": "[]",
            //         "codespace": "",
            //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func  (this *DydxCore) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21558 := (<-this.LoadMarkets())
            PanicOnError(retRes21558)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, this.Extend(params, map[string]interface{} {
            "methodName": "fetchWithdrawals",
        })))
            PanicOnError(response)
            var rows interface{} = this.FilterBy(response, "type", "WITHDRAWAL")
        
            ch <- this.ParseTransactions(rows, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func  (this *DydxCore) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21798 := (<-this.LoadMarkets())
            PanicOnError(retRes21798)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, this.Extend(params, map[string]interface{} {
            "methodName": "fetchDeposits",
        })))
            PanicOnError(response)
            var rows interface{} = this.FilterBy(response, "type", "DEPOSIT")
        
            ch <- this.ParseTransactions(rows, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.subAccountNumber] sub account number
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func  (this *DydxCore) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22038 := (<-this.LoadMarkets())
            PanicOnError(retRes22038)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, this.Extend(params, map[string]interface{} {
            "methodName": "fetchDepositsWithdrawals",
        })))
            PanicOnError(response)
            var withdrawals interface{} = this.FilterBy(response, "type", "WITHDRAWAL")
            var deposits interface{} = this.FilterBy(response, "type", "DEPOSIT")
            var rows interface{} = this.ArrayConcat(withdrawals, deposits)
        
            ch <- this.ParseTransactions(rows, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) FetchTransactionsHelper(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = this.SafeString(params, "methodName")
            params = this.Omit(params, "methodName")
            var userAddress interface{} = nil
            var subAccountNumber interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress(methodName, params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            subAccountNumberparamsVariable := this.HandleOptionAndParams(params, methodName, "subAccountNumber", "0");
            subAccountNumber = GetValue(subAccountNumberparamsVariable,0);
            params = GetValue(subAccountNumberparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "address": userAddress,
                "subaccountNumber": subAccountNumber,
            }
        
            response:= (<-this.IndexerGetTransfers(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "transfers": [
            //         {
            //             "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
            //             "sender": {
            //                 "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //                 "subaccountNumber": 0
            //             },
            //             "recipient": {
            //                 "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
            //                 "subaccountNumber": 1
            //             },
            //             "size": "0.000001",
            //             "createdAt": "2025-07-29T09:43:02.105Z",
            //             "createdAtHeight": "45116125",
            //             "symbol": "USDC",
            //             "type": "TRANSFER_OUT",
            //             "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
            //         }
            //     ]
            // }
            //
        ch <- this.SafeList(response, "transfers", []interface{}{})
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.dydx.xyz/indexer-client/http#get-subaccounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.address] wallet address that made trades
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
 */
func  (this *DydxCore) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchAccounts", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "address": userAddress,
            }
        
            response:= (<-this.IndexerGetAddressesAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "subaccounts": [
            //         {
            //             "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //             "subaccountNumber": 0,
            //             "equity": "25346.73993597",
            //             "freeCollateral": "24207.8530595294",
            //             "openPerpetualPositions": {
            //                 "BTC-USD": {
            //                     "market": "BTC-USD",
            //                     "status": "OPEN",
            //                     "side": "SHORT",
            //                     "size": "-0.491",
            //                     "maxSize": "-0.009",
            //                     "entryPrice": "118703.60811320754716981132",
            //                     "exitPrice": "119655.95",
            //                     "realizedPnl": "3075.17994830188679245283016",
            //                     "unrealizedPnl": "1339.12776155490566037735812",
            //                     "createdAt": "2025-07-14T07:53:55.631Z",
            //                     "createdAtHeight": "44140908",
            //                     "closedAt": null,
            //                     "sumOpen": "0.53",
            //                     "sumClose": "0.038",
            //                     "netFunding": "3111.36894",
            //                     "subaccountNumber": 0
            //                 }
            //             },
            //             "assetPositions": {
            //                 "USDC": {
            //                     "size": "82291.083758",
            //                     "symbol": "USDC",
            //                     "side": "LONG",
            //                     "assetId": "0",
            //                     "subaccountNumber": 0
            //                 }
            //             },
            //             "marginEnabled": true,
            //             "updatedAtHeight": "45234659",
            //             "latestProcessedBlockHeight": "45293477"
            //         }
            //     ]
            // }
            //
            var rows interface{} = this.SafeList(response, "subaccounts", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var account interface{} = GetValue(rows, i)
                var accountId interface{} = this.SafeString(account, "subaccountNumber")
                AppendToArray(&result, map[string]interface{} {
                    "id": accountId,
                    "type": nil,
                    "currency": nil,
                    "info": account,
                    "code": nil,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name dydx#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.dydx.xyz/indexer-client/http#get-subaccount
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *DydxCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23388 := (<-this.LoadMarkets())
            PanicOnError(retRes23388)
            var userAddress interface{} = nil
            userAddressparamsVariable := this.HandlePublicAddress("fetchAccounts", params);
            userAddress = GetValue(userAddressparamsVariable,0);
            params = GetValue(userAddressparamsVariable,1)
            var subaccountNumber interface{} = nil
            subaccountNumberparamsVariable := this.HandleOptionAndParams(params, "fetchAccounts", "subaccountNumber", 0);
            subaccountNumber = GetValue(subaccountNumberparamsVariable,0);
            params = GetValue(subaccountNumberparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "address": userAddress,
                "subaccountNumber": subaccountNumber,
            }
        
            response:= (<-this.IndexerGetAddressesAddressSubaccountNumberSubaccountNumber(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "subaccount": {
            //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //         "subaccountNumber": 0,
            //         "equity": "161451.040416029",
            //         "freeCollateral": "152508.28819133578",
            //         "openPerpetualPositions": {
            //             "ETH-USD": {
            //                 "market": "ETH-USD",
            //                 "status": "OPEN",
            //                 "side": "LONG",
            //                 "size": "0.001",
            //                 "maxSize": "0.002",
            //                 "entryPrice": "3894.7",
            //                 "exitPrice": "3864.5",
            //                 "realizedPnl": "-0.034847",
            //                 "unrealizedPnl": "-0.044675155",
            //                 "createdAt": "2025-10-22T08:34:05.883Z",
            //                 "createdAtHeight": "52228825",
            //                 "closedAt": null,
            //                 "sumOpen": "0.002",
            //                 "sumClose": "0.001",
            //                 "netFunding": "-0.004647",
            //                 "subaccountNumber": 0
            //             },
            //             "BTC-USD": {
            //                 "market": "BTC-USD",
            //                 "status": "OPEN",
            //                 "side": "SHORT",
            //                 "size": "-4.1368",
            //                 "maxSize": "-0.009",
            //                 "entryPrice": "112196.87848803433219017636",
            //                 "exitPrice": "113885.21872652924977050823",
            //                 "realizedPnl": "-15180.426770788459736511679821",
            //                 "unrealizedPnl": "17002.285719484425404321566048",
            //                 "createdAt": "2025-07-14T07:53:55.631Z",
            //                 "createdAtHeight": "44140908",
            //                 "closedAt": null,
            //                 "sumOpen": "5.3361",
            //                 "sumClose": "1.1983",
            //                 "netFunding": "-13157.288663",
            //                 "subaccountNumber": 0
            //             }
            //         },
            //         "assetPositions": {
            //             "USDC": {
            //                 "size": "608580.951601",
            //                 "symbol": "USDC",
            //                 "side": "LONG",
            //                 "assetId": "0",
            //                 "subaccountNumber": 0
            //             }
            //         },
            //         "marginEnabled": true,
            //         "updatedAtHeight": "52228833",
            //         "latestProcessedBlockHeight": "52246761"
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "subaccount")
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *DydxCore) ParseBalance(response interface{}) interface{}  {
    var account interface{} = this.Account()
    AddElementToObject(account, "free", this.SafeString(response, "freeCollateral"))
    var result interface{} = map[string]interface{} {
        "info": response,
        "USDC": account,
    }
    return this.SafeBalance(result)
}
func  (this *DydxCore) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *DydxCore) GetWalletAddress() interface{}  {
    if IsTrue(IsTrue(!IsEqual(this.WalletAddress, nil)) && IsTrue(!IsEqual(this.WalletAddress, ""))) {
        return this.WalletAddress
    }
    var dydxAccount interface{} = this.SafeDict(this.Options, "dydxAccount")
    if IsTrue(!IsEqual(dydxAccount, nil)) {
        // return dydxAccount;
        var wallet interface{} = this.SafeString(dydxAccount, "address")
        if IsTrue(!IsEqual(wallet, nil)) {
            return wallet
        }
    }
    panic(ArgumentsRequired(Add(this.Id, " getWalletAddress() requires a wallet address. Set `walletAddress` or `dydxAccount` in exchange options.")))
}
func  (this *DydxCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    section := GetArg(optionalArgs, 0, "public")
    _ = section
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var pathWithParams interface{} = this.ImplodeParams(path, params)
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), section))
    params = this.Omit(params, this.ExtractParams(path))
    params = this.Keysort(params)
    url = Add(url, Add("/", pathWithParams))
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        body = this.Json(params)
        headers = map[string]interface{} {
            "Content-type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *DydxCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    // abci response
    // { "result": { "code": 0 } }
    //
    // rest response
    // { "code": 123 }
    //
    var result interface{} = this.SafeDict(response, "result")
    var errorCode interface{} = this.SafeString(result, "code")
    if !IsTrue(errorCode) {
        errorCode = this.SafeString(response, "code")
    }
    if IsTrue(errorCode) {
        var errorCodeNum interface{} = this.ParseToNumeric(errorCode)
        if IsTrue(IsGreaterThan(errorCodeNum, 0)) {
            var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
            this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}
func  (this *DydxCore) SetSandboxMode(enable interface{})  {
    this.Exchange.SetSandboxMode(enable)
    // rewrite testnet parameters
    AddElementToObject(this.Options, "chainName", "dydx-testnet-4")
    AddElementToObject(this.Options, "chainId", 11155111)
    AddElementToObject(GetValue(this.Options, "feeDenom"), "CHAINTOKEN_DENOM", "adv4tnt")
}


func (this *DydxCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
