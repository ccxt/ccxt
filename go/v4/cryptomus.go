package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type CryptomusCore struct {
	Exchange
}

func NewCryptomusCore() *CryptomusCore {
	p := &CryptomusCore{}
	setDefaults(p)
	return p
}

func (this *CryptomusCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "cryptomus",
		"name":      "Cryptomus",
		"countries": []interface{}{"CA"},
		"rateLimit": 100,
		"version":   "v2",
		"certified": false,
		"pro":       false,
		"has": map[string]interface{}{
			"CORS":                                   nil,
			"spot":                                   true,
			"margin":                                 false,
			"swap":                                   false,
			"future":                                 false,
			"option":                                 false,
			"addMargin":                              false,
			"borrowCrossMargin":                      false,
			"borrowIsolatedMargin":                   false,
			"borrowMargin":                           false,
			"cancelAllOrders":                        false,
			"cancelAllOrdersAfter":                   false,
			"cancelOrder":                            true,
			"cancelOrders":                           false,
			"cancelWithdraw":                         false,
			"closeAllPositions":                      false,
			"closePosition":                          false,
			"createConvertTrade":                     false,
			"createDepositAddress":                   false,
			"createMarketBuyOrderWithCost":           false,
			"createMarketOrder":                      false,
			"createMarketOrderWithCost":              false,
			"createMarketSellOrderWithCost":          false,
			"createOrder":                            true,
			"createOrderWithTakeProfitAndStopLoss":   false,
			"createOrderWithTakeProfitAndStopLossWs": false,
			"createPostOnlyOrder":                    false,
			"createReduceOnlyOrder":                  false,
			"createStopLimitOrder":                   false,
			"createStopLossOrder":                    false,
			"createStopMarketOrder":                  false,
			"createStopOrder":                        false,
			"createTakeProfitOrder":                  false,
			"createTrailingAmountOrder":              false,
			"createTrailingPercentOrder":             false,
			"createTriggerOrder":                     false,
			"fetchAccounts":                          false,
			"fetchBalance":                           true,
			"fetchBorrowInterest":                    false,
			"fetchBorrowRate":                        false,
			"fetchBorrowRateHistories":               false,
			"fetchBorrowRateHistory":                 false,
			"fetchBorrowRates":                       false,
			"fetchBorrowRatesPerSymbol":              false,
			"fetchCanceledAndClosedOrders":           true,
			"fetchCanceledOrders":                    false,
			"fetchClosedOrder":                       false,
			"fetchClosedOrders":                      false,
			"fetchConvertCurrencies":                 false,
			"fetchConvertQuote":                      false,
			"fetchConvertTrade":                      false,
			"fetchConvertTradeHistory":               false,
			"fetchCrossBorrowRate":                   false,
			"fetchCrossBorrowRates":                  false,
			"fetchCurrencies":                        false,
			"fetchDepositAddress":                    false,
			"fetchDeposits":                          false,
			"fetchDepositsWithdrawals":               false,
			"fetchFundingHistory":                    false,
			"fetchFundingInterval":                   false,
			"fetchFundingIntervals":                  false,
			"fetchFundingRate":                       false,
			"fetchFundingRateHistory":                false,
			"fetchFundingRates":                      false,
			"fetchGreeks":                            false,
			"fetchIndexOHLCV":                        false,
			"fetchIsolatedBorrowRate":                false,
			"fetchIsolatedBorrowRates":               false,
			"fetchIsolatedPositions":                 false,
			"fetchLedger":                            false,
			"fetchLeverage":                          false,
			"fetchLeverages":                         false,
			"fetchLeverageTiers":                     false,
			"fetchLiquidations":                      false,
			"fetchLongShortRatio":                    false,
			"fetchLongShortRatioHistory":             false,
			"fetchMarginAdjustmentHistory":           false,
			"fetchMarginMode":                        false,
			"fetchMarginModes":                       false,
			"fetchMarketLeverageTiers":               false,
			"fetchMarkets":                           true,
			"fetchMarkOHLCV":                         false,
			"fetchMarkPrices":                        false,
			"fetchMyLiquidations":                    false,
			"fetchMySettlementHistory":               false,
			"fetchMyTrades":                          false,
			"fetchOHLCV":                             false,
			"fetchOpenInterest":                      false,
			"fetchOpenInterestHistory":               false,
			"fetchOpenInterests":                     false,
			"fetchOpenOrder":                         false,
			"fetchOpenOrders":                        true,
			"fetchOption":                            false,
			"fetchOptionChain":                       false,
			"fetchOrder":                             true,
			"fetchOrderBook":                         true,
			"fetchOrders":                            false,
			"fetchOrderTrades":                       false,
			"fetchPosition":                          false,
			"fetchPositionHistory":                   false,
			"fetchPositionMode":                      false,
			"fetchPositions":                         false,
			"fetchPositionsForSymbol":                false,
			"fetchPositionsHistory":                  false,
			"fetchPositionsRisk":                     false,
			"fetchPremiumIndexOHLCV":                 false,
			"fetchSettlementHistory":                 false,
			"fetchStatus":                            false,
			"fetchTicker":                            false,
			"fetchTickers":                           true,
			"fetchTime":                              false,
			"fetchTrades":                            true,
			"fetchTradingFee":                        false,
			"fetchTradingFees":                       true,
			"fetchTransactions":                      false,
			"fetchTransfers":                         false,
			"fetchVolatilityHistory":                 false,
			"fetchWithdrawals":                       false,
			"reduceMargin":                           false,
			"repayCrossMargin":                       false,
			"repayIsolatedMargin":                    false,
			"repayMargin":                            false,
			"sandbox":                                false,
			"setLeverage":                            false,
			"setMargin":                              false,
			"setMarginMode":                          false,
			"setPositionMode":                        false,
			"transfer":                               false,
			"withdraw":                               false,
		},
		"timeframes": map[string]interface{}{},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/8e0b1c48-7c01-4177-9224-f1b01d89d7e7",
			"api": map[string]interface{}{
				"public":  "https://api.cryptomus.com",
				"private": "https://api.cryptomus.com",
			},
			"www":      "https://cryptomus.com",
			"doc":      "https://doc.cryptomus.com/personal",
			"fees":     "https://cryptomus.com/tariffs",
			"referral": "https://app.cryptomus.com/signup/?ref=JRP4yj",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"v2/user-api/exchange/markets":                 1,
					"v2/user-api/exchange/market/price":            1,
					"v1/exchange/market/assets":                    1,
					"v1/exchange/market/order-book/{currencyPair}": 1,
					"v1/exchange/market/tickers":                   1,
					"v1/exchange/market/trades/{currencyPair}":     1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"v2/user-api/exchange/orders":          1,
					"v2/user-api/exchange/orders/history":  1,
					"v2/user-api/exchange/account/balance": 1,
					"v2/user-api/exchange/account/tariffs": 1,
					"v2/user-api/payment/services":         1,
					"v2/user-api/payout/services":          1,
					"v2/user-api/transaction/list":         1,
				},
				"post": map[string]interface{}{
					"v2/user-api/exchange/orders":        1,
					"v2/user-api/exchange/orders/market": 1,
				},
				"delete": map[string]interface{}{
					"v2/user-api/exchange/orders/{orderId}": 1,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"percentage": true,
				"feeSide":    "get",
				"maker":      this.ParseNumber("0.02"),
				"taker":      this.ParseNumber("0.02"),
			},
		},
		"options": map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": true,
			"networks": map[string]interface{}{
				"BEP20":   "bsc",
				"DASH":    "dash",
				"POLYGON": "polygon",
				"ARB":     "arbitrum",
				"SOL":     "sol",
				"TON":     "ton",
				"ERC20":   "eth",
				"TRC20":   "tron",
				"LTC":     "ltc",
				"XMR":     "xmr",
				"BCH":     "bch",
				"DOGE":    "doge",
				"AVAX":    "avalanche",
				"BTC":     "btc",
				"RUB":     "rub",
			},
			"networksById": map[string]interface{}{
				"bsc":       "BEP20",
				"dash":      "DASH",
				"polygon":   "POLYGON",
				"arbitrum":  "ARB",
				"sol":       "SOL",
				"ton":       "TON",
				"eth":       "ERC20",
				"tron":      "TRC20",
				"ltc":       "LTC",
				"xmr":       "XMR",
				"bch":       "BCH",
				"doge":      "DOGE",
				"avalanche": "AVAX",
				"btc":       "BTC",
				"rub":       "RUB",
			},
			"fetchOrderBook": map[string]interface{}{
				"level": 0,
			},
		},
		"commonCurrencies": map[string]interface{}{},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"500":                    ExchangeError,
				"6":                      InsufficientFunds,
				"Insufficient funds.":    InsufficientFunds,
				"Minimum amount 15 USDT": InvalidOrder,
			},
			"broad": map[string]interface{}{},
		},
		"precisionMode": TICK_SIZE,
		"requiredCredentials": map[string]interface{}{
			"apiKey": false,
			"uid":    true,
		},
		"features": map[string]interface{}{},
	})
}

/**
 * @method
 * @name cryptomus#fetchMarkets
 * @description retrieves data on all markets for the exchange
 * @see https://doc.cryptomus.com/personal/market-cap/tickers
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *CryptomusCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetV2UserApiExchangeMarkets(params))
		PanicOnError(response)
		//
		//     {
		//         "result": [
		//             {
		//                 "id": "01JHN5EFT64YC4HR9KCGM5M65D",
		//                 "symbol": "POL_USDT",
		//                 "baseCurrency": "POL",
		//                 "quoteCurrency": "USDT",
		//                 "baseMinSize": "1.00000000",
		//                 "quoteMinSize": "5.00000000",
		//                 "baseMaxSize": "50000.00000000",
		//                 "quoteMaxSize": "10000000000.00000000",
		//                 "basePrec": "1",
		//                 "quotePrec": "4"
		//             },
		//             ...
		//         ]
		//     }
		//
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseMarkets(result)
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseMarket(market interface{}) interface{} {
	//
	//     {
	//         "id": "01JHN5EFT64YC4HR9KCGM5M65D",
	//         "symbol": "POL_USDT",
	//         "baseCurrency": "POL",
	//         "quoteCurrency": "USDT",
	//         "baseMinSize": "1.00000000",
	//         "quoteMinSize": "5.00000000",
	//         "baseMaxSize": "50000.00000000",
	//         "quoteMaxSize": "10000000000.00000000",
	//         "basePrec": "1",
	//         "quotePrec": "4"
	//     }
	//
	var marketId interface{} = this.SafeString(market, "symbol")
	var parts interface{} = Split(marketId, "_")
	var baseId interface{} = GetValue(parts, 0)
	var quoteId interface{} = GetValue(parts, 1)
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var fees interface{} = this.SafeDict(this.Fees, "trading")
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             marketId,
		"symbol":         Add(Add(base, "/"), quote),
		"base":           base,
		"quote":          quote,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"active":         true,
		"type":           "spot",
		"subType":        nil,
		"spot":           true,
		"margin":         false,
		"swap":           false,
		"future":         false,
		"option":         false,
		"contract":       false,
		"settle":         nil,
		"settleId":       nil,
		"contractSize":   nil,
		"linear":         nil,
		"inverse":        nil,
		"taker":          this.SafeNumber(fees, "taker"),
		"maker":          this.SafeNumber(fees, "maker"),
		"percentage":     this.SafeBool(fees, "percentage"),
		"tierBased":      nil,
		"feeSide":        this.SafeString(fees, "feeSide"),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quotePrec"))),
			"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "basePrec"))),
		},
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": this.SafeNumber(market, "quoteMinSize"),
				"max": this.SafeNumber(market, "quoteMaxSize"),
			},
			"price": map[string]interface{}{
				"min": this.SafeNumber(market, "baseMinSize"),
				"max": this.SafeNumber(market, "baseMaxSize"),
			},
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"created": nil,
		"info":    market,
	})
}

/**
 * @method
 * @name cryptomus#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://doc.cryptomus.com/personal/market-cap/assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *CryptomusCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetV1ExchangeMarketAssets(params))
		PanicOnError(response)
		//
		//     {
		//         'state': '0',
		//         'result': [
		//             {
		//                 'currency_code': 'USDC',
		//                 'network_code': 'bsc',
		//                 'can_withdraw': true,
		//                 'can_deposit': true,
		//                 'min_withdraw': '1.00000000',
		//                 'max_withdraw': '10000000.00000000',
		//                 'max_deposit': '10000000.00000000',
		//                 'min_deposit': '1.00000000'
		//             },
		//             ...
		//         ]
		//     }
		//
		var coins interface{} = this.SafeList(response, "result")
		var groupedById interface{} = this.GroupBy(coins, "currency_code")
		var keys interface{} = ObjectKeys(groupedById)
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
			var id interface{} = GetValue(keys, i)
			var code interface{} = this.SafeCurrencyCode(id)
			var networks interface{} = map[string]interface{}{}
			var networkEntries interface{} = GetValue(groupedById, id)
			for j := 0; IsLessThan(j, GetArrayLength(networkEntries)); j++ {
				var networkEntry interface{} = GetValue(networkEntries, j)
				var networkId interface{} = this.SafeString(networkEntry, "network_code")
				var networkCode interface{} = this.NetworkIdToCode(networkId)
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"id":      networkId,
					"network": networkCode,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(networkEntry, "min_withdraw"),
							"max": this.SafeNumber(networkEntry, "max_withdraw"),
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(networkEntry, "min_deposit"),
							"max": this.SafeNumber(networkEntry, "max_deposit"),
						},
					},
					"active":    nil,
					"deposit":   this.SafeBool(networkEntry, "can_withdraw"),
					"withdraw":  this.SafeBool(networkEntry, "can_deposit"),
					"fee":       nil,
					"precision": nil,
					"info":      networkEntry,
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":       id,
				"code":     code,
				"networks": networks,
				"info":     networkEntries,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptomus#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://doc.cryptomus.com/personal/market-cap/tickers
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *CryptomusCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes4638 := (<-this.LoadMarkets())
		PanicOnError(retRes4638)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.PublicGetV1ExchangeMarketTickers(params))
		PanicOnError(response)
		//
		//     {
		//         "data": [
		//         {
		//             "currency_pair": "MATIC_USDT",
		//             "last_price": "0.342",
		//             "base_volume": "1676.84092771",
		//             "quote_volume": "573.48033609043"
		//         },
		//         ...
		//     }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "currency_pair": "XMR_USDT",
	//         "last_price": "158.04829772",
	//         "base_volume": "0.35185785",
	//         "quote_volume": "55.523761128544"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "currency_pair")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var last interface{} = this.SafeString(ticker, "last_price")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     nil,
		"datetime":      nil,
		"high":          nil,
		"low":           nil,
		"bid":           nil,
		"bidVolume":     nil,
		"ask":           nil,
		"askVolume":     nil,
		"vwap":          nil,
		"open":          nil,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    this.SafeString(ticker, "base_volume"),
		"quoteVolume":   this.SafeString(ticker, "quote_volume"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name cryptomus#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://doc.cryptomus.com/personal/market-cap/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.level] 0 or 1 or 2 or 3 or 4 or 5 - the level of volume
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *CryptomusCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes5318 := (<-this.LoadMarkets())
		PanicOnError(retRes5318)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"currencyPair": GetValue(market, "id"),
		}
		var level interface{} = 0
		levelparamsVariable := this.HandleOptionAndParams(params, "fetchOrderBook", "level", level)
		level = GetValue(levelparamsVariable, 0)
		params = GetValue(levelparamsVariable, 1)
		AddElementToObject(request, "level", level)

		response := (<-this.PublicGetV1ExchangeMarketOrderBookCurrencyPair(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "data": {
		//             "timestamp": "1730138702",
		//             "bids": [
		//                 {
		//                     "price": "2250.00",
		//                     "quantity": "1.00000"
		//                 }
		//             ],
		//             "asks": [
		//                 {
		//                     "price": "2428.69",
		//                     "quantity": "0.16470"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var timestamp interface{} = this.SafeTimestamp(data, "timestamp")

		ch <- this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "quantity")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptomus#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://doc.cryptomus.com/personal/market-cap/trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (maximum value is 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *CryptomusCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes5768 := (<-this.LoadMarkets())
		PanicOnError(retRes5768)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"currencyPair": GetValue(market, "id"),
		}

		response := (<-this.PublicGetV1ExchangeMarketTradesCurrencyPair(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "data": [
		//             {
		//                 "trade_id": "01J829C3RAXHXHR09HABGQ1YAT",
		//                 "price": "2315.6320500000000000",
		//                 "base_volume": "21.9839623057260000",
		//                 "quote_volume": "0.0094937200000000",
		//                 "timestamp": 1726653796,
		//                 "type": "sell"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "trade_id": "01J017Q6B3JGHZRP9D2NZHVKFX",
	//         "price": "59498.63487492",
	//         "base_volume": "94.00784310",
	//         "quote_volume": "0.00158000",
	//         "timestamp": 1718028573,
	//         "type": "sell"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeTimestamp(trade, "timestamp")
	return this.SafeTrade(map[string]interface{}{
		"id":           this.SafeString(trade, "trade_id"),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"side":         this.SafeString(trade, "type"),
		"price":        this.SafeString(trade, "price"),
		"amount":       this.SafeString(trade, "quote_volume"),
		"cost":         this.SafeString(trade, "base_volume"),
		"takerOrMaker": nil,
		"type":         nil,
		"order":        nil,
		"fee": map[string]interface{}{
			"currency": nil,
			"cost":     nil,
		},
		"info": trade,
	}, market)
}

/**
 * @method
 * @name cryptomus#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://doc.cryptomus.com/personal/converts/balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *CryptomusCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes6418 := (<-this.LoadMarkets())
		PanicOnError(retRes6418)
		var request interface{} = map[string]interface{}{}

		response := (<-this.PrivateGetV2UserApiExchangeAccountBalance(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "result": [
		//             {
		//                 "ticker": "AVAX",
		//                 "available": "0.00000000",
		//                 "held": "0.00000000"
		//             }
		//         ]
		//     }
		//
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseBalance(result)
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseBalance(balance interface{}) interface{} {
	//
	//     {
	//         "ticker": "AVAX",
	//         "available": "0.00000000",
	//         "held": "0.00000000"
	//     }
	//
	var result interface{} = map[string]interface{}{
		"info": balance,
	}
	for i := 0; IsLessThan(i, GetArrayLength(balance)); i++ {
		var balanceEntry interface{} = GetValue(balance, i)
		var currencyId interface{} = this.SafeString(balanceEntry, "ticker")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		AddElementToObject(account, "free", this.SafeString(balanceEntry, "available"))
		AddElementToObject(account, "used", this.SafeString(balanceEntry, "held"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name cryptomus#createOrder
 * @description create a trade order
 * @see https://doc.cryptomus.com/personal/exchange/market-order-creation
 * @see https://doc.cryptomus.com/personal/exchange/limit-order-creation
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or for spot
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders (only for limit orders)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {string} [params.clientOrderId] a unique identifier for the order (optional)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptomusCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes6998 := (<-this.LoadMarkets())
		PanicOnError(retRes6998)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"market":    GetValue(market, "id"),
			"direction": side,
			"tag":       "ccxt",
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			params = this.Omit(params, "clientOrderId")
			AddElementToObject(request, "client_order_id", clientOrderId)
		}
		var sideBuy interface{} = IsEqual(side, "buy")
		var amountToString interface{} = this.NumberToString(amount)
		var priceToString interface{} = this.NumberToString(price)
		var cost interface{} = nil
		costparamsVariable := this.HandleParamString(params, "cost")
		cost = GetValue(costparamsVariable, 0)
		params = GetValue(costparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "market")) {
			if IsTrue(sideBuy) {
				var createMarketBuyOrderRequiresPrice interface{} = true
				createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
				createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
				params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
				if IsTrue(createMarketBuyOrderRequiresPrice) {
					if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option of param to false and pass the cost to spend in the amount argument")))
					} else if IsTrue(IsEqual(cost, nil)) {
						cost = Precise.StringMul(amountToString, priceToString)
					}
				} else {
					cost = Ternary(IsTrue(cost), cost, amountToString)
				}
				AddElementToObject(request, "value", cost)
			} else {
				AddElementToObject(request, "quantity", amountToString)
			}

			response = (<-this.PrivatePostV2UserApiExchangeOrdersMarket(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "limit")) {
			if IsTrue(IsEqual(price, nil)) {
				panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price parameter for a "), typeVar), " order")))
			}
			AddElementToObject(request, "quantity", amountToString)
			AddElementToObject(request, "price", price)

			response = (<-this.PrivatePostV2UserApiExchangeOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a type parameter (limit or market)")))
		}

		//
		//     {
		//         "order_id": "01JEXAFCCC5ZVJPZAAHHDKQBMG"
		//     }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptomus#cancelOrder
 * @description cancels an open limit order
 * @see https://doc.cryptomus.com/personal/exchange/limit-order-cancellation
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in (not used in cryptomus)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptomusCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes7648 := (<-this.LoadMarkets())
		PanicOnError(retRes7648)
		var request interface{} = map[string]interface{}{}
		AddElementToObject(request, "orderId", id)

		response := (<-this.PrivateDeleteV2UserApiExchangeOrdersOrderId(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "success": true
		//     }
		//
		ch <- this.SafeOrder(map[string]interface{}{
			"info": response,
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptomus#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://doc.cryptomus.com/personal/exchange/history-of-completed-orders
 * @param {string} symbol unified market symbol of the market orders were made in (not used in cryptomus)
 * @param {int} [since] the earliest time in ms to fetch orders for (not used in cryptomus)
 * @param {int} [limit] the maximum number of order structures to retrieve (not used in cryptomus)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.direction] order direction 'buy' or 'sell'
 * @param {string} [params.order_id] order id
 * @param {string} [params.client_order_id] client order id
 * @param {string} [params.limit] A special parameter that sets the maximum number of records the request will return
 * @param {string} [params.offset] A special parameter that sets the number of records from the beginning of the list
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptomusCore) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes7938 := (<-this.LoadMarkets())
		PanicOnError(retRes7938)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "market", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetV2UserApiExchangeOrdersHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "result": [
		//             {
		//                 "id": "01JEXAPY04JDFBVFC2D23BCKMK",
		//                 "type": "market",
		//                 "direction": "sell",
		//                 "symbol": "TRX_USDT",
		//                 "quantity": "67.5400000000000000",
		//                 "filledQuantity": "67.5400000000000000",
		//                 "filledValue": "20.0053480000000000",
		//                 "state": "completed",
		//                 "internalState": "filled",
		//                 "createdAt": "2024-12-12 11:40:19",
		//                 "finishedAt": "2024-12-12 11:40:21",
		//                 "deal": {
		//                     "id": "01JEXAPZ9C9TWENPFZJASZ1YD2",
		//                     "state": "completed",
		//                     "createdAt": "2024-12-12 11:40:21",
		//                     "completedAt": "2024-12-12 11:40:21",
		//                     "averageFilledPrice": "0.2962000000000000",
		//                     "transactions": [
		//                         {
		//                             "id": "01JEXAPZ9C9TWENPFZJASZ1YD3",
		//                             "tradeRole": "taker",
		//                             "filledPrice": "0.2962000000000000",
		//                             "filledQuantity": "67.5400000000000000",
		//                             "filledValue": "20.0053480000000000",
		//                             "fee": "0.0000000000000000",
		//                             "feeCurrency": "USDT",
		//                             "committedAt": "2024-12-12 11:40:21"
		//                         }
		//                     ]
		//                 }
		//             },
		//             ...
		//         ]
		//     }
		//
		var result interface{} = this.SafeList(response, "result", []interface{}{})
		var orders interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
			var order interface{} = GetValue(result, i)
			AppendToArray(&orders, this.ParseOrder(order, market))
		}

		ch <- orders
		return nil

	}()
	return ch
}

/**
 * @method
 * @name cryptomus#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://doc.cryptomus.com/personal/exchange/list-of-active-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for (not used in cryptomus)
 * @param {int} [limit] the maximum number of  open orders structures to retrieve (not used in cryptomus)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.direction] order direction 'buy' or 'sell'
 * @param {string} [params.order_id] order id
 * @param {string} [params.client_order_id] client order id
 * @param {string} [params.limit] A special parameter that sets the maximum number of records the request will return
 * @param {string} [params.offset] A special parameter that sets the number of records from the beginning of the list
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *CryptomusCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes8698 := (<-this.LoadMarkets())
		PanicOnError(retRes8698)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(market, nil)) {
			AddElementToObject(request, "market", GetValue(market, "id"))
		}

		response := (<-this.PrivateGetV2UserApiExchangeOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "result": [
		//             {
		//                 "id": "01JFFG72CBRDP68K179KC9DSTG",
		//                 "direction": "sell",
		//                 "symbol": "BTC_USDT",
		//                 "price": "102.0130000000000000",
		//                 "quantity": "0.0005000000000000",
		//                 "value": "0.0510065000000000",
		//                 "filledQuantity": "0.0000000000000000",
		//                 "filledValue": "0.0000000000000000",
		//                 "createdAt": "2024-12-19 09:02:51",
		//                 "clientOrderId": "987654321",
		//                 "stopLossPrice": "101.12"
		//             },
		//             ...
		//         ]
		//     }
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseOrders(result, market, nil, nil)
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder
	//     {
	//         "order_id": "01JEXAFCCC5ZVJPZAAHHDKQBNG"
	//     }
	//
	// fetchOrders
	//     {
	//         "id": "01JEXAPY04JDFBVFC2D23BCKMK",
	//         "type": "market",
	//         "direction": "sell",
	//         "symbol": "TRX_USDT",
	//         "quantity": "67.5400000000000000",
	//         "filledQuantity": "67.5400000000000000",
	//         "filledValue": "20.0053480000000000",
	//         "state": "completed",
	//         "internalState": "filled",
	//         "createdAt": "2024-12-12 11:40:19",
	//         "finishedAt": "2024-12-12 11:40:21",
	//         "deal": {
	//             "id": "01JEXAPZ9C9TWENPFZJASZ1YD2",
	//             "state": "completed",
	//             "createdAt": "2024-12-12 11:40:21",
	//             "completedAt": "2024-12-12 11:40:21",
	//             "averageFilledPrice": "0.2962000000000000",
	//             "transactions": [
	//                 {
	//                     "id": "01JEXAPZ9C9TWENPFZJASZ1YD3",
	//                     "tradeRole": "taker",
	//                     "filledPrice": "0.2962000000000000",
	//                     "filledQuantity": "67.5400000000000000",
	//                     "filledValue": "20.0053480000000000",
	//                     "fee": "0.0000000000000000",
	//                     "feeCurrency": "USDT",
	//                     "committedAt": "2024-12-12 11:40:21"
	//                 }
	//             ]
	//         }
	//     },
	//     ...
	//
	// fetchOpenOrders
	//     {
	//         "id": "01JFFG72CBRDP68K179KC9DSTG",
	//         "direction": "sell",
	//         "symbol": "BTC_USDT",
	//         "price": "102.0130000000000000",
	//         "quantity": "0.0005000000000000",
	//         "value": "0.0510065000000000",
	//         "filledQuantity": "0.0000000000000000",
	//         "filledValue": "0.0000000000000000",
	//         "createdAt": "2024-12-19 09:02:51",
	//         "clientOrderId": "987654321",
	//         "stopLossPrice": "101.12"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString2(order, "order_id", "id")
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var dateTime interface{} = this.SafeString(order, "createdAt")
	var timestamp interface{} = this.Parse8601(dateTime)
	var deal interface{} = this.SafeDict(order, "deal", map[string]interface{}{})
	var averageFilledPrice interface{} = this.SafeNumber(deal, "averageFilledPrice")
	var typeVar interface{} = this.SafeString(order, "type")
	var side interface{} = this.SafeString(order, "direction")
	var price interface{} = this.SafeNumber(order, "price")
	var transaction interface{} = this.SafeList(deal, "transactions", []interface{}{})
	var fee interface{} = nil
	var firstTx interface{} = this.SafeDict(transaction, 0)
	var feeCurrency interface{} = this.SafeString(firstTx, "feeCurrency")
	if IsTrue(!IsEqual(feeCurrency, nil)) {
		fee = map[string]interface{}{
			"currency": this.SafeCurrencyCode(feeCurrency),
			"cost":     this.SafeNumber(firstTx, "fee"),
		}
	}
	if IsTrue(IsEqual(price, nil)) {
		price = this.SafeNumber(firstTx, "filledPrice")
	}
	var amount interface{} = this.SafeNumber(order, "quantity")
	var cost interface{} = this.SafeNumber(order, "value")
	var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
	var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      clientOrderId,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"symbol":             GetValue(market, "symbol"),
		"type":               typeVar,
		"timeInForce":        nil,
		"postOnly":           nil,
		"side":               side,
		"price":              price,
		"stopPrice":          this.SafeString(order, "stopLossPrice"),
		"triggerPrice":       this.SafeString(order, "stopLossPrice"),
		"amount":             amount,
		"cost":               cost,
		"average":            averageFilledPrice,
		"filled":             this.SafeString(order, "filledQuantity"),
		"remaining":          nil,
		"status":             status,
		"fee":                fee,
		"trades":             nil,
		"info":               order,
	}, market)
}
func (this *CryptomusCore) ParseOrderStatus(optionalArgs ...interface{}) interface{} {
	status := GetArg(optionalArgs, 0, nil)
	_ = status
	var statuses interface{} = map[string]interface{}{
		"active":              "open",
		"completed":           "closed",
		"partially_completed": "open",
		"cancelled":           "canceled",
		"expired":             "expired",
		"failed":              "failed",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name cryptomus#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-fees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure} indexed by market symbols
 */
func (this *CryptomusCore) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PrivateGetV2UserApiExchangeAccountTariffs(params))
		PanicOnError(response)
		//
		//     {
		//         result: {
		//             equivalent_currency_code: 'USD',
		//             current_tariff_step: {
		//                 step: '0',
		//                 from_turnover: '0.00000000',
		//                 maker_percent: '0.08',
		//                 taker_percent: '0.1'
		//             },
		//             tariff_steps: [
		//                 {
		//                     step: '0',
		//                     from_turnover: '0.00000000',
		//                     maker_percent: '0.08',
		//                     taker_percent: '0.1'
		//                 },
		//                 {
		//                     step: '1',
		//                     from_turnover: '100001.00000000',
		//                     maker_percent: '0.06',
		//                     taker_percent: '0.095'
		//                 },
		//                 {
		//                     step: '2',
		//                     from_turnover: '250001.00000000',
		//                     maker_percent: '0.055',
		//                     taker_percent: '0.085'
		//                 },
		//                 {
		//                     step: '3',
		//                     from_turnover: '500001.00000000',
		//                     maker_percent: '0.05',
		//                     taker_percent: '0.075'
		//                 },
		//                 {
		//                     step: '4',
		//                     from_turnover: '2500001.00000000',
		//                     maker_percent: '0.04',
		//                     taker_percent: '0.07'
		//                 }
		//             ],
		//             daily_turnover: '0.00000000',
		//             monthly_turnover: '77.52062617',
		//             circulation_funds: '25.48900443'
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "result", map[string]interface{}{})
		var currentFeeTier interface{} = this.SafeDict(data, "current_tariff_step", map[string]interface{}{})
		var makerFee interface{} = this.SafeString(currentFeeTier, "maker_percent")
		var takerFee interface{} = this.SafeString(currentFeeTier, "taker_percent")
		makerFee = Precise.StringDiv(makerFee, "100")
		takerFee = Precise.StringDiv(takerFee, "100")
		var feeTiers interface{} = this.SafeList(data, "tariff_steps", []interface{}{})
		var result interface{} = map[string]interface{}{}
		var tiers interface{} = this.ParseFeeTiers(feeTiers)
		for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
			var symbol interface{} = GetValue(this.Symbols, i)
			AddElementToObject(result, symbol, map[string]interface{}{
				"info":       response,
				"symbol":     symbol,
				"maker":      this.ParseNumber(makerFee),
				"taker":      this.ParseNumber(takerFee),
				"percentage": true,
				"tierBased":  true,
				"tiers":      tiers,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *CryptomusCore) ParseFeeTiers(feeTiers interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var takerFees interface{} = []interface{}{}
	var makerFees interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(feeTiers)); i++ {
		var tier interface{} = GetValue(feeTiers, i)
		var turnover interface{} = this.SafeNumber(tier, "from_turnover")
		var taker interface{} = this.SafeString(tier, "taker_percent")
		var maker interface{} = this.SafeString(tier, "maker_percent")
		maker = Precise.StringDiv(maker, "100")
		taker = Precise.StringDiv(taker, "100")
		AppendToArray(&makerFees, []interface{}{turnover, this.ParseNumber(maker)})
		AppendToArray(&takerFees, []interface{}{turnover, this.ParseNumber(taker)})
	}
	return map[string]interface{}{
		"maker": makerFees,
		"taker": takerFees,
	}
}
func (this *CryptomusCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var endpoint interface{} = this.ImplodeParams(path, params)
	params = this.Omit(params, this.ExtractParams(path))
	var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), endpoint)
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		var jsonParams interface{} = ""
		headers = map[string]interface{}{
			"userId": this.Uid,
		}
		if IsTrue(!IsEqual(method, "GET")) {
			body = this.Json(params)
			jsonParams = body
			AddElementToObject(headers, "Content-Type", "application/json")
		} else {
			var query interface{} = this.Urlencode(params)
			if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
				url = Add(url, Add("?", query))
			}
		}
		var jsonParamsBase64 interface{} = this.StringToBase64(jsonParams)
		var stringToSign interface{} = Add(jsonParamsBase64, this.Secret)
		var signature interface{} = this.Hash(this.Encode(stringToSign), md5)
		AddElementToObject(headers, "sign", signature)
	} else {
		var query interface{} = this.Urlencode(params)
		if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
			url = Add(url, Add("?", query))
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *CryptomusCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	if IsTrue(InOp(response, "code")) {
		var code interface{} = this.SafeString(response, "code")
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		panic(ExchangeError(feedback))
	} else if IsTrue(InOp(response, "message")) {
		//
		//      {"message":"Minimum amount 15 USDT","state":1}
		//
		var message interface{} = this.SafeString(response, "message")
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *CryptomusCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
