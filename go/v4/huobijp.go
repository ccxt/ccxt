package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type huobijp struct {
    Exchange

}

func NewHuobijpCore() huobijp {
   p := huobijp{}
   setDefaults(&p)
   return p
}

func  (this *huobijp) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "huobijp",
        "name": "Huobi Japan",
        "countries": []interface{}{"JP"},
        "rateLimit": 100,
        "userAgent": GetValue(this.UserAgents, "chrome39"),
        "certified": false,
        "version": "v1",
        "hostname": "api-cloud.bittrade.co.jp",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingLimits": true,
            "fetchWithdrawals": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "5m": "5min",
            "15m": "15min",
            "30m": "30min",
            "1h": "60min",
            "4h": "4hour",
            "1d": "1day",
            "1w": "1week",
            "1M": "1mon",
            "1y": "1year",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg",
            "api": map[string]interface{} {
                "market": "https://{hostname}",
                "public": "https://{hostname}",
                "private": "https://{hostname}",
                "v2Public": "https://{hostname}",
                "v2Private": "https://{hostname}",
            },
            "www": "https://www.huobi.co.jp",
            "referral": "https://www.huobi.co.jp/register/?invite_code=znnq3",
            "doc": "https://api-doc.huobi.co.jp",
            "fees": "https://www.huobi.co.jp/support/fee",
        },
        "api": map[string]interface{} {
            "v2Public": map[string]interface{} {
                "get": map[string]interface{} {
                    "reference/currencies": 1,
                    "market-status": 1,
                },
            },
            "v2Private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account/ledger": 1,
                    "account/withdraw/quota": 1,
                    "account/withdraw/address": 1,
                    "account/deposit/address": 1,
                    "account/repayment": 5,
                    "reference/transact-fee-rate": 1,
                    "account/asset-valuation": 0.2,
                    "point/account": 5,
                    "sub-user/user-list": 1,
                    "sub-user/user-state": 1,
                    "sub-user/account-list": 1,
                    "sub-user/deposit-address": 1,
                    "sub-user/query-deposit": 1,
                    "user/api-key": 1,
                    "user/uid": 1,
                    "algo-orders/opening": 1,
                    "algo-orders/history": 1,
                    "algo-orders/specific": 1,
                    "c2c/offers": 1,
                    "c2c/offer": 1,
                    "c2c/transactions": 1,
                    "c2c/repayment": 1,
                    "c2c/account": 1,
                    "etp/reference": 1,
                    "etp/transactions": 5,
                    "etp/transaction": 5,
                    "etp/rebalance": 1,
                    "etp/limit": 1,
                },
                "post": map[string]interface{} {
                    "account/transfer": 1,
                    "account/repayment": 5,
                    "point/transfer": 5,
                    "sub-user/management": 1,
                    "sub-user/creation": 1,
                    "sub-user/tradable-market": 1,
                    "sub-user/transferability": 1,
                    "sub-user/api-key-generation": 1,
                    "sub-user/api-key-modification": 1,
                    "sub-user/api-key-deletion": 1,
                    "sub-user/deduct-mode": 1,
                    "algo-orders": 1,
                    "algo-orders/cancel-all-after": 1,
                    "algo-orders/cancellation": 1,
                    "c2c/offer": 1,
                    "c2c/cancellation": 1,
                    "c2c/cancel-all": 1,
                    "c2c/repayment": 1,
                    "c2c/transfer": 1,
                    "etp/creation": 5,
                    "etp/redemption": 5,
                    "etp/{transactId}/cancel": 10,
                    "etp/batch-cancel": 50,
                },
            },
            "market": map[string]interface{} {
                "get": map[string]interface{} {
                    "history/kline": 1,
                    "detail/merged": 1,
                    "depth": 1,
                    "trade": 1,
                    "history/trade": 1,
                    "detail": 1,
                    "tickers": 1,
                    "etp": 1,
                },
            },
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "common/symbols": 1,
                    "common/currencys": 1,
                    "common/timestamp": 1,
                    "common/exchange": 1,
                    "settings/currencys": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account/accounts": 0.2,
                    "account/accounts/{id}/balance": 0.2,
                    "account/accounts/{sub-uid}": 1,
                    "account/history": 4,
                    "cross-margin/loan-info": 1,
                    "margin/loan-info": 1,
                    "fee/fee-rate/get": 1,
                    "order/openOrders": 0.4,
                    "order/orders": 0.4,
                    "order/orders/{id}": 0.4,
                    "order/orders/{id}/matchresults": 0.4,
                    "order/orders/getClientOrder": 0.4,
                    "order/history": 1,
                    "order/matchresults": 1,
                    "query/deposit-withdraw": 1,
                    "margin/loan-orders": 0.2,
                    "margin/accounts/balance": 0.2,
                    "cross-margin/loan-orders": 1,
                    "cross-margin/accounts/balance": 1,
                    "points/actions": 1,
                    "points/orders": 1,
                    "subuser/aggregate-balance": 10,
                    "stable-coin/exchange_rate": 1,
                    "stable-coin/quote": 1,
                },
                "post": map[string]interface{} {
                    "account/transfer": 1,
                    "futures/transfer": 1,
                    "order/batch-orders": 0.4,
                    "order/orders/place": 0.2,
                    "order/orders/submitCancelClientOrder": 0.2,
                    "order/orders/batchCancelOpenOrders": 0.4,
                    "order/orders/{id}/submitcancel": 0.2,
                    "order/orders/batchcancel": 0.4,
                    "dw/withdraw/api/create": 1,
                    "dw/withdraw-virtual/{id}/cancel": 1,
                    "dw/transfer-in/margin": 10,
                    "dw/transfer-out/margin": 10,
                    "margin/orders": 10,
                    "margin/orders/{id}/repay": 10,
                    "cross-margin/transfer-in": 1,
                    "cross-margin/transfer-out": 1,
                    "cross-margin/orders": 1,
                    "cross-margin/orders/{id}/repay": 1,
                    "stable-coin/exchange": 1,
                    "subuser/transfer": 10,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 120,
                    "untilDays": 2,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "broad": map[string]interface{} {
                "contract is restricted of closing positions on API.  Please contact customer service": OnMaintenance,
                "maintain": OnMaintenance,
            },
            "exact": map[string]interface{} {
                "bad-request": BadRequest,
                "base-date-limit-error": BadRequest,
                "api-not-support-temp-addr": PermissionDenied,
                "timeout": RequestTimeout,
                "gateway-internal-error": ExchangeNotAvailable,
                "account-frozen-balance-insufficient-error": InsufficientFunds,
                "invalid-amount": InvalidOrder,
                "order-limitorder-amount-min-error": InvalidOrder,
                "order-limitorder-amount-max-error": InvalidOrder,
                "order-marketorder-amount-min-error": InvalidOrder,
                "order-limitorder-price-min-error": InvalidOrder,
                "order-limitorder-price-max-error": InvalidOrder,
                "order-holding-limit-failed": InvalidOrder,
                "order-orderprice-precision-error": InvalidOrder,
                "order-etp-nav-price-max-error": InvalidOrder,
                "order-orderstate-error": OrderNotFound,
                "order-queryorder-invalid": OrderNotFound,
                "order-update-error": ExchangeNotAvailable,
                "api-signature-check-failed": AuthenticationError,
                "api-signature-not-valid": AuthenticationError,
                "base-record-invalid": OrderNotFound,
                "base-symbol-trade-disabled": BadSymbol,
                "base-symbol-error": BadSymbol,
                "system-maintenance": OnMaintenance,
                "invalid symbol": BadSymbol,
                "symbol trade not open now": BadSymbol,
                "invalid-address": BadRequest,
                "base-currency-chain-error": BadRequest,
                "dw-insufficient-balance": InsufficientFunds,
            },
        },
        "options": map[string]interface{} {
            "defaultNetwork": "ERC20",
            "networks": map[string]interface{} {
                "ETH": "erc20",
                "TRX": "trc20",
                "HRC20": "hrc20",
                "HECO": "hrc20",
                "HT": "hrc20",
                "ALGO": "algo",
                "OMNI": "",
            },
            "fetchOrdersByStatesMethod": "private_get_order_orders",
            "fetchOpenOrdersMethod": "fetch_open_orders_v1",
            "createMarketBuyOrderRequiresPrice": true,
            "fetchMarketsMethod": "publicGetCommonSymbols",
            "fetchBalanceMethod": "privateGetAccountAccountsIdBalance",
            "createOrderMethod": "privatePostOrderOrdersPlace",
            "currencyToPrecisionRoundingMode": TRUNCATE,
            "language": "en-US",
            "broker": map[string]interface{} {
                "id": "AA03022abc",
            },
        },
        "commonCurrencies": map[string]interface{} {
            "GET": "Themis",
            "GTC": "Game.com",
            "HIT": "HitChain",
            "PNT": "Penta",
            "SBTC": "Super Bitcoin",
            "BIFI": "Bitcoin File",
        },
    })
}
/**
 * @method
 * @name huobijp#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *huobijp) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCommonTimestamp(params))
            PanicOnError(response)
        
            ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) FetchTradingLimits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method should not be called directly, use loadTradingLimits () instead
            //  by default it will try load withdrawal fees of all currencies (with separate requests)
            //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
            symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes522500 := (<-this.LoadMarkets())
            PanicOnError(retRes522500)
            if IsTrue(IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                var symbol interface{} = GetValue(symbols, i)
                AddElementToObject(result, symbol, (<-this.FetchTradingLimitsById(this.MarketId(symbol), params)))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) FetchTradingLimitsById(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "symbol": id,
            }
        
            response:= (<-this.PublicGetCommonExchange(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     { status:   "ok",
            //         "data": {                                  symbol: "aidocbtc",
            //                              "buy-limit-must-less-than":  1.1,
            //                          "sell-limit-must-greater-than":  0.9,
            //                         "limit-order-must-greater-than":  1,
            //                            "limit-order-must-less-than":  5000000,
            //                    "market-buy-order-must-greater-than":  0.0001,
            //                       "market-buy-order-must-less-than":  100,
            //                   "market-sell-order-must-greater-than":  1,
            //                      "market-sell-order-must-less-than":  500000,
            //                       "circuit-break-when-greater-than":  10000,
            //                          "circuit-break-when-less-than":  10,
            //                 "market-sell-order-rate-must-less-than":  0.1,
            //                  "market-buy-order-rate-must-less-than":  0.1        } }
            //
        ch <- this.ParseTradingLimits(this.SafeValue(response, "data", map[string]interface{} {}))
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseTradingLimits(limits interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   {                                  symbol: "aidocbtc",
    //                  "buy-limit-must-less-than":  1.1,
    //              "sell-limit-must-greater-than":  0.9,
    //             "limit-order-must-greater-than":  1,
    //                "limit-order-must-less-than":  5000000,
    //        "market-buy-order-must-greater-than":  0.0001,
    //           "market-buy-order-must-less-than":  100,
    //       "market-sell-order-must-greater-than":  1,
    //          "market-sell-order-must-less-than":  500000,
    //           "circuit-break-when-greater-than":  10000,
    //              "circuit-break-when-less-than":  10,
    //     "market-sell-order-rate-must-less-than":  0.1,
    //      "market-buy-order-rate-must-less-than":  0.1        }
    //
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return map[string]interface{} {
        "info": limits,
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(limits, "limit-order-must-greater-than"),
                "max": this.SafeNumber(limits, "limit-order-must-less-than"),
            },
        },
    }
}
func  (this *huobijp) CostToPrecision(symbol interface{}, cost interface{}) interface{}  {
    return this.DecimalToPrecision(cost, TRUNCATE, GetValue(GetValue(GetValue(this.Markets, symbol), "precision"), "cost"), this.PrecisionMode)
}
/**
 * @method
 * @name huobijp#fetchMarkets
 * @description retrieves data on all markets for huobijp
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *huobijp) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var method interface{} = GetValue(this.Options, "fetchMarketsMethod")
        
            response:= (<-this.callDynamically(method, params))
            PanicOnError(response)
            //
            //    {
            //        "status": "ok",
            //        "data": [
            //            {
            //                "base-currency": "xrp",
            //                "quote-currency": "btc",
            //                "price-precision": 9,
            //                "amount-precision": 2,
            //                "symbol-partition": "default",
            //                "symbol": "xrpbtc",
            //                "state": "online",
            //                "value-precision": 8,
            //                "min-order-amt": 1,
            //                "max-order-amt": 5000000,
            //                "min-order-value": 0.0001,
            //                "limit-order-min-order-amt": 1,
            //                "limit-order-max-order-amt": 5000000,
            //                "limit-order-max-buy-amt": 5000000,
            //                "limit-order-max-sell-amt": 5000000,
            //                "sell-market-min-order-amt": 1,
            //                "sell-market-max-order-amt": 500000,
            //                "buy-market-max-order-value": 100,
            //                "leverage-ratio": 5,
            //                "super-margin-leverage-ratio": 3,
            //                "api-trading": "enabled",
            //                "tags": ""
            //            }
            //            ...
            //         ]
            //    }
            //
            var markets interface{} = this.SafeValue(response, "data", []interface{}{})
            var numMarkets interface{} =     GetArrayLength(markets)
            if IsTrue(IsLessThan(numMarkets, 1)) {
                panic(NetworkError(Add(Add(this.Id, " fetchMarkets() returned empty response: "), this.Json(markets))))
            }
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var baseId interface{} = this.SafeString(market, "base-currency")
                var quoteId interface{} = this.SafeString(market, "quote-currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var state interface{} = this.SafeString(market, "state")
                var leverageRatio interface{} = this.SafeString(market, "leverage-ratio", "1")
                var superLeverageRatio interface{} = this.SafeString(market, "super-margin-leverage-ratio", "1")
                var margin interface{} = IsTrue(Precise.StringGt(leverageRatio, "1")) || IsTrue(Precise.StringGt(superLeverageRatio, "1"))
                var fee interface{} = Ternary(IsTrue((IsEqual(base, "OMG"))), this.ParseNumber("0"), this.ParseNumber("0.002"))
                AppendToArray(&result,map[string]interface{} {
                    "id": Add(baseId, quoteId),
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": margin,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": (IsEqual(state, "online")),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": fee,
                    "maker": fee,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price-precision"))),
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount-precision"))),
                        "cost": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "value-precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.ParseNumber("1"),
                            "max": this.ParseNumber(leverageRatio),
                            "superMax": this.ParseNumber(superLeverageRatio),
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "min-order-amt"),
                            "max": this.SafeNumber(market, "max-order-amt"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "min-order-value"),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "amount": 26228.672978342216,
    //         "open": 9078.95,
    //         "close": 9146.86,
    //         "high": 9155.41,
    //         "id": 209988544334,
    //         "count": 265846,
    //         "low": 8988.0,
    //         "version": 209988544334,
    //         "ask": [ 9146.87, 0.156134 ],
    //         "vol": 2.3822168242201668E8,
    //         "bid": [ 9146.86, 0.080758 ],
    //     }
    //
    // fetchTickers
    //     {
    //         "symbol": "bhdht",
    //         "open":  2.3938,
    //         "high":  2.4151,
    //         "low":  2.3323,
    //         "close":  2.3909,
    //         "amount":  628.992,
    //         "vol":  1493.71841095,
    //         "count":  2088,
    //         "bid":  2.3643,
    //         "bidSize":  0.7136,
    //         "ask":  2.4061,
    //         "askSize":  0.4156
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeInteger(ticker, "ts")
    var bid interface{} = nil
    var bidVolume interface{} = nil
    var ask interface{} = nil
    var askVolume interface{} = nil
    if IsTrue(InOp(ticker, "bid")) {
        if IsTrue(IsArray(GetValue(ticker, "bid"))) {
            bid = this.SafeString(GetValue(ticker, "bid"), 0)
            bidVolume = this.SafeString(GetValue(ticker, "bid"), 1)
        } else {
            bid = this.SafeString(ticker, "bid")
            bidVolume = this.SafeString(ticker, "bidSize")
        }
    }
    if IsTrue(InOp(ticker, "ask")) {
        if IsTrue(IsArray(GetValue(ticker, "ask"))) {
            ask = this.SafeString(GetValue(ticker, "ask"), 0)
            askVolume = this.SafeString(GetValue(ticker, "ask"), 1)
        } else {
            ask = this.SafeString(ticker, "ask")
            askVolume = this.SafeString(ticker, "askSize")
        }
    }
    var open interface{} = this.SafeString(ticker, "open")
    var close interface{} = this.SafeString(ticker, "close")
    var baseVolume interface{} = this.SafeString(ticker, "amount")
    var quoteVolume interface{} = this.SafeString(ticker, "vol")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": bid,
        "bidVolume": bidVolume,
        "ask": ask,
        "askVolume": askVolume,
        "vwap": nil,
        "open": open,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name huobijp#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *huobijp) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes459891 := (<-this.LoadMarkets())
            PanicOnError(retRes459891)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": "step0",
            }
        
            response:= (<-this.MarketGetDepth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.depth.step0",
            //         "ts": 1583474832790,
            //         "tick": {
            //             "bids": [
            //                 [ 9100.290000000000000000, 0.200000000000000000 ],
            //                 [ 9099.820000000000000000, 0.200000000000000000 ],
            //                 [ 9099.610000000000000000, 0.205000000000000000 ],
            //             ],
            //             "asks": [
            //                 [ 9100.640000000000000000, 0.005904000000000000 ],
            //                 [ 9101.010000000000000000, 0.287311000000000000 ],
            //                 [ 9101.030000000000000000, 0.012121000000000000 ],
            //             ],
            //             "ts":1583474832008,
            //             "version":104999698780
            //         }
            //     }
            //
            if IsTrue(InOp(response, "tick")) {
                if !IsTrue(GetValue(response, "tick")) {
                    panic(BadSymbol(Add(Add(this.Id, " fetchOrderBook() returned empty response: "), this.Json(response))))
                }
                var tick interface{} = this.SafeValue(response, "tick")
                var timestamp interface{} = this.SafeInteger(tick, "ts", this.SafeInteger(response, "ts"))
                var result interface{} = this.ParseOrderBook(tick, symbol, timestamp)
                AddElementToObject(result, "nonce", this.SafeInteger(tick, "version"))
        
                ch <- result
                return nil
            }
            panic(ExchangeError(Add(Add(this.Id, " fetchOrderBook() returned unrecognized response: "), this.Json(response))))
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *huobijp) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes901890 := (<-this.LoadMarkets())
            PanicOnError(retRes901890)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.MarketGetDetailMerged(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.detail.merged",
            //         "ts": 1583494336669,
            //         "tick": {
            //             "amount": 26228.672978342216,
            //             "open": 9078.95,
            //             "close": 9146.86,
            //             "high": 9155.41,
            //             "id": 209988544334,
            //             "count": 265846,
            //             "low": 8988.0,
            //             "version": 209988544334,
            //             "ask": [ 9146.87, 0.156134 ],
            //             "vol": 2.3822168242201668E8,
            //             "bid": [ 9146.86, 0.080758 ],
            //         }
            //     }
            //
            var ticker interface{} = this.ParseTicker(GetValue(response, "tick"), market)
            var timestamp interface{} = this.SafeInteger(response, "ts")
            AddElementToObject(ticker, "timestamp", timestamp)
            AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
        
            ch <- ticker
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *huobijp) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes590145 := (<-this.LoadMarkets())
            PanicOnError(retRes590145)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.MarketGetTickers(params))
            PanicOnError(response)
            var tickers interface{} = this.SafeValue(response, "data", []interface{}{})
            var timestamp interface{} = this.SafeInteger(response, "ts")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var marketId interface{} = this.SafeString(GetValue(tickers, i), "symbol")
                var market interface{} = this.SafeMarket(marketId)
                var symbol interface{} = GetValue(market, "symbol")
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i), market)
                AddElementToObject(ticker, "timestamp", timestamp)
                AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "amount": 0.010411000000000000,
    //         "trade-id": 102090736910,
    //         "ts": 1583497692182,
    //         "id": 10500517034273194594947,
    //         "price": 9096.050000000000000000,
    //         "direction": "sell"
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //          "symbol": "swftcbtc",
    //          "fee-currency": "swftc",
    //          "filled-fees": "0",
    //          "source": "spot-api",
    //          "id": 83789509854000,
    //          "type": "buy-limit",
    //          "order-id": 83711103204909,
    //          'filled-points': "0.005826843283532154",
    //          "fee-deduct-currency": "ht",
    //          'filled-amount': "45941.53",
    //          "price": "0.0000001401",
    //          "created-at": 1597933260729,
    //          "match-id": 100087455560,
    //          "role": "maker",
    //          "trade-id": 100050305348
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeInteger2(trade, "ts", "created-at")
    var order interface{} = this.SafeString(trade, "order-id")
    var side interface{} = this.SafeString(trade, "direction")
    var typeVar interface{} = this.SafeString(trade, "type")
    if IsTrue(!IsEqual(typeVar, nil)) {
        var typeParts interface{} = Split(typeVar, "-")
        side = GetValue(typeParts, 0)
        typeVar = GetValue(typeParts, 1)
    }
    var takerOrMaker interface{} = this.SafeString(trade, "role")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString2(trade, "filled-amount", "amount")
    var cost interface{} = Precise.StringMul(price, amount)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "filled-fees")
    var feeCurrency interface{} = this.SafeCurrencyCode(this.SafeString(trade, "fee-currency"))
    var filledPoints interface{} = this.SafeString(trade, "filled-points")
    if IsTrue(!IsEqual(filledPoints, nil)) {
        if IsTrue(IsTrue((IsEqual(feeCost, nil))) || IsTrue((Precise.StringEq(feeCost, "0.0")))) {
            feeCost = filledPoints
            feeCurrency = this.SafeCurrencyCode(this.SafeString(trade, "fee-deduct-currency"))
        }
    }
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    var tradeId interface{} = this.SafeString2(trade, "trade-id", "tradeId")
    var id interface{} = this.SafeString(trade, "id", tradeId)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "symbol": symbol,
        "order": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "type": typeVar,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    })
}
/**
 * @method
 * @name huobijp#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *huobijp) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes200280 := (<-this.LoadMarkets())
            PanicOnError(retRes200280)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrderOrdersIdMatchresults(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "data"), nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchMyTrades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *huobijp) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes476955 := (<-this.LoadMarkets())
            PanicOnError(retRes476955)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // 1-100 orders, default is 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start-time", since) // a date within 120 days from today
            }
        
            response:= (<-this.PrivateGetOrderMatchresults(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "data"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *huobijp) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, 1000)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes542179 := (<-this.LoadMarkets())
            PanicOnError(retRes542179)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 2000))
            }
        
            response:= (<-this.MarketGetHistoryTrade(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.trade.detail",
            //         "ts": 1583497692365,
            //         "data": [
            //             {
            //                 "id": 105005170342,
            //                 "ts": 1583497692182,
            //                 "data": [
            //                     {
            //                         "amount": 0.010411000000000000,
            //                         "trade-id": 102090736910,
            //                         "ts": 1583497692182,
            //                         "id": 10500517034273194594947,
            //                         "price": 9096.050000000000000000,
            //                         "direction": "sell"
            //                     }
            //                 ]
            //             },
            //             // ...
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var trades interface{} = this.SafeValue(GetValue(data, i), "data", []interface{}{})
                for j := 0; IsLessThan(j, GetArrayLength(trades)); j++ {
                    var trade interface{} = this.ParseTrade(GetValue(trades, j), market)
                    AppendToArray(&result,trade)
                }
            }
            result = this.SortBy(result, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(result, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "amount":1.2082,
    //         "open":0.025096,
    //         "close":0.025095,
    //         "high":0.025096,
    //         "id":1591515300,
    //         "count":6,
    //         "low":0.025095,
    //         "vol":0.0303205097
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "id"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "amount")}
}
/**
 * @method
 * @name huobijp#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *huobijp) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 1000)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes264825 := (<-this.LoadMarkets())
            PanicOnError(retRes264825)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 2000))
            }
        
            response:= (<-this.MarketGetHistoryKline(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.ethbtc.kline.1min",
            //         "ts":1591515374371,
            //         "data":[
            //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
            //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
            //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *huobijp) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes52262 := (<-this.LoadMarkets())
            PanicOnError(retRes52262)
        
            response:= (<-this.PrivateGetAccountAccounts(params))
            PanicOnError(response)
        
            ch <- GetValue(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *huobijp) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "language": GetValue(this.Options, "language"),
            }
        
            response:= (<-this.PublicGetSettingsCurrencys(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"ok",
            //         "data":[
            //             {
            //                 "currency-addr-with-tag":false,
            //                 "fast-confirms":12,
            //                 "safe-confirms":12,
            //                 "currency-type":"eth",
            //                 "quote-currency":true,
            //                 "withdraw-enable-timestamp":1609430400000,
            //                 "deposit-enable-timestamp":1609430400000,
            //                 "currency-partition":"all",
            //                 "support-sites":["OTC","INSTITUTION","MINEPOOL"],
            //                 "withdraw-precision":6,
            //                 "visible-assets-timestamp":1508839200000,
            //                 "deposit-min-amount":"1",
            //                 "withdraw-min-amount":"10",
            //                 "show-precision":"8",
            //                 "tags":"",
            //                 "weight":23,
            //                 "full-name":"Tether USDT",
            //                 "otc-enable":1,
            //                 "visible":true,
            //                 "white-enabled":false,
            //                 "country-disabled":false,
            //                 "deposit-enabled":true,
            //                 "withdraw-enabled":true,
            //                 "name":"usdt",
            //                 "state":"online",
            //                 "display-name":"USDT",
            //                 "suspend-withdraw-desc":null,
            //                 "withdraw-desc":"Minimum withdrawal amount: 10 USDT (ERC20). !>_<!To ensure the safety of your funds, your withdrawal request will be manually reviewed if your security strategy or password is changed. Please wait for phone calls or emails from our staff.!>_<!Please make sure that your computer and browser are secure and your information is protected from being tampered or leaked.",
            //                 "suspend-deposit-desc":null,
            //                 "deposit-desc":"Please dont deposit any other digital assets except USDT to the above address. Otherwise, you may lose your assets permanently. !>_<!Depositing to the above address requires confirmations of the entire network. It will arrive after 12 confirmations, and it will be available to withdraw after 12 confirmations. !>_<!Minimum deposit amount: 1 USDT. Any deposits less than the minimum will not be credited or refunded.!>_<!Your deposit address wont change often. If there are any changes, we will notify you via announcement or email.!>_<!Please make sure that your computer and browser are secure and your information is protected from being tampered or leaked.",
            //                 "suspend-visible-desc":null
            //             }
            //         ]
            //     }
            //
            var currencies interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeValue(currency, "name")
                var code interface{} = this.SafeCurrencyCode(id)
                var depositEnabled interface{} = this.SafeValue(currency, "deposit-enabled")
                var withdrawEnabled interface{} = this.SafeValue(currency, "withdraw-enabled")
                var countryDisabled interface{} = this.SafeValue(currency, "country-disabled")
                var visible interface{} = this.SafeBool(currency, "visible", false)
                var state interface{} = this.SafeString(currency, "state")
                var active interface{} = IsTrue(IsTrue(IsTrue(IsTrue(visible) && IsTrue(depositEnabled)) && IsTrue(withdrawEnabled)) && IsTrue((IsEqual(state, "online")))) && !IsTrue(countryDisabled)
                var name interface{} = this.SafeString(currency, "display-name")
                var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "withdraw-precision")))
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "type": "crypto",
            "name": name,
            "active": active,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "fee": nil,
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": precision,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(currency, "deposit-min-amount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "withdraw-min-amount"),
                    "max": nil,
                },
            },
            "info": currency,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(GetValue(response, "data"), "list", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = nil
        if IsTrue(InOp(result, code)) {
            account = GetValue(result, code)
        } else {
            account = this.Account()
        }
        if IsTrue(IsEqual(GetValue(balance, "type"), "trade")) {
            AddElementToObject(account, "free", this.SafeString(balance, "balance"))
        }
        if IsTrue(IsEqual(GetValue(balance, "type"), "frozen")) {
            AddElementToObject(account, "used", this.SafeString(balance, "balance"))
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name huobijp#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *huobijp) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes261736 := (<-this.LoadMarkets())
            PanicOnError(retRes261736)
        
            retRes694292 := (<-this.LoadAccounts())
            PanicOnError(retRes694292)
            var method interface{} = GetValue(this.Options, "fetchBalanceMethod")
            var request interface{} = map[string]interface{} {
                "id": GetValue(GetValue(this.Accounts, 0), "id"),
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) FetchOrdersByStates(states interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes25749 := (<-this.LoadMarkets())
            PanicOnError(retRes25749)
            var request interface{} = map[string]interface{} {
                "states": states,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var method interface{} = this.SafeString(this.Options, "fetchOrdersByStatesMethod", "private_get_order_orders")
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     { "status":   "ok",
            //         "data": [ {                  id:  13997833014,
            //                                "symbol": "ethbtc",
            //                          "account-id":  3398321,
            //                                "amount": "0.045000000000000000",
            //                                 "price": "0.034014000000000000",
            //                          "created-at":  1545836976871,
            //                                  "type": "sell-limit",
            //                        "field-amount": "0.045000000000000000",
            //                   "field-cash-amount": "0.001530630000000000",
            //                          "field-fees": "0.000003061260000000",
            //                         "finished-at":  1545837948214,
            //                                "source": "spot-api",
            //                                 "state": "filled",
            //                         "canceled-at":  0                      }  ] }
            //
        ch <- this.ParseOrders(GetValue(response, "data"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchOrder
 * @description fetches information on an order made by the user
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes342830 := (<-this.LoadMarkets())
            PanicOnError(retRes342830)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrderOrdersId(this.Extend(request, params)))
            PanicOnError(response)
            var order interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes718428 :=  (<-this.FetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled", symbol, since, limit, params))
                PanicOnError(retRes718428)
                ch <- retRes718428
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var method interface{} = this.SafeString(this.Options, "fetchOpenOrdersMethod", "fetch_open_orders_v1")
        
                retRes951500 :=  (<-this.callDynamically(method, symbol, since, limit, params))
                PanicOnError(retRes951500)
                ch <- retRes951500
                return nil
        
            }()
            return ch
        }
func  (this *huobijp) FetchOpenOrdersV1(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrdersV1() requires a symbol argument")))
            }
        
                retRes873779 :=  (<-this.FetchOrdersByStates("pre-submitted,submitted,partial-filled", symbol, since, limit, params))
                PanicOnError(retRes873779)
                ch <- retRes873779
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes105571 :=  (<-this.FetchOrdersByStates("filled,partial-canceled,canceled", symbol, since, limit, params))
                PanicOnError(retRes105571)
                ch <- retRes105571
                return nil
        
            }()
            return ch
        }
func  (this *huobijp) FetchOpenOrdersV2(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes547766 := (<-this.LoadMarkets())
            PanicOnError(retRes547766)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var accountId interface{} = this.SafeString(params, "account-id")
            if IsTrue(IsEqual(accountId, nil)) {
                // pick the first account
        
                retRes351903 := (<-this.LoadAccounts())
                PanicOnError(retRes351903)
                for i := 0; IsLessThan(i, GetArrayLength(this.Accounts)); i++ {
                    var account interface{} = GetValue(this.Accounts, i)
                    if IsTrue(IsEqual(GetValue(account, "type"), "spot")) {
                        accountId = this.SafeString(account, "id")
                        if IsTrue(!IsEqual(accountId, nil)) {
                            break
                        }
                    }
                }
            }
            AddElementToObject(request, "account-id", accountId)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
            var omitted interface{} = this.Omit(params, "account-id")
        
            response:= (<-this.PrivateGetOrderOpenOrders(this.Extend(request, omitted)))
            PanicOnError(response)
            //
            //     {
            //         "status":"ok",
            //         "data":[
            //             {
            //                 "symbol":"ethusdt",
            //                 "source":"api",
            //                 "amount":"0.010000000000000000",
            //                 "account-id":1528640,
            //                 "created-at":1561597491963,
            //                 "price":"400.000000000000000000",
            //                 "filled-amount":"0.0",
            //                 "filled-cash-amount":"0.0",
            //                 "filled-fees":"0.0",
            //                 "id":38477101630,
            //                 "state":"submitted",
            //                 "type":"sell-limit"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "partial-filled": "open",
        "partial-canceled": "canceled",
        "filled": "closed",
        "canceled": "canceled",
        "submitted": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *huobijp) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {                  id:  13997833014,
    //                    "symbol": "ethbtc",
    //              "account-id":  3398321,
    //                    "amount": "0.045000000000000000",
    //                     "price": "0.034014000000000000",
    //              "created-at":  1545836976871,
    //                      "type": "sell-limit",
    //            "field-amount": "0.045000000000000000", // they have fixed it for filled-amount
    //       "field-cash-amount": "0.001530630000000000", // they have fixed it for filled-cash-amount
    //              "field-fees": "0.000003061260000000", // they have fixed it for filled-fees
    //             "finished-at":  1545837948214,
    //                    "source": "spot-api",
    //                     "state": "filled",
    //             "canceled-at":  0                      }
    //
    //     {                  id:  20395337822,
    //                    "symbol": "ethbtc",
    //              "account-id":  5685075,
    //                    "amount": "0.001000000000000000",
    //                     "price": "0.0",
    //              "created-at":  1545831584023,
    //                      "type": "buy-market",
    //            "field-amount": "0.029100000000000000", // they have fixed it for filled-amount
    //       "field-cash-amount": "0.000999788700000000", // they have fixed it for filled-cash-amount
    //              "field-fees": "0.000058200000000000", // they have fixed it for filled-fees
    //             "finished-at":  1545831584181,
    //                    "source": "spot-api",
    //                     "state": "filled",
    //             "canceled-at":  0                      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var side interface{} = nil
    var typeVar interface{} = nil
    var status interface{} = nil
    if IsTrue(InOp(order, "type")) {
        var orderType interface{} = Split(GetValue(order, "type"), "-")
        side = GetValue(orderType, 0)
        typeVar = GetValue(orderType, 1)
        status = this.ParseOrderStatus(this.SafeString(order, "state"))
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(order, "created-at")
    var clientOrderId interface{} = this.SafeString(order, "client-order-id")
    var amount interface{} = this.SafeString(order, "amount")
    var filled interface{} = this.SafeString2(order, "filled-amount", "field-amount") // typo in their API, filled amount
    var price interface{} = this.SafeString(order, "price")
    var cost interface{} = this.SafeString2(order, "filled-cash-amount", "field-cash-amount") // same typo
    var feeCost interface{} = this.SafeString2(order, "filled-fees", "field-fees") // typo in their API, filled fees
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrency interface{} = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "average": nil,
        "cost": cost,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name huobijp#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes442496 := (<-this.LoadMarkets())
            PanicOnError(retRes442496)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes784430 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes784430)
                ch <- retRes784430
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#createOrder
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes642146 := (<-this.LoadMarkets())
            PanicOnError(retRes642146)
        
            retRes747326 := (<-this.LoadAccounts())
            PanicOnError(retRes747326)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "account-id": GetValue(GetValue(this.Accounts, 0), "id"),
                "symbol": GetValue(market, "id"),
                "type": Add(Add(side, "-"), typeVar),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client-order-id") // must be 64 chars max and unique within 24 hours
            if IsTrue(IsEqual(clientOrderId, nil)) {
                var broker interface{} = this.SafeValue(this.Options, "broker", map[string]interface{} {})
                var brokerId interface{} = this.SafeString(broker, "id")
                AddElementToObject(request, "client-order-id", Add(brokerId, this.Uuid()))
            } else {
                AddElementToObject(request, "client-order-id", clientOrderId)
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "client-order-id"})
            if IsTrue(IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))) {
                var quoteAmount interface{} = nil
                var createMarketBuyOrderRequiresPrice interface{} = true
                createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                var cost interface{} = this.SafeNumber(params, "cost")
                params = this.Omit(params, "cost")
                if IsTrue(!IsEqual(cost, nil)) {
                    quoteAmount = this.AmountToPrecision(symbol, cost)
                } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                    if IsTrue(IsEqual(price, nil)) {
                        panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                    } else {
                        // despite that cost = amount * price is in quote currency and should have quote precision
                        // the exchange API requires the cost supplied in 'amount' to be of base precision
                        // more about it here:
                        // https://github.com/ccxt/ccxt/pull/4395
                        // https://github.com/ccxt/ccxt/issues/7611
                        // we use amountToPrecision here because the exchange requires cost in base precision
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        quoteAmount = this.AmountToPrecision(symbol, Precise.StringMul(amountString, priceString))
                    }
                } else {
                    quoteAmount = this.AmountToPrecision(symbol, amount)
                }
                AddElementToObject(request, "amount", quoteAmount)
            } else {
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "limit")) || IsTrue(IsEqual(typeVar, "ioc"))) || IsTrue(IsEqual(typeVar, "limit-maker"))) || IsTrue(IsEqual(typeVar, "stop-limit"))) || IsTrue(IsEqual(typeVar, "stop-limit-fok"))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var method interface{} = GetValue(this.Options, "createOrderMethod")
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
            var id interface{} = this.SafeString(response, "data")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": id,
                "timestamp": nil,
                "datetime": nil,
                "lastTradeTimestamp": nil,
                "status": nil,
                "symbol": symbol,
                "type": typeVar,
                "side": side,
                "price": price,
                "amount": amount,
                "filled": nil,
                "remaining": nil,
                "cost": nil,
                "trades": nil,
                "fee": nil,
                "clientOrderId": nil,
                "average": nil,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#cancelOrder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol not used by huobijp cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivatePostOrderOrdersIdSubmitcancel(map[string]interface{} {
            "id": id,
        }))
            PanicOnError(response)
        
                //
            //     {
            //         "status": "ok",
            //         "data": "10138899000",
            //     }
            //
        ch <- this.Extend(this.ParseOrder(response), map[string]interface{} {
                "id": id,
                "status": "canceled",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#cancelOrders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol not used by huobijp cancelOrders ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes425963 := (<-this.LoadMarkets())
            PanicOnError(retRes425963)
            var clientOrderIds interface{} = this.SafeValue2(params, "clientOrderIds", "client-order-ids")
            params = this.Omit(params, []interface{}{"clientOrderIds", "client-order-ids"})
            var request interface{} = map[string]interface{} {}
            if IsTrue(IsEqual(clientOrderIds, nil)) {
                AddElementToObject(request, "order-ids", ids)
            } else {
                AddElementToObject(request, "client-order-ids", clientOrderIds)
            }
        
            response:= (<-this.PrivatePostOrderOrdersBatchcancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "status": "ok",
            //         "data": {
            //             "success": [
            //                 "5983466"
            //             ],
            //             "failed": [
            //                 {
            //                     "err-msg": "Incorrect order state",
            //                     "order-state": 7,
            //                     "order-id": "",
            //                     "err-code": "order-orderstate-error",
            //                     "client-order-id": "first"
            //                 },
            //                 {
            //                     "err-msg": "Incorrect order state",
            //                     "order-state": 7,
            //                     "order-id": "",
            //                     "err-code": "order-orderstate-error",
            //                     "client-order-id": "second"
            //                 },
            //                 {
            //                     "err-msg": "The record is not found.",
            //                     "order-id": "",
            //                     "err-code": "base-not-found",
            //                     "client-order-id": "third"
            //                 }
            //             ]
            //         }
            //     }
            //
        ch <- this.ParseCancelOrders(response)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseCancelOrders(orders interface{}) interface{}  {
    //
    //    {
    //        "success": [
    //            "5983466"
    //        ],
    //        "failed": [
    //            {
    //                "err-msg": "Incorrect order state",
    //                "order-state": 7,
    //                "order-id": "",
    //                "err-code": "order-orderstate-error",
    //                "client-order-id": "first"
    //            },
    //            ...
    //        ]
    //    }
    //
    //    {
    //        "errors": [
    //            {
    //                "order_id": "769206471845261312",
    //                "err_code": 1061,
    //                "err_msg": "This order doesnt exist."
    //            }
    //        ],
    //        "successes": "1258075374411399168,1258075393254871040"
    //    }
    //
    var successes interface{} = this.SafeString(orders, "successes")
    var success interface{} = nil
    if IsTrue(!IsEqual(successes, nil)) {
        success = Split(successes, ",")
    } else {
        success = this.SafeList(orders, "success", []interface{}{})
    }
    var failed interface{} = this.SafeList2(orders, "errors", "failed", []interface{}{})
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(success)); i++ {
        var order interface{} = GetValue(success, i)
        AppendToArray(&result,this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": order,
            "status": "canceled",
        }))
    }
    for i := 0; IsLessThan(i, GetArrayLength(failed)); i++ {
        var order interface{} = GetValue(failed, i)
        AppendToArray(&result,this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": this.SafeString2(order, "order-id", "order_id"),
            "status": "failed",
            "clientOrderId": this.SafeString(order, "client-order-id"),
        }))
    }
    return result
}
/**
 * @method
 * @name huobijp#cancelAllOrders
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *huobijp) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes246018 := (<-this.LoadMarkets())
            PanicOnError(retRes246018)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostOrderOrdersBatchCancelOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 200,
            //         "data": {
            //             "success-count": 2,
            //             "failed-count": 0,
            //             "next-id": 5454600
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": data,
        })}
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "currency": "usdt",
    //         "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
    //         "addressTag": "",
    //         "chain": "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var tag interface{} = this.SafeString(depositAddress, "addressTag")
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    currency = this.SafeCurrency(currencyId, currency)
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var networkId interface{} = this.SafeString(depositAddress, "chain")
    var networks interface{} = this.SafeValue(currency, "networks", map[string]interface{} {})
    var networksById interface{} = this.IndexBy(networks, "id")
    var networkValue interface{} = this.SafeValue(networksById, networkId, networkId)
    var network interface{} = this.SafeString(networkValue, "network")
    this.CheckAddress(address)
    return map[string]interface{} {
        "currency": code,
        "address": address,
        "tag": tag,
        "network": network,
        "info": depositAddress,
    }
}
/**
 * @method
 * @name huobijp#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *huobijp) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsTrue(IsEqual(limit, nil)) || IsTrue(IsGreaterThan(limit, 100))) {
                limit = 100
            }
        
            retRes134804 := (<-this.LoadMarkets())
            PanicOnError(retRes134804)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {
                "type": "deposit",
                "from": 0,
            }
            if IsTrue(!IsEqual(currency, nil)) {
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // max 100
            }
        
            response:= (<-this.PrivateGetQueryDepositWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                // return response
        ch <- this.ParseTransactions(GetValue(response, "data"), currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name huobijp#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *huobijp) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsTrue(IsEqual(limit, nil)) || IsTrue(IsGreaterThan(limit, 100))) {
                limit = 100
            }
        
            retRes555130 := (<-this.LoadMarkets())
            PanicOnError(retRes555130)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {
                "type": "withdraw",
                "from": 0,
            }
            if IsTrue(!IsEqual(currency, nil)) {
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // max 100
            }
        
            response:= (<-this.PrivateGetQueryDepositWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                // return response
        ch <- this.ParseTransactions(GetValue(response, "data"), currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "id": 8211029,
    //         "type": "deposit",
    //         "currency": "eth",
    //         "chain": "eth",
    //         'tx-hash': "bd315....",
    //         "amount": 0.81162421,
    //         "address": "4b8b....",
    //         'address-tag": '",
    //         "fee": 0,
    //         "state": "safe",
    //         "created-at": 1542180380965,
    //         "updated-at": 1542180788077
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "id": 6908275,
    //         "type": "withdraw",
    //         "currency": "btc",
    //         "chain": "btc",
    //         'tx-hash': "c1a1a....",
    //         "amount": 0.80257005,
    //         "address": "1QR....",
    //         'address-tag": '",
    //         "fee": 0.0005,
    //         "state": "confirmed",
    //         "created-at": 1552107295685,
    //         "updated-at": 1552108032859
    //     }
    //
    // withdraw
    //
    //     {
    //         "status": "ok",
    //         "data": "99562054"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transaction, "created-at")
    var code interface{} = this.SafeCurrencyCode(this.SafeString(transaction, "currency"))
    var typeVar interface{} = this.SafeString(transaction, "type")
    if IsTrue(IsEqual(typeVar, "withdraw")) {
        typeVar = "withdrawal"
    }
    var feeCost interface{} = this.SafeString(transaction, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        feeCost = Precise.StringAbs(feeCost)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "id", "data"),
        "txid": this.SafeString(transaction, "tx-hash"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.SafeStringUpper(transaction, "chain"),
        "address": this.SafeString(transaction, "address"),
        "addressTo": nil,
        "addressFrom": nil,
        "tag": this.SafeString(transaction, "address-tag"),
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "state")),
        "updated": this.SafeInteger(transaction, "updated-at"),
        "comment": nil,
        "internal": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(feeCost),
            "rate": nil,
        },
    }
}
func  (this *huobijp) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "unknown": "failed",
        "confirming": "pending",
        "confirmed": "ok",
        "safe": "ok",
        "orphan": "failed",
        "submitted": "pending",
        "canceled": "canceled",
        "reexamine": "pending",
        "reject": "failed",
        "pass": "pending",
        "wallet-reject": "failed",
        "confirm-error": "failed",
        "repealed": "failed",
        "wallet-transfer": "pending",
        "pre-transfer": "pending",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name huobijp#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *huobijp) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes154084 := (<-this.LoadMarkets())
            PanicOnError(retRes154084)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "address": address,
                "amount": amount,
                "currency": ToLower(GetValue(currency, "id")),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "addr-tag", tag) // only for XRP?
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeStringLower(networks, network, network) // handle ETH>ERC20 alias
            if IsTrue(!IsEqual(network, nil)) {
                // possible chains - usdterc20, trc20usdt, hrc20usdt, usdt, algousdt
                if IsTrue(IsEqual(network, "erc20")) {
                    AddElementToObject(request, "chain", Add(GetValue(currency, "id"), network))
                } else {
                    AddElementToObject(request, "chain", Add(network, GetValue(currency, "id")))
                }
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivatePostDwWithdrawApiCreate(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "status": "ok",
            //         "data": "99562054"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *huobijp) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = "/"
    if IsTrue(IsEqual(api, "market")) {
        url = Add(url, api)
    } else if IsTrue(IsTrue((IsEqual(api, "public"))) || IsTrue((IsEqual(api, "private")))) {
        url = Add(url, this.Version)
    } else if IsTrue(IsTrue((IsEqual(api, "v2Public"))) || IsTrue((IsEqual(api, "v2Private")))) {
        url = Add(url, "v2")
    }
    url = Add(url, Add("/", this.ImplodeParams(path, params)))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsTrue(IsEqual(api, "private")) || IsTrue(IsEqual(api, "v2Private"))) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = this.Ymdhms(this.Milliseconds(), "T")
        var request interface{} = map[string]interface{} {
            "SignatureMethod": "HmacSHA256",
            "SignatureVersion": "2",
            "AccessKeyId": this.ApiKey,
            "Timestamp": timestamp,
        }
        if IsTrue(!IsEqual(method, "POST")) {
            request = this.Extend(request, query)
        }
        var requestSorted interface{} = this.Keysort(request)
        var auth interface{} = this.Urlencode(requestSorted)
        // unfortunately, PHP demands double quotes for the escaped newline symbol
        // eslint-disable-next-line quotes
        var payload interface{} = Join([]interface{}{method, this.Hostname, url, auth}, "\n")
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
        auth = Add(auth, Add("&", this.Urlencode(map[string]interface{} {
    "Signature": signature,
})))
        url = Add(url, Add("?", auth))
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(query)
            headers = map[string]interface{} {
                "Content-Type": "application/json",
            }
        } else {
            headers = map[string]interface{} {
                "Content-Type": "application/x-www-form-urlencoded",
            }
        }
    } else {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    url = Add(this.ImplodeParams(GetValue(GetValue(this.Urls, "api"), api), map[string]interface{} {
    "hostname": this.Hostname,
}), url)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *huobijp) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "status")) {
        //
        //     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
        //
        var status interface{} = this.SafeString(response, "status")
        if IsTrue(IsEqual(status, "error")) {
            var code interface{} = this.SafeString(response, "err-code")
            var feedback interface{} = Add(Add(this.Id, " "), body)
            this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
            var message interface{} = this.SafeString(response, "err-msg")
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}


func (this *huobijp) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
